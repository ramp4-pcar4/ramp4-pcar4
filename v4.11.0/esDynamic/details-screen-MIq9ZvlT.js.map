{"version":3,"file":"details-screen-MIq9ZvlT.js","sources":["../../src/fixtures/details/components/symbology-stack.vue","../../src/fixtures/details/components/symbology-item.vue","../../src/fixtures/details/components/symbology-list.vue","../../src/fixtures/details/templates/esri-default.vue","../../src/fixtures/details/templates/html-default.vue","../../src/fixtures/details/components/result-item.vue","../../src/fixtures/details/components/result-list.vue","../../src/fixtures/details/details-screen.vue"],"sourcesContent":["<template>\n    <div v-if=\"result.loaded\" class=\"relative\">\n        <div :class=\"result.items.length === 0 ? 'opacity-50' : ''\">\n            <!-- Multiple icons to display -->\n            <div v-if=\"stack.length > 1\" class=\"relative\">\n                <!-- the :class line calculates margin-left for each of the 3 symbols, and gives a margin-top to symbols that arent the first -->\n                <div\n                    class=\"absolute\"\n                    :class=\"[idx == 0 ? 'symbol-0' : idx == 1 ? 'left-3' : 'left-6']\"\n                    :style=\"{ 'z-index': 3 - idx }\"\n                    v-for=\"(item, idx) in stack.slice(0, 3).reverse()\"\n                    :key=\"idx\"\n                >\n                    <span v-if=\"stack[idx].svgcode\" class=\"symbologyIcon w-28 h-28\" v-html=\"stack[idx].svgcode\"></span>\n                    <img v-else-if=\"stack[idx].imgUrl\" class=\"symbologyIcon w-28 h-28\" :src=\"stack[idx].imgUrl\" />\n                </div>\n            </div>\n\n            <!-- Only one icon to display. -->\n            <div v-else-if=\"stack.length > 0\" class=\"w-32 h-32\">\n                <div class=\"symbologyIcon\">\n                    <span v-if=\"stack[0].svgcode\" v-html=\"stack[0].svgcode\"></span>\n                    <img v-else-if=\"stack[0].imgUrl\" class=\"symbologyIcon w-full h-full\" :src=\"stack[0].imgUrl\" />\n                </div>\n            </div>\n        </div>\n        <!-- result counter -->\n        <div class=\"badge z-50 rounded-full text-white absolute h-10 w-10 p-8 inline-flex items-center justify-center\">\n            <div v-if=\"result.loaded\" class=\"px-5\">\n                {{ result.items.length }}\n            </div>\n        </div>\n    </div>\n    <div v-else class=\"inline-flex justify-center items-center relative\">\n        <div class=\"symbologyIcon h-32 w-32\">\n            <div class=\"relative animate-spin spinner h-24 w-24\"></div>\n        </div>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\n// this renders the everything needed for a symbol stack running along the left side of the panel.\n// includes symbol stacking, loading spinners, result count badge\n\nimport type { LayerInstance } from '@/api';\n\nimport { onMounted, type PropType, ref } from 'vue';\n\nconst props = defineProps({\n    layer: { type: Object as PropType<LayerInstance>, required: true },\n    result: { type: Object as any, required: true }\n});\n\nconst stack = ref<any>([]); // ref instead of reactive to maintain reactivity after promise\n\nonMounted(() => {\n    stack.value = props.layer.legend;\n});\n</script>\n\n<style lang=\"scss\" scoped>\n.badge {\n    background-color: #576870;\n    bottom: -5px;\n    right: -5px;\n    font-size: 8px;\n}\n</style>\n","<template>\n    <button\n        class=\"flex flex-grow justify-start items-center px-7 py-10 default-focus-style symbologyStackButton truncate\"\n        :class=\"selected ? 'detailsButtonSelected' : 'px-11'\"\n        @click.stop=\"\"\n        :content=\"layerName()\"\n        v-tippy=\"{ placement: 'right', sticky: true }\"\n    >\n        <SymbologyStack class=\"symbStack w-32 h-32 mr-10\" :layer=\"layer\" :result=\"result\"></SymbologyStack>\n        <div class=\"symbologyLayerName truncate\">\n            {{ layerName() }}\n        </div>\n    </button>\n</template>\n\n<script setup lang=\"ts\">\n// this constructs an entire list item in the symbology-list\n// includes the symbology-stack, as well as fancy slideout magic to show\n// layer name when moused over\n\nimport { computed } from 'vue';\nimport SymbologyStack from './symbology-stack.vue';\nimport { useDetailsStore } from '../store';\n\nimport type { DetailsItemInstance } from '../store';\n\nconst detailsStore = useDetailsStore();\nconst detailProperties = computed<{ [id: string]: DetailsItemInstance }>(() => detailsStore.properties);\n\nconst props = defineProps({\n    layer: { type: Object as any, required: true },\n    result: { type: Object as any, required: true },\n    selected: { type: Boolean, required: true }\n});\n\n/**\n * Retrieve the layer name.\n */\nconst layerName = () => {\n    const layer = props.layer;\n    if (layer && detailProperties.value[layer.id] && detailProperties.value[layer.id].name) {\n        return detailProperties.value[layer.id].name;\n    }\n    return layer?.name ?? '';\n};\n</script>\n\n<style lang=\"scss\">\n.symbStack {\n    flex: 0 0 32px;\n}\n.detailsButtonSelected {\n    border-left: 3px solid #576870;\n    padding-left: 4px !important;\n}\n.symbologyStackButton {\n    transition: background 0.3s;\n}\n.symbologyStackButton:hover {\n    background: #eee;\n}\n.symbologyLayerName {\n    flex: 1 1 auto;\n    text-align: left;\n}\n\n.symbologyStackButton:focus {\n    outline: 2px solid black;\n    z-index: 1;\n}\n</style>\n","<template>\n    <div\n        class=\"symbology-list absolute overflow-hidden z-50 p-0 w-48 bg-white text-sm inline-flex flex-col\"\n        :class=\"{ 'symbology-list-expanded': expanded }\"\n        @mouseover=\"handleMouseOver\"\n        @mouseleave=\"handleMouseLeave\"\n        @focus=\"handleItemFocus\"\n        @blur.self=\"handleItemBlur\"\n        v-focus-list\n        :content=\"t('details.layers.results.list.tooltip')\"\n        v-tippy=\"{\n            trigger: 'manual',\n            placement: 'top-start',\n            touch: false\n        }\"\n        ref=\"el\"\n    >\n        <div class=\"flex justify-start relative\" v-for=\"(item, idx) in props.results\" :key=\"idx\">\n            <SymbologyItem\n                :key=\"item.uid\"\n                :layer=\"getLayerInfo(item.uid)\"\n                :result=\"item\"\n                :selected=\"item.uid === selectedLayer\"\n                @click=\"handleItemClick(item.uid)\"\n                v-focus-item\n            ></SymbologyItem>\n        </div>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\n// this renders the list of symbology items that run along the left side\n\nimport { ref, watch, onBeforeMount, onBeforeUnmount, onMounted } from 'vue';\nimport { useLayerStore } from '@/stores/layer';\n\nimport type { LayerInstance } from '@/api';\nimport { useI18n } from 'vue-i18n';\n\nimport SymbologyItem from './symbology-item.vue';\n\nconst { t } = useI18n();\nconst layerStore = useLayerStore();\n\nconst el = ref<Element>();\nconst blurEvent = () => {\n    (el.value as any)._tippy.hide();\n};\nconst keyupEvent = (e: Event) => {\n    const evt = e as KeyboardEvent;\n    if (evt.key === 'Tab' && el.value?.matches(':focus')) {\n        (el.value as any)._tippy.show();\n    }\n};\n\nconst emit = defineEmits(['selection-changed']);\nconst props = defineProps({\n    results: { type: Object as any, required: true },\n    selected: { type: String, required: true }\n});\n\n// Keep track of the currently selected layer index.\nconst selectedLayer = ref<string>('');\nconst watchers = ref<Array<() => void>>([]);\n\n// Expanded is true if the sidebar is expanded. Hovering is true only if the cursor is currently over the sidebar.\nconst expanded = ref<boolean>(false);\nconst hovering = ref<boolean>(false);\n\n/**\n * Return the LayerInstance that cooresponds with the provided UID.\n * @param uid the UID of the layer to look up.\n */\nconst getLayerInfo = (uid: string) => {\n    const layer: LayerInstance | undefined = layerStore.getLayerByUid(uid);\n    return layer;\n};\n\n/**\n * Handles when a user clicks on an item.\n * @param uid the UID of the clicked layer\n */\nconst handleItemClick = (uid: string) => {\n    selectedLayer.value = uid;\n    emit('selection-changed', uid);\n\n    // Close the sidebar when an item is clicked.\n    expanded.value = false;\n};\n\n/**\n * Handles when a user moves their mouse over the sidebar.\n */\nconst handleMouseOver = () => {\n    if (!hovering.value) {\n        // If not already hovering, delay expansion of the sidebar for 500ms.\n        setTimeout(() => {\n            expanded.value = hovering.value;\n        }, 500);\n    }\n\n    hovering.value = true;\n};\n\n/**\n * Handles when the user moves their mouse away from the sidebar.\n */\nconst handleMouseLeave = () => {\n    expanded.value = hovering.value = false;\n};\n\n/**\n * Activates when an item in the list is focused.\n */\nconst handleItemFocus = () => {\n    if (!hovering.value) {\n        expanded.value = true;\n    }\n    hovering.value = true;\n};\n\n/**\n * Activates when an item in the list is unfocused.\n */\nconst handleItemBlur = () => {\n    expanded.value = hovering.value = false;\n};\n\nonBeforeMount(() => {\n    // keep track of this watcher because it needs to be removed when this component is unmounted\n    watchers.value.push(\n        watch(props, () => {\n            // Something has changed, so re-fetch the icon.\n            selectedLayer.value = props.selected;\n        })\n    );\n});\n\nonMounted(() => {\n    el.value?.addEventListener('blur', blurEvent);\n    el.value?.addEventListener('keyup', keyupEvent);\n});\n\nonBeforeUnmount(() => {\n    watchers.value.forEach(unwatch => unwatch());\n\n    el.value?.removeEventListener('blur', blurEvent);\n    el.value?.removeEventListener('keyup', keyupEvent);\n});\n</script>\n\n<style lang=\"scss\">\n.symbology-list {\n    /** fun magic to get the bar to take up the entire height */\n    height: auto;\n    top: 0px;\n    bottom: -8px;\n\n    border-right: 1px solid #eee;\n    box-shadow: -1px 0px 5px rgba(0, 0, 0, 0.5);\n\n    margin: -8px;\n    margin-bottom: 0px;\n\n    transition: all 0.3s cubic-bezier(0.35, 0, 0.25, 1);\n}\n.symbology-list-expanded {\n    width: 70% !important;\n    overflow-y: auto !important;\n}\n</style>\n","<template>\n    <div>\n        <div\n            class=\"p-5 pl-3 flex justify-end flex-wrap even:bg-gray-300\"\n            v-for=\"(val, name, itemIdx) in itemData()\"\n            :key=\"itemIdx\"\n        >\n            <span class=\"inline font-bold\">{{ val.alias }}</span>\n            <span class=\"flex-auto\"></span>\n            <span class=\"inline\" v-html=\"formatValues(val.value, val.alias, val.type)\"></span>\n        </div>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { inject } from 'vue';\nimport type { PropType } from 'vue';\nimport type { FieldDefinition } from '@/geo/api';\nimport type { DetailsFieldItem } from '@/fixtures/details/store';\nimport linkifyHtml from 'linkify-html';\nimport type { IdentifyItem, InstanceAPI } from '@/api';\nimport { useI18n } from 'vue-i18n';\n\nconst { t } = useI18n();\n\nconst iApi = inject<InstanceAPI>('iApi');\n\nconst props = defineProps({\n    fixtureFields: {\n        type: Object as PropType<Array<DetailsFieldItem>>,\n        required: false\n    },\n    fields: {\n        type: Object as PropType<Array<FieldDefinition>>,\n        required: true\n    },\n    identifyData: {\n        type: Object as PropType<IdentifyItem>,\n        required: true\n    }\n});\n\nconst findAndDelete = (fields: FieldDefinition[], propertyType: 'type' | 'name', property: string, helper: any) => {\n    const field = fields.find(f => f[propertyType].toLowerCase() === property.toLowerCase());\n\n    // If the field is found, delete it from the helper object\n    if (field) delete helper[field.name];\n};\n\n/**\n * Constructs and returns a metadata mapping of what we actually want to display.\n * Key: field name\n * Value: object with these props\n * - value (formatted)\n * - alias (display text for field. See aliases.name below)\n * - type (field data type)\n */\nconst itemData = () => {\n    const clonePayload = Object.assign({}, props.identifyData.data);\n\n    // Remove any fields of type geometry\n    findAndDelete(props.fields, 'type', 'geometry', clonePayload);\n\n    if (!iApi?.ui.exposeOids) {\n        // check global oid flag\n        findAndDelete(props.fields, 'type', 'oid', clonePayload);\n    }\n\n    if (!iApi?.ui.exposeMeasurements) {\n        // check global measurements flag\n        findAndDelete(props.fields, 'name', 'shape_length', clonePayload);\n        findAndDelete(props.fields, 'name', 'shape_area', clonePayload);\n    }\n\n    /**\n     * Builds up a mapping of all LAYER field names --> data about field\n     * - name (display name. Priority order: detail fixture config alias, layer alias, layer field)\n     * - type (field data type)\n     * - visible (if should be displayed; detail fixture config option)\n     */\n    const fieldsMetadata: any = {};\n    props.fields.forEach(field => {\n        // Check to see if this field is being overwritten in the fixture config.\n        const checkField = props.fixtureFields?.find(item => field.name === item.field);\n\n        fieldsMetadata[field.name] = {\n            name: checkField?.alias || field.alias || field.name,\n            type: field.type,\n            visible: checkField?.visible ?? true\n        }; // use the key name if alias is not defined. Default visibility to true if it's not defined.\n    });\n\n    /**\n     * Builds up a mapping of valid PAYLOAD attribute field names --> data about that attribute\n     * - value (formatted)\n     * - alias (display text for field. See aliases.name below)\n     * - type (field data type)\n     *\n     * Invalid fields are: ones the system is hiding, and ones that don't exist on the layer\n     */\n    const displayMetadata: any = {};\n\n    // we iterate on the clone since that is what had the field removals.\n    Object.keys(clonePayload).forEach(key => {\n        const fieldMD = fieldsMetadata[key];\n        if (fieldMD && fieldMD.visible) {\n            // field exists in layer, and should be shown\n\n            const cloneValue = clonePayload[key];\n\n            displayMetadata[key] = {\n                value: typeof cloneValue === 'number' ? iApi?.ui.formatNumber(cloneValue) : cloneValue,\n                alias: fieldMD.name,\n                type: fieldMD.type\n            };\n        }\n    });\n\n    for (const [key] of Object.entries(displayMetadata)) {\n        // only replace html special chars if string represents plain text\n        if (iApi!.ui.isPlainText(displayMetadata[key].value)) {\n            displayMetadata[key].value = iApi!.ui.escapeHtml(displayMetadata[key].value);\n        }\n    }\n\n    return displayMetadata;\n};\n\n// render value based on type\nconst formatValues = (html: string, alias: string, type: string): string => {\n    switch (type) {\n        case 'date':\n            return makeDate(html);\n        default:\n            return makeHtmlLink(html, alias);\n    }\n};\n\n// make links look like links and work like links\nconst makeHtmlLink = (html: string, alias: string): string => {\n    if (!html) {\n        return html;\n    }\n\n    // Check to see if url is a valid image / data url based on extension type or format\n    if (\n        !!html.trim().match(/\\.(jpeg|jpg|gif|png)$/) ||\n        !!html\n            .trim()\n            .match(\n                /^\\s*data:([a-z]+\\/[a-z]+(;[a-z\\-]+\\=[a-z\\-]+)?)?(;base64)?,[a-z0-9\\!\\$\\&\\'\\,\\(\\)\\*\\+\\,\\;\\=\\-\\.\\_\\~\\:\\@\\/\\?\\%\\s]*\\s*$/i\n            )\n    ) {\n        return `<img src=\"${html}\" alt=\"${t('details.item.alert.defaultAltText', { alias: alias })}\" />`;\n    }\n\n    const classes = 'underline text-blue-700 break-all';\n    const div = document.createElement('div');\n    div.innerHTML = html.trim();\n\n    // check if the html string is just an <a> tag\n    if (div.firstElementChild?.tagName == 'A') {\n        div.firstElementChild.className = classes;\n        return div.innerHTML;\n    } else {\n        // otherwise, look for any valid links\n        const options = {\n            className: classes,\n            target: '_blank',\n            validate: {\n                url: (value: string) => /^https?:\\/\\//.test(value) // only links that begin with a protocol will be hyperlinked\n            }\n        };\n        return linkifyHtml(html, options);\n    }\n};\n\n// convert timestamps into date strings that match the datagrid\nconst makeDate = (html: string): string => {\n    // the value is saved as a string, so attempt to convert it to a number\n    const numericDate = parseInt(html);\n\n    // if the date can't be converted to a number, then it may already be formatted. Display it as it is.\n    if (isNaN(numericDate)) {\n        return html;\n    }\n\n    // Return in YYYY-MM-DD format\n    const formattedDate = new Date(numericDate);\n    return formattedDate.toISOString().split('T')[0];\n};\n</script>\n\n<style lang=\"scss\"></style>\n","<template>\n    <div\n        class=\"whitespace-pre-wrap break-words h-full overflow-auto\"\n        v-if=\"identifyData\"\n        v-html=\"identifyData.data.data ?? identifyData.data\"\n    ></div>\n    <div v-else>{{ t('details.layers.results.empty') }}</div>\n</template>\n\n<script setup lang=\"ts\">\nimport type { PropType } from 'vue';\nimport type { IdentifyItem } from '@/api';\nimport { useI18n } from 'vue-i18n';\n\nconst { t } = useI18n();\n\ndefineProps({\n    identifyData: {\n        type: Object as PropType<IdentifyItem>,\n        required: true\n    }\n});\n</script>\n\n<style lang=\"scss\"></style>\n","<template>\n    <!-- Header including icon, name, zoom button -->\n    <div class=\"relative flex flex-grow truncate\">\n        <div class=\"flex flex-grow items-center truncate\" v-if=\"supportsFeatures\">\n            <!-- display symbol if it has loaded, otherwise display a loading spinner -->\n            <div class=\"flex p-8 items-center\">\n                <span v-if=\"data.loaded && icon\" class=\"flex-none symbologyIcon\" v-html=\"icon\"></span>\n                <div class=\"symbologyIcon p-6\" v-else>\n                    <div class=\"animate-spin spinner h-20 w-20\"></div>\n                </div>\n            </div>\n\n            <!-- display name of the data point -->\n            <span\n                v-if=\"data.loaded\"\n                class=\"pl-3 text-left flex-grow itemName\"\n                :content=\"itemName\"\n                v-html=\"makeHtmlLink(itemName)\"\n                @touchstart=\"isTouch = true\"\n                @touchend=\"isTouch = false\"\n                v-truncate=\"{\n                    options: {\n                        placement: 'top-start',\n                        // Offset more for touch devices so tooltip is visible above finger\n                        offset: () => (isTouch ? [0, 25] : [0, 0])\n                    }\n                }\"\n                :tabindex=\"inList ? -1 : 0\"\n            ></span>\n            <div v-else class=\"flex p-6 flex-grow\">\n                {{ t('details.loading') }}\n            </div>\n\n            <!-- zoom icon -->\n            <span class=\"zoomButton text-center p-3\" v-if=\"data.loaded\"\n                ><button\n                    type=\"button\"\n                    :content=\"t(`details.item.zoom${zoomStatus === 'none' ? '' : `.${zoomStatus}`}`)\"\n                    v-tippy=\"{ placement: 'bottom' }\"\n                    :aria-label=\"t(`grid.cells.zoom${zoomStatus === 'none' ? '' : `.${zoomStatus}`}`)\"\n                    ref=\"zoomButton\"\n                    @click=\"\n                        (e: MouseEvent) => {\n                            e.stopPropagation();\n                            zoomToFeature();\n                        }\n                    \"\n                    class=\"text-gray-600 w-24 h-24 p-2 flex justify-center items-center\"\n                    v-if=\"isMapLayer\"\n                >\n                    <div v-if=\"zoomStatus === 'zooming'\" class=\"m-auto animate-spin spinner h-20 w-20\"></div>\n                    <svg\n                        v-else-if=\"zoomStatus === 'zoomed'\"\n                        xmlns=\"http://www.w3.org/2000/svg\"\n                        fill=\"none\"\n                        viewBox=\"0 0 24 24\"\n                        stroke-width=\"1.5\"\n                        stroke=\"green\"\n                        class=\"m-auto w-20 h-20\"\n                    >\n                        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M4.5 12.75l6 6 9-13.5\" />\n                    </svg>\n                    <svg\n                        v-else-if=\"zoomStatus === 'error'\"\n                        xmlns=\"http://www.w3.org/2000/svg\"\n                        fill=\"none\"\n                        viewBox=\"0 0 24 24\"\n                        stroke-width=\"1.5\"\n                        stroke=\"red\"\n                        class=\"m-auto w-20 h-20\"\n                    >\n                        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M6 18L18 6M6 6l12 12\" />\n                    </svg>\n                    <span v-else v-html=\"iApi.ui.getZoomIcon()\"></span></button\n            ></span>\n        </div>\n    </div>\n\n    <!-- Details Component -->\n    <component\n        v-if=\"!!open\"\n        :is=\"detailsTemplate\"\n        :identifyData=\"data\"\n        :fields=\"fieldsList\"\n        :fixtureFields=\"fixtureFields\"\n        class=\"p-8\"\n    ></component>\n</template>\n\n<script setup lang=\"ts\">\n// handles the rendering of a single result item.\n// has support for the different supported formats, and applying vue templates\n\nimport { useLayerStore } from '@/stores/layer';\nimport { GeometryType, LayerType } from '@/geo/api';\nimport { DetailsItemInstance, useDetailsStore, type DetailsFieldItem } from '../store';\nimport { computed, ref, inject, onBeforeMount, onBeforeUnmount, watch } from 'vue';\nimport { useI18n } from 'vue-i18n';\nimport linkifyHtml from 'linkify-html';\n\nimport ESRIDefault from '../templates/esri-default.vue';\nimport HTMLDefault from '../templates/html-default.vue';\n\nimport type { FieldDefinition } from '@/geo/api';\nimport type { IdentifyItem, InstanceAPI, LayerInstance } from '@/api';\nimport type { PropType } from 'vue';\n\nconst layerStore = useLayerStore();\nconst props = defineProps({\n    uid: { type: String, required: true },\n    data: { type: Object as PropType<IdentifyItem>, required: true },\n    open: { type: Boolean, required: false },\n    inList: { type: Boolean, required: false }\n});\n\nconst iApi = inject<InstanceAPI>('iApi')!;\nconst watchers = ref<Array<() => void>>([]);\nconst detailsStore = useDetailsStore();\nconst { t } = useI18n();\nconst isTouch = ref(false);\n\n/**\n * Icon string to display for this item\n */\nconst icon = ref<string>('');\nconst zoomStatus = ref<'zooming' | 'zoomed' | 'error' | 'none'>('none');\nconst zoomButton = ref<HTMLElement>();\n\n/**\n * Return the LayerInstance that cooresponds with the UID provided in props.\n */\nconst getLayerInfo = () => {\n    const layer: LayerInstance | undefined = layerStore.getLayerByUid(props.uid);\n    return layer;\n};\n\nconst detailProperties = computed<{ [id: string]: DetailsItemInstance }>(() => detailsStore.properties);\n\nconst defaultTemplates = computed<{ [type: string]: string }>(() => detailsStore.defaultTemplates);\n\nconst supportsFeatures = computed<boolean>(() => {\n    return getLayerInfo()?.supportsFeatures ?? false;\n});\n\nconst isMapLayer = computed<boolean>(() => {\n    return getLayerInfo()?.mapLayer ?? false;\n});\n\n/**\n * Determine the name of the data point.\n */\nconst itemName = computed<string>(() => {\n    const nameField = getLayerInfo()?.nameField;\n    let returnValue = nameField && props.data.loaded ? props.data.data[nameField] : iApi.$i18n.t('details.items.title');\n\n    // only replace html special chars if string represents plain text\n    if (iApi!.ui.isPlainText(returnValue)) {\n        returnValue = iApi!.ui.escapeHtml(returnValue);\n    }\n\n    return returnValue;\n});\n\n// make links look like links and work like links\nconst makeHtmlLink = (html: any): any => {\n    if (typeof html === 'string') {\n        const classes = 'underline text-blue-700 break-all';\n        const div = document.createElement('div');\n        div.innerHTML = html.trim();\n\n        // check if the html string is just an <a> tag\n        if (div.firstElementChild?.tagName == 'A') {\n            div.firstElementChild.className = classes;\n            return div.innerHTML;\n        } else {\n            // otherwise, look for any valid links\n            const options = {\n                className: classes,\n                target: '_blank',\n                validate: {\n                    url: (value: string) => /^https?:\\/\\//.test(value) // only links that begin with a protocol will be hyperlinked\n                }\n            };\n            return linkifyHtml(html, options);\n        }\n    }\n    return html;\n};\n\n/**\n * Called whenever the displayed item changes\n */\nconst itemChanged = () => {\n    updateZoomStatus('none');\n    if (props.data.loaded) {\n        fetchIcon();\n    } else {\n        // request any details download and wait.\n        // innards of .load() are smart enough not to double-request.\n        // TODO revist when we implement pagination on the result-list.vue list mode.\n        //      if it only renders what is on current page, then only visible items should\n        //      hit this and make load requests. But need to ensure -- hitting everything\n        //      will cause issue #2156\n\n        props.data.load().then(() => {\n            fetchIcon();\n        });\n\n        // TODO do we need some type of updateAlert that says the screen is now\n        //      in a loading state?\n    }\n};\n\n/**\n * Get the icon of the identify result.\n */\nconst fetchIcon = () => {\n    icon.value = '';\n    if (!(props.data && props.data.loaded)) {\n        return;\n    }\n\n    const layer: LayerInstance | undefined = getLayerInfo();\n\n    if (layer === undefined) {\n        console.warn(`could not find layer for uid ${props.uid} during icon lookup`);\n        return;\n    }\n\n    if (layer.supportsFeatures) {\n        const oidField = layer.oidField;\n\n        layer.getIcon(props.data.data[oidField]).then((value: string) => {\n            icon.value = value;\n        });\n    }\n};\n\n/**\n * Fetch the correct details template.\n */\nconst detailsTemplate = computed(() => {\n    const layer: LayerInstance | undefined = getLayerInfo();\n\n    // If there is a custom template binding for this layer in the store, then\n    // return its name.\n    if (layer && detailProperties.value[layer.id] && detailProperties.value[layer.id].template) {\n        return detailProperties.value[layer.id].template;\n    }\n\n    // If nothing is found, use a default template from config\n    if (defaultTemplates.value && defaultTemplates.value[props.data.format]) {\n        return defaultTemplates.value[props.data.format];\n    }\n\n    // If default template is not specified, use our default template\n    if (!supportsFeatures.value) {\n        return HTMLDefault;\n    } else {\n        return ESRIDefault;\n    }\n});\n\n/**\n * Retrieve layer fields.\n */\nconst fieldsList = computed<Array<FieldDefinition>>(() => {\n    // wms layers do not support fields\n    if (!supportsFeatures.value) {\n        return [];\n    }\n    const layer: LayerInstance | undefined = getLayerInfo();\n    const fields = layer?.fields;\n    return fields || [];\n});\n\n/**\n * Check for any field overrides.\n */\nconst fixtureFields = computed<DetailsFieldItem[] | undefined>(() => {\n    const layer: LayerInstance | undefined = getLayerInfo();\n\n    if (layer && detailProperties.value[layer.id] && detailProperties.value[layer.id].fields) {\n        return detailProperties.value[layer.id].fields;\n    }\n    return undefined;\n});\n\nconst updateZoomStatus = (value: 'zooming' | 'zoomed' | 'error' | 'none') => {\n    if (value === 'zoomed' || value === 'error') {\n        setTimeout(() => {\n            zoomStatus.value = value;\n            (zoomButton.value as any)?._tippy.show();\n            setTimeout(() => {\n                (zoomButton.value as any)?._tippy.hide();\n                zoomStatus.value = 'none';\n            }, 3000);\n        }, 300);\n    } else {\n        zoomStatus.value = value;\n    }\n};\n\n/**\n * Zoom to feature on the map\n */\nconst zoomToFeature = () => {\n    if (zoomStatus.value !== 'none') {\n        return;\n    }\n\n    updateZoomStatus('zooming');\n    const layer: LayerInstance | undefined = getLayerInfo();\n\n    if (layer === undefined || !layer.isLoaded) {\n        console.warn(`Could not find layer for uid ${props.uid} during zoom geometry lookup`);\n        updateZoomStatus('error');\n        return;\n    }\n\n    if (!props.data.loaded) {\n        console.warn('Details zoomToFeature call on item that is still loading. Should be impossible, alert the devs.');\n        updateZoomStatus('error');\n        return;\n    }\n\n    const oid = props.data.data[layer.oidField];\n    const zoomUsingGraphic = () => {\n        const opts = { getGeom: true };\n        layer\n            .getGraphic(oid, opts)\n            .then(g => {\n                if (g.geometry.invalid()) {\n                    console.error(`Could not find graphic for objectid ${oid}`);\n                    updateZoomStatus('error');\n                } else {\n                    iApi.geo.map.zoomMapTo(g.geometry);\n                    updateZoomStatus('zoomed');\n                    iApi.updateAlert(iApi.$i18n.t('details.item.alert.zoom'));\n                }\n            })\n            .catch(() => {\n                updateZoomStatus('error');\n            });\n    };\n\n    if (layer.layerType === LayerType.FEATURE && layer.geomType !== GeometryType.POINT) {\n        layer\n            .getGraphicExtent(oid)\n            .then(e => {\n                iApi.geo.map.zoomMapTo(e);\n                updateZoomStatus('zoomed');\n                iApi.updateAlert(iApi.$i18n.t('details.item.alert.zoom'));\n            })\n            .catch(() => {\n                zoomUsingGraphic();\n            });\n    } else {\n        zoomUsingGraphic();\n    }\n};\n\nonBeforeMount(() => {\n    // keep track of this watcher because it needs to be removed when this component is unmounted\n    watchers.value.push(\n        watch(\n            props,\n            () => {\n                // Something has changed, so re-fetch the icon.\n                itemChanged();\n            },\n            {\n                deep: false,\n                immediate: true\n            }\n        )\n    );\n});\n\nonBeforeUnmount(() => {\n    watchers.value.forEach(unwatch => unwatch());\n});\n</script>\n\n<style lang=\"scss\" scoped></style>\n","<template>\n    <div\n        class=\"detailsContent relative flex flex-col flex-grow pl-5\"\n        :style=\"results.length > 1 ? { 'margin-left': '42px' } : ''\"\n        v-if=\"isLayerResultLoaded && activeGreedy === 0\"\n    >\n        <!-- layer name -->\n        <h1\n            class=\"layerName w-full flex-grow p-5 pb-8 font-bold truncate\"\n            v-if=\"layerExists\"\n            v-truncate=\"{ options: { placement: 'top-start' } }\"\n            tabIndex=\"0\"\n        >\n            {{ layerName }}\n        </h1>\n\n        <!-- highlight toggle -->\n        <div class=\"p-8 mb-8 bg-gray-100 flex justify-between\" v-if=\"canHighlight\">\n            <label for=\"toggle\">{{ t('details.togglehilight.title') }}</label>\n            <Toggle\n                :config=\"{\n                    value: hilightToggle,\n                    disabled: false\n                }\"\n                @toggled=\"onHilightToggle\"\n            ></Toggle>\n        </div>\n\n        <!-- paginator and list button for multiple features -->\n        <div class=\"flex flex-col justify-between p-8 mb-8 bg-gray-100\" v-if=\"showPaginator\">\n            <div class=\"flex\">\n                <button\n                    v-if=\"!showList\"\n                    type=\"button\"\n                    class=\"px-8 font-bold hover:bg-gray-200 focus:bg-gray-200\"\n                    :aria-label=\"t('details.item.see.list')\"\n                    @click=\"clickShowList()\"\n                >\n                    {{ t('details.item.see.list') }}\n                </button>\n                <div class=\"flex ml-auto bg-gray-200 py-8 items-center\" :class=\"{ 'w-full': showList }\">\n                    <button\n                        type=\"button\"\n                        :content=\"t(showList ? 'details.items.previous' : 'details.item.previous.item')\"\n                        v-tippy=\"{ placement: 'top' }\"\n                        @click=\"advanceItemIndex(-1)\"\n                        class=\"mx-2 opacity-60 hover:opacity-90 disabled:opacity-30 disabled:cursor-default\"\n                        :aria-label=\"t(showList ? 'details.items.previous' : 'details.item.previous.item')\"\n                        :disabled=\"currentIdx === 0\"\n                    >\n                        <svg height=\"24\" width=\"24\" viewBox=\"0 0 23 23\">\n                            <g>\n                                <path d=\"M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z\" />\n                            </g>\n                        </svg>\n                    </button>\n                    <span class=\"px-3 text-center flex-grow\">\n                        {{\n                            showList\n                                ? t('details.items.range', [\n                                      currentIdx + 1,\n                                      Math.min(endIdx, getLayerIdentifyItems().length),\n                                      getLayerIdentifyItems().length\n                                  ])\n                                : t('details.item.count', [currentIdx + 1, getLayerIdentifyItems().length])\n                        }}\n                    </span>\n                    <button\n                        type=\"button\"\n                        :content=\"t(showList ? 'details.items.next' : 'details.item.next.item')\"\n                        v-tippy=\"{ placement: 'top' }\"\n                        @click=\"advanceItemIndex(1)\"\n                        class=\"mx-2 rotate-180 opacity-60 hover:opacity-90 disabled:opacity-30 disabled:cursor-default\"\n                        :aria-label=\"t(showList ? 'details.items.next' : 'details.item.next.item')\"\n                        :disabled=\"\n                            (!showList && currentIdx === getLayerIdentifyItems().length - 1) ||\n                            (showList && endIdx >= getLayerIdentifyItems().length)\n                        \"\n                    >\n                        <svg height=\"24\" width=\"24\" viewBox=\"0 0 23 23\">\n                            <g>\n                                <path d=\"M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z\" />\n                            </g>\n                        </svg>\n                    </button>\n                </div>\n            </div>\n        </div>\n\n        <!-- details result, or result list -->\n        <div v-if=\"layerExists\">\n            <div v-if=\"getLayerIdentifyItems().length > 0\">\n                <div\n                    v-if=\"showList\"\n                    class=\"flex flex-col\"\n                    v-focus-list\n                    :content=\"t('details.layers.results.list.tooltip')\"\n                    v-tippy=\"{\n                        trigger: 'manual',\n                        placement: 'top-start',\n                        touch: false\n                    }\"\n                    ref=\"el\"\n                >\n                    <button\n                        class=\"flex flex-grow truncate default-focus-style hover:bg-gray-200\"\n                        v-for=\"(item, idx) in getLayerIdentifyItems().slice(currentIdx, endIdx)\"\n                        :key=\"idx\"\n                        @click=\"clickListItem(currentIdx + idx)\"\n                        v-focus-item=\"'show-truncate'\"\n                    >\n                        <ResultItem :data=\"item\" :uid=\"uid\" :open=\"false\" :in-list=\"true\"></ResultItem>\n                    </button>\n                </div>\n                <ResultItem :data=\"currentIdentifyItem\" :uid=\"uid\" :open=\"true\" :in-list=\"false\" v-else></ResultItem>\n            </div>\n            <div class=\"text-center\" v-else>\n                {{ t('details.layers.results.empty.currentLayer') }}\n            </div>\n        </div>\n        <!-- layer does not exist anymore, show no data text -->\n        <div v-else class=\"p-5\">\n            {{ t('details.item.no.data') }}\n        </div>\n    </div>\n\n    <!-- identified item is loading -->\n    <div v-else class=\"flex justify-center py-10 items-center\" :class=\"results.length > 1 ? 'ml-42' : ''\">\n        <span class=\"animate-spin spinner h-20 w-20 px-5 mr-8\"></span>\n        {{ t('details.item.loading') }}\n    </div>\n</template>\n\n<script setup lang=\"ts\">\n// acts as the result container for a single layer's result set. Includes header controls,\n// and will render the list view if we're in that mode. If in single detail mode, it just\n// inserts a result-item under the header.\n\nimport { useLayerStore } from '@/stores/layer';\nimport { useI18n } from 'vue-i18n';\nimport type { DetailsAPI } from '../api/details';\nimport ResultItem from './result-item.vue';\nimport Toggle from '../../../components/controls/toggle-switch-control.vue';\n\nimport { GlobalEvents } from '@/api';\nimport type { IdentifyItem, IdentifyResult, InstanceAPI, LayerInstance, PanelInstance } from '@/api';\n\nimport type { BasemapChange } from '@/geo/api';\n\nimport { computed, inject, onMounted, onBeforeMount, onBeforeUnmount, ref, watch } from 'vue';\nimport type { PropType } from 'vue';\n\nimport { useDetailsStore } from '../store';\nimport type { DetailsItemInstance } from '../store';\n\nconst el = ref<Element>();\nconst blurEvent = () => {\n    (el.value as any)._tippy.hide();\n};\nconst keyupEvent = (e: Event) => {\n    const evt = e as KeyboardEvent;\n    if (evt.key === 'Tab' && el.value?.matches(':focus')) {\n        (el.value as any)._tippy.show();\n    }\n};\n\nconst iApi = inject<InstanceAPI>('iApi')!;\n\nconst detailsStore = useDetailsStore();\nconst layerStore = useLayerStore();\nconst props = defineProps({\n    uid: { type: String, required: true },\n    results: { type: Object as PropType<Array<IdentifyResult>>, required: true }\n});\nconst { t } = useI18n();\n\n/**\n * If we could find the bound layer in our instance\n */\nconst layerExists = ref<boolean>(false);\n\n/**\n * Details fixture\n */\nconst detailsFixture = ref<DetailsAPI>(iApi.fixture.get('details'));\n\n/**\n * Value of the onscreen highlighter toggle control\n */\nconst hilightToggle = ref<boolean>(true);\n\n/**\n * If we are displaying list view or single item view\n */\nconst showList = ref<boolean>(false);\n\n/**\n * Index of the item we are displaying within the result's item array\n * Persists in list view\n */\nconst currentIdx = ref<number>(0);\n\n/**\n * Number of items to display at once in list view\n */\nconst itemsPerPage = ref<number>(20);\n\nconst handlers = ref<Array<string>>([]);\nconst watchers = ref<Array<() => void>>([]);\n\nconst activeGreedy = computed<number>(() => detailsStore.activeGreedy);\nconst detailProperties = computed<{ [id: string]: DetailsItemInstance }>(() => detailsStore.properties);\nconst endIdx = computed<number>(() => currentIdx.value + itemsPerPage.value);\n\n/**\n * Return the LayerInstance that cooresponds with the UID provided in props.\n */\nconst getBoundLayer = () => {\n    return layerStore.getLayerByUid(props.uid);\n};\n\n/**\n * Find the layer result object for the bound layer, if exists\n */\nconst getBoundLayerResult = (): IdentifyResult | undefined => {\n    return props.results.find(layerIR => {\n        return layerIR.uid === props.uid;\n    });\n};\n\n/**\n * Computed property that returns true if the layer's overall identify result has loaded.\n */\nconst isLayerResultLoaded = computed<boolean>(() => {\n    const results = getBoundLayerResult();\n    return results?.loaded ?? false;\n});\n\nconst itemRequestTime = computed<number | undefined>(() => {\n    const results = getBoundLayerResult();\n    return results?.requestTime;\n});\n\nconst showPaginator = computed<boolean>(\n    () =>\n        layerExists.value &&\n        ((!showList.value && getLayerIdentifyItems().length > 1) ||\n            (showList.value && getLayerIdentifyItems().length > itemsPerPage.value))\n);\n\nconst layerName = computed<string>(() => {\n    const layer = getBoundLayer();\n\n    if (layer && detailProperties.value[layer.id] && detailProperties.value[layer.id].name) {\n        return detailProperties.value[layer.id].name;\n    }\n    return layer?.name ?? '';\n});\n\n/**\n * Lets us watch() the uid\n */\nconst uidCompute = computed<string>(() => {\n    return props.uid;\n});\n\n/**\n * Retrieves the identify items that belong to the layer currently bound to this list.\n * If there are no results, returns an empty array.\n */\nconst getLayerIdentifyItems = () => {\n    const results = getBoundLayerResult();\n\n    return results ? results.items : [];\n};\n\n/**\n * Computed property that returns the identify item currently being viewed.\n * In list mode, this returns last item viewed in detail view (defaults to first).\n * If no results, returns undefined\n */\nconst currentIdentifyItem = computed<IdentifyItem>(() => {\n    return getLayerIdentifyItems()[currentIdx.value];\n});\n\n/**\n * Computed property that indicates if highlighting is a possibility\n */\nconst canHighlight = computed<boolean>(() => {\n    if (detailsFixture.value.hasHilighter()) {\n        const layer = getBoundLayer();\n        if (layer) {\n            return layer.mapLayer && layer.supportsFeatures;\n        }\n    }\n    return false;\n});\n\n/**\n * Event handler for the UI highlight toggle. Toggles highlight on data points.\n * @param value the value to assign the highlight\n */\nconst onHilightToggle = (value: boolean) => {\n    // change control state, remember in store, update any highlighting\n\n    hilightToggle.value = value;\n    detailsStore.hilightToggle = value;\n    updateHighlight();\n};\n\n/**\n * Initialize the details screen\n */\nconst initDetails = () => {\n    const layer = getBoundLayer();\n\n    currentIdx.value = currentIdx.value ?? 0;\n    hilightToggle.value = detailsStore.hilightToggle ?? hilightToggle.value;\n    showList.value = false;\n\n    // could not find this layer, so mark this result as invalid\n    // this handles the case where user minimized item screen -> deletes layer -> opens item screen again\n    layerExists.value = !!layer;\n\n    updateHighlight();\n};\n\n/**\n * Advance the item index by direction (an integer). Singular in detail mode, by a page in list mode\n */\nconst advanceItemIndex = (direction: number) => {\n    if (showList.value) {\n        currentIdx.value += direction * itemsPerPage.value;\n        updateHighlight();\n    } else {\n        currentIdx.value += direction;\n    }\n};\n\n/**\n * Updates the highlighter when something changes (panel minimized, opened, change in selected result, etc.)\n */\nconst updateHighlight = () => {\n    /*\n    Dev notes for paths that hit this method, since its a bit spicey.\n    currentIdentifyItem watcher -> initDetails : handles changes in the details view of an item.\n        includes initial load, layer change, item pagination. Anything that isn't in list mode.\n    uidCompute watcher : handles a new layer being selected and we are in list mode.\n    advanceItemIndex : handles pagination change when in list mode\n    onHilightToggle : handles user mashing the toggler button\n    clickShowList : handles user going from detail view to list view on same layer\n    clickListItem : handles weird scenario where user clicks first (top) item in list view to switch to its detail view\n    BASEMAP_CHANGE event : handles re-applying hilight if schema changed\n    */\n\n    const resultItems = getLayerIdentifyItems();\n\n    if (hilightToggle.value && isLayerResultLoaded.value && resultItems.length > 0 && canHighlight.value) {\n        // we are highlighting, and there is something that could be hilighted.\n        // the hilightDetailsItems will handle the waiting for items to finish loading, as well as ensuring\n        // that any stale loads will not be drawn / removed when users spam their highlights real fast.\n\n        if (showList.value) {\n            // highlight what is on current page of the list.\n            detailsFixture.value.hilightDetailsItems(resultItems.slice(currentIdx.value, endIdx.value), props.uid);\n        } else {\n            // highlight current item being displayed.\n            // being extra careful just incase our index went beyond the array bounds\n            const currItem = resultItems[currentIdx.value];\n            if (currItem) {\n                detailsFixture.value.hilightDetailsItems([currItem], props.uid);\n            }\n        }\n    } else {\n        // nothing to hilight. This ensures any old details highlights get wiped\n        detailsFixture.value.removeDetailsHilight();\n    }\n};\n\n/**\n * Called when the `Show List` button is pressed. Enables list view and sets highlight to show\n * all items in the list.\n */\nconst clickShowList = () => {\n    showList.value = true;\n\n    currentIdx.value = Math.floor(currentIdx.value / itemsPerPage.value) * itemsPerPage.value;\n    updateHighlight();\n};\n\n/**\n * Clean up for when the details screen is closed.\n */\nconst detailsClosed = () => {\n    detailsFixture.value.removeDetailsHilight();\n    // unwatch when the panel is closed, not when unmounted because a minimized\n    // panel will be unmounted but still needs to have watchers active.\n    watchers.value.forEach(unwatch => unwatch());\n    handlers.value.forEach(handler => iApi.event.off(handler));\n\n    // (JR) commenting this out. if user turns off toggle, it shouldnt reset back to on when screen closes.\n    // detailsStore.hilightToggle = true;\n};\n\n/**\n * Clean up for when the details screen is minimized.\n */\nconst detailsMinimized = () => {\n    detailsFixture.value.removeDetailsHilight();\n};\n\n/**\n * Called when an item in the list is clicked. Disables list view and updates highlight.\n * @param idx the index of the point that was clicked.\n */\nconst clickListItem = (idx: number) => {\n    const secretIdx = currentIdx.value;\n    currentIdx.value = idx;\n    showList.value = false;\n    if (secretIdx === idx) {\n        // we clicked on the row that currentIdx was secretly tracking.\n        // as such, the watcher on the current item won't trigger, so\n        // need to update the highlight\n        updateHighlight();\n    }\n};\n\nonMounted(() => {\n    // close this panel if layer is removed\n    handlers.value.push(\n        iApi.event.on(GlobalEvents.LAYER_REMOVE, (removedLayer: LayerInstance) => {\n            const detailsPanel = iApi.panel.get('details');\n            if (props.uid === removedLayer.uid && !!detailsPanel) {\n                detailsPanel.close();\n            }\n        })\n    );\n\n    handlers.value.push(\n        iApi.event.on(GlobalEvents.PANEL_CLOSED, (panel: PanelInstance) => {\n            if (panel.id === 'details') {\n                detailsClosed();\n            }\n        })\n    );\n\n    handlers.value.push(\n        iApi.event.on(GlobalEvents.PANEL_MINIMIZED, (panel: PanelInstance) => {\n            if (panel.id === 'details') {\n                detailsMinimized();\n            }\n        })\n    );\n\n    handlers.value.push(\n        iApi.event.on(GlobalEvents.MAP_BASEMAPCHANGE, (payload: BasemapChange) => {\n            if (hilightToggle.value && payload.schemaChanged) {\n                // will just wipe and re-apply the highlight\n                updateHighlight();\n            }\n        })\n    );\n\n    el.value?.addEventListener('blur', blurEvent);\n    el.value?.addEventListener('keyup', keyupEvent);\n});\n\nonBeforeMount(() => {\n    // Keep an eye to see if the currently selected identify item has been changed.\n    // Use a watcher to account for the async nature of results appearing in the\n    // IdentifyItems object\n    watchers.value.push(\n        watch(\n            currentIdentifyItem,\n            () => {\n                // ignore stuff in list mode. we manually work the highlights in that mode.\n                if (!showList.value) {\n                    // Re-initialize the details panel if the content has changed.\n                    initDetails();\n\n                    // If the identifyItem is undefined, clear any hilights.\n                    // this occurs when the bound layer has no results.\n                    if (currentIdentifyItem.value === undefined) {\n                        detailsFixture.value.removeDetailsHilight();\n                    }\n                }\n            },\n            {\n                deep: false,\n                immediate: true\n            }\n        )\n    );\n\n    // handle the case where the layer changes and we are in list mode.\n    // that change comes from `details-screen.vue` updating the props of this component,\n    // to there is no \"manual update\" of the highlight from local button event handlers.\n    watchers.value.push(\n        watch(\n            uidCompute,\n            () => {\n                const localUid = props.uid;\n\n                if (showList.value && localUid) {\n                    // we're in list mode, and a valid layer is linked\n\n                    // find layer result, wait for outer request to finish (need items to pass to hilighter)\n                    const layerIR = getBoundLayerResult();\n                    if (layerIR) {\n                        layerIR.loading.then(() => {\n                            if (props.uid === localUid && showList.value) {\n                                // Still on the same layer. User didn't pick diff layer during the loading wait.\n                                // Still in list mode. User didn't pick diff layer, change to detail mode, then come back.\n                                //\n                                // If user switches to a different layer, stays in list mode, and comes back to this prior to either layer being loaded,\n                                // will probably get a double hilight request on this layer (first visit & second vist resolve at same time),\n                                // but will just spam warnings on the console. Requires slow layers and fidgity user.\n                                // If we really don't like that, need to think of some wilder solution to track async stuff across components.\n\n                                updateHighlight();\n                            }\n                        });\n                    }\n                }\n            },\n            {\n                deep: false,\n                immediate: true\n            }\n        )\n    );\n\n    // If a new request is made, reset the index.\n    watchers.value.push(\n        watch(itemRequestTime, () => {\n            currentIdx.value = 0;\n        })\n    );\n\n    // Similarily to above, if a new layer is selected, reset the index.\n    watchers.value.push(\n        watch(\n            () => props.uid,\n            () => {\n                currentIdx.value = 0;\n            }\n        )\n    );\n});\n\nonBeforeUnmount(() => {\n    el.value?.removeEventListener('blur', blurEvent);\n    el.value?.removeEventListener('keyup', keyupEvent);\n});\n</script>\n\n<style lang=\"scss\" scoped>\n.layerName {\n    border-bottom: 1px solid #eee;\n}\n</style>\n","<template>\n    <panel-screen :panel=\"panel\">\n        <template #header>\n            {{\n                // Show different titles based on what requested the panel\n                detailsStore.origin === 'toggleEvent'\n                    ? t('details.layers.title.gridOrigin')\n                    : t('details.layers.title.identifyOrigin')\n            }}\n        </template>\n\n        <template #content>\n            <div class=\"relative h-full\">\n                <!-- Layer Picker, symbology stacks -->\n                <SymbologyList\n                    :results=\"layerResults\"\n                    :detailsProperties=\"detailProperties\"\n                    :selected=\"selectedLayer\"\n                    @selection-changed=\"changeLayerSelection\"\n                    v-if=\"layerResults.length > 1\"\n                ></SymbologyList>\n\n                <!-- Main Details Panel -->\n                <div class=\"detailsContentSection overflow-y-auto h-full\">\n                    <ResultList :uid=\"selectedLayer\" :results=\"layerResults\" v-if=\"!noResults\"></ResultList>\n                    <div :class=\"['text-center', { 'ml-42': layerResults.length > 1 }]\" v-else>\n                        {{\n                            layerResults.length >= 1\n                                ? t('details.layers.results.empty')\n                                : t('details.layers.results.empty.noLayers')\n                        }}\n                    </div>\n                </div>\n            </div>\n        </template>\n    </panel-screen>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed, onBeforeMount, onBeforeUnmount, ref, inject, watch } from 'vue';\n\nimport SymbologyList from './components/symbology-list.vue';\nimport ResultList from './components/result-list.vue';\n\nimport type { PropType } from 'vue';\nimport type { IdentifyResult, InstanceAPI, PanelInstance } from '@/api';\nimport type { DetailsItemInstance } from './store';\n\nimport { useI18n } from 'vue-i18n';\nimport { useDetailsStore } from './store';\n\nconst { t } = useI18n();\nconst iApi = inject<InstanceAPI>('iApi')!;\nconst detailsStore = useDetailsStore();\n\nconst handlers = ref<Array<string>>([]);\nconst watchers = ref<Array<() => void>>([]);\nconst layerResults = ref<Array<IdentifyResult>>([]);\nconst noResults = ref<boolean>(false);\n\n/**\n * UID of the layer \"selected\" into the detail/list section. Empty string when panel is freshly opened.\n */\nconst selectedLayer = ref<string>('');\n\n/**\n * Contains the timestamp of the most recent payload. 0 if we are not watching for a greedy open\n */\nconst activeGreedy = computed<number>(() => detailsStore.activeGreedy);\nconst payload = computed<IdentifyResult[]>(() => detailsStore.payload);\nconst detailProperties = computed<{ [id: string]: DetailsItemInstance }>(() => detailsStore.properties);\n\ndefineProps({\n    panel: {\n        type: Object as PropType<PanelInstance>\n    }\n});\n\n/**\n * Handles user picking a new layer from the \"symbol stack\" list\n */\nconst changeLayerSelection = (uid: string) => {\n    selectedLayer.value = uid;\n};\n\n/**\n * Finds the result object for a layer uid, or undefined if no result exists\n * @param uid logical layer uid\n */\nconst findLayerResult = (uid: string): IdentifyResult | undefined => layerResults.value.find(item => item.uid === uid);\n\n/**\n * Intake a new identify result set, initiate auto-open logic.\n */\nconst loadPayloadItems = (newPayload: Array<IdentifyResult>): void => {\n    // NOTE: the incoming payload array needs to be made reactive at the source,\n    // i.e. in the layer that ran the identify and created this stuff.\n    // Not ideal. Have tried a number of workarounds but vue remains\n    // disrespectful in ignoring changes to array elements and updating\n    // controls in the template v-for's.\n    // I think the reason is because a promise that lives outside of\n    // the component is updating values, and the vue reactivity magic\n    // is not registering it in the dependency graph thing. Still don't know\n    // enough to say for sure.\n    // The alternative is to use $forceUpdate, which works but seems less\n    // efficient and sort of defeats the purpose of using a framework with\n    // \"smart\" two way binding.\n    // Tried making a reactive copy of elements here that would watch\n    // the original elements and update itself, would work for the\n    // IdentifyResults but the nested IdentifyItems would still break.\n    // It was also a big hack.\n    // Would like to revist, as this current solution is unintuitive,\n    // nobody writing a new layer type is going to have a clue they need\n    // to wrap their identify outputs in reactive() due to disrespectful code.\n\n    // if no payload, just return\n    if (newPayload === undefined) {\n        return;\n    }\n\n    // track last identify request timestamp and add to payload items. If no new results,\n    // disable the greedy identify.\n    detailsStore.activeGreedy = newPayload.length === 0 ? 0 : newPayload[0].requestTime;\n\n    layerResults.value = newPayload;\n\n    autoOpen(newPayload);\n};\n\n/**\n * Auto-selects which layer to show in the detail section when a new payload of identify results arrive.\n *\n * 1. If a layer is already the active layer in the details view, we wait for it to report its findings.\n *    If it has a result, it remains the active layer.\n * 2. If no active layer (freshly opened panel or old active layer was deleted), or the active layer had\n *    no results in 1., we then watch identify results for all candidate layers. First layer to report\n *    a hit becomes the active layer.\n */\nconst autoOpen = (newPayload: Array<IdentifyResult>): void => {\n    // if the detail panel is already showing details of a specific layer,\n    // wait on that layer to resolve first\n    if (selectedLayer.value) {\n        const selectedResult = findLayerResult(selectedLayer.value);\n\n        if (selectedResult) {\n            // wait on the currently selected layer to see if it resolves with new results\n            selectedResult.loading.then(() => {\n                // new identify request came in while loading old results, exit greedy algo\n                if (selectedResult.requestTime !== activeGreedy.value) {\n                    return;\n                }\n\n                if (selectedResult.items.length > 0) {\n                    // got a hit. update items screen with new results and turn off greedy loading\n                    detailsStore.activeGreedy = 0;\n                    noResults.value = false;\n                } else {\n                    // current layer has no hits, fall back to examining all.\n                    autoOpenAny(newPayload);\n                }\n            });\n        } else {\n            // last opened layer no longer exists, proceed examine all layers\n            autoOpenAny(newPayload);\n        }\n    } else {\n        // panel was freshly opened. show first layer with results\n        autoOpenAny(newPayload);\n    }\n};\n\n/**\n * Will watch all the result items. First layer to resolve with a valid result will become\n * the active layer in the details view.\n *\n * @param newPayload the identify result payload we're watching\n * @param priorityStack helper param for priority recursion. Is omitted on initial call\n */\nconst autoOpenAny = (newPayload: Array<IdentifyResult>, priorityStack?: Array<[number, Array<string>]>): void => {\n    /**\n     * Array of [priority, [layerIds]], sorted by highest to lowest priority value (low number goes first)\n     */\n    let priStack: Array<[number, Array<string>]>;\n    if (priorityStack) {\n        // recursive call, use previously generated stack\n        priStack = priorityStack;\n    } else {\n        const layerDetailsConfigs = detailsStore.properties;\n\n        // list of [priority, layerId]\n        const layerPriorities = newPayload.map((idRes): [number, string] => [\n            (layerDetailsConfigs[idRes.layerId]?.priority as number) ?? 50,\n            idRes.layerId\n        ]);\n        // create set of distinct priority values\n        const setMagic = new Set(layerPriorities.map(lp => lp[0]));\n        priStack = [];\n        // group layer ids by priority value\n        setMagic.forEach(uniquePriority => {\n            const matchingLayerIds = layerPriorities.filter(lp => lp[0] === uniquePriority).map(lp => lp[1]);\n            priStack.push([uniquePriority, matchingLayerIds]);\n        });\n        // sort by priority value in descending order\n        priStack.sort((a, b) => b[0] - a[0]);\n    }\n\n    if (priStack.length === 0) {\n        // handles case of no identifiable layers (either from initial conditions, or all priorities have been popped).\n        // Stop & exit.\n        detailsStore.activeGreedy = 0;\n        noResults.value = true;\n        return;\n    }\n\n    // watch the priority layers\n    const currentPriorites = priStack[priStack.length - 1][1];\n    const loadingResults = newPayload\n        .filter(payloadIR => currentPriorites.includes(payloadIR.layerId))\n        .map(payloadIR =>\n            payloadIR.loading.then(() => (payloadIR.items.length > 0 ? Promise.resolve(payloadIR) : Promise.reject()))\n        );\n    const lastTime = newPayload.length === 0 ? 0 : newPayload[0].requestTime;\n\n    // wait on any layer promise to resolve first with new identify results\n    Promise.any(loadingResults)\n        .then(winningResult => {\n            // new identify request came in while loading old results, exit greedy algo\n            if (winningResult.requestTime !== activeGreedy.value) {\n                return;\n            }\n\n            // open results item screen and turn off greedy loading\n            detailsStore.activeGreedy = 0;\n            selectedLayer.value = winningResult.uid;\n            noResults.value = false;\n        })\n        .catch(() => {\n            if (lastTime === activeGreedy.value) {\n                // this process is still the active greedy result.\n                // try next priority bucket. recursive call will also handle the no-result empty array case\n                priStack.pop();\n                autoOpenAny(newPayload, priStack);\n            }\n        });\n};\n\n/* Vue Lifecycle Functions */\n\nonBeforeMount(() => {\n    // keep track of this watcher because it needs to be removed when this component is unmounted\n    watchers.value.push(\n        watch(\n            payload,\n            (newPayload: Array<IdentifyResult>) => {\n                // Reload items\n                loadPayloadItems(newPayload);\n            },\n            {\n                deep: false, // was true when our array had undefineds. now that objects arrive intact, we dont want this triggering when innards update\n                immediate: true\n            }\n        )\n    );\n});\n\nonBeforeUnmount(() => {\n    handlers.value.forEach(handler => iApi.event.off(handler));\n    watchers.value.forEach(unwatch => unwatch());\n});\n</script>\n\n<style lang=\"scss\" scoped>\n.detailsContentSection {\n    padding-right: 8px;\n    margin-right: -8px;\n}\n</style>\n"],"names":["props","__props","stack","ref","onMounted","detailsStore","useDetailsStore","detailProperties","computed","layerName","layer","t","useI18n","layerStore","useLayerStore","el","blurEvent","keyupEvent","e","emit","__emit","selectedLayer","watchers","expanded","hovering","getLayerInfo","uid","handleItemClick","handleMouseOver","handleMouseLeave","handleItemFocus","handleItemBlur","onBeforeMount","watch","onBeforeUnmount","unwatch","iApi","inject","findAndDelete","fields","propertyType","property","helper","field","f","itemData","clonePayload","fieldsMetadata","checkField","item","displayMetadata","key","fieldMD","cloneValue","formatValues","html","alias","type","makeDate","makeHtmlLink","classes","div","linkifyHtml","value","numericDate","isTouch","icon","zoomStatus","zoomButton","defaultTemplates","supportsFeatures","isMapLayer","itemName","nameField","returnValue","itemChanged","updateZoomStatus","fetchIcon","oidField","detailsTemplate","ESRIDefault","HTMLDefault","fieldsList","fixtureFields","zoomToFeature","oid","zoomUsingGraphic","opts","g","LayerType","GeometryType","layerExists","detailsFixture","hilightToggle","showList","currentIdx","itemsPerPage","handlers","activeGreedy","endIdx","getBoundLayer","getBoundLayerResult","layerIR","isLayerResultLoaded","itemRequestTime","showPaginator","getLayerIdentifyItems","uidCompute","results","currentIdentifyItem","canHighlight","onHilightToggle","updateHighlight","initDetails","advanceItemIndex","direction","resultItems","currItem","clickShowList","detailsClosed","handler","detailsMinimized","clickListItem","idx","secretIdx","GlobalEvents","removedLayer","detailsPanel","panel","payload","localUid","layerResults","noResults","changeLayerSelection","findLayerResult","loadPayloadItems","newPayload","autoOpen","selectedResult","autoOpenAny","priorityStack","priStack","layerDetailsConfigs","layerPriorities","idRes","setMagic","lp","uniquePriority","matchingLayerIds","a","b","currentPriorites","loadingResults","payloadIR","lastTime","winningResult"],"mappings":"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"}