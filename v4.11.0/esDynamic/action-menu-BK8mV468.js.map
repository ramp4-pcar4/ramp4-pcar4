{"version":3,"file":"action-menu-BK8mV468.js","sources":["../../node_modules/@esri/calcite-components/dist/components/focusTrapComponent.js","../../node_modules/@esri/calcite-components/dist/components/array.js","../../node_modules/@esri/calcite-components/dist/components/Heading.js","../../node_modules/@esri/calcite-components/dist/components/popover.js","../../node_modules/@esri/calcite-components/dist/components/action-menu.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.\n * v2.13.2\n */\nimport { h as isFocusable, j as tabbable, k as focusable, l as isTabbable, m as getTabIndex, e as focusElement, n as tabbableOptions } from './dom.js';\nimport { f as focusTrapStack } from './config.js';\n\n/*!\n* focus-trap 7.6.0\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nvar activeFocusTraps = {\n  activateTrap: function activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      var activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap.pause();\n      }\n    }\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      // move this existing trap to the front of the queue\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  deactivateTrap: function deactivateTrap(trapStack, trap) {\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    if (trapStack.length > 0) {\n      trapStack[trapStack.length - 1].unpause();\n    }\n  }\n};\nvar isSelectableInput = function isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n};\nvar isEscapeEvent = function isEscapeEvent(e) {\n  return (e === null || e === void 0 ? void 0 : e.key) === 'Escape' || (e === null || e === void 0 ? void 0 : e.key) === 'Esc' || (e === null || e === void 0 ? void 0 : e.keyCode) === 27;\n};\nvar isTabEvent = function isTabEvent(e) {\n  return (e === null || e === void 0 ? void 0 : e.key) === 'Tab' || (e === null || e === void 0 ? void 0 : e.keyCode) === 9;\n};\n\n// checks for TAB by default\nvar isKeyForward = function isKeyForward(e) {\n  return isTabEvent(e) && !e.shiftKey;\n};\n\n// checks for SHIFT+TAB by default\nvar isKeyBackward = function isKeyBackward(e) {\n  return isTabEvent(e) && e.shiftKey;\n};\nvar delay = function delay(fn) {\n  return setTimeout(fn, 0);\n};\n\n// Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\nvar findIndex = function findIndex(arr, fn) {\n  var idx = -1;\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n    return true; // next\n  });\n  return idx;\n};\n\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\nvar valueOrHandler = function valueOrHandler(value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n  return typeof value === 'function' ? value.apply(void 0, params) : value;\n};\nvar getActualTarget = function getActualTarget(event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;\n};\n\n// NOTE: this must be _outside_ `createFocusTrap()` to make sure all traps in this\n//  current instance use the same stack if `userOptions.trapStack` isn't specified\nvar internalTrapStack = [];\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n  // SSR: a live trap shouldn't be created in this type of environment so this\n  //  should be safe code to execute if the `document` option isn't specified\n  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;\n  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true,\n    isKeyForward: isKeyForward,\n    isKeyBackward: isKeyBackward\n  }, userOptions);\n  var state = {\n    // containers given to createFocusTrap()\n    // @type {Array<HTMLElement>}\n    containers: [],\n    // list of objects identifying tabbable nodes in `containers` in the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{\n    //   container: HTMLElement,\n    //   tabbableNodes: Array<HTMLElement>, // empty if none\n    //   focusableNodes: Array<HTMLElement>, // empty if none\n    //   posTabIndexesFound: boolean,\n    //   firstTabbableNode: HTMLElement|undefined,\n    //   lastTabbableNode: HTMLElement|undefined,\n    //   firstDomTabbableNode: HTMLElement|undefined,\n    //   lastDomTabbableNode: HTMLElement|undefined,\n    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n    // }>}\n    containerGroups: [],\n    // same order/length as `containers` list\n\n    // references to objects in `containerGroups`, but only those that actually have\n    //  tabbable nodes in them\n    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__\n    //  the same length\n    tabbableGroups: [],\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined,\n    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any\n    recentNavEvent: undefined\n  };\n  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */\n  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n  };\n\n  /**\n   * Finds the index of the container that contains the element.\n   * @param {HTMLElement} element\n   * @param {Event} [event] If available, and `element` isn't directly found in any container,\n   *  the event's composed path is used to see if includes any known trap containers in the\n   *  case where the element is inside a Shadow DOM.\n   * @returns {number} Index of the container in either `state.containers` or\n   *  `state.containerGroups` (the order/length of these lists are the same); -1\n   *  if the element isn't found.\n   */\n  var findContainerIndex = function findContainerIndex(element, event) {\n    var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === 'function' ? event.composedPath() : undefined;\n    // NOTE: search `containerGroups` because it's possible a group contains no tabbable\n    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)\n    //  and we still need to find the element in there\n    return state.containerGroups.findIndex(function (_ref) {\n      var container = _ref.container,\n        tabbableNodes = _ref.tabbableNodes;\n      return container.contains(element) || ( // fall back to explicit tabbable search which will take into consideration any\n      //  web components if the `tabbableOptions.getShadowRoot` option was used for\n      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't\n      //  look inside web components even if open)\n      composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function (node) {\n        return node === element;\n      });\n    });\n  };\n\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */\n  var getNodeForOption = function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n    if (typeof optionValue === 'function') {\n      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        params[_key2 - 1] = arguments[_key2];\n      }\n      optionValue = optionValue.apply(void 0, params);\n    }\n    if (optionValue === true) {\n      optionValue = undefined; // use default value\n    }\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      }\n      // else, empty string (invalid), null (invalid), 0 (invalid)\n\n      throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n    }\n    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue); // resolve to node, or null if fails\n      if (!node) {\n        throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n      }\n    }\n    return node;\n  };\n  var getInitialFocusNode = function getInitialFocusNode() {\n    var node = getNodeForOption('initialFocus');\n\n    // false explicitly indicates we want no initialFocus at all\n    if (node === false) {\n      return false;\n    }\n    if (node === undefined || !isFocusable(node, config.tabbableOptions)) {\n      // option not specified nor focusable: use fallback options\n      if (findContainerIndex(doc.activeElement) >= 0) {\n        node = doc.activeElement;\n      } else {\n        var firstTabbableGroup = state.tabbableGroups[0];\n        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n\n        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    }\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n    return node;\n  };\n  var updateTabbableNodes = function updateTabbableNodes() {\n    state.containerGroups = state.containers.map(function (container) {\n      var tabbableNodes = tabbable(container, config.tabbableOptions);\n\n      // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n      //  are a superset of tabbable nodes since nodes with negative `tabindex` attributes\n      //  are focusable but not tabbable\n      var focusableNodes = focusable(container, config.tabbableOptions);\n      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : undefined;\n      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : undefined;\n      var firstDomTabbableNode = focusableNodes.find(function (node) {\n        return isTabbable(node);\n      });\n      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function (node) {\n        return isTabbable(node);\n      });\n      var posTabIndexesFound = !!tabbableNodes.find(function (node) {\n        return getTabIndex(node) > 0;\n      });\n      return {\n        container: container,\n        tabbableNodes: tabbableNodes,\n        focusableNodes: focusableNodes,\n        /** True if at least one node with positive `tabindex` was found in this container. */\n        posTabIndexesFound: posTabIndexesFound,\n        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */\n        firstTabbableNode: firstTabbableNode,\n        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */\n        lastTabbableNode: lastTabbableNode,\n        // NOTE: DOM order is NOT NECESSARILY \"document position\" order, but figuring that out\n        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n        //  because that API doesn't work with Shadow DOM as well as it should (@see\n        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,\n        //  to address an edge case related to positive tabindex support, this seems like a much easier,\n        //  \"close enough most of the time\" alternative for positive tabindexes which should generally\n        //  be avoided anyway...\n        /** First tabbable node in container, __DOM__ order; `undefined` if none. */\n        firstDomTabbableNode: firstDomTabbableNode,\n        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */\n        lastDomTabbableNode: lastDomTabbableNode,\n        /**\n         * Finds the __tabbable__ node that follows the given node in the specified direction,\n         *  in this container, if any.\n         * @param {HTMLElement} node\n         * @param {boolean} [forward] True if going in forward tab order; false if going\n         *  in reverse.\n         * @returns {HTMLElement|undefined} The next tabbable node, if any.\n         */\n        nextTabbableNode: function nextTabbableNode(node) {\n          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          var nodeIdx = tabbableNodes.indexOf(node);\n          if (nodeIdx < 0) {\n            // either not tabbable nor focusable, or was focused but not tabbable (negative tabindex):\n            //  since `node` should at least have been focusable, we assume that's the case and mimic\n            //  what browsers do, which is set focus to the next node in __document position order__,\n            //  regardless of positive tabindexes, if any -- and for reasons explained in the NOTE\n            //  above related to `firstDomTabbable` and `lastDomTabbable` properties, we fall back to\n            //  basic DOM order\n            if (forward) {\n              return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function (el) {\n                return isTabbable(el);\n              });\n            }\n            return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function (el) {\n              return isTabbable(el);\n            });\n          }\n          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];\n        }\n      };\n    });\n    state.tabbableGroups = state.containerGroups.filter(function (group) {\n      return group.tabbableNodes.length > 0;\n    });\n\n    // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');\n    }\n\n    // NOTE: Positive tabindexes are only properly supported in single-container traps because\n    //  doing it across multiple containers where tabindexes could be all over the place\n    //  would require Tabbable to support multiple containers, would require additional\n    //  specialized Shadow DOM support, and would require Tabbable's multi-container support\n    //  to look at those containers in document position order rather than user-provided\n    //  order (as they are treated in Focus-trap, for legacy reasons). See discussion on\n    //  https://github.com/focus-trap/focus-trap/issues/375 for more details.\n    if (state.containerGroups.find(function (g) {\n      return g.posTabIndexesFound;\n    }) && state.containerGroups.length > 1) {\n      throw new Error(\"At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.\");\n    }\n  };\n\n  /**\n   * Gets the current activeElement. If it's a web-component and has open shadow-root\n   * it will recursively search inside shadow roots for the \"true\" activeElement.\n   *\n   * @param {Document | ShadowRoot} el\n   *\n   * @returns {HTMLElement} The element that currently has the focus\n   **/\n  var _getActiveElement = function getActiveElement(el) {\n    var activeElement = el.activeElement;\n    if (!activeElement) {\n      return;\n    }\n    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {\n      return _getActiveElement(activeElement.shadowRoot);\n    }\n    return activeElement;\n  };\n  var _tryFocus = function tryFocus(node) {\n    if (node === false) {\n      return;\n    }\n    if (node === _getActiveElement(document)) {\n      return;\n    }\n    if (!node || !node.focus) {\n      _tryFocus(getInitialFocusNode());\n      return;\n    }\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    // NOTE: focus() API does not trigger focusIn event so set MRU node manually\n    state.mostRecentlyFocusedNode = node;\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus', previousActiveElement);\n    return node ? node : node === false ? false : previousActiveElement;\n  };\n\n  /**\n   * Finds the next node (in either direction) where focus should move according to a\n   *  keyboard focus-in event.\n   * @param {Object} params\n   * @param {Node} [params.target] Known target __from which__ to navigate, if any.\n   * @param {KeyboardEvent|FocusEvent} [params.event] Event to use if `target` isn't known (event\n   *  will be used to determine the `target`). Ignored if `target` is specified.\n   * @param {boolean} [params.isBackward] True if focus should move backward.\n   * @returns {Node|undefined} The next node, or `undefined` if a next node couldn't be\n   *  determined given the current state of the trap.\n   */\n  var findNextNavNode = function findNextNavNode(_ref2) {\n    var target = _ref2.target,\n      event = _ref2.event,\n      _ref2$isBackward = _ref2.isBackward,\n      isBackward = _ref2$isBackward === void 0 ? false : _ref2$isBackward;\n    target = target || getActualTarget(event);\n    updateTabbableNodes();\n    var destinationNode = null;\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's focusable\n      //  with tabIndex='-1' and was given initial focus\n      var containerIndex = findContainerIndex(target, event);\n      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back into...\n        if (isBackward) {\n          // ...the last node in the last group\n          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (isBackward) {\n        // REVERSE\n\n        // is the target the first tabbable node in a group?\n        var startOfGroupIndex = findIndex(state.tabbableGroups, function (_ref3) {\n          var firstTabbableNode = _ref3.firstTabbableNode;\n          return target === firstTabbableNode;\n        });\n        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {\n          // an exception case where the target is either the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n          var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target, false);\n        }\n      } else {\n        // FORWARD\n\n        // is the target the last tabbable node in a group?\n        var lastOfGroupIndex = findIndex(state.tabbableGroups, function (_ref4) {\n          var lastTabbableNode = _ref4.lastTabbableNode;\n          return target === lastTabbableNode;\n        });\n        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {\n          // an exception case where the target is the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n          destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target);\n        }\n      }\n    } else {\n      // no groups available\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n    return destinationNode;\n  };\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  var checkPointerDown = function checkPointerDown(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target, e) >= 0) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked (and if not focusable, to \"nothing\"); by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node), whether the\n        //  outside click was on a focusable node or not\n        returnFocus: config.returnFocusOnDeactivate\n      });\n      return;\n    }\n\n    // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    }\n\n    // otherwise, prevent the click\n    e.preventDefault();\n  };\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  // NOTE: the focusIn event is NOT cancelable, so if focus escapes, it may cause unexpected\n  //  scrolling if the node that got focused was out of view; there's nothing we can do to\n  //  prevent that from happening by the time we discover that focus escaped\n  var checkFocusIn = function checkFocusIn(event) {\n    var target = getActualTarget(event);\n    var targetContained = findContainerIndex(target, event) >= 0;\n\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      event.stopImmediatePropagation();\n\n      // focus will escape if the MRU node had a positive tab index and user tried to nav forward;\n      //  it will also escape if the MRU node had a 0 tab index and user tried to nav backward\n      //  toward a node with a positive tab index\n      var nextNode; // next node to focus, if we find one\n      var navAcrossContainers = true;\n      if (state.mostRecentlyFocusedNode) {\n        if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {\n          // MRU container index must be >=0 otherwise we wouldn't have it as an MRU node...\n          var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);\n          // there MAY not be any tabbable nodes in the container if there are at least 2 containers\n          //  and the MRU node is focusable but not tabbable (focus-trap requires at least 1 container\n          //  with at least one tabbable node in order to function, so this could be the other container\n          //  with nothing tabbable in it)\n          var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;\n          if (tabbableNodes.length > 0) {\n            // MRU tab index MAY not be found if the MRU node is focusable but not tabbable\n            var mruTabIdx = tabbableNodes.findIndex(function (node) {\n              return node === state.mostRecentlyFocusedNode;\n            });\n            if (mruTabIdx >= 0) {\n              if (config.isKeyForward(state.recentNavEvent)) {\n                if (mruTabIdx + 1 < tabbableNodes.length) {\n                  nextNode = tabbableNodes[mruTabIdx + 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              } else {\n                if (mruTabIdx - 1 >= 0) {\n                  nextNode = tabbableNodes[mruTabIdx - 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              }\n              // else, don't find in container order without considering direction too\n            }\n          }\n          // else, no tabbable nodes in that container (which means we must have at least one other\n          //  container with at least one tabbable node in it, otherwise focus-trap would've thrown\n          //  an error the last time updateTabbableNodes() was run): find next node among all known\n          //  containers\n        } else {\n          // check to see if there's at least one tabbable node with a positive tab index inside\n          //  the trap because focus seems to escape when navigating backward from a tabbable node\n          //  with tabindex=0 when this is the case (instead of wrapping to the tabbable node with\n          //  the greatest positive tab index like it should)\n          if (!state.containerGroups.some(function (g) {\n            return g.tabbableNodes.some(function (n) {\n              return getTabIndex(n) > 0;\n            });\n          })) {\n            // no containers with tabbable nodes with positive tab indexes which means the focus\n            //  escaped for some other reason and we should just execute the fallback to the\n            //  MRU node or initial focus node, if any\n            navAcrossContainers = false;\n          }\n        }\n      } else {\n        // no MRU node means we're likely in some initial condition when the trap has just\n        //  been activated and initial focus hasn't been given yet, in which case we should\n        //  fall through to trying to focus the initial focus node, which is what should\n        //  happen below at this point in the logic\n        navAcrossContainers = false;\n      }\n      if (navAcrossContainers) {\n        nextNode = findNextNavNode({\n          // move FROM the MRU node, not event-related node (which will be the node that is\n          //  outside the trap causing the focus escape we're trying to fix)\n          target: state.mostRecentlyFocusedNode,\n          isBackward: config.isKeyBackward(state.recentNavEvent)\n        });\n      }\n      if (nextNode) {\n        _tryFocus(nextNode);\n      } else {\n        _tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n      }\n    }\n    state.recentNavEvent = undefined; // clear\n  };\n\n  // Hijack key nav events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  var checkKeyNav = function checkKeyNav(event) {\n    var isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    state.recentNavEvent = event;\n    var destinationNode = findNextNavNode({\n      event: event,\n      isBackward: isBackward\n    });\n    if (destinationNode) {\n      if (isTabEvent(event)) {\n        // since tab natively moves focus, we wouldn't have a destination node unless we\n        //  were on the edge of a container and had to move to the next/previous edge, in\n        //  which case we want to prevent default to keep the browser from moving focus\n        //  to where it normally would\n        event.preventDefault();\n      }\n      _tryFocus(destinationNode);\n    }\n    // else, let the browser take care of [shift+]tab and move the focus\n  };\n  var checkTabKey = function checkTabKey(event) {\n    if (config.isKeyForward(event) || config.isKeyBackward(event)) {\n      checkKeyNav(event, config.isKeyBackward(event));\n    }\n  };\n\n  // we use a different event phase for the Escape key to allow canceling the event and checking for this in escapeDeactivates\n  var checkEscapeKey = function checkEscapeKey(event) {\n    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {\n      event.preventDefault();\n      trap.deactivate();\n    }\n  };\n  var checkClick = function checkClick(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target, e) >= 0) {\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  };\n\n  //\n  // EVENT LISTENERS\n  //\n\n  var addListeners = function addListeners() {\n    if (!state.active) {\n      return;\n    }\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trapStack, trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {\n      _tryFocus(getInitialFocusNode());\n    }) : _tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkTabKey, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkEscapeKey);\n    return trap;\n  };\n  var removeListeners = function removeListeners() {\n    if (!state.active) {\n      return;\n    }\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkTabKey, true);\n    doc.removeEventListener('keydown', checkEscapeKey);\n    return trap;\n  };\n\n  //\n  // MUTATION OBSERVER\n  //\n\n  var checkDomRemoval = function checkDomRemoval(mutations) {\n    var isFocusedNodeRemoved = mutations.some(function (mutation) {\n      var removedNodes = Array.from(mutation.removedNodes);\n      return removedNodes.some(function (node) {\n        return node === state.mostRecentlyFocusedNode;\n      });\n    });\n\n    // If the currently focused is removed then browsers will move focus to the\n    // <body> element. If this happens, try to move focus back into the trap.\n    if (isFocusedNodeRemoved) {\n      _tryFocus(getInitialFocusNode());\n    }\n  };\n\n  // Use MutationObserver - if supported - to detect if focused node is removed\n  // from the DOM.\n  var mutationObserver = typeof window !== 'undefined' && 'MutationObserver' in window ? new MutationObserver(checkDomRemoval) : undefined;\n  var updateObservedNodes = function updateObservedNodes() {\n    if (!mutationObserver) {\n      return;\n    }\n    mutationObserver.disconnect();\n    if (state.active && !state.paused) {\n      state.containers.map(function (container) {\n        mutationObserver.observe(container, {\n          subtree: true,\n          childList: true\n        });\n      });\n    }\n  };\n\n  //\n  // TRAP DEFINITION\n  //\n\n  trap = {\n    get active() {\n      return state.active;\n    },\n    get paused() {\n      return state.paused;\n    },\n    activate: function activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n      var onActivate = getOption(activateOptions, 'onActivate');\n      var onPostActivate = getOption(activateOptions, 'onPostActivate');\n      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n      onActivate === null || onActivate === void 0 || onActivate();\n      var finishActivation = function finishActivation() {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n        addListeners();\n        updateObservedNodes();\n        onPostActivate === null || onPostActivate === void 0 || onPostActivate();\n      };\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n        return this;\n      }\n      finishActivation();\n      return this;\n    },\n    deactivate: function deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n      var options = _objectSpread2({\n        onDeactivate: config.onDeactivate,\n        onPostDeactivate: config.onPostDeactivate,\n        checkCanReturnFocus: config.checkCanReturnFocus\n      }, deactivateOptions);\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n      state.delayInitialFocusTimer = undefined;\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      updateObservedNodes();\n      activeFocusTraps.deactivateTrap(trapStack, trap);\n      var onDeactivate = getOption(options, 'onDeactivate');\n      var onPostDeactivate = getOption(options, 'onPostDeactivate');\n      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');\n      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');\n      onDeactivate === null || onDeactivate === void 0 || onDeactivate();\n      var finishDeactivation = function finishDeactivation() {\n        delay(function () {\n          if (returnFocus) {\n            _tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    },\n    pause: function pause(pauseOptions) {\n      if (state.paused || !state.active) {\n        return this;\n      }\n      var onPause = getOption(pauseOptions, 'onPause');\n      var onPostPause = getOption(pauseOptions, 'onPostPause');\n      state.paused = true;\n      onPause === null || onPause === void 0 || onPause();\n      removeListeners();\n      updateObservedNodes();\n      onPostPause === null || onPostPause === void 0 || onPostPause();\n      return this;\n    },\n    unpause: function unpause(unpauseOptions) {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n      var onUnpause = getOption(unpauseOptions, 'onUnpause');\n      var onPostUnpause = getOption(unpauseOptions, 'onPostUnpause');\n      state.paused = false;\n      onUnpause === null || onUnpause === void 0 || onUnpause();\n      updateTabbableNodes();\n      addListeners();\n      updateObservedNodes();\n      onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();\n      return this;\n    },\n    updateContainerElements: function updateContainerElements(containerElements) {\n      var elementsAsArray = [].concat(containerElements).filter(Boolean);\n      state.containers = elementsAsArray.map(function (element) {\n        return typeof element === 'string' ? doc.querySelector(element) : element;\n      });\n      if (state.active) {\n        updateTabbableNodes();\n      }\n      updateObservedNodes();\n      return this;\n    }\n  };\n\n  // initialize container elements\n  trap.updateContainerElements(elements);\n  return trap;\n};\n\n/**\n * Helper to set up the FocusTrap component.\n *\n * @param {FocusTrapComponent} component The FocusTrap component.\n * @param options\n */\nfunction connectFocusTrap(component, options) {\n    const { el } = component;\n    const focusTrapNode = options?.focusTrapEl || el;\n    if (!focusTrapNode) {\n        return;\n    }\n    const focusTrapOptions = {\n        clickOutsideDeactivates: true,\n        escapeDeactivates: false,\n        fallbackFocus: focusTrapNode,\n        setReturnFocus: (el) => {\n            focusElement(el);\n            return false;\n        },\n        ...options?.focusTrapOptions,\n        // the following options are not overridable\n        document: el.ownerDocument,\n        tabbableOptions,\n        trapStack: focusTrapStack,\n    };\n    component.focusTrap = createFocusTrap(focusTrapNode, focusTrapOptions);\n}\n/**\n * Helper to activate the FocusTrap component.\n *\n * @param {FocusTrapComponent} component The FocusTrap component.\n * @param [options] The FocusTrap activate options.\n */\nfunction activateFocusTrap(component, options) {\n    if (!component.focusTrapDisabled) {\n        component.focusTrap?.activate(options);\n    }\n}\n/**\n * Helper to deactivate the FocusTrap component.\n *\n * @param {FocusTrapComponent} component The FocusTrap component.\n * @param [options] The FocusTrap deactivate options.\n */\nfunction deactivateFocusTrap(component, options) {\n    component.focusTrap?.deactivate(options);\n}\n/**\n * Helper to update the element(s) that are used within the FocusTrap component.\n *\n * @param {FocusTrapComponent} component The FocusTrap component.\n * @example\n * const modal = document.querySelector(\"calcite-modal\");\n * const input = document.createElement(\"calcite-input\");\n * content.appendChild(input);\n * await input.componentOnReady();\n * await modal.updateFocusTrapElements();\n * requestAnimationFrame(() => input.setFocus());\n */\nfunction updateFocusTrapElements(component) {\n    component.focusTrap?.updateContainerElements(component.el);\n}\n\nexport { activateFocusTrap as a, connectFocusTrap as c, deactivateFocusTrap as d, updateFocusTrapElements as u };\n\n//# sourceMappingURL=focusTrapComponent.js.map","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.\n * v2.13.2\n */\nfunction getRoundRobinIndex(index, total) {\n    return (index + total) % total;\n}\n\nexport { getRoundRobinIndex as g };\n\n//# sourceMappingURL=array.js.map","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.\n * v2.13.2\n */\nimport { h } from '@stencil/core/internal/client';\n\nfunction constrainHeadingLevel(level) {\n    return Math.min(Math.max(Math.ceil(level), 1), 6);\n}\nconst Heading = (props, children) => {\n    const HeadingTag = props.level ? `h${props.level}` : \"div\";\n    delete props.level;\n    return (h(HeadingTag, { class: props.class, key: props.key }, children));\n};\n\nexport { Heading as H, constrainHeadingLevel as c };\n\n//# sourceMappingURL=Heading.js.map","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.\n * v2.13.2\n */\nimport { proxyCustomElement, HTMLElement, createEvent, forceUpdate, h, Host } from '@stencil/core/internal/client';\nimport { f as filterValidFlipPlacements, c as connectFloatingUI, d as defaultOffsetDistance, a as disconnectFloatingUI, r as reposition, F as FloatingCSS } from './floating-ui.js';\nimport { d as deactivateFocusTrap, a as activateFocusTrap, c as connectFocusTrap, u as updateFocusTrapElements } from './focusTrapComponent.js';\nimport { i as isKeyboardTriggeredClick, t as toAriaBoolean, f as focusFirstTabbable, q as queryElementRoots } from './dom.js';\nimport { g as guid } from './guid.js';\nimport { o as onToggleOpenCloseComponent } from './openCloseComponent.js';\nimport { H as Heading } from './Heading.js';\nimport { c as connectLocalized, d as disconnectLocalized } from './locale.js';\nimport { u as updateMessages, c as connectMessages, s as setUpMessages, d as disconnectMessages } from './t9n.js';\nimport { s as setUpLoadableComponent, a as setComponentLoaded, c as componentFocusable } from './loadable.js';\nimport { c as createObserver } from './observers.js';\nimport { F as FloatingArrow } from './FloatingArrow.js';\nimport { g as getIconScale } from './component.js';\nimport { i as isActivationKey } from './key.js';\nimport { d as defineCustomElement$3 } from './action.js';\nimport { d as defineCustomElement$2 } from './icon.js';\nimport { d as defineCustomElement$1 } from './loader.js';\n\nclass PopoverManager {\n    constructor() {\n        // --------------------------------------------------------------------------\n        //\n        //  Private Properties\n        //\n        // --------------------------------------------------------------------------\n        this.registeredElements = new Map();\n        this.registeredElementCount = 0;\n        // --------------------------------------------------------------------------\n        //\n        //  Private Methods\n        //\n        // --------------------------------------------------------------------------\n        this.queryPopover = (composedPath) => {\n            const { registeredElements } = this;\n            const registeredElement = composedPath.find((pathEl) => registeredElements.has(pathEl));\n            return registeredElements.get(registeredElement);\n        };\n        this.togglePopovers = (event) => {\n            const composedPath = event.composedPath();\n            const togglePopover = this.queryPopover(composedPath);\n            if (togglePopover && !togglePopover.triggerDisabled) {\n                togglePopover.open = !togglePopover.open;\n            }\n            Array.from(this.registeredElements.values())\n                .filter((popover) => popover !== togglePopover && popover.autoClose && popover.open && !composedPath.includes(popover))\n                .forEach((popover) => (popover.open = false));\n        };\n        this.keyDownHandler = (event) => {\n            if (event.defaultPrevented) {\n                return;\n            }\n            if (event.key === \"Escape\") {\n                this.closeAllPopovers();\n            }\n            else if (isActivationKey(event.key)) {\n                this.togglePopovers(event);\n            }\n        };\n        this.clickHandler = (event) => {\n            if (isKeyboardTriggeredClick(event)) {\n                return;\n            }\n            this.togglePopovers(event);\n        };\n    }\n    // --------------------------------------------------------------------------\n    //\n    //  Public Methods\n    //\n    // --------------------------------------------------------------------------\n    registerElement(referenceEl, popover) {\n        this.registeredElementCount++;\n        this.registeredElements.set(referenceEl, popover);\n        if (this.registeredElementCount === 1) {\n            this.addListeners();\n        }\n    }\n    unregisterElement(referenceEl) {\n        if (this.registeredElements.delete(referenceEl)) {\n            this.registeredElementCount--;\n        }\n        if (this.registeredElementCount === 0) {\n            this.removeListeners();\n        }\n    }\n    closeAllPopovers() {\n        Array.from(this.registeredElements.values()).forEach((popover) => (popover.open = false));\n    }\n    addListeners() {\n        window.addEventListener(\"click\", this.clickHandler);\n        window.addEventListener(\"keydown\", this.keyDownHandler);\n    }\n    removeListeners() {\n        window.removeEventListener(\"click\", this.clickHandler);\n        window.removeEventListener(\"keydown\", this.keyDownHandler);\n    }\n}\n\nconst CSS = {\n    container: \"container\",\n    imageContainer: \"image-container\",\n    closeButtonContainer: \"close-button-container\",\n    closeButton: \"close-button\",\n    content: \"content\",\n    hasHeader: \"has-header\",\n    header: \"header\",\n    headerContainer: \"headerContainer\",\n    headerContent: \"header-content\",\n    heading: \"heading\",\n};\nconst defaultPopoverPlacement = \"auto\";\nconst ARIA_CONTROLS = \"aria-controls\";\nconst ARIA_EXPANDED = \"aria-expanded\";\n\nconst popoverCss = \":host{--calcite-floating-ui-z-index:var(--calcite-popover-z-index, var(--calcite-z-index-popup));display:block;position:absolute;z-index:var(--calcite-floating-ui-z-index)}.calcite-floating-ui-anim{position:relative;transition:var(--calcite-floating-ui-transition);transition-property:inset, left, opacity;opacity:0;box-shadow:0 0 16px 0 rgba(0, 0, 0, 0.16);z-index:var(--calcite-z-index);border-radius:0.25rem}:host([data-placement^=bottom]) .calcite-floating-ui-anim{inset-block-start:-5px}:host([data-placement^=top]) .calcite-floating-ui-anim{inset-block-start:5px}:host([data-placement^=left]) .calcite-floating-ui-anim{left:5px}:host([data-placement^=right]) .calcite-floating-ui-anim{left:-5px}:host([data-placement]) .calcite-floating-ui-anim--active{opacity:1;inset-block:0;left:0}:host([calcite-hydrated-hidden]){visibility:hidden !important;pointer-events:none}.calcite-floating-ui-arrow{pointer-events:none;position:absolute;z-index:calc(var(--calcite-z-index) * -1);fill:var(--calcite-color-foreground-1)}.calcite-floating-ui-arrow__stroke{stroke:var(--calcite-color-border-3)}:host([scale=s]) .heading{padding-inline:0.75rem;padding-block:0.5rem;font-size:var(--calcite-font-size--1);line-height:1.375}:host([scale=m]) .heading{padding-inline:1rem;padding-block:0.75rem;font-size:var(--calcite-font-size-0);line-height:1.375}:host([scale=l]) .heading{padding-inline:1.25rem;padding-block:1rem;font-size:var(--calcite-font-size-1);line-height:1.375}:host{pointer-events:none}:host([open]){pointer-events:initial}.calcite-floating-ui-anim{border-width:1px;border-style:solid;background-color:var(--calcite-popover-background-color, var(--calcite-color-foreground-1));border-color:var(--calcite-popover-border-color, var(--calcite-color-border-3));border-radius:var(--calcite-popover-corner-radius, var(--calcite-corner-radius-round))}.calcite-floating-ui-arrow{fill:var(--calcite-popover-background-color, var(--calcite-color-foreground-1))}.calcite-floating-ui-arrow__stroke{stroke:var(--calcite-popover-border-color, var(--calcite-color-border-3))}.header{display:flex;flex:1 1 auto;align-items:stretch;justify-content:flex-start;border-width:0px;border-block-end-width:1px;border-style:solid;border-block-end-color:var(--calcite-popover-border-color, var(--calcite-color-border-3))}.heading{margin:0px;display:block;flex:1 1 auto;align-self:center;white-space:normal;font-weight:var(--calcite-font-weight-medium);word-wrap:break-word;word-break:break-word;color:var(--calcite-popover-text-color, var(--calcite-color-text-1))}.headerContainer{position:relative;display:flex;block-size:100%;flex-direction:row;flex-wrap:nowrap;border-radius:0.25rem;color:var(--calcite-popover-text-color, var(--calcite-color-text-1))}.headerContainer.has-header{flex-direction:column}.content{display:flex;block-size:100%;inline-size:100%;flex-direction:column;flex-wrap:nowrap;align-self:center;word-wrap:break-word;word-break:break-word}.close-button-container{display:flex;overflow:hidden;flex:0 0 auto;border-start-end-radius:var(--calcite-popover-corner-radius, var(--calcite-corner-radius-round));border-end-end-radius:var(--calcite-popover-corner-radius, var(--calcite-corner-radius-round));--calcite-action-corner-radius-start-end:var(--calcite-popover-corner-radius, var(--calcite-corner-radius-sharp));--calcite-action-corner-radius-end-end:var(--calcite-popover-corner-radius, var(--calcite-corner-radius-sharp))}::slotted(calcite-panel),::slotted(calcite-flow){block-size:100%}:host([hidden]){display:none}[hidden]{display:none}\";\nconst CalcitePopoverStyle0 = popoverCss;\n\nconst manager = new PopoverManager();\nconst Popover = /*@__PURE__*/ proxyCustomElement(class Popover extends HTMLElement {\n    constructor() {\n        super();\n        this.__registerHost();\n        this.__attachShadow();\n        this.calcitePopoverBeforeClose = createEvent(this, \"calcitePopoverBeforeClose\", 6);\n        this.calcitePopoverClose = createEvent(this, \"calcitePopoverClose\", 6);\n        this.calcitePopoverBeforeOpen = createEvent(this, \"calcitePopoverBeforeOpen\", 6);\n        this.calcitePopoverOpen = createEvent(this, \"calcitePopoverOpen\", 6);\n        this.mutationObserver = createObserver(\"mutation\", () => this.updateFocusTrapElements());\n        this.guid = `calcite-popover-${guid()}`;\n        this.openTransitionProp = \"opacity\";\n        this.hasLoaded = false;\n        // --------------------------------------------------------------------------\n        //\n        //  Private Methods\n        //\n        // --------------------------------------------------------------------------\n        this.setTransitionEl = (el) => {\n            this.transitionEl = el;\n        };\n        this.setFilteredPlacements = () => {\n            const { el, flipPlacements } = this;\n            this.filteredFlipPlacements = flipPlacements\n                ? filterValidFlipPlacements(flipPlacements, el)\n                : null;\n        };\n        this.setUpReferenceElement = (warn = true) => {\n            this.removeReferences();\n            this.effectiveReferenceElement = this.getReferenceElement();\n            connectFloatingUI(this, this.effectiveReferenceElement, this.el);\n            const { el, referenceElement, effectiveReferenceElement } = this;\n            if (warn && referenceElement && !effectiveReferenceElement) {\n                console.warn(`${el.tagName}: reference-element id \"${referenceElement}\" was not found.`, {\n                    el,\n                });\n            }\n            this.addReferences();\n        };\n        this.getId = () => {\n            return this.el.id || this.guid;\n        };\n        this.setExpandedAttr = () => {\n            const { effectiveReferenceElement, open } = this;\n            if (!effectiveReferenceElement) {\n                return;\n            }\n            if (\"setAttribute\" in effectiveReferenceElement) {\n                effectiveReferenceElement.setAttribute(ARIA_EXPANDED, toAriaBoolean(open));\n            }\n        };\n        this.addReferences = () => {\n            const { effectiveReferenceElement } = this;\n            if (!effectiveReferenceElement) {\n                return;\n            }\n            const id = this.getId();\n            if (\"setAttribute\" in effectiveReferenceElement) {\n                effectiveReferenceElement.setAttribute(ARIA_CONTROLS, id);\n            }\n            manager.registerElement(effectiveReferenceElement, this.el);\n            this.setExpandedAttr();\n        };\n        this.removeReferences = () => {\n            const { effectiveReferenceElement } = this;\n            if (!effectiveReferenceElement) {\n                return;\n            }\n            if (\"removeAttribute\" in effectiveReferenceElement) {\n                effectiveReferenceElement.removeAttribute(ARIA_CONTROLS);\n                effectiveReferenceElement.removeAttribute(ARIA_EXPANDED);\n            }\n            manager.unregisterElement(effectiveReferenceElement);\n        };\n        this.hide = () => {\n            this.open = false;\n        };\n        this.storeArrowEl = (el) => {\n            this.arrowEl = el;\n            this.reposition(true);\n        };\n        this.autoClose = false;\n        this.closable = false;\n        this.flipDisabled = false;\n        this.focusTrapDisabled = false;\n        this.pointerDisabled = false;\n        this.flipPlacements = undefined;\n        this.heading = undefined;\n        this.headingLevel = undefined;\n        this.label = undefined;\n        this.messageOverrides = undefined;\n        this.messages = undefined;\n        this.offsetDistance = defaultOffsetDistance;\n        this.offsetSkidding = 0;\n        this.open = false;\n        this.overlayPositioning = \"absolute\";\n        this.placement = defaultPopoverPlacement;\n        this.referenceElement = undefined;\n        this.scale = \"m\";\n        this.triggerDisabled = false;\n        this.effectiveLocale = \"\";\n        this.floatingLayout = \"vertical\";\n        this.effectiveReferenceElement = undefined;\n        this.defaultMessages = undefined;\n    }\n    handleFocusTrapDisabled(focusTrapDisabled) {\n        if (!this.open) {\n            return;\n        }\n        focusTrapDisabled ? deactivateFocusTrap(this) : activateFocusTrap(this);\n    }\n    flipPlacementsHandler() {\n        this.setFilteredPlacements();\n        this.reposition(true);\n    }\n    onMessagesChange() {\n        /* wired up by t9n util */\n    }\n    offsetDistanceOffsetHandler() {\n        this.reposition(true);\n    }\n    offsetSkiddingHandler() {\n        this.reposition(true);\n    }\n    openHandler() {\n        onToggleOpenCloseComponent(this);\n        this.reposition(true);\n        this.setExpandedAttr();\n    }\n    overlayPositioningHandler() {\n        this.reposition(true);\n    }\n    placementHandler() {\n        this.reposition(true);\n    }\n    referenceElementHandler() {\n        this.setUpReferenceElement();\n        this.reposition(true);\n    }\n    effectiveLocaleChange() {\n        updateMessages(this, this.effectiveLocale);\n    }\n    // --------------------------------------------------------------------------\n    //\n    //  Lifecycle\n    //\n    // --------------------------------------------------------------------------\n    connectedCallback() {\n        this.mutationObserver?.observe(this.el, { childList: true, subtree: true });\n        this.setFilteredPlacements();\n        connectLocalized(this);\n        connectMessages(this);\n        connectFocusTrap(this);\n        // we set up the ref element in the next frame to ensure PopoverManager\n        // event handlers are invoked after connect (mainly for `components` output target)\n        requestAnimationFrame(() => this.setUpReferenceElement(this.hasLoaded));\n    }\n    async componentWillLoad() {\n        await setUpMessages(this);\n        setUpLoadableComponent(this);\n    }\n    componentDidLoad() {\n        setComponentLoaded(this);\n        if (this.referenceElement && !this.effectiveReferenceElement) {\n            this.setUpReferenceElement();\n        }\n        if (this.open) {\n            onToggleOpenCloseComponent(this);\n        }\n        this.hasLoaded = true;\n    }\n    disconnectedCallback() {\n        this.mutationObserver?.disconnect();\n        this.removeReferences();\n        disconnectLocalized(this);\n        disconnectMessages(this);\n        disconnectFloatingUI(this, this.effectiveReferenceElement, this.el);\n        deactivateFocusTrap(this);\n    }\n    // --------------------------------------------------------------------------\n    //\n    //  Public Methods\n    //\n    // --------------------------------------------------------------------------\n    /**\n     * Updates the position of the component.\n     *\n     * @param delayed\n     */\n    async reposition(delayed = false) {\n        const { el, effectiveReferenceElement, placement, overlayPositioning, flipDisabled, filteredFlipPlacements, offsetDistance, offsetSkidding, arrowEl, } = this;\n        return reposition(this, {\n            floatingEl: el,\n            referenceEl: effectiveReferenceElement,\n            overlayPositioning,\n            placement,\n            flipDisabled,\n            flipPlacements: filteredFlipPlacements,\n            offsetDistance,\n            offsetSkidding,\n            arrowEl,\n            type: \"popover\",\n        }, delayed);\n    }\n    /**\n     * Sets focus on the component's first focusable element.\n     */\n    async setFocus() {\n        await componentFocusable(this);\n        forceUpdate(this.el);\n        focusFirstTabbable(this.el);\n    }\n    /**\n     * Updates the element(s) that are used within the focus-trap of the component.\n     */\n    async updateFocusTrapElements() {\n        updateFocusTrapElements(this);\n    }\n    getReferenceElement() {\n        const { referenceElement, el } = this;\n        return ((typeof referenceElement === \"string\"\n            ? queryElementRoots(el, { id: referenceElement })\n            : referenceElement) || null);\n    }\n    onBeforeOpen() {\n        this.calcitePopoverBeforeOpen.emit();\n    }\n    onOpen() {\n        this.calcitePopoverOpen.emit();\n        activateFocusTrap(this);\n    }\n    onBeforeClose() {\n        this.calcitePopoverBeforeClose.emit();\n    }\n    onClose() {\n        this.calcitePopoverClose.emit();\n        deactivateFocusTrap(this);\n    }\n    // --------------------------------------------------------------------------\n    //\n    //  Render Methods\n    //\n    // --------------------------------------------------------------------------\n    renderCloseButton() {\n        const { messages, closable } = this;\n        return closable ? (h(\"div\", { class: CSS.closeButtonContainer, key: CSS.closeButtonContainer }, h(\"calcite-action\", { appearance: \"transparent\", class: CSS.closeButton, onClick: this.hide, ref: (closeButtonEl) => (this.closeButtonEl = closeButtonEl), scale: this.scale, text: messages.close }, h(\"calcite-icon\", { icon: \"x\", scale: getIconScale(this.scale) })))) : null;\n    }\n    renderHeader() {\n        const { heading, headingLevel } = this;\n        const headingNode = heading ? (h(Heading, { class: CSS.heading, level: headingLevel }, heading)) : null;\n        return headingNode ? (h(\"div\", { class: CSS.header, key: CSS.header }, headingNode, this.renderCloseButton())) : null;\n    }\n    render() {\n        const { effectiveReferenceElement, heading, label, open, pointerDisabled, floatingLayout } = this;\n        const displayed = effectiveReferenceElement && open;\n        const hidden = !displayed;\n        const arrowNode = !pointerDisabled ? (h(FloatingArrow, { floatingLayout: floatingLayout, key: \"floating-arrow\", ref: this.storeArrowEl })) : null;\n        return (h(Host, { key: 'a563d48090d6e6c0c138023e169667834f657c4c', \"aria-hidden\": toAriaBoolean(hidden), \"aria-label\": label, \"aria-live\": \"polite\", \"calcite-hydrated-hidden\": hidden, id: this.getId(), role: \"dialog\" }, h(\"div\", { key: '73053dbdce2cfc68fcd42667089d611e81010955', class: {\n                [CSS.container]: true,\n                [FloatingCSS.animation]: true,\n                [FloatingCSS.animationActive]: displayed,\n            }, ref: this.setTransitionEl }, arrowNode, h(\"div\", { key: '1fbcd45ee42b10a67881ced74db2db051231c94d', class: {\n                [CSS.hasHeader]: !!heading,\n                [CSS.headerContainer]: true,\n            } }, this.renderHeader(), h(\"div\", { key: '522abe801b98787863aac14d990b948d2d286156', class: CSS.content }, h(\"slot\", { key: '022a8f690288acdbac4ec1b3eccf807ffe382d5d' })), !heading ? this.renderCloseButton() : null))));\n    }\n    static get assetsDirs() { return [\"assets\"]; }\n    get el() { return this; }\n    static get watchers() { return {\n        \"focusTrapDisabled\": [\"handleFocusTrapDisabled\"],\n        \"flipPlacements\": [\"flipPlacementsHandler\"],\n        \"messageOverrides\": [\"onMessagesChange\"],\n        \"offsetDistance\": [\"offsetDistanceOffsetHandler\"],\n        \"offsetSkidding\": [\"offsetSkiddingHandler\"],\n        \"open\": [\"openHandler\"],\n        \"overlayPositioning\": [\"overlayPositioningHandler\"],\n        \"placement\": [\"placementHandler\"],\n        \"referenceElement\": [\"referenceElementHandler\"],\n        \"effectiveLocale\": [\"effectiveLocaleChange\"]\n    }; }\n    static get style() { return CalcitePopoverStyle0; }\n}, [1, \"calcite-popover\", {\n        \"autoClose\": [516, \"auto-close\"],\n        \"closable\": [516],\n        \"flipDisabled\": [516, \"flip-disabled\"],\n        \"focusTrapDisabled\": [516, \"focus-trap-disabled\"],\n        \"pointerDisabled\": [516, \"pointer-disabled\"],\n        \"flipPlacements\": [16],\n        \"heading\": [1],\n        \"headingLevel\": [514, \"heading-level\"],\n        \"label\": [1],\n        \"messageOverrides\": [1040],\n        \"messages\": [1040],\n        \"offsetDistance\": [514, \"offset-distance\"],\n        \"offsetSkidding\": [514, \"offset-skidding\"],\n        \"open\": [1540],\n        \"overlayPositioning\": [513, \"overlay-positioning\"],\n        \"placement\": [513],\n        \"referenceElement\": [1, \"reference-element\"],\n        \"scale\": [513],\n        \"triggerDisabled\": [516, \"trigger-disabled\"],\n        \"effectiveLocale\": [32],\n        \"floatingLayout\": [32],\n        \"effectiveReferenceElement\": [32],\n        \"defaultMessages\": [32],\n        \"reposition\": [64],\n        \"setFocus\": [64],\n        \"updateFocusTrapElements\": [64]\n    }, undefined, {\n        \"focusTrapDisabled\": [\"handleFocusTrapDisabled\"],\n        \"flipPlacements\": [\"flipPlacementsHandler\"],\n        \"messageOverrides\": [\"onMessagesChange\"],\n        \"offsetDistance\": [\"offsetDistanceOffsetHandler\"],\n        \"offsetSkidding\": [\"offsetSkiddingHandler\"],\n        \"open\": [\"openHandler\"],\n        \"overlayPositioning\": [\"overlayPositioningHandler\"],\n        \"placement\": [\"placementHandler\"],\n        \"referenceElement\": [\"referenceElementHandler\"],\n        \"effectiveLocale\": [\"effectiveLocaleChange\"]\n    }]);\nfunction defineCustomElement() {\n    if (typeof customElements === \"undefined\") {\n        return;\n    }\n    const components = [\"calcite-popover\", \"calcite-action\", \"calcite-icon\", \"calcite-loader\"];\n    components.forEach(tagName => { switch (tagName) {\n        case \"calcite-popover\":\n            if (!customElements.get(tagName)) {\n                customElements.define(tagName, Popover);\n            }\n            break;\n        case \"calcite-action\":\n            if (!customElements.get(tagName)) {\n                defineCustomElement$3();\n            }\n            break;\n        case \"calcite-icon\":\n            if (!customElements.get(tagName)) {\n                defineCustomElement$2();\n            }\n            break;\n        case \"calcite-loader\":\n            if (!customElements.get(tagName)) {\n                defineCustomElement$1();\n            }\n            break;\n    } });\n}\ndefineCustomElement();\n\nexport { Popover as P, defineCustomElement as d };\n\n//# sourceMappingURL=popover.js.map","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.\n * v2.13.2\n */\nimport { proxyCustomElement, HTMLElement, createEvent, h, Fragment } from '@stencil/core/internal/client';\nimport { g as getRoundRobinIndex } from './array.js';\nimport { t as toAriaBoolean, e as focusElement } from './dom.js';\nimport { g as guid } from './guid.js';\nimport { i as isActivationKey } from './key.js';\nimport { s as setUpLoadableComponent, a as setComponentLoaded, c as componentFocusable } from './loadable.js';\nimport { d as defineCustomElement$4 } from './action.js';\nimport { d as defineCustomElement$3 } from './icon.js';\nimport { d as defineCustomElement$2 } from './loader.js';\nimport { d as defineCustomElement$1 } from './popover.js';\n\nconst CSS = {\n    menu: \"menu\",\n    defaultTrigger: \"default-trigger\",\n};\nconst SLOTS = {\n    tooltip: \"tooltip\",\n    trigger: \"trigger\",\n};\nconst ICONS = {\n    menu: \"ellipsis\",\n};\nconst activeAttr = \"data-active\";\n\nconst actionMenuCss = \":host{box-sizing:border-box;display:flex;flex-direction:column;font-size:var(--calcite-font-size-1)}::slotted(calcite-action-group:not(:last-of-type)){border-block-end-width:var(--calcite-border-width-sm)}.default-trigger{position:relative;block-size:100%;flex:0 1 auto;align-self:stretch}slot[name=trigger]::slotted(calcite-action),calcite-action::slotted([slot=trigger]){position:relative;block-size:100%;flex:0 1 auto;align-self:stretch}.menu{display:flex;max-block-size:45vh;flex-direction:column;flex-wrap:nowrap;overflow-y:auto;overflow-x:hidden;outline:2px solid transparent;outline-offset:2px;gap:var(--calcite-action-menu-items-space, 0)}:host([hidden]){display:none}[hidden]{display:none}\";\nconst CalciteActionMenuStyle0 = actionMenuCss;\n\nconst SUPPORTED_MENU_NAV_KEYS = [\"ArrowUp\", \"ArrowDown\", \"End\", \"Home\"];\nconst ActionMenu = /*@__PURE__*/ proxyCustomElement(class ActionMenu extends HTMLElement {\n    constructor() {\n        super();\n        this.__registerHost();\n        this.__attachShadow();\n        this.calciteActionMenuOpen = createEvent(this, \"calciteActionMenuOpen\", 6);\n        this.actionElements = [];\n        this.guid = `calcite-action-menu-${guid()}`;\n        this.menuId = `${this.guid}-menu`;\n        this.menuButtonId = `${this.guid}-menu-button`;\n        // --------------------------------------------------------------------------\n        //\n        //  Component Methods\n        //\n        // --------------------------------------------------------------------------\n        this.connectMenuButtonEl = () => {\n            const { menuButtonId, menuId, open, label } = this;\n            const menuButtonEl = this.slottedMenuButtonEl || this.defaultMenuButtonEl;\n            if (this.menuButtonEl === menuButtonEl) {\n                return;\n            }\n            this.disconnectMenuButtonEl();\n            this.menuButtonEl = menuButtonEl;\n            this.setTooltipReferenceElement();\n            if (!menuButtonEl) {\n                return;\n            }\n            menuButtonEl.active = open;\n            menuButtonEl.setAttribute(\"aria-controls\", menuId);\n            menuButtonEl.setAttribute(\"aria-expanded\", toAriaBoolean(open));\n            menuButtonEl.setAttribute(\"aria-haspopup\", \"true\");\n            if (!menuButtonEl.id) {\n                menuButtonEl.id = menuButtonId;\n            }\n            if (!menuButtonEl.label) {\n                menuButtonEl.label = label;\n            }\n            if (!menuButtonEl.text) {\n                menuButtonEl.text = label;\n            }\n            menuButtonEl.addEventListener(\"click\", this.menuButtonClick);\n            menuButtonEl.addEventListener(\"keydown\", this.menuButtonKeyDown);\n        };\n        this.disconnectMenuButtonEl = () => {\n            const { menuButtonEl } = this;\n            if (!menuButtonEl) {\n                return;\n            }\n            menuButtonEl.removeEventListener(\"click\", this.menuButtonClick);\n            menuButtonEl.removeEventListener(\"keydown\", this.menuButtonKeyDown);\n        };\n        this.setMenuButtonEl = (event) => {\n            const actions = event.target\n                .assignedElements({\n                flatten: true,\n            })\n                .filter((el) => el?.matches(\"calcite-action\"));\n            this.slottedMenuButtonEl = actions[0];\n            this.connectMenuButtonEl();\n        };\n        this.setDefaultMenuButtonEl = (el) => {\n            this.defaultMenuButtonEl = el;\n            this.connectMenuButtonEl();\n        };\n        // --------------------------------------------------------------------------\n        //\n        //  Private Methods\n        //\n        // --------------------------------------------------------------------------\n        this.handleCalciteActionClick = () => {\n            this.open = false;\n            this.setFocus();\n        };\n        this.menuButtonClick = () => {\n            this.toggleOpen();\n        };\n        this.updateTooltip = (event) => {\n            const tooltips = event.target\n                .assignedElements({\n                flatten: true,\n            })\n                .filter((el) => el?.matches(\"calcite-tooltip\"));\n            this.tooltipEl = tooltips[0];\n            this.setTooltipReferenceElement();\n        };\n        this.setTooltipReferenceElement = () => {\n            const { tooltipEl, expanded, menuButtonEl, open } = this;\n            if (tooltipEl) {\n                tooltipEl.referenceElement = !expanded && !open ? menuButtonEl : null;\n            }\n        };\n        this.updateAction = (action, index) => {\n            const { guid, activeMenuItemIndex } = this;\n            const id = `${guid}-action-${index}`;\n            action.tabIndex = -1;\n            action.setAttribute(\"role\", \"menuitem\");\n            if (!action.id) {\n                action.id = id;\n            }\n            // data attribute is used to style the \"activeMenuItemIndex\" action using token focus styling.\n            action.toggleAttribute(activeAttr, index === activeMenuItemIndex);\n        };\n        this.updateActions = (actions) => {\n            actions?.forEach(this.updateAction);\n        };\n        this.handleDefaultSlotChange = (event) => {\n            const actions = event.target\n                .assignedElements({\n                flatten: true,\n            })\n                .reduce((previousValue, currentValue) => {\n                if (currentValue?.matches(\"calcite-action\")) {\n                    previousValue.push(currentValue);\n                    return previousValue;\n                }\n                if (currentValue?.matches(\"calcite-action-group\")) {\n                    return previousValue.concat(Array.from(currentValue.querySelectorAll(\"calcite-action\")));\n                }\n                return previousValue;\n            }, []);\n            this.actionElements = actions.filter((action) => !action.disabled && !action.hidden);\n        };\n        this.menuButtonKeyDown = (event) => {\n            const { key } = event;\n            const { actionElements, activeMenuItemIndex, open } = this;\n            if (!actionElements.length) {\n                return;\n            }\n            if (isActivationKey(key)) {\n                event.preventDefault();\n                if (!open) {\n                    this.toggleOpen();\n                    return;\n                }\n                const action = actionElements[activeMenuItemIndex];\n                action ? action.click() : this.toggleOpen(false);\n            }\n            if (key === \"Tab\") {\n                this.open = false;\n                return;\n            }\n            if (key === \"Escape\") {\n                this.toggleOpen(false);\n                event.preventDefault();\n                return;\n            }\n            this.handleActionNavigation(event, key, actionElements);\n        };\n        this.handleActionNavigation = (event, key, actions) => {\n            if (!this.isValidKey(key, SUPPORTED_MENU_NAV_KEYS)) {\n                return;\n            }\n            event.preventDefault();\n            if (!this.open) {\n                this.toggleOpen();\n                if (key === \"Home\" || key === \"ArrowDown\") {\n                    this.activeMenuItemIndex = 0;\n                }\n                if (key === \"End\" || key === \"ArrowUp\") {\n                    this.activeMenuItemIndex = actions.length - 1;\n                }\n                return;\n            }\n            if (key === \"Home\") {\n                this.activeMenuItemIndex = 0;\n            }\n            if (key === \"End\") {\n                this.activeMenuItemIndex = actions.length - 1;\n            }\n            const currentIndex = this.activeMenuItemIndex;\n            if (key === \"ArrowUp\") {\n                this.activeMenuItemIndex = getRoundRobinIndex(Math.max(currentIndex - 1, -1), actions.length);\n            }\n            if (key === \"ArrowDown\") {\n                this.activeMenuItemIndex = getRoundRobinIndex(currentIndex + 1, actions.length);\n            }\n        };\n        this.toggleOpenEnd = () => {\n            this.setFocus();\n            this.el.removeEventListener(\"calcitePopoverOpen\", this.toggleOpenEnd);\n        };\n        this.toggleOpen = (value = !this.open) => {\n            this.el.addEventListener(\"calcitePopoverOpen\", this.toggleOpenEnd);\n            this.open = value;\n        };\n        this.handlePopoverOpen = () => {\n            this.open = true;\n        };\n        this.handlePopoverClose = () => {\n            this.open = false;\n        };\n        this.appearance = \"solid\";\n        this.expanded = false;\n        this.flipPlacements = undefined;\n        this.label = undefined;\n        this.open = false;\n        this.overlayPositioning = \"absolute\";\n        this.placement = \"auto\";\n        this.scale = undefined;\n        this.menuButtonEl = undefined;\n        this.activeMenuItemIndex = -1;\n    }\n    // --------------------------------------------------------------------------\n    //\n    //  Lifecycle\n    //\n    // --------------------------------------------------------------------------\n    connectedCallback() {\n        this.connectMenuButtonEl();\n    }\n    componentWillLoad() {\n        setUpLoadableComponent(this);\n    }\n    componentDidLoad() {\n        setComponentLoaded(this);\n    }\n    disconnectedCallback() {\n        this.disconnectMenuButtonEl();\n    }\n    expandedHandler() {\n        this.open = false;\n        this.setTooltipReferenceElement();\n    }\n    openHandler(open) {\n        this.activeMenuItemIndex = this.open ? 0 : -1;\n        if (this.menuButtonEl) {\n            this.menuButtonEl.active = open;\n        }\n        this.calciteActionMenuOpen.emit();\n        this.setTooltipReferenceElement();\n    }\n    activeMenuItemIndexHandler() {\n        this.updateActions(this.actionElements);\n    }\n    // --------------------------------------------------------------------------\n    //\n    //  Methods\n    //\n    // --------------------------------------------------------------------------\n    /** Sets focus on the component. */\n    async setFocus() {\n        await componentFocusable(this);\n        return focusElement(this.menuButtonEl);\n    }\n    renderMenuButton() {\n        const { appearance, label, scale, expanded } = this;\n        const menuButtonSlot = (h(\"slot\", { name: SLOTS.trigger, onSlotchange: this.setMenuButtonEl }, h(\"calcite-action\", { appearance: appearance, class: CSS.defaultTrigger, icon: ICONS.menu, ref: this.setDefaultMenuButtonEl, scale: scale, text: label, textEnabled: expanded })));\n        return menuButtonSlot;\n    }\n    renderMenuItems() {\n        const { actionElements, activeMenuItemIndex, open, menuId, menuButtonEl, label, placement, overlayPositioning, flipPlacements, } = this;\n        const activeAction = actionElements[activeMenuItemIndex];\n        const activeDescendantId = activeAction?.id || null;\n        return (h(\"calcite-popover\", { autoClose: true, flipPlacements: flipPlacements, focusTrapDisabled: true, label: label, offsetDistance: 0, onCalcitePopoverClose: this.handlePopoverClose, onCalcitePopoverOpen: this.handlePopoverOpen, open: open, overlayPositioning: overlayPositioning, placement: placement, pointerDisabled: true, referenceElement: menuButtonEl }, h(\"div\", { \"aria-activedescendant\": activeDescendantId, \"aria-labelledby\": menuButtonEl?.id, class: CSS.menu, id: menuId, onClick: this.handleCalciteActionClick, role: \"menu\", tabIndex: -1 }, h(\"slot\", { onSlotchange: this.handleDefaultSlotChange }))));\n    }\n    render() {\n        return (h(Fragment, { key: 'd13aa4f3d43fb5651c0487ccfa456813f69955d2' }, this.renderMenuButton(), this.renderMenuItems(), h(\"slot\", { key: 'b63d187516c766db6a1b1db3df34050fdec9e6ce', name: SLOTS.tooltip, onSlotchange: this.updateTooltip })));\n    }\n    isValidKey(key, supportedKeys) {\n        return !!supportedKeys.find((k) => k === key);\n    }\n    get el() { return this; }\n    static get watchers() { return {\n        \"expanded\": [\"expandedHandler\"],\n        \"open\": [\"openHandler\"],\n        \"activeMenuItemIndex\": [\"activeMenuItemIndexHandler\"]\n    }; }\n    static get style() { return CalciteActionMenuStyle0; }\n}, [1, \"calcite-action-menu\", {\n        \"appearance\": [513],\n        \"expanded\": [516],\n        \"flipPlacements\": [16],\n        \"label\": [1],\n        \"open\": [1540],\n        \"overlayPositioning\": [513, \"overlay-positioning\"],\n        \"placement\": [513],\n        \"scale\": [513],\n        \"menuButtonEl\": [32],\n        \"activeMenuItemIndex\": [32],\n        \"setFocus\": [64]\n    }, undefined, {\n        \"expanded\": [\"expandedHandler\"],\n        \"open\": [\"openHandler\"],\n        \"activeMenuItemIndex\": [\"activeMenuItemIndexHandler\"]\n    }]);\nfunction defineCustomElement() {\n    if (typeof customElements === \"undefined\") {\n        return;\n    }\n    const components = [\"calcite-action-menu\", \"calcite-action\", \"calcite-icon\", \"calcite-loader\", \"calcite-popover\"];\n    components.forEach(tagName => { switch (tagName) {\n        case \"calcite-action-menu\":\n            if (!customElements.get(tagName)) {\n                customElements.define(tagName, ActionMenu);\n            }\n            break;\n        case \"calcite-action\":\n            if (!customElements.get(tagName)) {\n                defineCustomElement$4();\n            }\n            break;\n        case \"calcite-icon\":\n            if (!customElements.get(tagName)) {\n                defineCustomElement$3();\n            }\n            break;\n        case \"calcite-loader\":\n            if (!customElements.get(tagName)) {\n                defineCustomElement$2();\n            }\n            break;\n        case \"calcite-popover\":\n            if (!customElements.get(tagName)) {\n                defineCustomElement$1();\n            }\n            break;\n    } });\n}\ndefineCustomElement();\n\nexport { ActionMenu as A, SLOTS as S, defineCustomElement as d };\n\n//# sourceMappingURL=action-menu.js.map"],"names":["_defineProperty","e","r","_toPropertyKey","ownKeys","o","_objectSpread2","_toPrimitive","t","i","activeFocusTraps","trapStack","trap","activeTrap","trapIndex","isSelectableInput","node","isEscapeEvent","isTabEvent","isKeyForward","isKeyBackward","delay","fn","findIndex","arr","idx","value","valueOrHandler","_len","params","_key","getActualTarget","event","internalTrapStack","createFocusTrap","elements","userOptions","doc","config","state","getOption","configOverrideOptions","optionName","configOptionName","findContainerIndex","element","composedPath","_ref","container","tabbableNodes","getNodeForOption","optionValue","_len2","_key2","getInitialFocusNode","isFocusable","firstTabbableGroup","firstTabbableNode","updateTabbableNodes","tabbable","focusableNodes","focusable","lastTabbableNode","firstDomTabbableNode","isTabbable","lastDomTabbableNode","posTabIndexesFound","getTabIndex","forward","nodeIdx","el","group","g","_getActiveElement","activeElement","_tryFocus","getReturnFocusNode","previousActiveElement","findNextNavNode","_ref2","target","_ref2$isBackward","isBackward","destinationNode","containerIndex","containerGroup","startOfGroupIndex","_ref3","destinationGroupIndex","destinationGroup","lastOfGroupIndex","_ref4","_destinationGroupIndex","_destinationGroup","checkPointerDown","checkFocusIn","targetContained","nextNode","navAcrossContainers","mruContainerIdx","mruTabIdx","n","checkKeyNav","checkTabKey","checkEscapeKey","checkClick","addListeners","removeListeners","checkDomRemoval","mutations","isFocusedNodeRemoved","mutation","removedNodes","mutationObserver","updateObservedNodes","activateOptions","onActivate","onPostActivate","checkCanFocusTrap","finishActivation","deactivateOptions","options","onDeactivate","onPostDeactivate","checkCanReturnFocus","returnFocus","finishDeactivation","pauseOptions","onPause","onPostPause","unpauseOptions","onUnpause","onPostUnpause","containerElements","elementsAsArray","connectFocusTrap","component","focusTrapNode","focusTrapOptions","focusElement","tabbableOptions","focusTrapStack","activateFocusTrap","deactivateFocusTrap","updateFocusTrapElements","getRoundRobinIndex","index","total","Heading","props","children","HeadingTag","h","PopoverManager","registeredElements","registeredElement","pathEl","togglePopover","popover","isActivationKey","isKeyboardTriggeredClick","referenceEl","CSS","defaultPopoverPlacement","ARIA_CONTROLS","ARIA_EXPANDED","popoverCss","CalcitePopoverStyle0","manager","Popover","proxyCustomElement","HTMLElement","createEvent","createObserver","guid","flipPlacements","filterValidFlipPlacements","warn","connectFloatingUI","referenceElement","effectiveReferenceElement","open","toAriaBoolean","id","defaultOffsetDistance","focusTrapDisabled","onToggleOpenCloseComponent","updateMessages","connectLocalized","connectMessages","setUpMessages","setUpLoadableComponent","setComponentLoaded","disconnectLocalized","disconnectMessages","disconnectFloatingUI","delayed","placement","overlayPositioning","flipDisabled","filteredFlipPlacements","offsetDistance","offsetSkidding","arrowEl","reposition","componentFocusable","forceUpdate","focusFirstTabbable","queryElementRoots","messages","closable","closeButtonEl","getIconScale","heading","headingLevel","headingNode","label","pointerDisabled","floatingLayout","displayed","hidden","arrowNode","FloatingArrow","Host","FloatingCSS","defineCustomElement","tagName","defineCustomElement$3","defineCustomElement$2","defineCustomElement$1","SLOTS","ICONS","activeAttr","actionMenuCss","CalciteActionMenuStyle0","SUPPORTED_MENU_NAV_KEYS","ActionMenu","menuButtonId","menuId","menuButtonEl","actions","tooltips","tooltipEl","expanded","action","activeMenuItemIndex","previousValue","currentValue","key","actionElements","currentIndex","appearance","scale","activeDescendantId","Fragment","supportedKeys","k","defineCustomElement$4"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}