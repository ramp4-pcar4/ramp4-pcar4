const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./geometryEngineJSON-5ScVeRQz.js","./geometryEngineBase-8g0RzW7z.js","./_commonjsHelpers-DCkdB7M8.js","./json-Wa8cmqdu.js"])))=>i.map(i=>d[i]);
import{C as h}from"./enums-Dk3osxpS.js";import{aE as te,s as ee,n as se,iW as ie,b1 as re,bg as y,aR as gt}from"./main-7nqzKo04.js";import{ac as kt,ad as St,ae as Pt,a7 as T,af as oe,ag as zt,ah as It,ai as K,aj as wt,ak as ne,al as ae,am as ce,an as ue,ao as le,ap as he,aq as pe,ar as fe,o as C}from"./UpdateTracking2D-gmKWFf1k.js";import{c as At,i as Dt,l as de}from"./GeometryUtils-CtYxuPg5.js";import{a as tt,m as rt,t as L,R as xe,d as me,e as ye,G as _e,A as ge}from"./definitions-C0Jy3zs7.js";import{a as ke,i as Se,c as Pe}from"./TurboLine-CqvCmaHg.js";import{e as we,o as be,f as ve,g as Nt}from"./LabelMetric-BkQF-_9M.js";import{E as Yt}from"./utils-QWndGYJy.js";import{U as G,e as nt,w as at,n as ct,i as Bt}from"./enums-CmIX1y88.js";import"./earcut-Lltz9D9k.js";import{s as Te}from"./OptimizedFeature-CIptWNVu.js";import{n as Ee,b as Me,a as $e,c as ze}from"./Tile-M056j5jm.js";import{S as q}from"./vec2-DGVIkCvT.js";import{e as Q}from"./constants-F8oTIn7N.js";import{_ as Ie}from"./preload-helper-ExcqyqRp.js";const Ae=()=>se.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.meshWriterUtils"),De=0,Ne=100;function V(e,t){return[!!e?.minScale&&t.scaleToZoom(e.minScale)||De,!!e?.maxScale&&t.scaleToZoom(e.maxScale)||Ne]}function O(e){return 1<<e}function Z(e){let t=0;for(const[s,i]of e)i&&(t|=1<<s);return t}function g(e){let t;if(!e)return[0,0,0,0];if(typeof e=="string"){const n=te.fromString(e);if(!n)return Ae().errorOnce(new ee("mapview:mesh-processing","Unable to parse string into color",{color:e})),[0,0,0,0];t=n.toArray()}else t=e;const[s,i,r,o]=t;return[s*(o/255),i*(o/255),r*(o/255),o]}function Ye(e){switch(e){case"butt":case G.Butt:return nt.BUTT;case"round":case G.Round:return nt.ROUND;case"square":case G.Square:return nt.SQUARE}}function Be(e){switch(e){case"bevel":case at.Bevel:return ct.BEVEL;case"miter":case at.Miter:return ct.MITER;case"round":case at.Round:return ct.ROUND}}function ut(e,t){return Math.round(Math.min(Math.sqrt(e*t),255))}function j(e,t){return Math.round(e*t)/t}const Ge=96/72;let Le=class{static executeEffects(t,s,i,r){const o=Ge,n=kt(t);let a=new Pt(s);for(const c of t){const l=St(c);l&&(a=l.execute(a,c,o,i,r,n))}return a}static applyEffects(t,s,i){if(!t)return s;const r=kt(t);let o,n=new Pt(T.fromJSONCIM(s));for(const l of t){const u=St(l);u&&(n=u.execute(n,l,1,null,i,r))}const a=[];let c=null;for(;o=n.next();)a.push(...ie(o)),c=o.geometryType;return a.length===0||c===null?null:c==="esriGeometryPolygon"?{rings:a}:{paths:a}}},Gt=null;function mt(){return Gt}async function Fe(){Gt=await Ie(()=>import("./geometryEngineJSON-5ScVeRQz.js").then(e=>e.g),__vite__mapDeps([0,1,2,3]),import.meta.url)}function Lt(e){switch(e){case h.BYTE:case h.UNSIGNED_BYTE:return 1;case h.SHORT:case h.UNSIGNED_SHORT:case h.HALF_FLOAT:return 2;case h.FLOAT:case h.INT:case h.UNSIGNED_INT:return 4}}function Re(e){const t=[],s=[],i=[];for(const r of e){const o=Lt(r.type)*r.count;switch(o%2||o%4||4){case 4:t.push(r);continue;case 2:s.push(r);continue;case 1:i.push(r);continue;default:throw new Error("Found unexpected dataType byte count")}}return t.push(...s),t.push(...i),t}let Ce=class Ft{static fromVertexSpec(t,s){const{attributes:i,optionalAttributes:r}=t;let o,n,a;const c=[];for(const m in i){const _=i[m];_.pack==="position"?o={..._,name:m,offset:0}:_.pack==="id"?n={..._,name:m,offset:4}:m==="bitset"?a={..._,name:m,offset:7}:c.push({..._,name:m})}for(const m in r)if(s[m]===!0){const _=r[m];c.push({..._,name:m})}const l=Re(c),u=[];let x=8,d=1;for(const m of l)u.push({...m,offset:x}),x+=Lt(m.type)*m.count,m.packAlternating&&(d=Math.max(m.packAlternating.count,d));const f=Uint32Array.BYTES_PER_ELEMENT,p=x%f;return new Ft(o,n,a,u,x+(p?f-p:0),d)}constructor(t,s,i,r,o,n){this.position=t,this.id=s,this.bitset=i,this.standardAttributes=r,this.stride=o,this.packVertexCount=n,r.push(i),this._attributes=[t,s,i,...r]}get attributeLayout(){if(!this._attributeLayout){const t=we(this._attributes),s=this._attributes.map(i=>({name:i.name,count:i.count,offset:i.offset,type:i.type,packPrecisionFactor:i.packPrecisionFactor,normalized:i.normalized??!1}));this._attributeLayout={attributes:s,hash:t,stride:this.stride}}return this._attributeLayout}},Oe=class Rt{static fromVertexSpec(t,s){const i=Ce.fromVertexSpec(t,s);return new Rt(i)}constructor(t){this._spec=t,this._packed=new Uint8Array(this._spec.stride*this._spec.packVertexCount),this._packedU32View=new Uint32Array(this._packed.buffer),this._dataView=new DataView(this._packed.buffer)}get attributeLayout(){return this._spec.attributeLayout}get stride(){return this._spec.stride}writeVertex(t,s,i,r,o,n){for(let a=0;a<this._spec.packVertexCount;a++){const c=a*this._spec.stride;this._packPosition(i,r,c),this._packId(s,c);const l=this._spec.bitset;if(n){if(l.packTessellation){const u=l.packTessellation(n,o);this._pack(u,l,c)}for(const u of this._spec.standardAttributes)if(u.packTessellation!=null){const x=u.packTessellation(n,o);this._pack(x,u,c)}else if(u.packAlternating?.packTessellation){const x=u.packAlternating.packTessellation(n,o);for(let d=0;d<this._spec.packVertexCount;d++){const f=x[d];this._pack(f,u,d*this._spec.stride)}}}}t.vertexWriteRegion(this._packedU32View)}pack(t,s){for(const i of this._spec.standardAttributes)if(i.pack&&typeof i.pack!="string"){const r=i.pack(t,s);for(let o=0;o<this._spec.packVertexCount;o++)this._pack(r,i,o*this._spec.stride)}else if(i.packAlternating?.pack){const r=i.packAlternating.pack(t,s);for(let o=0;o<this._spec.packVertexCount;o++){const n=r[o];this._pack(n,i,o*this._spec.stride)}}}_packPosition(t,s,i){const{offset:r}=this._spec.position,o=this._spec.position.packPrecisionFactor??1,n=ve(t*o,s*o);this._dataView.setUint32(i+r,n,!0)}_packId(t,s){const i=t*(this._spec.id.packPrecisionFactor??1),r=4278190080&this._dataView.getUint32(s+this._spec.id.offset,!0);this._dataView.setUint32(s+this._spec.id.offset,i|r,!0)}_pack(t,s,i){be(this._dataView,t,s,i)}};function We(e){if(!e)return!1;for(const t of e)switch(t.effect.type){case"CIMGeometricEffectBuffer":case"CIMGeometricEffectOffset":case"CIMGeometricEffectDonut":return!0}return!1}let R=class{constructor(t,s,i,r){this._instanceId=t,this._evaluator=s,this._enabledOptionalAttributes=i,this._viewParams=r,this._evaluator.evaluator=o=>this.vertexSpec.createComputedParams(o)}get _vertexPack(){if(!this._cachedVertexPack){const t=Oe.fromVertexSpec(this.vertexSpec,this._enabledOptionalAttributes);this._evaluator.hasDynamicProperties||t.pack(this._evaluator.evaluatedMeshParams,this._viewParams),this._cachedVertexPack=t}return this._cachedVertexPack}get evaluatedMeshParams(){return this._evaluator.evaluatedMeshParams}get hasEffects(){return!!this.evaluatedMeshParams.effects}get instanceId(){return this._instanceId}get attributeLayout(){return this._vertexPack.attributeLayout}setReferences(t){this._references=t}getBoundsInfo(){return null}getTileInfo(){return this._viewParams.tileInfo}async loadDependencies(){We(this._evaluator.inputMeshParams.effects?.effectInfos)&&await Fe()}enqueueRequest(t,s,i){this._evaluator.hasDynamicProperties&&this._evaluator.enqueueRequest(t,s,i)}write(t,s,i,r,o){this.ensurePacked(s,i,r);const n=this.evaluatedMeshParams.effects;if(!n||n.length===0)return void this._write(t,i,void 0,o);const a=i.readGeometryForDisplay()?.clone();if(!a)return;const c=T.fromOptimizedCIM(a,i.geometryType),l=mt();c.invertY();const u=t.id||"",x=Le.executeEffects(n,c,u,l);let d;for(;d=x.next();)d.invertY(),this._write(t,i,d,o)}ensurePacked(t,s,i){if(!this._evaluator.hasDynamicProperties)return;const r=this._evaluator.evaluateMeshParams(t,s,i);this._vertexPack.pack(r,this._viewParams)}_writeVertex(t,s,i,r,o){const n=this.evaluatedMeshParams;this._vertexPack.writeVertex(t,s,i,r,n,o)}};function Ue(e,t,s,i,r,o,n){pt=0;const a=(i-s)*o,c=r&&r.length,l=c?(r[0]-s)*o:a;let u,x,d,f,p,m=Ct(t,s,i,0,l,o,!0);if(m&&m.next!==m.prev){if(c&&(m=Ze(t,s,i,r,m,o)),a>80*o){u=d=t[0+s*o],x=f=t[1+s*o];for(let _=o;_<l;_+=o){const P=t[_+s*o],S=t[_+1+s*o];u=Math.min(u,P),x=Math.min(x,S),d=Math.max(d,P),f=Math.max(f,S)}p=Math.max(d-u,f-x),p=p!==0?1/p:0}U(m,e,o,u,x,p,n,0)}}function Ct(e,t,s,i,r,o,n){let a;if(n===Ke(e,t,s,i,r,o)>0)for(let c=i;c<r;c+=o)a=bt(c+t*o,e[c+t*o],e[c+1+t*o],a);else for(let c=r-o;c>=i;c-=o)a=bt(c+t*o,e[c+t*o],e[c+1+t*o],a);return a&&I(a,a.next)&&(H(a),a=a.next),a}function W(e,t=e){if(!e)return e;let s,i=e;do if(s=!1,i.steiner||!I(i,i.next)&&k(i.prev,i,i.next)!==0)i=i.next;else{if(H(i),i=t=i.prev,i===i.next)break;s=!0}while(s||i!==t);return t}function U(e,t,s,i,r,o,n,a){if(!e)return;!a&&o&&(e=Ot(e,i,r,o));let c=e;for(;e.prev!==e.next;){const l=e.prev,u=e.next;if(o?Xe(e,i,r,o):He(e))t.push(l.index/s+n),t.push(e.index/s+n),t.push(u.index/s+n),H(e),e=u.next,c=u.next;else if((e=u)===c){a?a===1?U(e=es(e,t,s,n),t,s,i,r,o,n,2):a===2&&ss(e,t,s,i,r,o,n):U(W(e),t,s,i,r,o,n,1);break}}}function He(e){const t=e.prev,s=e,i=e.next;if(k(t,s,i)>=0)return!1;let r=e.next.next;const o=r;let n=0;for(;r!==e.prev&&(n===0||r!==o);){if(n++,B(t.x,t.y,s.x,s.y,i.x,i.y,r.x,r.y)&&k(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function Xe(e,t,s,i){const r=e.prev,o=e,n=e.next;if(k(r,o,n)>=0)return!1;const a=r.x<o.x?r.x<n.x?r.x:n.x:o.x<n.x?o.x:n.x,c=r.y<o.y?r.y<n.y?r.y:n.y:o.y<n.y?o.y:n.y,l=r.x>o.x?r.x>n.x?r.x:n.x:o.x>n.x?o.x:n.x,u=r.y>o.y?r.y>n.y?r.y:n.y:o.y>n.y?o.y:n.y,x=lt(a,c,t,s,i),d=lt(l,u,t,s,i);let f=e.prevZ,p=e.nextZ;for(;f&&f.z>=x&&p&&p.z<=d;){if(f!==e.prev&&f!==e.next&&B(r.x,r.y,o.x,o.y,n.x,n.y,f.x,f.y)&&k(f.prev,f,f.next)>=0||(f=f.prevZ,p!==e.prev&&p!==e.next&&B(r.x,r.y,o.x,o.y,n.x,n.y,p.x,p.y)&&k(p.prev,p,p.next)>=0))return!1;p=p.nextZ}for(;f&&f.z>=x;){if(f!==e.prev&&f!==e.next&&B(r.x,r.y,o.x,o.y,n.x,n.y,f.x,f.y)&&k(f.prev,f,f.next)>=0)return!1;f=f.prevZ}for(;p&&p.z<=d;){if(p!==e.prev&&p!==e.next&&B(r.x,r.y,o.x,o.y,n.x,n.y,p.x,p.y)&&k(p.prev,p,p.next)>=0)return!1;p=p.nextZ}return!0}function bt(e,t,s,i){const r=F.create(e,t,s);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function H(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function Ve(e){let t=e,s=e;do(t.x<s.x||t.x===s.x&&t.y<s.y)&&(s=t),t=t.next;while(t!==e);return s}function Ze(e,t,s,i,r,o){const n=new Array;for(let a=0,c=i.length;a<c;a++){const l=Ct(e,t,s,i[a]*o,a<c-1?i[a+1]*o:s*o,o,!1);l===l.next&&(l.steiner=!0),n.push(Ve(l))}n.sort(ts);for(const a of n)r=qe(a,r);return r}function qe(e,t){const s=Qe(e,t);if(!s)return t;const i=Ut(s,e);return W(i,i.next),W(s,s.next)}function Qe(e,t){let s=t;const i=e.x,r=e.y;let o,n=-1/0;do{if(r<=s.y&&r>=s.next.y&&s.next.y!==s.y){const d=s.x+(r-s.y)*(s.next.x-s.x)/(s.next.y-s.y);if(d<=i&&d>n){if(n=d,d===i){if(r===s.y)return s;if(r===s.next.y)return s.next}o=s.x<s.next.x?s:s.next}}s=s.next}while(s!==t);if(!o)return null;if(i===n)return o.prev;const a=o,c=o.x,l=o.y;let u,x=1/0;for(s=o.next;s!==a;)i>=s.x&&s.x>=c&&i!==s.x&&B(r<l?i:n,r,c,l,r<l?n:i,r,s.x,s.y)&&(u=Math.abs(r-s.y)/(i-s.x),(u<x||u===x&&s.x>o.x)&&X(s,e)&&(o=s,x=u)),s=s.next;return o}function Ot(e,t,s,i){let r;for(;r!==e;r=r.next){if(r=r||e,r.z===null&&(r.z=lt(r.x,r.y,t,s,i)),r.prev.next!==r||r.next.prev!==r)return r.prev.next=r,r.next.prev=r,Ot(e,t,s,i);r.prevZ=r.prev,r.nextZ=r.next}return e.prevZ.nextZ=null,e.prevZ=null,je(e)}function je(e){let t,s=1;for(;;){let i,r=e;e=null,t=null;let o=0;for(;r;){o++,i=r;let n=0;for(;n<s&&i;n++)i=i.nextZ;let a=s;for(;n>0||a>0&&i;){let c;n===0?(c=i,i=i.nextZ,a--):a!==0&&i?r.z<=i.z?(c=r,r=r.nextZ,n--):(c=i,i=i.nextZ,a--):(c=r,r=r.nextZ,n--),t?t.nextZ=c:e=c,c.prevZ=t,t=c}r=i}if(t.nextZ=null,s*=2,o<2)return e}}function k(e,t,s){return(t.y-e.y)*(s.x-t.x)-(t.x-e.x)*(s.y-t.y)}function Wt(e,t,s,i){return!!(I(e,t)&&I(s,i)||I(e,i)&&I(s,t))||k(e,t,s)>0!=k(e,t,i)>0&&k(s,i,e)>0!=k(s,i,t)>0}function Je(e,t){let s=e;do{if(s.index!==e.index&&s.next.index!==e.index&&s.index!==t.index&&s.next.index!==t.index&&Wt(s,s.next,e,t))return!0;s=s.next}while(s!==e);return!1}function Ke(e,t,s,i,r,o){let n=0;for(let a=i,c=r-o;a<r;a+=o)n+=(e[c+t*o]-e[a+t*o])*(e[a+1+t*o]+e[c+1+t*o]),c=a;return n}function B(e,t,s,i,r,o,n,a){return(r-n)*(t-a)-(e-n)*(o-a)>=0&&(e-n)*(i-a)-(s-n)*(t-a)>=0&&(s-n)*(o-a)-(r-n)*(i-a)>=0}function X(e,t){return k(e.prev,e,e.next)<0?k(e,t,e.next)>=0&&k(e,e.prev,t)>=0:k(e,t,e.prev)<0||k(e,e.next,t)<0}function lt(e,t,s,i,r){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-s)*r)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-i)*r)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function I(e,t){return e.x===t.x&&e.y===t.y}function ts(e,t){return e.x-t.x}function es(e,t,s,i){let r=e;do{const o=r.prev,n=r.next.next;!I(o,n)&&Wt(o,r,r.next,n)&&X(o,n)&&X(n,o)&&(t.push(o.index/s+i),t.push(r.index/s+i),t.push(n.index/s+i),H(r),H(r.next),r=e=n),r=r.next}while(r!==e);return r}function ss(e,t,s,i,r,o,n){let a=e;do{let c=a.next.next;for(;c!==a.prev;){if(a.index!==c.index&&is(a,c)){let l=Ut(a,c);return a=W(a,a.next),l=W(l,l.next),U(a,t,s,i,r,o,n,0),void U(l,t,s,i,r,o,n,0)}c=c.next}a=a.next}while(a!==e)}function is(e,t){return e.next.index!==t.index&&e.prev.index!==t.index&&!Je(e,t)&&X(e,t)&&X(t,e)&&rs(e,t)}function rs(e,t){let s=e,i=!1;const r=(e.x+t.x)/2,o=(e.y+t.y)/2;do s.y>o!=s.next.y>o&&s.next.y!==s.y&&r<(s.next.x-s.x)*(o-s.y)/(s.next.y-s.y)+s.x&&(i=!i),s=s.next;while(s!==e);return i}function Ut(e,t){const s=F.create(e.index,e.x,e.y),i=F.create(t.index,t.x,t.y),r=e.next,o=t.prev;return e.next=t,t.prev=e,s.next=r,r.prev=s,i.next=s,s.prev=i,o.next=i,i.prev=o,i}class F{constructor(){this.index=0,this.x=0,this.y=0,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}static create(t,s,i){const r=pt<ht.length?ht[pt++]:new F;return r.index=t,r.x=s,r.y=i,r.prev=null,r.next=null,r.z=null,r.prevZ=null,r.nextZ=null,r.steiner=!1,r}}const ht=[],os=8096;let pt=0;for(let e=0;e<os;e++)ht.push(new F);const ns=1e-5,z=new At(0,0,0,1,0),ft=new At(0,0,0,1,0);function vt(e,t,s){let i=0;for(let r=1;r<s;r++){const o=e[2*(t+r-1)],n=e[2*(t+r-1)+1];i+=(e[2*(t+r)]-o)*(e[2*(t+r)+1]+n)}return i}function as(e,t,s,i,r){let o=0;const n=2;for(let a=s;a<i;a+=3){const c=(e[a]-r)*n,l=(e[a+1]-r)*n,u=(e[a+2]-r)*n;o+=Math.abs((t[c]-t[u])*(t[l+1]-t[c+1])-(t[c]-t[l])*(t[u+1]-t[c+1]))}return o}function cs(e,t){const{coords:s,lengths:i}=t,r=0,o=e;let n=0;for(let a=0;a<i.length;){let c=a,l=i[a],u=vt(s,n,l);const x=[];for(;++c<i.length;){const m=i[c],_=vt(s,n+l,m);if(!(_>0))break;u+=_,x.push(n+l),l+=m}const d=o.length;Ue(o,s,n,n+l,x,2,r);const f=as(o,s,d,o.length,r),p=Math.abs(u);if(Math.abs((f-p)/Math.max(1e-7,p))>ns)return o.length=0,!1;a=c,n+=l}return!0}function us(e){const{coords:t,lengths:s}=e,{buffer:i}=ke(t,s);return i}function ls(e,t,s){let i=0;for(let r=0;r<e.lengths.length;r++){const o=e.lengths[r];for(let n=0;n<o;n++){const a=e.coords[2*(n+i)],c=e.coords[2*(n+i)+1];if(a<t||a>s||c<t||c>s)return!0}i+=o}return!1}function Ht(e,t){if(e==null)return null;if(!ls(e,-128,tt+128))return e;z.setPixelMargin(t),z.reset(Dt.Polygon);let s=0;for(let n=0;n<e.lengths.length;n++){const a=e.lengths[n];let c=e.coords[2*(0+s)],l=e.coords[2*(0+s)+1];z.moveTo(c,l);for(let u=1;u<a;u++)c=e.coords[2*(u+s)],l=e.coords[2*(u+s)+1],z.lineTo(c,l);z.close(),s+=a}const i=z.result(!1);if(!i)return null;const r=[],o=[];for(const n of i){let a=0;for(const c of n)o.push(c.x),o.push(c.y),a++;r.push(a)}return new Te(r,o)}function hs(e,t){ft.setPixelMargin(t);const s=ft,i=-t,r=tt+t;let o=[],n=!1;if(!e.nextPath())return null;let a=!0;for(;a;){e.seekPathStart();const c=[];if(!e.pathSize)return null;s.reset(Dt.LineString),e.nextPoint();let l=e.x,u=e.y;if(n)s.moveTo(l,u);else{if(l<i||l>r||u<i||u>r){n=!0;continue}c.push({x:l,y:u})}let x=!1;for(;e.nextPoint();)if(l=e.x,u=e.y,n)s.lineTo(l,u);else{if(l<i||l>r||u<i||u>r){x=!0;break}c.push({x:l,y:u})}if(x)n=!0;else{if(n){const d=s.resultWithStarts();if(d)for(const f of d)o.push(f)}else o.push({line:c,start:0});a=e.nextPath(),n=!1}}return o=o.filter(c=>c.line.length>1),o.length===0?null:o}z.setExtent(tt),ft.setExtent(tt);const ps=100,fs=re("featurelayer-fast-triangulation-enabled");class Xt extends R{async loadDependencies(){await Promise.all([super.loadDependencies(),Se()])}_write(t,s,i){const r=i?.asOptimized()??s.readGeometryForDisplay(),o=this._clip(r);o&&(t.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(t,s,o),t.recordEnd())}_clip(t){if(!t)return null;const s=this.hasEffects;return Ht(t,s?256:8)}_writeGeometry(t,s,i){const r=i.maxLength>ps,o=[],n=this.createTesselationParams(s);if(!r&&fs&&cs(o,i))return void(o.length&&this._writeVertices(t,s,i.coords,n,o));const a=us(i);this._writeVertices(t,s,a,n)}_writeVertices(t,s,i,r,o){const n=s.getDisplayId(),a=t.vertexCount(),c=this.hasEffects;let l=0;if(o)for(const u of o){const x=i[2*u],d=i[2*u+1];c&&t.recordBounds(x,d,0,0),this._writeVertex(t,n,x,d,r),l++}else for(let u=0;u<i.length;u+=2){const x=Math.round(i[u]),d=Math.round(i[u+1]);c&&t.recordBounds(x,d,0,0),this._writeVertex(t,n,x,d,r),l++}t.indexEnsureSize(l);for(let u=0;u<l;u++)t.indexWrite(u+a)}}const ds={createComputedParams:e=>e,optionalAttributes:{},attributes:{id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1},pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},inverseArea:{type:h.FLOAT,count:1,packTessellation:({inverseArea:e})=>e}}};let ai=class extends Xt{constructor(){super(...arguments),this.vertexSpec=ds}createTesselationParams(t){return{inverseArea:1/t.readGeometryArea()}}};const dt={createComputedParams:e=>e,optionalAttributes:{zoomRange:{type:h.SHORT,count:2,packPrecisionFactor:rt,pack:({scaleInfo:e},{tileInfo:t})=>V(e,t)}},attributes:{id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1},pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:e})=>g(e)}}};let Vt=class extends Xt{constructor(){super(...arguments),this.vertexSpec=dt}createTesselationParams(t){return null}};const A={createComputedParams:e=>e,optionalAttributes:dt.optionalAttributes,attributes:{...dt.attributes,tlbr:{count:4,type:h.UNSIGNED_SHORT,pack:({sprite:e})=>{const{rect:t,width:s,height:i}=e,r=t.x+L,o=t.y+L;return[r,o,r+s,o+i]}},inverseRasterizationScale:{count:1,type:h.BYTE,packPrecisionFactor:16,pack:({sprite:e})=>1/e.rasterizationScale}}};let xs=class extends Vt{constructor(){super(...arguments),this.vertexSpec=A}_write(t,s,i){const r=i?.asOptimized()??s.readGeometryForDisplay(),o=this._clip(r);if(!o)return;const n=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(t,s,o),t.recordEnd()}};function et(e){const{sprite:t,aspectRatio:s,scaleProportionally:i}=e,r=y(e.height),o=r>0?r:t.height;let n=r*s;return n<=0?n=t.width:i&&(n*=t.width/t.height),{width:n,height:o}}function Zt(e){const{applyRandomOffset:t,sampleAlphaOnly:s}=e;return Z([[oe,t],[zt,s]])}const qt={createComputedParams:e=>e,optionalAttributes:A.optionalAttributes,attributes:{...A.attributes,bitset:{count:1,type:h.UNSIGNED_BYTE,pack:Zt},width:{count:1,type:h.HALF_FLOAT,pack:e=>et(e).width},height:{count:1,type:h.HALF_FLOAT,pack:e=>et(e).height},offset:{count:2,type:h.HALF_FLOAT,pack:({offsetX:e,offsetY:t})=>[y(e),-y(t)]},scale:{count:2,type:h.UNSIGNED_BYTE,packPrecisionFactor:16,pack:({scaleX:e,scaleY:t})=>[e,t]},angle:{count:1,type:h.UNSIGNED_BYTE,pack:({angle:e})=>de(e)}}};let hi=class extends xs{constructor(){super(...arguments),this.vertexSpec=qt}},ms=class{constructor(){this.extrusionOffsetX=0,this.extrusionOffsetY=0,this.normalX=0,this.normalY=0,this.directionX=0,this.directionY=0,this.distance=0}};const D={createComputedParams:e=>e,optionalAttributes:{zoomRange:{type:h.SHORT,count:2,packPrecisionFactor:rt,pack:({scaleInfo:e},{tileInfo:t})=>V(e,t)}},attributes:{id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},bitset:{type:h.UNSIGNED_BYTE,count:1},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:e})=>g(e)},offset:{type:h.BYTE,count:2,packPrecisionFactor:16,packTessellation:({extrusionOffsetX:e,extrusionOffsetY:t})=>[j(e,16),j(t,16)]},normal:{type:h.BYTE,count:2,packPrecisionFactor:16,packTessellation:({normalX:e,normalY:t})=>[j(e,16),j(t,16)]},halfWidth:{type:h.HALF_FLOAT,count:1,pack:({width:e})=>y(.5*e)},referenceHalfWidth:{type:h.HALF_FLOAT,count:1,pack:({referenceWidth:e})=>y(.5*e)}}};let ys=class{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0}};const Tt=65535;let Qt=class extends R{constructor(t,s,i,r){super(t,s,i,r),this.vertexSpec=D,this._currentWrite=new ys,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:Tt,textured:!1},this._tessParams=new ms,this._initializeTessellator()}writeLineVertices(t,s,i){const r=this._getLines(s);r!=null&&this._writeVertices(t,i,r)}_initializeTessellator(){this._lineTessellator=new Pe(this._writeTesselatedVertex.bind(this),this._writeTriangle.bind(this),!0)}_write(t,s,i){const r=i??T.fromFeatureSetReaderCIM(s);r&&this._writeGeometry(t,s,r)}_writeGeometry(t,s,i,r){t.recordStart(this.instanceId,this.attributeLayout,r),this.writeLineVertices(t,i,s),t.recordEnd()}_getLines(t){return hs(t,Nt(this.evaluatedMeshParams))}_writeVertices(t,s,i){const{_currentWrite:r,_tessellationOptions:o,evaluatedMeshParams:n}=this,{width:a,capType:c,joinType:l,miterLimit:u,hasSizeVV:x}=n,d=y(.5*a);o.halfWidth=d,o.capType=Ye(c),o.joinType=Be(l),o.miterLimit=u;const f=!x;r.out=t,r.id=s.getDisplayId(),r.vertexCount=0,r.indexCount=0,r.vertexFrom=t.vertexCount(),r.vertexBounds=f&&d<xe?0:1;for(const{line:p,start:m}of i)o.initialDistance=m%Tt,this._lineTessellator.tessellate(p,o,f)}_writeTesselatedVertex(t,s,i,r,o,n,a,c,l,u,x){const{out:d,id:f,vertexBounds:p}=this._currentWrite;return this.hasEffects&&d.recordBounds(t,s,p,p),this._tessParams.extrusionOffsetX=a,this._tessParams.extrusionOffsetY=c,this._tessParams.normalX=l,this._tessParams.normalY=u,this._tessParams.directionX=o,this._tessParams.directionY=n,this._tessParams.distance=x,this._writeVertex(d,f,t,s,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(t,s,i){const{out:r}=this._currentWrite;r.indexEnsureSize(3),r.indexWrite(t),r.indexWrite(s),r.indexWrite(i),this._currentWrite.indexCount+=3}};const jt={createComputedParams:e=>e,optionalAttributes:D.optionalAttributes,attributes:{...D.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:e=>0},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:e})=>g(e)}}},yt={createComputedParams:e=>e,optionalAttributes:D.optionalAttributes,attributes:{...D.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:e=>Z([[It,!0]])},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:e})=>g(e)}}};let _t=class extends Qt{constructor(){super(...arguments),this.vertexSpec=yt}},Jt=class extends Vt{constructor(t,s,i,r){super(t,s,i,r),this.vertexSpec=jt,this._lineMeshWriter=this._createOutlineWriter(t,s,i,r)}_createOutlineWriter(t,s,i,r){return new _t(t,s,i,r)}_write(t,s,i){const r=i?.asOptimized()??s.readGeometryForDisplay(),o=this._clip(r);o&&(t.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(t,s,o),this._lineMeshWriter.writeLineVertices(t,T.fromOptimizedCIM(o,"esriGeometryPolyline"),s),t.recordEnd())}_clip(t){return t?Ht(t,Nt(this.evaluatedMeshParams)):null}ensurePacked(t,s,i){super.ensurePacked(t,s,i),this._lineMeshWriter.ensurePacked(t,s,i)}enqueueRequest(t,s,i){super.enqueueRequest(t,s,i),this._lineMeshWriter.enqueueRequest(t,s,i)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}};const st=qt,_s=yt,gs={createComputedParams:e=>e,optionalAttributes:st.optionalAttributes,attributes:{...st.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:e=>Zt(e)},aux1:{count:1,type:h.HALF_FLOAT,pack:e=>et(e).width},aux2:{count:1,type:h.HALF_FLOAT,pack:e=>et(e).height},aux3:{count:2,type:h.HALF_FLOAT,pack:({offsetX:e,offsetY:t})=>[y(e),y(t)]},aux4:{count:2,type:h.UNSIGNED_BYTE,pack:({scaleX:e,scaleY:t})=>[e*K,t*K]}}},ks={createComputedParams:e=>e,optionalAttributes:st.optionalAttributes,attributes:{...st.attributes,color:_s.attributes.color,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:e=>Z([[It,!0]])},aux1:{count:1,type:h.HALF_FLOAT,pack:e=>y(.5*e.width)},aux2:{count:1,type:h.HALF_FLOAT,pack:e=>y(.5*e.referenceWidth)},aux3:{count:2,type:h.HALF_FLOAT,packTessellation:({extrusionOffsetX:e,extrusionOffsetY:t})=>[e,t]},aux4:{count:2,type:h.UNSIGNED_BYTE,packTessellation:({normalX:e,normalY:t})=>[e*K+wt,t*K+wt]}}};class Ss extends _t{constructor(){super(...arguments),this.vertexSpec=ks}}let _i=class extends Jt{constructor(){super(...arguments),this.vertexSpec=gs}_createOutlineWriter(t,s,i,r){return new Ss(t,s,i,r)}_write(t,s,i){const r=i?.asOptimized()??s.readGeometryForDisplay(),o=this._clip(r);if(!o)return;const n=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(t,s,o),this._lineMeshWriter.writeLineVertices(t,T.fromOptimizedCIM(o,"esriGeometryPolyline"),s),t.recordEnd()}ensurePacked(t,s,i){super.ensurePacked(t,s,i),this._lineMeshWriter.ensurePacked(t,s,i)}enqueueRequest(t,s,i){super.enqueueRequest(t,s,i),this._lineMeshWriter.enqueueRequest(t,s,i)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}};const Ps={optionalAttributes:A.optionalAttributes,createComputedParams:e=>e,attributes:{...A.attributes,...jt.attributes}},ws={optionalAttributes:A.optionalAttributes,createComputedParams:e=>e,attributes:{...A.attributes,...yt.attributes}};class bs extends _t{constructor(){super(...arguments),this.vertexSpec=ws}}class ki extends Jt{constructor(){super(...arguments),this.vertexSpec=Ps}_createOutlineWriter(t,s,i,r){return new bs(t,s,i,r)}_write(t,s,i){const r=i?.asOptimized()??s.readGeometryForDisplay(),o=this._clip(r);if(!o)return;const n=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(t,s,o),this._lineMeshWriter.writeLineVertices(t,T.fromOptimizedCIM(o,"esriGeometryPolyline"),s),t.recordEnd()}ensurePacked(t,s,i){super.ensurePacked(t,s,i),this._lineMeshWriter.ensurePacked(t,s,i)}enqueueRequest(t,s,i){super.enqueueRequest(t,s,i),this._lineMeshWriter.enqueueRequest(t,s,i)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const vs={createComputedParams:e=>e,optionalAttributes:{},attributes:{pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1},offset:{type:h.BYTE,count:2,packAlternating:{count:4,pack:()=>[[-1,-1],[1,-1],[-1,1],[1,1]]}}}};let Si=class extends R{constructor(){super(...arguments),this.vertexSpec=vs}_write(t,s){t.recordStart(this.instanceId,this.attributeLayout);const i=s.getDisplayId();if(s.geometryType==="esriGeometryPoint"){const r=s.readXForDisplay(),o=s.readYForDisplay();this._writeQuad(t,i,r,o)}else s.geometryType==="esriGeometryMultipoint"&&s.readGeometryForDisplay()?.forEachVertex((o,n)=>{o>=0&&o<=512&&n>=0&&n<=512&&this._writeQuad(t,i,o,n)});t.recordEnd()}_writeQuad(t,s,i,r){const o=t.vertexCount();this._writeVertex(t,s,i,r),t.indexWrite(o+0),t.indexWrite(o+1),t.indexWrite(o+2),t.indexWrite(o+1),t.indexWrite(o+3),t.indexWrite(o+2)}};class Kt{static getPlacement(t,s,i,r,o,n){const a=ne(i);return a?(s===-1&&t.invertY(),a.execute(t,i,r,o,n)):null}}const Et=96;class Ts{constructor(t){const{offsetX:s,offsetY:i,postAngle:r,fontSize:o,haloSize:n,outlineSize:a,scaleFactor:c,transforms:l}=t;if(this.offsetX=s,this.offsetY=i,this.postAngle=r,this.fontSize=Math.min(o,Et),this.haloSize=n??0,this.outlineSize=a??0,this.transforms=l,l&&l.infos.length>1){const u=Yt(o,r,!1,s,i,l,!1);this.fontSize=Math.min(u.size,Et);const x=u.size/o;this.haloSize*=x,this.outlineSize*=x,this.postAngle=u.rotation,this.offsetX=u.offsetX,this.offsetY=u.offsetY}c&&(this.fontSize*=c,this.offsetX*=c,this.offsetY*=c)}}const Es=28,M=[4,4],J=[16,4],Ms={topLeft:J,topRight:J,bottomLeft:J,bottomRight:J},it=[4,2],w=[4,6],Mt={topLeft:it,topRight:it,bottomLeft:w,bottomRight:w},$t={topLeft:it,topRight:w,bottomLeft:it,bottomRight:w},$s={topLeft:w,topRight:w,bottomLeft:M,bottomRight:M},zs={topLeft:M,topRight:M,bottomLeft:w,bottomRight:w},Is={topLeft:w,topRight:M,bottomLeft:w,bottomRight:M},As={topLeft:M,topRight:w,bottomLeft:M,bottomRight:w},Ds={createComputedParams:e=>e,optionalAttributes:{zoomRange:{type:h.UNSIGNED_SHORT,count:2,packPrecisionFactor:rt,packTessellation:({minZoom:e,maxZoom:t})=>[e||0,t||Es]},clipAngle:{type:h.UNSIGNED_BYTE,count:1,packTessellation:({clipAngle:e})=>Ns(e||0)},referenceSymbol:{type:h.BYTE,count:4,packPrecisionFactor:1,packTessellation:(e,t)=>{const s=e.isLineLabel||!e.referenceBounds,i=ae(s?"center":t.horizontalAlignment),r=ce(s?"middle":t.verticalAlignment),{offsetX:o,offsetY:n,size:a}=s?{offsetX:0,offsetY:0,size:0}:e.referenceBounds;return[y(o),-y(n),Math.round(y(a)),i+1<<2|r+1]}}},attributes:{pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1,packTessellation:({isBackground:e,mapAligned:t})=>Z([[ue,e],[le,!!t]])},offset:{type:h.SHORT,count:2,packPrecisionFactor:8,packAlternating:{count:4,packTessellation:({offsets:e})=>{const{bottomLeft:t,bottomRight:s,topLeft:i,topRight:r}=e;return[i,r,t,s]}}},textureUV:{type:h.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,packTessellation:({texcoords:e})=>{const{bottomLeft:t,bottomRight:s,topLeft:i,topRight:r}=e;return[i,r,t,s]}}},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,packTessellation:({color:e})=>e},fontSize:{type:h.UNSIGNED_SHORT,count:1,packPrecisionFactor:4,packTessellation:({fontSize:e})=>Math.round(y(e))},referenceSize:{type:h.UNSIGNED_BYTE,count:1,packPrecisionFactor:4,packTessellation:({fontSize:e},{referenceSize:t})=>Math.round(y(t??e))},outlineColor:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:e})=>g(e)},haloColor:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({haloColor:e})=>g(e)},outlineAndHaloSize:{type:h.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({outlineSize:e,haloSize:t})=>[Math.round(y(e)),Math.round(y(t))]}}};class wi extends R{constructor(){super(...arguments),this.vertexSpec=Ds,this._textMeshParamsPropsInitialized=!1}ensurePacked(t,s,i){super.ensurePacked(t,s,i),this._textMeshParamsPropsInitialized&&!this._evaluator.hasDynamicProperties||(this._textMeshTransformProps=new Ts(this.evaluatedMeshParams),this._textMeshParamsPropsInitialized=!0)}_write(t,s,i){const r=this._getShaping();if(!r)return;const o=s.getDisplayId();if(this.evaluatedMeshParams.placement!=null)return this._writePlacedTextMarkers(t,s,r,i);if(i?.nextPath())return i.nextPoint(),this._writeGlyphs(t,o,i.x,i.y,r,0);if(s.geometryType==="esriGeometryPolygon"){const c=s.readCentroidForDisplay();if(!c)return;const[l,u]=c.coords;return this._writeGlyphs(t,o,l,u,r,0)}if(s.geometryType==="esriGeometryMultipoint")return void s.readGeometryForDisplay()?.forEachVertex((l,u)=>this._writeGlyphs(t,o,l,u,r,0));const n=s.readXForDisplay(),a=s.readYForDisplay();return this._writeGlyphs(t,o,n,a,r,0)}_writePlacedTextMarkers(t,s,i,r){const o=r??T.fromFeatureSetReaderCIM(s);if(!o)return;const n=-1,a=Kt.getPlacement(o,n,this.evaluatedMeshParams.placement,y(1),t.id,mt());if(!a)return;const c=s.getDisplayId();let l=a.next();for(;l!=null;){const u=l.tx,x=-l.ty,d=-l.getAngle();this._writeGlyphs(t,c,u,x,i,d),l=a.next()}}_getShaping(t){const s=this._textMeshTransformProps,i=this.evaluatedMeshParams;if(!i.glyphs?.glyphs.length)return null;const r=y(s.fontSize),o=y(s.offsetX),n=y(s.offsetY),a=gt(y(i.lineWidth),ye,me),c=_e*gt(i.lineHeightRatio,.25,4);return he(i.glyphs,{scale:r/ge,angle:s.postAngle,xOffset:o,yOffset:n,horizontalAlignment:i.horizontalAlignment,verticalAlignment:t||i.verticalAlignment,maxLineWidth:a,lineHeight:c,decoration:i.decoration,borderLineSizePx:y(i.boxBorderLineSize),hasBackground:!!i.boxBackgroundColor,useCIMAngleBehavior:i.useCIMAngleBehavior})}_writeGlyphs(t,s,i,r,o,n,a,c){const l=this.evaluatedMeshParams,u=this._textMeshTransformProps,x=y(u.fontSize),d=u.haloSize,f=u.outlineSize,p=y(u.offsetX),m=y(u.offsetY),[_,P]=V(l.scaleInfo,this.getTileInfo());n!==0&&o.setRotation(n);const S=o.bounds,$=i+S.x+p,v=r+S.y-m,N=2*(l.minPixelBuffer?l.minPixelBuffer/x:1),b=Math.max(S.width,S.height)*N;o.textBox&&(t.recordStart(this.instanceId,this.attributeLayout,o.glyphs[0].textureBinding),t.recordBounds($,v,b,b),this._writeTextBox(t,s,i,r,o.textBox,a,c),t.recordEnd());for(const E of o.glyphs){t.recordStart(this.instanceId,this.attributeLayout,E.textureBinding),t.recordBounds($,v,b,b);const{texcoords:ot,offsets:Y}=E;this._writeQuad(t,s,i,r,{texcoords:ot,offsets:Y,fontSize:x,haloSize:d,outlineSize:f,color:g(l.color),isBackground:!1,referenceBounds:a,minZoom:_,maxZoom:P,...c}),t.recordEnd()}n!==0&&o.setRotation(-n)}_writeTextBox(t,s,i,r,o,n,a){const c=this.evaluatedMeshParams,{fontSize:l,haloSize:u,outlineSize:x}=this._textMeshTransformProps,{boxBackgroundColor:d,boxBorderLineColor:f}=c,p={isBackground:!0,fontSize:l,haloSize:u,outlineSize:x,referenceBounds:n,...a};d&&(this._writeQuad(t,s,i,r,{texcoords:Ms,offsets:o.main,color:g(d),...p}),f||(this._writeQuad(t,s,i,r,{texcoords:$s,offsets:o.top,color:g(d),...p}),this._writeQuad(t,s,i,r,{texcoords:zs,offsets:o.bot,color:g(d),...p}),this._writeQuad(t,s,i,r,{texcoords:Is,offsets:o.left,color:g(d),...p}),this._writeQuad(t,s,i,r,{texcoords:As,offsets:o.right,color:g(d),...p}))),f&&(this._writeQuad(t,s,i,r,{texcoords:Mt,offsets:o.top,color:g(f),...p}),this._writeQuad(t,s,i,r,{texcoords:Mt,offsets:o.bot,color:g(f),...p}),this._writeQuad(t,s,i,r,{texcoords:$t,offsets:o.left,color:g(f),...p}),this._writeQuad(t,s,i,r,{texcoords:$t,offsets:o.right,color:g(f),...p}))}_writeQuad(t,s,i,r,o){const n=t.vertexCount();this._writeVertex(t,s,i,r,o),t.indexWrite(n+0),t.indexWrite(n+1),t.indexWrite(n+2),t.indexWrite(n+1),t.indexWrite(n+3),t.indexWrite(n+2)}}const Ns=e=>Math.round(e*(254/360)),Ys={createComputedParams:e=>e,optionalAttributes:D.optionalAttributes,attributes:{...D.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:({shouldSampleAlphaOnly:e,shouldScaleDash:t,isSDF:s})=>Z([[zt,e],[pe,t],[fe,s]])},tlbr:{type:h.UNSIGNED_SHORT,count:4,pack:({sprite:e})=>{const{rect:t,width:s,height:i}=e,r=t.x+L,o=t.y+L;return[r,o,r+s,o+i]}},accumulatedDistance:{type:h.UNSIGNED_SHORT,count:1,packTessellation:({distance:e})=>e},segmentDirection:{type:h.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:e,directionY:t})=>[e,t]},offsetAlongLine:{type:h.HALF_FLOAT,count:1,pack:({offsetAlongLine:e})=>y(e)},capType:{type:h.UNSIGNED_BYTE,count:1,pack:({capType:e})=>{switch(e){case G.Butt:case"butt":return 0;case G.Square:case"square":return 1;case G.Round:case"round":return 2;default:return 0}}}}};class bi extends Qt{constructor(t,s,i,r){super(t,s,i,r),this.vertexSpec=Ys,this._tessellationOptions.textured=!0}_write(t,s,i){const r=i??T.fromFeatureSetReaderCIM(s);if(!r)return;const{sprite:o}=this.evaluatedMeshParams;this._writeGeometry(t,s,r,o?.textureBinding)}}let Bs=class xt{static from(t){return"width"in t?this.fromSimpleMeshParams(t):this.fromComplexMeshParams(t)}static fromSimpleMeshParams(t){const s=new xt(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects),{type:i,width:r,height:o,angle:n,alignment:a,outlineSize:c,referenceSize:l,sprite:u,overrideOutlineColor:x}=t;return s.rawWidth=y(r),s.rawHeight=y(o),s.angle=n,s.alignment=a,s.outlineSize=y(c),s.referenceSize=y(l),s.overrideOutlineColor=x,s.offsetX=y(t.offsetX),s.offsetY=y(t.offsetY),i!=="simple"||u.sdf||(s.rawWidth=u.width,s.rawHeight=u.height),s._computeSize(t,!1),s}static fromComplexMeshParams(t){const s=new xt(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects);let{alignment:i,transforms:r,size:o,scaleX:n,anchorX:a,anchorY:c,angle:l,colorLocked:u,frameHeight:x,widthRatio:d,offsetX:f,offsetY:p,outlineSize:m,referenceSize:_,scaleFactor:P,sizeRatio:S,isAbsoluteAnchorPoint:$,rotateClockwise:v,scaleSymbolsProportionally:N,sprite:b}=t;if(r&&r.infos.length>0){const Y=Yt(o,l,v,f,p,r);o=Y.size,l=Y.rotation,f=Y.offsetX,p=Y.offsetY,v=!1}P&&(o*=P,f*=P,p*=P);const E=n*(b.width/b.height);s.alignment=i,s.rawHeight=y(o),s.rawWidth=s.rawHeight*E,s.referenceSize=y(_),s.sizeRatio=S,s.sdfDecodeCoeff=(b.sdfDecodeCoeff??1)*S,s.angle=l,s.rotateClockwise=v,s.anchorX=a,s.anchorY=c,s.offsetX=y(f),s.offsetY=y(p),$&&o&&(b.sdf?s.anchorX=a/(o*d):s.anchorX=a/(o*E),s.anchorY=c/o);const ot=N&&x?o/x:1;return s.outlineSize=m===0||isNaN(m)?0:y(m)*ot,s.scaleSymbolsProportionally=N,s.colorLocked=u,s._computeSize(t,!0),s}constructor(t,s,i,r,o,n,a){this.sprite=t,this.color=s,this.outlineColor=i,this.minPixelBuffer=r,this.placement=o,this.scaleInfo=n,this.effects=a,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.sdfDecodeCoeff=1,this.alignment=Bt.SCREEN,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize(t,s){const{sprite:i,hasSizeVV:r}=t,o=!!i.sdf,n=i.sdfPaddingRatio??.5,{rawWidth:a,rawHeight:c,sizeRatio:l,outlineSize:u}=this,x=l*(o?1/(1-n):1),d=a*x,f=c*x;if(o&&!r){const N=s&&a>c?d:a,b=c,E=u+2*1;this.computedWidth=Math.min(N+E,d),this.computedHeight=Math.min(b+E,f)}else this.computedWidth=d,this.computedHeight=f;const p=o?Math.max(i.width,i.height)/Math.max(d,f):1,m=.5*(d-this.computedWidth)*p,_=.5*(f-this.computedHeight)*p,P=i.rect.x+L+m,S=i.rect.y+L+_,$=P+i.width-2*m,v=S+i.height-2*_;this.texXmin=Math.floor(P),this.texYmin=Math.floor(S),this.texXmax=Math.ceil($),this.texYmax=Math.ceil(v),this.computedWidth*=(this.texXmax-this.texXmin)/($-P),this.computedHeight*=(this.texYmax-this.texYmin)/(v-S),this.anchorX*=d/this.computedWidth,this.anchorY*=f/this.computedHeight}};const Gs=3.14159265359/180,Ls=128/Math.PI;function Fs(e,t){return e%=t,Math.abs(e>=0?e:e+t)}function Rs(e){return Fs(e*Ls,256)}function Cs(e,t,s,i,r=!1){const o=Ee(),n=r?1:-1;return Me(o),(t||s)&&$e(o,o,[t,-s]),i&&ze(o,o,n*Gs*-i),o}const Os={createComputedParams:e=>Bs.from(e),optionalAttributes:{zoomRange:{type:h.SHORT,count:2,packPrecisionFactor:rt,pack:({scaleInfo:e},{tileInfo:t})=>V(e,t)}},attributes:{pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1,pack:({sprite:e,alignment:t,scaleSymbolsProportionally:s,overrideOutlineColor:i,colorLocked:r})=>{let o=0;return e.sdf&&(o|=O(C.bitset.isSDF)),t===Bt.MAP&&(o|=O(C.bitset.isMapAligned)),s&&(o|=O(C.bitset.scaleSymbolsProportionally)),i&&(o|=O(C.bitset.overrideOutlineColor)),r&&(o|=O(C.bitset.colorLocked)),o}},offset:{type:h.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({angle:e,computedWidth:t,computedHeight:s,anchorX:i,anchorY:r,offsetX:o,offsetY:n,rotateClockwise:a})=>{const c=Cs(0,o,n,-e,a),l=-(.5+i)*t,u=-(.5-r)*s,x=[l,u],d=[l+t,u],f=[l,u+s],p=[l+t,u+s];return q(x,x,c),q(d,d,c),q(f,f,c),q(p,p,c),[x,d,f,p]}}},textureUV:{type:h.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({texXmax:e,texXmin:t,texYmax:s,texYmin:i})=>[[t,i],[e,i],[t,s],[e,s]]}},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:e})=>g(e)},outlineColor:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:e})=>g(e)},sizing:{type:h.UNSIGNED_BYTE,count:4,pack:({rawWidth:e,rawHeight:t,outlineSize:s,referenceSize:i})=>{const r=Math.max(e,t);return[ut(r,128),ut(s,128),ut(i,128),0]}},placementAngle:{type:h.UNSIGNED_BYTE,count:1,packTessellation:({placementAngle:e})=>Rs(e)},sdfDecodeCoeff:{type:h.UNSIGNED_SHORT,count:1,packPrecisionFactor:64,pack:({sdfDecodeCoeff:e})=>e}}};class vi extends R{constructor(){super(...arguments),this.vertexSpec=Os}getBoundsInfo(){return this.evaluatedMeshParams.boundsInfo}_write(t,s,i){const r=this.evaluatedMeshParams.sprite?.textureBinding,o=s.getDisplayId();t.recordStart(this.instanceId,this.attributeLayout,r);const n=this.evaluatedMeshParams.minPixelBuffer,a=Math.max(this.evaluatedMeshParams.computedWidth,n),c=Math.max(this.evaluatedMeshParams.computedHeight,n),l=-this.evaluatedMeshParams.anchorX*this.evaluatedMeshParams.computedWidth,u=this.evaluatedMeshParams.anchorY*this.evaluatedMeshParams.computedHeight,x=this.evaluatedMeshParams.offsetX+l,d=-this.evaluatedMeshParams.offsetY+u;if(this.evaluatedMeshParams.placement!=null)this._writePlacedMarkers(t,s,i,a,c);else if(i?.nextPath()){i.nextPoint();const f=i.x,p=i.y;t.recordBounds(f+x,p+d,a,c),this._writeQuad(t,o,f,p)}else if(s.geometryType==="esriGeometryPolygon"){const f=s.readCentroidForDisplay();if(!f)return;const[p,m]=f.coords;t.recordBounds(p+x,m+d,a,c),this._writeQuad(t,o,p,m)}else if(s.geometryType==="esriGeometryPoint"){const f=s.readXForDisplay(),p=s.readYForDisplay();t.recordBounds(f+x,p+d,a,c),this._writeQuad(t,o,f,p)}else s.readGeometryForDisplay()?.forEachVertex((p,m)=>{t.recordBounds(p+x,m+d,a,c),Math.abs(p)>Q||Math.abs(m)>Q||this._writeQuad(t,o,p,m)});t.recordEnd()}_writePlacedMarkers(t,s,i,r,o){const n=i??T.fromFeatureSetReaderCIM(s)?.clone();if(!n)return;const a=-1,c=Kt.getPlacement(n,a,this.evaluatedMeshParams.placement,y(1),t.id,mt());if(!c)return;const l=s.getDisplayId();let u=c.next();const x=this.evaluatedMeshParams.offsetX,d=-this.evaluatedMeshParams.offsetY;for(;u!=null;){const f=u.tx,p=-u.ty;if(Math.abs(f)>Q||Math.abs(p)>Q){u=c.next();continue}const m=-u.getAngle();t.recordBounds(f+x,p+d,r,o),this._writeQuad(t,l,f,p,m),u=c.next()}}_writeQuad(t,s,i,r,o){const n=t.vertexCount(),a=o==null?null:{placementAngle:o};this._writeVertex(t,s,i,r,a),t.indexWrite(n+0),t.indexWrite(n+1),t.indexWrite(n+2),t.indexWrite(n+1),t.indexWrite(n+3),t.indexWrite(n+2)}}const Ws={createComputedParams:e=>e,optionalAttributes:{},attributes:{pos:{type:h.SHORT,count:2,packPrecisionFactor:10,pack:"position"},id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1,pack:e=>0},offset:{type:h.SHORT,count:2,packPrecisionFactor:16,packAlternating:{count:4,pack:({size:e})=>{const t=y(e),s=-t/2,i=-t/2;return[[s,i],[s+t,i],[s,i+t],[s+t,i+t]]}}},texCoords:{type:h.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:()=>[[0,1],[1,1],[0,0],[1,0]]}},size:{type:h.UNSIGNED_BYTE,count:2,pack:({size:e})=>[e,e]},referenceSize:{type:h.UNSIGNED_BYTE,count:1,pack:({size:e})=>y(e)},zoomRange:{type:h.UNSIGNED_BYTE,count:2,pack:({scaleInfo:e},{tileInfo:t})=>V(e,t)}}};class Ti extends R{constructor(){super(...arguments),this.vertexSpec=Ws}_write(t,s){const i=s.getDisplayId(),r=this.evaluatedMeshParams.minPixelBuffer,o=Math.max(y(this.evaluatedMeshParams.size),r);let n,a;if(s.geometryType==="esriGeometryPoint")n=s.readXForDisplay(),a=s.readYForDisplay();else{const l=s.readCentroidForDisplay();if(!l)return;n=l?.coords[0],a=l?.coords[1]}t.recordStart(this.instanceId,this.attributeLayout),t.recordBounds(n,a,o,o);const c=t.vertexCount();this._writeVertex(t,i,n,a),t.indexWrite(c+0),t.indexWrite(c+1),t.indexWrite(c+2),t.indexWrite(c+1),t.indexWrite(c+3),t.indexWrite(c+2),t.recordEnd()}}export{wi as N,Es as P,Qt as T,vi as _,_i as a,ki as b,R as c,hi as d,ai as e,O as f,g,Jt as h,Si as i,Vt as j,Le as k,bi as l,V as m,xs as o,Ti as s};
