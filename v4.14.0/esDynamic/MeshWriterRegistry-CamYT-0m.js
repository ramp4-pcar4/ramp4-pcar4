import{bA as ce,ca as P,aJ as Lt,ms as le,mt as O,d_ as K,hW as B,mu as Dt,m8 as ct,lV as he,lW as Et,bJ as tt,G as ue,i as de,s as fe}from"./main-CSjwO60s.js";import{a as W}from"./labelPoint-DTWBMY-Z.js";import{r as G}from"./rasterizingUtils-Cf1zdzIw.js";import{S as pe,z as me,d as ge,s as ye,y as _e}from"./CIMSymbolHelper-C-M9oL19.js";import{s as Q,t as L,o as C,c as xe,d as Pe,l as Me,q as ve}from"./definitions-DVO21zOC.js";import{i as D,a as j,s as Z,d as be,p as we,f as Se,m as ke,h as Ie,g as ze,b as Te,c as z,u as Ae,l as lt,e as Le,j as De,T as Ee,k as Be,o as Re,n as Ce,q as Fe,r as We,t as Ye,v as Oe}from"./TexturedLineMeshWriter-BCl73Ao0.js";import{d as E,h as Y}from"./UpdateTracking2D-CIKx7GWt.js";import{o as Bt,e as Ge}from"./grouping-CrNPfBhl.js";import{R as y}from"./enums-DDJfd4_p.js";import{o as Ne,F as Xe,G as He}from"./constants-CWFGCPkc.js";import{_ as Ve,a as Ue}from"./TurboLine-CvWJ2xTB.js";import{M as ht,i as ut,a as Qe,s as je}from"./mat2d-Cf4xHr3Z.js";import{n as N}from"./mat2df32-fg3OHsAI.js";import{r as et}from"./vec2f32-hTAvipMV.js";import{n as X}from"./vec2f64-CkowXrDb.js";import{d as Ze,l as Rt}from"./featureConversionUtils-CZmIxyv5.js";import{e as dt}from"./OptimizedGeometry-BYxlP_oK.js";import{i as Ct}from"./BoundingBox-DlCd_wcU.js";import{h as Ft,r as qe}from"./Utils-CYY0kXyb.js";import{q as Wt}from"./utils-CIm5uQvO.js";import{u as $e}from"./ArcadeExpression-BGPPS6z-.js";import{a as Je}from"./AttributeStore-DvLAcaW_.js";let ft=class{static getPlacement(s,t,e,i,n){const r=pe(e);return r?(t===-1&&s.invertY(),r.execute(s,e,i,n)):null}},Yt=class extends j{};function Ke(s){const{sprite:t,isMapAligned:e,colorLocked:i,scaleSymbolsProportionally:n,isStroke:r}=s;let o=0;return e&&(o|=D(E.bitset.isMapAligned)),i&&(o|=D(E.bitset.colorLocked)),t.sdf&&(o|=D(E.bitset.isSDF)),n&&(o|=D(E.bitset.scaleSymbolsProportionally)),r&&(o|=D(E.bitset.isStroke)),o}function q(s){return s instanceof $?s:typeof s=="object"&&"type"in s?is[s.type].hydrate(s):new H(s)}let $=class{constructor(s){this.inputs=s}encode(){const s=[];for(const t of this.inputs)s.push(...t.encode());return s.push(...this.instructions),s}},H=class extends ${constructor(s){super([]),this.value=s}simplify(){return this}get instructions(){if(Array.isArray(this.value)){const[s,t,e,i]=this.value;return i!=null?Y.vector4.encode([s,t||0,e||0,i]):Y.vector3.encode([s,t||0,e||0])}return Y.scalar.encode(this.value)}},ts=class kt extends ${constructor(t,e){super([e]),this._config=t,this._parent=e}static hydrate(t){return new kt(t,q(t.parent))}simplify(){if(this._config.relativeTranslation||this._config.absoluteScale)return this;const t=this._parent.simplify();if(!(t instanceof H))return this;const[e,i,n,r]=t.value,o=this._config.translation.from[0],a=this._config.translation.from[1],c=this._config.rotation.from,l=this._config.scale.from;if(o===this._config.translation.to[0]&&a===this._config.translation.to[1]&&c===this._config.rotation.to&&l===this._config.scale.to){const h=n+c,p=r*l,u=Math.sin(n),d=Math.cos(n);return new H([d*r*o-u*r*a+e,u*r*o+d*r*a+i,h,p])}return new kt(this._config,t)}get instructions(){return Y.animatedTransform.encode(this._config)}},es=class It extends ${constructor(t,e){super([e]),this._config=t,this._parent=e}static hydrate(t){return new It(t,q(t.parent))}simplify(){const t=this._parent.simplify();if(!(t instanceof H))return this;const[e,i,n,r]=t.value,o=this._config.color.from[0],a=this._config.color.from[1],c=this._config.color.from[2];let l=this._config.color.from[3];const h=this._config.opacity.from;return o===this._config.color.to[0]&&a===this._config.color.to[1]&&c===this._config.color.to[2]&&l===this._config.color.to[3]&&h===this._config.opacity.to?(l*=h,new H([e*o,i*a,n*c,r*l])):new It(this._config,t)}get instructions(){return Y.animatedColor.encode(this._config)}},ss=class zt extends ${constructor(t,e){super([e]),this._config=t,this._parent=e}static hydrate(t){return new zt(t,q(t.parent))}simplify(){const t=this._parent.simplify();return t instanceof H?new zt(this._config,t):this}get instructions(){return Y.animatedShift.encode(this._config)}};const is={AnimatedTransform:ts,AnimatedColor:es,AnimatedShift:ss};function rs(s){return Ot(s.map(t=>I(t)).map(t=>q(t).simplify()))}function ns(s){const t=[];return t.push(s.transform),t.push(s.fromColor),t.push(s.toColor),t.push(s.colorMix),t.push(s.toOpacity),t.push(s.opacityMix),s?.shift?t.push(s?.shift):t.push([1,1,1,1]),t}function Ot(s){const t=[],e=[];let i=0;for(const n of s){const r=[...n.encode(),...Y.ret.encode()];t.push([i+s.length,0,0,0]),e.push(...r),i+=r.length}return[...t,...e]}async function pt(s,t){const e=s;let i;if(typeof e=="number"||typeof e=="string"||typeof e=="boolean")i=e;else if(Array.isArray(e))i=await Promise.all(e.map(n=>pt(n,t)));else if(typeof e=="object")if("valueExpressionInfo"in e){const{valueExpressionInfo:n}=e,{expression:r}=n;i={...e,computed:await t.createComputedField({expression:r})}}else{i={};for(const n in e)i[n]=await pt(e[n],t)}return i}function I(s,t,e){function i(o){if(!("computed"in o))return o;let a=o.computed.readWithDefault(t,e,[255*o.defaultValue[0],255*o.defaultValue[1],255*o.defaultValue[2],o.defaultValue[3]]);if(typeof a=="string"){const c=ce.fromString(a);c&&(a=[c.r,c.g,c.b,c.a])}return a}const n=s;let r;if(typeof n=="number"||typeof n=="string"||typeof n=="boolean")r=n;else if(Array.isArray(n))r=n.map(o=>I(o,t,e));else if(typeof n=="object")if("type"in n&&n.type!=null&&n.type==="Process")switch(n.op){case"ArcadeColor":{const o=I(n.value,t,e);J(Array.isArray(o)&&o.length===4),r=[o[0]/255,o[1]/255,o[2]/255,o[3]]}break;case"Transparency":{const o=I(n.value,t,e);J(typeof o=="number"),r=1-o/100}break;case"Divide":case"Multiply":case"Add":{const o=I(n.left,t,e);J(typeof o=="number");const a=I(n.right,t,e);switch(J(typeof a=="number"),n.op){case"Divide":r=o/a;break;case"Multiply":r=o*a;break;case"Add":r=o+a}}break;case"Random":{const o=I(n.seed,t,e),a=I(n.min,t,e),c=I(n.max,t,e),l=t.getObjectId(),h=Bt(l||0);r=a+Ge(h,o)*(c-a)}break;case"Cond":{const o=I(n.condition,t,e),a=I(n.ifTrue,t,e),c=I(n.ifFalse,t,e);r=o?a:c}break;case"MatchWinding":{const o=I(n.sign,t,e);let a=I(n.angle,t,e);if(o>0)for(;a<0;)a+=2*Math.PI;else for(;a>0;)a-=2*Math.PI;r=a}}else if("computed"in n)r=i(n);else{r={};for(const o in n)r[o]=I(n[o],t,e)}return r}function*T(s){const t=s;if(Array.isArray(t))for(const e of t)yield*T(e);else if(typeof t=="object")if("type"in t&&t.type!=null&&t.type==="Process")switch(t.op){case"ArcadeColor":case"Transparency":yield*T(t.value);break;case"Divide":case"Multiply":case"Add":yield*T(t.left),yield*T(t.right);break;case"Random":yield*T(t.seed),yield*T(t.min),yield*T(t.max);break;case"Cond":yield*T(t.condition),yield*T(t.ifTrue),yield*T(t.ifFalse);break;case"MatchWinding":yield*T(t.sign),yield*T(t.angle)}else if("computed"in t)yield t.computed;else for(const e in t)yield*T(t[e])}function J(s){if(!s)throw new Error("Assertion failed.")}const mt={type:y.SHORT,count:2,packPrecisionFactor:Q,pack:({scaleInfo:s},{tileInfo:t})=>Z(s,t)},os={type:y.FLOAT,count:4,packPrecisionFactor:1,packTessellation:({value1Position2Value2:s})=>(J(s),s)},Gt={type:y.FLOAT,count:4,packPrecisionFactor:1,packTessellation:()=>[0,0,0,1]},as={type:y.FLOAT,count:1,packPrecisionFactor:1,pack:()=>0},Nt={type:y.FLOAT,count:1,packPrecisionFactor:1,packTessellation:({lineLength:s})=>s},cs={type:y.UNSIGNED_SHORT,count:1,packTessellation:({distance:s})=>s},ls={type:y.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:s,directionY:t})=>[s,t]},hs={type:y.FLOAT,count:2,packPrecisionFactor:16,packTessellation:({normalX:s,normalY:t})=>[s,t]},gt={type:y.UNSIGNED_BYTE,count:3,pack:"id"},yt={type:y.UNSIGNED_BYTE,count:1,pack:Ke},_t={type:y.SHORT,count:2,pack:"position",packPrecisionFactor:1},xt={marker:{type:y.FLOAT,count:2,packAlternating:{count:4,pack:({texelDimensions:s})=>[[-.5*s[0],-.5*s[1]],[.5*s[0],-.5*s[1]],[-.5*s[0],.5*s[1]],[.5*s[0],.5*s[1]]]}},line:{type:y.FLOAT,count:2,packTessellation:({extrusionOffsetX:s,extrusionOffsetY:t},{baseSize:e})=>[s*e/2,t*e/2]},fill:{type:y.FLOAT,count:2,packTessellation:()=>[0,0]}},us={marker:{type:y.SHORT,count:2,packPrecisionFactor:1,packAlternating:{count:4,packTessellation:({texXmax:s,texXmin:t,texYmax:e,texYmin:i})=>[[t,i],[s,i],[t,e],[s,e]]}}},Xt={type:y.UNSIGNED_SHORT,count:4,pack:({sprite:s})=>{const{rect:t,width:e,height:i}=s,n=t.x+L,r=t.y+L;return[n+1,r+1,n+e-1,r+i-1]}},Pt={type:y.UNSIGNED_SHORT,count:4,packPrecisionFactor:4,pack:({animations:s,baseSize:t,referenceSize:e})=>[s.dataColumn,s.dataRow,t,e]},Mt={type:y.UNSIGNED_SHORT,count:4,packPrecisionFactor:8,pack:({strokeWidth:s,pixelDimensions:t,baseSize:e,sprite:i,sizeRatio:n})=>{const r=Math.max(e*i.width/i.height,e),o=i.sdfDecodeCoeff*r*n;return[t[0],t[1],s,o]}},ds={type:y.BYTE,count:1,packTessellation:({angle:s})=>s};function vt(s){let{pixelDimensions:t,texelDimensions:e,baseSize:i,referenceSize:n,strokeWidth:r,sizeRatio:o}=s;if(t||(t=s.sprite.sdf?[0,0]:[s.sprite.width,s.sprite.height]),e||(e=s.sprite.sdf?[0,0]:t),s.patternHeight!=null){const c=s.patternHeight/t[1];t[1]*=c,t[0]*=c}i===-1&&(i=t[1]),i=P(i),n=P(n),r=P(r);const a=(s.sprite.sdfDecodeCoeff??1)*o;return{...s,pixelDimensions:t,texelDimensions:e,baseSize:i,referenceSize:n,strokeWidth:r,sdfDecodeCoeff:a}}const bt=64,fs=64,ps=2;let Ht=class extends Yt{get vertexSpec(){return{createComputedParams:vt,optionalAttributes:{zoomRange:mt,value1Position2Value2:os,lineLength:Nt},attributes:{id:gt,bitset:yt,pos:_t,offset:xt.marker,uv:us.marker,animationPointerAndBaseSizeAndReferenceSize:Pt,sizing:Mt,angle:ds}}}_write(s,t,e){const i=this.evaluatedMeshParams.sprite,{textureBinding:n}=i;s.recordStart(this.instanceId,this.attributeLayout,n);const r=t.getDisplayId();if(this.shift&&t.geometryType==="esriGeometryPolyline"){if(!e){const o=W.fromFeatureSetReaderCIM(t);o&&this._writeParticles(s,t,o)}}else if(this.evaluatedMeshParams.placement!=null)this._writePlacedMarkers(s,t);else if(t.geometryType==="esriGeometryPolygon"){const o=t.readCentroidForDisplay();if(!o)return;const[a,c]=o.coords;this._writeQuad(s,r,a,c)}else if(t.geometryType==="esriGeometryPoint"){const o=t.readXForDisplay(),a=t.readYForDisplay();this._writeQuad(s,r,o,a)}else{const o=t.readGeometryForDisplay();o&&o.forEachVertex((a,c)=>{this._writeQuad(s,r,a,c)})}s.recordEnd()}_writePlacedMarkers(s,t){const e=W.fromFeatureSetReaderCIM(t)?.clone();if(!e)return;const i=-1,n=ft.getPlacement(e,i,this.evaluatedMeshParams.placement,P(1),s.id);if(!n)return;const r=t.getDisplayId();let o=n.next(),a=null;for(;o!=null;){const c=o.tx,l=-o.ty;if(Math.abs(c)>G||Math.abs(l)>G){o=n.next();continue}const h=-o.getAngle();s.recordBounds(c,l,bt,fs),this.shift?a&&this._writeQuad(s,r,a[0],a[1],void 0,h):this._writeQuad(s,r,c,l,void 0,h),a=[c,l],o=n.next()}}_writeParticles(s,t,e){const i=t.getDisplayId();for(;e.nextPath();){const n=[];for(;e.nextPoint();)n.push([e.x,e.y]);const r=ms(n);let o=0;for(let l=1;l<n.length;l++){const h=n[l][0]-n[l-1][0],p=n[l][1]-n[l-1][1],u=Math.sqrt(h*h+p*p);o+=u}const a=l=>{for(const h of r){const{a:p,b:u}=h;this._writeQuad(s,i,p.position[0],p.position[1],[p.distance-l,u.position[0],u.position[1],u.distance-l],this.evaluatedMeshParams.angleToLine?Math.atan2(p.direction[1],p.direction[0]):0,o,!0)}},{placement:c}=this.evaluatedMeshParams;if(!c||"placementTemplate"in c||c.type==="CIMMarkerPlacementOnVertices"){let l;if(c&&c.type!=="CIMMarkerPlacementOnVertices")l=c.placementTemplate;else{l=[0];for(const p of r){const{a:u,b:d}=p,f=u.position[0]-d.position[0],m=u.position[1]-d.position[1],g=Math.sqrt(f*f+m*m);l.push(g)}}let h=-1*o;for(;h<(1+ps/2)*o;)for(const p of l)h+=p,a(h)}else c.type==="CIMMarkerPlacementAtExtremities"?c.extremityPlacement==="JustBegin"?a(1):c.extremityPlacement==="JustEnd"?(a(o-1),a(-1)):c.extremityPlacement==="Both"&&(a(1),a(o-1)):c.type==="CIMMarkerPlacementOnLine"&&(c.relativeTo==="LineBeginning"?a(1):c.relativeTo==="LineEnd"?(a(o-1),a(-1)):c.relativeTo==="LineMiddle"&&a(o/2))}}_writeQuad(s,t,e,i,n,r=0,o=0,a=!1){const c=this.evaluatedMeshParams.sprite,{rect:l}=c,h=l.x+L,p=l.y+L,u=l.x+l.width-L,d=l.y+l.height-L,f=s.vertexCount();a||s.recordBounds(e,i,bt,bt);const m={texXmin:h,texYmin:p,texXmax:u,texYmax:d,value1Position2Value2:n,angle:r/Ne,lineLength:o};for(let g=0;g<4;g++)this._writeVertex(s,t,e,i,m);s.indexEnsureSize(6),s.indexWrite(f),s.indexWrite(f+1),s.indexWrite(f+2),s.indexWrite(f+1),s.indexWrite(f+3),s.indexWrite(f+2)}};function ms(s){const t=[];let e=0;for(let i=1;i<s.length;i++){const n=s[i-1],r=s[i],o=r[0]-n[0],a=r[1]-n[1],c=Math.sqrt(o*o+a*a),l=o/c,h=a/c;t.push({a:{position:n,distance:e,direction:[l,h]},b:{position:r,distance:e+c,direction:[l,h]}}),e+=c}return t}let gs=class extends Ht{constructor(){super(...arguments),this.shift=!1}},ys=class extends Ht{constructor(){super(...arguments),this.shift=!0}};class Vt extends Yt{_write(t,e,i){const n=i??W.fromFeatureSetReaderCIM(e);if(!n)return;const r=this.evaluatedMeshParams.sprite,{textureBinding:o}=r;t.recordStart(this.instanceId,this.attributeLayout,o);const a=e.getDisplayId();this._writePoly(t,a,n.asOptimized()),t.recordEnd()}}let _s=class extends Vt{constructor(){super(...arguments),this.vertexSpec={createComputedParams:vt,attributes:{id:gt,bitset:yt,pos:_t,offset:xt.fill,tlbr:Xt,animationPointerAndBaseSizeAndReferenceSize:Pt,sizing:Mt},optionalAttributes:{zoomRange:mt,value1Position2Value2:Gt,lineLength:as}}}_writePoly(s,t,e){const i=this._clip(e);if(!i)return;e=i;const n=[],r=s.vertexCount();let o;if(Ie(n,e)){if(n.length===0)return;o=0;for(const a of n){const c=e.coords[2*a],l=e.coords[2*a+1];this._writeVertex(s,t,c,l),o++}}else{const{coords:a,lengths:c}=e,l=Ue(a,c);o=l.vertexCount;for(let h=0;h<l.buffer.length/2;h++){const p=l.buffer[2*h],u=l.buffer[2*h+1];this._writeVertex(s,t,p,u)}}if(o>0){s.indexEnsureSize(o);for(let a=0;a<o;a++)s.indexWrite(a+r)}}_clip(s){const t=this.hasEffects;return ze(s,t?256:8)}},xs=class{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0}};const Ut=65535;let Ps=class extends Vt{constructor(){super(...arguments),this.vertexSpec={createComputedParams:vt,attributes:{id:gt,bitset:yt,pos:_t,offset:xt.line,tlbr:Xt,animationPointerAndBaseSizeAndReferenceSize:Pt,sizing:Mt,accumulatedDistance:cs,normal:hs,segmentDirection:ls},optionalAttributes:{zoomRange:mt,value1Position2Value2:Gt,lineLength:Nt}},this._tessParams=new be,this._currentWrite=new xs,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:Ut,textured:!1},this._lineLength=0,this._lineTessellator=new Ve((s,t,e,i,n,r,o,a,c,l,h)=>this._writeTesselatedVertex(s,t,e,i,n,r,o,a,c,l,h,this._lineLength),this._writeTriangle.bind(this),!1)}_writePoly(s,t,e){const i=we(W.fromOptimized(e,"esriGeometryPolyline"),64);if(i==null)return;const{_currentWrite:n,_tessellationOptions:r}=this,{baseSize:o,capType:a,joinType:c,miterLimit:l}=this.evaluatedMeshParams,h=P(.5*o);r.halfWidth=h,r.capType=Se(a||"Round"),r.joinType=ke(c||"Round"),r.miterLimit=l||2,n.out=s,n.id=t,n.vertexCount=0,n.indexCount=0,n.vertexFrom=s.vertexCount(),n.vertexBounds=1;for(const{line:p,start:u,pathLength:d}of i){r.initialDistance=u%Ut,n.pathLength=d,this._lineLength=0;for(let f=1;f<p.length;f++){const m=p[f].x-p[f-1].x,g=p[f].y-p[f-1].y;this._lineLength+=Math.sqrt(m*m+g*g)}this._lineTessellator.tessellate(p,r,!1)}}_writeTesselatedVertex(s,t,e,i,n,r,o,a,c,l,h,p){const{out:u,id:d,vertexBounds:f,pathLength:m}=this._currentWrite;return this.hasEffects&&u.recordBounds(s,t,f,f),this._tessParams.extrusionOffsetX=o,this._tessParams.extrusionOffsetY=a,this._tessParams.normalX=c,this._tessParams.normalY=l,this._tessParams.directionX=n,this._tessParams.directionY=r,this._tessParams.distance=h,this._tessParams.pathLength=m,this._tessParams.lineLength=p,this._writeVertex(u,d,s,t,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(s,t,e){const{out:i}=this._currentWrite;i.indexEnsureSize(3),i.indexWrite(s),i.indexWrite(t),i.indexWrite(e),this._currentWrite.indexCount+=3}};const Ms={createComputedParams:s=>s,optionalAttributes:{},attributes:{id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:y.UNSIGNED_BYTE,count:1},pos:{type:y.SHORT,count:2,pack:"position",packPrecisionFactor:10},inverseArea:{type:y.FLOAT,count:1,packTessellation:({inverseArea:s})=>s}}};let vs=class extends Te{constructor(){super(...arguments),this.vertexSpec=Ms}createTesselationParams(s){return{inverseArea:1/s.readGeometryArea()}}};const bs={createComputedParams:s=>s,optionalAttributes:{},attributes:{pos:{type:y.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:y.UNSIGNED_BYTE,count:1},offset:{type:y.BYTE,count:2,packAlternating:{count:4,pack:()=>[[-1,-1],[1,-1],[-1,1],[1,1]]}}}};let ws=class extends j{constructor(){super(...arguments),this.vertexSpec=bs}_write(s,t){s.recordStart(this.instanceId,this.attributeLayout);const e=t.getDisplayId();if(t.geometryType==="esriGeometryPoint"){const i=t.readXForDisplay(),n=t.readYForDisplay();this._writeQuad(s,e,i,n)}else t.geometryType==="esriGeometryMultipoint"&&t.readGeometryForDisplay()?.forEachVertex((i,n)=>{i>=0&&i<=512&&n>=0&&n<=512&&this._writeQuad(s,e,i,n)});s.recordEnd()}_writeQuad(s,t,e,i){const n=s.vertexCount();this._writeVertex(s,t,e,i),s.indexWrite(n+0),s.indexWrite(n+1),s.indexWrite(n+2),s.indexWrite(n+1),s.indexWrite(n+3),s.indexWrite(n+2)}};function Qt(s,t,e){return s[0]=t[0]-e[0],s[1]=t[1]-e[1],s}function jt(s,t){return Math.sqrt(s*s+t*t)}function Zt(s){const t=jt(s[0],s[1]);s[0]/=t,s[1]/=t}function Ss(s,t){return jt(s[0]-t[0],s[1]-t[1])}function ks(s,t){return s[t+1]}function qt(s){return s.length-1}function Is(s){let t=0;for(let e=0;e<qt(s);e++)t+=zs(s,e);return t}function zs(s,t,e=1){let[i,n]=ks(s,t);return[i,n]=[Math.round(i),Math.round(n)],Math.sqrt(i*i+n*n)*e}class at{constructor(t,e,i,n,r){this._segments=t,this._index=e,this._distance=i,this._xStart=n,this._yStart=r,this._done=!1}static create(t){return new at(t,0,0,t[0][0],t[0][1])}clone(){return new at(this._segments,this._index,this._distance,this.xStart,this.yStart)}equals(t){return this._index===t._index||t._index===this._index-1&&(this._distance===0||t._distance===1)||t._index===this._index+1&&(this._distance===1||t._distance===0)}leq(t){return this._index<t._index||this._index===t._index&&this._distance<=t._distance}geq(t){return this._index>t._index||this._index===t._index&&this._distance>=t._distance}get _segment(){return this._segments[this._index+1]}get angle(){const t=this.dy,e=(0*t+-1*-this.dx)/(1*this.length);let i=Math.acos(e);return t>0&&(i=2*Math.PI-i),i}get xStart(){return this._xStart}get yStart(){return this._yStart}get x(){return this.xStart+this.distance*this.dx}get y(){return this.yStart+this.distance*this.dy}get dx(){return this._segment[0]}get dy(){return this._segment[1]}get xMidpoint(){return this.xStart+.5*this.dx}get yMidpoint(){return this.yStart+.5*this.dy}get xEnd(){return this.xStart+this.dx}get yEnd(){return this.yStart+this.dy}get length(){const{dx:t,dy:e}=this;return Math.sqrt(t*t+e*e)}get remainingLength(){return this.length*(1-this._distance)}get backwardLength(){return this.length*this._distance}get distance(){return this._distance}get done(){return this._done}hasPrev(){return this._index-1>=0}hasNext(){return this._index+1<qt(this._segments)}next(){return this.hasNext()?(this._xStart+=this.dx,this._yStart+=this.dy,this._distance=0,this._index+=1,this):null}prev(){return this.hasPrev()?(this._index-=1,this._xStart-=this.dx,this._yStart-=this.dy,this._distance=1,this):(this._done=!0,null)}_seekBackwards(t,e){const i=this.backwardLength;if(t<=i)return this._distance=(i-t)/this.length,this;let n=this.backwardLength;for(;this.prev();){if(n+this.length>t)return this._seekBackwards(t-n);n+=this.length}return this._distance=0,e?this:null}seek(t,e=!1){if(t<0)return this._seekBackwards(Math.abs(t),e);if(t<=this.remainingLength)return this._distance=(this.backwardLength+t)/this.length,this;let i=this.remainingLength;for(;this.next();){if(i+this.length>t)return this.seek(t-i,e);i+=this.length}return this._distance=1,e?this:null}}function wt(s,t,e,i=!0){const n=Is(s),r=at.create(s),o=n/2;if(!i)return r.seek(o),void(r.x<C&&r.y<C&&r.x>=0&&r.y>=0&&e(r.clone(),0,o+0*t,n));const a=Math.max((n-t)/2,0),c=Math.floor(a/t),l=o-c*t;r.seek(l);for(let h=-c;h<=c;h++)r.x<C&&r.y<C&&r.x>=0&&r.y>=0&&e(r.clone(),h,o+h*t,n),r.seek(t)}function St(s,t){const e=t;for(let i=0;i<s.length;i++){let n=s[i];Ts(n,e);const r=[];r.push(n[0]);for(let o=1;o<n.length;o++){const[a,c]=n[o-1],[l,h]=n[o],p=l-a,u=h-c;r.push([p,u])}s[i]=r,n=r}return s}function Ts(s,t){if(t<=0)return;const e=s.length;if(e<3)return;const i=[];let n=0;i.push(0);for(let h=1;h<e;h++)n+=Ss(s[h],s[h-1]),i.push(n);t=Math.min(t,.2*n);const r=[];r.push(s[0][0]),r.push(s[0][1]);const o=s[e-1][0],a=s[e-1][1],c=Qt([0,0],s[0],s[1]);Zt(c),s[0][0]+=t*c[0],s[0][1]+=t*c[1],Qt(c,s[e-1],s[e-2]),Zt(c),s[e-1][0]+=t*c[0],s[e-1][1]+=t*c[1];for(let h=1;h<e;h++)i[h]+=t;i[e-1]+=t;const l=.5*t;for(let h=1;h<e-1;h++){let p=0,u=0,d=0;for(let f=h-1;f>=0&&!(i[f+1]<i[h]-l);f--){const m=l+i[f+1]-i[h],g=i[f+1]-i[f],_=i[h]-i[f]<l?1:m/g;if(Math.abs(_)<1e-6)break;const M=_*_,b=_*m-.5*M*g,x=_*g/t,v=s[f+1],S=s[f][0]-v[0],w=s[f][1]-v[1];p+=x/b*(v[0]*_*m+.5*M*(m*S-g*v[0])-M*_*g*S/3),u+=x/b*(v[1]*_*m+.5*M*(m*w-g*v[1])-M*_*g*w/3),d+=x}for(let f=h+1;f<e&&!(i[f-1]>i[h]+l);f++){const m=l-i[f-1]+i[h],g=i[f]-i[f-1],_=i[f]-i[h]<l?1:m/g;if(Math.abs(_)<1e-6)break;const M=_*_,b=_*m-.5*M*g,x=_*g/t,v=s[f-1],S=s[f][0]-v[0],w=s[f][1]-v[1];p+=x/b*(v[0]*_*m+.5*M*(m*S-g*v[0])-M*_*g*S/3),u+=x/b*(v[1]*_*m+.5*M*(m*w-g*v[1])-M*_*g*w/3),d+=x}r.push(p/d),r.push(u/d)}r.push(o),r.push(a);for(let h=0,p=0;h<e;h++)s[h][0]=r[p++],s[h][1]=r[p++]}const $t=96;class As{constructor(t){const{offsetX:e,offsetY:i,postAngle:n,fontSize:r,haloSize:o,outlineSize:a,scaleFactor:c,transforms:l}=t;if(this.offsetX=e,this.offsetY=i,this.postAngle=n,this.fontSize=Math.min(r,$t),this.haloSize=o??0,this.outlineSize=a??0,this.transforms=l,l&&l.infos.length>1){const h=Wt(r,n,!1,e,i,l,!1);this.fontSize=Math.min(h.size,$t);const p=h.size/r;this.haloSize*=p,this.outlineSize*=p,this.postAngle=h.rotation,this.offsetX=h.offsetX,this.offsetY=h.offsetY}c&&(this.fontSize*=c,this.offsetX*=c,this.offsetY*=c)}}const V=28,F=[4,4],st=[16,4],Ls={topLeft:st,topRight:st,bottomLeft:st,bottomRight:st},it=[4,2],A=[4,6],Jt={topLeft:it,topRight:it,bottomLeft:A,bottomRight:A},Kt={topLeft:it,topRight:A,bottomLeft:it,bottomRight:A},Ds={topLeft:A,topRight:A,bottomLeft:F,bottomRight:F},Es={topLeft:F,topRight:F,bottomLeft:A,bottomRight:A},Bs={topLeft:A,topRight:F,bottomLeft:A,bottomRight:F},Rs={topLeft:F,topRight:A,bottomLeft:F,bottomRight:A},Cs={createComputedParams:s=>s,optionalAttributes:{zoomRange:{type:y.UNSIGNED_SHORT,count:2,packPrecisionFactor:Q,packTessellation:({minZoom:s,maxZoom:t})=>[s||0,t||V]},clipAngle:{type:y.UNSIGNED_BYTE,count:1,packTessellation:({clipAngle:s})=>Fs(s||0)},referenceSymbol:{type:y.BYTE,count:4,packPrecisionFactor:1,packTessellation:(s,t)=>{const e=s.isLineLabel||!s.referenceBounds,i=ge(e?"center":t.horizontalAlignment),n=ye(e?"middle":t.verticalAlignment),{offsetX:r,offsetY:o,size:a}=e?{offsetX:0,offsetY:0,size:0}:s.referenceBounds;return[P(r),-P(o),Math.round(P(a)),i+1<<2|n+1]}},visibility:{type:y.FLOAT,count:1,otherSource:!0}},attributes:{pos:{type:y.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:y.UNSIGNED_BYTE,count:1,packTessellation:({isBackground:s,mapAligned:t})=>Ae([[Xe,s],[He,!!t]])},offset:{type:y.SHORT,count:2,packPrecisionFactor:8,packAlternating:{count:4,packTessellation:({offsets:s})=>{const{bottomLeft:t,bottomRight:e,topLeft:i,topRight:n}=s;return[i,n,t,e]}}},textureUV:{type:y.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,packTessellation:({texcoords:s})=>{const{bottomLeft:t,bottomRight:e,topLeft:i,topRight:n}=s;return[i,n,t,e]}}},color:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,packTessellation:({color:s})=>s},fontAndReferenceSize:{type:y.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({fontSize:s},{referenceSize:t})=>[Math.round(P(s)),Math.round(P(t??s))]},outlineColor:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:s})=>z(s)},haloColor:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({haloColor:s})=>z(s)},outlineAndHaloSize:{type:y.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({outlineSize:s,haloSize:t})=>[Math.round(P(s)),Math.round(P(t))]}}};class te extends j{constructor(){super(...arguments),this.vertexSpec=Cs,this._textMeshParamsPropsInitialized=!1}ensurePacked(t,e,i){super.ensurePacked(t,e,i),this._textMeshParamsPropsInitialized&&!this._evaluator.hasDynamicProperties||(this._textMeshTransformProps=new As(this.evaluatedMeshParams),this._textMeshParamsPropsInitialized=!0)}_write(t,e,i){const n=this._getShaping();if(!n)return;const r=e.getDisplayId();if(this.evaluatedMeshParams.placement!=null)return this._writePlacedTextMarkers(t,e,n,i);if(i?.nextPath())return i.nextPoint(),this._writeGlyphs(t,r,i.x,i.y,n,0);if(e.geometryType==="esriGeometryPolygon"){const c=e.readCentroidForDisplay();if(!c)return;const[l,h]=c.coords;return this._writeGlyphs(t,r,l,h,n,0)}if(e.geometryType==="esriGeometryMultipoint")return void e.readGeometryForDisplay()?.forEachVertex((c,l)=>this._writeGlyphs(t,r,c,l,n,0));const o=e.readXForDisplay(),a=e.readYForDisplay();return this._writeGlyphs(t,r,o,a,n,0)}_writePlacedTextMarkers(t,e,i,n){const r=n??W.fromFeatureSetReaderCIM(e);if(!r)return;const o=-1,a=ft.getPlacement(r,o,this.evaluatedMeshParams.placement,P(1),t.id);if(!a)return;const c=e.getDisplayId();let l=a.next();for(;l!=null;){const h=l.tx,p=-l.ty,u=-l.getAngle();this._writeGlyphs(t,c,h,p,i,u),l=a.next()}}_getShaping(t){const e=this._textMeshTransformProps,i=this.evaluatedMeshParams;if(!i.glyphs?.glyphs.length)return null;const n=P(e.fontSize),r=P(e.offsetX),o=P(e.offsetY),a=Lt(P(i.lineWidth),Pe,xe),c=Me*Lt(i.lineHeightRatio,.25,4);return me(i.glyphs,{scale:n/ve,angle:e.postAngle,xOffset:r,yOffset:o,horizontalAlignment:i.horizontalAlignment,verticalAlignment:t||i.verticalAlignment,maxLineWidth:a,lineHeight:c,decoration:i.decoration,borderLineSizePx:P(i.boxBorderLineSize),hasBackground:!!i.boxBackgroundColor,useCIMAngleBehavior:i.useCIMAngleBehavior})}_writeGlyphs(t,e,i,n,r,o,a,c,l=!0){const h=this.evaluatedMeshParams,p=this._textMeshTransformProps,u=P(p.fontSize),d=p.haloSize,f=p.outlineSize,m=P(p.offsetX),g=P(p.offsetY),[_,M]=Z(h.scaleInfo,this.getTileInfo());o!==0&&r.setRotation(o);const b=r.bounds,x=i+b.x+m,v=n+b.y-g,S=2*(h.minPixelBuffer?h.minPixelBuffer/u:1),w=Math.max(b.width,b.height)*S;r.textBox&&(t.recordStart(this.instanceId,this.attributeLayout,r.glyphs[0].textureBinding),l&&t.recordBounds(x,v,w,w),this._writeTextBox(t,e,i,n,r.textBox,a,c),t.recordEnd());for(const k of r.glyphs){t.recordStart(this.instanceId,this.attributeLayout,k.textureBinding),l&&t.recordBounds(x,v,w,w);const{texcoords:R,offsets:ae}=k;this._writeQuad(t,e,i,n,{texcoords:R,offsets:ae,fontSize:u,haloSize:d,outlineSize:f,color:z(h.color),isBackground:!1,referenceBounds:a,minZoom:_,maxZoom:M,...c}),t.recordEnd()}o!==0&&r.setRotation(-o)}_writeTextBox(t,e,i,n,r,o,a){const c=this.evaluatedMeshParams,{fontSize:l,haloSize:h,outlineSize:p}=this._textMeshTransformProps,{boxBackgroundColor:u,boxBorderLineColor:d}=c,f={isBackground:!0,fontSize:l,haloSize:h,outlineSize:p,referenceBounds:o,...a};u&&(this._writeQuad(t,e,i,n,{texcoords:Ls,offsets:r.main,color:z(u),...f}),d||(this._writeQuad(t,e,i,n,{texcoords:Ds,offsets:r.top,color:z(u),...f}),this._writeQuad(t,e,i,n,{texcoords:Es,offsets:r.bot,color:z(u),...f}),this._writeQuad(t,e,i,n,{texcoords:Bs,offsets:r.left,color:z(u),...f}),this._writeQuad(t,e,i,n,{texcoords:Rs,offsets:r.right,color:z(u),...f}))),d&&(this._writeQuad(t,e,i,n,{texcoords:Jt,offsets:r.top,color:z(d),...f}),this._writeQuad(t,e,i,n,{texcoords:Jt,offsets:r.bot,color:z(d),...f}),this._writeQuad(t,e,i,n,{texcoords:Kt,offsets:r.left,color:z(d),...f}),this._writeQuad(t,e,i,n,{texcoords:Kt,offsets:r.right,color:z(d),...f}))}_writeQuad(t,e,i,n,r){const o=t.vertexCount();this._writeVertex(t,e,i,n,r),t.indexWrite(o+0),t.indexWrite(o+1),t.indexWrite(o+2),t.indexWrite(o+1),t.indexWrite(o+3),t.indexWrite(o+2)}}const Fs=s=>Math.round(s*(254/360)),rt=1,U=0,Ws=128;function Ys(s,t,e){return K(`${s}${t}${e}`)}function Os(s,t,e,i,n){return K(`${s}${t}${e}${i*2**(V-n)}`)}function Gs(s,t,e){return K(`${s}${t}${e}`)}function Ns(s,t,e,i,n){return K(`${s}${n}${t}${e*2**(V-i)}`)}const Xs=le(s=>{let t=0;if(s===0)return 1/0;for(;!(s%2);)t++,s/=2;return t});class Hs extends te{constructor(){super(...arguments),this._zoomLevel=0}_write(t,e,i,n){if(this._zoomLevel=n||0,i!=null)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(e.geometryType){case"esriGeometryPoint":{const r=e.readXForDisplay(),o=e.readYForDisplay();this._writePoint(t,r,o,0,e);break}case"esriGeometryEnvelope":case"esriGeometryPolygon":{const r=e.readCentroidForDisplay();if(!r)return;const[o,a]=r.coords;this._writePoint(t,o,a,0,e);break}case"esriGeometryMultipoint":{let r=0;const o=W.fromFeatureSetReader(e);if(o?.nextPath())for(;o.nextPoint();)this._writePoint(t,o.x,o.y,r++,e);break}case"esriGeometryPolyline":this._writeLines(t,e)}}_getMetricDir(){const{horizontalAlignment:t,verticalAlignment:e}=this.evaluatedMeshParams;return[t==="center"?0:t==="right"?-1:1,e==="middle"?0:e==="bottom"?-1:1]}_createLineLabelMetric(t,e,i,n,r,o){const[a,c]=this._getMetricDir(),l=this.evaluatedMeshParams.scaleInfo?.maxScale??0,h=this.evaluatedMeshParams.scaleInfo?.minScale??0,p=this.evaluatedMeshParams.labelClassId;return new Ft(t,p,e,i,n,r,a,c,l,h,o)}_writePoint(t,e,i,n,r){if(e<0||e>C||i<0||i>C)return;const o=this._getShaping();if(!o)return;const a=r.getDisplayId(),c=this.evaluatedMeshParams.labelClassId,l=Ys(this.evaluatedMeshParams.layerId,r.getObjectId(),n),h=Gs(r.getObjectId(),c,n),[p,u]=this._getMetricDir(),d=this.evaluatedMeshParams.scaleInfo?.maxScale??0,f=this.evaluatedMeshParams.scaleInfo?.minScale??0,m=this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0};t.metricStart(new Ft(a,c,l,h,e,i,p,u,d,f,m)),this._writeGlyphs(t,a,e,i,o,0,m,void 0,!1),t.metricBoxWrite(o.boundsT),t.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const t of this._references){const e=t.getBoundsInfo();if(e)return e}return null}_writeLines(t,e){const{scaleInfo:i,verticalAlignment:n}=this.evaluatedMeshParams,r=this.evaluatedMeshParams.repeatLabelDistance||128,o=this._getShaping("middle");if(!o)return;const a=(l,h,p,u)=>this._placeSubdivGlyphs(l,h,p,u),c=(o.bounds.width+r)/(1<<rt);this._current={out:t,id:e.getDisplayId(),objId:e.getObjectId(),shaping:o,zoomRange:Z(i,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null,pathIndex:0},this._verticalPlacement=n==="bottom"?"above":n==="top"?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(e,a,c):this._writeCenterAlong(e,a,c)}_writeAboveAndBelowAlong(t,e,i){const{repeatLabel:n}=this.evaluatedMeshParams,{shaping:r}=this._current,o=r.bounds.halfHeight,a=t.readGeometryForDisplay();if(!a)return;const c=new dt;Ze(c,a,!1,!1,"esriGeometryPolyline",1);const l=ee(new dt,c,o),h=ee(new dt,c,-o),p=Rt(h,"esriGeometryPolyline",!1,!1),u=Rt(l,"esriGeometryPolyline",!1,!1),d=St(u.paths,r.bounds.width),f=St(p.paths,r.bounds.width);this._current.offsetDirection="above";for(let m=0;m<d.length;m++)this._current.pathIndex=m,wt(d[m],i,e,!!n);this._current.offsetDirection="below";for(let m=0;m<f.length;m++)this._current.pathIndex=m,wt(f[m],i,e,!!n)}_writeCenterAlong(t,e,i){const{repeatLabel:n}=this.evaluatedMeshParams,{shaping:r}=this._current,o=St(t.readLegacyGeometryForDisplay().paths,r.bounds.width);for(let a=0;a<o.length;a++)this._current.pathIndex=a,wt(o[a],i,e,!!n)}_placeSubdivGlyphs(t,e,i,n){const{allowOverrun:r,labelPosition:o,repeatLabelDistance:a,layerId:c,labelClassId:l}=this.evaluatedMeshParams,{objId:h,shaping:p,pathIndex:u}=this._current,d=this._current.zoomRange[0],f=Xs(e),m=this._current.shaping.bounds.width/(1<<rt),g=Math.sqrt(a||Ws)/(1<<rt),_=Math.min(i,n-i),M=p.isMultiline?V:Math.log2(_/(g+m/2)),b=e===0?M:Math.min(f,M),x=Math.max(d,this._zoomLevel+rt-b),v=this._zoomLevel-x,S=p.bounds.width/2*2**v,w=Os(c,h,u,e,this._zoomLevel),k=Ns(h,u,e,this._zoomLevel,l);this._current.shaping.isMultiline?e===0&&this._placeStraight(t,x,w,k):r&&v<0?this._placeStraightAlong(t,d,w,k):o==="parallel"?this._placeStraightAlong(t,x,w,k):o==="curved"&&this._placeCurved(t,x,S,w,k)}_placeStraight(t,e,i,n){const{out:r,id:o,shaping:a,referenceBounds:c}=this._current,{x:l,y:h}=t;r.metricStart(this._createLineLabelMetric(o,i,n,l,h)),r.metricBoxWrite(a.boundsT);const p=t.angle*(180/Math.PI)%360,u=(t.angle*(180/Math.PI)+180)%360;if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const d={clipAngle:p,mapAligned:!0,isLineLabel:!0,minZoom:e};this._writeGlyphs(r,o,l,h,a,0,c,d,!1)}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const d={clipAngle:u,mapAligned:!0,isLineLabel:!0,minZoom:e};this._writeGlyphs(r,o,l,h,a,0,c,d,!1)}r.metricEnd()}_placeCurved(t,e,i,n,r){const{out:o,id:a}=this._current;o.metricStart(this._createLineLabelMetric(a,n,r,t.x,t.y));const c=t.clone(),l=t.angle*(180/Math.PI)%360,h=(t.angle*(180/Math.PI)+180)%360;this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(c,e,1,l),this._placeBack(t,c,e,i,1,l),this._placeForward(t,c,e,i,1,l)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(c,e,0,h),this._placeBack(t,c,e,i,0,h),this._placeForward(t,c,e,i,0,h)),o.metricEnd()}_placeStraightAlong(t,e,i,n){const{out:r,id:o,shaping:a,zoomRange:c,referenceBounds:l}=this._current,{boxBorderLineColor:h,boxBackgroundColor:p}=this.evaluatedMeshParams,u=t.clone(),d=t.angle*(180/Math.PI)%360,f=(t.angle*(180/Math.PI)+180)%360,m=a.glyphs.length>0&&!(!h&&!p);if(r.metricStart(this._createLineLabelMetric(o,i,n,t.x,t.y)),m){const g=Math.max(e,c[0],0),_=Math.min(V,c[1]),M=ht(N(),-t.angle),b={minZoom:g,maxZoom:_,clipAngle:d,mapAligned:!0,isLineLabel:!0},x=P(this.evaluatedMeshParams.offsetX),v=P(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const S=et(x,-1*v),[w,k]=a.shapeBackground(ut(N(),M,S));r.recordStart(this.instanceId,this.attributeLayout,a.glyphs[0].textureBinding),this._writeTextBox(r,o,t.x,t.y,k,l,b),r.recordEnd()}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const S=et(x,v),[w,k]=a.shapeBackground(ut(N(),M,S));b.clipAngle=f,r.recordStart(this.instanceId,this.attributeLayout,a.glyphs[0].textureBinding),this._writeTextBox(r,o,t.x,t.y,k,l,b),r.recordEnd()}}this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(u,e,1,d,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(u,e,0,f,!0),r.metricEnd()}_placeBack(t,e,i,n,r,o){const a=t.clone();let c=t.backwardLength+U;for(;a.prev()&&!(c>=n);)this._placeOnSegment(a,e,c,i,-1,r,o),c+=a.length+U}_placeForward(t,e,i,n,r,o){const a=t.clone();let c=t.remainingLength+U;for(;a.next()&&!(c>=n);)this._placeOnSegment(a,e,c,i,1,r,o),c+=a.length+U}_placeFirst(t,e,i,n,r=!1){const{out:o,id:a,shaping:c,zoomRange:l,referenceBounds:h}=this._current,p=c.glyphs,u=P(this.evaluatedMeshParams.offsetX),d=P(this.evaluatedMeshParams.offsetY),f=et(u,d),m=ht(N(),-t.angle);O(f,f,m);for(const g of p){const _=g.x>c.bounds.x?i:1-i,M=_*t.remainingLength+(1-_)*t.backwardLength,b=Math.abs(g.x+g.width/2-c.bounds.x),x=Math.max(0,this._zoomLevel+Math.log2(b/(M+U))),v=Math.max(e,r?0:x);if(g.maxZoom=Math.min(l[1],V),g.angle=t.angle+(1-i)*Math.PI,g.minZoom=Math.max(l[0],v),this._writeLineGlyph(o,a,t.x,t.y,g,n,h,!0),(i||this._current.offsetDirection)&&this._isVisible(g.minZoom,g.maxZoom)){const S=new Ct(g.bounds.x+f[0],g.bounds.y+f[1],g.bounds.width,g.bounds.height);o.metricBoxWrite(S)}}}_placeOnSegment(t,e,i,n,r,o,a){const{out:c,id:l,shaping:h,referenceBounds:p}=this._current,u=h.glyphs,d=t.dx/t.length,f=t.dy/t.length,m={x:t.x+i*-r*d,y:t.y+i*-r*f},g=P(this.evaluatedMeshParams.offsetX),_=P(this.evaluatedMeshParams.offsetY),M=et(g,_),b=ht(N(),-t.angle);O(M,M,b);for(const x of u){const v=x.x>h.bounds.x?o:1-o;if(!(v&&r===1||!v&&r===-1))continue;const S=Math.abs(x.x+x.width/2-h.bounds.x),w=Math.max(0,this._zoomLevel+Math.log2(S/i)-.1),k=Math.max(n,this._zoomLevel+Math.log2(S/(i+t.length+U)));if(w!==0&&(x.angle=t.angle+(1-o)*Math.PI,x.minZoom=k,x.maxZoom=w,this._writeLineGlyph(c,l,m.x,m.y,x,a,p,!0),(o||this._current.offsetDirection)&&this._isVisible(x.minZoom,x.maxZoom))){const R=new Ct(x.bounds.x+M[0],x.bounds.y+M[1],x.bounds.width,x.bounds.height);c.metricBoxWrite(R)}}}_writeLineGlyph(t,e,i,n,r,o,a,c){if(i<0||i>C||n<0||n>C)return;t.recordStart(this.instanceId,this.attributeLayout,r.textureBinding);const{texcoords:l,offsets:h}=r,{fontSize:p,haloSize:u,outlineSize:d}=this._textMeshTransformProps;this._writeQuad(t,e,i,n,{texcoords:l,offsets:h,fontSize:p,haloSize:u,outlineSize:d,color:z(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:a,minZoom:Math.max(this._current.zoomRange[0],r.minZoom),maxZoom:Math.min(this._current.zoomRange[1],r.maxZoom),clipAngle:o,mapAligned:c,isLineLabel:!0}),t.recordEnd()}_packedZoom(t){return Math.floor(t*Q)/Q}_isVisible(t,e){let i=Math.max(this._current.zoomRange[0],t),n=Math.min(this._current.zoomRange[1],e);i=this._packedZoom(i),n=this._packedZoom(n);const r=this._packedZoom(this._zoomLevel);return i<=r&&r<=n}}function ee(s,t,e){const{coords:i,lengths:n}=t,r=X(),o=X(),a=X(),c=X(),l=X(),h=X(),p=2;let u=0;for(let d=0;d<n.length;d++){const f=n[d];for(let m=0;m<f;m++){const g=p*(m+u-1),_=p*(m+u),M=p*(m+u+1);m>0?B(r,i[g],i[g+1]):B(r,0,0),B(o,i[_],i[_+1]),m<f-1?B(a,i[M],i[M+1]):B(a,0,0),m===0?B(c,0,0):(Dt(c,o,r),ct(c,c),B(c,c[1],-c[0])),m===f-1?B(l,0,0):(Dt(l,a,o),ct(l,l),B(l,l[1],-l[0])),he(h,c,l),ct(h,h);const b=h[0]*l[0]+h[1]*l[1];b!==0&&Et(h,h,b),Et(h,h,e),s.coords.push(o[0]+h[0],o[1]+h[1])}s.lengths.push(f),u+=f}return s}let Vs=class Tt{static from(t){return"width"in t?this.fromSimpleMeshParams(t):this.fromComplexMeshParams(t)}static fromSimpleMeshParams(t){const e=new Tt(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects),{type:i,width:n,height:r,angle:o,alignment:a,outlineSize:c,referenceSize:l,sprite:h,overrideOutlineColor:p}=t;return e.rawWidth=P(n),e.rawHeight=P(r),e.angle=o,e.alignment=a,e.outlineSize=P(c),e.referenceSize=P(l),e.overrideOutlineColor=p,e.offsetX=P(t.offsetX),e.offsetY=P(t.offsetY),i!=="simple"||h.sdf||(e.rawWidth=h.width,e.rawHeight=h.height),e._computeSize(t,!1),e}static fromComplexMeshParams(t){const e=new Tt(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects);let{alignment:i,transforms:n,size:r,scaleX:o,anchorX:a,anchorY:c,angle:l,colorLocked:h,frameHeight:p,widthRatio:u,offsetX:d,offsetY:f,outlineSize:m,referenceSize:g,scaleFactor:_,sizeRatio:M,isAbsoluteAnchorPoint:b,rotateClockwise:x,scaleSymbolsProportionally:v,sprite:S}=t;if(n&&n.infos.length>0){const R=Wt(r,l,x,d,f,n);r=R.size,l=R.rotation,d=R.offsetX,f=R.offsetY,x=!1}_&&(r*=_,d*=_,f*=_);const w=o*(S.width/S.height);e.alignment=i,e.rawHeight=P(r),e.rawWidth=e.rawHeight*w,e.referenceSize=P(g),e.sizeRatio=M,e.sdfDecodeCoeff=(S.sdfDecodeCoeff??1)*M,e.angle=l,e.rotateClockwise=x,e.anchorX=a,e.anchorY=c,e.offsetX=P(d),e.offsetY=P(f),b&&r&&(S.sdf?e.anchorX=a/(r*u):e.anchorX=a/(r*w),e.anchorY=c/r);const k=v&&p?r/p:1;return e.outlineSize=m===0||isNaN(m)?0:P(m)*k,e.scaleSymbolsProportionally=v,e.colorLocked=h,e._computeSize(t,!0),e}constructor(t,e,i,n,r,o,a){this.sprite=t,this.color=e,this.outlineColor=i,this.minPixelBuffer=n,this.placement=r,this.scaleInfo=o,this.effects=a,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.sdfDecodeCoeff=1,this.alignment=0,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize(t,e){const{sprite:i,hasSizeVV:n}=t,r=!!i.sdf,o=i.sdfPaddingRatio??.5,{rawWidth:a,rawHeight:c,sizeRatio:l,outlineSize:h}=this,p=i.rect;let u=a*l,d=c*l,f=0,m=0;if(r){const x=1/(1-o);if(u*=x,d*=x,n)this.computedWidth=u,this.computedHeight=d;else{const v=e&&a>c?u:a,S=c,w=h+2;this.computedWidth=Math.min(v+w,u),this.computedHeight=Math.min(S+w,d);const k=Math.max(i.width,i.height)/Math.max(u,d);f=(this.computedWidth-u)*k,m=(this.computedHeight-d)*k}}else this.computedWidth=u*(p.width/i.width),this.computedHeight=d*(p.height/i.height),f=2*L,m=2*L;const g=p.x+L-f/2,_=p.y+L-m/2,M=g+i.width+f,b=_+i.height+m;this.texXmin=se(g),this.texYmin=se(_),this.texXmax=ie(M),this.texYmax=ie(b),this.computedWidth*=(this.texXmax-this.texXmin)/(M-g),this.computedHeight*=(this.texYmax-this.texYmin)/(b-_),this.anchorX*=u/this.computedWidth,this.anchorY*=d/this.computedHeight}};function se(s,t=1e-7){const e=Math.ceil(s);return e-s<t?e:Math.floor(s)}function ie(s,t=1e-7){const e=Math.floor(s);return s-e<t?e:Math.ceil(s)}const Us=3.14159265359/180,Qs=128/Math.PI;function js(s,t){return s%=t,Math.abs(s>=0?s:s+t)}function Zs(s){return js(s*Qs,256)}function qs(s,t,e,i,n=!1){const r=N(),o=n?1:-1;return Qe(r),(t||e)&&ut(r,r,[t,-e]),i&&je(r,r,o*Us*-i),r}const $s={createComputedParams:s=>Vs.from(s),optionalAttributes:{zoomRange:{type:y.SHORT,count:2,packPrecisionFactor:Q,pack:({scaleInfo:s},{tileInfo:t})=>Z(s,t)}},attributes:{pos:{type:y.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:y.UNSIGNED_BYTE,count:1,pack:({sprite:s,alignment:t,scaleSymbolsProportionally:e,overrideOutlineColor:i,colorLocked:n})=>{let r=0;return s.sdf&&(r|=D(E.bitset.isSDF)),t===1&&(r|=D(E.bitset.isMapAligned)),e&&(r|=D(E.bitset.scaleSymbolsProportionally)),i&&(r|=D(E.bitset.overrideOutlineColor)),n&&(r|=D(E.bitset.colorLocked)),r}},offset:{type:y.HALF_FLOAT,count:2,packAlternating:{count:4,pack:({angle:s,computedWidth:t,computedHeight:e,anchorX:i,anchorY:n,offsetX:r,offsetY:o,rotateClockwise:a})=>{const c=qs(0,r,o,-s,a),l=-(.5+i)*t,h=-(.5-n)*e,p=[l,h],u=[l+t,h],d=[l,h+e],f=[l+t,h+e];return O(p,p,c),O(u,u,c),O(d,d,c),O(f,f,c),[p,u,d,f]}}},textureUV:{type:y.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({texXmax:s,texXmin:t,texYmax:e,texYmin:i})=>[[t,i],[s,i],[t,e],[s,e]]}},color:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:s})=>z(s)},outlineColor:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:s})=>z(s)},sizing:{type:y.UNSIGNED_BYTE,count:4,pack:({rawWidth:s,rawHeight:t,outlineSize:e,referenceSize:i})=>{const n=Math.max(s,t);return[lt(n,128),lt(e,128),lt(i,128),0]}},placementAngle:{type:y.UNSIGNED_BYTE,count:1,packTessellation:({placementAngle:s})=>Zs(s)},sdfDecodeCoeff:{type:y.UNSIGNED_SHORT,count:1,packPrecisionFactor:64,pack:({sdfDecodeCoeff:s})=>s}}};let Js=class extends j{constructor(){super(...arguments),this.vertexSpec=$s}getBoundsInfo(){return this.evaluatedMeshParams.boundsInfo}_write(s,t,e){const i=this.evaluatedMeshParams.sprite?.textureBinding,n=t.getDisplayId();s.recordStart(this.instanceId,this.attributeLayout,i);const r=this.evaluatedMeshParams.minPixelBuffer,o=Math.max(this.evaluatedMeshParams.computedWidth,r),a=Math.max(this.evaluatedMeshParams.computedHeight,r),c=-this.evaluatedMeshParams.anchorX*this.evaluatedMeshParams.computedWidth,l=this.evaluatedMeshParams.anchorY*this.evaluatedMeshParams.computedHeight,h=this.evaluatedMeshParams.offsetX+c,p=-this.evaluatedMeshParams.offsetY+l;if(this.evaluatedMeshParams.placement!=null){let u=null;if(e!=null){const d=Math.max(this.evaluatedMeshParams.computedWidth,this.evaluatedMeshParams.computedHeight);if(u=_e(e,2*d,!1),u===null)return}this._writePlacedMarkers(s,t,u,o,a)}else if(e?.nextPath()){e.nextPoint();const u=e.x,d=e.y;s.recordBounds(u+h,d+p,o,a),this._writeQuad(s,n,u,d)}else if(t.geometryType==="esriGeometryPolygon"){const u=t.readCentroidForDisplay();if(!u)return;const[d,f]=u.coords;s.recordBounds(d+h,f+p,o,a),this._writeQuad(s,n,d,f)}else if(t.geometryType==="esriGeometryPoint"){const u=t.readXForDisplay(),d=t.readYForDisplay();s.recordBounds(u+h,d+p,o,a),this._writeQuad(s,n,u,d)}else t.readGeometryForDisplay()?.forEachVertex((u,d)=>{s.recordBounds(u+h,d+p,o,a),Math.abs(u)>G||Math.abs(d)>G||this._writeQuad(s,n,u,d)});s.recordEnd()}_writePlacedMarkers(s,t,e,i,n){const r=e??W.fromFeatureSetReaderCIM(t);if(!r)return;const o=-1,a=ft.getPlacement(r,o,this.evaluatedMeshParams.placement,P(1),s.id);if(!a)return;const c=t.getDisplayId();let l=a.next();const h=this.evaluatedMeshParams.offsetX,p=-this.evaluatedMeshParams.offsetY;for(;l!=null;){const u=l.tx,d=-l.ty;if(Math.abs(u)>G||Math.abs(d)>G){l=a.next();continue}const f=-l.getAngle();s.recordBounds(u+h,d+p,i,n),this._writeQuad(s,c,u,d,f),l=a.next()}}_writeQuad(s,t,e,i,n){const r=s.vertexCount(),o=n==null?null:{placementAngle:n};this._writeVertex(s,t,e,i,o),s.indexWrite(r+0),s.indexWrite(r+1),s.indexWrite(r+2),s.indexWrite(r+1),s.indexWrite(r+3),s.indexWrite(r+2)}};class re extends Je{constructor(t){super(),this._value=t}resize(t){}read(t,e){return this._value}readWithDefault(t,e,i){return this._value}hasArcadeDependency(t){return!1}}const Ks=()=>de.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator");async function nt(s,t,e,i){const{defaultValue:n,valueExpressionInfo:r,value:o}=t;if(r){if(r.type==="dictionary-template")return{...t,computed:s.createDictionaryTemplateField(r,e),defaultValue:n};const{expression:a}=r,c=await s.createComputedField({expression:a},i);return c?{...t,computed:c,defaultValue:n}:null}return{...t,computed:new re(o),defaultValue:n}}async function ne(s,t,e){const{valueExpressionInfo:i}=t,n=i.type==="dictionary-template"?s.createDictionaryTemplateField(i,e):await s.createComputedField({expression:i.expression});return n?{...t,computed:n}:null}function oe(s){return typeof s=="object"&&s!=null&&(!(!("valueExpressionInfo"in s)||!s.valueExpressionInfo)||"type"in s&&s.type==="Process"&&"op"in s&&s.op==="Random")}function ot(s){if(Array.isArray(s)){for(const t of s)if(ot(t))return!0}if(typeof s=="object"){if(oe(s))return!0;for(const t in s)if(ot(s[t]))return!0}return!1}class At{static async create(t,e,i,n){const r={},o=new Map,a=new Map,c=new Map,l=new Map,h=new Map,p=new Map;for(const u in i){const d=i[u];if(d!=null&&typeof d=="object")if(Array.isArray(d)){if(typeof d[0]=="object")throw new Error(`InternalError: Cannot handle ${u}. Nested array params are not supported`);r[u]=d}else{if("valueExpressionInfo"in d){if(d.value){r[u]=d.value;continue}const f=await ne(t,d,n);if(!f){r[u]=d.defaultValue;continue}o.set(u,f),r[u]=null;continue}switch(d.type){case"cim-effect-infos":if(d.effectInfos.some(f=>f.overrides.length)){a.set(u,{effects:await Promise.all(d.effectInfos.map(async f=>{const m=f.overrides.map(g=>nt(t,g,n,!1));return{effect:f.effect,compiledOverrides:(await Promise.all(m)).filter(tt)}}))});break}r[u]=d.effectInfos.map(f=>f.effect);break;case"cim-marker-placement-param":d.overrides.length&&c.set(u,{placementInfo:d,compiledOverrides:(await Promise.all(d.overrides.map(f=>nt(t,f,n,!1)))).filter(tt)}),r[u]=d.placement;break;case"text-rasterization-param":{if(d.overrides.length){const m=d.overrides.map(g=>nt(t,g,n,d.useLegacyLabelEvaluationRules??!1));l.set(u,{compiledOverrides:(await Promise.all(m)).filter(tt),rasterizationParam:d,objectIdToResourceId:new Map});continue}const f={type:"cim-rasterization-info",resource:d.resource};r[u]=await e.fetchResourceImmediate(f)??null;break}case"sprite-rasterization-param":{if(d.overrides.length){const m=d.overrides.map(g=>nt(t,g,n,!1));l.set(u,{compiledOverrides:(await Promise.all(m)).filter(tt),rasterizationParam:d,objectIdToResourceId:new Map});continue}if(d.resource.type==="animated"){l.set(u,{compiledOverrides:[],rasterizationParam:d,objectIdToResourceId:new Map});continue}const f={type:"cim-rasterization-info",resource:d.resource};r[u]=await e.fetchResourceImmediate(f)??null;break}case"cim-marker-transform-param":{const{params:f}=d;if(ot(f)){const m={compiledMarkerInfos:[]};await Promise.all(f.map(async g=>{const _={props:{}};for(const M in g)if(oe(g[M])){const b=await ne(t,g[M],n);_.compiledExpressionMap||(_.compiledExpressionMap=new Map);const x=_.compiledExpressionMap;b&&x.set(M,b)}else _.props[M]=g[M];m.compiledMarkerInfos.push(_)})),h.set(u,m)}else r[u]={type:"cim-marker-transform-info",infos:f};break}case"animation-params":{const{params:f}=d,m=ns(f);if(ot(m)){const g=await Promise.all(m.map(_=>pt(_,t)));p.set(u,{params:g,propertyIdToResourceId:new Map,key:u})}else{const g=rs(m),_=await e.fetchResourceImmediate({type:"animation-info",resource:g});_!=null&&_.type==="sprite"&&(r[u]={dataRow:_.rect.y,dataColumn:_.rect.x})}break}default:r[u]=d}}else r[u]=d}return new At(i,r,o,a,c,l,h,p)}constructor(t,e,i,n,r,o,a,c){this.inputMeshParams=t,this._resolvedMeshParams=e,this._dynamicProperties=i,this._dynamicEffectProperties=n,this._dynamicPlacementProperties=r,this._dynamicAsyncProperties=o,this._dynamicTransformProperties=a,this._dynamicAsyncAnimations=c,this.evaluator=l=>l,this._arcadeDependencies=new Set;for(const l of this._expressions())$e(this._arcadeDependencies,l)}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size||this._dynamicAsyncAnimations.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(t,e,i){for(const n of this._dynamicAsyncProperties.values()){const r=ue(n.rasterizationParam.resource);n.rasterizationParam.resource.type==="animated"&&n.rasterizationParam.resource.randomizeStartTime&&(r.primitiveName="__RESERVED__PRIMITIVE__NAME__",r.startGroup=Bt(e.getObjectId()||0));for(const{primitiveName:a,propertyName:c,computed:l,defaultValue:h,valueExpressionInfo:p}of n.compiledOverrides)try{const u=n.rasterizationParam.resource.type==="animated"?r.primitiveName:a;qe(r,u,c,l,e,i,h)}catch(u){Ks().errorOnce(new fe("invalid-arcade-expression","Encountered an error when evaluating the arcade expression",{error:u,valueExpressionInfo:p}))}const o=t.enqueueRequest({type:"cim-rasterization-info",resource:r});n.objectIdToResourceId.set(e.getObjectId(),o)}for(const n of this._dynamicAsyncAnimations.values()){const r=n.params.map(c=>I(c,e,i)).map(q).map(c=>c.simplify()),o=Ot(r),a=t.enqueueRequest({type:"animation-info",resource:o});n.propertyIdToResourceId.set(e.getObjectId()+"."+n.key,a)}}evaluateMeshParams(t,e,i){for(const[n,r]of this._dynamicProperties.entries())this._resolvedMeshParams[n]=r.computed.readWithDefault(e,i,r.defaultValue);for(const[n,r]of this._dynamicPlacementProperties.entries())for(const{computed:o,defaultValue:a,propertyName:c}of r.compiledOverrides){const l=o.readWithDefault(e,i,a);r.placementInfo.placement[c]=l,this._resolvedMeshParams[n]=r.placementInfo.placement}for(const[n,r]of this._dynamicEffectProperties.entries())for(const o of r.effects){for(const{computed:a,defaultValue:c,propertyName:l}of o.compiledOverrides){const h=a.readWithDefault(e,i,c);o.effect[l]=h}this._resolvedMeshParams[n]=r.effects.map(a=>a.effect)}for(const[n,r]of this._dynamicTransformProperties.entries()){const o={type:"cim-marker-transform-info",infos:[]};for(const a of r.compiledMarkerInfos){const c={...a.props};if(a.compiledExpressionMap)for(const[l,h]of a.compiledExpressionMap){const p=h.computed.readWithDefault(e,i,h.defaultValue);c[l]=typeof p=="number"||typeof p=="boolean"?p:h.defaultValue}o.infos.push(c)}this._resolvedMeshParams[n]=o}for(const[n,r]of this._dynamicAsyncProperties.entries()){const o=r.objectIdToResourceId.get(e.getObjectId());if(o==null)continue;const a=t.getResource(o);this._resolvedMeshParams[n]=a}for(const[n,r]of this._dynamicAsyncAnimations.entries()){const o=r.propertyIdToResourceId.get(e.getObjectId()+"."+n);if(o==null)continue;const a=t.getResource(o);this._resolvedMeshParams[n]={dataRow:a.rect.y,dataColumn:a.rect.x}}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}hasArcadeDependency(t){return this._arcadeDependencies.has(t)}*_expressions(){for(const t of this._dynamicProperties.values())yield t.computed;for(const t of this._dynamicEffectProperties.values())for(const e of t.effects)for(const i of e.compiledOverrides)yield i.computed;for(const t of this._dynamicPlacementProperties.values())for(const e of t.compiledOverrides)yield e.computed;for(const t of this._dynamicAsyncProperties.values())for(const e of t.compiledOverrides)yield e.computed;for(const t of this._dynamicTransformProperties.values())for(const e of t.compiledMarkerInfos)if(e.compiledExpressionMap!=null)for(const i of e.compiledExpressionMap.values())yield i.computed;for(const t of this._dynamicAsyncAnimations.values())for(const e of t.params)yield*T(e)}}const ti={createComputedParams:s=>s,optionalAttributes:{},attributes:{pos:{type:y.SHORT,count:2,packPrecisionFactor:10,pack:"position"},id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:y.UNSIGNED_BYTE,count:1,pack:s=>0},offset:{type:y.SHORT,count:2,packPrecisionFactor:16,packAlternating:{count:4,pack:({size:s})=>{const t=P(s),e=-t/2,i=-t/2;return[[e,i],[e+t,i],[e,i+t],[e+t,i+t]]}}},texCoords:{type:y.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:()=>[[0,1],[1,1],[0,0],[1,0]]}},size:{type:y.UNSIGNED_BYTE,count:2,pack:({size:s})=>[s,s]},referenceSize:{type:y.UNSIGNED_BYTE,count:1,pack:({size:s})=>P(s)},zoomRange:{type:y.UNSIGNED_BYTE,count:2,pack:({scaleInfo:s},{tileInfo:t})=>Z(s,t)}}};class ei extends j{constructor(){super(...arguments),this.vertexSpec=ti}_write(t,e){const i=e.getDisplayId(),n=this.evaluatedMeshParams.minPixelBuffer,r=Math.max(P(this.evaluatedMeshParams.size),n);let o,a;if(e.geometryType==="esriGeometryPoint")o=e.readXForDisplay(),a=e.readYForDisplay();else{const l=e.readCentroidForDisplay();if(!l)return;o=l?.coords[0],a=l?.coords[1]}t.recordStart(this.instanceId,this.attributeLayout),t.recordBounds(o,a,r,r);const c=t.vertexCount();this._writeVertex(t,i,o,a),t.indexWrite(c+0),t.indexWrite(c+1),t.indexWrite(c+2),t.indexWrite(c+1),t.indexWrite(c+3),t.indexWrite(c+2),t.recordEnd()}}class si{async createMeshWriter(t,e,i,n,r){const o=this._getMeshWriter(n.techniqueType),a=await At.create(t,e,n.inputParams,r),c=new o(n.id,a,n.optionalAttributes,i);return await c.loadDependencies(),c}_getMeshWriter(t){switch(t){case 13:return Oe;case 11:return vs;case 9:return Ye;case 26:return We;case 14:return Fe;case 24:return Ce;case 27:return Re;case 10:return Be;case 21:return Js;case 28:return ei;case 30:return te;case 19:return Ee;case 31:return De;case 15:return Le;case 17:return ws;case 18:return Hs;case 2:return gs;case 3:return ys;case 0:return _s;case 1:return Ps;default:throw new Error("Internal Error: Mesh writer not in the registry")}}}export{re as r,si as x};
