import{dU as u,aG as y,cl as m}from"./main-CSjwO60s.js";import{N as R,W as d}from"./projectionUtils-CsX1UTBu.js";class f{constructor(n){this.geometry=n,this.spatialReference=n.spatialReference}export(){return this._exporter(this.coordinates,this.spatialReference)}clone(n){const s=new f(this.geometry);return s.spatialReference=this.spatialReference,s.coordinates=n??this.coordinates.map(t=>t.clone()),s._exporter=this._exporter,s}async project(n,s){if(this.spatialReference.equals(n))return this.clone();await R([{source:this.spatialReference,dest:n}],{signal:s});const t=new u({spatialReference:this.spatialReference,points:this.coordinates.map(l=>[l.x,l.y])}),a=d(t,n);if(!a)return null;const r=this.coordinates.map((l,i)=>{const p=l.clone(),o=a.points[i];return p.x=o[0],p.y=o[1],p}),e=this.clone(r);return e.spatialReference=n,e}static fromGeometry(n){const s=new f(n);if(n instanceof f)return s.coordinates=n.coordinates.map(t=>t.clone()),s._exporter=(t,a)=>{const r=n.clone(t);return r.spatialReference=a,r},s;switch(n.type){case"point":{const t=n,{hasZ:a,hasM:r}=t;return s.coordinates=a&&r?[new c(t.x,t.y,t.z,t.m)]:a?[new c(t.x,t.y,t.z)]:r?[new c(t.x,t.y,null,t.m)]:[new c(t.x,t.y)],s._exporter=(e,l)=>n.hasM?new m(e[0].x,e[0].y,e[0].z,e[0].m,l):new m(e[0].x,e[0].y,e[0].z,l),s}case"multipoint":{const t=n,{hasZ:a,hasM:r}=t;return s.coordinates=a&&r?t.points.map(e=>new c(e[0],e[1],e[2],e[3])):a?t.points.map(e=>new c(e[0],e[1],e[2])):r?t.points.map(e=>new c(e[0],e[1],null,e[2])):t.points.map(e=>new c(e[0],e[1])),s._exporter=(e,l)=>n.hasM?new u({points:e.map(i=>[i.x,i.y,i.z??0,i.m??0]),hasZ:!0,hasM:!0,spatialReference:l}):new u({points:e.map(i=>[i.x,i.y,i.z??0]),spatialReference:l}),s}case"polyline":{const t=n,a=[],r=[],{hasZ:e,hasM:l}=n;let i=0;for(const p of t.paths)if(r.push([i,i+p.length]),i+=p.length,e&&l)for(const o of p)a.push(new c(o[0],o[1],o[2],o[3]));else if(e)for(const o of p)a.push(new c(o[0],o[1],o[2]));else if(l)for(const o of p)a.push(new c(o[0],o[1],null,o[2]));else for(const o of p)a.push(new c(o[0],o[1]));return s.coordinates=a,s._exporter=(p,o)=>{const w=n.hasM?p.map(h=>[h.x,h.y,h.z??0,h.m??0]):p.map(h=>[h.x,h.y,h.z??0]),x=r.map(h=>w.slice(h[0],h[1]));return new y({paths:x,hasM:n.hasM,hasZ:!0,spatialReference:o})},s}}}}class c{constructor(n,s,t=null,a=null,r=null,e=null){this.x=n,this.y=s,this.z=t,this.m=a,this.tile=r,this.elevationTile=e}clone(){return new c(this.x,this.y,this.z,this.m)}}export{f as r};
