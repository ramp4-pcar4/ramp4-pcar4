import{H as me,V as we,da as N,je as be,j as ve,aa as q,L as G,b1 as Te,ak as R,jT as Se,bP as $,ba as Ie,a8 as M,T as Pe,i as V,G as xe,cl as Ce,_ as X,X as De,Y as Re}from"./main-CSjwO60s.js";import{y as Me,p as ke}from"./diffUtils-D3O4EfgX.js";import{p as Le}from"./workers-CixlqDQM.js";import{t as I}from"./Rect-DD6XS68q.js";import{h as Y,A as Z}from"./Texture-DLw7oaIg.js";import{n as Q}from"./pbf-42TrGguk.js";import{u as He}from"./rasterizingUtils-Cf1zdzIw.js";import{e as P}from"./TileKey-BZu7Ia24.js";import{e as Ue}from"./LRUCache-CvGiiws0.js";import{o as D,t as k,c as Fe}from"./constants-t42rMCzy.js";import{s as J,h as Ae,p as ee}from"./Tile-BNoJIjzH.js";import{n as ze,a as qe,y as Ve}from"./SymbolFader-Bp4Rc0g4.js";import{z as te}from"./TileInfo-BmHJ3kZT.js";import{e as se}from"./MapView-CrB-5KSL.js";import{b as Qe}from"./WGLContainer-CV7lovie.js";import{n as Be}from"./TileContainer-BIM43zRp.js";import{s as Oe}from"./PooledRBush-CJtyGgW1.js";import{s as Ee,o as Ke}from"./GraphicOrigin-BZpgptRb.js";import{a as ie,t as re}from"./SourceLayerData-Bj7ibB9F.js";import{d as We}from"./GeometryUtils-C8-DjR3I.js";import{D as je,l as ae}from"./StyleRepository-BkGEVTu-.js";import{b as Ne}from"./LayerView2D-D_-BpxcP.js";import{d as Ge}from"./LayerView-DBq501tj.js";import{i as $e}from"./RefreshableLayerView-BoQ2vcWz.js";import{f as le}from"./Scheduler-D_tOhFWn.js";const ne=Symbol("isVectorTileGraphicOrigin");function oe(i){return!!i&&ne in i}class L{constructor(e,t){this._width=0,this._height=0,this._free=[],this._width=e,this._height=t,this._free.push(new I(0,0,e,t))}get width(){return this._width}get height(){return this._height}allocate(e,t){if(e>this._width||t>this._height)return new I;let s=null,a=-1;for(let r=0;r<this._free.length;++r){const l=this._free[r];e<=l.width&&t<=l.height&&(s===null||l.y<=s.y&&l.x<=s.x)&&(s=l,a=r)}return s===null?new I:(this._free.splice(a,1),s.width<s.height?(s.width>e&&this._free.push(new I(s.x+e,s.y,s.width-e,t)),s.height>t&&this._free.push(new I(s.x,s.y+t,s.width,s.height-t))):(s.width>e&&this._free.push(new I(s.x+e,s.y,s.width-e,s.height)),s.height>t&&this._free.push(new I(s.x,s.y+t,e,s.height-t))),new I(s.x,s.y,e,t))}release(e){for(let t=0;t<this._free.length;++t){const s=this._free[t];if(s.y===e.y&&s.height===e.height&&s.x+s.width===e.x)s.width+=e.width;else if(s.x===e.x&&s.width===e.width&&s.y+s.height===e.y)s.height+=e.height;else if(e.y===s.y&&e.height===s.height&&e.x+e.width===s.x)s.x=e.x,s.width+=e.width;else{if(e.x!==s.x||e.width!==s.width||e.y+e.height!==s.y)continue;s.y=e.y,s.height+=e.height}this._free.splice(t,1),this.release(e)}this._free.push(e)}}let he=class{constructor(i,e,t){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=i,this.height=e,this._glyphSource=t,this._binPack=new L(i-4,e-4),this._glyphData.push(new Uint8Array(i*e)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(i,e){const t=[],s=this._glyphSource,a=new Set,r=1/256;for(const n of e){const o=Math.floor(n*r);a.add(o)}const l=[];return a.forEach(n=>{const o=i+n;if(this._rangePromises.has(o))l.push(this._rangePromises.get(o));else{const h=s.getRange(i,n).then(()=>{this._rangePromises.delete(o)},()=>{this._rangePromises.delete(o)});this._rangePromises.set(o,h),l.push(h)}}),Promise.all(l).then(()=>{let n=this._glyphIndex[i];n||(n={},this._glyphIndex[i]=n);for(const o of e){const h=n[o];if(h){t[o]={sdf:!0,rect:h.rect,metrics:h.metrics,page:h.page,code:o};continue}const c=s.getGlyph(i,o);if(!c?.metrics)continue;const u=c.metrics;let d;if(u.width===0)d=new I(0,0,0,0);else{const _=u.width+6,y=u.height+6;let p=_%4?4-_%4:4,g=y%4?4-y%4:4;p===1&&(p=5),g===1&&(g=5),d=this._binPack.allocate(_+p,y+g),d.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new L(this.width-4,this.height-4),d=this._binPack.allocate(_+p,y+g));const w=this._glyphData[this._currentPage],T=c.bitmap;let m,b;if(T)for(let S=0;S<y;S++){m=_*S,b=this.width*(d.y+S+1)+d.x;for(let f=0;f<_;f++)w[b+f+1]=T.at(m+f)}}n[o]={rect:d,metrics:u,tileIDs:null,page:this._currentPage},t[o]={sdf:!0,rect:d,metrics:u,page:this._currentPage,code:o},this._dirties[this._currentPage]=!0}return t})}removeGlyphs(i){for(const e in this._glyphIndex){const t=this._glyphIndex[e];if(!t)continue;let s;for(const a in t)if(s=t[a],s.tileIDs.delete(i),s.tileIDs.size===0){const r=this._glyphData[s.page],l=s.rect;let n,o;for(let h=0;h<l.height;h++)for(n=this.width*(l.y+h)+l.x,o=0;o<l.width;o++)r[n+o]=0;delete t[a],this._dirties[s.page]=!0}}}bind(i,e,t,s=0){if(!this._textures[t]){const r=new Y(this.width,this.height);r.pixelFormat=6406,r.wrapMode=33071,this._textures[t]=new Z(i,r,new Uint8Array(this.width*this.height))}const a=this._textures[t];a.setSamplingMode(e),this._dirties[t]&&a.setData(this._glyphData[t]),i.bindTexture(a,s),this._dirties[t]=!1}destroy(){this.dispose()}dispose(){this._glyphData.length=0,this._binPack=null;for(const i of this._textures)i&&i.dispose();this._textures.length=0}},B=class{constructor(i){if(this._metrics=[],!i)return void(this._allBitmaps=null);const e=new Map;let t=0;for(;i.next();)switch(i.tag()){case 1:{const r=i.getMessage();for(;r.next();)switch(r.tag()){case 3:{const l=r.getMessage();let n,o,h,c,u,d,_;for(;l.next();)switch(l.tag()){case 1:n=l.getUInt32();break;case 2:o=l.getBytes();break;case 3:h=l.getUInt32();break;case 4:c=l.getUInt32();break;case 5:u=l.getSInt32();break;case 6:d=l.getSInt32();break;case 7:_=l.getUInt32();break;default:l.skip()}if(l.release(),n){const y=o?.length??0;this._metrics[n]={width:h,height:c,left:u,top:d,advance:_,startOffset:t,length:y},e.set(n,o),t+=y}break}default:r.skip()}r.release();break}default:i.skip()}const s=new Uint8Array(t),a=this._metrics;for(const[r,l]of e){const{startOffset:n,length:o}=a[r];if(l)for(let h=0;h<o;++h)s[n+h]=l[h]}this._allBitmaps=s}getMetrics(i){return this._metrics[i]}getBitmap(i){if(!this._allBitmaps)return;const e=this._metrics[i];if(e===void 0)return;const{startOffset:t,length:s}=e;return s!==0?new Ye(this._allBitmaps,t,s):void 0}},Xe=class{constructor(){this._ranges=[]}get ranges(){return this._ranges}getRange(i){return this._ranges[i]}addRange(i,e){this._ranges[i]=e}},ce=class{constructor(i){this._glyphInfo={},this._baseURL=i}getRange(i,e){const t=this._getFontStack(i);if(t.getRange(e))return Promise.resolve();const s=256*e,a=s+255;if(this._baseURL){const r=this._baseURL.replace("{fontstack}",i).replace("{range}",s+"-"+a);return me(r,{responseType:"array-buffer"}).then(l=>{t.addRange(e,new B(new Q(new Uint8Array(l.data),new DataView(l.data))))}).catch(()=>{t.addRange(e,new B)})}return t.addRange(e,new B),Promise.resolve()}getGlyph(i,e){const t=this._getFontStack(i);if(!t)return;const s=Math.floor(e/256),a=t.getRange(s);return a?{metrics:a.getMetrics(e),bitmap:a.getBitmap(e)}:void 0}_getFontStack(i){let e=this._glyphInfo[i];return e||(e=this._glyphInfo[i]=new Xe),e}},Ye=class{constructor(i,e,t){this._array=i,this._start=e,this.length=t}at(i){return 0<=i&&i<this.length?this._array[this._start+i]:void 0}};const Ze="dasharray-";class z{constructor(e,t,s=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,t<=0&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=e,this._pageHeight=t,s>0&&(this._maxItemSize=s),this._binPack=new L(e-4,t-4)}destroy(){this.dispose()}dispose(){this._binPack=null,this._mosaicsData.length=0,this._mosaicRects={};for(const e of this._textures)e&&e.dispose();this._textures.length=0}getWidth(e){return e>=this._size.length?-1:this._size[e][0]}getHeight(e){return e>=this._size.length?-1:this._size[e][1]}getPageSize(e){return e>=this._size.length?null:this._size[e]}setSpriteSource(e){if(this.dispose(),this.pixelRatio=e.devicePixelRatio,this._mosaicsData.length===0){this._binPack=new L(this._pageWidth-4,this._pageHeight-4);const t=Math.floor(this._pageWidth),s=Math.floor(this._pageHeight),a=new Uint32Array(t*s);this._mosaicsData[0]=a,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=e}getSpriteItem(e,t=!1){let s,a,r=this._mosaicRects[e];if(r)return r;if(!this._sprites||this._sprites.loadStatus!=="loaded"||(e&&e.startsWith(Ze)?([s,a]=this._rasterizeDash(e),t=!0):s=this._sprites.getSpriteInfo(e),!s?.width||!s.height||s.width<0||s.height<0))return null;const l=s.width,n=s.height,[o,h,c]=this._allocateImage(l,n);return o.width<=0?null:(this._copy(o,s,h,c,t,a),r={type:"sprite",rect:o,width:l,height:n,sdf:s.sdf,simplePattern:!1,rasterizationScale:s.pixelRatio??1,samplingMode:"Linear",page:h},this._mosaicRects[e]=r,r)}getSpriteItems(e){const t={};for(const s of e)t[s.name]=this.getSpriteItem(s.name,s.repeat);return t}getMosaicItemPosition(e,t){const s=this.getSpriteItem(e,t),a=s?.rect;if(!a)return null;a.width=s.width,a.height=s.height;const r=s.width,l=s.height,n=2;return{tl:[a.x+n,a.y+n],br:[a.x+n+r,a.y+n+l],page:s.page}}bind(e,t,s=0,a=0){if(s>=this._size.length||s>=this._mosaicsData.length)return;if(!this._textures[s]){const l=new Y(this._size[s][0],this._size[s][1]);l.wrapMode=33071,this._textures[s]=new Z(e,l,new Uint8Array(this._mosaicsData[s].buffer))}const r=this._textures[s];r.setSamplingMode(t),this._dirties[s]&&r.setData(new Uint8Array(this._mosaicsData[s].buffer)),e.bindTexture(r,a),this._dirties[s]=!1}static _copyBits(e,t,s,a,r,l,n,o,h,c,u){let d=a*t+s,_=o*l+n;if(u){_-=l;for(let y=-1;y<=c;y++,d=((y+c)%c+a)*t+s,_+=l)for(let p=-1;p<=h;p++)r[_+p]=e[d+(p+h)%h]}else for(let y=0;y<c;y++){for(let p=0;p<h;p++)r[_+p]=e[d+p];d+=t,_+=l}}_copy(e,t,s,a,r,l){if(!this._sprites||this._sprites.loadStatus!=="loaded"||s>=this._mosaicsData.length)return;const n=new Uint32Array(l?l.buffer:this._sprites.image.buffer),o=this._mosaicsData[s],h=2,c=l?t.width:this._sprites.width;z._copyBits(n,c,t.x,t.y,o,a[0],e.x+h,e.y+h,t.width,t.height,r),this._dirties[s]=!0}_allocateImage(e,t){e+=2,t+=2;const s=Math.max(e,t);if(this._maxItemSize&&this._maxItemSize<s){const n=new I(0,0,e,t);return this._mosaicsData.push(new Uint32Array(e*t)),this._dirties.push(!0),this._size.push([e,t]),this._textures.push(void 0),[n,this._mosaicsData.length-1,[e,t]]}let a=e%4?4-e%4:4,r=t%4?4-t%4:4;a===1&&(a=5),r===1&&(r=5);const l=this._binPack.allocate(e+a,t+r);return l.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new L(this._pageWidth-4,this._pageHeight-4),this._allocateImage(e,t)):[l,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(e){const t=/\[(.*?)\]/,s=e.match(t);if(!s)return null;const a=s[1].split(",").map(Number),r=e.slice(e.lastIndexOf("-")+1),[l,n,o]=He(a,r);return[{x:0,y:0,width:n,height:o,sdf:!0,pixelRatio:1},new Uint8Array(l.buffer)]}}let Je=class{constructor(i,e,t,s){this._layer=i,this._styleRepository=e,this.devicePixelRatio=t,this._sourceDataMaxLOD=s,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._spriteSourceAbortController=null,this._startOptionsInputSignal=null,this._inputSignalEventListener=null}destroy(){this._connection?.close(),this._connection=null,this._styleRepository=null,this._layer=null,this._spriteMosaic?.destroy(),this._spriteMosaic=null,this._glyphMosaic=null,this._spriteSourceAbortController=we(this._spriteSourceAbortController),this._spriteSourcePromise=null,this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,this._inputSignalEventListener=null}get spriteMosaic(){return this._spriteSourcePromise.then(()=>this._spriteMosaic)}get glyphMosaic(){return this._glyphMosaic}async start(i){this._requestSprite(i);const e=this._layer.currentStyleInfo.glyphsUrl,t=new ce(e?N(e,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new he(1024,1024,t),this._broadcastPromise=Le("WorkerTileHandler",{client:this,schedule:i.schedule,signal:i.signal}).then(s=>{if(this._layer&&(this._connection?.close(),this._connection=s,this._layer&&!this._connection.closed)){const a=s.broadcast("setStyle",{style:this._layer.currentStyleInfo.style,sourceDataMaxLOD:this._sourceDataMaxLOD},i);Promise.all(a).catch(r=>be(r))}})}_requestSprite(i){this._spriteSourceAbortController?.abort();const e=new AbortController;this._spriteSourceAbortController=e;const t=i?.signal;this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,t&&(this._inputSignalEventListener=et(e),t.addEventListener("abort",this._inputSignalEventListener,{once:!0}));const{signal:s}=e,a={...i,signal:s};this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,a),this._spriteSourcePromise.then(r=>{ve(s),this._spriteMosaic=new z(1024,1024,250),this._spriteMosaic.setSpriteSource(r)})}async updateStyle(i){const e=[];for(const t of i)t.type===4?e.push({type:4,data:{spriteSource:null}}):e.push(t);return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",e)),this._broadcastPromise}setSpriteSource(i){const e=new z(1024,1024,250);return e.setSpriteSource(i),this._spriteMosaic=e,this._spriteSourcePromise=Promise.resolve(i),this._spriteSourceAbortController=null,e}async setStyle(i,e,t){await this._broadcastPromise,this._styleRepository=i,this._sourceDataMaxLOD=t,this._requestSprite();const s=new ce(this._layer.currentStyleInfo.glyphsUrl?N(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);return this._glyphMosaic=new he(1024,1024,s),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",{style:e,sourceDataMaxLOD:this._sourceDataMaxLOD})),this._broadcastPromise}async fetchTileData(i,e){const t=await this._getRefKeys(i,e);return this._getSourcesData(Object.keys(this._layer.sourceNameToSource),t,e)}async fetchTilePBFs(i){const e=Object.keys(this._layer.sourceNameToSource),t={},s=await this._getRefKeys(i,t),a=[],r=[];for(let l=0;l<s.length;l++)if(s[l].value==null||e[l]==null)r.push(null);else{const n=s[l].value,o=this._getTilePayload(n,e[l],t);o.then(h=>{a.push({...h,key:n})}),r.push(o)}return Promise.all(r).then(()=>a)}async parseTileData(i,e){const t=i&&i.data;if(!t)return null;const{sourceName2DataAndRefKey:s,transferList:a}=t;return Object.keys(s).length===0?null:this._broadcastPromise.then(()=>this._connection.invoke("createTileAndParse",{key:i.key.id,sourceName2DataAndRefKey:s,styleLayerUIDs:i.styleLayerUIDs},{...e,transferList:a}))}async getSprites(i){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(i)}getGlyphs(i){return this._glyphMosaic.getGlyphItems(i.font,i.codePoints)}async _getTilePayload(i,e,t){const s=P.pool.acquire(i.id),a=this._layer.sourceNameToSource[e],{level:r,row:l,col:n}=s;P.pool.release(s);try{return{protobuff:await a.requestTile(r,l,n,t),sourceName:e}}catch(o){if(q(o))throw o;return{protobuff:null,sourceName:e}}}async _getRefKeys(i,e){const t=this._layer.sourceNameToSource,s=new Array;for(const a in t){const r=t[a].getRefKey(i,e);s.push(r)}return G(s)}_getSourcesData(i,e,t){const s=[];for(let a=0;a<e.length;a++)if(e[a].value==null||i[a]==null)s.push(null);else{const r=e[a].value,l=this._getTilePayload(r,i[a],t);s.push(l)}return G(s).then(a=>{const r={},l=[];for(let n=0;n<a.length;n++){const o=a[n].value;if(o&&o.protobuff&&o.protobuff.byteLength>0){const h=e[n].value.id;r[o.sourceName]={refKey:h,protobuff:o.protobuff},l.push(o.protobuff)}}return{sourceName2DataAndRefKey:r,transferList:l}})}};function et(i){return()=>i.abort()}const tt=1e-6,st=(i,e)=>i+1/(1<<2*e);let ue=class{constructor(i,e){this._tiles=new Map,this._tileCache=new Ue(40,t=>t.dispose()),this._viewSize=[0,0],this._visibleTiles=new Map,this.acquireTile=i.acquireTile,this.releaseTile=i.releaseTile,this.tileInfoView=i.tileInfoView,this._container=e}destroy(){for(const i of this._tiles.values())i.dispose();this._tiles=null,this._tileCache.clear(),this._tileCache=null}update(i){this._updateCacheSize(i);const e=this.tileInfoView,t=e.getTileCoverage(i.state,0,!0,"smallest");if(!t)return!0;const{spans:s,lodInfo:a}=t,{level:r}=a,l=this._tiles,n=new Set,o=new Set;for(const{row:c,colFrom:u,colTo:d}of s)for(let _=u;_<=d;_++){const y=P.getId(r,c,a.normalizeCol(_),a.getWorldForColumn(_)),p=this._getOrAcquireTile(y);n.add(y),p.processed()?this._addToContainer(p):o.add(new P(y))}for(const[c,u]of l)u.isCoverage=n.has(c);for(const c of o)this._findPlaceholdersForMissingTiles(c,n);let h=!1;for(const[c,u]of l)u.neededForCoverage=n.has(c),u.neededForCoverage||u.isHoldingForFade&&e.intersects(t,u.key)&&n.add(c),u.isFading&&(h=!0);for(const c of this._tiles.keys())n.has(c)||this._releaseTile(c);return J.pool.release(t),!h}clear(){this._tiles.clear(),this._tileCache.clear(),this._visibleTiles.clear()}clearCache(){this._tileCache.clear()}getIntersectingTiles(i,e,t,s,a){const r=[0,0],l=[0,0];s.toMap(r,i-t,e+t),s.toMap(l,i+t,e-t);const n=Math.min(r[0],l[0]),o=Math.min(r[1],l[1]),h=Math.max(r[0],l[0]),c=Math.max(r[1],l[1]),u=Te(n,o,h,c),d=R(),_=[];for(const y of this._visibleTiles.values())this.tileInfoView.getTileBounds(d,y.key),Se(u,d)&&_.push(y);if(a!=null&&a.length>0){const y=new Set(_.map(g=>g.id)),p=a.filter(g=>!y.has(g.tileKey.id)).map(g=>this._visibleTiles.get(g.tileKey.id)).filter(g=>g!==void 0);_.push(...p)}return _}_findPlaceholdersForMissingTiles(i,e){const t=[];for(const a of this._tiles.values())this._addPlaceholderChild(t,a,i,e);const s=t.reduce(st,0);Math.abs(1-s)<tt||this._addPlaceholderParent(i.id,e)}_addPlaceholderChild(i,e,t,s){e.key.level<=t.level||!e.hasData()||rt(t,e.key)&&(this._addToContainer(e),s.add(e.id),i.push(e.key.level-t.level))}_addPlaceholderParent(i,e){const t=this._tiles;let s=i;for(;;){if(s=it(s),!s||e.has(s))return;const a=t.get(s);if(a?.hasData())return this._addToContainer(a),void e.add(a.id)}}_getOrAcquireTile(i){let e=this._tiles.get(i);return e||(e=this._tileCache.pop(i),e||(e=this.acquireTile(new P(i))),this._tiles.set(i,e),e)}_releaseTile(i){const e=this._tiles.get(i);this.releaseTile(e),this._removeFromContainer(e),this._tiles.delete(i),e.hasData()?this._tileCache.put(i,e,1):e.dispose()}_addToContainer(i){let e;const t=[],s=this._container;if(s.contains(i))return;const a=this._visibleTiles;for(const r of a.values())this._canConnectDirectly(i,r)&&t.push(r),e==null&&this._canConnectDirectly(r,i)&&(e=r);if(e!=null){for(const r of t)e.childrenTiles.delete(r),i.childrenTiles.add(r),r.parentTile=i;e.childrenTiles.add(i),i.parentTile=e}else for(const r of t)i.childrenTiles.add(r),r.parentTile=i;a.set(i.id,i),s.addChild(i)}_removeFromContainer(i){if(this._visibleTiles.delete(i.id),this._container.removeChild(i),i.parentTile!=null){i.parentTile.childrenTiles.delete(i);for(const e of i.childrenTiles)i.parentTile!=null&&i.parentTile.childrenTiles.add(e)}for(const e of i.childrenTiles)e.parentTile=i.parentTile;i.parentTile=null,i.childrenTiles.clear()}_canConnectDirectly(i,e){const t=i.key;let{level:s,row:a,col:r,world:l}=e.key;const n=this._visibleTiles;for(;s>0;){if(s--,a>>=1,r>>=1,t.level===s&&t.row===a&&t.col===r&&t.world===l)return!0;if(n.has(`${s}/${a}/${r}/${l}`))return!1}return!1}_updateCacheSize(i){const e=i.state.size;if(e[0]===this._viewSize[0]&&e[1]===this._viewSize[1])return;const t=Math.ceil(e[0]/D)+1,s=Math.ceil(e[1]/D)+1;this._viewSize[0]=e[0],this._viewSize[1]=e[1],this._tileCache.maxSize=5*t*s}};function it(i){const[e,t,s,a]=i.split("/"),r=parseInt(e,10);return r===0?null:`${r-1}/${parseInt(t,10)>>1}/${parseInt(s,10)>>1}/${parseInt(a,10)}`}function rt(i,e){const t=e.level-i.level;return i.row===e.row>>t&&i.col===e.col>>t&&i.world===e.world}let at=class extends Qe{_createTransforms(){return{displayViewScreenMat3:se(),tileMat3:se()}}};const F=1e-6;function de(i,e){if(i){const t=i.getLayoutProperty("visibility");if(!t||t.getValue()!==1&&(i.minzoom===void 0||i.minzoom<e+F)&&(i.maxzoom===void 0||i.maxzoom>=e-F))return!0}return!1}class lt extends Be{constructor(e){super(e),this._backgroundTiles=[],this._computeDisplayInfoView(e)}destroy(){super.destroy(),this.removeAllChildren(),this._spriteMosaic?.dispose(),this._spriteMosaic=null,this._glyphMosaic?.dispose(),this._glyphMosaic=null,this._symbolFader!=null&&(this._symbolFader.clear(),this._symbolFader=null),this._styleRepository=null,this._backgroundTiles=[]}get fading(){return this._symbolFader?.fading??!1}get symbolFader(){return this._symbolFader}get symbolRepository(){return this._symbolFader?.symbolRepository}setStyleResources(e,t,s,a){if(this._spriteMosaic=e,this._glyphMosaic=t,this._styleRepository=s,this.tileInfoView=a,this._computeDisplayInfoView(a),this._symbolFader==null){const r=(l,n)=>{l.allSymbolsFadingOut=!0,l.lastOpacityUpdate=n,qe(l,n,!0),l.decluttered=!0,l.requestRender()};this._symbolFader=new ze("vector-tile",this._styleRepository,r,this.children,k)}this._symbolFader.styleRepository=s}setSpriteMosaic(e){this._spriteMosaic?.dispose(),this._spriteMosaic=e}deleteStyleLayers(e){this._symbolFader!=null&&this._symbolFader.deleteStyleLayers(e)}createRenderParams(e){return{...super.createRenderParams(e),renderPass:null,styleLayer:null,styleLayerUID:-1,glyphMosaic:this._glyphMosaic,spriteMosaic:this._spriteMosaic,hasClipping:!!this._clippingInfos}}doRender(e){!this.visible||e.drawPhase!==1&&e.drawPhase!==64||this._spriteMosaic===void 0||super.doRender(e)}addChild(e){return super.addChild(e),this._symbolFader!=null?this._symbolFader.addTile(e):e.decluttered=!0,this.requestRender(),e}removeChild(e){return this._symbolFader!=null&&this._symbolFader.removeTile(e),this.requestRender(),super.removeChild(e)}renderChildren(e){const{drawPhase:t}=e;t!==64?this._doRender(e):super.renderChildren(e)}removeAllChildren(){for(let e=0;e<this.children.length;e++){const t=this.children[e];this._symbolFader!=null&&this._symbolFader.removeTile(t),t.dispose()}super.removeAllChildren()}getStencilTarget(){return this.children.filter(e=>e.neededForCoverage&&e.hasData())}restartDeclutter(){this._symbolFader!=null&&this._symbolFader.restartDeclutter()}_doRender(e){const{context:t,state:s}=e,a=this._styleRepository;if(!a)return;const r=a.layers,l=this._displayInfo.scaleToZoom(s.scale);a.backgroundBucketIds.length>0&&(e.renderPass="background",this._renderBackgroundLayers(e,a.backgroundBucketIds,l)),super.renderChildren(e),e.drawPhase===1&&this._fade(l,s);const n=this.children.filter(o=>o.visible&&o.hasData());if(!n||n.length===0)return t.bindVAO(null),t.setStencilTestEnabled(!0),void t.setBlendingEnabled(!0);for(const o of n)o.triangleCount=0;t.setStencilWriteMask(0),t.setColorMask(!0,!0,!0,!0),t.setStencilOp(7680,7680,7681),t.setStencilTestEnabled(!0),t.setBlendingEnabled(!1),t.setDepthTestEnabled(!0),t.setDepthWriteEnabled(!0),t.setDepthFunction(515),t.setClearDepth(1),t.clear(256),e.renderPass="opaque";for(let o=r.length-1;o>=0;o--)this._renderStyleLayer(r[o],e,n);t.setDepthWriteEnabled(!1),t.setBlendingEnabled(!0),t.setBlendFunctionSeparate(1,771,1,771),e.renderPass="translucent";for(let o=0;o<r.length;o++)this._renderStyleLayer(r[o],e,n);t.bindVAO(null),t.setStencilTestEnabled(!0),t.setBlendingEnabled(!0);for(const o of n)o.debugInfo.display.triangleCount=o.triangleCount}_fade(e,t){this._symbolFader!=null&&(this._symbolFader.update(e,t)||this.requestRender())}_renderStyleLayer(e,t,s){const{displayLevel:a,painter:r,renderPass:l}=t;if(e===void 0)return;const n=e.getLayoutProperty("visibility");if(n&&n.getValue()===1)return;let o;switch(e.type){case 0:return;case 1:if(l!=="opaque"&&t.renderPass!=="translucent")return;o="vtlFill";break;case 2:if(l!=="translucent")return;o="vtlLine";break;case 4:if(l!=="translucent")return;o="vtlCircle";break;case 3:if(l!=="translucent")return;o="vtlSymbol"}if(s=e.type===3?s.filter(c=>c.decluttered):s.filter(c=>c.neededForCoverage),o!=="vtlSymbol"&&(s.length===0||e.minzoom!==void 0&&e.minzoom>=a+F||e.maxzoom!==void 0&&e.maxzoom<a-F))return;const h=e.uid;t.styleLayerUID=h,t.styleLayer=e;for(const c of s)if(c.layerData.has(h)){r.renderObjects(t,s,o);break}}_renderBackgroundLayers(e,t,s){const{context:a,painter:r,state:l}=e,n=this._styleRepository;let o=!1;for(const m of t)if(n.getLayerById(m).type===0&&de(n.getLayerById(m),s)){o=!0;break}if(!o)return;const h=this.tileInfoView,c=h.getTileCoverage(e.state,0,!0,"smallest"),{spans:u,lodInfo:d}=c,{level:_}=d,y=R(),p=[];if(this._renderPasses){const m=this._renderPasses[0];this._clippingInfos!=null&&(m.brushes[0].prepareState(e),m.brushes[0].drawMany(e,this._clippingInfos))}const g=this._backgroundTiles;let w,T=0;for(const{row:m,colFrom:b,colTo:S}of u)for(let f=b;f<=S;f++){if(T<g.length)w=g[T],w.key.set(_,m,d.normalizeCol(f),d.getWorldForColumn(f)),h.getTileBounds(y,w.key,!1),w.x=y[0],w.y=y[3],w.resolution=h.getTileResolution(_);else{const x=new P(_,m,d.normalizeCol(f),d.getWorldForColumn(f)),C=h.getTileBounds(R(),x),H=h.getTileResolution(_);w=new at(x,H,C[0],C[3],D,D,k,k),g.push(w)}w.setTransform(l),p.push(w),T++}a.setStencilWriteMask(0),a.setColorMask(!0,!0,!0,!0),a.setStencilOp(7680,7680,7681),a.setStencilFunction(514,0,255),a.setStencilTestEnabled(!0);for(const m of t){const b=n.getLayerById(m);b.type===0&&de(b,s)&&(e.styleLayerUID=b.uid,e.styleLayer=b,r.renderObjects(e,p,"vtlBackground"))}J.pool.release(c)}_computeDisplayInfoView(e){let t=e.tileInfo.lods[0].scale;const s=Math.max(25,e.tileInfo.lods.length),a=[];for(let r=0;r<=s;r++)a.push(t),t/=2;this._displayInfo=te.create({scales:a,size:D,spatialReference:e.spatialReference,numLODs:s})}}var _e;class ye extends Ee{get[(_e=ne,Ke)](){return this.layer}constructor(e,t,s){super(),this[_e]=!0,this.type="vector-tile",this.layer=e,this.layerId=t,this.layerIndex=s}get id(){return`${this.layer.id}:__${this.layerId}__:__${this.layerIndex}__`}}const nt=(i,e)=>{const t=i.vtlSymbol.sourceTile,s=e.vtlSymbol.sourceTile;return t.level!==s.level?t.level-s.level:t.row!==s.row?t.row-s.row:t.col!==s.col?t.col-s.col:i.styleLayerUID-e.styleLayerUID};class E{constructor(e,t,s,a,r){this.tileKey=e,this._tileLayerData=t,this._styleRepository=s,this._tileHandler=a,this._parentLayer=r,this._index=null,this._tileKeyToPBF=new Map}static create(e,t,s,a,r){return new E(e,t,s,a,r)}clear(){this._index?.clear(),this._tileKeyToPBF.clear()}async queryAttributes(e,t,s,a,r){if(this._tileLayerData.size===0||!this._styleRepository||!this._tileHandler)return[];this._index===null&&(this._index=new Oe(100,ot),await this._indexLayers());const l=[];return this._queryIndex(l,e,t,s,this.tileKey.level,a),r&&r?.length>0&&await this._getSymbolsAttributes(l,r),l}async _indexLayers(){const e=this.tileKey,t=this._styleRepository.layers,s=await this._getTilePayload(e);for(const[a,r]of this._tileLayerData){const l=t[a],n=s.find(c=>c.sourceName===l.source);if(!n)continue;const{protobuff:o,key:h}=n;if(r.type!==3){const c=1<<e.level-h.level,u=e.row-h.row*c,d=e.col-h.col*c;this._indexLayer(l,o,e.level,c,u,d)}}}_indexLayer(e,t,s,a,r,l){const n=e.sourceLayer,o=e.getFeatureFilter(),h=s,c=s+1,u=We(h),d=new Q(new Uint8Array(t),new DataView(t));for(;d.next();)switch(d.tag()){case 3:{const _=d.getMessage(),y=new ie(_);if(_.release(),y.name!==n)continue;const p=y.getData(),g=y.extent/a,w=g*l-u,T=g*r-u,m=w+g+2*u,b=T+g+2*u,S=g/D,f=k/g,x=g*l,C=g*r;for(;p.nextTag(2);){const H=p.getMessage(),U=new re(H,y);if(H.release(),o&&!o.filter(U,s))continue;const K=U.values||{},W=K._minzoom,j=K._maxzoom;if(W&&W>=10*c||j&&j<=10*h)continue;const v=e.getFeatureInflatedBounds(U,h,y.extent,S);v==null||v[0]>m||v[1]>b||v[2]<w||v[3]<T||(v[0]=(v[0]-x)*f,v[1]=(v[1]-C)*f,v[2]=(v[2]-x)*f,v[3]=(v[3]-C)*f,this._index.insert(new je(e,U,v,f,x,C)))}break}default:d.skip()}d.release()}async _getSymbolsAttributes(e,t){if(!t||t.length===0)return e;const s=[];if(t.sort(nt),t.length>0){let r=0,{styleLayerUID:l}=t[0];for(let o=1;o<t.length;o++){const{styleLayerUID:h}=t[o];h!==l&&(s.push({from:r,to:o,styleLayerUID:l,sourceTileKey:t[o-1].vtlSymbol.sourceTile}),r=o,l=h)}const n=t.length-1;s.push({from:r,to:t.length,styleLayerUID:l,sourceTileKey:t[n].vtlSymbol.sourceTile})}const a=this._styleRepository.layers;for(const r of s){const l=await this._getTilePayload(r.sourceTileKey),n=a[r.styleLayerUID],o=!!n&&l.find(h=>h.sourceName===n.source);o&&this._addSymbolsAttributes(e,t.slice(r.from,r.to).map(h=>h.vtlSymbol.featureIndex),r.styleLayerUID,o)}return e}_addSymbolsAttributes(e,t,s,a){const r=this._styleRepository.layers,l=a.key,n=this.tileKey,o=1<<n.level-l.level,h=n.row-l.row*o,c=n.col-l.col*o;this._getSymbolAttributes(a.protobuff,t,s,o,h,c).forEach(u=>{const{attributes:d,tilePoint:_}=u;e.push({layerId:r[s].id,layerIndex:s,graphic:new $({attributes:d,origin:new ye(this._parentLayer,r[s].id,s)}),tilePoint:_})})}_getSymbolAttributes(e,t,s,a,r,l){const n=[],o=this._styleRepository.layers;let h=0;t.sort((u,d)=>u-d);const c=new Q(new Uint8Array(e),new DataView(e));for(;c.next();)switch(c.tag()){case 3:{const u=c.getMessage(),d=new ie(u);if(u.release(),d.name!==o[s].sourceLayer)continue;const _=d.getData(),y=d.extent/a,p=k/y,g=y*l,w=y*r;let T=0;for(;_.nextTag(2);){const m=_.getMessage();if(T++===t[h]){const b=new re(m,d),S=b.values,f=b.getGeometry(),x=f!=null?[p*(f[0][0].x-g),p*(f[0][0].y-w)]:null;n.push({attributes:S,tilePoint:x}),h++}if(m.release(),h===t.length)return n}break}default:c.skip()}return c.release(),n}_queryIndex(e,t,s,a,r,l){const n=Fe*a*(window.devicePixelRatio||1);return this._index?.search({minX:t-n,minY:s-n,maxX:t+n,maxY:s+n},o=>{const{layer:h,feature:c}=o;h.isIntersectingFeature(t,s,a,c,r,l,o)&&e.push({layerId:h.id,layerIndex:h.uid,tilePoint:null,graphic:new $({attributes:c.values,origin:new ye(this._parentLayer,o.layer.id,o.layer.uid)})})}),e}async _getTilePayload(e){return Ie(this._tileKeyToPBF,e.id,()=>this._tileHandler.fetchTilePBFs(e)).then(t=>t)}}const ot=i=>({minX:i.bounds[0],minY:i.bounds[1],maxX:i.bounds[2],maxY:i.bounds[3]});class pe extends Ae{constructor(){super(...arguments),this._fullCacheLodInfos=null,this._levelByScale={}}getTileParentId(e){const t=P.pool.acquire(e),s=t.level===0?null:P.getId(t.level-1,t.row>>1,t.col>>1,t.world);return P.pool.release(t),s}getTileCoverage(e,t,s=!0,a){const r=super.getTileCoverage(e,t,s,a);if(!r)return r;const l=1<<r.lodInfo.level;return r.spans=r.spans.filter(n=>n.row>=0&&n.row<l),r}scaleToLevel(e){if(this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos),this._levelByScale[e])return this._levelByScale[e];{const t=this._fullCacheLodInfos;if(e>t[0].scale)return t[0].level;let s,a;for(let r=0;r<t.length-1;r++)if(a=t[r+1],e>a.scale)return s=t[r],s.level+(s.scale-e)/(s.scale-a.scale);return t[t.length-1].level}}_initializeFullCacheLODs(e){let t;if(e[0].level===0)t=e.map(s=>({level:s.level,resolution:s.resolution,scale:s.scale}));else{const s=this.tileInfo.size[0],a=this.tileInfo.spatialReference;t=te.create({size:s,spatialReference:a}).lods.map(r=>({level:r.level,resolution:r.resolution,scale:r.scale}))}for(let s=0;s<t.length;s++)this._levelByScale[t[s].scale]=t[s].level;this._fullCacheLodInfos=t}}const O=2,ge=8,fe=512;let A=class extends $e(Ne(Ge)){constructor(){super(...arguments),this._styleChanges=[],this._fetchQueue=null,this._parseQueue=null,this._tileHandlerPromise=null,this._isTileHandlerReady=!1,this._styeChanged=!1,this._spriteSourceChanged=!1}get fading(){return this._vectorTileContainer?.fading??!1}get hasVisibleFeatures(){const i=this._vectorTileContainer.children;for(const e of i)if(e.hasFeatures())return!0;return!1}get spriteSourceChanged(){return this._spriteSourceChanged}get styleChanged(){return this._styeChanged}async hitTest(i,e){const t=this._tileHandlerPromise,s=this._vectorTileContainer?.symbolFader;if(!t||!this._isTileHandlerReady||!s)return;await t;let a=null;const r=this._vectorTileContainer?.symbolRepository;r&&(a=r.querySymbols(e,O,s.decluttererOffset,{}));const l=this.view.state,n=this._tileManager.getIntersectingTiles(e.x,e.y,O,l,a);if((!n||n.length===0)&&a?.length===0)return null;i=i.clone().normalize();const o=[],h=[];for(const c of n)o.push(this._queryTile(h,i,O,this.view.state.rotation,c,a?.filter(u=>u.tileKey.id===c.id)));return await Promise.all(o),h}update(i){if(this._tileHandlerPromise&&this._isTileHandlerReady)return i.pixelRatio!==this._tileHandler.devicePixelRatio?(this._tileHandler.devicePixelRatio=i.pixelRatio,void this._loadStyle()):void(this._styleChanges.length>0?this._tileHandlerPromise=this._applyStyleChanges():(this._pauseQueues(),this._fetchQueue.state=i.state,this._parseQueue.state=i.state,this._tileManager.update(i)||this.requestUpdate(),this._resumeQueues()))}attach(){const{style:i}=this.layer.currentStyleInfo;this._styleRepository=new ae(i),this._tileInfoView=new pe(this.layer.tileInfo,this.layer.fullExtent),this._vectorTileContainer=new lt(this._tileInfoView),this._tileHandler=new Je(this.layer,this._styleRepository,window.devicePixelRatio||1,this.layer.tileInfo.lods.length-1),this.container.addChild(this._vectorTileContainer),this._start(),this.addAttachHandles([this.layer.on("paint-change",e=>{if(this._styeChanged=!0,e.isDataDriven)this._styleChanges.push({type:0,data:e}),this.requestUpdate();else{const t=this._styleRepository,s=t.getLayerById(e.layer);if(!s)return;const a=s.type===3;t.setPaintProperties(e.layer,e.paint),a&&this._vectorTileContainer?.restartDeclutter(),this._vectorTileContainer?.requestRender()}}),this.layer.on("layout-change",e=>{const t=this._styleRepository,s=t.getLayerById(e.layer);if(!s)return;this._styeChanged=!0;const a=Me(s.layout,e.layout);if(a!=null){if(ke(a,"visibility")&&ht(a)===1)return t.setLayoutProperties(e.layer,e.layout),s.type===3&&this._vectorTileContainer?.restartDeclutter(),void this._vectorTileContainer?.requestRender();this._styleChanges.push({type:1,data:e}),this.requestUpdate()}}),this.layer.on("style-layer-visibility-change",e=>{const t=this._styleRepository,s=t.getLayerById(e.layer);s&&(this._styeChanged=!0,t.setStyleLayerVisibility(e.layer,e.visibility),s.type===3&&this._vectorTileContainer?.restartDeclutter(),this._vectorTileContainer?.requestRender())}),this.layer.on("style-layer-change",e=>{this._styleChanges.push({type:2,data:e}),this._styeChanged=!0,this.requestUpdate()}),this.layer.on("delete-style-layer",e=>{this._styleChanges.push({type:3,data:e}),this._styeChanged=!0,this.requestUpdate()}),this.layer.on("load-style",()=>this._loadStyle()),this.layer.on("spriteSource-change",e=>{this._spriteSourceChanged=!0,this._styleChanges.push({type:4,data:e});const t=this._styleRepository.layers;for(const s of t)switch(s.type){case 3:s.getLayoutProperty("icon-image")&&this._styleChanges.push({type:1,data:{layer:s.id,layout:s.layout}});break;case 2:s.getPaintProperty("line-pattern")&&this._styleChanges.push({type:0,data:{layer:s.id,paint:s.paint,isDataDriven:s.isPainterDataDriven()}});break;case 1:s.getLayoutProperty("fill-pattern")&&this._styleChanges.push({type:0,data:{layer:s.id,paint:s.paint,isDataDriven:s.isPainterDataDriven()}})}this.requestUpdate()})])}detach(){this._stop(),this.container.removeAllChildren(),this._vectorTileContainer=M(this._vectorTileContainer),this._tileHandler=M(this._tileHandler)}viewChange(){this.requestUpdate()}moveEnd(){this.requestUpdate()}supportsSpatialReference(i){return Pe(this.layer.tileInfo?.spatialReference,i)}canResume(){let i=super.canResume();const{currentStyleInfo:e}=this.layer;if(i&&e?.layerDefinition){const t=this.view.scale,{minScale:s,maxScale:a}=e.layerDefinition;e?.layerDefinition&&(s&&s<t&&(i=!1),a&&a>t&&(i=!1))}return i}isUpdating(){return this.fading}acquireTile(i){const e=this._createVectorTile(i);return this._updatingHandles.addPromise(this._fetchQueue.push(e.key).then(t=>this._parseQueue.push({key:e.key,data:t})).then(t=>{e.once("attach",()=>this.requestUpdate()),e.setData(t),this.requestUpdate()}).catch(t=>{q(t)||V.getLogger(this).error(t)})),e}releaseTile(i){const e=i.key.id;this._fetchQueue.abort(e),this._parseQueue.abort(e),this.requestUpdate()}async doRefresh(){if(!this.attached)return;if(this.suspended)return this._tileManager.clear(),void this.requestUpdate();this._isTileHandlerReady=!1,this._pauseQueues(),this._clearQueues(),this._tileManager.clearCache(),this._resumeQueues();const i=this._vectorTileContainer.children,e=[];try{for(const t of i){const s=this._updatingHandles.addPromise(this._fetchQueue.push(t.key).then(a=>this._parseQueue.push({key:t.key,data:a})).then(a=>t.setData(a)).finally(()=>t.featureIndex=null));e.push(s)}await Promise.all(e)}catch(t){V.getLogger(this).error("error refreshing vector-tiles layer-view",t),this._resumeQueues(),this._isTileHandlerReady=!0}this._isTileHandlerReady=!0,this.requestUpdate()}_start(){if(this._stop(),this._tileManager=new ue({acquireTile:t=>this.acquireTile(t),releaseTile:t=>this.releaseTile(t),tileInfoView:this._tileInfoView},this._vectorTileContainer),!this.layer.currentStyleInfo)return;const i=new AbortController,e=this._tileHandler.start({signal:i.signal}).then(()=>{this._fetchQueue=new ee({tileInfoView:this._tileInfoView,process:(t,s)=>this._getTileData(t,s),concurrency:15,scheduler:this.scheduler,priority:le.MAPVIEW_FETCH_QUEUE}),this._parseQueue=new ee({tileInfoView:this._tileInfoView,process:(t,s)=>this._parseTileData(t,s),concurrency:8,scheduler:this.scheduler,priority:le.MAPVIEW_VECTOR_TILE_PARSING_QUEUE}),this.requestUpdate(),this._isTileHandlerReady=!0});this._tileHandler.spriteMosaic.then(t=>{this._vectorTileContainer.setStyleResources(t,this._tileHandler.glyphMosaic,this._styleRepository,this._tileInfoView),this.requestUpdate()}),this._tileHandlerAbortController=i,this._tileHandlerPromise=e}_stop(){if(!this._tileHandlerAbortController||!this._vectorTileContainer)return;const i=this._tileHandlerAbortController;i&&i.abort(),this._tileHandlerPromise=null,this._isTileHandlerReady=!1,this._fetchQueue=M(this._fetchQueue),this._parseQueue=M(this._parseQueue),this._tileManager=M(this._tileManager),this._vectorTileContainer.removeAllChildren()}async _getTileData(i,e){return this._tileHandler.fetchTileData(i,e)}async _parseTileData(i,e){return this._tileHandler.parseTileData(i,e)}async _applyStyleChanges(){this._isTileHandlerReady=!1,this._pauseQueues(),this._clearQueues(),this._tileManager.clearCache();const i=this._styleChanges;try{await this._tileHandler.updateStyle(i)}catch(r){V.getLogger(this).error("error applying vector-tiles style update",r.message),this._resumeQueues(),this._isTileHandlerReady=!0}const e=this._styleRepository,t=new Set;i.forEach(r=>{if(r.type!==3)return;const l=r.data,n=e.getLayerById(l.layer);n&&t.add(n.uid)});const s=new Set;i.forEach(r=>{let l;switch(r.type){case 0:e.setPaintProperties(r.data.layer,r.data.paint),l=r.data.layer;break;case 1:e.setLayoutProperties(r.data.layer,r.data.layout),l=r.data.layer;break;case 3:return void e.deleteStyleLayer(r.data.layer);case 2:e.setStyleLayer(r.data.layer,r.data.index),l=r.data.layer.id;break;case 4:this._vectorTileContainer.setSpriteMosaic(this._tileHandler.setSpriteSource(r.data.spriteSource))}if(l){const n=e.getLayerById(l);n&&s.add(n.uid)}});const a=this._vectorTileContainer.children;if(t.size>0){const r=Array.from(t);this._vectorTileContainer.deleteStyleLayers(r);for(const l of a)l.deleteLayerData(r)}if(this._resumeQueues(),s.size>0){const r=Array.from(s),l=[];for(const n of a){const o=this._updatingHandles.addPromise(this._fetchQueue.push(n.key).then(h=>this._parseQueue.push({key:n.key,data:h,styleLayerUIDs:r})).then(h=>n.setData(h)).finally(()=>n.featureIndex=null));l.push(o)}await Promise.all(l)}this._styleChanges=[],this._isTileHandlerReady=!0,this.requestUpdate()}async _loadStyle(){const{style:i}=this.layer.currentStyleInfo,e=xe(i);this._isTileHandlerReady=!1,this._pauseQueues(),this._clearQueues(),this._styleRepository=new ae(e),this._vectorTileContainer.destroy(),this._tileManager.clear(),this._tileHandlerAbortController.abort(),this._tileHandlerAbortController=new AbortController;const{signal:t}=this._tileHandlerAbortController;try{this._tileHandlerPromise=this._tileHandler.setStyle(this._styleRepository,e,this.layer.tileInfo.lods.length-1),await this._tileHandlerPromise}catch(r){if(!q(r))throw r}if(t.aborted)return this._resumeQueues(),this._isTileHandlerReady=!0,this._styeChanged=!1,this._spriteSourceChanged=!1,void this.requestUpdate();const s=await this._tileHandler.spriteMosaic,a=this._vectorTileContainer;this._tileInfoView=new pe(this.layer.tileInfo,this.layer.fullExtent),a.setStyleResources(s,this._tileHandler.glyphMosaic,this._styleRepository,this._tileInfoView),this._tileManager=new ue({acquireTile:r=>this.acquireTile(r),releaseTile:r=>this.releaseTile(r),tileInfoView:this._tileInfoView},this._vectorTileContainer),this._resumeQueues(),this._isTileHandlerReady=!0,this.requestUpdate(),this._styeChanged=!1,this._spriteSourceChanged=!1}_createVectorTile(i){const e=this._tileInfoView.getTileBounds(R(),i),t=this._tileInfoView.getTileResolution(i.level);return new Ve(i,t,e[0],e[3],512,512,this._styleRepository)}async _queryTile(i,e,t,s,a,r){if(a.layerData.size===0)return;const l=this._ensureTileIndex(a),n=this._tileInfoView.getTileBounds(R(),a.key,!0),o=ge*fe*((e.x-n[0])/(n[2]-n[0])),h=ge*fe*(1-(e.y-n[1])/(n[3]-n[1])),c=await l.queryAttributes(o,h,t,s,r);for(const u of c)u.graphic.geometry=this._tileToMapPoint(u.tilePoint,a.transforms.tileUnitsToPixels),i.push({type:"graphic",layer:this.layer,graphic:u.graphic,mapPoint:e.clone()});i.sort((u,d)=>(oe(d.graphic.origin)?d.graphic.origin.layerIndex:0)-(oe(u.graphic.origin)?u.graphic.origin.layerIndex:0))}_tileToMapPoint(i,e){if(!i)return null;const t=i[0]*e[0]+i[1]*e[3]+e[6],s=i[0]*e[1]+i[1]*e[4]+e[7],a=this.view.state,r=[0,0];return a.toMap(r,[t,s]),new Ce({x:r[0],y:r[1],spatialReference:a.spatialReference})}_ensureTileIndex(i){let e=i.featureIndex;return e||(e=E.create(i.key,i.layerData,this._styleRepository,this._tileHandler,this.layer),i.featureIndex=e),e}_pauseQueues(){this._fetchQueue.pause(),this._parseQueue.pause()}_resumeQueues(){this._fetchQueue.resume(),this._parseQueue.resume()}_clearQueues(){this._fetchQueue.clear(),this._parseQueue.clear()}};function ht(i){if(i==null)return 0;switch(i.type){case"partial":return Object.keys(i.diff).length;case"complete":return Math.max(Object.keys(i.oldValue).length,Object.keys(i.newValue).length);case"collection":return Object.keys(i.added).length+Object.keys(i.changed).length+Object.keys(i.removed).length}}X([De()],A.prototype,"_isTileHandlerReady",void 0),A=X([Re("esri.views.2d.layers.VectorTileLayerView2D")],A);const ct=A;export{ct as default};
