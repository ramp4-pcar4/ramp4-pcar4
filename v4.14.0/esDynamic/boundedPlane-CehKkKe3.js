import{cS as E,aI as S,i as ot,cY as L,az as at,b1 as et,e0 as rt}from"./main-CSjwO60s.js";import{s as _,w as ct}from"./sphere-CIGsF4vz.js";import{h as ut,s as gt,p as bt}from"./mat4-R0VY9B_E.js";import{s as u,P as d,r as N,E as m,g as l,u as p,c as x,o as w,p as ft,H as O,K as lt,j as B,A as H}from"./vec32-CI1xtKog.js";import{A as U,M as pt,v as dt}from"./lineSegment-D8lwRkdT.js";import{j as V,I as j,d as mt,k as v,G as It,R as ht,K as Nt,q as Pt,O as D,y as Mt,L as wt,N as vt}from"./plane-wUwHaY3K.js";import{c as e,f as T}from"./vectorStacks-B2ngxq6F.js";const F=()=>ot.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");function I(t=it){return{plane:V(t.plane),origin:S(t.origin),basis1:S(t.basis1),basis2:S(t.basis2)}}function Tt(t,n,s){const i=zt.get();return i.origin=t,i.basis1=n,i.basis2=s,i.plane=mt(0,0,0,0),M(i),i}function P(t,n=I()){return Y(t.origin,t.basis1,t.basis2,n)}function yt(t,n){u(n.origin,t.origin),u(n.basis1,t.basis1),u(n.basis2,t.basis2),Mt(n.plane,t.plane)}function Y(t,n,s,i=I()){return u(i.origin,t),u(i.basis1,n),u(i.basis2,s),M(i),kt(i,"fromValues()"),i}function M(t){j(t.basis2,t.basis1,t.origin,t.plane)}function J(t,n,s){t!==s&&P(t,s);const i=l(e.get(),f(t),n);return p(s.origin,s.origin,i),s.plane[3]-=n,s}function At(t,n,s){return q(n,s),J(s,G(t,t.origin),s),s}function Et(t,n){const s=t.basis1[0],i=t.basis2[1],[o,a]=t.origin;return et(o-s,a-i,o+s,a+i,n)}function q(t,n=I()){const s=(t[2]-t[0])/2,i=(t[3]-t[1])/2;return w(n.origin,t[0]+s,t[1]+i,0),w(n.basis1,s,0,0),w(n.basis2,0,i,0),Pt(0,0,1,0,n.plane),n}function R(t,n,s){return!!Nt(t.plane,n,s)&&tt(t,s)}function St(t,n,s){if(R(t,n,s))return s;const i=W(t,n,e.get());return p(s,n.origin,l(e.get(),n.direction,ft(n.origin,i)/N(n.direction))),s}function W(t,n,s){const i=y.get();nt(t,n,i,y.get());let o=Number.POSITIVE_INFINITY;for(const a of C){const r=z(t,a,A.get()),g=e.get();if(wt(i,r,g)){const c=lt(e.get(),n.origin,g),b=Math.abs(rt(d(n.direction,c)));b<o&&(o=b,u(s,g))}}return o===Number.POSITIVE_INFINITY?Z(t,n,s):s}function _t(t,n){return(n-t)/n}function Z(t,n,s){if(R(t,n,s))return s;const i=y.get(),o=y.get();nt(t,n,i,o);let a=Number.POSITIVE_INFINITY;for(const r of C){const g=z(t,r,A.get()),c=e.get();if(vt(i,g,c)){const b=ct(n,c);if(!D(o,c))continue;b<a&&(a=b,u(s,c))}}return k(t,n.origin)<a&&$(t,n.origin,s),s}function $(t,n,s){const i=ht(t.plane,n,e.get()),o=U(st(t,t.basis1),i,-1,1,e.get()),a=U(st(t,t.basis2),i,-1,1,e.get());return x(s,p(e.get(),o,a),t.origin),s}function Q(t,n,s){const{origin:i,basis1:o,basis2:a}=t,r=x(e.get(),n,i),g=T(o,r),c=T(a,r),b=T(f(t),r);return w(s,g,c,b)}function k(t,n){const s=Q(t,n,e.get()),{basis1:i,basis2:o}=t,a=N(i),r=N(o),g=Math.max(Math.abs(s[0])-a,0),c=Math.max(Math.abs(s[1])-r,0),b=s[2];return g*g+c*c+b*b}function X(t,n){return Math.sqrt(k(t,n))}function xt(t,n){let s=Number.NEGATIVE_INFINITY;for(const i of C){const o=z(t,i,A.get()),a=pt(o,n);a>s&&(s=a)}return Math.sqrt(s)}function Ot(t,n){return D(t.plane,n)&&tt(t,n)}function Vt(t,n,s,i){return Rt(t,s,i)}function G(t,n){const s=-t.plane[3];return T(f(t),n)-s}function jt(t,n,s,i){const o=G(t,n),a=l(Gt,f(t),s-o);return p(i,n,a),i}function Ft(t,n){return O(t.basis1,n.basis1)&&O(t.basis2,n.basis2)&&O(t.origin,n.origin)}function Yt(t,n,s){return t!==s&&P(t,s),ut(h,n),gt(h,h),m(s.basis1,t.basis1,h),m(s.basis2,t.basis2,h),m(v(s.plane),v(t.plane),h),m(s.origin,t.origin,n),It(s.plane,s.plane,s.origin),s}function qt(t,n,s,i){return t!==i&&P(t,i),bt(K,n,s),m(i.basis1,t.basis1,K),m(i.basis2,t.basis2,K),M(i),i}function f(t){return v(t.plane)}function Rt(t,n,s){switch(n){case 0:u(s,t.basis1),H(s,s);break;case 1:u(s,t.basis2),H(s,s);break;case 2:u(s,f(t))}return s}function tt(t,n){const s=x(e.get(),n,t.origin),i=B(t.basis1),o=B(t.basis2),a=d(t.basis1,s),r=d(t.basis2,s);return-a-i<0&&a-i<0&&-r-o<0&&r-o<0}function st(t,n){const s=A.get();return u(s.origin,t.origin),u(s.vector,n),s}function z(t,n,s){const{basis1:i,basis2:o,origin:a}=t,r=l(e.get(),i,n.origin[0]),g=l(e.get(),o,n.origin[1]);p(s.origin,r,g),p(s.origin,s.origin,a);const c=l(e.get(),i,n.direction[0]),b=l(e.get(),o,n.direction[1]);return l(s.vector,p(c,c,b),2),s}function kt(t,n){Math.abs(d(t.basis1,t.basis2)/(N(t.basis1)*N(t.basis2)))>1e-6&&F().warn(n,"Provided basis vectors are not perpendicular"),Math.abs(d(t.basis1,f(t)))>1e-6&&F().warn(n,"Basis vectors and plane normal are not perpendicular"),Math.abs(-d(f(t),t.origin)-t.plane[3])>1e-6&&F().warn(n,"Plane offset is not consistent with plane origin")}function nt(t,n,s,i){const o=f(t);j(o,n.direction,n.origin,s),j(v(s),o,n.origin,i)}const it={plane:V(),origin:E(0,0,0),basis1:E(1,0,0),basis2:E(0,1,0)},y=new _(V),A=new _(dt),Gt=at(),zt=new _(()=>I()),C=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],h=L(),K=L(),Ct=Object.freeze(Object.defineProperty({__proto__:null,altitudeAt:G,axisAt:Vt,cameraFrustumCoverage:_t,closestPoint:Z,closestPointOnSilhouette:W,copy:P,copyWithoutVerify:yt,create:I,distance:X,distance2:k,distanceToSilhouette:xt,elevate:J,equals:Ft,extrusionContainsPoint:Ot,fromAABoundingRect:q,fromValues:Y,getExtent:Et,intersectRay:R,intersectRayClosestSilhouette:St,normal:f,projectPoint:$,projectPointLocal:Q,rotate:qt,setAltitudeAt:jt,setExtent:At,transform:Yt,up:it,updateUnboundedPlane:M,wrap:Tt},Symbol.toStringTag,{value:"Module"}));export{Ct as E,P as G,Y as H,M as J,q as Z,X as a,I as z};
