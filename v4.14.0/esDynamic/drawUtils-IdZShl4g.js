import{ee as d,ak as b,ef as P,eg as D,cW as E,eh as v,d4 as F,ei as G,ej as R,ek as k,el as q,em as H,en as I}from"./main-CSjwO60s.js";import{c as J}from"./curveOperationUtils-ClbIvhut.js";function j(t,r,n,o){if(t.type==="point")return t.x+=r,t.y+=n,t.hasZ&&o!=null,t;if(t.type==="multipoint"){const c=t.points;for(let i=0;i<c.length;i++)c[i]=U(c[i],r,n,o);return t}if(t.type==="extent")return t.xmin+=r,t.xmax+=r,t.ymin+=n,t.ymax+=n,t;const a=t.type==="polyline"?t.curvePaths??t.paths:t.curveRings??t.rings,e=G(t);for(let c=0;c<a.length;c++){const i=a[c];for(let p=0;p<i.length;p++)i[p]=O(i[p],r,n,o)}return"paths"in t?e?t.curvePaths=a:t.paths=a:e?t.curveRings=a:t.rings=a,t}function K(t,r,n,o,a){const e=t.clone();if(a){const{resolution:c}=o;j(e,r*c,-n*c)}else{const{dxMap:c,dyMap:i}=T(r,n,o);j(e,c,i)}return e}function T(t,r,n){const o=n.state.inverseTransform;return{dxMap:o[0]*t+o[2]*r,dyMap:o[1]*t+o[3]*r}}function U(t,r,n,o){return Z(t,t[0]+r,t[1]+n,t[2]!=null&&o!=null?t[2]+o:void 0)}function O(t,r,n,o){const a=U(v(t),r,n,o);if(R(t))return a;if(k(t)){const[,i,p]=t.b;return{b:[a,[i[0]+r,i[1]+n],[p[0]+r,p[1]+n]]}}if(q(t)){const[,i]=t.c;return{c:[a,[i[0]+r,i[1]+n]]}}const[,e,...c]=t.a;return{a:[a,[e[0]+r,e[1]+n],...c]}}function Q(t,r,n,o){if(t.type==="point"){const{x:s,y:f}=t,m=o?o[0]:s,l=o?o[1]:f,x=t.clone(),y=(s-m)*r+m,u=(f-l)*n+l;return x.x=y,x.y=u,x}if(t.type==="extent"){const{xmin:s,xmax:f,ymin:m,ymax:l}=t,x=o?o[0]:(s+f)/2,y=o?o[1]:(l+m)/2,u=t.clone();if(u.xmin=(s-x)*r+x,u.ymax=(l-y)*n+y,u.xmax=(f-x)*r+x,u.ymin=(m-y)*n+y,u.xmin>u.xmax){const h=u.xmin,M=u.xmax;u.xmin=M,u.xmax=h}if(u.ymin>u.ymax){const h=u.ymin,M=u.ymax;u.ymin=M,u.ymax=h}return u}let a=null;if(!o){a=d(t);const s=b(),f=P(s,a);if(!f)return t.clone();const[m,l,x,y]=f;o=[(m+x)/2,(l+y)/2]}const[e,c]=o;if(t.type==="multipoint"){const s=t.clone(),f=s.points;for(let m=0;m<f.length;m++){const l=f[m],[x,y]=l,u=(x-e)*r+e,h=(y-c)*n+c;f[m]=Z(l,u,h,void 0)}return s.points=f,s}const i=t.clone();a??=d(t);const p=i.type==="polygon",g=p?i.curveRings??i.rings:i.curvePaths??i.paths;if(!o){const s=b(),f=P(s,g,!1,!1);if(!f)return i;o=D(f)}for(const s of g){let f=null;const m=p&&s.length>0&&E(v(s[0]),v(s.at(-1)));for(let l=0;l<s.length;l++){const x=s[l];s[l]=S(x,r,n,e,c,f),f=x}m&&(s[0]=[...v(s.at(-1))])}return i}function W(t,r,n,o,a){const[e,c,...i]=t;return[(e-o)*r+o,(c-a)*n+a,...i]}function S(t,r,n,o,a,e){if(R(t))return W(t,r,n,o,a);if(k(t)){const[w,z,B]=t.b.map(C=>W(C,r,n,o,a));return{b:[w,z,B]}}if(!e)return t;const c=v(e),i=q(t)?H(c,t):t,[p,g,s,f,m,l,x]=i.a,y=m??0,u=l??Math.hypot(p[0]-g[0],p[1]-g[1]),h=x??1,M=J(o,a,1,0,0,1,r,n);return I(c,{a:[[...p],[...g],s,f,y,u,h]},M)}function V(t,r,n,o,a,e){const c=Math.sqrt((n-t)*(n-t)+(o-r)*(o-r));return Math.sqrt((a-t)*(a-t)+(e-r)*(e-r))/c}function A(t,r,n,o=!1){const a=Math.atan2(r.y-n.y,r.x-n.x)-Math.atan2(t.y-n.y,t.x-n.x),e=Math.atan2(Math.sin(a),Math.cos(a));return o?e:F(e)}function Z(t,r,n,o){const a=[r,n];return t.length>2&&a.push(o??t[2]),t.length>3&&a.push(t[3]),a}export{Q as M,V as U,A as b,T as h,K as x};
