{"version":3,"file":"dom-cV1JHjxC.js","sources":["../../node_modules/@esri/calcite-components/dist/chunks/dom.js"],"sourcesContent":["/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.\nv3.3.3 */\nimport { g as guid } from \"./guid.js\";\nimport { C as CSS_UTILITY } from \"./runtime.js\";\n/*!\n* tabbable 6.2.0\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\nvar candidateSelectors = [\"input:not([inert])\", \"select:not([inert])\", \"textarea:not([inert])\", \"a[href]:not([inert])\", \"button:not([inert])\", \"[tabindex]:not(slot):not([inert])\", \"audio[controls]:not([inert])\", \"video[controls]:not([inert])\", '[contenteditable]:not([contenteditable=\"false\"]):not([inert])', \"details>summary:first-of-type:not([inert])\", \"details:not([inert])\"];\nvar candidateSelector = /* @__PURE__ */ candidateSelectors.join(\",\");\nvar NoElement = typeof Element === \"undefined\";\nvar matches = NoElement ? function() {\n} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\nvar getRootNode$1 = !NoElement && Element.prototype.getRootNode ? function(element) {\n  var _element$getRootNode;\n  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);\n} : function(element) {\n  return element === null || element === void 0 ? void 0 : element.ownerDocument;\n};\nvar isInert = function isInert2(node, lookUp) {\n  var _node$getAttribute;\n  if (lookUp === void 0) {\n    lookUp = true;\n  }\n  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, \"inert\");\n  var inert = inertAtt === \"\" || inertAtt === \"true\";\n  var result = inert || lookUp && node && isInert2(node.parentNode);\n  return result;\n};\nvar isContentEditable = function isContentEditable2(node) {\n  var _node$getAttribute2;\n  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, \"contenteditable\");\n  return attValue === \"\" || attValue === \"true\";\n};\nvar getCandidates = function getCandidates2(el, includeContainer, filter) {\n  if (isInert(el)) {\n    return [];\n  }\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\nvar getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {\n  var candidates = [];\n  var elementsToCheck = Array.from(elements);\n  while (elementsToCheck.length) {\n    var element = elementsToCheck.shift();\n    if (isInert(element, false)) {\n      continue;\n    }\n    if (element.tagName === \"SLOT\") {\n      var assigned = element.assignedElements();\n      var content = assigned.length ? assigned : element.children;\n      var nestedCandidates = getCandidatesIteratively2(content, true, options);\n      if (options.flatten) {\n        candidates.push.apply(candidates, nestedCandidates);\n      } else {\n        candidates.push({\n          scopeParent: element,\n          candidates: nestedCandidates\n        });\n      }\n    } else {\n      var validCandidate = matches.call(element, candidateSelector);\n      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n        candidates.push(element);\n      }\n      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow\n      typeof options.getShadowRoot === \"function\" && options.getShadowRoot(element);\n      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));\n      if (shadowRoot && validShadowRoot) {\n        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n        if (options.flatten) {\n          candidates.push.apply(candidates, _nestedCandidates);\n        } else {\n          candidates.push({\n            scopeParent: element,\n            candidates: _nestedCandidates\n          });\n        }\n      } else {\n        elementsToCheck.unshift.apply(elementsToCheck, element.children);\n      }\n    }\n  }\n  return candidates;\n};\nvar hasTabIndex = function hasTabIndex2(node) {\n  return !isNaN(parseInt(node.getAttribute(\"tabindex\"), 10));\n};\nvar getTabIndex = function getTabIndex2(node) {\n  if (!node) {\n    throw new Error(\"No node provided\");\n  }\n  if (node.tabIndex < 0) {\n    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {\n      return 0;\n    }\n  }\n  return node.tabIndex;\n};\nvar getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {\n  var tabIndex = getTabIndex(node);\n  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {\n    return 0;\n  }\n  return tabIndex;\n};\nvar sortOrderedTabbables = function sortOrderedTabbables2(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\nvar isInput = function isInput2(node) {\n  return node.tagName === \"INPUT\";\n};\nvar isHiddenInput = function isHiddenInput2(node) {\n  return isInput(node) && node.type === \"hidden\";\n};\nvar isDetailsWithSummary = function isDetailsWithSummary2(node) {\n  var r = node.tagName === \"DETAILS\" && Array.prototype.slice.apply(node.children).some(function(child) {\n    return child.tagName === \"SUMMARY\";\n  });\n  return r;\n};\nvar getCheckedRadio = function getCheckedRadio2(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\nvar isTabbableRadio = function isTabbableRadio2(node) {\n  if (!node.name) {\n    return true;\n  }\n  var radioScope = node.form || getRootNode$1(node);\n  var queryRadios = function queryRadios2(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n  var radioSet;\n  if (typeof window !== \"undefined\" && typeof window.CSS !== \"undefined\" && typeof window.CSS.escape === \"function\") {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      console.error(\"Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s\", err.message);\n      return false;\n    }\n  }\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\nvar isRadio = function isRadio2(node) {\n  return isInput(node) && node.type === \"radio\";\n};\nvar isNonTabbableRadio = function isNonTabbableRadio2(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\nvar isNodeAttached = function isNodeAttached2(node) {\n  var _nodeRoot;\n  var nodeRoot = node && getRootNode$1(node);\n  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;\n  var attached = false;\n  if (nodeRoot && nodeRoot !== node) {\n    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;\n    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));\n    while (!attached && nodeRootHost) {\n      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;\n      nodeRoot = getRootNode$1(nodeRootHost);\n      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;\n      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));\n    }\n  }\n  return attached;\n};\nvar isZeroArea = function isZeroArea2(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;\n  return width === 0 && height === 0;\n};\nvar isHidden = function isHidden2(node, _ref) {\n  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;\n  if (getComputedStyle(node).visibility === \"hidden\") {\n    return true;\n  }\n  var isDirectSummary = matches.call(node, \"details>summary:first-of-type\");\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, \"details:not([open]) *\")) {\n    return true;\n  }\n  if (!displayCheck || displayCheck === \"full\" || displayCheck === \"legacy-full\") {\n    if (typeof getShadowRoot === \"function\") {\n      var originalNode = node;\n      while (node) {\n        var parentElement = node.parentElement;\n        var rootNode = getRootNode$1(node);\n        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          node = rootNode.host;\n        } else {\n          node = parentElement;\n        }\n      }\n      node = originalNode;\n    }\n    if (isNodeAttached(node)) {\n      return !node.getClientRects().length;\n    }\n    if (displayCheck !== \"legacy-full\") {\n      return true;\n    }\n  } else if (displayCheck === \"non-zero-area\") {\n    return isZeroArea(node);\n  }\n  return false;\n};\nvar isDisabledFromFieldset = function isDisabledFromFieldset2(node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    var parentNode = node.parentElement;\n    while (parentNode) {\n      if (parentNode.tagName === \"FIELDSET\" && parentNode.disabled) {\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i);\n          if (child.tagName === \"LEGEND\") {\n            return matches.call(parentNode, \"fieldset[disabled] *\") ? true : !child.contains(node);\n          }\n        }\n        return true;\n      }\n      parentNode = parentNode.parentElement;\n    }\n  }\n  return false;\n};\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {\n  if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor\n  //  because we're limited in the type of selectors we can use in JSDom (see related\n  //  note related to `candidateSelectors`)\n  isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n  return true;\n};\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {\n  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\n    return false;\n  }\n  return true;\n};\nvar isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {\n  var tabIndex = parseInt(shadowHostNode.getAttribute(\"tabindex\"), 10);\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  }\n  return false;\n};\nvar sortByOrder = function sortByOrder2(candidates) {\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  candidates.forEach(function(item, i) {\n    var isScope = !!item.scopeParent;\n    var element = isScope ? item.scopeParent : item;\n    var candidateTabindex = getSortOrderTabIndex(element, isScope);\n    var elements = isScope ? sortByOrder2(item.candidates) : element;\n    if (candidateTabindex === 0) {\n      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item,\n        isScope,\n        content: elements\n      });\n    }\n  });\n  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {\n    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n    return acc;\n  }, []).concat(regularTabbables);\n};\nvar tabbable = function tabbable2(container, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([container], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot,\n      shadowRootFilter: isValidShadowRootTabbable\n    });\n  } else {\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  }\n  return sortByOrder(candidates);\n};\nvar focusable = function focusable2(container, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([container], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot\n    });\n  } else {\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  }\n  return candidates;\n};\nconst tabbableOptions = {\n  getShadowRoot: true\n};\nfunction ensureId(el) {\n  if (!el) {\n    return \"\";\n  }\n  return el.id = el.id || `${el.tagName.toLowerCase()}-${guid()}`;\n}\nfunction nodeListToArray(nodeList) {\n  return Array.isArray(nodeList) ? nodeList : Array.from(nodeList);\n}\nfunction getModeName(el) {\n  const closestElWithMode = closestElementCrossShadowBoundary(\n    el,\n    `.${CSS_UTILITY.darkMode}, .${CSS_UTILITY.lightMode}, .${CSS_UTILITY.autoMode}`\n  );\n  return closestElWithMode?.classList.contains(\"calcite-mode-dark\") || closestElWithMode?.classList.contains(\"calcite-mode-auto\") && window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"dark\" : \"light\";\n}\nfunction getElementDir(el) {\n  const prop = \"dir\";\n  const selector = `[${prop}]`;\n  const closest = closestElementCrossShadowBoundary(el, selector);\n  return closest ? closest.getAttribute(prop) : \"ltr\";\n}\nfunction getElementWidth(el) {\n  if (!el) {\n    return 0;\n  }\n  return parseFloat(getComputedStyle(el).inlineSize);\n}\nfunction getRootNode(el) {\n  return el.getRootNode();\n}\nfunction getShadowRootNode(el) {\n  const rootNode = getRootNode(el);\n  return \"host\" in rootNode ? rootNode : null;\n}\nfunction getTextWidth(text, font) {\n  if (!text) {\n    return 0;\n  }\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  context.font = font;\n  return context.measureText(text).width;\n}\nfunction getHost(root) {\n  return root.host || null;\n}\nfunction queryElementRoots(el, {\n  selector,\n  id\n}) {\n  if (!el) {\n    return null;\n  }\n  if (el.assignedSlot) {\n    el = el.assignedSlot;\n  }\n  const rootNode = getRootNode(el);\n  const found = id ? \"getElementById\" in rootNode ? (\n    /*\n      Check to make sure 'getElementById' exists in cases where element is no longer connected to the DOM and getRootNode() returns the element.\n      https://github.com/Esri/calcite-design-system/pull/4280\n       */\n    rootNode.getElementById(id)\n  ) : null : selector ? rootNode.querySelector(selector) : null;\n  return found || queryElementRoots(getHost(rootNode), { selector, id });\n}\nfunction closestElementCrossShadowBoundary(element, selector) {\n  return element ? element.closest(selector) || closestElementCrossShadowBoundary(getHost(getRootNode(element)), selector) : null;\n}\nfunction isCalciteFocusable(el) {\n  return typeof el?.setFocus === \"function\";\n}\nasync function focusElement(el, includeContainer = false, strategy = \"tabbable\", context, options) {\n  if (!el) {\n    return;\n  }\n  if (isCalciteFocusable(el) && context !== el) {\n    return el.setFocus(options);\n  }\n  const firstFocusFunction = strategy === \"tabbable\" ? focusFirstTabbable : focusFirstFocusable;\n  return firstFocusFunction(el, includeContainer, options);\n}\nfunction getFirstTabbable(element, includeContainer) {\n  if (!element) {\n    return;\n  }\n  return tabbable(element, { ...tabbableOptions, includeContainer })[0] ?? element;\n}\nfunction focusFirstTabbable(element, includeContainer, options) {\n  getFirstTabbable(element, includeContainer)?.focus(options);\n}\nfunction getFirstFocusable(element, includeContainer) {\n  if (!element) {\n    return;\n  }\n  return focusable(element, { ...tabbableOptions, includeContainer })[0] ?? element;\n}\nfunction focusFirstFocusable(element, includeContainer, options) {\n  getFirstFocusable(element, includeContainer)?.focus(options);\n}\nfunction filterDirectChildren(el, selector) {\n  return Array.from(el.children).filter((child) => child.matches(selector));\n}\nfunction filterElementsBySelector(elements, selector) {\n  return elements.filter((element) => element.matches(selector));\n}\nfunction setRequestedIcon(iconObject, iconValue, matchedValue) {\n  if (typeof iconValue === \"string\" && iconValue !== \"\") {\n    return iconValue;\n  } else if (iconValue === \"\" || iconValue === true) {\n    return iconObject[matchedValue];\n  }\n}\nfunction intersects(rect1, rect2) {\n  return !(rect2.left > rect1.right || rect2.right < rect1.left || rect2.top > rect1.bottom || rect2.bottom < rect1.top);\n}\nfunction toAriaBoolean(value) {\n  return Boolean(value).toString();\n}\nfunction slotChangeHasContent(event) {\n  return slotChangeHasAssignedElement(event) || slotChangeHasTextContent(event);\n}\nfunction slotChangeGetTextContent(event) {\n  return slotChangeGetAssignedNodes(event).filter((node) => node.nodeType === Node.TEXT_NODE).map((node) => node.textContent).join(\"\").trim();\n}\nfunction hasVisibleContent(element) {\n  for (const node of element.childNodes) {\n    if (node.nodeType === Node.TEXT_NODE && node.textContent?.trim() !== \"\" || node.nodeType === Node.ELEMENT_NODE) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction slotChangeHasTextContent(event) {\n  return !!slotChangeGetTextContent(event);\n}\nfunction slotChangeGetAssignedNodes(event) {\n  return event.currentTarget.assignedNodes({\n    flatten: true\n  });\n}\nfunction slotChangeHasAssignedElement(event) {\n  return !!slotChangeGetAssignedElements(event).length;\n}\nfunction slotChangeGetAssignedElements(event, selector) {\n  return getSlotAssignedElements(event.currentTarget, selector);\n}\nfunction getSlotAssignedElements(slot, selector) {\n  const assignedElements = slot.assignedElements({\n    flatten: true\n  });\n  return selector ? filterElementsBySelector(assignedElements, selector) : assignedElements;\n}\nfunction isPrimaryPointerButton(event) {\n  return !!(event.isPrimary && event.button === 0);\n}\nfunction isKeyboardTriggeredClick(event) {\n  return event.detail === 0;\n}\nconst focusElementInGroup = (elements, currentElement, destination, cycle = true, includeContainer = true, targetAsContext = false) => {\n  const currentIndex = elements.indexOf(currentElement);\n  const isFirstItem = currentIndex === 0;\n  const isLastItem = currentIndex === elements.length - 1;\n  if (cycle) {\n    destination = destination === \"previous\" && isFirstItem ? \"last\" : destination === \"next\" && isLastItem ? \"first\" : destination;\n  }\n  let focusTarget;\n  if (destination === \"previous\") {\n    focusTarget = elements[currentIndex - 1] || elements[cycle ? elements.length - 1 : currentIndex];\n  } else if (destination === \"next\") {\n    focusTarget = elements[currentIndex + 1] || elements[cycle ? 0 : currentIndex];\n  } else if (destination === \"last\") {\n    focusTarget = elements[elements.length - 1];\n  } else {\n    focusTarget = elements[0];\n  }\n  focusElement(focusTarget, includeContainer, \"tabbable\", targetAsContext ? focusTarget : void 0);\n  return focusTarget;\n};\nfunction isBefore(a, b) {\n  if (a.parentNode !== b.parentNode) {\n    return false;\n  }\n  const children = Array.from(a.parentNode.children);\n  return children.indexOf(a) < children.indexOf(b);\n}\nasync function whenAnimationDone(targetEl, animationName) {\n  return whenTransitionOrAnimationDone(targetEl, animationName, \"animation\");\n}\nasync function whenTransitionDone(targetEl, transitionProp) {\n  return whenTransitionOrAnimationDone(targetEl, transitionProp, \"transition\");\n}\nfunction findAnimation(targetEl, type, transitionPropOrAnimationName) {\n  const targetProp = type === \"transition\" ? \"transitionProperty\" : \"animationName\";\n  return targetEl.getAnimations().find((anim) => anim[targetProp] === transitionPropOrAnimationName);\n}\nasync function whenTransitionOrAnimationDone(targetEl, transitionPropOrAnimationName, type) {\n  let anim = findAnimation(targetEl, type, transitionPropOrAnimationName);\n  if (!anim) {\n    await nextFrame();\n    anim = findAnimation(targetEl, type, transitionPropOrAnimationName);\n  }\n  if (!anim) {\n    return;\n  }\n  try {\n    await anim.finished;\n  } catch {\n  }\n}\nasync function nextFrame() {\n  await new Promise((resolve) => requestAnimationFrame(() => resolve()));\n}\nfunction getStylePixelValue(value) {\n  if (value.endsWith(\"px\")) {\n    return parseFloat(value);\n  } else if (value.endsWith(\"vw\")) {\n    return viewportUnitToPixel(parseFloat(value), window.innerWidth);\n  } else if (value.endsWith(\"vh\")) {\n    return viewportUnitToPixel(parseFloat(value), window.innerHeight);\n  }\n  return 0;\n}\nfunction viewportUnitToPixel(value, viewportSize) {\n  return value * viewportSize / 100;\n}\nexport {\n  getTextWidth as A,\n  getElementWidth as B,\n  getModeName as C,\n  hasVisibleContent as D,\n  slotChangeHasAssignedElement as a,\n  focusElement as b,\n  getShadowRootNode as c,\n  focusElementInGroup as d,\n  getSlotAssignedElements as e,\n  filterDirectChildren as f,\n  getElementDir as g,\n  slotChangeHasContent as h,\n  isPrimaryPointerButton as i,\n  intersects as j,\n  getRootNode as k,\n  closestElementCrossShadowBoundary as l,\n  isBefore as m,\n  nodeListToArray as n,\n  getStylePixelValue as o,\n  ensureId as p,\n  queryElementRoots as q,\n  tabbableOptions as r,\n  slotChangeGetAssignedElements as s,\n  toAriaBoolean as t,\n  isKeyboardTriggeredClick as u,\n  setRequestedIcon as v,\n  whenTransitionDone as w,\n  getFirstTabbable as x,\n  whenAnimationDone as y,\n  nextFrame as z\n};\n"],"names":["candidateSelectors","candidateSelector","NoElement","matches","getRootNode$1","element","_element$getRootNode","isInert","isInert2","node","lookUp","_node$getAttribute","inertAtt","inert","result","isContentEditable","_node$getAttribute2","attValue","getCandidates","el","includeContainer","filter","candidates","getCandidatesIteratively","getCandidatesIteratively2","elements","options","elementsToCheck","assigned","content","nestedCandidates","validCandidate","shadowRoot","validShadowRoot","_nestedCandidates","hasTabIndex","getTabIndex","getSortOrderTabIndex","isScope","tabIndex","sortOrderedTabbables","a","b","isInput","isHiddenInput","isDetailsWithSummary","child","getCheckedRadio","nodes","form","i","isTabbableRadio","radioScope","queryRadios","name","radioSet","err","checked","isRadio","isNonTabbableRadio","isNodeAttached","_nodeRoot","nodeRoot","nodeRootHost","attached","_nodeRootHost","_nodeRootHost$ownerDo","_node$ownerDocument","_nodeRoot2","_nodeRootHost2","_nodeRootHost2$ownerD","isZeroArea","_node$getBoundingClie","width","height","isHidden","_ref","displayCheck","getShadowRoot","isDirectSummary","nodeUnderDetails","originalNode","parentElement","rootNode","isDisabledFromFieldset","parentNode","isNodeMatchingSelectorFocusable","isNodeMatchingSelectorTabbable","isValidShadowRootTabbable","shadowHostNode","sortByOrder","sortByOrder2","regularTabbables","orderedTabbables","item","candidateTabindex","acc","sortable","tabbable","container","focusable","tabbableOptions","nodeListToArray","nodeList","getElementDir","closest","closestElementCrossShadowBoundary","getRootNode","getShadowRootNode","getHost","root","queryElementRoots","selector","id","isCalciteFocusable","focusElement","strategy","context","focusFirstTabbable","focusFirstFocusable","getFirstTabbable","getFirstFocusable","filterDirectChildren","filterElementsBySelector","setRequestedIcon","iconObject","iconValue","matchedValue","toAriaBoolean","value","slotChangeHasContent","event","slotChangeHasAssignedElement","slotChangeHasTextContent","slotChangeGetTextContent","slotChangeGetAssignedNodes","hasVisibleContent","slotChangeGetAssignedElements","getSlotAssignedElements","slot","assignedElements","isPrimaryPointerButton","isKeyboardTriggeredClick","focusElementInGroup","currentElement","destination","cycle","targetAsContext","currentIndex","isFirstItem","isLastItem","focusTarget","isBefore","children","whenAnimationDone","targetEl","animationName","whenTransitionOrAnimationDone","whenTransitionDone","transitionProp","findAnimation","type","transitionPropOrAnimationName","targetProp","anim","nextFrame","resolve","getStylePixelValue","viewportUnitToPixel","viewportSize"],"mappings":"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","x_google_ignoreList":[0]}