import{_ as se}from"./asyncUtils-Cu__bxqs.js";import{ks as oe,kt as P,eE as re,dD as ce,i as W,cl as ue,_ as p,Y as C,h2 as G,z as fe,ak as he,c3 as R,i3 as me,X as g,s as d,a_ as U,cu as M,h$ as pe,j as X}from"./main-CSjwO60s.js";import{N as Y,W as B}from"./projectionUtils-CsX1UTBu.js";import{e as S}from"./TileKey-1TQKLvpf.js";import{r as I}from"./GeometryDescriptor-CGSMioST.js";class H{constructor(t,n){this.layer=t,this.parameters=n}}let de=class extends H{constructor(e,t,n){super(e,n),this.outSpatialReference=t,this.type="geometry"}selectTilesAtLOD(e){if(e<0)this.geometry.coordinates.forEach(t=>t.tile=null);else{const{tileInfo:t,tilemapCache:n}=this.layer,i=w(t,n)[e].level;this.geometry.coordinates.forEach(a=>a.tile=t.tileAt(i,a.x,a.y))}}allElevationTilesFetched(){return!this.geometry.coordinates.some(e=>!e.elevationTile)}clearElevationTiles(){for(const e of this.geometry.coordinates)e.elevationTile!==this.outsideExtentTile&&(e.elevationTile=null)}populateElevationTiles(e){for(const t of this.geometry.coordinates)!t.elevationTile&&t.tile?.id&&(t.elevationTile=e[t.tile.id])}remapTiles(e){for(const t of this.geometry.coordinates){const n=t.tile?.id;t.tile=n?e[n]:null}}getTilesToFetch(){return oe(this.geometry.coordinates.filter(({tile:e,elevationTile:t})=>e?.id&&!t),(e,t)=>e.tile?.id===t.tile?.id).map(({tile:e})=>e)}forEachTileToFetch(e){for(const t of this.geometry.coordinates)t.tile&&!t.elevationTile&&e(t.tile,()=>t.tile=null)}};class ye extends H{constructor(t,n,i,a){super(t,i),this.maskExtents=a,this.type="extent",this.elevationTiles=[],this._candidateTiles=[],this._fetchedCandidates=new Set,this.extent=n.clone().intersection(t.fullExtent)}selectTilesAtLOD(t,n){const i=this._maximumLodForRequests(n),a=Math.min(i,t);a<0?this._candidateTiles.length=0:this._selectCandidateTilesCoveringExtentAt(a)}_maximumLodForRequests(t){const{tileInfo:n,tilemapCache:i}=this.layer,a=w(n,i);if(!t)return a.length-1;const l=this.extent;if(l==null)return-1;for(let s=a.length-1;s>=0;s--){const o=a[s],r=o.resolution*n.size[0],c=o.resolution*n.size[1];if(Math.ceil(l.width/r)*Math.ceil(l.height/c)<=t)return s}return-1}allElevationTilesFetched(){return this._candidateTiles.length===this.elevationTiles.length}clearElevationTiles(){this.elevationTiles.length=0,this._fetchedCandidates.clear()}populateElevationTiles(t){for(const n of this._candidateTiles){const i=n.id&&t[n.id];i&&(this._fetchedCandidates.add(n),this.elevationTiles.push(i))}}remapTiles(t){this._candidateTiles=J(this._candidateTiles.map(n=>t[n.id]))}getTilesToFetch(){return this._candidateTiles}forEachTileToFetch(t,n){const i=this._candidateTiles;this._candidateTiles=[],i.forEach(a=>{if(this._fetchedCandidates.has(a))return void n?.(a);let l=!1;t(a,()=>l=!0),l?n?.(a):this._candidateTiles.push(a)}),this._candidateTiles=J(this._candidateTiles,n)}_selectCandidateTilesCoveringExtentAt(t){this._candidateTiles.length=0;const n=this.extent;if(n==null)return;const{tileInfo:i,tilemapCache:a}=this.layer,l=w(i,a)[t],s=i.tileAt(l.level,n.xmin,n.ymin),o=s.extent,r=l.resolution*i.size[0],c=l.resolution*i.size[1],f=Math.ceil((n.xmax-o[0])/r),u=Math.ceil((n.ymax-o[1])/c);for(let h=0;h<u;h++)for(let y=0;y<f;y++){const v=new S(s.level,s.row-h,s.col+y);i.updateTileInfo(v),this._tileIsMasked(v)||this._candidateTiles.push(v)}}_tileIsMasked(t){return this.maskExtents?.some(n=>P(n,t.extent))??!1}}function F(e){return e?.tileInfo!=null}function w(e,t){const n=e.lods;if(F(t)){const{effectiveMinLOD:i,effectiveMaxLOD:a}=t;return n.filter(l=>l.level>=i&&l.level<=a)}return n}function J(e,t){const n={},i=[];for(const l of e){const s=l.id;s&&!n[s]?(n[s]=l,i.push(l)):t?.(l)}const a=i.sort((l,s)=>l.level-s.level);return a.filter((l,s)=>{for(let o=0;o<s;o++){const r=a[o].extent;if(r&&P(r,l.extent))return t?.(l),!1}return!0})}let ve=class{constructor(e,t){this.data=e,this.safeWidth=.99999999*(e.width-1),this.dx=(e.width-1)/(t[2]-t[0]),this.dy=(e.width-1)/(t[3]-t[1]),this.x0=t[0],this.y1=t[3]}};class K{constructor(t,n=null){if(this.key=t,n!=null){const i=t.extent;this._samplerData=new ve(n,i)}}get zmin(){return this._samplerData!=null?this._samplerData.data.minValue:0}get zmax(){return this._samplerData!=null?this._samplerData.data.maxValue:0}get hasNoDataValues(){return!!this._samplerData?.data.hasNoDataValues}sample(t,n){if(this._samplerData==null)return;const{safeWidth:i,data:a,dx:l,dy:s,y1:o,x0:r}=this._samplerData,{width:c,values:f,noDataValue:u}=a,h=Q(s*(o-n),0,i),y=Q(l*(t-r),0,i),v=Math.floor(h),b=Math.floor(y),q=v*c+b,O=q+c,V=f[q],k=f[O],$=f[q+1],j=f[O+1];if(V!==u&&k!==u&&$!==u&&j!==u){const Z=y-b,N=V+($-V)*Z;return N+(k+(j-k)*Z-N)*(h-v)}}}function Q(e,t,n){return e<t?t:e>n?n:e}let D=class extends re{queryElevation(e){const t=this.projectIfRequired(e,this.spatialReference);if(!t)return null;switch(e.type){case"point":return xe(e,t,this);case"polyline":return Te(e,t,this);case"multipoint":return ge(e,t,this);default:return null}}projectIfRequired(e,t){if(e==null)return null;const n=e.spatialReference;if(n.equals(t))return e;const i=ce(e,t);return i||W.getLogger(this).error(`Cannot project geometry spatial reference (wkid:${n.wkid}) to elevation sampler spatial reference (wkid:${t.wkid})`),i}};function xe(e,t,n){return e.hasZ=!0,e.z=n.elevationAt(t.x,t.y),e}function Te(e,t,n){m.spatialReference=t.spatialReference;const i=e.hasM&&!e.hasZ;for(let a=0;a<e.paths.length;a++){const l=e.paths[a],s=t.paths[a];for(let o=0;o<l.length;o++){const r=l[o],c=s[o];m.x=c[0],m.y=c[1],i&&(r[3]=r[2]),r[2]=n.elevationAt(m.x,m.y)}}return e.hasZ=!0,e}function ge(e,t,n){m.spatialReference=t.spatialReference;const i=e.hasM&&!e.hasZ;for(let a=0;a<e.points.length;a++){const l=e.points[a],s=t.points[a];m.x=s[0],m.y=s[1],i&&(l[3]=l[2]),l[2]=n.elevationAt(m.x,m.y)}return e.hasZ=!0,e}D=p([C("esri.layers.support.ElevationSampler")],D);const m=new ue;let x=class extends D{get spatialReference(){return this.extent.spatialReference}constructor(e){const t=e.noDataValue,n="tiles"in e?e.tiles.map(a=>new T({tile:a,tileInfo:e.tileInfo,noDataValue:t})):e.samplers;super({noDataValue:t,samplers:n});const i=n[0];if(i){this.extent=i.extent.clone();const{min:a,max:l}=i.demResolution;this.demResolution={min:a,max:l};for(let s=1;s<n.length;s++){const o=n[s];this.extent.union(o.extent),this.demResolution.min=Math.min(this.demResolution.min,o.demResolution.min),this.demResolution.max=Math.max(this.demResolution.max,o.demResolution.max)}}else{const a="tileInfo"in e?e.tileInfo:null;this.extent=G(he(),a?.spatialReference??fe.WGS84),this.demResolution={min:0,max:0}}}elevationAt(e,t){let n;for(const i of this.samplers)if(i.containsAt(e,t)&&(n=i.elevationAt(e,t),n!==i.noDataValue))return n;return n??(W.getLogger(this).warn("#elevationAt()",`Point used to sample elevation (${e}, ${t}) is outside of the sampler`),this.noDataValue)}};p([g({constructOnly:!0})],x.prototype,"noDataValue",void 0),p([g({constructOnly:!0})],x.prototype,"samplers",void 0),x=p([C("esri.layers.support.TileElevationSampler")],x);let T=class extends D{get spatialReference(){return this.extent.spatialReference}constructor(e){super(e);const t=e.tile.key.extent;this.extent=G(t,e.tileInfo.spatialReference),this.extent.zmin=e.tile.zmin,this.extent.zmax=e.tile.zmax;const n=R(e.tileInfo.spatialReference),i=e.tileInfo.lodAt(e.tile.key.level).resolution*n;this.demResolution={min:i,max:i}}contains(e){const t=this.projectIfRequired(e,this.spatialReference);return t!=null&&this.containsAt(t.x,t.y)}containsAt(e,t){return me(this.tile.key.extent,e,t)}elevationAt(e,t){return this.containsAt(e,t)?this.tile.sample(e,t)??this.noDataValue:this.noDataValue}};p([g({constructOnly:!0})],T.prototype,"tile",void 0),p([g({constructOnly:!0})],T.prototype,"noDataValue",void 0),p([g({constructOnly:!0})],T.prototype,"tileInfo",void 0),T=p([C("esri.layers.support.TileElevationSampler.SingleTileElevationSampler")],T);async function we(e,t,n){if(e=n?.ignoreInvisibleLayers?e.filter(r=>r.visible):e.slice(),!e.length)throw new d(A,"Elevation queries require at least one elevation layer to fetch tiles from");const i=I.fromGeometry(t),a={...E,...n,returnSampleInfo:!0},l=e.pop(),s=await z(l,i,a),o=await ne(e,s,a);return o.geometry=o.geometry.export(),n?.returnSampleInfo||delete o.sampleInfo,o}async function z(e,t,n){if(!e)throw new d(A,"Elevation queries require an elevation layer to fetch tiles from");if(!t||!(t instanceof I)&&t.type!=="point"&&t.type!=="multipoint"&&t.type!=="polyline")throw new d("elevation-query:invalid-geometry","Only point, polyline and multipoint geometries can be used to query elevation");const i={...E,...n},a=new de(e,t.spatialReference,i),l=i.signal;return await e.load({signal:l}),await Ee(a,t,l),await ie(a,l),await _(a,l),Ce(a),Me(a,l)}async function Re(e,t,n){if(e=Array.isArray(e)?e:[e],(e=n?.ignoreInvisibleLayers?e.filter(l=>l.visible):e.slice()).length===0)throw new d(A,"Elevation queries require at least one elevation layer to fetch tiles from");if(!t||t.type!=="extent")throw new d("elevation-query:invalid-extent","Invalid or undefined extent");const i={...E,...n,returnSampleInfo:!0},a=ee(e[e.length-1],t,i);return e.length===1?a:te(e,t,await a,i)}async function ee(e,t,n,i){const a=n.signal;await e.load({signal:a});const l=t.spatialReference,s=e.tileInfo.spatialReference;l.equals(s)||(await Y([{source:l,dest:s}],{signal:a}),t=B(t,s));const o=new ye(e,t,n,i);await ie(o,a),await _(o,a);const r=o.elevationTiles,c=o.layer.tileInfo,f=o.parameters.noDataValue;return new x({noDataValue:f,tiles:r,tileInfo:c})}async function te(e,t,n,i){if(e.pop(),!e.length)return n;const a=n.samplers.filter(r=>!r.tile.hasNoDataValues).map(r=>pe(r.extent)),l=await ee(e[e.length-1],t,i,a);if(l.samplers.length===0)return n;const s=n.samplers.concat(l.samplers),o=i.noDataValue;return te(e,t,new x({samplers:s,noDataValue:o}),i)}async function ne(e,t,n){const i=t.geometry.coordinates,a=t.sampleInfo;U(a);const l=new Array,s=new Array;for(let u=0;u<i.length;u++)a[u].demResolution<0&&e.length&&(l.push(i[u]),s.push(u));const o=e.pop();if(o==null||l.length===0)return t;const r=t.geometry.clone(l),c=await z(o,r,n),f=c.sampleInfo;if(!f)throw new Error("no sampleInfo");return s.forEach((u,h)=>{i[u].z=c.geometry.coordinates[h].z,a[u].demResolution=f[h].demResolution,a[u].source=f[h].source}),ne(e,t,n)}async function ie(e,t){e.type==="geometry"&&_e(e);const n=e.parameters.demResolution;if(typeof n=="number")qe(e,n);else if(n==="finest-contiguous")await Ie(e,t);else{if(n!=="auto")throw new d("elevation-query:invalid-dem-resolution",`Invalid dem resolution value '${n}', expected a number, "finest-contiguous" or "auto"`);await De(e,t)}}async function Ie(e,t){const{tileInfo:n,tilemapCache:i}=e.layer,a=L(n,i,e.parameters.minDemResolution);await ae(e,a,t)}async function ae(e,t,n){const i=e.layer;if(e.selectTilesAtLOD(t),t<0)return;const a=i.tilemapCache,l=e.getTilesToFetch();try{if(a&&!F(a))await M(Promise.all(l.map(s=>a.fetchAvailability(s.level,s.row,s.col,{signal:n}))),n);else if(await _(e,n),!e.allElevationTilesFetched())throw e.clearElevationTiles(),new d("elevation-query:has-unavailable-tiles","Some elevation tiles are unavailable")}catch(s){X(s),await ae(e,t-1,n)}}async function De(e,t){Ve(e),ke(e);const n=e.layer.tilemapCache;if(!n||F(n))return le(e,t);const i=e.getTilesToFetch(),a={},l=i.map(async s=>{const o=new S(0,0,0),r=await se(n.fetchAvailabilityUpsample(s.level,s.row,s.col,o,{signal:t}));r.ok!==!1?s.id!=null&&(a[s.id]=o):X(r.error)});await M(Promise.all(l),t),e.remapTiles(a)}async function le(e,t){const n=e.layer.tileInfo;await _(e,t);let i=!1;e.forEachTileToFetch((a,l)=>{n.upsampleTile(a)?i=!0:l()}),i&&await le(e,t)}function L(e,t,n=0){const i=w(e,t);let a=i.length-1;if(n>0){const l=n/R(e.spatialReference),s=i.findIndex(o=>o.resolution<l);s===0?a=0:s>0&&(a=s-1)}return a}const E={maximumAutoTileRequests:20,noDataValue:0,returnSampleInfo:!1,demResolution:"auto",minDemResolution:0,signal:null};async function Ee(e,t,n){let i;const a=e.layer.tileInfo.spatialReference;if(t instanceof I?i=await t.project(a,n):(await Y([{source:t.spatialReference,dest:a}],{signal:n}),i=B(t,a)),!i)throw new d("elevation-query:spatial-reference-mismatch",`Cannot query elevation in '${t.spatialReference.wkid}' on an elevation service in '${a.wkid}'`);e.geometry=I.fromGeometry(i)}function _e(e){if(e.layer.fullExtent==null)return;const t=new K(new S(-1,-1,-1));t.sample=()=>e.parameters.noDataValue,e.outsideExtentTile=t;const n=e.layer.fullExtent;e.geometry.coordinates.forEach(i=>{const a=i.x,l=i.y;(a<n.xmin||a>n.xmax||l<n.ymin||l>n.ymax)&&(i.elevationTile=t)})}function Ae(e,t){const{tileInfo:n,tilemapCache:i}=e.layer,a=t/R(n.spatialReference),l=w(n,i);let s=l[0],o=0;for(let r=1;r<l.length;r++){const c=l[r];Math.abs(c.resolution-a)<Math.abs(s.resolution-a)&&(s=c,o=r)}return o}function qe(e,t){const n=Ae(e,t);e.selectTilesAtLOD(n)}function Ve(e){const{tileInfo:t,tilemapCache:n}=e.layer,i=L(t,n,e.parameters.minDemResolution);e.selectTilesAtLOD(i,e.parameters.maximumAutoTileRequests)}async function _(e,t){const n=e.getTilesToFetch(),i={},a=e.parameters.cache,l=e.parameters.noDataValue,s={noDataValue:l,signal:t},o=n.map(async r=>{if(r.id==null)return;const c=`${e.layer.uid}:${r.id}:${l}`,f=a?.get(c),u=f??await e.layer.fetchTile(r.level,r.row,r.col,s);a?.put(c,u),i[r.id]=new K(r,u)});await M(Promise.allSettled(o),t),e.populateElevationTiles(i)}function ke(e){const t=e.layer.tileInfo;let n=0;const i={},a=o=>{o.id!=null&&(o.id in i?i[o.id]++:(i[o.id]=1,n++))},l=o=>{if(o.id==null)return;const r=i[o.id];r===1?(delete i[o.id],n--):i[o.id]=r-1};e.forEachTileToFetch(a,l);let s=!0;for(;s&&(s=!1,e.forEachTileToFetch(o=>{n<=e.parameters.maximumAutoTileRequests||(l(o),t.upsampleTile(o)&&(s=!0),a(o))},l),s););}function Ce(e){e.geometry.coordinates.forEach(t=>{const n=t.elevationTile;let i=e.parameters.noDataValue;if(n){const a=n.sample(t.x,t.y);a==null?t.elevationTile=null:i=a}t.z=i})}async function Me(e,t){const n=await e.geometry.project(e.outSpatialReference,t);U(n);const i={geometry:n.export(),noDataValue:e.parameters.noDataValue};return e.parameters.returnSampleInfo&&(i.sampleInfo=Se(e)),e.geometry.coordinates.forEach(a=>{a.tile=null,a.elevationTile=null}),i}function Se(e){const t=e.layer.tileInfo,n=R(t.spatialReference);return e.geometry.coordinates.map(i=>{let a=-1;return i.elevationTile&&i.elevationTile!==e.outsideExtentTile&&(a=t.lodAt(i.elevationTile.key.level).resolution*n),{demResolution:a,source:a===-1?void 0:e.layer}})}const A="elevation-query:invalid-layer";export{A as InvalidLayerError,Re as createSampler,E as defaultOptions,L as getFinestLodIndex,z as query,we as queryAll};
