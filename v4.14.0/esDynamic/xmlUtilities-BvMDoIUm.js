import{Z as Fe,a7 as ue,i as ee,s as H,aF as X,cl as B,ch as U,H as he,z as me,a as Pe,_ as R,X as I,Y as te,aH as Be,cd as De,c1 as Ce,a6 as ze,cg as He}from"./main-CSjwO60s.js";import{y as de}from"./OperationalLayer-Ds0FQSCg.js";import{t as M,y as fe,C as Je,n as Me,s as Ne,a as Oe,p as pe,g as Ee,v as ye,U as We,D as Le,b as qe}from"./datasetUtils-CoevgV-1.js";import{u as Ge,N as ge,p as Ae,l as je,d as Ve,j as Ue,D as xe,h as $e,a as Qe,b as Xe,q as Ye,W as Ze,z as Ke,B as Re,c as et,i as Ie}from"./RasterJobHandlerMixin-UR-8PHpt.js";import{R as tt,l as it,a as nt,k as rt,O as st}from"./RasterSymbolizer-BrZXkSNW.js";import{z as Y,l as at}from"./TileInfo-BmHJ3kZT.js";import{QueueProcessor as ot}from"./QueueProcessor-Bne-Dlbg.js";import{i as lt,m as ct,h as ut,x as ht,s as mt}from"./RawBlockCache-BpKctfOs.js";import{g as dt}from"./pixelRangeUtils-DcEknavd.js";import{T as ie,N as be,D as ft,a as pt,l as yt}from"./vectorFieldUtils-BL5wnf_H.js";import{$ as Z,j as ne,W as we,f as Se,c as gt,n as re,H as K,r as xt,i as Rt,C as It,Q as se}from"./rasterProjectionHelper-DNfZ9Hwc.js";import{r as ae,p as bt}from"./clipUtils-BtWPrYe-.js";import{g as wt}from"./FeatureSet-BIUKCqNW.js";import{T as St}from"./rasterFunctionHelper-BsM3I63S.js";const ve=8,vt=256;let _t=0,w=class extends Fe{constructor(){super(...arguments),this._tileFetchQueue=new ot({concurrency:32,process:(t,i)=>this._fetchRawTile(t.pyramidLevel,t.row,t.col,{...t.options,signal:i})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(t){return t?.ioConfig&&(t={...t,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:Y.create(),...t.ioConfig}}),t}get _isGlobalWrappableSource(){const{rasterInfo:t}=this,i=Z(t.spatialReference);return i!=null&&t.extent.width>=i/2}get _hasNoneOrGCSShiftTransform(){const{transform:t}=this.rasterInfo;return t==null||t.type==="gcs-shift"}set rasterJobHandler(t){this._set("rasterJobHandler",t),M(this)&&this.primaryRasters?.rasters?.forEach(i=>i.rasterJobHandler=t)}get rasterId(){return this.url||"rasterId-"+_t++}set url(t){this._set("url",ue(t,ee.getLogger(this)))}async open(t){return this._openPromise??=ne().then(()=>this._open(t)),this._openPromise}async fetchTile(t,i,n,r={}){const e=r.tileInfo||this.rasterInfo.storageInfo.tileInfo,s=this.getTileExtentFromTileInfo(t,i,n,e);if(!s)throw new H("imagery-tile:out-of-bounds","Level for fetch tile out of range");return r={noClip:!0,...r},this.fetchPixels(s,e.size[0],e.size[1],r)}async identify(t,i={}){t=X(B,t).clone().normalize();const{multidimensionalDefinition:n,timeExtent:r}=i,{rasterInfo:e}=this,{hasMultidimensionalTranspose:s,multidimensionalInfo:a}=e;let{transposedVariableName:o}=i;const l=a!=null&&s&&(r!=null||fe(n));l&&!o&&(o=n!=null&&n.length>0?n[0].variableName??void 0:a.variables[0].name,i={...i,transposedVariableName:o}),i=this._getRequestOptionsWithSliceId(i);const{spatialReference:c,extent:u}=e,{datumTransformation:h}=i;let d=we(t,c,h);if(!u.intersects(d))return{location:d,value:null};if(e.transform!=null){const F=e.transform.inverseTransform(d);if(!e.nativeExtent.intersects(F))return{location:F,value:null};d=F}let f=0;const p=o!=null&&a!=null&&e.hasMultidimensionalTranspose;if(M(this)){const F=this.primaryRasters.rasters[0];if(p)return F.identify(d,i);const{pixelSize:L}=e,S=3,z=L.x*S/2,q=L.y*S/2,G=new U({xmin:d.x-z,xmax:d.x+z,ymin:d.y-q,ymax:d.y+q,spatialReference:c}),A={interpolation:"nearest",multidimensionalDefinition:n,sliceId:i.sliceId,bandIds:i.bandIds},{pixelBlock:T}=await F.fetchPixels(G,S,S,A),{pixelBlock:v}=await this.fetchPixels(G,S,S,A);if(T==null)return{location:d,value:null};const P=Math.floor(S*S*.5),J=!T.mask||T.mask[P]?T.pixels.map(C=>C[P]):null;let N;return v!=null&&(N=!v.mask||v.mask[P]?v.pixels.map(C=>C[P]):void 0),{location:d,value:J,processedValue:N,pyramidLevel:0}}if(!p){if(i.srcResolution)f=Se(i.srcResolution,e,this.ioConfig.sampling).pyramidLevel;else if(f=await this.computeBestPyramidLevelForLocation(t,i),f==null)return{location:d,value:null}}const g=this.identifyPixelLocation(d,f,null,p);if(g===null)return{location:d,value:null};const{row:y,col:m,rowOffset:b,colOffset:x,blockWidth:_}=g,k=await this._tileFetchQueue.push({pyramidLevel:f,row:y,col:m,options:i},{signal:i.signal});if(!k?.pixels?.length)return{location:d,value:null};const D=b*_+x;return this._processIdentifyResult(k,{srcLocation:d,position:D,pyramidLevel:f,useTransposedTile:!!p,requestSomeSlices:l,identifyOptions:i})}async fetchPixels(t,i,n,r={}){t=gt(t),r=this._getRequestOptionsWithSliceId(r);const{_hasNoneOrGCSShiftTransform:e}=this;if(r.requestRawData&&e)return this._fetchPixels(t,i,n,r);const s=Z(t.spatialReference),a=re(t);if(s==null||a===0||a===1&&this._isGlobalWrappableSource&&e)return this._fetchPixels(t,i,n,r);if(a>=3)return{extent:t,pixelBlock:null};const o=[],{xmin:l,xmax:c}=t,u=Math.round(s/(c-l)*i),h=u-Math.round((s/2-l)/(c-l)*i);let d=0;const f=[];for(let m=0;m<=a;m++){const b=new U({xmin:m===0?l:-s/2,xmax:m===a?c-s*m:s/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),x=m===0?u-h:m===a?i-d:u;d+=x,f.push(x);const _=r.disableWrapAround&&m>0?null:this._fetchPixels(b,x,n,r);o.push(_)}const p=(await Promise.all(o)).map(m=>m?.pixelBlock);let g=null;const y={width:i,height:n};return this.rasterJobHandler?g=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:y,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:f},r)).pixelBlock:g=ie(p,y,{blockWidths:f}),{extent:t,srcExtent:K(t,this.rasterInfo.spatialReference,r.datumTransformation),pixelBlock:g}}async fetchRawPixels(t,i,n,r={}){i={x:Math.floor(i.x),y:Math.floor(i.y)};const e=await this._fetchRawTiles(t,i,n,r),{nativeExtent:s,nativePixelSize:a,storageInfo:o}=this.rasterInfo,l=2**t,c=a.x*l,u=a.y*l,h=new U({xmin:s.xmin+c*i.x,xmax:s.xmin+c*(i.x+n.width-1),ymin:s.ymax-u*(i.y+n.height-1),ymax:s.ymax-u*i.y,spatialReference:s.spatialReference});if(!e)return{extent:h,srcExtent:h,pixelBlock:null};const{pixelBlocks:d,mosaicSize:f}=e;if(d.length===1&&d[0]!=null&&d[0].width===n.width&&d[0].height===n.height)return{extent:h,srcExtent:h,pixelBlock:e.pixelBlocks[0]};const p=t>0?o.pyramidBlockWidth:o.blockWidth,g=t>0?o.pyramidBlockHeight:o.blockHeight,y={x:i.x%p,y:i.y%g};let m;return this.rasterJobHandler?m=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:d,srcMosaicSize:f,destDimension:n,clipOffset:y,clipSize:n,coefs:null,sampleSpacing:null,interpolation:r.interpolation,alignmentInfo:null,blockWidths:null},r)).pixelBlock:m=ie(d,f,{clipOffset:y,clipSize:n}),{extent:h,srcExtent:h,pixelBlock:m}}fetchRawTile(t,i,n,r){throw new H("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return K(this.rasterInfo.extent,t)}decodePixelBlock(t,i){return!this.rasterJobHandler||i.useCanvas?tt(t,i):this.rasterJobHandler.decode({data:t,options:i})}async request(t,i,n=0){const{customFetchParameters:r}=this.ioConfig,{range:e,query:s,headers:a}=i;n=n??i.retryCount??this.ioConfig.retryCount;const o=e?{Range:`bytes=${e.from}-${e.to}`}:null;try{return await he(t,{...i,query:{...s,...r},headers:{...a,...o}})}catch(l){if(n>0)return n--,this.request(t,i,n);throw l}}getSliceIndex(t){const{multidimensionalInfo:i}=this.rasterInfo;return i==null||t==null||t.length===0?null:Je(t,i)}getTileExtentFromTileInfo(t,i,n,r){const e=r.lodAt(t);return e?this.getTileExtent({x:e.resolution,y:e.resolution},i,n,r.origin,r.spatialReference,r.size):null}updateTileInfo(){const{storageInfo:t,spatialReference:i,extent:n,pixelSize:r}=this.rasterInfo,{pyramidResolutions:e}=t;if(!t.tileInfo){const s=[],a=t.maximumPyramidLevel||0;let o=(r.x+r.y)/2,l=1/.0254*96*o;for(let u=0;u<=a&&(s.unshift(new at({level:a-u,resolution:o,scale:l})),u!==a);u++)if(e){const h=(e[u].x+e[u].y)/2;l*=h/o,o=h}else o*=2,l*=2;const c=new B({x:n.xmin,y:n.ymax,spatialReference:i});t.tileInfo=new Y({origin:c,size:[t.blockWidth,t.blockHeight],spatialReference:i,lods:s}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,i=512,n=512,r){const{width:e,height:s,nativeExtent:a,pixelSize:o,spatialReference:l}=t,c=new B({x:a.xmin,y:a.ymax,spatialReference:l});r==null&&(r=Math.max(0,Math.round(Math.log(Math.max(e,s))/Math.LN2-8)));const u=this.computeBlockBoundary(a,512,512,{x:a.xmin,y:a.ymax},[o],r);t.storageInfo=new it({blockWidth:i,blockHeight:n,pyramidBlockWidth:i,pyramidBlockHeight:n,origin:c,firstPyramidLevel:1,maximumPyramidLevel:r,blockBoundary:u})}async computeBestPyramidLevelForLocation(t,i={}){return 0}computeBlockBoundary(t,i,n,r,e,s=0,a=2){if(e.length===1&&s>0){e=[...e];let{x:u,y:h}=e[0];for(let d=0;d<s;d++)u*=a,h*=a,e.push({x:u,y:h})}const o=[],{x:l,y:c}=r;for(let u=0;u<e.length;u++){const{x:h,y:d}=e[u];o.push({minCol:Math.floor((t.xmin-l+.1*h)/i/h),maxCol:Math.floor((t.xmax-l-.1*h)/i/h),minRow:Math.floor((c-t.ymax+.1*d)/n/d),maxRow:Math.floor((c-t.ymin-.1*d)/n/d)})}return o}getPyramidPixelSize(t){const{nativePixelSize:i}=this.rasterInfo,{pyramidResolutions:n,pyramidScalingFactor:r}=this.rasterInfo.storageInfo;if(t===0)return i;if(n!=null&&n.length)return n[t-1];const e=r**t;return{x:i.x*e,y:i.y*e}}identifyPixelLocation(t,i,n,r){const{spatialReference:e,nativeExtent:s,storageInfo:a}=this.rasterInfo,{maximumPyramidLevel:o,origin:l,transposeInfo:c}=a,u=r&&c!=null?c.tileSize[0]:a.blockWidth,h=r&&c!=null?c.tileSize[1]:a.blockHeight,d=we(t,e,n);if(!s.intersects(d)||i<0||i>o)return null;const f=this.getPyramidPixelSize(i),{x:p,y:g}=f,y=(l.y-d.y)/g/h,m=(d.x-l.x)/p/u,b=Math.min(h-1,Math.floor((y-Math.floor(y))*h)),x=Math.min(u-1,Math.floor((m-Math.floor(m))*u));return{pyramidLevel:i,row:Math.floor(y),col:Math.floor(m),rowOffset:b,colOffset:x,blockWidth:u,srcLocation:d}}getTileExtent(t,i,n,r,e,s){const[a,o]=s,l=r.x+n*a*t.x,c=l+a*t.x,u=r.y-i*o*t.y,h=u-o*t.y;return new U({xmin:l,xmax:c,ymin:h,ymax:u,spatialReference:e})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,i,n){const r=this.rasterInfo.storageInfo.blockBoundary[t];return!r||r.maxRow<i||r.maxCol<n||r.minRow>i||r.minCol>n}updateImageSpaceRasterInfo(t){const{pixelSize:i}=t,{width:n,height:r}=t,e=me.WebMercator;t.spatialReference=e,t.extent=t.nativeExtent=new U({xmin:-.5,ymax:.5,xmax:n-.5,ymin:.5-r,spatialReference:e}),t.isPseudoSpatialReference=!0,t.transform=null,t.pixelSize=new B({x:1,y:1,spatialReference:e});const{extent:s,storageInfo:a}=t;if(a){a.origin=new B({x:s.xmin,y:s.ymax,spatialReference:e});const{pyramidResolutions:o,tileInfo:l}=a;if(o&&o.forEach(c=>{c.x/=i.x,c.y/=i.y}),l){l.origin=a.origin;const c=(t.nativePixelSize.x+t.nativePixelSize.y)/2;l.lods.forEach((u,h)=>{u.resolution=c*2**h,u.scale=96*u.resolution/.0254})}}}async _fetchPixels(t,i,n,r={}){let e=re(t);if(e>=2)return{extent:t,pixelBlock:null};const s=this._getSourceDataInfo(t,i,n,r),{pyramidLevel:a,srcResolution:o,srcExtent:l,srcWidth:c,srcHeight:u,ul:h}=s;if(c===0||u===0)return{extent:t,srcExtent:l,pixelBlock:null};const{rasterInfo:d}=this,f=d.transform,p=f?.type==="gcs-shift",g=Z(t.spatialReference)!=null;!p&&g||(e=re(s.srcExtent,p));const y=await this._fetchRawTiles(a,h,{width:c,height:u,wrapCount:e},r);if(!y)return{extent:t,srcExtent:l,pixelBlock:null};const m=d.storageInfo,b=a>0?m.pyramidBlockWidth:m.blockWidth,x=a>0?m.pyramidBlockHeight:m.blockHeight;let{x:_,y:k}=d.pixelSize;if(a>0){const{pyramidResolutions:E,pyramidScalingFactor:ke}=m;if(E!=null&&E[a-1])({x:_,y:k}=E[a-1]);else{const ce=ke**a;_*=ce,k*=ce}}const D=d.spatialReference,F=new B({x:_,y:k,spatialReference:D}),L=b===c&&x===u&&h.x%b===0&&h.y%x===0,S=new B({x:(t.xmax-t.xmin)/i,y:(t.ymax-t.ymin)/n,spatialReference:t.spatialReference}),z=!t.spatialReference.equals(D),q=D.isGeographic?1e-9:1e-4,{datumTransformation:G}=r;if(!z&&L&&y.pixelBlocks.length===1&&b===i&&x===n&&Tt(o,S,q))return{extent:t,srcExtent:l,srcTilePixelSize:F,pixelBlock:y.pixelBlocks[0]};const A=g&&Z(l.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,T=r.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");T&&!this.rasterJobHandler&&await ne();const v=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:y.extent,pixelSize:S.toJSON(),datumTransformation:G,rasterTransform:f,hasWrapAround:e>0||A,isAdaptive:this.ioConfig.optimizeProjectionAccuracy!==!1,includeGCSGrid:T},r):xt({projectedExtent:t,srcBufferExtent:y.extent,pixelSize:S,datumTransformation:G,rasterTransform:f,hasWrapAround:e>0||A,isAdaptive:!1,includeGCSGrid:T});let P;const J=!r.requestRawData,N={rows:v.spacing[0],cols:v.spacing[1]},C=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(a,y.extent.xmin):void 0,{pixelBlocks:O,mosaicSize:j,isPartiallyFilled:Q}=y;let V=null;if(this.rasterJobHandler)({pixelBlock:P,localNorthDirections:V}=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:O,srcMosaicSize:j,destDimension:J?{width:i,height:n}:null,coefs:J?v.coefficients:null,sampleSpacing:J?N:null,projectDirections:T,gcsGrid:T?v.gcsGrid:null,isUV:this.rasterInfo.dataType==="vector-uv",interpolation:r.interpolation,alignmentInfo:C,blockWidths:null},r));else{const E=ie(O,j,{alignmentInfo:C});P=J?be(E,{width:i,height:n},v.coefficients,N,r.interpolation):E,T&&v.gcsGrid&&(V=ft({width:i,height:n},v.gcsGrid),P=pt(P,this.rasterInfo.dataType,V))}return r.requestRawData||T?{extent:t,srcExtent:l,srcTilePixelSize:F,pixelBlock:P,transformGrid:v,localNorthDirections:V,isPartiallyFilled:Q}:{extent:t,srcExtent:l,srcTilePixelSize:F,pixelBlock:P}}async _fetchRawTiles(t,i,n,r){const{origin:e,blockBoundary:s}=this.rasterInfo.storageInfo,{blockWidth:a,blockHeight:o}=this.getBlockWidthHeight(t);let{x:l,y:c}=i,{width:u,height:h,wrapCount:d}=n;const f=this._getRasterTileAlignmentInfo(t,0);r.buffer&&(l-=r.buffer.cols,c-=r.buffer.rows,u+=2*r.buffer.cols,h+=2*r.buffer.rows);let p=0,g=0,y=0;d&&f!=null&&({worldColumnCountFromOrigin:g,originColumnOffset:y,rightPadding:p}=f,g*f.blockWidth-p>=l+u&&(p=0));const m=Math.floor(l/a),b=Math.floor(c/o),x=Math.floor((l+u+p-1)/a),_=Math.floor((c+h+p-1)/o),k=s[t];if(!k)return null;const{minRow:D,minCol:F,maxCol:L,maxRow:S}=k;if(d===0&&(_<D||x<F||b>S||m>L))return null;const z=new Array;let q=!1;const G=this.ioConfig.allowPartialFill==null?r.allowPartialFill:this.ioConfig.allowPartialFill;for(let C=b;C<=_;C++)for(let O=m;O<=x;O++){let j=O;if(!r.disableWrapAround&&d&&f!=null&&g<=O&&(j=O-g-y),C>=D&&j>=F&&S>=C&&L>=j){const Q=this._tileFetchQueue.push({pyramidLevel:t,row:C,col:j,options:r},{signal:r.signal});G?z.push(new Promise(V=>{Q.then(E=>V(E)).catch(()=>{q=!0,V(null)})})):z.push(Q)}else z.push(Promise.resolve(null))}if(z.length===0)return null;const A=await Promise.all(z),T={height:(_-b+1)*o,width:(x-m+1)*a},{spatialReference:v}=this.rasterInfo,P=this.getPyramidPixelSize(t),{x:J,y:N}=P;return{extent:new U({xmin:e.x+m*a*J,xmax:e.x+(x+1)*a*J,ymin:e.y-(_+1)*o*N,ymax:e.y-b*o*N,spatialReference:v}),pixelBlocks:A,mosaicSize:T,isPartiallyFilled:q}}_fetchRawTile(t,i,n,r){const{storageInfo:e}=this.rasterInfo,s=e.transposeInfo!=null&&!!r.transposedVariableName;if(!s){const h=e.blockBoundary[t];if(!h)return Promise.resolve(null);const{minRow:d,minCol:f,maxCol:p,maxRow:g}=h;if(i<d||n<f||i>g||n>p)return Promise.resolve(null)}const a=s?r.transposeVariableName:r.sliceId,o=this.rasterInfo.storageInfo.isBsqTile?r.bandIds:null,l=lt(this.rasterId,a,o),c=`${t}/${i}/${n}`;let u=ct(l,r.registryId,c);if(u==null){const h=new AbortController;u=this.fetchRawTile(t,i,n,{...r,signal:h.signal}),ut(l,r.registryId,c,u,h),u.catch(()=>ht(l,r.registryId,c))}return r.signal&&Pe(r,()=>{mt(l,r.registryId,c)}),u}_computeMagDirValues(t){const{bandCount:i,dataType:n}=this.rasterInfo;if(!(i===2&&n==="vector-magdir"||n==="vector-uv")||t?.length!==2||!t[0]?.length)return null;const r=t[0].length;if(n==="vector-magdir"){const l=t[1].map(c=>(c+360)%360);return[t[0],l]}const[e,s]=t,a=[],o=[];for(let l=0;l<r;l++){const[c,u]=yt([e[l],s[l]]);a.push(c),o.push(u)}return[a,o]}_getRasterTileAlignmentInfo(t,i){return this._rasterTileAlignmentInfo==null&&(this._rasterTileAlignmentInfo=Rt(this.rasterInfo)),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:{startX:i,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[t]}}_getSourceDataInfo(t,i,n,r={}){const e={datumTransformation:r.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};r.srcResolution&&(e.srcResolution=r.srcResolution,this._updateSourceDataInfo(t,e));const s=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:a,srcHeight:o,pyramidLevel:l}=e,c=a/i,u=o/n,h=l<s&&c*u>=16,d=l===s&&this._requireTooManySrcTiles(a,o,i,n);if(h||d||a===0||o===0){const f=new B({x:(t.xmax-t.xmin)/i,y:(t.ymax-t.ymin)/n,spatialReference:t.spatialReference});let p=It(f,this.rasterInfo.spatialReference,t,e.datumTransformation);const g=!p||r.srcResolution&&p.x+p.y<r.srcResolution.x+r.srcResolution.y;if(h&&r.srcResolution&&g){const y=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(s-l+3>=y){const m=2**y;p={x:r.srcResolution.x*m,y:r.srcResolution.y*m}}}p&&(e.srcResolution=p,this._updateSourceDataInfo(t,e))}return this._requireTooManySrcTiles(e.srcWidth,e.srcHeight,i,n)&&(e.srcWidth=0,e.srcHeight=0),e}_requireTooManySrcTiles(t,i,n,r){const{tileInfo:e}=this.rasterInfo.storageInfo,s=Math.ceil(t/e.size[0])*Math.ceil(i/e.size[1]),a=t/n,o=i/r,l=Math.max(1,(n+r)/1024);return s>=vt*l||a>ve||o>ve}_updateSourceDataInfo(t,i){i.srcWidth=0,i.srcHeight=0;const{rasterInfo:n}=this,r=n.spatialReference,{srcResolution:e,datumTransformation:s}=i,{pyramidLevel:a,pyramidResolution:o,excessiveReading:l}=Se(e,n,this.ioConfig.sampling);if(l)return;let c=i.srcExtent||K(t,r,s);if(c==null)return;const u=n.transform;u&&(c=u.inverseTransform(c)),i.srcExtent=c;const{origin:h}=n.storageInfo,{width:d,height:f,ul:p}=Me(c,h,o,a);i.pyramidLevel=a,i.pyramidResolution=o,i.srcWidth=d,i.srcHeight=f,i.ul=p}_getRequestOptionsWithSliceId(t){return this.rasterInfo.multidimensionalInfo!=null&&t.sliceId==null&&(t={...t,sliceId:this.getSliceIndex(t.multidimensionalDefinition)}),t}_processIdentifyResult(t,i){const{srcLocation:n,position:r,pyramidLevel:e,useTransposedTile:s}=i,a=t.pixels[0].length/t.width/t.height;if(!(!t.mask||t.mask[r]))return{location:n,value:null};const{multidimensionalInfo:o}=this.rasterInfo;if(o==null||!s){const y=t.pixels.map(x=>x[r]),m={location:n,value:y,pyramidLevel:e},b=this._computeMagDirValues(y.map(x=>[x]));return b?.length&&(m.magdirValue=b.map(x=>x[0])),m}let l=t.pixels.map(y=>y.slice(r*a,r*a+a)),c=this._computeMagDirValues(l);const{requestSomeSlices:u,identifyOptions:h}=i;let d=Ne(o,h.transposedVariableName);if(u){const y=Oe(d,h.multidimensionalDefinition,h.timeExtent);l=l.map(m=>y.map(b=>m[b])),c=c?.map(m=>y.map(b=>m[b])),d=y.map(m=>d[m])}const f=t.noDataValues||this.rasterInfo.noDataValue,p={pixels:l,pixelType:t.pixelType};let g;return f!=null&&(dt(p,f),g=p.mask),{location:n,value:null,dataSeries:d.map((y,m)=>{const b={value:g?.[m]===0?null:l.map(x=>x[m]),multidimensionalDefinition:y.multidimensionalDefinition.map(x=>new pe({...x,isSlice:!0}))};return c?.length&&(b.magdirValue=[c[0][m],c[1][m]]),b}),pyramidLevel:e}}};function Tt(t,i,n){return Math.abs(t.x-i.x)<n&&Math.abs(t.y-i.y)<n}R([I()],w.prototype,"_rasterTileAlignmentInfo",void 0),R([I()],w.prototype,"_tileFetchQueue",void 0),R([I({readOnly:!0})],w.prototype,"_isGlobalWrappableSource",null),R([I({readOnly:!0})],w.prototype,"_hasNoneOrGCSShiftTransform",null),R([I()],w.prototype,"_openPromise",void 0),R([I()],w.prototype,"rasterJobHandler",null),R([I({readOnly:!0})],w.prototype,"rasterId",null),R([I(de)],w.prototype,"url",null),R([I({type:String,json:{write:!0}})],w.prototype,"datasetName",void 0),R([I({type:String,json:{write:!0}})],w.prototype,"datasetFormat",void 0),R([I()],w.prototype,"hasUniqueSourceStorageInfo",void 0),R([I()],w.prototype,"rasterInfo",void 0),R([I()],w.prototype,"ioConfig",void 0),R([I()],w.prototype,"sourceJSON",void 0),w=R([te("esri.layers.support.rasterDatasets.BaseRaster")],w);const kt=40;let W=class extends w{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(t,i,n,r={}){const{rasters:e,rasterIds:s}=this.primaryRasters;let a=!1;const{interpolation:o}=r,l=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!r.requestRawData&&l&&(a=e.length===1&&!r.skipRasterFunction,r={...r,interpolation:"bilinear",requestRawData:a}),r.requestRawData&&e.length>1&&!this.hasUniqueSourceStorageInfo&&(a=!1,r={...r,requestRawData:!1});const c=e.map(x=>x.fetchPixels(t,i,n,r)),u=await Promise.all(c),h=u.map(x=>x.pixelBlock),d=a||r.requestRawData?u.map(x=>x.srcTilePixelSize):null;if(r.skipRasterFunction||h.every(x=>x==null))return u[0];const f=u.find(x=>x.pixelBlock!=null)?.extent??t;let p=this.rasterJobHandler?await this.rasterJobHandler.process({extent:f,primaryPixelBlocks:h,primaryPixelSizes:d,primaryRasterIds:s}):this.rasterFunction.process({extent:f,primaryPixelBlocks:h,primaryPixelSizes:d,primaryRasterIds:s});const{transformGrid:g}=u[0];if(!a||p==null||g==null){const x=r.noClip?null:this.getClippingGeometry(f.spatialReference);return!r.noClip&&p!=null&&x&&(p=await ae(p,f,x)),{...u[0],pixelBlock:p}}const y={rows:g.spacing[0],cols:g.spacing[1]};let m;this.rasterJobHandler?m=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[p],srcMosaicSize:{width:p.width,height:p.height},destDimension:{width:i,height:n},coefs:g.coefficients,sampleSpacing:y,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:o,alignmentInfo:void 0,blockWidths:null},r)).pixelBlock:m=be(p,{width:i,height:n},g.coefficients,y,o);const b=r.noClip?null:this.getClippingGeometry(t.spatialReference);return r.noClip||m==null||b==null||(m=await ae(m,t,b)),{extent:t,srcExtent:u[0].srcExtent,pixelBlock:m}}getClippingGeometry(t){const i=this._clippingGeometry.get("0");if(!t||!i)return i;const n=Pt(t);let r=this._clippingGeometry.get(n);return r!=null||(r=t.equals(i.spatialReference)?i:se(i,t),this._clippingGeometry.set(n,r)),r}async _open(t){const{rasterFunction:i}=this;i.isRoot=!0,this.primaryRasters?.rasters?.length?i.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=i.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach(c=>c.rasterJobHandler=this.rasterJobHandler));const{rasters:n,rasterIds:r}=this.primaryRasters,e=n.map(c=>c.rasterInfo?void 0:c.open(t));await Promise.all(e);const s=n.map(({rasterInfo:c})=>c),a=i.bind({rasterInfos:s,rasterIds:r});if(i.rawSourceRasterInfos=s,!a.success||s.length===0)throw new H("raster-function:open",`cannot bind the function: ${a.error??""}`);const o=i.functionName==="Table"?i:i.functionArguments?.raster;o?.functionName==="Table"&&(i.rasterInfo.attributeTable=wt.fromJSON(o.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const l=s[0];this.hasUniqueSourceStorageInfo=s.length===1||s.slice(1).every(c=>Ft(c,l)),this.set("sourceJSON",n[0].sourceJSON),this.set("rasterInfo",i.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const t=this.rasterFunction.getClippingGeometries()[0];let i=t?.clippingGeometry;if(i&&t.clippingType==="inside"){const{extent:n}=this.rasterInfo,r=await import("./densifyOperator-BHu30UIi.js").then(a=>a.d),e=await import("./differenceOperator-DM4qBgat.js").then(a=>a.d);let s=r.execute(Be.fromExtent(n),2*(n.width+n.height)/kt);s=se(s,i.spatialReference),i=e.execute(s,i)}this._clippingGeometry.clear(),i&&this._clippingGeometry.set("0",i)}};function Ft(t,i){const{storageInfo:n,pixelSize:r,spatialReference:e,extent:s}=t,{storageInfo:a,pixelSize:o,spatialReference:l,extent:c}=i;return r.x===o.x&&r.y===o.y&&e.equals(l)&&s.equals(c)&&n.blockHeight===a.blockHeight&&n.blockWidth===a.blockWidth&&n.maximumPyramidLevel===a.maximumPyramidLevel&&n.firstPyramidLevel===a.firstPyramidLevel&&n.pyramidBlockWidth===a.pyramidBlockWidth&&n.pyramidBlockHeight===a.pyramidBlockHeight&&n.pyramidScalingFactor===a.pyramidScalingFactor}function Pt(t){return String(t.wkid??t.wkt??t.wkt2)}R([I({type:String,json:{write:!0}})],W.prototype,"datasetFormat",void 0),R([I()],W.prototype,"tileType",void 0),R([I()],W.prototype,"rasterFunction",void 0),R([I()],W.prototype,"primaryRasters",void 0),W=R([te("esri.layers.support.rasterDatasets.FunctionRaster")],W);const _e=1e3,Bt=t=>{const i=t;let n=class extends i{constructor(...e){super(...e),this._isConstructedFromFunctionRaster=!1,this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=M(e[0]?.raster)}destroy(){this._shutdownJobHandler()}get fullExtent(){return this.serviceRasterInfo?.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){e?.functionName?.toLowerCase()==="none"&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",ue(e,ee.getLogger(this)))}get renderer(){if(this.type!=="imagery-tile")return this.internalRenderer;const{activePresetRendererName:e,presetRenderers:s}=this;return e?s?.find(({name:a})=>a===e)?.renderer.clone():this.internalRenderer}set renderer(e){this.type==="imagery-tile"&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){e==null&&this.rasterFunction==null?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,s,a){const o=s?.layerDefinition?.drawingInfo?.renderer;return Ve(o,a)||void 0}async computeStatisticsHistograms(e,s){await this.load(s),e=X(Ue,e).clone();const{serviceRasterInfo:a}=this;if(a==null)throw new H("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:o}=e;if(o==null)throw new H("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let l=o;const{spatialReference:c}=a;if(!o.spatialReference.equals(c)){await ne();const m=o.type==="extent"?K(o,c):se(o,c);if(m==null)throw new H("imagery-tile-mixin:compute-statistics-histograms","geometry cannot be projected to the data source");l=m}const u=e.pixelSize??new B({x:a.pixelSize.x,y:a.pixelSize.y,spatialReference:c}),{extent:h,width:d,height:f}=bt(a,l,u),p=await this.fetchPixels(h,d,f,{...s,interpolation:"nearest"});if(p.pixelBlock==null)throw new H("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const g=await ae(p.pixelBlock,h,l),y=this._rasterJobHandler;return y?y.computeStatisticsHistograms({pixelBlock:g},s):rt(g)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:s}=this.serviceRasterInfo??{};if(s==null)return e;const a=Ee({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:a,timeExtent:void 0}}async updateRasterFunction(){return this.loaded&&this.type==="imagery-tile"&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){const{loaded:e,symbolizer:s,renderer:a}=this;if(!e||!s||!a)return;const{rasterInfo:o}=this.raster,l=ye(o,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),c=l?.name,u=xe(o,c);return this._updateSymbolizer(s,a,c,u)}async applyRenderer(e,s,a){const o=e?.pixelBlock;if(!(o!=null&&o.pixels&&o.pixels.length>0))return null;await this.updateRenderer();const l=this.bandIds??[],{pixelBlock:c}=await this._symbolize({pixelData:e,simpleStretchParams:s,bandIds:l,symbolizer:this.symbolizer},a);return c}getRawDisplayBandIds(){let{bandIds:e,raster:s}=this;if(this.rasterFunction&&M(s)){const a=s.rasterFunction.rawInputBandIds;e=e?.length&&a?.length&&s.rasterInfo.bandCount!==1?e.map(o=>a[Math.min(o,a.length-1)]):a}return e&&e.length>3&&e.every((a,o)=>a===o)?null:e}getTileUrl(e,s,a){return this.raster.datasetFormat==="RasterTileServer"?`${this.url}/tile/${e}/${s}/${a}`:""}getCompatibleTileInfo(e,s,a=!1){if(!this.loaded||s==null)return null;if(a&&e.equals(this.spatialReference))return this.tileInfo;const o=He(e);return Y.create({size:256,spatialReference:e,origin:o?{x:o.origin[0],y:o.origin[1]}:{x:s.xmin,y:s.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent?.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,s,a,o={}){if(r(this),o.requestAsImageElement){const c=this.getTileUrl(e,s,a);return he(c,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:o.signal}).then(u=>u.data)}const{serviceRasterInfo:l}=this;if(l.multidimensionalInfo!=null&&(o=this.normalizeRasterFetchOptions(o)).multidimensionalDefinition==null){const c=o.tileInfo||l.storageInfo.tileInfo,u=this.raster.getTileExtentFromTileInfo(e,s,a,c);if(u)return{extent:u,pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),this.renderer?.type==="raster-shaded-relief"&&(o={...o,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,s,a,o)}async fetchPixels(e,s,a,o={}){if(this.serviceRasterInfo.multidimensionalInfo!=null&&(o=this.normalizeRasterFetchOptions(o)).multidimensionalDefinition==null)return{extent:e,pixelBlock:null};await this._initJobHandler(),await this.updateRasterFunction(),s=Math.round(s),a=Math.round(a);const l=await this.raster.fetchPixels(e,s,a,o);return o.bandIds?.length&&!this.raster.rasterInfo.storageInfo.isBsqTile&&(l.pixelBlock=l.pixelBlock?.extractBands(o.bandIds)),l}async getSamples(e,s){if(await this.load(),(e=X($e,e).clone()).interpolation&&e.interpolation!=="nearest")throw new H("imagery-tile-mixin:get-samples","only nearest interpolation is currently supported");const a=e.mosaicRule?.multidimensionalDefinition,o={...s,multidimensionalDefinition:a},l=(await this._getSampleLocations(e)).map(u=>this.identify(u,o).then(h=>(h.location=u,h))),c=(await Promise.all(l)).flatMap((u,h)=>this._convertRasterIdentifyResultToSample(u,h));return new Qe({samples:c})}async identify(e,s={}){await this.load(),e=X(B,e).clone().normalize();const{raster:a,serviceRasterInfo:o}=this;if(o?.multidimensionalInfo!=null&&!(o.hasMultidimensionalTranspose&&!(!fe(s.multidimensionalDefinition)&&!s.transposedVariableName))&&(s=this.normalizeRasterFetchOptions(s)).multidimensionalDefinition==null)return{location:e,value:null};const l=this.multidimensionalSubset?.areaOfInterest;if(l&&!l.contains(e))throw new H("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");let c;if(this.serviceRasterInfo?.storageInfo.isBsqTile){const u=M(a)?this.getRawDisplayBandIds():this.bandIds;c=u?.length?u:void 0}return a.identify(e,{...s,bandIds:c})}hasStandardTime(){const e=this.serviceRasterInfo?.multidimensionalInfo;if(e==null||this.serviceRasterInfo?.dataType!=="standard-time")return!1;const s=this.multidimensionalDefinition,a=s?.[0]?.variableName;return e.variables.some(o=>o.name===a&&(!s?.[0].dimensionName||o.dimensions.some(l=>l.name==="StdTime")))}getStandardTimeValue(e){return new Date(We(e)).toISOString()}getMultidimensionalSubsetVariables(e){const s=e??this.serviceRasterInfo?.multidimensionalInfo;return Le(this.multidimensionalSubset,s)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=qe(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&M(this.raster)&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}async _initJobHandler(){if(!this._rasterJobHandler)return super._initJobHandler().then(async()=>{if(!this._rasterJobHandler)return;r(this);const{raster:e}=this;e.rasterJobHandler=this._rasterJobHandler,M(e)&&e.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{})}_shutdownJobHandler(){super._shutdownJobHandler(),this.raster&&(this.raster.rasterJobHandler=null)}async _getSampleLocations(e){const{geometry:s}=e;if(s.type==="point")return[s];const{spatialReference:a,type:o}=s;if(o==="multipoint")return s.points.map(m=>new B({x:m[0],y:m[1],spatialReference:a}));if(o==="polyline"){let m=s;if(e.sampleCount||e.sampleDistance){const b=await import("./densifyOperator-BHu30UIi.js").then(D=>D.d),x=(await import("./lengthOperator-BGZzaL7w.js").then(D=>D.l)).execute(s,{unit:"meters"}),_=Math.min(e.sampleCount||100,_e);let k=e.sampleDistance;k||(k=x/(_+(m.paths[0].length===2?1:0))),m=b.execute(s,k,{unit:"meters"})}return m.paths.flatMap(b=>b.map(x=>new B({x:x[0],y:x[1],spatialReference:a})))}const l=Math.min(e.sampleCount||100,_e),c=s.type==="extent",u=c?s:s.extent,h=Math.sqrt(u.width*u.height/l),d=u.height/h,f=u.width/h,{xmin:p,ymax:g}=u,y=[];for(let m=0;m<d;m++)for(let b=0;b<f;b++){const x=new B({x:p+(b+.5)*h,y:g-(m+.5)*h,spatialReference:a});(c||s.contains(x))&&y.push(x)}return y}_configDefaultInterpolation(){if(this.interpolation==null){r(this);const{raster:e}=this,s=Xe(e.rasterInfo,e.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",s)}}_configDefaultRenderer(e="no"){r(this);const{rasterInfo:s}=this.raster,a=ye(s,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),o=a?.name,l=Ye({variableName:o,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&s.bandCount>1&&(this.bandIds=l?.bandIds??Ze(s)),!this.renderer||e==="override"){const d=Ke(this.raster),f=l?.renderer??Re(s,{bandIds:this.bandIds,variableName:o,rasterFunctionColorRamp:d}),p=s.statistics,g=p&&p.length>0?p[0]:null,y=g?.max??0,m=g?.min??0;this.raster.datasetFormat==="WCSServer"&&f.type==="raster-stretch"&&(y>1e24||m<-1e24)&&(f.dynamicRangeAdjustment=!0,f.customStatistics=null,f.stretchType==="none"&&(f.stretchType="min-max")),this.renderer=f}const c=et({...this.renderer.toJSON(),variableName:o}),u=xe(s,o);this.symbolizer?(this.symbolizer.rendererJSON=c,this.symbolizer.rasterInfo=u):this.symbolizer=new st({rendererJSON:c,rasterInfo:u});const h=this.symbolizer.bind();if(h.success){if(e==="auto"){const{colormap:d}=this.raster.rasterInfo,f=this.renderer;if(d!=null&&f.type==="raster-colormap"){const p=Re(this.raster.rasterInfo);JSON.stringify(p)!==JSON.stringify(f)&&this._configDefaultRenderer("override")}else if(f.type==="raster-stretch"){const p=this.bandIds?.length,g=f.customStatistics?.length;!f.dynamicRangeAdjustment&&g&&p&&g!==p&&this._configDefaultRenderer("override")}}}else ee.getLogger(this).warn("imagery-tile-mixin",h.error||"The given renderer is not supported by the layer."),e==="auto"&&this._configDefaultRenderer("override")}async _updateRasterFunction(){if(this._isConstructedFromFunctionRaster&&M(this.raster)){const h=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&h&&this._set("rasterFunction",ge.fromJSON(h)))}let e,s=this.raster,a=!1;M(s)?(e=s.primaryRasters.rasters,s=e[0],a=!0):e=[s];const{rasterFunction:o}=this;if(o){const h={raster:s};e.length>1&&e.forEach(p=>h[p.url]=p);const d=St(o.functionDefinition?.toJSON()??o.toJSON(),h),f=new W({rasterFunction:d});f.rasterJobHandler=this._rasterJobHandler,await f.open(),this.raster=f}else this.raster=s,await s.open();if(this._cachedRendererJson=void 0,!a&&!o)return;const{bandIds:l}=this,{bandCount:c}=this.raster.rasterInfo,u=l?.length?l.some(h=>h>=c):c>=3;l&&(u||this.renderer&&this.renderer.type!=="raster-stretch")&&this._set("bandIds",null),this._configDefaultRenderer("auto")}_convertRasterIdentifyResultToSample(e,s){const{rasterInfo:a}=this.raster,o=a.storageInfo.pyramidScalingFactor**(e.pyramidLevel??0),l=(a.pixelSize.x+a.pixelSize.y)/2*o;if(!e.dataSeries?.length)return[new Ie({location:e.location,pixelValue:e.value,locationId:s,resolution:l})];const c=[];return e.dataSeries.forEach(({value:u,multidimensionalDefinition:h},d)=>{const f={Variables:h[0].variableName,Dimensions:h.flatMap(({dimensionName:g})=>g).join(",")};for(const{dimensionName:g,values:y}of h){f[g]=Array.isArray(y[0])?y[0][0]:y[0];const m=y[y.length-1];f[`${g}_Max`]=Array.isArray(m)?m[m.length-1]:m}const p=new Ie({location:e.location,pixelValue:u,rasterId:d,locationId:s,resolution:l,attributes:f});c.push(p)}),c}};function r(e){if(!e.raster||!e.serviceRasterInfo)throw new H("imagery-tile","no raster")}return R([I({clonable:!1})],n.prototype,"_cachedRasterFunctionJson",void 0),R([I({clonable:!1})],n.prototype,"_compatibleFullExtent",void 0),R([I({clonable:!1})],n.prototype,"_isConstructedFromFunctionRaster",void 0),R([I({clonable:!1})],n.prototype,"_rasterFunctionUpdatePromise",void 0),R([I({type:[De],json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.bandIds?.join(",")!=="0,1,2"}}}}})],n.prototype,"bandIds",void 0),R([I({json:{origins:{service:{read:{source:"copyrightText"}}}}})],n.prototype,"copyright",void 0),R([I({json:{read:!1}})],n.prototype,"fullExtent",null),R([I({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.interpolation!=="bilinear"}}}}}),Ce(nt)],n.prototype,"interpolation",void 0),R([I()],n.prototype,"ioConfig",void 0),R([I({type:[pe],json:{write:!0}})],n.prototype,"multidimensionalDefinition",null),R([I({type:Ge,json:{write:!0}})],n.prototype,"multidimensionalSubset",void 0),R([I()],n.prototype,"raster",void 0),R([I({type:ge})],n.prototype,"rasterFunction",null),R([I()],n.prototype,"serviceRasterInfo",void 0),R([I()],n.prototype,"sourceJSON",void 0),R([I({readOnly:!0,type:me,json:{read:!1}})],n.prototype,"spatialReference",void 0),R([I({type:Y})],n.prototype,"tileInfo",void 0),R([I(de)],n.prototype,"url",null),R([I()],n.prototype,"renderer",null),R([I({types:je,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){const e=this.renderer?.type==="raster-stretch"&&this.renderer.stretchType==="none"&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType==="Raster"||!e}}},origins:{"web-scene":{types:Ae,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&e.type!=="vector-field"})}}}}})],n.prototype,"internalRenderer",null),R([ze("internalRenderer")],n.prototype,"readRenderer",null),R([I({clonable:!1})],n.prototype,"symbolizer",void 0),n=R([te("esri.layers.mixins.ImageryTileMixin")],n),n};function $(t,i){if(!t||!i)return[];let n=i;i.includes("/")?(n=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";const r=[];if(i){const s=$(t,n);for(let a=0;a<s.length;a++)$(s[a],i).forEach(o=>r.push(o));return r}const e=t.getElementsByTagNameNS("*",n);if(!e||e.length===0)return[];for(let s=0;s<e.length;s++)r.push(e[s]||e.item(s));return r}function oe(t,i){if(!t||!i)return null;let n=i;i.includes("/")?(n=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";const r=$(t,n);return r.length>0?i?oe(r[0],i):r[0]:null}function le(t,i=null){const n=i?oe(t,i):t;let r;return n?(r=n.textContent||n.nodeValue,r?r.trim():null):null}function Te(t,i){const n=$(t,i),r=[];let e;for(let s=0;s<n.length;s++)e=n[s].textContent||n[s].nodeValue,e&&(e=e.trim(),e!==""&&r.push(e));return r}function Dt(t,i=null){return le(t,i)?.split(" ").map(n=>Number(n))??[]}function Ct(t,i){return Te(t,i).map(n=>Number(n))}function zt(t,i){const n=le(t,i);return Number(n)}function Ht(t,i){const n=t?.nodeName?.toLowerCase(),r=i.toLowerCase();return n.slice(n.lastIndexOf(":")+1)===r}function Jt(t){return t.nodeName.slice(t.nodeName.lastIndexOf(":")+1)}export{w as X,Bt as a,Jt as c,oe as e,Ht as i,Te as l,W as m,$ as n,zt as o,Dt as r,le as t,Ct as u};
