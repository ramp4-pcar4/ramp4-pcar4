import{cl as v,az as p,cS as L,ku as W,cX as Re,ky as Ce,j7 as be,m7 as Me,cg as ze,i8 as K,g1 as Ge,dU as Oe,aG as ke,aH as Ze,cW as E,eh as y,ej as Q,ek as ee,el as te,e_ as ie,f5 as Ee,k2 as Ae,f0 as Xe,k3 as He,e$ as Le,k4 as Ye,k5 as Ie,k7 as Ne,aj as je,eb as se,m8 as Be,kv as qe,aJ as Fe,ci as Ue,eq as P,lX as V,ll as Je,cR as $e,m9 as We,ma as Ke,ai as D,aI as Qe}from"./main-CSjwO60s.js";import{n as m,r as A,o as et}from"./vec2f64-CkowXrDb.js";import{p as re,o as x,I as ne,s as T,J as Y,K as ae,_ as R,A as C,g as oe,P as I,y as he,u as b}from"./vec32-CI1xtKog.js";import{_ as tt,a as it,L as st}from"./vec42-DHp-FUwt.js";import{n as rt,r as N,u as nt}from"./vec4f64-DD-nkcCV.js";import{j as ce,U as at,X as M,k as j,y as B,J as ot,O as ht,R as ct}from"./plane-wUwHaY3K.js";import{b as lt,f as le}from"./vectorStacks-B2ngxq6F.js";import{a2 as pt}from"./SketchViewModel-BCVIeloG.js";import{c as dt}from"./rotate-ClH9iv5s.js";import{c as ut,m as _t}from"./curveOperationUtils-ClbIvhut.js";let gt=class{constructor(s){this.spatialReference=s}createVector(){return this._tag(m())}pointToVector(s){return this._tag(A(s.x,s.y))}arrayToVector(s){return this._tag(A(s[0],s[1]))}vectorToArray(s){return[s[0],s[1]]}pointToArray(s){return[s.x,s.y]}vectorToPoint(s,e=new v){if(s)return e.x=s[0],e.y=s[1],e.z=void 0,e.m=void 0,e.spatialReference=this.spatialReference,e}arrayToPoint(s,e=new v){return e.x=s[0],e.y=s[1],e.z=void 0,e.m=void 0,e.spatialReference=this.spatialReference,e}vectorToDehydratedPoint(s,e){if(s)return e??={x:void 0,y:void 0,z:void 0,m:void 0,hasZ:void 0,hasM:void 0,spatialReference:void 0,type:"point"},e.x=s[0],e.y=s[1],e.z=void 0,e.m=void 0,e.hasZ=!1,e.hasM=!1,e.spatialReference=this.spatialReference,e}lerp(s,e,t,i){return Ce(i,s,e,t)}addDelta(s,e,t){s[0]+=e,s[1]+=t}distance(s,e){return W(s,e)}getZ(s,e=void 0){return e}hasZ(){return!1}getM(s,e=void 0){return e}hasM(){return!1}clone(s){return this._tag(et(s))}copy(s,e){return be(e,s)}fromXYZ(s){return this._tag(A(s[0],s[1]))}toXYZ(s,e=p()){return x(e,s[0],s[1],0)}pointToXYZ(s,e=p()){return x(e,s.x,s.y,0)}equals(s,e){return Me(s,e)}_tag(s){return s}};class pe{constructor(e,t){this._valueType=e,this.spatialReference=t}createVector(){return this._tag(p())}pointToVector(e){return this._tag(L(e.x,e.y,this._valueType===0?e.z:e.m))}arrayToVector(e){return this._tag(L(e[0],e[1],e[2]||0))}vectorToArray(e){return[e[0],e[1],e[2]]}pointToArray(e){return this._valueType===0?[e.x,e.y,e.z]:[e.x,e.y,e.m]}vectorToPoint(e,t=new v){if(e)return t.x=e[0],t.y=e[1],t.z=this._valueType===0?e[2]:void 0,t.m=this._valueType===1?e[2]:void 0,t.spatialReference=this.spatialReference,t}arrayToPoint(e,t=new v){return t.x=e[0],t.y=e[1],t.z=this._valueType===0?e[2]:void 0,t.m=this._valueType===1?e[2]:void 0,t.spatialReference=this.spatialReference,t}vectorToDehydratedPoint(e,t){if(!e)return;t??={x:void 0,y:void 0,z:void 0,m:void 0,hasZ:void 0,hasM:void 0,spatialReference:void 0,type:"point"};const i=this._valueType===0,r=this._valueType===1;return t.x=e[0],t.y=e[1],t.z=i?e[2]:void 0,t.m=r?e[2]:void 0,t.hasZ=i,t.hasM=r,t.spatialReference=this.spatialReference,t}lerp(e,t,i,r){return ne(r,e,t,i)}addDelta(e,t,i,r){e[0]+=t,e[1]+=i,this._valueType===0&&(e[2]+=r)}distance(e,t){return this._valueType===0?re(e,t):W(e,t)}getZ(e,t=void 0){return this._valueType===0?e[2]:t}hasZ(){return this._valueType===0}getM(e,t=void 0){return this._valueType===1?e[2]:t}hasM(){return this._valueType===1}clone(e){return this._tag(Re(e))}copy(e,t){return T(t,e)}fromXYZ(e,t=0,i=0){return this._tag(L(e[0],e[1],this._valueType===0?e.length>2?e[2]:t:i))}toXYZ(e,t=p()){return x(t,e[0],e[1],this._valueType===0?e[2]:0)}pointToXYZ(e,t=p()){return x(t,e.x,e.y,this._valueType===0?e.z??0:0)}equals(e,t){return Y(e,t)}_tag(e){return e}}let ft=class{constructor(s){this.spatialReference=s}createVector(){return this._tag(rt())}pointToVector(s){return this._tag(N(s.x,s.y,s.z,s.m))}arrayToVector(s){return this._tag(N(s[0],s[1],s[2]||0,s[3]||0))}vectorToArray(s){return[s[0],s[1],s[2],s[3]]}pointToArray(s){return[s.x,s.y,s.z,s.m]}vectorToPoint(s,e=new v){return e.x=s[0],e.y=s[1],e.z=s[2],e.m=s[3],e.spatialReference=this.spatialReference,e}arrayToPoint(s,e=new v){return e.x=s[0],e.y=s[1],e.z=s[2],e.m=s[3],e.spatialReference=this.spatialReference,e}vectorToDehydratedPoint(s,e){if(s)return e??={x:void 0,y:void 0,z:void 0,m:void 0,hasZ:void 0,hasM:void 0,spatialReference:void 0,type:"point"},e.x=s[0],e.y=s[1],e.z=s[2],e.m=s[3],e.hasZ=!0,e.hasM=!0,e.spatialReference=this.spatialReference,e}lerp(s,e,t,i){return tt(i,s,e,t)}addDelta(s,e,t,i){s[0]+=e,s[1]+=t,s[2]+=i}distance(s,e){return re(s,e)}getZ(s){return s[2]}hasZ(){return!0}getM(s){return s[3]}hasM(){return!0}clone(s){return this._tag(nt(s))}copy(s,e){return it(e,s)}fromXYZ(s,e=0,t=0){return this._tag(N(s[0],s[1],s.length>2?s[2]:e,t))}toXYZ(s,e=p()){return x(e,s[0],s[1],s[2])}pointToXYZ(s,e=p()){return x(e,s.x,s.y,s.z??0)}equals(s,e){return st(s,e)}_tag(s){return s}};function de(s,e,t){return s&&e?new ft(t):e?new pe(1,t):s?new pe(0,t):new gt(t)}function mt(s,e){if(!e.supported)return;let t=1/0,i=-1/0;const r=e.upperBoundX-e.lowerBoundX;s.forEach(a=>{let o=a.pos[0];for(;o<e.lowerBoundX;)o+=r;for(;o>e.upperBoundX;)o-=r;t=Math.min(t,o),i=Math.max(i,o),a.pos[0]=o});const n=i-t;r-n<n&&s.forEach(a=>{a.pos[0]<0&&(a.pos[0]+=r)})}function yt(s,e){const t=ze(s);return e===1&&t?{supported:!0,lowerBoundX:t.valid[0],upperBoundX:t.valid[1]}:{supported:!1,lowerBoundX:null,upperBoundX:null}}class z{constructor(e){this.part=e,this.leftSegment=null,this.rightSegment=null,this.type="vertex",this.index=null}get pos(){return this._pos}set pos(e){this._pos=e,this.part.unnormalizeVertexPositions()}}let X=class{constructor(s,e,t){this.part=s,this.leftVertex=e,this.rightVertex=t,this.type="line",e.rightSegment=this,t.leftSegment=this}toCurveOrCoordinate(){return[...this.rightVertex.pos]}};class xt{constructor(e,t,i,r){this.part=e,this.leftVertex=t,this.rightVertex=i,this.curveDefinition=r,this.type="bezier",t.rightSegment=this,i.leftSegment=this}toCurveOrCoordinate(){return{b:[[...this.rightVertex.pos],[...this.curveDefinition.controlPoint1],[...this.curveDefinition.controlPoint2]]}}}class vt{constructor(e,t,i,r){this.part=e,this.leftVertex=t,this.rightVertex=i,this.curveDefinition=r,this.type="circular-arc",t.rightSegment=this,i.leftSegment=this}toCurveOrCoordinate(){const e=this.rightVertex.pos,{interiorPoint:t}=this.curveDefinition;return{c:[[...e],[...t]]}}}class Vt{constructor(e,t,i,r){this.part=e,this.leftVertex=t,this.rightVertex=i,this.curveDefinition=r,this.type="elliptic-arc-4",t.rightSegment=this,i.leftSegment=this}toCurveOrCoordinate(){const e=this.rightVertex.pos,{centerPoint:t,sweep:i,orientation:r}=this.curveDefinition;return{a:[[...e],[...t],i,r]}}}class ue{constructor(e,t,i,r){this.part=e,this.leftVertex=t,this.rightVertex=i,this.curveDefinition=r,this.type="elliptic-arc-7",t.rightSegment=this,i.leftSegment=this}toCurveOrCoordinate(){const e=this.rightVertex.pos,{centerPoint:t,sweep:i,orientation:r,rotation:n,semiMajorAxisLength:a,minorMajorAxisRatio:o}=this.curveDefinition;return{a:[[...e],t,i,r,n,a,o]}}}class S{constructor(e,t){this._spatialReference=e,this._viewingMode=t,this.vertices=[],this.segments=[],this.index=null}unnormalizeVertexPositions(){this.vertices.length<=1||mt(this.vertices,yt(this._spatialReference,this._viewingMode))}updateVertexIndex(e,t){const{vertices:i}=this;if(i.length===0)return;const r=i[0];let n=null,a=e,o=t;do n=a,n.index=o++,a=n.rightSegment?n.rightSegment.rightVertex:null;while(a!=null&&a!==r);n.leftSegment&&n!==i[i.length-1]&&this.swapVertices(i.indexOf(n),i.length-1)}getFirstVertex(){return this.vertices.at(0)}getLastVertex(){return this.vertices.at(-1)}isClosed(){return this.getFirstVertex()?.leftSegment!==null}swapVertices(e,t){const{vertices:i}=this,r=i[e];i[e]=i[t],i[t]=r}*iterateVertices(){const e=this.getFirstVertex();let t=e;if(t)do yield t,t=t.rightSegment?.rightVertex;while(t!==e&&t!=null)}}class O extends K{constructor(e,t){super(),this.type=e,this.coordinateHelper=t,this._geometry=null,this._dirty=!0,this.parts=[]}get geometry(){if(this._dirty){switch(this.type){case"point":this._geometry=this._toPoint();break;case"multipoint":this._geometry=this._toMultipoint();break;case"polyline":this._geometry=this._toPolyline();break;case"polygon":this._geometry=this._toPolygon();break;case"mesh":break;default:Ge(this.type)}this._dirty=!1}return this._geometry}get spatialReference(){return this.coordinateHelper.spatialReference}get allVerticesUnordered(){return Array.from(this.iterateVerticesUnordered())}*iterateVerticesUnordered(){for(const e of this.parts)for(const t of e.vertices)yield t}get allVertices(){return Array.from(this.iterateVertices())}*iterateVertices(){for(const e of this.parts)yield*e.iterateVertices()}notifyChanges(e){this._dirty=!0,this.emit("change",e)}_toPoint(){const{parts:e,coordinateHelper:t}=this;return e.at(0)?.vertices.length?t.vectorToPoint(e[0].vertices[0].pos):null}_toMultipoint(){const e=[],{coordinateHelper:t,parts:i,spatialReference:r}=this;for(const n of i){const a=n.getFirstVertex();a&&e.push(t.arrayToVector(a.pos))}return new Oe({hasM:t.hasM(),hasZ:t.hasZ(),spatialReference:r,points:e})}_toPolyline(){const e=[];let t=!1;for(const i of this.parts){if(i.vertices.length<1)continue;const r=i.vertices[0],n=[];n.push(r.pos);let a=r.rightSegment;for(;a;)t||=a.type!=="line",n.push(a.toCurveOrCoordinate()),a=a.rightVertex.rightSegment;e.push(n)}return new ke({paths:t?void 0:e,curvePaths:t?e:void 0,spatialReference:this.spatialReference,hasZ:this.coordinateHelper.hasZ(),hasM:this.coordinateHelper.hasM()})}_toPolygon(){const e=[];let t=!1;for(const i of this.parts){if(i.vertices.length<1)continue;const r=i.vertices[0],n=[];n.push(r.pos);let a=r.rightSegment;for(;a&&(t||=a.type!=="line",n.push(a.toCurveOrCoordinate()),a=a.rightVertex.rightSegment,a?.leftVertex!==r););e.push(n)}return new Ze({rings:t?void 0:e,curveRings:t?e:void 0,spatialReference:this.spatialReference,hasZ:this.coordinateHelper.hasZ(),hasM:this.coordinateHelper.hasM()})}static fromGeometry(e,t,i){const r=e.spatialReference,n=de(e.hasZ,e.hasM,r),a=new O(e.type,n);switch(e.type){case"polygon":St(a,e,t,i?.allowCurves??!1);break;case"polyline":wt(a,e,t,i?.allowCurves??!1);break;case"point":_e(a,e,t);break;case"multipoint":Pt(a,e,t);break;case"mesh":_e(a,e.origin,t),a._geometry=e,a._dirty=!1}return a}}function q(s,e,t,i){const r=new z(s);s.vertices.push(r);const n=y(i);return r.pos=e.arrayToVector(n),r.index=s.vertices.length-1,t&&s.segments.push(w(s,t,r,i)),r}function w(s,e,t,i){if(Q(i))return new X(s,e,t);if(ee(i)){const[,c,d]=i.b;return new xt(s,e,t,{controlPoint1:[...c],controlPoint2:[...d]})}if(te(i)){const[,c]=i.c;return new vt(s,e,t,{interiorPoint:[...c]})}if(ie(i)){const[,c,d,l]=i.a;return new Vt(s,e,t,{centerPoint:[...c],sweep:d,orientation:l})}const[,r,n,a,o,h,u]=i.a;return new ue(s,e,t,{centerPoint:[...r],sweep:n,orientation:a,rotation:o,semiMajorAxisLength:h,minorMajorAxisRatio:u})}function St(s,e,t,i){const r=e.spatialReference,n=s.coordinateHelper,{rings:a,curveRings:o}=e,h=o&&i?o:a;for(let u=0;u<h.length;++u){const c=h[u],d=new S(r,t);if(d.index=u,s.parts.push(d),c.length<1)continue;let l=null,_=null;for(let g=0;g<c.length-1;++g)_=q(d,n,_,c[g]),l??=_;c.length>1&&E(y(c[c.length-1]),l?.pos)?_&&l&&d.segments.push(w(d,_,l,c[c.length-1])):_=q(d,n,_,c[c.length-1])}}function wt(s,e,t,i){const r=e.spatialReference,n=s.coordinateHelper,{curvePaths:a,paths:o}=e,h=a&&i?a:o;for(let u=0;u<h.length;++u){const c=h[u],d=new S(r,t);if(d.index=u,s.parts.push(d),c.length<1)continue;let l=null;for(let _=0;_<c.length;++_)l=q(d,n,l,c[_])}}function _e(s,e,t){const i=e.spatialReference,r=s.coordinateHelper,n=new S(i,t);n.index=0;const a=new z(n);a.index=0,a.pos=r.pointToVector(e),n.vertices.push(a),s.parts.push(n)}function Pt(s,e,t){const i=e.spatialReference,{coordinateHelper:r,parts:n}=s,a=e.points.map(o=>r.arrayToVector(o));for(let o=0;o<a.length;o++){const h=new S(i,t);h.index=o,n.push(h);const u=new z(h);u.pos=a[o],u.index=0,h.vertices.push(u)}}function G(s){return s.type==="mesh"}let ge=class{constructor(s,e,t){this._editGeometry=s,this._part=e,this._posOrCurveDef=t,this._addedVertex=null,this._originalSegment=null,this._left=null,this._right=null,this._partAdded=!1}apply(){let s="redo";const{_part:e,_editGeometry:t,_posOrCurveDef:i}=this;if(this._addedVertex==null&&(s="apply",this._addedVertex=new z(e)),!t.parts.includes(e)){this._partAdded=!0;const a=t.parts.at(-1)?.index??-1;e.index=a+1,t.parts.push(e)}const r=e.getLastVertex(),n=t.coordinateHelper.arrayToVector(y(i));if(r==null)e.vertices.push(this._addedVertex),this._addedVertex.pos=n,this._addedVertex.index=0;else{let a=null;r.rightSegment&&(this._originalSegment=r.rightSegment,a=this._originalSegment.rightVertex,e.segments.splice(e.segments.indexOf(this._originalSegment),1)),e.vertices.push(this._addedVertex),this._addedVertex.pos=n,this._left??=w(e,r,this._addedVertex,i),e.segments.push(this._left),r.rightSegment=this._left,this._originalSegment!=null&&a!=null&&(this._right??=new X(this._part,this._addedVertex,a),e.segments.push(this._right),a.leftSegment=this._right),e.updateVertexIndex(this._addedVertex,r.index+1)}this._editGeometry.notifyChanges({operation:s,addedVertices:[this._addedVertex]})}undo(){const{_addedVertex:s,_part:e,_left:t,_right:i,_originalSegment:r}=this;s!=null&&(e.vertices.splice(e.vertices.indexOf(s),1),t!=null&&(e.segments.splice(e.segments.indexOf(t),1),t.leftVertex.rightSegment=null),i!=null&&(e.segments.splice(e.segments.indexOf(i),1),i.rightVertex.leftSegment=null),r!=null&&(e.segments.push(r),r.leftVertex.rightSegment=r,r.rightVertex.leftSegment=r),t!=null?e.updateVertexIndex(t.leftVertex,t.leftVertex.index):e.updateVertexIndex(s,0),this._partAdded&&this._editGeometry.parts.splice(this._editGeometry.parts.indexOf(this._part)),this._editGeometry.notifyChanges({operation:"undo",removedVertices:[s]}))}accumulate(){return!1}},fe=class we{constructor(e,t,i){this._editGeometry=e,this._vertices=t,this.operation=i,this._undone=!1}_notifyChanges(e){this._editGeometry.parts.forEach(t=>t.unnormalizeVertexPositions()),this._editGeometry.notifyChanges({operation:e,updatedVertices:this._vertices})}apply(){this._vertices.forEach(e=>this.operation.apply(e)),this._notifyChanges(this._undone?"redo":"apply")}undo(){this._vertices.forEach(e=>this.operation.undo(e)),this._undone=!0,this._notifyChanges("undo")}canAccumulate(e){if(this._undone||e._vertices.length!==this._vertices.length)return!1;for(let t=0;t<e._vertices.length;++t)if(e._vertices[t]!==this._vertices[t])return!1;return this.operation.canAccumulate(e.operation)}accumulate(e){return!!(e instanceof we&&this.canAccumulate(e))&&(this._vertices.forEach(t=>this.operation.accumulate(t,e.operation)),this.operation.accumulateParams(e.operation),this._notifyChanges("apply"),!0)}},Dt=class{constructor(s,e,t=0){this._editGeometry=s,this._vertices=e,this._minNumberOfVertices=t,this.removedVertices=null}apply(){let s="redo";if(this.removedVertices==null){const e=this.removedVertices=[];this._vertices.forEach(t=>{const i=this._removeVertex(t);i!=null&&e.push(i)}),s="apply"}else this.removedVertices.forEach(e=>{this._removeVertex(e.removedVertex)});this._editGeometry.notifyChanges({operation:s,removedVertices:this._vertices})}undo(){this.removedVertices?.forEach(s=>{this._undoRemoveVertex(s)}),this._editGeometry.notifyChanges({operation:"undo",addedVertices:this._vertices})}accumulate(){return!1}_removeVertex(s){const e=s.part;if(e.vertices.length<=this._minNumberOfVertices)return null;const t={removedVertex:s,createdSegment:null},i=s.leftSegment,r=s.rightSegment;return e.vertices.splice(e.vertices.indexOf(s),1),i&&(e.segments.splice(e.segments.indexOf(i),1),i.leftVertex.rightSegment=null),r&&(e.segments.splice(e.segments.indexOf(r),1),r.rightVertex.leftSegment=null),s.index===0&&r&&this._vertices.length>0&&e.swapVertices(e.vertices.indexOf(r.rightVertex),0),i&&r&&(t.createdSegment=new X(e,i.leftVertex,r.rightVertex),e.segments.push(t.createdSegment)),r&&e.updateVertexIndex(r.rightVertex,r.rightVertex.index-1),t}_undoRemoveVertex(s){const e=s.removedVertex,t=s.removedVertex.part,i=e.leftSegment,r=e.rightSegment;s.createdSegment&&t.segments.splice(t.segments.indexOf(s.createdSegment),1),t.vertices.push(e),i&&(t.segments.push(i),i.leftVertex.rightSegment=i),r&&(t.segments.push(r),r.rightVertex.leftSegment=r),t.updateVertexIndex(e,e.index)}},Tt=class{constructor(s,e,t){this._editGeometry=s,this._segment=e,this._t=t,this.createdVertex=null,this._createdLeftEdge=null,this._createdRightEdge=null}apply(){let s="redo";const e=this._editGeometry.coordinateHelper,t=this._segment,i=t.part,r=t.leftVertex,n=t.rightVertex;i.segments.splice(i.segments.indexOf(t),1);const a=[];switch(this.createdVertex==null&&(s="apply",this.createdVertex=new z(i)),t.type){case"line":a.push(e.lerp(r.pos,n.pos,this._t,e.createVector()));break;case"bezier":{const o=t.toCurveOrCoordinate();a.push(...Ie(r.pos,o,this._t));break}case"circular-arc":{const o=t.toCurveOrCoordinate(),h=Le(r.pos,o);a.push(...Ye(h,o,this._t));break}case"elliptic-arc-4":{const o=t.toCurveOrCoordinate(),h=Xe(r.pos,o);a.push(...He(h,o,this._t));break}case"elliptic-arc-7":{const o=t.toCurveOrCoordinate(),h=Ee(r.pos,o);a.push(...Ae(h,o,this._t));break}}i.vertices.push(this.createdVertex),this.createdVertex.pos=e.arrayToVector(y(a[0])),a.length>1&&(n.pos=e.arrayToVector(y(a[1]))),this._createdLeftEdge==null&&(this._createdLeftEdge=w(i,r,this.createdVertex,a[0])),this._createdLeftEdge.leftVertex.leftSegment?i.segments.push(this._createdLeftEdge):i.segments.unshift(this._createdLeftEdge),r.rightSegment=this._createdLeftEdge,this._createdRightEdge==null&&(this._createdRightEdge=w(i,this.createdVertex,n,a.at(1)??n.pos)),i.segments.push(this._createdRightEdge),n.leftSegment=this._createdRightEdge,i.updateVertexIndex(this.createdVertex,r.index+1),this._editGeometry.notifyChanges({operation:s,addedVertices:[this.createdVertex]})}undo(){if(this.createdVertex==null||this._createdLeftEdge==null||this._createdRightEdge==null)return null;const s=this._segment,e=s.part,{leftSegment:t,rightSegment:i}=this.createdVertex,r=t?.leftVertex,n=i?.rightVertex;e.vertices.splice(e.vertices.indexOf(this.createdVertex),1),e.segments.splice(e.segments.indexOf(this._createdLeftEdge),1),e.segments.splice(e.segments.indexOf(this._createdRightEdge),1),s.leftVertex.leftSegment?e.segments.push(s):e.segments.unshift(s),r&&(r.rightSegment=s),n&&(n.leftSegment=s),r&&e.updateVertexIndex(r,r.index),this._editGeometry.notifyChanges({operation:"undo",removedVertices:[this.createdVertex]})}accumulate(){return!1}};class F{constructor(e,t,i){this._editGeometry=e,this._vertex=t,this._pos=i}apply(){const e=this._originalPosition==null;e&&(this._originalPosition=this._vertex.leftSegment?.toCurveOrCoordinate()??this._vertex.pos),this._apply(e?"apply":"redo")}undo(){const e=this._vertex.leftSegment;e&&this._originalPosition&&this._replaceEdge(e,this._vertex,this._originalPosition),this._vertex.pos=this._editGeometry.coordinateHelper.arrayToVector(y(this._originalPosition)),this._editGeometry.notifyChanges({operation:"undo",updatedVertices:[this._vertex]})}accumulate(e){return e instanceof F&&e._vertex===this._vertex&&(this._pos=e._pos,this._apply("apply"),!0)}_apply(e){this._vertex.pos=this._editGeometry.coordinateHelper.arrayToVector(y(this._pos));const t=this._pos,i=this._vertex.leftSegment;switch(i?.type){case void 0:break;case"line":Q(t)||this._replaceEdge(i,this._vertex,t);break;case"bezier":ee(t)?(i.curveDefinition.controlPoint1=t.b[1],i.curveDefinition.controlPoint2=t.b[2]):this._replaceEdge(i,this._vertex,t);break;case"circular-arc":te(t)?i.curveDefinition.interiorPoint=t.c[1]:this._replaceEdge(i,this._vertex,t);break;case"elliptic-arc-4":ie(t)?(i.curveDefinition.centerPoint=t.a[1],i.curveDefinition.sweep=t.a[2],i.curveDefinition.orientation=t.a[3]):this._replaceEdge(i,this._vertex,t);break;case"elliptic-arc-7":Ne(t)?(i.curveDefinition.centerPoint=t.a[1],i.curveDefinition.sweep=t.a[2],i.curveDefinition.orientation=t.a[3],i.curveDefinition.rotation=t.a[4],i.curveDefinition.semiMajorAxisLength=t.a[5],i.curveDefinition.minorMajorAxisRatio=t.a[6]):this._replaceEdge(i,this._vertex,t)}this._editGeometry.parts.forEach(r=>r.unnormalizeVertexPositions()),this._editGeometry.notifyChanges({operation:e,updatedVertices:[this._vertex]})}_replaceEdge(e,t,i){const r=this._vertex.part,n=e?r.segments.indexOf(e):-1;if(n>-1&&e.leftVertex){const a=w(r,e.leftVertex,t,i);this._vertex.part.segments.splice(n,1,a)}}}class Rt{constructor(e,t){this._editGeometry=e,this._part=t,this._createdSegment=null}apply(){let e="redo";const{_part:t}=this;if(this._createdSegment==null){e="apply";const i=t.getFirstVertex(),r=t.getLastVertex();if(t.isClosed()||t.vertices.length<2||i==null||r==null||t.vertices.length===2&&r.leftSegment?.type==="line")return;this._createdSegment=new X(this._part,r,i)}this._createdSegment.leftVertex.rightSegment=this._createdSegment,this._createdSegment.rightVertex.leftSegment=this._createdSegment,t.segments.push(this._createdSegment),this._editGeometry.notifyChanges({operation:e})}undo(){const{_part:e,_createdSegment:t,_editGeometry:i}=this;t!=null&&(je(e.segments,t),t.leftVertex.rightSegment=null,t.rightVertex.leftSegment=null,i.notifyChanges({operation:"undo"}))}accumulate(){return!1}}let me=class Pe{constructor(e,t,i,r){this._editGeometry=e,this.dx=t,this.dy=i,this.dz=r,this._firstTime=!0}apply(){const e=this._firstTime?"apply":"redo";this._firstTime=!1,this._apply(e,this.dx,this.dy,this.dz)}undo(){this._apply("undo",-this.dx,-this.dy,-this.dz)}accumulate(e){const t=this._editGeometry.geometry;return e instanceof Pe&&e._editGeometry.geometry===t&&(this._apply("apply",e.dx,e.dy,e.dz),this.dx+=e.dx,this.dy+=e.dy,this.dz+=e.dz,!0)}_apply(e,t,i,r){const n=this._editGeometry.geometry;n.offset(t,i,r);const a=this._editGeometry.parts[0].getFirstVertex();if(!a)return;const o=this._editGeometry.coordinateHelper;a.pos=o.pointToVector(n.origin),this._editGeometry.notifyChanges({operation:e,updatedVertices:[a]})}},ye=class De{constructor(e,t,i,r){this._helper=e,this.dx=t,this.dy=i,this.dz=r}_move(e,t,i,r){this._helper.addDelta(e.pos,t,i,r),Ct(e.leftSegment,t,i)}apply(e){this._move(e,this.dx,this.dy,this.dz)}undo(e){this._move(e,-this.dx,-this.dy,-this.dz)}canAccumulate(e){return e instanceof De}accumulate(e,t){this._move(e,t.dx,t.dy,t.dz)}accumulateParams(e){this.dx+=e.dx,this.dy+=e.dy,this.dz+=e.dz}};function Ct(s,e,t){switch(s?.type){case null:case void 0:case"line":return;case"bezier":{const{controlPoint1:i,controlPoint2:r}=s.curveDefinition;i[0]+=e,i[1]+=t,r[0]+=e,r[1]+=t;break}case"circular-arc":{const{interiorPoint:i}=s.curveDefinition;i[0]+=e,i[1]+=t;break}case"elliptic-arc-4":case"elliptic-arc-7":{const{centerPoint:i}=s.curveDefinition;i[0]+=e,i[1]+=t}}}class k{get plane(){return this._plane}get requiresSplitEdgeLeft(){return!this._left.isOriginalDirection}get requiresSplitEdgeRight(){return!this._right.isOriginalDirection}get edgeDirection(){return this._edgeDirection}constructor(e,t,i,r=0,n=0){this._helper=e,this._planeType=t,this._edge=i,this.distance=r,this._plane=ce(),this._offsetPlane=ce(),this._minDistance=-1/0,this._maxDistance=1/0,this._selectedArrow=1,n===0&&this._initialize()}_initialize(){this._initializeNeighbors(),this._initializePlane(),this._initializeDistanceConstraints()}_initializeNeighbors(){const e=this._toXYZ(this._edge.leftVertex.pos),t=this._toXYZ(this._edge.leftVertex.leftSegment?.leftVertex?.pos),i=this._toXYZ(this._edge.rightVertex.pos),r=this._toXYZ(this._edge.rightVertex.rightSegment?.rightVertex?.pos);this._edgeDirection=ae(p(),e,i),t?(this._left=this._computeNeighbor(e,t,this._edgeDirection),this._right=this._computeNeighbor(i,r,this._edgeDirection,this._left)):(this._right=this._computeNeighbor(i,r,this._edgeDirection),this._left=this._computeNeighbor(e,t,this._edgeDirection,this._right))}_toXYZ(e){return e!=null?this._helper.toXYZ(e):null}_pointToXYZ(e){return this._toXYZ(this._helper.pointToVector(e))}_computeNeighbor(e,t,i,r){const n=p();if(t){ae(n,e,t);const a=!this._passesBisectingAngleThreshold(n,i);return{start:e,end:t,direction:a?this._bisectVectorsPerpendicular(i,n):n,isOriginalDirection:!a}}return this._helper.hasZ()?r&&(R(n,i,r.direction),R(n,n,i),C(n,n),Math.sign(n[1])!==Math.sign(i[0])&&oe(n,n,-1)):x(n,-i[1],i[0],0),{start:e,end:t,direction:n,isOriginalDirection:!0}}_passesBisectingAngleThreshold(e,t){const i=Math.abs(lt(t,e));return i>=xe&&i<=Math.PI-xe}_bisectVectorsPerpendicular(e,t){const i=I(e,t)<0?e:he(p(),e),r=Math.abs(I(i,t));if(!(r<ve||r>1-ve))return this._bisectDirection(i,t);const n=R(p(),i,[0,0,1]);return C(n,n)}_bisectDirection(e,t){const i=b(p(),e,t);return C(i,i)}_initializePlane(){const e=this._computeNormalDirection(this._left),t=this._computeNormalDirection(this._right);I(e,t)<0&&he(t,t),at(this._left.start,this._bisectDirection(e,t),this._plane)}_computeNormalDirection(e){const t=R(p(),e.direction,this._edgeDirection);C(t,t);const i=R(p(),this._edgeDirection,t);return this._planeType===1&&(i[2]=0),C(i,i)}_initializeDistanceConstraints(){this._left.end==null||this.requiresSplitEdgeLeft||this._updateDistanceConstraint(M(this._plane,this._left.end)),this._right.end==null||this.requiresSplitEdgeRight||this._updateDistanceConstraint(M(this._plane,this._right.end)),this._updateIntersectDistanceConstraint(this._plane)}_updateDistanceConstraint(e){e<=0&&(this._minDistance=Math.max(this._minDistance,e)),e>=0&&(this._maxDistance=Math.min(this._maxDistance,e))}_updateIntersectDistanceConstraint(e){const t=j(e),i=this._edgeDirection,r=b(p(),this._left.start,this._left.direction),n=b(p(),this._right.start,this._right.direction),a=this._pointInBasis2D(m(),t,i,this._left.start),o=this._pointInBasis2D(m(),t,i,r),h=this._pointInBasis2D(m(),t,i,this._right.start),u=this._pointInBasis2D(m(),t,i,n),[c]=pt({start:o,end:a},{start:u,end:h});if(!c)return;const d=se(m(),a,o);Be(d,d);const l=se(m(),c,o),_=qe(d,l),g=b(p(),r,oe(p(),this._left.direction,-_)),Z=M(e,g);this._updateDistanceConstraint(Z)}_pointInBasis2D(e,t,i,r){return e[0]=le(t,r),e[1]=le(i,r),e}_offset(e,t){Number.isFinite(this._minDistance)&&(t=Math.max(this._minDistance,t)),Number.isFinite(this._maxDistance)&&(t=Math.min(this._maxDistance,t)),B(this._offsetPlane,this._plane),this._offsetPlane[3]-=t;const i=(n,a,o)=>a!=null&&ot(this._offsetPlane,n,b(p(),n,a),o),r=p();(e===this._edge.leftVertex?i(this._left.start,this._left.direction,r):i(this._right.start,this._right.direction,r))&&this._helper.copy(this._helper.fromXYZ(r,void 0,this._helper.getM(e.pos)),e.pos)}selectArrowFromStartPoint(e){this._selectedArrow=ht(this.plane,this._pointToXYZ(e))?1:-1}get selectedArrow(){return this._selectedArrow}signedDistanceToPoint(e){return M(this.plane,this._pointToXYZ(e))}clampedStartAndEnd(e){const t=this._helper.toXYZ(this._helper.pointToVector(e)),i=ct(this._plane,t,p()),r=M(this._plane,t),n=Fe(r,this._minDistance,this._maxDistance);return ne(t,i,t,n/r),{start:i,end:t}}apply(e){this._offset(e,this.distance)}undo(e){this._offset(e,0)}canAccumulate(e){return e instanceof k&&this._edge.leftVertex.index===e._edge.leftVertex.index&&this._edge.rightVertex.index===e._edge.rightVertex.index&&this._edge.part===e._edge.part&&this._maybeEqualsVec3(this._left.direction,e._left.direction)&&this._maybeEqualsVec3(this._right.direction,e._right.direction)&&Y(j(this._plane),j(e._plane))}accumulate(e,t){const i=this._plane[3]-t._plane[3]+t.distance;this._offset(e,i)}accumulateParams(e){const t=e.distance-e._plane[3];this.distance=t+this._plane[3]}clone(){const e=new k(this._helper,this._planeType,this._edge,this.distance,1);return B(e._plane,this._plane),B(e._offsetPlane,this._offsetPlane),e._maxDistance=this._maxDistance,e._minDistance=this._minDistance,e._left=this._cloneNeighbor(this._left),e._right=this._cloneNeighbor(this._right),e._edgeDirection=T(p(),this._edgeDirection),e}_maybeEqualsVec3(e,t){return e==null&&t==null||e!=null&&t!=null&&Y(e,t)}_cloneNeighbor({start:e,end:t,direction:i,isOriginalDirection:r}){return{start:T(p(),e),end:t!=null?T(p(),t):null,direction:T(p(),i),isOriginalDirection:r}}}const xe=Ue(15),ve=.001;let Ve=class Te{constructor(e,t,i=0){this.origin=e,this.angle=t,this._accumulationType=i}_rotate(e,t){P(e.pos,e.pos,this.origin,t),bt(e.leftSegment,this.origin,t)}apply(e){this._rotate(e,this.angle)}undo(e){this._rotate(e,-this.angle)}canAccumulate(e){return e instanceof Te&&E(this.origin,e.origin)}accumulate(e,t){const i=t._accumulationType===1;this._rotate(e,i?t.angle-this.angle:t.angle)}accumulateParams(e){const t=e._accumulationType===1;this.angle=t?e.angle:this.angle+e.angle}};function bt(s,e,t){switch(s?.type){case null:case void 0:case"line":return;case"bezier":{const{controlPoint1:i,controlPoint2:r}=s.curveDefinition;return P(i,i,e,t),void P(r,r,e,t)}case"circular-arc":{const{interiorPoint:i}=s.curveDefinition;return void P(i,i,e,t)}case"elliptic-arc-4":case"elliptic-arc-7":{const i=s.leftVertex.pos,r=P([0,0],[i[0],i[1]],e,-t),n=s.toCurveOrCoordinate(),[,a,o,h,u,c,d]=dt(r,n,e,t).a;if(s.type==="elliptic-arc-4"){const l=s.curveDefinition;l.centerPoint=[...a],l.sweep=o,l.orientation=h}else{const l=s.curveDefinition;l.centerPoint=[...a],l.sweep=o,l.orientation=h,l.rotation=u,l.semiMajorAxisLength=c,l.minorMajorAxisRatio=d}}}}class H{constructor(e,t,i,r,n=0){this.origin=e,this.axis1=t,this.factor1=i,this.factor2=r,this._accumulationType=n,this.axis2=A(t[1],-t[0])}_scale({pos:e,leftSegment:t},i,r){const n=t?.toCurveOrCoordinate(),{origin:a,axis1:o,axis2:h}=this;V(e,e,a,o,i),V(e,e,a,h,r),Mt(t,a,o,h,i,r,n)}apply(e){this._scale(e,this.factor1,this.factor2)}undo(e){this._scale(e,1/this.factor1,1/this.factor2)}canAccumulate(e){return e instanceof H&&E(this.origin,e.origin)&&E(this.axis1,e.axis1)}accumulate(e,t){t._accumulationType===1?this._scale(e,t.factor1/this.factor1,t.factor2/this.factor2):this._scale(e,t.factor1,t.factor2)}accumulateParams(e){const t=e._accumulationType===1;this.factor1=t?e.factor1:this.factor1*e.factor1,this.factor2=t?e.factor2:this.factor2*e.factor2}}function Mt(s,e,t,i,r,n,a){switch(s?.type){case null:case void 0:case"line":return;case"bezier":{const{controlPoint1:o,controlPoint2:h}=s.curveDefinition;V(o,o,e,t,r),V(o,o,e,i,n),V(h,h,e,t,r),V(h,h,e,i,n);break}case"circular-arc":case"elliptic-arc-4":case"elliptic-arc-7":{if(!a)return;const o=s.leftVertex.pos,h=ut(e[0],e[1],t[0],t[1],i[0],i[1],r,n),u=Je($e(),h),c=u?We(m(),[o[0],o[1]],u):o,[,d,l,_,g,Z,$]=_t(a,[c[0],c[1]],s,e,t,i,r,n).a;if(s.type==="elliptic-arc-7"){const f=s.curveDefinition;f.centerPoint=d,f.sweep=l,f.orientation=_,f.rotation=g,f.semiMajorAxisLength=Z,f.minorMajorAxisRatio=$}else{const f=new ue(s.part,s.leftVertex,s.rightVertex,{centerPoint:d,sweep:l,orientation:_,rotation:g,semiMajorAxisLength:Z,minorMajorAxisRatio:$});s.part.segments.splice(s.part.segments.indexOf(s),1,f)}return}}}class U{constructor(e,t){this._editGeometry=e,this._newPositions=t}apply(){const e=this._originalPositions==null?"apply":"redo";if(!this._originalPositions){const t=this._editGeometry.coordinateHelper;this._originalPositions=[];for(const{pos:i}of this._editGeometry.iterateVertices())this._originalPositions.push(t.clone(i))}this._apply(e,this._newPositions)}undo(){this._originalPositions&&this._apply("undo",this._originalPositions)}accumulate(e){return e instanceof U&&(this._newPositions=e._newPositions,this._apply("apply",this._newPositions),!0)}_apply(e,t){const i=this._editGeometry.coordinateHelper,r=this._editGeometry.allVertices;for(let n=0;n<r.length;n++)i.copy(t[n],r[n].pos);this._editGeometry.parts.forEach(n=>n.unnormalizeVertexPositions()),this._editGeometry.notifyChanges({operation:e,updatedVertices:r})}}var Se;const zt=Symbol();class Gt{static{Se=zt}constructor(e){this._operations=[],this._closed=!1,this[Se]=!0,e&&(this._operations=e,this._closed=!0)}close(){this._closed=!0}apply(){for(const e of this._operations)e.apply()}undo(){for(let e=this._operations.length-1;e>=0;e--)this._operations[e].undo()}accumulate(e){if(this._closed)return!1;const t=this._operations.length?this._operations[this._operations.length-1]:null;return t&&t.accumulate(e)||(this._operations.push(e),e.apply()),!0}}class J extends K{constructor(e,t,i=!1){super(),this.data=e,this.viewingMode=t,this.allowCurves=i,this._undoStack=[],this._redoStack=[],this._listener=this.data.on("change",r=>{r.addedVertices&&this.emit("vertex-add",{type:"vertex-add",vertices:r.addedVertices,operation:r.operation}),r.removedVertices&&this.emit("vertex-remove",{type:"vertex-remove",vertices:r.removedVertices,operation:r.operation}),r.updatedVertices&&this.emit("vertex-update",{type:"vertex-update",vertices:r.updatedVertices,operation:r.operation})})}destroy(){super.destroy(),this._listener.remove()}splitSegment(e,t){return this._apply(new Tt(this.data,e,t))}updateVertices(e,t,i=1){return this._apply(new fe(this.data,e,t),i)}move(e,t,i,r=1){return G(this.data)?this._apply(new me(this.data,e,t,i),r):this.moveVertices(this.data.allVerticesUnordered,e,t,i,r)}moveVertices(e,t,i,r,n=1){return G(this.data)?this._apply(new me(this.data,t,i,r),n):this.updateVertices(e,new ye(this.data.coordinateHelper,t,i,r),n)}scale(e,t,i,r,n=1,a=0){return this.scaleVertices(this.data.allVerticesUnordered,e,t,i,r,n,a)}scaleVertices(e,t,i,r,n,a=1,o=0){return this.updateVertices(e,new H(t,i,r,n,o),a)}rotate(e,t,i=1,r=0){return this.rotateVertices(this.data.allVerticesUnordered,e,t,i,r)}rotateVertices(e,t,i,r=1,n=0){return this.updateVertices(e,new Ve(t,i,n),r)}removeVertices(e){return this._apply(new Dt(this.data,e,this._minNumVerticesPerType))}appendVertex(e,t){return t??=new S(this.data.spatialReference,this.viewingMode),this._apply(new ge(this.data,t,e))}appendVertexToFirstPart(e){const t=this.data.parts.at(0);return t?this._apply(new ge(this.data,t,e)):null}setVertexPosition(e,t){return this._apply(new F(this.data,e,t))}offsetEdge(e,t,i,r=1){return this.updateVertices([t.leftVertex,t.rightVertex],new k(this.data.coordinateHelper,e,t,i),r)}trySetGeometry(e,t=1){const{data:i}=this,{coordinateHelper:r}=i;if(i.type!==e.type||!i.spatialReference.equals(e.spatialReference)||r.hasZ()!==e.hasZ||r.hasM()!==e.hasM||!Ke(i.geometry,e)||G(i))return;const n=Array.from(O.fromGeometry(e,this.viewingMode,{allowCurves:this.allowCurves}).iterateVerticesUnordered(),a=>a.pos);return this.setVertexPositions(n,t)}setVertexPositions(e,t=1){return this._apply(new U(this.data,e),t)}createResetState(){if(G(this.data))return this._createResetStateMesh();const e=this.data.geometry.clone();return D(()=>this.trySetGeometry(e))}closePart(e){return this.data.parts.includes(e)?this._apply(new Rt(this.data,e)):null}canRemoveVertex(e){return e.vertices.length>this._minNumVerticesPerType}createUndoGroup(){const e=new Gt;return this._apply(e),D(()=>e.close())}recordUndo(e){this._undoStack.push(e),this._redoStack=[]}undo(){if(this._undoStack.length>0){const e=this._undoStack.pop();return e.undo(),this._redoStack.push(e),e}return null}redo(){if(this._redoStack.length>0){const e=this._redoStack.pop();return e.apply(),this._undoStack.push(e),e}return null}get canUndo(){return this._undoStack.length>0}get canRedo(){return this._redoStack.length>0}get lastOperation(){return this._undoStack.length>0?this._undoStack[this._undoStack.length-1]:null}get _minNumVerticesPerType(){switch(this.data.type){case"point":return 1;case"polyline":return 2;case"polygon":return 3;default:return 0}}_apply(e,t=1){return t!==0&&this.lastOperation!=null&&this.lastOperation.accumulate(e)||(e.apply(),this.recordUndo(e)),e}_createResetStateMesh(){if(!G(this.data))return D();const e=this.data.geometry,{vertexSpace:t}=e;if(t.origin){const r=Qe(t.origin);return D(()=>{e.vertexSpace.origin=r})}const i=e.vertexAttributes.clonePositional();return D(()=>{e.vertexAttributes=i,e.vertexAttributesChanged()})}static fromGeometry(e,t,i){return new J(O.fromGeometry(e,t,i),t,!!i?.allowCurves)}}class Ot{constructor(e){this.vertexHandle=null,this.excludeFeature=null,this.visualizer=null,this.selfSnappingZ=null,this.drawConstraints=null,this.editGeometryOperations=e.editGeometryOperations,this.elevationInfo=e.elevationInfo,this.pointer=e.pointer,this.vertexHandle=e.vertexHandle,this.excludeFeature=e.excludeFeature,this.feature=e.feature,this.visualizer=e.visualizer,this.selfSnappingZ=e.selfSnappingZ,this.drawConstraints=e.drawConstraints}get coordinateHelper(){return this.editGeometryOperations.data.coordinateHelper}get spatialReference(){return this.coordinateHelper.spatialReference}}export{k as M,S as V,O as a,ye as b,Ot as e,J as g,H as l,Ve as o,fe as t,de as w};
