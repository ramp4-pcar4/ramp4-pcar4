{"version":3,"file":"index-wKUv--LN.js","sources":["../../src/fixtures/details/store/details-state.ts","../../src/fixtures/details/api/details.ts","../../src/fixtures/details/components/symbology-stack.vue","../../src/fixtures/details/components/symbology-item.vue","../../src/fixtures/details/components/symbology-list.vue","../../src/fixtures/details/templates/esri-default.vue","../../src/fixtures/details/templates/html-default.vue","../../src/fixtures/details/components/result-item.vue","../../src/fixtures/details/components/result-list.vue","../../src/fixtures/details/details-screen.vue","../../src/fixtures/details/lang/lang.csv?raw","../../src/fixtures/details/index.ts"],"sourcesContent":["import type { PanelWidthObject } from '@/api';\n\nexport type DetailsItemSet = { [name: string]: DetailsItemInstance };\n\n/**\n * Types of requests for the details panel. Currently, consists of requests\n * from the toggle events, such as the grid (details for a single item) and\n * requests from a map click (details for all items at a point).\n */\nexport type DetailsRequestOrigin = 'toggleEvent' | 'identify';\n\nexport interface DetailsConfig {\n    /**\n     * The dictionary of default templates indexed by identify result format with value as the template component id.\n     */\n    templates: { [type: string]: string };\n\n    /**\n     * The width of the details panel in pixels.\n     *\n     * @type {number}\n     * @interface GridConfig\n     */\n    panelWidth: PanelWidthObject | number;\n}\n\nexport interface DetailsFieldItem {\n    /**\n     * Unique identifier for the field. Aligns with the layer field name.\n     */\n    field: string;\n\n    /**\n     * Specifies the field title.\n     */\n    alias?: string;\n\n    /**\n     * Whether this field is displayed.\n     */\n    visible?: boolean;\n}\n\nexport interface DetailsConfigItem {\n    /**\n     * The layer ID that we want to bind the custom template to.\n     *\n     * @type {string}\n     * @memberof DetailsConfigItem\n     */\n    id: string;\n\n    /**\n     * The optional display name of the layer.\n     *\n     * @type {string}\n     * @memberof DetailsConfigItem\n     */\n    name: string;\n\n    /**\n     * The component that we would like to use as a template.\n     *\n     * @type {string}\n     * @memberof DetailsConfigItem\n     */\n    template: string;\n\n    /**\n     * An array to specify how the layer data fields are defined.\n     *\n     * @type {array}\n     * @memberof DetailsConfigItem\n     */\n    fields?: DetailsFieldItem[];\n}\n\nexport class DetailsItemInstance implements DetailsConfigItem {\n    id: string;\n\n    name: string;\n\n    template: string;\n\n    fields?: DetailsFieldItem[];\n\n    componentId?: string;\n\n    constructor(value: string | DetailsConfigItem) {\n        const params = {\n            ...(typeof value === 'string' ? { id: value, template: '', name: '' } : value)\n        };\n        ({ template: this.template, id: this.id, name: this.name, fields: this.fields } = params);\n    }\n}\n","import { FixtureInstance, LayerInstance, ReactiveIdentifyFactory } from '@/api';\nimport type { IdentifyItem, IdentifyResult } from '@/api';\nimport type { Graphic, IdentifyResultFormat } from '@/geo/api';\nimport { DetailsItemInstance, useDetailsStore } from '../store';\n\nimport type { DetailsConfig, DetailsConfigItem, DetailsItemSet } from '../store';\n\nimport type { HilightAPI } from '../../hilight/api/hilight';\nimport { HilightMode } from '../../hilight/api/hilight-defs';\n\nexport const ORIGIN_DETAILS = 'details';\n\nexport class DetailsAPI extends FixtureInstance {\n    private detailsStore = useDetailsStore(this.$vApp.$pinia);\n\n    get config(): DetailsConfig | undefined {\n        return super.config;\n    }\n\n    /**\n     * Updates the identify result in the store, and then opens the details panel.\n     *\n     * @param {IdentifyResult[]} payload\n     * @memberof DetailsAPI\n     */\n    openDetails(payload: IdentifyResult[]): void {\n        // Save the provided identify result in the store.\n        this.detailsStore.payload = payload;\n\n        const panel = this.$iApi.panel.get('details');\n        // Indicate this request for the details panel comes from clicking on the map\n        this.detailsStore.origin = 'identify';\n        panel.button.tooltip = 'details.layers.title.identifyOrigin';\n\n        // Check to see if each layer has a fixture config in the store.\n        payload.forEach(p => {\n            const layer: LayerInstance | undefined = (this as any).$iApi.useStore('layer').getLayerByUid(p.uid);\n\n            this._loadDetailsConfig(layer);\n        });\n\n        // Open the details panel.\n        const detailsPanel = this.$iApi.panel.get('details');\n        if (!detailsPanel.isOpen) {\n            this.$iApi.panel.open({\n                id: 'details'\n            });\n        }\n    }\n\n    /**\n     * Provided with the data for a single feature, shows or hides details panel.\n     * If panel is closed or incoming data is different than current content, panel is shown.\n     * If panel open and incoming data is what is currently shown, panel closes.\n     * The `open` parameter can override the behavior.\n     * featureData payload (can be empty if forcing closed)\n     * - uid     : uid string of the layer hosting the feature\n     * - format  : structure of the data. IdentifyResultFormat value.\n     * - data    : source information for the feature. Analogous to the data property of an IdentifyItem\n     * - layerId : optional layerId string of the layer hosting the feature. Will be looked up if not provided\n     *\n     * @param {{data: any, uid: string, format: IdentifyResultFormat}} featureData\n     * @param {boolean | undefined} open can force the panel to open (true) or close (false) regardless of current panel state\n     * @memberof DetailsAPI\n     */\n    toggleFeature(\n        featureData: {\n            data: any;\n            uid: string;\n            layerId?: string;\n            format: IdentifyResultFormat;\n        },\n        open: boolean | undefined\n    ): void {\n        const panel = this.$iApi.panel.get('details');\n\n        if (open === false) {\n            // close panel and run away. allows a close without providing featureData\n            panel.close();\n            this.detailsStore.currentFeatureId = undefined;\n            return;\n        }\n\n        // feature ids are composed of the layer uid and feature object id\n        const layer: LayerInstance | undefined = this.$iApi.geo.layer.getLayer(featureData.uid);\n        const currFeatureId = `${featureData.uid}-${\n            // see https://github.com/ramp4-pcar4/ramp4-pcar4/issues/1767 for the reasoning behind this\n            layer?.supportsFeatures ? featureData.data[layer?.oidField ?? ''] : JSON.stringify(featureData.data)\n        }`;\n\n        if (panel.isOpen && currFeatureId === this.detailsStore.currentFeatureId && !(open === true)) {\n            // panel is open, same request was fired at it, and not a force-open. Close it.\n            panel.close();\n            this.detailsStore.currentFeatureId = undefined;\n            return;\n        }\n\n        // at this point, we are showing the payload\n\n        // Indicate this request for the details panel comes from a grid item\n        this.detailsStore.origin = 'toggleEvent';\n\n        panel.button.tooltip = 'details.layers.title.gridOrigin';\n\n        this.detailsStore.currentFeatureId = currFeatureId;\n\n        // Check to see if the layer has a fixture config in the store.\n        this._loadDetailsConfig(layer);\n\n        const fakeResult: IdentifyResult = {\n            items: [ReactiveIdentifyFactory.makeRawItem(featureData.format, featureData.data)],\n            uid: featureData.uid,\n            layerId: featureData.layerId || layer?.id || 'error-not-found',\n            loading: Promise.resolve(),\n            loaded: true,\n            errored: false,\n            requestTime: Date.now()\n        };\n\n        this.detailsStore.payload = [fakeResult];\n\n        if (!panel.isOpen) {\n            panel.open();\n        }\n    }\n\n    /**\n     * Read the details section of the layers' fixture config\n     *\n     * @param {DetailsConfig} [config]\n     * @memberof DetailsAPI\n     */\n    _parseConfig(config?: DetailsConfig) {\n        // set the default templates if provided\n        if (config && config.templates) {\n            this.detailsStore.defaultTemplates = config.templates;\n        }\n\n        this.handlePanelWidths(['details']);\n        this.handlePanelTeleports(['details']);\n\n        // get all layer fixture configs\n        const layerDetailsConfigs: any = this.getLayerFixtureConfigs();\n        const detailsConfigItems: DetailsConfigItem[] = [];\n\n        // construct the details config from the layer fixture configs\n        Object.keys(layerDetailsConfigs).forEach((layerId: string) => {\n            detailsConfigItems.push({\n                id: layerId,\n                name: layerDetailsConfigs[layerId].name,\n                template: layerDetailsConfigs[layerId].template,\n                fields: layerDetailsConfigs[layerId].fields\n            });\n        });\n\n        const detailsItems = detailsConfigItems.map((item: any) => new DetailsItemInstance(item));\n\n        // save the items in the store\n        this.detailsStore.properties = detailsItems.reduce<DetailsItemSet>((map, item) => {\n            map[item.id] = item;\n            return map;\n        }, {});\n\n        this._validateItems();\n    }\n\n    _loadDetailsConfig(layer: LayerInstance | undefined) {\n        // Check to see if the layer has a fixture config in the store.\n        if (layer) {\n            // Check to see if we've already saved this layer's details config.\n            const detailsItem = this.detailsStore.properties[layer.id];\n\n            // If we haven't and the layer has a details config set, add it to the details store.\n            if (detailsItem === undefined) {\n                const layerDetailsConfigs: any = this.getLayerFixtureConfigs();\n\n                if (layerDetailsConfigs[layer.id] !== undefined) {\n                    this.detailsStore.addConfigProperty({\n                        id: layer.id,\n                        name: layerDetailsConfigs[layer.id].name,\n                        template: layerDetailsConfigs[layer.id].template,\n                        fields: layerDetailsConfigs[layer.id].fields\n                    });\n                }\n            }\n        }\n    }\n\n    /**\n     * Check to see if the stored components are registered properly.\n     *\n     * @memberof DetailsAPI\n     */\n    _validateItems() {\n        Object.values<DetailsConfigItem>(this.detailsStore.properties).forEach(item => {\n            if (item.template in this.$vApp.$options.components!) {\n                this.detailsStore.properties[item.id].componentId = item.template;\n            }\n        });\n    }\n\n    /**\n     * Highlight identified items\n     * @param items items to add\n     * @param layerUid uid of layer the items belong to\n     */\n    async hilightDetailsItems(items: IdentifyItem | Array<IdentifyItem>, layerUid: string) {\n        // hilight all provided identify items for this layer\n        const hItems = items instanceof Array ? items : [items];\n        const hilightFix: HilightAPI = this.$iApi.fixture.get('hilight');\n        if (hilightFix) {\n            const gsByKey = await hilightFix.getGraphicsByKey(ORIGIN_DETAILS);\n            await hilightFix.removeHilight(gsByKey);\n\n            // calculate after the above removeHilight call, since it also does a timestamp.\n            // NOTE if the two calls are too fast (same time) then we can add optional param to\n            //      not stamp when removing, or pass in this stamp.\n            // mark and save this highlight session\n            const thisHighlight = Date.now();\n            this.detailsStore.lastHilight = thisHighlight;\n\n            const graphics: Array<Graphic> = await this.getHilightGraphics(hItems, layerUid);\n\n            if (this.detailsStore.lastHilight === thisHighlight) {\n                // our request on this thread is still the most recent one. begin to add graphics to highlighter\n                await hilightFix.addHilight(graphics);\n\n                // while unlikely, given everything is async its possible that a delete request completes before\n                // the graphics could be added to the hilight layer.\n                // so check one again. If we're now stale, remove the hilight.\n                if (this.detailsStore.lastHilight !== thisHighlight) {\n                    // hilight removal will gracefully exit if something else already deleted any of these graphics.\n                    hilightFix.removeHilight(graphics);\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove all details panel map hilights.\n     */\n    async removeDetailsHilight() {\n        const hilightFix: HilightAPI = this.$iApi.fixture.get('hilight');\n        if (hilightFix) {\n            // mark that we are removing. any in-progress highlights will\n            // see this new timestamp and know they are stale once finished.\n            this.detailsStore.lastHilight = Date.now();\n            const gsByKey = await hilightFix.getGraphicsByKey(ORIGIN_DETAILS);\n            await hilightFix.removeHilight(gsByKey);\n        }\n    }\n\n    /**\n     * Reload map elements of the hilighter for a set of identify items.\n     *\n     * @param {IdentifyItem | Array<IdentifyItem>} items items to reload\n     * @param {string} layerUid uid of layer the items belong to\n     */\n    async reloadDetailsHilight(items: IdentifyItem | Array<IdentifyItem>, layerUid: string) {\n        // DEV NOTE: this call is not being used anymore. But since part of public API, remains\n        //           for respectful compatibility\n\n        // TODO this method doesn't use the lastHilight flag, so in theory if a stale\n        //      batch of identify items is passed, they will end up drawing.\n        //      Might be easier to depreciate this method? Breaks API but\n        //      the method is really just a shortcut to remove + add, without the\n        //      smarter code of those methods.\n        //      Alternate, replace all the guts with\n        //        await removeDetailsHilight\n        //        await hilightDetailsItems(items, layerUid)\n        //      but that technically changes the method behavior\n\n        // hilight all provided identify items for this layer\n        const hItems = items instanceof Array ? items : [items];\n        const hilightFix: HilightAPI = this.$iApi.fixture.get('hilight');\n        if (hilightFix) {\n            const graphics: Array<Graphic> = await this.getHilightGraphics(hItems, layerUid);\n            hilightFix.reloadHilight(graphics);\n        }\n    }\n\n    /**\n     * Return the graphics of the given IdentifyItems once the items have loaded.\n     * @param {Array<IdentifyItem>} items identify items to hilight. Items should be of ESRI format\n     * @param layerUid uid of layer the items belong to\n     * @returns {Promise<Array<Graphic>>} resolves with array of graphics\n     */\n    async getHilightGraphics(items: Array<IdentifyItem>, layerUid: string): Promise<Array<Graphic>> {\n        const layer: LayerInstance = this.$iApi.geo.layer.getLayer(layerUid)!;\n        const hilightFix: HilightAPI = this.$iApi.fixture.get('hilight');\n        const gs: Array<Graphic> = [];\n        if (layer) {\n            // get all the identified Graphics\n            await Promise.all(\n                items.map(async item => {\n                    // ensure item finishes loading\n                    await item.loading;\n\n                    const oid = item.data[layer.oidField];\n                    const g = await layer.getGraphic(oid, {\n                        getGeom: true,\n                        getAttribs: true,\n                        getStyle: true\n                    });\n                    g.id = hilightFix.constructGraphicKey(ORIGIN_DETAILS, layerUid, oid);\n                    gs.push(g);\n                })\n            );\n        }\n        return gs;\n    }\n\n    /**\n     * Updates hilighted graphics when the hilight toggler is toggled.\n     *\n     * @param {boolean} hilightOn Whether the toggler has been turned on/off\n     * @param {IdentifyItem | Array<IdentifyItem>} items The identify items to highlight. Only required if turning on\n     * @param {string} layerUid the layer UID that owns the items. Only required if turning on\n     */\n    onHilightToggle(hilightOn: boolean, items?: IdentifyItem | Array<IdentifyItem>, layerUid?: string) {\n        // DEV NOTE: this call is not being used anymore. But since part of public API, remains\n        //           for respectful compatibility\n\n        this.detailsStore.hilightToggle = hilightOn;\n\n        if (hilightOn && items && layerUid) {\n            // hilight got turned on, and valid params provided\n            this.hilightDetailsItems(items, layerUid);\n        } else if (!hilightOn) {\n            // hilight got turned off\n            this.removeDetailsHilight();\n        }\n    }\n\n    /**\n     * Return whether or not a HilightMode has been defined (other than NONE)\n     */\n    hasHilighter(): boolean {\n        const hilightFix: HilightAPI = this.$iApi.fixture.get('hilight');\n        return hilightFix && hilightFix.hilightMode.mode !== HilightMode.NONE;\n    }\n}\n","<template>\n    <div v-if=\"result.loaded\" class=\"relative\">\n        <div :class=\"result.items.length === 0 ? 'opacity-50' : ''\">\n            <!-- Multiple icons to display -->\n            <div v-if=\"stack.length > 1\" class=\"relative\">\n                <!-- the :class line calculates margin-left for each of the 3 symbols, and gives a margin-top to symbols that arent the first -->\n                <div\n                    class=\"absolute\"\n                    :class=\"[idx == 0 ? 'symbol-0' : idx == 1 ? 'left-3' : 'left-6']\"\n                    :style=\"{ 'z-index': 3 - idx }\"\n                    v-for=\"(item, idx) in stack.slice(0, 3).reverse()\"\n                    :key=\"idx\"\n                >\n                    <span v-if=\"stack[idx].svgcode\" class=\"symbologyIcon w-28 h-28\" v-html=\"stack[idx].svgcode\"></span>\n                    <img v-else-if=\"stack[idx].imgUrl\" class=\"symbologyIcon w-28 h-28\" :src=\"stack[idx].imgUrl\" />\n                </div>\n            </div>\n\n            <!-- Only one icon to display. -->\n            <div v-else-if=\"stack.length > 0\" class=\"w-32 h-32\">\n                <div class=\"symbologyIcon\">\n                    <span v-if=\"stack[0].svgcode\" v-html=\"stack[0].svgcode\"></span>\n                    <img v-else-if=\"stack[0].imgUrl\" class=\"symbologyIcon w-full h-full\" :src=\"stack[0].imgUrl\" />\n                </div>\n            </div>\n        </div>\n        <!-- result counter -->\n        <div class=\"badge z-50 rounded-full text-white absolute h-10 w-10 p-8 inline-flex items-center justify-center\">\n            <div v-if=\"result.loaded\" class=\"px-5\">\n                {{ result.items.length }}\n            </div>\n        </div>\n    </div>\n    <div v-else class=\"inline-flex justify-center items-center relative\">\n        <div class=\"symbologyIcon h-32 w-32\">\n            <div class=\"relative animate-spin spinner h-24 w-24\"></div>\n        </div>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\n// this renders the everything needed for a symbol stack running along the left side of the panel.\n// includes symbol stacking, loading spinners, result count badge\n\nimport type { LayerInstance } from '@/api';\n\nimport { onMounted, type PropType, ref } from 'vue';\n\nconst props = defineProps({\n    layer: { type: Object as PropType<LayerInstance>, required: true },\n    result: { type: Object as any, required: true }\n});\n\nconst stack = ref<any>([]); // ref instead of reactive to maintain reactivity after promise\n\nonMounted(() => {\n    stack.value = props.layer.legend;\n});\n</script>\n\n<style lang=\"scss\" scoped>\n.badge {\n    background-color: #576870;\n    bottom: -5px;\n    right: -5px;\n    font-size: 8px;\n}\n</style>\n","<template>\n    <button\n        class=\"flex flex-grow justify-start items-center px-7 py-10 default-focus-style symbologyStackButton truncate\"\n        :class=\"selected ? 'detailsButtonSelected' : 'px-11'\"\n        @click.stop=\"\"\n        :content=\"layerName()\"\n        v-tippy=\"{ placement: 'right', sticky: true }\"\n    >\n        <SymbologyStack class=\"symbStack w-32 h-32 mr-10\" :layer=\"layer\" :result=\"result\"></SymbologyStack>\n        <div class=\"symbologyLayerName truncate\">\n            {{ layerName() }}\n        </div>\n    </button>\n</template>\n\n<script setup lang=\"ts\">\n// this constructs an entire list item in the symbology-list\n// includes the symbology-stack, as well as fancy slideout magic to show\n// layer name when moused over\n\nimport { computed } from 'vue';\nimport SymbologyStack from './symbology-stack.vue';\nimport { useDetailsStore } from '../store';\n\nimport type { DetailsItemInstance } from '../store';\n\nconst detailsStore = useDetailsStore();\nconst detailProperties = computed<{ [id: string]: DetailsItemInstance }>(() => detailsStore.properties);\n\nconst props = defineProps({\n    layer: { type: Object as any, required: true },\n    result: { type: Object as any, required: true },\n    selected: { type: Boolean, required: true }\n});\n\n/**\n * Retrieve the layer name.\n */\nconst layerName = () => {\n    const layer = props.layer;\n    if (layer && detailProperties.value[layer.id] && detailProperties.value[layer.id].name) {\n        return detailProperties.value[layer.id].name;\n    }\n    return layer?.name ?? '';\n};\n</script>\n\n<style lang=\"scss\">\n.symbStack {\n    flex: 0 0 32px;\n}\n.detailsButtonSelected {\n    border-left: 3px solid #576870;\n    padding-left: 4px !important;\n}\n.symbologyStackButton {\n    transition: background 0.3s;\n}\n.symbologyStackButton:hover {\n    background: #eee;\n}\n.symbologyLayerName {\n    flex: 1 1 auto;\n    text-align: left;\n}\n\n.symbologyStackButton:focus {\n    outline: 2px solid black;\n    z-index: 1;\n}\n</style>\n","<template>\n    <div\n        class=\"symbology-list absolute overflow-hidden z-50 p-0 w-48 bg-white text-sm inline-flex flex-col\"\n        :class=\"{ 'symbology-list-expanded': expanded }\"\n        @mouseover=\"handleMouseOver\"\n        @mouseleave=\"handleMouseLeave\"\n        @focus=\"handleItemFocus\"\n        @blur.self=\"handleItemBlur\"\n        v-focus-list\n        :content=\"t('details.layers.results.list.tooltip')\"\n        v-tippy=\"{\n            trigger: 'manual',\n            placement: 'top-start'\n        }\"\n        ref=\"el\"\n    >\n        <div class=\"flex justify-start relative\" v-for=\"(item, idx) in props.results\" :key=\"idx\">\n            <SymbologyItem\n                :key=\"item.uid\"\n                :layer=\"getLayerInfo(item.uid)\"\n                :result=\"item\"\n                :selected=\"item.uid === selectedLayer\"\n                @click=\"handleItemClick(item.uid)\"\n                v-focus-item\n            ></SymbologyItem>\n        </div>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\n// this renders the list of symbology items that run along the left side\n\nimport { ref, watch, onBeforeMount, onBeforeUnmount, onMounted } from 'vue';\nimport { useLayerStore } from '@/stores/layer';\n\nimport type { LayerInstance } from '@/api';\nimport { useI18n } from 'vue-i18n';\n\nimport SymbologyItem from './symbology-item.vue';\n\nconst { t } = useI18n();\nconst layerStore = useLayerStore();\n\nconst el = ref<Element>();\nconst blurEvent = () => {\n    (el.value as any)._tippy.hide();\n};\nconst keyupEvent = (e: Event) => {\n    const evt = e as KeyboardEvent;\n    if (evt.key === 'Tab' && el.value?.matches(':focus')) {\n        (el.value as any)._tippy.show();\n    }\n};\n\nconst emit = defineEmits(['selection-changed']);\nconst props = defineProps({\n    results: { type: Object as any, required: true },\n    selected: { type: String, required: true }\n});\n\n// Keep track of the currently selected layer index.\nconst selectedLayer = ref<string>('');\nconst watchers = ref<Array<Function>>([]);\n\n// Expanded is true if the sidebar is expanded. Hovering is true only if the cursor is currently over the sidebar.\nconst expanded = ref<Boolean>(false);\nconst hovering = ref<Boolean>(false);\n\n/**\n * Return the LayerInstance that cooresponds with the provided UID.\n * @param uid the UID of the layer to look up.\n */\nconst getLayerInfo = (uid: string) => {\n    let layer: LayerInstance | undefined = layerStore.getLayerByUid(uid);\n    return layer;\n};\n\n/**\n * Handles when a user clicks on an item.\n * @param uid the UID of the clicked layer\n */\nconst handleItemClick = (uid: string) => {\n    selectedLayer.value = uid;\n    emit('selection-changed', uid);\n\n    // Close the sidebar when an item is clicked.\n    expanded.value = false;\n};\n\n/**\n * Handles when a user moves their mouse over the sidebar.\n */\nconst handleMouseOver = () => {\n    if (!hovering.value) {\n        // If not already hovering, delay expansion of the sidebar for 500ms.\n        setTimeout(() => {\n            expanded.value = hovering.value;\n        }, 500);\n    }\n\n    hovering.value = true;\n};\n\n/**\n * Handles when the user moves their mouse away from the sidebar.\n */\nconst handleMouseLeave = () => {\n    expanded.value = hovering.value = false;\n};\n\n/**\n * Activates when an item in the list is focused.\n */\nconst handleItemFocus = () => {\n    if (!hovering.value) {\n        expanded.value = true;\n    }\n    hovering.value = true;\n};\n\n/**\n * Activates when an item in the list is unfocused.\n */\nconst handleItemBlur = () => {\n    expanded.value = hovering.value = false;\n};\n\nonBeforeMount(() => {\n    // keep track of this watcher because it needs to be removed when this component is unmounted\n    watchers.value.push(\n        watch(props, () => {\n            // Something has changed, so re-fetch the icon.\n            selectedLayer.value = props.selected;\n        })\n    );\n});\n\nonMounted(() => {\n    el.value?.addEventListener('blur', blurEvent);\n    el.value?.addEventListener('keyup', keyupEvent);\n});\n\nonBeforeUnmount(() => {\n    watchers.value.forEach(unwatch => unwatch());\n\n    el.value?.removeEventListener('blur', blurEvent);\n    el.value?.removeEventListener('keyup', keyupEvent);\n});\n</script>\n\n<style lang=\"scss\">\n.symbology-list {\n    /** fun magic to get the bar to take up the entire height */\n    height: auto;\n    top: 0px;\n    bottom: -8px;\n\n    border-right: 1px solid #eee;\n    box-shadow: -1px 0px 5px rgba(0, 0, 0, 0.5);\n\n    margin: -8px;\n    margin-bottom: 0px;\n\n    transition: all 0.3s cubic-bezier(0.35, 0, 0.25, 1);\n}\n.symbology-list-expanded {\n    width: 70% !important;\n    overflow-y: auto !important;\n}\n</style>\n","<template>\n    <div>\n        <div\n            class=\"p-5 pl-3 flex justify-end flex-wrap even:bg-gray-300\"\n            v-for=\"(val, name, itemIdx) in itemData()\"\n            :key=\"itemIdx\"\n        >\n            <span class=\"inline font-bold\">{{ val.alias }}</span>\n            <span class=\"flex-auto\"></span>\n            <span class=\"inline\" v-html=\"formatValues(val.value, val.alias, val.type)\"></span>\n        </div>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { inject } from 'vue';\nimport type { PropType } from 'vue';\nimport type { FieldDefinition } from '@/geo/api';\nimport type { DetailsFieldItem } from '@/fixtures/details/store';\nimport linkifyHtml from 'linkify-html';\nimport type { IdentifyItem, InstanceAPI } from '@/api';\nimport { useI18n } from 'vue-i18n';\n\nconst { t } = useI18n();\n\nconst iApi = inject<InstanceAPI>('iApi');\n\nconst props = defineProps({\n    fixtureFields: {\n        type: Object as PropType<Array<DetailsFieldItem>>,\n        required: false\n    },\n    fields: {\n        type: Object as PropType<Array<FieldDefinition>>,\n        required: true\n    },\n    identifyData: {\n        type: Object as PropType<IdentifyItem>,\n        required: true\n    }\n});\n\nconst findAndDelete = (fields: FieldDefinition[], propertyType: 'type' | 'name', property: string, helper: any) => {\n    const field = fields.find(f => f[propertyType].toLowerCase() === property.toLowerCase());\n\n    // If the field is found, delete it from the helper object\n    if (field) delete helper[field.name];\n};\n\n/**\n * Constructs and returns a metadata mapping of what we actually want to display.\n * Key: field name\n * Value: object with these props\n * - value (formatted)\n * - alias (display text for field. See aliases.name below)\n * - type (field data type)\n */\nconst itemData = () => {\n    const clonePayload = Object.assign({}, props.identifyData.data);\n\n    // Remove any fields of type geometry\n    findAndDelete(props.fields, 'type', 'geometry', clonePayload);\n\n    if (!iApi?.ui.exposeOids) {\n        // check global oid flag\n        findAndDelete(props.fields, 'type', 'oid', clonePayload);\n    }\n\n    if (!iApi?.ui.exposeMeasurements) {\n        // check global measurements flag\n        findAndDelete(props.fields, 'name', 'shape_length', clonePayload);\n        findAndDelete(props.fields, 'name', 'shape_area', clonePayload);\n    }\n\n    /**\n     * Builds up a mapping of all LAYER field names --> data about field\n     * - name (display name. Priority order: detail fixture config alias, layer alias, layer field)\n     * - type (field data type)\n     * - visible (if should be displayed; detail fixture config option)\n     */\n    const fieldsMetadata: any = {};\n    props.fields.forEach(field => {\n        // Check to see if this field is being overwritten in the fixture config.\n        const checkField = props.fixtureFields?.find(item => field.name === item.field);\n\n        fieldsMetadata[field.name] = {\n            name: checkField?.alias || field.alias || field.name,\n            type: field.type,\n            visible: checkField?.visible ?? true\n        }; // use the key name if alias is not defined. Default visibility to true if it's not defined.\n    });\n\n    /**\n     * Builds up a mapping of valid PAYLOAD attribute field names --> data about that attribute\n     * - value (formatted)\n     * - alias (display text for field. See aliases.name below)\n     * - type (field data type)\n     *\n     * Invalid fields are: ones the system is hiding, and ones that don't exist on the layer\n     */\n    const displayMetadata: any = {};\n\n    // we iterate on the clone since that is what had the field removals.\n    Object.keys(clonePayload).forEach(key => {\n        const fieldMD = fieldsMetadata[key];\n        if (fieldMD && fieldMD.visible) {\n            // field exists in layer, and should be shown\n\n            const cloneValue = clonePayload[key];\n\n            displayMetadata[key] = {\n                value: typeof cloneValue === 'number' ? iApi?.ui.formatNumber(cloneValue) : cloneValue,\n                alias: fieldMD.name,\n                type: fieldMD.type\n            };\n        }\n    });\n\n    for (const [key] of Object.entries(displayMetadata)) {\n        // only replace html special chars if string represents plain text\n        if (iApi!.ui.isPlainText(displayMetadata[key].value)) {\n            displayMetadata[key].value = iApi!.ui.escapeHtml(displayMetadata[key].value);\n        }\n    }\n\n    return displayMetadata;\n};\n\n// render value based on type\nconst formatValues = (html: string, alias: string, type: string): string => {\n    switch (type) {\n        case 'date':\n            return makeDate(html);\n        default:\n            return makeHtmlLink(html, alias);\n    }\n};\n\n// make links look like links and work like links\nconst makeHtmlLink = (html: string, alias: string): string => {\n    if (!html) {\n        return html;\n    }\n\n    // Check to see if url is a valid image / data url based on extension type or format\n    if (\n        !!html.trim().match(/\\.(jpeg|jpg|gif|png)$/) ||\n        !!html.trim().match(\n            /^\\s*data:([a-z]+\\/[a-z]+(;[a-z\\-]+\\=[a-z\\-]+)?)?(;base64)?,[a-z0-9\\!\\$\\&\\'\\,\\(\\)\\*\\+\\,\\;\\=\\-\\.\\_\\~\\:\\@\\/\\?\\%\\s]*\\s*$/i //eslint-disable-line\n        )\n    ) {\n        return `<img src=\"${html}\" alt=\"${t('details.item.alert.defaultAltText', { alias: alias })}\" />`;\n    }\n\n    const classes = 'underline text-blue-700 break-all';\n    const div = document.createElement('div');\n    div.innerHTML = html.trim();\n\n    // check if the html string is just an <a> tag\n    if (div.firstElementChild?.tagName == 'A') {\n        div.firstElementChild.className = classes;\n        return div.innerHTML;\n    } else {\n        // otherwise, look for any valid links\n        const options = {\n            className: classes,\n            target: '_blank',\n            validate: {\n                url: (value: string) => /^https?:\\/\\//.test(value) // only links that begin with a protocol will be hyperlinked\n            }\n        };\n        return linkifyHtml(html, options);\n    }\n};\n\n// convert timestamps into date strings that match the datagrid\nconst makeDate = (html: string): string => {\n    // the value is saved as a string, so attempt to convert it to a number\n    const numericDate = parseInt(html);\n\n    // if the date can't be converted to a number, then it may already be formatted. Display it as it is.\n    if (isNaN(numericDate)) {\n        return html;\n    }\n\n    // Return in YYYY-MM-DD format\n    const formattedDate = new Date(numericDate);\n    return formattedDate.toISOString().split('T')[0];\n};\n</script>\n\n<style lang=\"scss\"></style>\n","<template>\n    <div\n        class=\"whitespace-pre-wrap break-words h-full overflow-auto\"\n        v-if=\"identifyData\"\n        v-html=\"identifyData.data.data ?? identifyData.data\"\n    ></div>\n    <div v-else>{{ t('details.layers.results.empty') }}</div>\n</template>\n\n<script setup lang=\"ts\">\nimport type { PropType } from 'vue';\nimport type { IdentifyItem } from '@/api';\nimport { useI18n } from 'vue-i18n';\n\nconst { t } = useI18n();\n\ndefineProps({\n    identifyData: {\n        type: Object as PropType<IdentifyItem>,\n        required: true\n    }\n});\n</script>\n\n<style lang=\"scss\"></style>\n","<template>\n    <!-- Header including icon, name, zoom button -->\n    <div class=\"relative flex flex-grow truncate\">\n        <div class=\"flex flex-grow items-center truncate\" v-if=\"supportsFeatures\">\n            <!-- display symbol if it has loaded, otherwise display a loading spinner -->\n            <div class=\"flex p-8 items-center\">\n                <span v-if=\"data.loaded && icon\" class=\"flex-none symbologyIcon\" v-html=\"icon\"></span>\n                <div class=\"symbologyIcon p-6\" v-else>\n                    <div class=\"animate-spin spinner h-20 w-20\"></div>\n                </div>\n            </div>\n\n            <!-- display name of the data point -->\n            <span\n                v-if=\"data.loaded\"\n                class=\"pl-3 text-left flex-grow itemName\"\n                :content=\"itemName\"\n                v-html=\"makeHtmlLink(itemName)\"\n                v-truncate=\"{\n                    options: { placement: 'right' }\n                }\"\n                :tabindex=\"inList ? -1 : 0\"\n            ></span>\n            <div v-else class=\"flex p-6 flex-grow\">\n                {{ t('details.loading') }}\n            </div>\n\n            <!-- zoom icon -->\n            <span class=\"zoomButton text-center p-3\" v-if=\"data.loaded\"\n                ><button\n                    type=\"button\"\n                    :content=\"t(`details.item.zoom${zoomStatus === 'none' ? '' : `.${zoomStatus}`}`)\"\n                    v-tippy=\"{ placement: 'bottom' }\"\n                    :aria-label=\"t(`grid.cells.zoom${zoomStatus === 'none' ? '' : `.${zoomStatus}`}`)\"\n                    ref=\"zoomButton\"\n                    @click=\"\n                        (e: MouseEvent) => {\n                            e.stopPropagation();\n                            zoomToFeature();\n                        }\n                    \"\n                    class=\"text-gray-600 w-24 h-24 p-2 flex justify-center items-center\"\n                    v-if=\"isMapLayer\"\n                >\n                    <div v-if=\"zoomStatus === 'zooming'\" class=\"m-auto animate-spin spinner h-20 w-20\"></div>\n                    <svg\n                        v-else-if=\"zoomStatus === 'zoomed'\"\n                        xmlns=\"http://www.w3.org/2000/svg\"\n                        fill=\"none\"\n                        viewBox=\"0 0 24 24\"\n                        stroke-width=\"1.5\"\n                        stroke=\"green\"\n                        class=\"m-auto w-20 h-20\"\n                    >\n                        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M4.5 12.75l6 6 9-13.5\" />\n                    </svg>\n                    <svg\n                        v-else-if=\"zoomStatus === 'error'\"\n                        xmlns=\"http://www.w3.org/2000/svg\"\n                        fill=\"none\"\n                        viewBox=\"0 0 24 24\"\n                        stroke-width=\"1.5\"\n                        stroke=\"red\"\n                        class=\"m-auto w-20 h-20\"\n                    >\n                        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M6 18L18 6M6 6l12 12\" />\n                    </svg>\n                    <span v-else v-html=\"iApi.ui.getZoomIcon()\"></span></button\n            ></span>\n        </div>\n    </div>\n\n    <!-- Details Component -->\n    <component\n        v-if=\"!!open\"\n        :is=\"detailsTemplate\"\n        :identifyData=\"data\"\n        :fields=\"fieldsList\"\n        :fixtureFields=\"fixtureFields\"\n        class=\"p-8\"\n    ></component>\n</template>\n\n<script setup lang=\"ts\">\n// handles the rendering of a single result item.\n// has support for the different supported formats, and applying vue templates\n\nimport { useLayerStore } from '@/stores/layer';\nimport { GeometryType, LayerType } from '@/geo/api';\nimport { DetailsItemInstance, useDetailsStore, type DetailsFieldItem } from '../store';\nimport { computed, ref, inject, onBeforeMount, onBeforeUnmount, watch } from 'vue';\nimport { useI18n } from 'vue-i18n';\nimport linkifyHtml from 'linkify-html';\n\nimport ESRIDefault from '../templates/esri-default.vue';\nimport HTMLDefault from '../templates/html-default.vue';\n\nimport type { FieldDefinition } from '@/geo/api';\nimport type { IdentifyItem, InstanceAPI, LayerInstance } from '@/api';\nimport type { PropType } from 'vue';\n\nconst layerStore = useLayerStore();\nconst props = defineProps({\n    uid: { type: String, required: true },\n    data: { type: Object as PropType<IdentifyItem>, required: true },\n    open: { type: Boolean, required: false },\n    inList: { type: Boolean, required: false }\n});\n\nconst iApi = inject<InstanceAPI>('iApi')!;\nconst watchers = ref<Array<Function>>([]);\nconst detailsStore = useDetailsStore();\nconst { t } = useI18n();\n\n/**\n * Icon string to display for this item\n */\nconst icon = ref<string>('');\nconst zoomStatus = ref<'zooming' | 'zoomed' | 'error' | 'none'>('none');\nconst zoomButton = ref<HTMLElement>();\n\n/**\n * Return the LayerInstance that cooresponds with the UID provided in props.\n */\nconst getLayerInfo = () => {\n    let layer: LayerInstance | undefined = layerStore.getLayerByUid(props.uid);\n    return layer;\n};\n\nconst detailProperties = computed<{ [id: string]: DetailsItemInstance }>(() => detailsStore.properties);\n\nconst defaultTemplates = computed<{ [type: string]: string }>(() => detailsStore.defaultTemplates);\n\nconst supportsFeatures = computed<Boolean>(() => {\n    return getLayerInfo()?.supportsFeatures ?? false;\n});\n\nconst isMapLayer = computed<Boolean>(() => {\n    return getLayerInfo()?.mapLayer ?? false;\n});\n\n/**\n * Determine the name of the data point.\n */\nconst itemName = computed<string>(() => {\n    const nameField = getLayerInfo()?.nameField;\n    let returnValue = nameField && props.data.loaded ? props.data.data[nameField] : iApi.$i18n.t('details.items.title');\n\n    // only replace html special chars if string represents plain text\n    if (iApi!.ui.isPlainText(returnValue)) {\n        returnValue = iApi!.ui.escapeHtml(returnValue);\n    }\n\n    return returnValue;\n});\n\n// make links look like links and work like links\nconst makeHtmlLink = (html: any): any => {\n    if (typeof html === 'string') {\n        const classes = 'underline text-blue-700 break-all';\n        const div = document.createElement('div');\n        div.innerHTML = html.trim();\n\n        // check if the html string is just an <a> tag\n        if (div.firstElementChild?.tagName == 'A') {\n            div.firstElementChild.className = classes;\n            return div.innerHTML;\n        } else {\n            // otherwise, look for any valid links\n            const options = {\n                className: classes,\n                target: '_blank',\n                validate: {\n                    url: (value: string) => /^https?:\\/\\//.test(value) // only links that begin with a protocol will be hyperlinked\n                }\n            };\n            return linkifyHtml(html, options);\n        }\n    }\n    return html;\n};\n\n/**\n * Called whenever the displayed item changes\n */\nconst itemChanged = () => {\n    updateZoomStatus('none');\n    if (props.data.loaded) {\n        fetchIcon();\n    } else {\n        // request any details download and wait.\n        // innards of .load() are smart enough not to double-request.\n        // TODO revist when we implement pagination on the result-list.vue list mode.\n        //      if it only renders what is on current page, then only visible items should\n        //      hit this and make load requests. But need to ensure -- hitting everything\n        //      will cause issue #2156\n\n        props.data.load().then(() => {\n            fetchIcon();\n        });\n\n        // TODO do we need some type of updateAlert that says the screen is now\n        //      in a loading state?\n    }\n};\n\n/**\n * Get the icon of the identify result.\n */\nconst fetchIcon = () => {\n    icon.value = '';\n    if (!(props.data && props.data.loaded)) {\n        return;\n    }\n\n    const layer: LayerInstance | undefined = getLayerInfo();\n\n    if (layer === undefined) {\n        console.warn(`could not find layer for uid ${props.uid} during icon lookup`);\n        return;\n    }\n\n    if (layer.supportsFeatures) {\n        const oidField = layer.oidField;\n\n        layer.getIcon(props.data.data[oidField]).then((value: string) => {\n            icon.value = value;\n        });\n    }\n};\n\n/**\n * Fetch the correct details template.\n */\nconst detailsTemplate = computed(() => {\n    const layer: LayerInstance | undefined = getLayerInfo();\n\n    // If there is a custom template binding for this layer in the store, then\n    // return its name.\n    if (layer && detailProperties.value[layer.id] && detailProperties.value[layer.id].template) {\n        return detailProperties.value[layer.id].template;\n    }\n\n    // If nothing is found, use a default template from config\n    if (defaultTemplates.value && defaultTemplates.value[props.data.format]) {\n        return defaultTemplates.value[props.data.format];\n    }\n\n    // If default template is not specified, use our default template\n    if (!supportsFeatures.value) {\n        return HTMLDefault;\n    } else {\n        return ESRIDefault;\n    }\n});\n\n/**\n * Retrieve layer fields.\n */\nconst fieldsList = computed<Array<FieldDefinition>>(() => {\n    // wms layers do not support fields\n    if (!supportsFeatures.value) {\n        return [];\n    }\n    const layer: LayerInstance | undefined = getLayerInfo();\n    const fields = layer?.fields;\n    return fields || [];\n});\n\n/**\n * Check for any field overrides.\n */\nconst fixtureFields = computed<DetailsFieldItem[] | undefined>(() => {\n    const layer: LayerInstance | undefined = getLayerInfo();\n\n    if (layer && detailProperties.value[layer.id] && detailProperties.value[layer.id].fields) {\n        return detailProperties.value[layer.id].fields;\n    }\n    return undefined;\n});\n\nconst updateZoomStatus = (value: 'zooming' | 'zoomed' | 'error' | 'none') => {\n    if (value === 'zoomed' || value === 'error') {\n        setTimeout(() => {\n            zoomStatus.value = value;\n            (zoomButton.value as any)?._tippy.show();\n            setTimeout(() => {\n                (zoomButton.value as any)?._tippy.hide();\n                zoomStatus.value = 'none';\n            }, 3000);\n        }, 300);\n    } else {\n        zoomStatus.value = value;\n    }\n};\n\n/**\n * Zoom to feature on the map\n */\nconst zoomToFeature = () => {\n    if (zoomStatus.value !== 'none') {\n        return;\n    }\n\n    updateZoomStatus('zooming');\n    const layer: LayerInstance | undefined = getLayerInfo();\n\n    if (layer === undefined || !layer.isLoaded) {\n        console.warn(`Could not find layer for uid ${props.uid} during zoom geometry lookup`);\n        updateZoomStatus('error');\n        return;\n    }\n\n    if (!props.data.loaded) {\n        console.warn('Details zoomToFeature call on item that is still loading. Should be impossible, alert the devs.');\n        updateZoomStatus('error');\n        return;\n    }\n\n    const oid = props.data.data[layer.oidField];\n    const zoomUsingGraphic = () => {\n        const opts = { getGeom: true };\n        layer\n            .getGraphic(oid, opts)\n            .then(g => {\n                if (g.geometry.invalid()) {\n                    console.error(`Could not find graphic for objectid ${oid}`);\n                    updateZoomStatus('error');\n                } else {\n                    iApi.geo.map.zoomMapTo(g.geometry);\n                    updateZoomStatus('zoomed');\n                    iApi.updateAlert(iApi.$i18n.t('details.item.alert.zoom'));\n                }\n            })\n            .catch(() => {\n                updateZoomStatus('error');\n            });\n    };\n\n    if (layer.layerType === LayerType.FEATURE && layer.geomType !== GeometryType.POINT) {\n        layer\n            .getGraphicExtent(oid)\n            .then(e => {\n                iApi.geo.map.zoomMapTo(e);\n                updateZoomStatus('zoomed');\n                iApi.updateAlert(iApi.$i18n.t('details.item.alert.zoom'));\n            })\n            .catch(() => {\n                zoomUsingGraphic();\n            });\n    } else {\n        zoomUsingGraphic();\n    }\n};\n\nonBeforeMount(() => {\n    // keep track of this watcher because it needs to be removed when this component is unmounted\n    watchers.value.push(\n        watch(\n            props,\n            () => {\n                // Something has changed, so re-fetch the icon.\n                itemChanged();\n            },\n            {\n                deep: false,\n                immediate: true\n            }\n        )\n    );\n});\n\nonBeforeUnmount(() => {\n    watchers.value.forEach(unwatch => unwatch());\n});\n</script>\n\n<style lang=\"scss\" scoped></style>\n","<template>\n    <div\n        class=\"detailsContent relative flex flex-col flex-grow pl-5\"\n        :style=\"results.length > 1 ? { 'margin-left': '42px' } : ''\"\n        v-if=\"isLayerResultLoaded && activeGreedy === 0\"\n    >\n        <!-- layer name -->\n        <h1\n            class=\"layerName w-full flex-grow p-5 pb-8 font-bold truncate\"\n            v-if=\"layerExists\"\n            v-truncate=\"{ options: { placement: 'top-start' } }\"\n            tabIndex=\"0\"\n        >\n            {{ layerName }}\n        </h1>\n\n        <!-- highlight toggle -->\n        <div class=\"p-8 mb-8 bg-gray-100 flex justify-between\" v-if=\"canHighlight\">\n            <label for=\"toggle\">{{ t('details.togglehilight.title') }}</label>\n            <Toggle\n                :config=\"{\n                    value: hilightToggle,\n                    disabled: false\n                }\"\n                @toggled=\"onHilightToggle\"\n            ></Toggle>\n        </div>\n\n        <!-- paginator and list button for multiple features -->\n        <div class=\"flex flex-col justify-between p-8 mb-8 bg-gray-100\" v-if=\"showPaginator\">\n            <div class=\"flex\">\n                <button\n                    v-if=\"!showList\"\n                    type=\"button\"\n                    class=\"px-8 font-bold hover:bg-gray-200 focus:bg-gray-200\"\n                    :aria-label=\"t('details.item.see.list')\"\n                    @click=\"clickShowList()\"\n                >\n                    {{ t('details.item.see.list') }}\n                </button>\n                <div class=\"flex ml-auto bg-gray-200 py-8 items-center\" :class=\"{ 'w-full': showList }\">\n                    <button\n                        type=\"button\"\n                        :content=\"t(showList ? 'details.items.previous' : 'details.item.previous.item')\"\n                        v-tippy=\"{ placement: 'top' }\"\n                        @click=\"advanceItemIndex(-1)\"\n                        class=\"mx-2 opacity-60 hover:opacity-90 disabled:opacity-30 disabled:cursor-default\"\n                        :aria-label=\"t(showList ? 'details.items.previous' : 'details.item.previous.item')\"\n                        :disabled=\"currentIdx === 0\"\n                    >\n                        <svg height=\"24\" width=\"24\" viewBox=\"0 0 23 23\">\n                            <g>\n                                <path d=\"M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z\" />\n                            </g>\n                        </svg>\n                    </button>\n                    <span class=\"px-3 text-center flex-grow\">\n                        {{\n                            showList\n                                ? t('details.items.range', [\n                                      currentIdx + 1,\n                                      Math.min(endIdx, getLayerIdentifyItems().length),\n                                      getLayerIdentifyItems().length\n                                  ])\n                                : t('details.item.count', [currentIdx + 1, getLayerIdentifyItems().length])\n                        }}\n                    </span>\n                    <button\n                        type=\"button\"\n                        :content=\"t(showList ? 'details.items.next' : 'details.item.next.item')\"\n                        v-tippy=\"{ placement: 'top' }\"\n                        @click=\"advanceItemIndex(1)\"\n                        class=\"mx-2 rotate-180 opacity-60 hover:opacity-90 disabled:opacity-30 disabled:cursor-default\"\n                        :aria-label=\"t(showList ? 'details.items.next' : 'details.item.next.item')\"\n                        :disabled=\"\n                            (!showList && currentIdx === getLayerIdentifyItems().length - 1) ||\n                            (showList && endIdx >= getLayerIdentifyItems().length)\n                        \"\n                    >\n                        <svg height=\"24\" width=\"24\" viewBox=\"0 0 23 23\">\n                            <g>\n                                <path d=\"M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z\" />\n                            </g>\n                        </svg>\n                    </button>\n                </div>\n            </div>\n        </div>\n\n        <!-- details result, or result list -->\n        <div v-if=\"layerExists\">\n            <div v-if=\"getLayerIdentifyItems().length > 0\">\n                <div\n                    v-if=\"showList\"\n                    class=\"flex flex-col\"\n                    v-focus-list\n                    :content=\"t('details.layers.results.list.tooltip')\"\n                    v-tippy=\"{\n                        trigger: 'manual',\n                        placement: 'top-start'\n                    }\"\n                    ref=\"el\"\n                >\n                    <button\n                        class=\"flex flex-grow truncate default-focus-style hover:bg-gray-200\"\n                        v-for=\"(item, idx) in getLayerIdentifyItems().slice(currentIdx, endIdx)\"\n                        :key=\"idx\"\n                        @click=\"clickListItem(currentIdx + idx)\"\n                        v-focus-item=\"'show-truncate'\"\n                    >\n                        <ResultItem :data=\"item\" :uid=\"uid\" :open=\"false\" :in-list=\"true\"></ResultItem>\n                    </button>\n                </div>\n                <ResultItem :data=\"currentIdentifyItem\" :uid=\"uid\" :open=\"true\" :in-list=\"false\" v-else></ResultItem>\n            </div>\n            <div class=\"text-center\" v-else>\n                {{ t('details.layers.results.empty.currentLayer') }}\n            </div>\n        </div>\n        <!-- layer does not exist anymore, show no data text -->\n        <div v-else class=\"p-5\">\n            {{ t('details.item.no.data') }}\n        </div>\n    </div>\n\n    <!-- identified item is loading -->\n    <div v-else class=\"flex justify-center py-10 items-center\" :class=\"results.length > 1 ? 'ml-42' : ''\">\n        <span class=\"animate-spin spinner h-20 w-20 px-5 mr-8\"></span>\n        {{ t('details.item.loading') }}\n    </div>\n</template>\n\n<script setup lang=\"ts\">\n// acts as the result container for a single layer's result set. Includes header controls,\n// and will render the list view if we're in that mode. If in single detail mode, it just\n// inserts a result-item under the header.\n\nimport { useLayerStore } from '@/stores/layer';\nimport { useI18n } from 'vue-i18n';\nimport type { DetailsAPI } from '../api/details';\nimport ResultItem from './result-item.vue';\nimport Toggle from '../../../components/controls/toggle-switch-control.vue';\n\nimport { GlobalEvents } from '@/api';\nimport type { IdentifyItem, IdentifyResult, InstanceAPI, LayerInstance, PanelInstance } from '@/api';\n\nimport type { BasemapChange } from '@/geo/api';\n\nimport { computed, inject, onMounted, onBeforeMount, onBeforeUnmount, ref, watch } from 'vue';\nimport type { PropType } from 'vue';\n\nimport { useDetailsStore } from '../store';\nimport type { DetailsItemInstance } from '../store';\n\nconst el = ref<Element>();\nconst blurEvent = () => {\n    (el.value as any)._tippy.hide();\n};\nconst keyupEvent = (e: Event) => {\n    const evt = e as KeyboardEvent;\n    if (evt.key === 'Tab' && el.value?.matches(':focus')) {\n        (el.value as any)._tippy.show();\n    }\n};\n\nconst iApi = inject<InstanceAPI>('iApi')!;\n\nconst detailsStore = useDetailsStore();\nconst layerStore = useLayerStore();\nconst props = defineProps({\n    uid: { type: String, required: true },\n    results: { type: Object as PropType<Array<IdentifyResult>>, required: true }\n});\nconst { t } = useI18n();\n\n/**\n * If we could find the bound layer in our instance\n */\nconst layerExists = ref<Boolean>(false);\n\n/**\n * Details fixture\n */\nconst detailsFixture = ref<DetailsAPI>(iApi.fixture.get('details'));\n\n/**\n * Value of the onscreen highlighter toggle control\n */\nconst hilightToggle = ref<boolean>(true);\n\n/**\n * If we are displaying list view or single item view\n */\nconst showList = ref<boolean>(false);\n\n/**\n * Index of the item we are displaying within the result's item array\n * Persists in list view\n */\nconst currentIdx = ref<number>(0);\n\n/**\n * Number of items to display at once in list view\n */\nconst itemsPerPage = ref<number>(20);\n\nconst handlers = ref<Array<string>>([]);\nconst watchers = ref<Array<Function>>([]);\n\nconst activeGreedy = computed<number>(() => detailsStore.activeGreedy);\nconst detailProperties = computed<{ [id: string]: DetailsItemInstance }>(() => detailsStore.properties);\nconst endIdx = computed<number>(() => currentIdx.value + itemsPerPage.value);\n\n/**\n * Return the LayerInstance that cooresponds with the UID provided in props.\n */\nconst getBoundLayer = () => {\n    return layerStore.getLayerByUid(props.uid);\n};\n\n/**\n * Find the layer result object for the bound layer, if exists\n */\nconst getBoundLayerResult = (): IdentifyResult | undefined => {\n    return props.results.find(layerIR => {\n        return layerIR.uid === props.uid;\n    });\n};\n\n/**\n * Computed property that returns true if the layer's overall identify result has loaded.\n */\nconst isLayerResultLoaded = computed<Boolean>(() => {\n    const results = getBoundLayerResult();\n    return results?.loaded ?? false;\n});\n\nconst itemRequestTime = computed<Number | undefined>(() => {\n    const results = getBoundLayerResult();\n    return results?.requestTime;\n});\n\nconst showPaginator = computed<boolean>(\n    () =>\n        layerExists.value &&\n        ((!showList.value && getLayerIdentifyItems().length > 1) ||\n            (showList.value && getLayerIdentifyItems().length > itemsPerPage.value))\n);\n\nconst layerName = computed<string>(() => {\n    const layer = getBoundLayer();\n\n    if (layer && detailProperties.value[layer.id] && detailProperties.value[layer.id].name) {\n        return detailProperties.value[layer.id].name;\n    }\n    return layer?.name ?? '';\n});\n\n/**\n * Lets us watch() the uid\n */\nconst uidCompute = computed<string>(() => {\n    return props.uid;\n});\n\n/**\n * Retrieves the identify items that belong to the layer currently bound to this list.\n * If there are no results, returns an empty array.\n */\nconst getLayerIdentifyItems = () => {\n    const results = getBoundLayerResult();\n\n    return results ? results.items : [];\n};\n\n/**\n * Computed property that returns the identify item currently being viewed.\n * In list mode, this returns last item viewed in detail view (defaults to first).\n * If no results, returns undefined\n */\nconst currentIdentifyItem = computed<IdentifyItem>(() => {\n    return getLayerIdentifyItems()[currentIdx.value];\n});\n\n/**\n * Computed property that indicates if highlighting is a possibility\n */\nconst canHighlight = computed<Boolean>(() => {\n    if (detailsFixture.value.hasHilighter()) {\n        const layer = getBoundLayer();\n        if (layer) {\n            return layer.mapLayer && layer.supportsFeatures;\n        }\n    }\n    return false;\n});\n\n/**\n * Event handler for the UI highlight toggle. Toggles highlight on data points.\n * @param value the value to assign the highlight\n */\nconst onHilightToggle = (value: boolean) => {\n    // change control state, remember in store, update any highlighting\n\n    hilightToggle.value = value;\n    detailsStore.hilightToggle = value;\n    updateHighlight();\n};\n\n/**\n * Initialize the details screen\n */\nconst initDetails = () => {\n    const layer = getBoundLayer();\n\n    currentIdx.value = currentIdx.value ?? 0;\n    hilightToggle.value = detailsStore.hilightToggle ?? hilightToggle.value;\n    showList.value = false;\n\n    // could not find this layer, so mark this result as invalid\n    // this handles the case where user minimized item screen -> deletes layer -> opens item screen again\n    layerExists.value = !!layer;\n\n    updateHighlight();\n};\n\n/**\n * Advance the item index by direction (an integer). Singular in detail mode, by a page in list mode\n */\nconst advanceItemIndex = (direction: number) => {\n    if (showList.value) {\n        currentIdx.value += direction * itemsPerPage.value;\n        updateHighlight();\n    } else {\n        currentIdx.value += direction;\n    }\n};\n\n/**\n * Updates the highlighter when something changes (panel minimized, opened, change in selected result, etc.)\n */\nconst updateHighlight = () => {\n    /*\n    Dev notes for paths that hit this method, since its a bit spicey.\n    currentIdentifyItem watcher -> initDetails : handles changes in the details view of an item.\n        includes initial load, layer change, item pagination. Anything that isn't in list mode.\n    uidCompute watcher : handles a new layer being selected and we are in list mode.\n    advanceItemIndex : handles pagination change when in list mode\n    onHilightToggle : handles user mashing the toggler button\n    clickShowList : handles user going from detail view to list view on same layer\n    clickListItem : handles weird scenario where user clicks first (top) item in list view to switch to its detail view\n    BASEMAP_CHANGE event : handles re-applying hilight if schema changed\n    */\n\n    const resultItems = getLayerIdentifyItems();\n\n    if (hilightToggle.value && isLayerResultLoaded.value && resultItems.length > 0 && canHighlight.value) {\n        // we are highlighting, and there is something that could be hilighted.\n        // the hilightDetailsItems will handle the waiting for items to finish loading, as well as ensuring\n        // that any stale loads will not be drawn / removed when users spam their highlights real fast.\n\n        if (showList.value) {\n            // highlight what is on current page of the list.\n            detailsFixture.value.hilightDetailsItems(resultItems.slice(currentIdx.value, endIdx.value), props.uid);\n        } else {\n            // highlight current item being displayed.\n            // being extra careful just incase our index went beyond the array bounds\n            const currItem = resultItems[currentIdx.value];\n            if (currItem) {\n                detailsFixture.value.hilightDetailsItems([currItem], props.uid);\n            }\n        }\n    } else {\n        // nothing to hilight. This ensures any old details highlights get wiped\n        detailsFixture.value.removeDetailsHilight();\n    }\n};\n\n/**\n * Called when the `Show List` button is pressed. Enables list view and sets highlight to show\n * all items in the list.\n */\nconst clickShowList = () => {\n    showList.value = true;\n\n    currentIdx.value = Math.floor(currentIdx.value / itemsPerPage.value) * itemsPerPage.value;\n    updateHighlight();\n};\n\n/**\n * Clean up for when the details screen is closed.\n */\nconst detailsClosed = () => {\n    detailsFixture.value.removeDetailsHilight();\n\n    // (JR) commenting this out. if user turns off toggle, it shouldnt reset back to on when screen closes.\n    // detailsStore.hilightToggle = true;\n};\n\n/**\n * Clean up for when the details screen is minimized.\n */\nconst detailsMinimized = () => {\n    detailsFixture.value.removeDetailsHilight();\n};\n\n/**\n * Called when an item in the list is clicked. Disables list view and updates highlight.\n * @param idx the index of the point that was clicked.\n */\nconst clickListItem = (idx: number) => {\n    const secretIdx = currentIdx.value;\n    currentIdx.value = idx;\n    showList.value = false;\n    if (secretIdx === idx) {\n        // we clicked on the row that currentIdx was secretly tracking.\n        // as such, the watcher on the current item won't trigger, so\n        // need to update the highlight\n        updateHighlight();\n    }\n};\n\nonMounted(() => {\n    // close this panel if layer is removed\n    handlers.value.push(\n        iApi.event.on(GlobalEvents.LAYER_REMOVE, (removedLayer: LayerInstance) => {\n            const detailsPanel = iApi.panel.get('details');\n            if (props.uid === removedLayer.uid && !!detailsPanel) {\n                detailsPanel.close();\n            }\n        })\n    );\n\n    handlers.value.push(\n        iApi.event.on(GlobalEvents.PANEL_CLOSED, (panel: PanelInstance) => {\n            if (panel.id === 'details') {\n                detailsClosed();\n            }\n        })\n    );\n\n    handlers.value.push(\n        iApi.event.on(GlobalEvents.PANEL_MINIMIZED, (panel: PanelInstance) => {\n            if (panel.id === 'details') {\n                detailsMinimized();\n            }\n        })\n    );\n\n    handlers.value.push(\n        iApi.event.on(GlobalEvents.MAP_BASEMAPCHANGE, (payload: BasemapChange) => {\n            if (hilightToggle.value && payload.schemaChanged) {\n                // will just wipe and re-apply the highlight\n                updateHighlight();\n            }\n        })\n    );\n\n    el.value?.addEventListener('blur', blurEvent);\n    el.value?.addEventListener('keyup', keyupEvent);\n});\n\nonBeforeMount(() => {\n    // Keep an eye to see if the currently selected identify item has been changed.\n    // Use a watcher to account for the async nature of results appearing in the\n    // IdentifyItems object\n    watchers.value.push(\n        watch(\n            currentIdentifyItem,\n            () => {\n                // ignore stuff in list mode. we manually work the highlights in that mode.\n                if (!showList.value) {\n                    // Re-initialize the details panel if the content has changed.\n                    initDetails();\n\n                    // If the identifyItem is undefined, clear any hilights.\n                    // this occurs when the bound layer has no results.\n                    if (currentIdentifyItem.value === undefined) {\n                        detailsFixture.value.removeDetailsHilight();\n                    }\n                }\n            },\n            {\n                deep: false,\n                immediate: true\n            }\n        )\n    );\n\n    // handle the case where the layer changes and we are in list mode.\n    // that change comes from `details-screen.vue` updating the props of this component,\n    // to there is no \"manual update\" of the highlight from local button event handlers.\n    watchers.value.push(\n        watch(\n            uidCompute,\n            () => {\n                const localUid = props.uid;\n\n                if (showList.value && localUid) {\n                    // we're in list mode, and a valid layer is linked\n\n                    // find layer result, wait for outer request to finish (need items to pass to hilighter)\n                    const layerIR = getBoundLayerResult();\n                    if (layerIR) {\n                        layerIR.loading.then(() => {\n                            if (props.uid === localUid && showList.value) {\n                                // Still on the same layer. User didn't pick diff layer during the loading wait.\n                                // Still in list mode. User didn't pick diff layer, change to detail mode, then come back.\n                                //\n                                // If user switches to a different layer, stays in list mode, and comes back to this prior to either layer being loaded,\n                                // will probably get a double hilight request on this layer (first visit & second vist resolve at same time),\n                                // but will just spam warnings on the console. Requires slow layers and fidgity user.\n                                // If we really don't like that, need to think of some wilder solution to track async stuff across components.\n\n                                updateHighlight();\n                            }\n                        });\n                    }\n                }\n            },\n            {\n                deep: false,\n                immediate: true\n            }\n        )\n    );\n\n    // If a new request is made, reset the index.\n    watchers.value.push(\n        watch(itemRequestTime, () => {\n            currentIdx.value = 0;\n        })\n    );\n\n    // Similarily to above, if a new layer is selected, reset the index.\n    watchers.value.push(\n        watch(\n            () => props.uid,\n            () => {\n                currentIdx.value = 0;\n            }\n        )\n    );\n});\n\nonBeforeUnmount(() => {\n    // clean up hooks into various events.\n    watchers.value.forEach(unwatch => unwatch());\n    handlers.value.forEach(handler => iApi.event.off(handler));\n\n    el.value?.removeEventListener('blur', blurEvent);\n    el.value?.removeEventListener('keyup', keyupEvent);\n});\n</script>\n\n<style lang=\"scss\" scoped>\n.layerName {\n    border-bottom: 1px solid #eee;\n}\n</style>\n","<template>\n    <panel-screen :panel=\"panel\">\n        <template #header>\n            {{\n                // Show different titles based on what requested the panel\n                detailsStore.origin === 'toggleEvent'\n                    ? t('details.layers.title.gridOrigin')\n                    : t('details.layers.title.identifyOrigin')\n            }}\n        </template>\n\n        <template #content>\n            <div class=\"relative h-full\">\n                <!-- Layer Picker, symbology stacks -->\n                <SymbologyList\n                    :results=\"layerResults\"\n                    :detailsProperties=\"detailProperties\"\n                    :selected=\"selectedLayer\"\n                    @selection-changed=\"changeLayerSelection\"\n                    v-if=\"layerResults.length > 1\"\n                ></SymbologyList>\n\n                <!-- Main Details Panel -->\n                <div class=\"detailsContentSection overflow-y-auto h-full\">\n                    <ResultList :uid=\"selectedLayer\" :results=\"layerResults\" v-if=\"!noResults\"></ResultList>\n                    <div :class=\"['text-center', { 'ml-42': layerResults.length > 1 }]\" v-else>\n                        {{\n                            layerResults.length >= 1\n                                ? t('details.layers.results.empty')\n                                : t('details.layers.results.empty.noLayers')\n                        }}\n                    </div>\n                </div>\n            </div>\n        </template>\n    </panel-screen>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed, onBeforeMount, onBeforeUnmount, ref, inject, watch } from 'vue';\n\nimport SymbologyList from './components/symbology-list.vue';\nimport ResultList from './components/result-list.vue';\n\nimport type { PropType } from 'vue';\nimport type { IdentifyResult, InstanceAPI, PanelInstance } from '@/api';\nimport type { DetailsItemInstance } from './store';\n\nimport { useI18n } from 'vue-i18n';\nimport { useDetailsStore } from './store';\n\nconst { t } = useI18n();\nconst iApi = inject<InstanceAPI>('iApi')!;\nconst detailsStore = useDetailsStore();\n\nconst handlers = ref<Array<string>>([]);\nconst watchers = ref<Array<Function>>([]);\nconst layerResults = ref<Array<IdentifyResult>>([]);\nconst noResults = ref<boolean>(false);\nconst selectedLayer = ref<string>('');\nconst userSelectedLayer = ref<boolean>(false);\n\nconst activeGreedy = computed<number>(() => detailsStore.activeGreedy);\nconst payload = computed<IdentifyResult[]>(() => detailsStore.payload);\nconst detailProperties = computed<{ [id: string]: DetailsItemInstance }>(() => detailsStore.properties);\n\ndefineProps({\n    panel: {\n        type: Object as PropType<PanelInstance>\n    }\n});\n\nconst changeLayerSelection = (uid: string) => {\n    selectedLayer.value = uid;\n    userSelectedLayer.value = true;\n};\n\n/**\n * Load identify result items after all item's load promise has resolved\n */\nconst loadPayloadItems = (newPayload: Array<IdentifyResult>): void => {\n    // NOTE: the incoming payload array needs to be made reactive at the source,\n    // i.e. in the layer that ran the identify and created this stuff.\n    // Not ideal. Have tried a number of workarounds but vue remains\n    // disrespectful in ignoring changes to array elements and updating\n    // controls in the template v-for's.\n    // I think the reason is because a promise that lives outside of\n    // the component is updating values, and the vue reactivity magic\n    // is not registering it in the dependency graph thing. Still don't know\n    // enough to say for sure.\n    // The alternative is to use $forceUpdate, which works but seems less\n    // efficient and sort of defeats the purpose of using a framework with\n    // \"smart\" two way binding.\n    // Tried making a reactive copy of elements here that would watch\n    // the original elements and update itself, would work for the\n    // IdentifyResults but the nested IdentifyItems would still break.\n    // It was also a big hack.\n    // Would like to revist, as this current solution is unintuitive,\n    // nobody writing a new layer type is going to have a clue they need\n    // to wrap their identify outputs in reactive() due to disrespectful code.\n    // if no payload, just return\n    if (newPayload === undefined) {\n        return;\n    }\n\n    // track last identify request timestamp and add to payload items. If details items panel does not exist, no new results,\n    // app is in mobile mode, or if there is not enough space available to open the detail items panel,\n    // then disable the greedy identify.\n    const greedyMode = newPayload.length === 0 ? 0 : newPayload[0].requestTime;\n    detailsStore.activeGreedy = greedyMode;\n    detailsStore.slowLoadingFlag = false;\n\n    layerResults.value = newPayload;\n\n    autoOpen(newPayload);\n};\n\n/**\n * Multiple greedy approach to auto-open identify item panel explained as follows:\n * A new array of promises (loadingResults) is created that resolves for each item when it is done loading and contains non-empty results count, and is rejected otherwise.\n * Case 1 - if no identify panels are open or only the identify summary panel is open:\n *              wait for any of the promises to resolve and open the item screen for the first that does, track this layer ID (also tracked if item screen opened manually)\n *              if no promises resolve, user clicked on empty map point with no data so reset last layer ID to none and close items screen\n * Case 2 - if item panel is already open for a layer:\n *              this layer takes priority so wait for it to resolve first, if there are new results refresh the panel to update\n *              otherwise if there are no results for this previously open layer, follow the same steps as for case 1\n */\nconst autoOpen = (newPayload: Array<IdentifyResult>): void => {\n    // if the item panel is already open for a layer, wait on that layer to resolve first\n    if (userSelectedLayer.value) {\n        const lastIdx = layerResults.value.findIndex((item: IdentifyResult) => item.uid === selectedLayer.value);\n\n        if (lastIdx !== -1) {\n            const lastIdentify = layerResults.value[lastIdx];\n            // wait on last opened layer to see if it resolves with new results\n            lastIdentify.loading.then(() => {\n                // new identify request came in while loading old results, exit greedy algo\n                if (lastIdentify.requestTime !== activeGreedy.value) {\n                    return;\n                }\n\n                // update items screen with new results for that layer and turn off greedy loading and abort flags\n                if (lastIdentify.items.length > 0) {\n                    detailsStore.activeGreedy = 0;\n                    userSelectedLayer.value = false;\n                    noResults.value = false;\n                } else {\n                    // otherwise proceed as normal in case 1\n                    autoOpenAny(newPayload);\n                }\n            });\n        } else {\n            // if last opened layer no longer exists proceed with case 1\n            autoOpenAny(newPayload);\n        }\n    } else {\n        // if no identify item panel was open or no last layer is tracked, proceed with case 1\n        autoOpenAny(newPayload);\n    }\n\n    // after a set time period, if greedy mode is still running for current identify request turn on loading flag\n    setTimeout(() => {\n        if (activeGreedy.value !== 0 && newPayload[0].requestTime === activeGreedy.value) {\n            detailsStore.slowLoadingFlag = true;\n        }\n    }, 500);\n};\n\n/**\n * Helper function for greedy auto-open function, implementation for case 1.\n */\nconst autoOpenAny = (newPayload: Array<IdentifyResult>): void => {\n    const loadingResults = newPayload.map((item: IdentifyResult) =>\n        item.loading.then(() => (item.items.length > 0 ? Promise.resolve(item) : Promise.reject()))\n    );\n    const lastTime = newPayload.length === 0 ? 0 : newPayload[0].requestTime;\n\n    // wait on any layer promise to resolve first with new identify results\n    // @ts-ignore\n    Promise.any(loadingResults)\n        .then((res: IdentifyResult) => {\n            // new identify request came in while loading old results, exit greedy algo\n            if (res.requestTime !== activeGreedy.value) {\n                return;\n            }\n\n            // open results item screen and turn off greedy loading and abort flags\n            const idx = layerResults.value.find((item: IdentifyResult) => item.uid === res.uid);\n            detailsStore.activeGreedy = 0;\n            if (idx !== undefined) {\n                selectedLayer.value = idx.uid;\n                noResults.value = false;\n            }\n        })\n        .catch(() => {\n            // new identify request came in while loading old results, exit greedy algo\n            if (lastTime !== activeGreedy.value) {\n                return;\n            }\n\n            // no promise resolved, clicked on empty map point with no identify results.\n            detailsStore.activeGreedy = 0;\n            noResults.value = true;\n        });\n};\n\n/* Vue Lifecycle Functions */\n\nonBeforeMount(() => {\n    // keep track of this watcher because it needs to be removed when this component is unmounted\n    watchers.value.push(\n        watch(\n            payload,\n            (newPayload: Array<IdentifyResult>) => {\n                // Reload items\n                loadPayloadItems(newPayload);\n            },\n            {\n                deep: false, // was true when our array had undefineds. now that objects arrive intact, we dont want this triggering when innards update\n                immediate: true\n            }\n        )\n    );\n\n    watchers.value.push(\n        watch(activeGreedy, (newGreedy: Number) => {\n            // watch to turn off greedy loading flag if greedy mode is turned off\n            if (newGreedy === 0) {\n                detailsStore.slowLoadingFlag = false;\n            }\n        })\n    );\n});\n\nonBeforeUnmount(() => {\n    handlers.value.forEach(handler => iApi.event.off(handler));\n    watchers.value.forEach(unwatch => unwatch());\n});\n</script>\n\n<style lang=\"scss\" scoped>\n.detailsContentSection {\n    padding-right: 8px;\n    margin-right: -8px;\n}\n</style>\n","export default \"key,enValue,enValid,frValue,frValid\\ndetails.layers.title.identifyOrigin,Identify Details,1,Identifier les détails,0\\ndetails.layers.title.gridOrigin,Details,1,Détails,1\\ndetails.layers.found,Found {numResults} results in {numLayers} layers,1,{numResults} résultats trouvés dans {numLayers} couches,1\\ndetails.layers.loading,The layer is loading...,1,La couche est en cours de chargement...,1\\ndetails.layers.error,Error,1,Erreur,1\\ndetails.layers.results.empty,No results found for any layer.,1,Aucun résultat trouvé pour aucune couche.,0\\ndetails.layers.results.empty.currentLayer,No results found for the selected layer.,1,Aucun résultat trouvé pour la couche sélectionnée.,1\\ndetails.layers.results.empty.noLayers,No layers for identification.,1,Pas de couches pour l'identification.,0\\ndetails.layers.results.list.tooltip,Use the arrow keys to navigate the items,1,Utilisez les touches fléchées pour naviguer entre les éléments,0\\ndetails.result.default.name,Identify Item {0},1,Désigner l'élément {0},1\\ndetails.loading,Loading...,1,Chargement en cours...,1\\ndetails.items.title,Details,1,Détails,1\\ndetails.items.range,{0} - {1} of {2},1,{0} - {1} de {2},0\\ndetails.items.next,Next page,1,Page suivante,0\\ndetails.items.previous,Previous page,1,Page précédente,0\\ndetails.items.page,Items per page,1,éléments par page,0\\ndetails.item.see.list,See List,1,Voir la liste,1\\ndetails.item.zoom,Zoom to feature,1,Zoom à l'élément,1\\ndetails.item.zoom.zooming,Zooming...,1,Zoom en cours...,1\\ndetails.item.zoom.error,Zoom failed,1,Échec du zoom,1\\ndetails.item.zoom.zoomed,Zoomed,1,Zoom terminé,1\\ndetails.item.previous.item,Previous item,1,Élément précédent,1\\ndetails.item.next.item,Next item,1,Élément suivant,1\\ndetails.item.count,{0} of {1},1,{0} de {1},1\\ndetails.item.loading,Loading results...,1,Chargement des résultats...,1\\ndetails.item.no.data,No data to show because the layer has been removed,1,Aucune donnée à afficher, car la couche a été supprimée,1\\ndetails.item.alert.zoom,Zoomed into feature,1,Zoom sur la caractéristique,1\\ndetails.item.alert.show.item,Showing result {itemName},1,Affichage du résultat {itemName},1\\ndetails.item.alert.show.list,Showing all results for {layerName},1,Affichage de tous les résultats pour {layerName},1\\ndetails.item.alert.defaultAltText,Image associated with {alias} field,1,Image associée au champ {alias},1\\ndetails.togglehilight.title,Toggle Highlight,1,Basculer vers l'élément principal,1\\ndetails.item.open,Expand,1,Développer,1\\ndetails.item.collapse,Collapse,1,Réduire,1\"","import { DetailsAPI } from './api/details';\nimport { type DetailsConfig, useDetailsStore } from './store';\nimport DetailsScreenV from './details-screen.vue';\nimport messages from './lang/lang.csv?raw';\n\nimport { markRaw } from 'vue';\nimport { useAppbarStore } from '../appbar/store';\n\nclass DetailsFixture extends DetailsAPI {\n    async added() {\n        this.$iApi.panel.register(\n            {\n                details: {\n                    screens: {\n                        'details-screen': markRaw(DetailsScreenV)\n                    },\n                    style: {\n                        width: '425px'\n                    },\n                    button: {\n                        tooltip: 'details.layers.title.identifyOrigin',\n                        // https://fonts.google.com/icons?selected=Material%20Icons%3Aarticle%3A\n                        icon: '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M0 0h24v24H0z\" fill=\"none\" /><path d=\"M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z\" /></svg>'\n                    },\n                    alertName: 'details.items.title'\n                }\n            },\n            { i18n: { messages } }\n        );\n\n        // Parse the details portion of the configuration file and save any custom\n        // template bindings in the details store.\n        this._parseConfig(this.config);\n        const unwatch = this.$vApp.$watch(\n            () => this.config,\n            (value: DetailsConfig | undefined) => this._parseConfig(value)\n        );\n\n        // override the removed method here to get access to scope\n        this.removed = () => {\n            // console.log(`[fixture] ${this.id} removed`);\n            unwatch();\n\n            this.$iApi.panel.remove('details');\n\n            if (this.$iApi.fixture.exists('appbar')) {\n                const appbarStore = useAppbarStore(this.$vApp.$pinia);\n                appbarStore.removeButton('details');\n            }\n\n            const detailsStore = useDetailsStore(this.$vApp.$pinia);\n            detailsStore.$reset();\n        };\n    }\n}\n\nexport default DetailsFixture;\n"],"names":["DetailsItemInstance","value","params","ORIGIN_DETAILS","DetailsAPI","FixtureInstance","useDetailsStore","payload","panel","p","layer","featureData","open","currFeatureId","fakeResult","ReactiveIdentifyFactory","config","layerDetailsConfigs","detailsConfigItems","layerId","detailsItems","item","map","items","layerUid","hItems","hilightFix","gsByKey","thisHighlight","graphics","gs","oid","g","hilightOn","HilightMode","props","__props","stack","ref","onMounted","detailsStore","detailProperties","computed","layerName","useI18n","layerStore","useLayerStore","el","blurEvent","keyupEvent","e","emit","__emit","selectedLayer","watchers","expanded","hovering","getLayerInfo","uid","handleItemClick","handleMouseOver","handleMouseLeave","handleItemFocus","handleItemBlur","onBeforeMount","watch","onBeforeUnmount","unwatch","t","iApi","inject","findAndDelete","fields","propertyType","property","helper","field","f","itemData","clonePayload","fieldsMetadata","checkField","displayMetadata","key","fieldMD","cloneValue","formatValues","html","alias","type","makeDate","makeHtmlLink","classes","div","linkifyHtml","numericDate","icon","zoomStatus","zoomButton","defaultTemplates","supportsFeatures","isMapLayer","itemName","nameField","returnValue","itemChanged","updateZoomStatus","fetchIcon","oidField","detailsTemplate","ESRIDefault","HTMLDefault","fieldsList","fixtureFields","zoomToFeature","zoomUsingGraphic","opts","LayerType","GeometryType","layerExists","detailsFixture","hilightToggle","showList","currentIdx","itemsPerPage","handlers","activeGreedy","endIdx","getBoundLayer","getBoundLayerResult","layerIR","isLayerResultLoaded","itemRequestTime","showPaginator","getLayerIdentifyItems","uidCompute","results","currentIdentifyItem","canHighlight","onHilightToggle","updateHighlight","initDetails","advanceItemIndex","direction","resultItems","currItem","clickShowList","detailsClosed","detailsMinimized","clickListItem","idx","secretIdx","GlobalEvents","removedLayer","detailsPanel","localUid","handler","layerResults","noResults","userSelectedLayer","changeLayerSelection","loadPayloadItems","newPayload","greedyMode","autoOpen","lastIdx","lastIdentify","autoOpenAny","loadingResults","lastTime","res","newGreedy","messages","DetailsFixture","markRaw","DetailsScreenV","useAppbarStore"],"mappings":"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"}