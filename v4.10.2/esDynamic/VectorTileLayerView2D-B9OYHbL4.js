import{U as Ve,eO as ze,cn as oe,eM as Fe,G as He,E as G,d8 as ne,ae as qe,bS as V,hc as Be,cF as O,fn as ae,b1 as le,ao as Ne,C as z,bh as Qe,n as Y,f as We,bv as Je,k as he,o as Ke,A as Ge}from"./main-kpG51UWM.js";import{d as Ye,p as je}from"./diffUtils-Cz3Fi8Xb.js";import{I as T,E as R}from"./enums-qHpGJ28Q.js";import{p as $e}from"./workers-PiCjreoO.js";import{t as P}from"./Rect-DD6XS68q.js";import{G as Xe,D as ce,F as C,I as k,O as ue,R as B}from"./enums-DBi1-Mm2.js";import{p as ye,m as de}from"./Texture-BCt2hphT.js";import{n as j}from"./pbf-D-y3_eZO.js";import{l as Ze}from"./rasterizingUtils-BmlDdKBf.js";import{e as A}from"./TileKey-C5IL-JBr.js";import{e as et}from"./LRUCache-C3erQTWv.js";import{s as _e,h as tt,p as fe}from"./Tile-D75RMC64.js";import{o as st,M as it,h as rt,f as ot}from"./mat3-CC4Foazl.js";import{e as F,c as nt,E as N}from"./MapView-BGOJJ8ch.js";import{w as at,d as lt}from"./GeometryUtils-NHgB9gGQ.js";import{E as D}from"./BufferObject-BM_7mcDb.js";import{o as U}from"./VertexArrayObject-M4iRGGoi.js";import{e as Q,t as ht,c as ct}from"./config-nuMERBvb.js";import{r as pe}from"./WGLContainer-LxgEo4I_.js";import{z as ge}from"./TileInfo-CWIRDhZl.js";import{r as ut}from"./signal-CETehA7D.js";import{n as yt,l as L,r as dt,i as $,a as M}from"./StyleDefinition-Ct4HIk9T.js";import{i as _t}from"./TileContainer-D48pXXgL.js";import{h as ft}from"./PooledRBush-DbfAmeLn.js";import{e as me,s as be}from"./SourceLayerData-BT_Ywuvg.js";import{L as pt,l as we}from"./StyleRepository-D3WuVprR.js";import{j as gt,y as mt}from"./LayerView-Bish-E63.js";import{i as bt}from"./RefreshableLayerView-BdQpGYly.js";import{g as Se}from"./Scheduler-B7UX7Wr5.js";let H=class{constructor(i,e){this._width=0,this._height=0,this._free=[],this._width=i,this._height=e,this._free.push(new P(0,0,i,e))}get width(){return this._width}get height(){return this._height}allocate(i,e){if(i>this._width||e>this._height)return new P;let t=null,s=-1;for(let r=0;r<this._free.length;++r){const o=this._free[r];i<=o.width&&e<=o.height&&(t===null||o.y<=t.y&&o.x<=t.x)&&(t=o,s=r)}return t===null?new P:(this._free.splice(s,1),t.width<t.height?(t.width>i&&this._free.push(new P(t.x+i,t.y,t.width-i,e)),t.height>e&&this._free.push(new P(t.x,t.y+e,t.width,t.height-e))):(t.width>i&&this._free.push(new P(t.x+i,t.y,t.width-i,t.height)),t.height>e&&this._free.push(new P(t.x,t.y+e,i,t.height-e))),new P(t.x,t.y,i,e))}release(i){for(let e=0;e<this._free.length;++e){const t=this._free[e];if(t.y===i.y&&t.height===i.height&&t.x+t.width===i.x)t.width+=i.width;else if(t.x===i.x&&t.width===i.width&&t.y+t.height===i.y)t.height+=i.height;else if(i.y===t.y&&i.height===t.height&&i.x+i.width===t.x)t.x=i.x,t.width+=i.width;else{if(i.x!==t.x||i.width!==t.width||i.y+i.height!==t.y)continue;t.y=i.y,t.height+=i.height}this._free.splice(e,1),this.release(i)}this._free.push(i)}},xe=class{constructor(i,e,t){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=i,this.height=e,this._glyphSource=t,this._binPack=new H(i-4,e-4),this._glyphData.push(new Uint8Array(i*e)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(i,e){const t=[],s=this._glyphSource,r=new Set,o=1/256;for(const a of e){const l=Math.floor(a*o);r.add(l)}const n=[];return r.forEach(a=>{const l=i+a;if(this._rangePromises.has(l))n.push(this._rangePromises.get(l));else{const h=s.getRange(i,a).then(()=>{this._rangePromises.delete(l)},()=>{this._rangePromises.delete(l)});this._rangePromises.set(l,h),n.push(h)}}),Promise.all(n).then(()=>{let a=this._glyphIndex[i];a||(a={},this._glyphIndex[i]=a);for(const l of e){const h=a[l];if(h){t[l]={sdf:!0,rect:h.rect,metrics:h.metrics,page:h.page,code:l};continue}const y=s.getGlyph(i,l);if(!y?.metrics)continue;const u=y.metrics;let d;if(u.width===0)d=new P(0,0,0,0);else{const c=u.width+6,_=u.height+2*3;let f=c%4?4-c%4:4,p=_%4?4-_%4:4;f===1&&(f=5),p===1&&(p=5),d=this._binPack.allocate(c+f,_+p),d.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new H(this.width-4,this.height-4),d=this._binPack.allocate(c+f,_+p));const g=this._glyphData[this._currentPage],m=y.bitmap;let b,x;if(m)for(let S=0;S<_;S++){b=c*S,x=this.width*(d.y+S+1)+d.x;for(let w=0;w<c;w++)g[x+w+1]=m.at(b+w)}}a[l]={rect:d,metrics:u,tileIDs:null,page:this._currentPage},t[l]={sdf:!0,rect:d,metrics:u,page:this._currentPage,code:l},this._dirties[this._currentPage]=!0}return t})}removeGlyphs(i){for(const e in this._glyphIndex){const t=this._glyphIndex[e];if(!t)continue;let s;for(const r in t)if(s=t[r],s.tileIDs.delete(i),s.tileIDs.size===0){const o=this._glyphData[s.page],n=s.rect;let a,l;for(let h=0;h<n.height;h++)for(a=this.width*(n.y+h)+n.x,l=0;l<n.width;l++)o[a+l]=0;delete t[r],this._dirties[s.page]=!0}}}bind(i,e,t,s=0){if(!this._textures[t]){const o=new ye;o.pixelFormat=Xe.ALPHA,o.wrapMode=ce.CLAMP_TO_EDGE,o.width=this.width,o.height=this.height,this._textures[t]=new de(i,o,new Uint8Array(this.width*this.height))}const r=this._textures[t];r.setSamplingMode(e),this._dirties[t]&&r.setData(this._glyphData[t]),i.bindTexture(r,s),this._dirties[t]=!1}destroy(){this.dispose()}dispose(){this._glyphData.length=0,this._binPack=null;for(const i of this._textures)i&&i.dispose();this._textures.length=0}},X=class{constructor(i){if(this._metrics=[],!i)return void(this._allBitmaps=null);const e=new Map;let t=0;for(;i.next();)switch(i.tag()){case 1:{const o=i.getMessage();for(;o.next();)switch(o.tag()){case 3:{const n=o.getMessage();let a,l,h,y,u,d,c;for(;n.next();)switch(n.tag()){case 1:a=n.getUInt32();break;case 2:l=n.getBytes();break;case 3:h=n.getUInt32();break;case 4:y=n.getUInt32();break;case 5:u=n.getSInt32();break;case 6:d=n.getSInt32();break;case 7:c=n.getUInt32();break;default:n.skip()}if(n.release(),a){const _=l?.length??0;this._metrics[a]={width:h,height:y,left:u,top:d,advance:c,startOffset:t,length:_},e.set(a,l),t+=_}break}default:o.skip()}o.release();break}default:i.skip()}const s=new Uint8Array(t),r=this._metrics;for(const[o,n]of e){const{startOffset:a,length:l}=r[o];if(n)for(let h=0;h<l;++h)s[a+h]=n[h]}this._allBitmaps=s}getMetrics(i){return this._metrics[i]}getBitmap(i){if(!this._allBitmaps)return;const e=this._metrics[i];if(e===void 0)return;const{startOffset:t,length:s}=e;return s!==0?new St(this._allBitmaps,t,s):void 0}},wt=class{constructor(){this._ranges=[]}get ranges(){return this._ranges}getRange(i){return this._ranges[i]}addRange(i,e){this._ranges[i]=e}},Te=class{constructor(i){this._glyphInfo={},this._baseURL=i}getRange(i,e){const t=this._getFontStack(i);if(t.getRange(e))return Promise.resolve();const s=256*e,r=s+255;if(this._baseURL){const o=this._baseURL.replace("{fontstack}",i).replace("{range}",s+"-"+r);return Ve(o,{responseType:"array-buffer"}).then(n=>{t.addRange(e,new X(new j(new Uint8Array(n.data),new DataView(n.data))))}).catch(()=>{t.addRange(e,new X)})}return t.addRange(e,new X),Promise.resolve()}getGlyph(i,e){const t=this._getFontStack(i);if(!t)return;const s=Math.floor(e/256),r=t.getRange(s);return r?{metrics:r.getMetrics(e),bitmap:r.getBitmap(e)}:void 0}_getFontStack(i){let e=this._glyphInfo[i];return e||(e=this._glyphInfo[i]=new wt),e}},St=class{constructor(i,e,t){this._array=i,this._start=e,this.length=t}at(i){return 0<=i&&i<this.length?this._array[this._start+i]:void 0}};const xt="dasharray-";let Ie=class Ue{constructor(e,t,s=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,t<=0&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=e,this._pageHeight=t,s>0&&(this._maxItemSize=s),this._binPack=new H(e-4,t-4)}destroy(){this.dispose()}dispose(){this._binPack=null,this._mosaicsData.length=0,this._mosaicRects={};for(const e of this._textures)e&&e.dispose();this._textures.length=0}getWidth(e){return e>=this._size.length?-1:this._size[e][0]}getHeight(e){return e>=this._size.length?-1:this._size[e][1]}getPageSize(e){return e>=this._size.length?null:this._size[e]}setSpriteSource(e){if(this.dispose(),this.pixelRatio=e.devicePixelRatio,this._mosaicsData.length===0){this._binPack=new H(this._pageWidth-4,this._pageHeight-4);const t=Math.floor(this._pageWidth),s=Math.floor(this._pageHeight),r=new Uint32Array(t*s);this._mosaicsData[0]=r,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=e}getSpriteItem(e,t=!1){let s,r,o=this._mosaicRects[e];if(o)return o;if(!this._sprites||this._sprites.loadStatus!=="loaded"||(e&&e.startsWith(xt)?([s,r]=this._rasterizeDash(e),t=!0):s=this._sprites.getSpriteInfo(e),!s?.width||!s.height||s.width<0||s.height<0))return null;const n=s.width,a=s.height,[l,h,y]=this._allocateImage(n,a);return l.width<=0?null:(this._copy(l,s,h,y,t,r),o={type:"sprite",rect:l,width:n,height:a,sdf:s.sdf,simplePattern:!1,rasterizationScale:s.pixelRatio,page:h},this._mosaicRects[e]=o,o)}getSpriteItems(e){const t={};for(const s of e)t[s.name]=this.getSpriteItem(s.name,s.repeat);return t}getMosaicItemPosition(e,t){const s=this.getSpriteItem(e,t),r=s?.rect;if(!r)return null;r.width=s.width,r.height=s.height;const o=s.width,n=s.height,a=2;return{tl:[r.x+a,r.y+a],br:[r.x+a+o,r.y+a+n],page:s.page}}bind(e,t,s=0,r=0){if(s>=this._size.length||s>=this._mosaicsData.length)return;if(!this._textures[s]){const n=new ye;n.wrapMode=ce.CLAMP_TO_EDGE,n.width=this._size[s][0],n.height=this._size[s][1],this._textures[s]=new de(e,n,new Uint8Array(this._mosaicsData[s].buffer))}const o=this._textures[s];o.setSamplingMode(t),this._dirties[s]&&o.setData(new Uint8Array(this._mosaicsData[s].buffer)),e.bindTexture(o,r),this._dirties[s]=!1}static _copyBits(e,t,s,r,o,n,a,l,h,y,u){let d=r*t+s,c=l*n+a;if(u){c-=n;for(let _=-1;_<=y;_++,d=((_+y)%y+r)*t+s,c+=n)for(let f=-1;f<=h;f++)o[c+f]=e[d+(f+h)%h]}else for(let _=0;_<y;_++){for(let f=0;f<h;f++)o[c+f]=e[d+f];d+=t,c+=n}}_copy(e,t,s,r,o,n){if(!this._sprites||this._sprites.loadStatus!=="loaded"||s>=this._mosaicsData.length)return;const a=new Uint32Array(n?n.buffer:this._sprites.image.buffer),l=this._mosaicsData[s],h=2,y=n?t.width:this._sprites.width;Ue._copyBits(a,y,t.x,t.y,l,r[0],e.x+h,e.y+h,t.width,t.height,o),this._dirties[s]=!0}_allocateImage(e,t){e+=2,t+=2;const s=Math.max(e,t);if(this._maxItemSize&&this._maxItemSize<s){const a=new P(0,0,e,t);return this._mosaicsData.push(new Uint32Array(e*t)),this._dirties.push(!0),this._size.push([e,t]),this._textures.push(void 0),[a,this._mosaicsData.length-1,[e,t]]}let r=e%4?4-e%4:4,o=t%4?4-t%4:4;r===1&&(r=5),o===1&&(o=5);const n=this._binPack.allocate(e+r,t+o);return n.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new H(this._pageWidth-4,this._pageHeight-4),this._allocateImage(e,t)):[n,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(e){const t=/\[(.*?)\]/,s=e.match(t);if(!s)return null;const r=s[1].split(",").map(Number),o=e.slice(e.lastIndexOf("-")+1),[n,a,l]=Ze(r,o);return[{x:0,y:0,width:a,height:l,sdf:!0,pixelRatio:1},new Uint8Array(n.buffer)]}},Tt=class{constructor(i,e,t,s){this._layer=i,this._styleRepository=e,this.devicePixelRatio=t,this._sourceDataMaxLOD=s,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._spriteSourceAbortController=null,this._startOptionsInputSignal=null,this._inputSignalEventListener=null}destroy(){this._connection?.close(),this._connection=null,this._styleRepository=null,this._layer=null,this._spriteMosaic?.destroy(),this._spriteMosaic=null,this._glyphMosaic=null,this._spriteSourceAbortController=ze(this._spriteSourceAbortController),this._spriteSourcePromise=null,this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,this._inputSignalEventListener=null}get spriteMosaic(){return this._spriteSourcePromise.then(()=>this._spriteMosaic)}get glyphMosaic(){return this._glyphMosaic}async start(i){this._requestSprite(i);const e=this._layer.currentStyleInfo.glyphsUrl,t=new Te(e?oe(e,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new xe(1024,1024,t),this._broadcastPromise=$e("WorkerTileHandler",{client:this,schedule:i.schedule,signal:i.signal}).then(s=>{if(this._layer&&(this._connection?.close(),this._connection=s,this._layer&&!this._connection.closed)){const r=s.broadcast("setStyle",{style:this._layer.currentStyleInfo.style,sourceDataMaxLOD:this._sourceDataMaxLOD},i);Promise.all(r).catch(o=>Fe(o))}})}_requestSprite(i){this._spriteSourceAbortController?.abort();const e=new AbortController;this._spriteSourceAbortController=e;const t=i?.signal;this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,t&&(this._inputSignalEventListener=It(e),t.addEventListener("abort",this._inputSignalEventListener,{once:!0}));const{signal:s}=e,r={...i,signal:s};this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,r),this._spriteSourcePromise.then(o=>{He(s),this._spriteMosaic=new Ie(1024,1024,250),this._spriteMosaic.setSpriteSource(o)})}async updateStyle(i){const e=[];for(const t of i)t.type===T.SPRITES_CHANGED?e.push({type:T.SPRITES_CHANGED,data:{spriteSource:null}}):e.push(t);return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",e)),this._broadcastPromise}setSpriteSource(i){const e=new Ie(1024,1024,250);return e.setSpriteSource(i),this._spriteMosaic=e,this._spriteSourcePromise=Promise.resolve(i),this._spriteSourceAbortController=null,e}async setStyle(i,e,t){await this._broadcastPromise,this._styleRepository=i,this._sourceDataMaxLOD=t,this._requestSprite();const s=new Te(this._layer.currentStyleInfo.glyphsUrl?oe(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);return this._glyphMosaic=new xe(1024,1024,s),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",{style:e,sourceDataMaxLOD:this._sourceDataMaxLOD})),this._broadcastPromise}async fetchTileData(i,e){const t=await this._getRefKeys(i,e);return this._getSourcesData(Object.keys(this._layer.sourceNameToSource),t,e)}async fetchTilePBFs(i){const e=Object.keys(this._layer.sourceNameToSource),t={},s=await this._getRefKeys(i,t),r=[],o=[];for(let n=0;n<s.length;n++)if(s[n].value==null||e[n]==null)o.push(null);else{const a=s[n].value,l=this._getTilePayload(a,e[n],t);l.then(h=>{r.push({...h,key:a})}),o.push(l)}return Promise.all(o).then(()=>r)}async parseTileData(i,e){const t=i&&i.data;if(!t)return null;const{sourceName2DataAndRefKey:s,transferList:r}=t;return Object.keys(s).length===0?null:this._broadcastPromise.then(()=>this._connection.invoke("createTileAndParse",{key:i.key.id,sourceName2DataAndRefKey:s,styleLayerUIDs:i.styleLayerUIDs},{...e,transferList:r}))}async getSprites(i){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(i)}getGlyphs(i){return this._glyphMosaic.getGlyphItems(i.font,i.codePoints)}async _getTilePayload(i,e,t){const s=A.pool.acquire(i.id),r=this._layer.sourceNameToSource[e],{level:o,row:n,col:a}=s;A.pool.release(s);try{return{protobuff:await r.requestTile(o,n,a,t),sourceName:e}}catch(l){if(G(l))throw l;return{protobuff:null,sourceName:e}}}async _getRefKeys(i,e){const t=this._layer.sourceNameToSource,s=new Array;for(const r in t){const o=t[r].getRefKey(i,e);s.push(o)}return ne(s)}_getSourcesData(i,e,t){const s=[];for(let r=0;r<e.length;r++)if(e[r].value==null||i[r]==null)s.push(null);else{const o=e[r].value,n=this._getTilePayload(o,i[r],t);s.push(n)}return ne(s).then(r=>{const o={},n=[];for(let a=0;a<r.length;a++){const l=r[a].value;if(l&&l.protobuff&&l.protobuff.byteLength>0){const h=e[a].value.id;o[l.sourceName]={refKey:h,protobuff:l.protobuff},n.push(l.protobuff)}}return{sourceName2DataAndRefKey:o,transferList:n}})}};function It(i){return()=>i.abort()}const ve=512,vt=1e-6,Ct=(i,e)=>i+1/(1<<2*e);let Ce=class{constructor(i,e){this._tiles=new Map,this._tileCache=new et(40,t=>t.dispose()),this._viewSize=[0,0],this._visibleTiles=new Map,this.acquireTile=i.acquireTile,this.releaseTile=i.releaseTile,this.tileInfoView=i.tileInfoView,this._container=e}destroy(){for(const i of this._tiles.values())i.dispose();this._tiles=null,this._tileCache.clear(),this._tileCache=null}update(i){this._updateCacheSize(i);const e=this.tileInfoView,t=e.getTileCoverage(i.state,0,!0,"smallest");if(!t)return!0;const{spans:s,lodInfo:r}=t,{level:o}=r,n=this._tiles,a=new Set,l=new Set;for(const{row:y,colFrom:u,colTo:d}of s)for(let c=u;c<=d;c++){const _=A.getId(o,y,r.normalizeCol(c),r.getWorldForColumn(c)),f=this._getOrAcquireTile(_);a.add(_),f.processed()?this._addToContainer(f):l.add(new A(_))}for(const[y,u]of n)u.isCoverage=a.has(y);for(const y of l)this._findPlaceholdersForMissingTiles(y,a);let h=!1;for(const[y,u]of n)u.neededForCoverage=a.has(y),u.neededForCoverage||u.isHoldingForFade&&e.intersects(t,u.key)&&a.add(y),u.isFading&&(h=!0);for(const y of this._tiles.keys())a.has(y)||this._releaseTile(y);return _e.pool.release(t),!h}clear(){this._tiles.clear(),this._tileCache.clear(),this._visibleTiles.clear()}clearCache(){this._tileCache.clear()}getIntersectingTiles(i,e,t,s,r){const o=[0,0],n=[0,0];s.toMap(o,i-t,e+t),s.toMap(n,i+t,e-t);const a=Math.min(o[0],n[0]),l=Math.min(o[1],n[1]),h=Math.max(o[0],n[0]),y=Math.max(o[1],n[1]),u=qe(a,l,h,y),d=V(),c=[];for(const _ of this._visibleTiles.values())this.tileInfoView.getTileBounds(d,_.key),Be(u,d)&&c.push(_);if(r!=null&&r.length>0){const _=new Set(c.map(p=>p.id)),f=r.filter(p=>!_.has(p.tileKey.id)).map(p=>this._visibleTiles.get(p.tileKey.id)).filter(p=>p!==void 0);c.push(...f)}return c}_findPlaceholdersForMissingTiles(i,e){const t=[];for(const r of this._tiles.values())this._addPlaceholderChild(t,r,i,e);const s=t.reduce(Ct,0);Math.abs(1-s)<vt||this._addPlaceholderParent(i.id,e)}_addPlaceholderChild(i,e,t,s){e.key.level<=t.level||!e.hasData()||Mt(t,e.key)&&(this._addToContainer(e),s.add(e.id),i.push(e.key.level-t.level))}_addPlaceholderParent(i,e){const t=this._tiles;let s=i;for(;;){if(s=Dt(s),!s||e.has(s))return;const r=t.get(s);if(r?.hasData())return this._addToContainer(r),void e.add(r.id)}}_getOrAcquireTile(i){let e=this._tiles.get(i);return e||(e=this._tileCache.pop(i),e||(e=this.acquireTile(new A(i))),this._tiles.set(i,e),e)}_releaseTile(i){const e=this._tiles.get(i);this.releaseTile(e),this._removeFromContainer(e),this._tiles.delete(i),e.hasData()?this._tileCache.put(i,e,1):e.dispose()}_addToContainer(i){let e;const t=[],s=this._container;if(s.contains(i))return;const r=this._visibleTiles;for(const o of r.values())this._canConnectDirectly(i,o)&&t.push(o),e==null&&this._canConnectDirectly(o,i)&&(e=o);if(e!=null){for(const o of t)e.childrenTiles.delete(o),i.childrenTiles.add(o),o.parentTile=i;e.childrenTiles.add(i),i.parentTile=e}else for(const o of t)i.childrenTiles.add(o),o.parentTile=i;r.set(i.id,i),s.addChild(i)}_removeFromContainer(i){if(this._visibleTiles.delete(i.id),this._container.removeChild(i),i.parentTile!=null){i.parentTile.childrenTiles.delete(i);for(const e of i.childrenTiles)i.parentTile!=null&&i.parentTile.childrenTiles.add(e)}for(const e of i.childrenTiles)e.parentTile=i.parentTile;i.parentTile=null,i.childrenTiles.clear()}_canConnectDirectly(i,e){const t=i.key;let{level:s,row:r,col:o,world:n}=e.key;const a=this._visibleTiles;for(;s>0;){if(s--,r>>=1,o>>=1,t.level===s&&t.row===r&&t.col===o&&t.world===n)return!0;if(a.has(`${s}/${r}/${o}/${n}`))return!1}return!1}_updateCacheSize(i){const e=i.state.size;if(e[0]===this._viewSize[0]&&e[1]===this._viewSize[1])return;const t=Math.ceil(e[0]/ve)+1,s=Math.ceil(e[1]/ve)+1;this._viewSize[0]=e[0],this._viewSize[1]=e[1],this._tileCache.maxSize=5*t*s}};function Dt(i){const[e,t,s,r]=i.split("/"),o=parseInt(e,10);return o===0?null:`${o-1}/${parseInt(t,10)>>1}/${parseInt(s,10)>>1}/${parseInt(r,10)}`}function Mt(i,e){const t=e.level-i.level;return i.row===e.row>>t&&i.col===e.col>>t&&i.world===e.world}let Rt=class{constructor(i,e){this.sourceTile=e,this.xTile=0,this.yTile=0,this.hash=0,this.priority=1,this.featureIndex=0,this.colliders=[],this.textVertexRanges=[],this.iconVertexRanges=[],this.tile=i}};class Pt{constructor(){this.tileSymbols=[],this.parts=[{startTime:0,startOpacity:0,targetOpacity:0,show:!1},{startTime:0,startOpacity:0,targetOpacity:0,show:!1}],this.show=!1}}function De(i,e,t,s,r,o){const n=t-r;if(n>=0)return(e>>n)+(s-(o<<n))*(i>>n);const a=-n;return e-(o-(s<<a))*(i>>a)<<a}let Me=class{constructor(i,e,t){this._rows=Math.ceil(e/t),this._columns=Math.ceil(i/t),this._cellSize=t,this.cells=new Array(this._rows);for(let s=0;s<this._rows;s++){this.cells[s]=new Array(this._columns);for(let r=0;r<this._columns;r++)this.cells[s][r]=[]}}getCell(i,e){const t=Math.min(Math.max(Math.floor(e/this._cellSize),0),this._rows-1),s=Math.min(Math.max(Math.floor(i/this._cellSize),0),this._columns-1);return this.cells[t]&&this.cells[t][s]||null}getCellSpan(i,e,t,s){return[Math.min(Math.max(Math.floor(i/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(e/this._cellSize),0),this.rows-1),Math.min(Math.max(Math.floor(t/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(s/this._cellSize),0),this.rows-1)]}get cellSize(){return this._cellSize}get columns(){return this._columns}get rows(){return this._rows}};function At(i,e,t,s,r,o,n){const a=e[s++];for(let l=0;l<a;l++){const h=new Rt(o,n);h.xTile=e[s++],h.yTile=e[s++],h.hash=e[s++],h.priority=e[s++],h.featureIndex=e[s++];const y=e[s++];for(let c=0;c<y;c++){const _=e[s++],f=e[s++],p=e[s++],g=e[s++],m=!!e[s++],b=e[s++],x=t[s++],S=t[s++],w=e[s++],I=e[s++];h.colliders.push({xTile:_,yTile:f,dxPixels:p,dyPixels:g,hard:m,partIndex:b,width:w,height:I,minLod:x,maxLod:S})}const u=i[s++];for(let c=0;c<u;c++)h.textVertexRanges.push([i[s++],i[s++]]);const d=i[s++];for(let c=0;c<d;c++)h.iconVertexRanges.push([i[s++],i[s++]]);r.push(h)}return s}function Lt(i,e,t){for(const[s,r]of i.symbols)Ot(i,e,t,r,s)}function Ot(i,e,t,s,r){const o=i.layerData.get(r);if(o.type===R.SYMBOL){for(const n of s){const a=n.unique;let l;if(n.selectedForRendering){const h=a.parts[0],y=h.startOpacity,u=h.targetOpacity;i.allSymbolsFadingOut=i.allSymbolsFadingOut&&u===0;const d=Math.floor(127*y)|u<<7;l=d<<24|d<<16|d<<8|d}else l=0;for(const[h,y]of n.iconVertexRanges)for(let u=h;u<h+y;u+=4)o.iconOpacity[u/4]=l;if(n.selectedForRendering){const h=a.parts[1],y=h.startOpacity,u=h.targetOpacity;i.allSymbolsFadingOut=i.allSymbolsFadingOut&&u===0;const d=Math.floor(127*y)|u<<7;l=d<<24|d<<16|d<<8|d}else l=0;for(const[h,y]of n.textVertexRanges)for(let u=h;u<h+y;u+=4)o.textOpacity[u/4]=l}o.lastOpacityUpdate=e,o.opacityChanged=!0}}function kt(i,e,t,s){const r=i.colliders;let o,n,a,l;for(const h of r)if(i.unique.show&&i.unique.parts[h.partIndex].show&&(o=h.xScreen-s[0]+h.dxScreen,n=h.yScreen-s[1]+h.dyScreen,a=o+h.width,l=n+h.height,at(t,e.x,e.y,o,n,a,l)))return!0;return!1}let W=class{constructor(i,e){this.layerUIDs=[],this.isDestroyed=!1,this._data=i;let t=1;const s=new Uint32Array(i);this.layerUIDs=[];const r=s[t++];for(let o=0;o<r;o++)this.layerUIDs[o]=s[t++];this.bufferDataOffset=t,e&&(this.layer=e.getStyleLayerByUID(this.layerUIDs[0]))}get isPreparedForRendering(){return this._data==null}get offset(){return this.bufferDataOffset}get data(){return this._data}destroy(){this.isDestroyed||(this.doDestroy(),this._data=null,this.isDestroyed=!0)}prepareForRendering(i){this._data!=null&&(this.doPrepareForRendering(i,this._data,this.bufferDataOffset),this._data=null)}},Ut=class extends W{constructor(i,e){super(i,e),this.type=R.LINE,this.lineIndexStart=0,this.lineIndexCount=0;const t=new Uint32Array(i);let s=this.bufferDataOffset;this.lineIndexStart=t[s++],this.lineIndexCount=t[s++];const r=t[s++];if(r>0){this.patternMap=new Map;for(let o=0;o<r;o++){const n=t[s++],a=t[s++],l=t[s++];this.patternMap.set(n,[a,l])}}this.bufferDataOffset=s}get usedMemory(){return(this.data?.byteLength??0)+(this.vao?.usedMemory??0)}hasData(){return this.lineIndexCount>0}triangleCount(){return this.lineIndexCount/3}doDestroy(){this.vao=O(this.vao)}doPrepareForRendering(i,e,t){const s=new Uint32Array(e),r=new Int32Array(s.buffer),o=s[t++],n=D.createVertex(i,C.STATIC_DRAW,new Int32Array(r.buffer,4*t,o));t+=o;const a=s[t++],l=D.createIndex(i,C.STATIC_DRAW,new Uint32Array(s.buffer,4*t,a));t+=a;const h=this.layer.lineMaterial;this.vao=new U(i,h.getAttributeLocations(),h.getLayoutInfo(),new Map([["geometry",n]]),l)}};class Et extends W{constructor(e,t){super(e,t),this.type=R.FILL,this.fillIndexStart=0,this.fillIndexCount=0,this.outlineIndexStart=0,this.outlineIndexCount=0;const s=new Uint32Array(e);let r=this.bufferDataOffset;this.fillIndexStart=s[r++],this.fillIndexCount=s[r++],this.outlineIndexStart=s[r++],this.outlineIndexCount=s[r++];const o=s[r++];if(o>0){this.patternMap=new Map;for(let n=0;n<o;n++){const a=s[r++],l=s[r++],h=s[r++];this.patternMap.set(a,[l,h])}}this.bufferDataOffset=r}get usedMemory(){return(this.data?.byteLength??0)+(this.fillVAO?.usedMemory??0)+(this.outlineVAO?.usedMemory??0)}hasData(){return this.fillIndexCount>0||this.outlineIndexCount>0}triangleCount(){return(this.fillIndexCount+this.outlineIndexCount)/3}doDestroy(){this.fillVAO=O(this.fillVAO),this.outlineVAO=O(this.outlineVAO)}doPrepareForRendering(e,t,s){const r=new Uint32Array(t),o=new Int32Array(r.buffer),n=r[s++],a=D.createVertex(e,C.STATIC_DRAW,new Int32Array(o.buffer,4*s,n));s+=n;const l=r[s++],h=D.createIndex(e,C.STATIC_DRAW,new Uint32Array(r.buffer,4*s,l));s+=l;const y=r[s++],u=D.createVertex(e,C.STATIC_DRAW,new Int32Array(o.buffer,4*s,y));s+=y;const d=r[s++],c=D.createIndex(e,C.STATIC_DRAW,new Uint32Array(r.buffer,4*s,d));s+=d;const _=this.layer,f=_.fillMaterial,p=_.outlineMaterial;this.fillVAO=new U(e,f.getAttributeLocations(),f.getLayoutInfo(),new Map([["geometry",a]]),h),this.outlineVAO=new U(e,p.getAttributeLocations(),p.getLayoutInfo(),new Map([["geometry",u]]),c)}}let Vt=class extends W{constructor(i,e,t){super(i,e),this.type=R.SYMBOL,this.iconPerPageElementsMap=new Map,this.glyphPerPageElementsMap=new Map,this.symbolInstances=[],this.isIconSDF=!1,this.opacityChanged=!1,this.lastOpacityUpdate=0,this.symbols=[];const s=new Uint32Array(i),r=new Int32Array(i),o=new Float32Array(i);let n=this.bufferDataOffset;this.isIconSDF=!!s[n++];const a=s[n++],l=s[n++],h=s[n++],y=new A(a,l,h,0),u=s[n++];for(let f=0;f<u;f++){const p=s[n++],g=s[n++],m=s[n++];this.iconPerPageElementsMap.set(p,[g,m])}const d=s[n++];for(let f=0;f<d;f++){const p=s[n++],g=s[n++],m=s[n++];this.glyphPerPageElementsMap.set(p,[g,m])}const c=s[n++],_=s[n++];this.iconOpacity=new Int32Array(c),this.textOpacity=new Int32Array(_),n=At(s,r,o,n,this.symbols,t,y),this.bufferDataOffset=n}get usedMemory(){return(this.data?.byteLength??0)+(this.iconVAO?.usedMemory??0)+(this.textVAO?.usedMemory??0)+ae(this.iconOpacity)+ae(this.textOpacity)}hasData(){return this.iconPerPageElementsMap.size>0||this.glyphPerPageElementsMap.size>0}triangleCount(){let i=0;for(const e of this.iconPerPageElementsMap.values())i+=e[1];for(const e of this.glyphPerPageElementsMap.values())i+=e[1];return i/3}doDestroy(){this.iconVAO=O(this.iconVAO),this.textVAO=O(this.textVAO)}updateOpacityInfo(){if(!this.opacityChanged)return;this.opacityChanged=!1;const i=this.iconOpacity,e=this.iconVAO.vertexBuffers.get("opacity");i.length>0&&i.byteLength===e.usedMemory&&e.setSubData(i,0,0,i.length);const t=this.textOpacity,s=this.textVAO.vertexBuffers.get("opacity");t.length>0&&t.byteLength===s.usedMemory&&s.setSubData(t,0,0,t.length)}doPrepareForRendering(i,e,t){const s=new Uint32Array(e),r=new Int32Array(s.buffer),o=s[t++],n=D.createVertex(i,C.STATIC_DRAW,new Int32Array(r.buffer,4*t,o));t+=o;const a=s[t++],l=D.createIndex(i,C.STATIC_DRAW,new Uint32Array(s.buffer,4*t,a));t+=a;const h=s[t++],y=D.createVertex(i,C.STATIC_DRAW,new Int32Array(r.buffer,4*t,h));t+=h;const u=s[t++],d=D.createIndex(i,C.STATIC_DRAW,new Uint32Array(s.buffer,4*t,u));t+=u;const c=D.createVertex(i,C.STATIC_DRAW,this.iconOpacity.buffer),_=D.createVertex(i,C.STATIC_DRAW,this.textOpacity.buffer),f=this.layer,p=f.iconMaterial,g=f.textMaterial;this.iconVAO=new U(i,p.getAttributeLocations(),p.getLayoutInfo(),new Map([["geometry",n],["opacity",c]]),l),this.textVAO=new U(i,g.getAttributeLocations(),g.getLayoutInfo(),new Map([["geometry",y],["opacity",_]]),d)}},zt=class extends W{constructor(i,e){super(i,e),this.type=R.CIRCLE,this.circleIndexStart=0,this.circleIndexCount=0;const t=new Uint32Array(i);let s=this.bufferDataOffset;this.circleIndexStart=t[s++],this.circleIndexCount=t[s++],this.bufferDataOffset=s}get usedMemory(){return(this.data?.byteLength??0)+(this.vao?.usedMemory??0)}hasData(){return this.circleIndexCount>0}triangleCount(){return this.circleIndexCount/3}doDestroy(){this.vao=O(this.vao)}doPrepareForRendering(i,e,t){const s=new Uint32Array(e),r=new Int32Array(s.buffer),o=s[t++],n=D.createVertex(i,C.STATIC_DRAW,new Int32Array(r.buffer,4*t,o));t+=o;const a=s[t++],l=D.createIndex(i,C.STATIC_DRAW,new Uint32Array(s.buffer,4*t,a));t+=a;const h=this.layer.circleMaterial;this.vao=new U(i,h.getAttributeLocations(),h.getLayoutInfo(),new Map([["geometry",n]]),l)}},Ft=class Ee extends pe{constructor(e,t,s,r,o,n,a,l=null){super(e,t,s,r,o,n,4096,4096),this.styleRepository=a,this._memCache=l,this.type="vector-tile",this._referenced=1,this._hasSymbolBuckets=!1,this._usedMemory=256,this.layerData=new Map,this.status="loading",this.allSymbolsFadingOut=!1,this.lastOpacityUpdate=0,this.symbols=new Map,this.isCoverage=!1,this.neededForCoverage=!1,this.decluttered=!1,this.parentTile=null,this.childrenTiles=new Set,this.featureIndex=null,this.triangleCount=0,this._processed=!1,this.id=e.id}get hasSymbolBuckets(){return this._hasSymbolBuckets}get isFading(){return this._hasSymbolBuckets&&performance.now()-this.lastOpacityUpdate<Q}get isHoldingForFade(){return this._hasSymbolBuckets&&(!this.allSymbolsFadingOut||performance.now()-this.lastOpacityUpdate<Q)}get wasRequested(){return this.status==="errored"||this.status==="loaded"||this.status==="reloading"}setData(e){this.changeDataImpl(e),this.requestRender(),this.ready(),this._processed=!0}deleteLayerData(e){let t=!1;for(const s of e){const r=this.layerData.get(s);r&&(this._usedMemory-=r.usedMemory,r.type===R.SYMBOL&&this.symbols.delete(s)&&(t=!0),r.destroy(),this.layerData.delete(s))}this._memCache?.updateSize(this.key.id,this,this._usedMemory),t&&(this.featureIndex?.clear(),this.emit("symbols-changed")),this.requestRender()}processed(){return this._processed}hasData(){return this.layerData.size>0}hasFeatures(){const e=this.layerData.values();for(const t of e)if(t.hasData())return!0;return!1}dispose(){this.status!=="unloaded"&&(Ee._destroyRenderBuckets(this.layerData),this.layerData.clear(),this.featureIndex=null,this._usedMemory=0,this.destroy(),this.status="unloaded")}release(){--this._referenced==0&&(this.dispose(),this.stage=null)}retain(){++this._referenced}get usedMemory(){return this._usedMemory}get usedMemoryPerReference(){return this._usedMemory/(this._referenced||1)}changeDataImpl(e){this.featureIndex?.clear();let t=!1;if(e){const{bucketsWithData:s,emptyBuckets:r}=e,o=this._createRenderBuckets(s);if(r&&r.byteLength>0){const n=new Uint32Array(r);for(const a of n)this._deleteLayerData(a)}for(const[n,a]of o)this._deleteLayerData(n),a.type===R.SYMBOL&&(this.symbols.set(n,a.symbols),t=!0),this._usedMemory+=a.usedMemory,this.layerData.set(n,a);this._memCache?.updateSize(this.key.id,this,this.usedMemory)}this._hasSymbolBuckets=!1;for(const s of this.layerData.values())s.type===R.SYMBOL&&(this._hasSymbolBuckets=!0);t&&this.emit("symbols-changed")}attachWithContext(e){this.stage={context:e,trashDisplayObject(t){t.processDetach()},untrashDisplayObject:()=>!1}}setTransform(e){super.setTransform(e);const t=this.resolution/(e.resolution*e.pixelRatio),s=this.width/this.rangeX*t,r=this.height/this.rangeY*t,o=[0,0];e.toScreen(o,[this.x,this.y]);const n=this.transforms.tileUnitsToPixels;st(n),it(n,n,o),rt(n,n,Math.PI*e.rotation/180),ot(n,n,[s,r,1])}_createTransforms(){return{displayViewScreenMat3:F(),tileMat3:F(),tileUnitsToPixels:F()}}static _destroyRenderBuckets(e){if(!e)return;const t=new Set;for(const s of e.values())t.has(s)||(s.destroy(),t.add(s));e.clear()}_createRenderBuckets(e){const t=new Map,s=new Map;for(const r of e){const o=this._deserializeBucket(r,s);for(const n of o.layerUIDs)t.set(n,o)}return t}_deserializeBucket(e,t){let s=t.get(e);if(s)return s;switch(new Uint32Array(e)[0]){case R.FILL:s=new Et(e,this.styleRepository);break;case R.LINE:s=new Ut(e,this.styleRepository);break;case R.SYMBOL:s=new Vt(e,this.styleRepository,this);break;case R.CIRCLE:s=new zt(e,this.styleRepository)}return t.set(e,s),s}_deleteLayerData(e){if(!this.layerData.has(e))return;const t=this.layerData.get(e);this._usedMemory-=t.usedMemory,t.destroy(),this.layerData.delete(e)}};function Ht(i,e,t,s,r,o){const{iconRotationAlignment:n,textRotationAlignment:a,iconTranslate:l,iconTranslateAnchor:h,textTranslate:y,textTranslateAnchor:u}=s;let d=0;for(const c of i.colliders){const[_,f]=c.partIndex===0?l:y,p=c.partIndex===0?h:u,g=c.minLod<=o&&o<=c.maxLod;d+=g?0:1,c.enabled=g,c.xScreen=c.xTile*r[0]+c.yTile*r[3]+r[6],c.yScreen=c.xTile*r[1]+c.yTile*r[4]+r[7],p===dt.MAP?(c.xScreen+=t*_-e*f,c.yScreen+=e*_+t*f):(c.xScreen+=_,c.yScreen+=f),L.VIEWPORT===(c.partIndex===0?n:a)?(c.dxScreen=c.dxPixels,c.dyScreen=c.dyPixels):(c.dxScreen=t*(c.dxPixels+c.width/2)-e*(c.dyPixels+c.height/2)-c.width/2,c.dyScreen=e*(c.dxPixels+c.width/2)+t*(c.dyPixels+c.height/2)-c.height/2)}i.colliders.length>0&&d===i.colliders.length&&(i.unique.show=!1)}class qt{constructor(e,t,s,r,o,n){this._symbols=e,this._styleRepository=r,this._zoom=o,this._currentLayerCursor=0,this._currentSymbolCursor=0,this._styleProps=new Map,this._allNeededMatrices=new Map,this._gridIndex=new Me(t,s,ht),this._si=Math.sin(Math.PI*n/180),this._co=Math.cos(Math.PI*n/180);for(const a of e)for(const l of a.symbols)this._allNeededMatrices.has(l.tile)||this._allNeededMatrices.set(l.tile,nt(l.tile.transforms.tileUnitsToPixels))}work(e){const t=this._gridIndex;function s(o){const n=o.xScreen+o.dxScreen,a=o.yScreen+o.dyScreen,l=n+o.width,h=a+o.height,[y,u,d,c]=t.getCellSpan(n,a,l,h);for(let _=u;_<=c;_++)for(let f=y;f<=d;f++){const p=t.cells[_][f];for(const g of p){const m=g.xScreen+g.dxScreen,b=g.yScreen+g.dyScreen,x=m+g.width,S=b+g.height;if(!(l<m||n>x||h<b||a>S))return!0}}return!1}const r=performance.now();for(;this._currentLayerCursor<this._symbols.length;this._currentLayerCursor++,this._currentSymbolCursor=0){const o=this._symbols[this._currentLayerCursor],n=this._getProperties(o.styleLayerUID);for(;this._currentSymbolCursor<o.symbols.length;this._currentSymbolCursor++){if(this._currentSymbolCursor%100==99&&performance.now()-r>e)return!1;const a=o.symbols[this._currentSymbolCursor];if(!a.unique.show)continue;Ht(a,this._si,this._co,n,this._allNeededMatrices.get(a.tile),this._zoom);const l=a.unique;if(!l.show)continue;const{iconAllowOverlap:h,iconIgnorePlacement:y,textAllowOverlap:u,textIgnorePlacement:d}=n;for(const c of a.colliders){if(!c.enabled)continue;const _=l.parts[c.partIndex];_.show&&!(c.partIndex?u:h)&&s(c)&&(c.hard?l.show=!1:_.show=!1)}if(l.show)for(const c of a.colliders){if(!c.enabled||(c.partIndex?d:y)||!l.parts[c.partIndex].show)continue;const _=c.xScreen+c.dxScreen,f=c.yScreen+c.dyScreen,p=_+c.width,g=f+c.height,[m,b,x,S]=this._gridIndex.getCellSpan(_,f,p,g);for(let w=b;w<=S;w++)for(let I=m;I<=x;I++)this._gridIndex.cells[w][I].push(c)}}}return!0}_getProperties(e){const t=this._styleProps.get(e);if(t)return t;const s=this._zoom,r=this._styleRepository.getStyleLayerByUID(e),o=r.getLayoutValue("symbol-placement",s)!==yt.POINT;let n=r.getLayoutValue("icon-rotation-alignment",s);n===L.AUTO&&(n=o?L.MAP:L.VIEWPORT);let a=r.getLayoutValue("text-rotation-alignment",s);a===L.AUTO&&(a=o?L.MAP:L.VIEWPORT);const l=r.getPaintValue("icon-translate",s),h=r.getPaintValue("icon-translate-anchor",s),y=r.getPaintValue("text-translate",s),u=r.getPaintValue("text-translate-anchor",s),d={iconAllowOverlap:r.getLayoutValue("icon-allow-overlap",s),iconIgnorePlacement:r.getLayoutValue("icon-ignore-placement",s),textAllowOverlap:r.getLayoutValue("text-allow-overlap",s),textIgnorePlacement:r.getLayoutValue("text-ignore-placement",s),iconRotationAlignment:n,textRotationAlignment:a,iconTranslateAnchor:h,iconTranslate:l,textTranslateAnchor:u,textTranslate:y};return this._styleProps.set(e,d),d}}function Bt(i,e){if(i.priority-e.priority)return i.priority-e.priority;const t=i.tile.key,s=e.tile.key;return t.world-s.world?t.world-s.world:t.level-s.level?t.level-s.level:t.row-s.row?t.row-s.row:t.col-s.col?t.col-s.col:i.xTile-e.xTile?i.xTile-e.xTile:i.yTile-e.yTile}let Nt=class{get running(){return this._running}constructor(i,e,t,s,r,o){this._visibleTiles=i,this._symbolRepository=e,this._createCollisionJob=t,this._assignTileSymbolsOpacity=s,this._symbolLayerSorter=r,this._isLayerVisible=o,this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}setScreenSize(i,e){this._screenWidth===i&&this._screenHeight===e||this.restart(),this._screenWidth=i,this._screenHeight=e}restart(){this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}continue(i){if(this._selectionJob||(this._selectionJob=this._createSelectionJob()),!this._selectionJobCompleted){const e=performance.now();if(!this._selectionJob.work(i)||(this._selectionJobCompleted=!0,(i=Math.max(0,i-(performance.now()-e)))===0))return!1}if(this._collisionJob||(this._collisionJob=this._createCollisionJob(this._selectionJob.sortedSymbols,this._screenWidth,this._screenHeight)),!this._collisionJobCompleted){const e=performance.now();if(!this._collisionJob.work(i)||(this._collisionJobCompleted=!0,(i=Math.max(0,i-(performance.now()-e)))===0))return!1}if(this._opacityJob||(this._opacityJob=this._createOpacityJob()),!this._opacityJobCompleted){const e=performance.now();if(!this._opacityJob.work(i)||(this._opacityJobCompleted=!0,(i=Math.max(0,i-(performance.now()-e)))===0))return!1}return this._running=!1,!0}_createSelectionJob(){const i=this._symbolRepository.uniqueSymbols;for(let a=0;a<i.length;a++){const l=i[a];for(let h=0;h<l.uniqueSymbols.length;h++){const y=l.uniqueSymbols[h];for(const u of y.tileSymbols)u.selectedForRendering=!1}}const e=[];let t=0,s=0;const r=this._isLayerVisible;function o(a){let l;const h=performance.now();for(;s<i.length;s++,t=0){const y=i[s],u=y.styleLayerUID;if(!r(u)){e[s]||(e[s]={styleLayerUID:u,symbols:[]});continue}e[s]=e[s]||{styleLayerUID:u,symbols:[]};const d=e[s];for(;t<y.uniqueSymbols.length;t++){if(l=y.uniqueSymbols[t],t%100==99&&performance.now()-h>a)return!1;let c=null,_=!1,f=!1;for(const p of l.tileSymbols)if(!f||!_){const g=p.tile;(!c||g.isCoverage||g.neededForCoverage&&!_)&&(c=p,(g.neededForCoverage||g.isCoverage)&&(f=!0),g.isCoverage&&(_=!0))}if(c.selectedForRendering=!0,f){d.symbols.push(c),l.show=!0;for(const p of l.parts)p.show=!0}else l.show=!1}}for(const y of e)y.symbols.sort(Bt);return!0}const n=this._symbolLayerSorter;return{work:o,get sortedSymbols(){return e.sort(n)}}}_createOpacityJob(){const i=this._assignTileSymbolsOpacity,e=this._visibleTiles;let t=0;function s(r,o){for(const n of r.symbols.values())Qt(n,o);i(r,o);for(const n of r.childrenTiles)s(n,o)}return{work(r){const o=performance.now();for(;t<e.length;t++){if(performance.now()-o>r)return!1;const n=e[t];n.parentTile==null&&s(n,performance.now())}return!0}}}};function Qt(i,e){for(const t of i){const s=t.unique;for(const r of s.parts){const o=r.targetOpacity>.5?1:-1;r.startOpacity+=o*((e-r.startTime)/Q),r.startOpacity=Math.min(Math.max(r.startOpacity,0),1),r.startTime=e,r.targetOpacity=s.show&&r.show?1:0}}}const Wt=32,Jt=8,Kt=64,Gt=20;class Yt{constructor(e,t,s){this.tileCoordRange=e,this._visibleTiles=t,this._createUnique=s,this._tiles=new Map,this._uniqueSymbolsReferences=new Map}get uniqueSymbols(){return this._uniqueSymbolLayerArray==null&&(this._uniqueSymbolLayerArray=this._createUniqueSymbolLayerArray()),this._uniqueSymbolLayerArray}get uniqueSymbolsReferences(){return this._uniqueSymbolsReferences}add(e,t){this._uniqueSymbolLayerArray=null;let s=this._tiles.get(e.id);s||(s={symbols:new Map},this._tiles.set(e.id,s));const r=new Map;if(t)for(const a of t)s.symbols.has(a)&&(r.set(a,s.symbols.get(a)),s.symbols.delete(a));else for(const[a,l]of e.layerData)s.symbols.has(a)&&(r.set(a,s.symbols.get(a)),s.symbols.delete(a));this._removeSymbols(r);const o=e.symbols,n=new Map;for(const[a,l]of o){let h=l.length;if(h>=Wt){let y=this.tileCoordRange;do y/=2,h/=4;while(h>Jt&&y>Kt);const u=new Me(this.tileCoordRange,this.tileCoordRange,y);n.set(a,{flat:l,index:u}),s.symbols.set(a,{flat:l,index:u});for(const d of l)u.getCell(d.xTile,d.yTile).push(d)}else n.set(a,{flat:l}),s.symbols.set(a,{flat:l})}this._addSymbols(e.key,o)}deleteStyleLayers(e){this._uniqueSymbolLayerArray=null;for(const[t,s]of this._tiles){const r=new Map;for(const o of e)s.symbols.has(o)&&(r.set(o,s.symbols.get(o)),s.symbols.delete(o));this._removeSymbols(r),s.symbols.size===0&&this._tiles.delete(t)}}removeTile(e){this._uniqueSymbolLayerArray=null;const t=this._tiles.get(e.id);if(!t)return;const s=new Map;for(const[r,o]of e.symbols)t.symbols.has(r)&&(s.set(r,t.symbols.get(r)),t.symbols.delete(r));this._removeSymbols(s),t.symbols.size===0&&this._tiles.delete(e.id)}querySymbols(e,t,s,r){const o=[],n=this.uniqueSymbols;for(const a of n){const l=a.styleLayerUID,h=a.uniqueSymbols;for(const y of h){const u=y.tileSymbols.find(d=>d.selectedForRendering);u&&kt(u,e,t*(window.devicePixelRatio||1),s)&&o.push({vtlSymbol:u,styleLayerUID:l,tileKey:u.tile.key})}}return o}_removeSymbols(e){for(const[t,{flat:s}]of e)for(const r of s){const o=r.unique,n=o.tileSymbols,a=n.length-1;for(let l=0;l<a;l++)if(n[l]===r){n[l]=n[a];break}if(n.length=a,a===0){const l=this._uniqueSymbolsReferences.get(t);l.delete(o),l.size===0&&this._uniqueSymbolsReferences.delete(t)}r.unique=null}}_addSymbols(e,t){if(t.size===0)return;const s=this._visibleTiles;for(const r of s)r.parentTile||r.key.world!==e.world||r.key.level===e.level&&!r.key.equals(e)||this._matchSymbols(r,e,t);for(const[r,o]of t)for(const n of o)if(n.unique==null){const a=this._createUnique();n.unique=a,a.tileSymbols.push(n);let l=this._uniqueSymbolsReferences.get(r);l||(l=new Set,this._uniqueSymbolsReferences.set(r,l)),l.add(a)}}_matchSymbols(e,t,s){if(e.key.level>t.level){const o=e.key.level-t.level;if(e.key.row>>o!==t.row||e.key.col>>o!==t.col)return}if(t.level>e.key.level){const o=t.level-e.key.level;if(t.row>>o!==e.key.row||t.col>>o!==e.key.col)return}if(t.equals(e.key)){for(const o of e.childrenTiles)this._matchSymbols(o,t,s);return}const r=new Map;for(const[o,n]of s){const a=[];for(const u of n){const d=De(this.tileCoordRange,u.xTile,t.level,t.col,e.key.level,e.key.col),c=De(this.tileCoordRange,u.yTile,t.level,t.row,e.key.level,e.key.row);d>=0&&d<this.tileCoordRange&&c>=0&&c<this.tileCoordRange&&a.push({symbol:u,xTransformed:d,yTransformed:c})}const l=[],h=(e.key.level<t.level?1:1<<e.key.level-t.level)+Gt,y=this._tiles.get(e.id).symbols.get(o);if(y){const u=y.flat;for(const d of a){let c,_=!1;const f=d.xTransformed,p=d.yTransformed;c=y.index!=null?y.index.getCell(f,p):u;const g=d.symbol,m=g.hash;for(const b of c)if(m===b.hash&&Math.abs(f-b.xTile)<=h&&Math.abs(p-b.yTile)<=h){const x=b.unique;g.unique=x,x.tileSymbols.push(g),_=!0;break}_||l.push(g)}}l.length>0&&r.set(o,l)}for(const o of e.childrenTiles)this._matchSymbols(o,t,r)}_createUniqueSymbolLayerArray(){const e=this._uniqueSymbolsReferences,t=new Array(e.size);let s,r=0;for(const[o,n]of e){const a=new Array(n.size);s=0;for(const l of n)a[s++]=l;t[r]={styleLayerUID:o,uniqueSymbols:a},r++}return t}}const jt=.5,Re=1e-6;class $t{constructor(e,t){this.styleRepository=e,this._tileToHandle=new Map,this._viewState={scale:0,rotation:0,center:[0,0],size:[0,0]},this._declutterViewState={scale:0,rotation:0,center:[0,0],size:[0,0]},this._offsetFromScreenCenter=[0,0],this._completed=!1,this._fading=ut(!1),this._symbolRepository=new Yt(4096,t,()=>new Pt),this._symbolDeclutterer=new Nt(t,this._symbolRepository,(s,r,o)=>this._createCollisionJob(s,r,o),(s,r)=>{s.allSymbolsFadingOut=!0,s.lastOpacityUpdate=r,Lt(s,r,!0),s.decluttered=!0,s.requestRender()},(s,r)=>this.styleRepository.getStyleLayerByUID(s.styleLayerUID).z-this.styleRepository.getStyleLayerByUID(r.styleLayerUID).z,s=>{const r=this.styleRepository.getStyleLayerByUID(s);if(this._zoom+Re<r.minzoom||this._zoom-Re>=r.maxzoom)return!1;const o=r.getLayoutProperty("visibility");return!o||o.getValue()!==$.NONE})}get symbolRepository(){return this._symbolRepository}_createCollisionJob(e,t,s){return this.updateDecluttererViewState(),new qt(e,t,s,this.styleRepository,this._zoom,this._viewState.rotation)}get fading(){return this._fading.value}get decluttererOffset(){return this._offsetFromScreenCenter}addTile(e){e.decluttered=!1,this._tileToHandle.set(e,e.on("symbols-changed",()=>{this._symbolRepository.add(e),this.restartDeclutter()})),this._symbolRepository.add(e),this.restartDeclutter()}removeTile(e){const t=this._tileToHandle.get(e);t&&(this._symbolRepository.removeTile(e),this.restartDeclutter(),t.remove(),this._tileToHandle.delete(e))}update(e,t){this._zoom=e,this._viewState={scale:t.scale,rotation:t.rotation,center:[t.center[0],t.center[1]],size:[t.size[0],t.size[1]]};const s=[0,0];t.toScreen(s,t.center);const r=[0,0];return t.toScreen(r,this._declutterViewState.center),this._offsetFromScreenCenter[0]=s[0]-r[0],this._offsetFromScreenCenter[1]=s[1]-r[1],this._continueDeclutter(),this._completed}restartDeclutter(){this._completed=!1,this._symbolDeclutterer.restart(),this._notifyUnstable()}clear(){this._completed=!1,this._symbolRepository=null,this._symbolDeclutterer.restart(),this._tileToHandle.forEach(e=>e.remove()),this._tileToHandle.clear()}get stale(){return this._zoom!==this._declutterZoom||this._viewState.size[0]!==this._declutterViewState.size[0]||this._viewState.size[1]!==this._declutterViewState.size[1]||this._viewState.scale!==this._declutterViewState.scale||this._viewState.rotation!==this._declutterViewState.rotation}deleteStyleLayers(e){this._symbolRepository.deleteStyleLayers(e)}_continueDeclutter(){this._completed&&!this.stale||(this._symbolDeclutterer.running||(this.updateDecluttererViewState(),this._symbolDeclutterer.restart()),this._symbolDeclutterer.setScreenSize(this._viewState.size[0],this._viewState.size[1]),this._completed=this._symbolDeclutterer.continue(ct),this._completed&&this._scheduleNotifyStable())}_scheduleNotifyStable(){this._stableNotificationHandle!=null&&clearTimeout(this._stableNotificationHandle),this._stableNotificationHandle=setTimeout(()=>{this._stableNotificationHandle=null,this._fading.value=!1},(1+jt)*Q)}_notifyUnstable(){this._stableNotificationHandle!=null&&(clearTimeout(this._stableNotificationHandle),this._stableNotificationHandle=null),this._fading.value=!0}updateDecluttererViewState(){this._declutterZoom=this._zoom,this._declutterViewState.center[0]=this._viewState.center[0],this._declutterViewState.center[1]=this._viewState.center[1],this._declutterViewState.rotation=this._viewState.rotation,this._declutterViewState.scale=this._viewState.scale,this._declutterViewState.size[0]=this._viewState.size[0],this._declutterViewState.size[1]=this._viewState.size[1],this._offsetFromScreenCenter[0]=0,this._offsetFromScreenCenter[1]=0}}let Xt=class extends pe{_createTransforms(){return{displayViewScreenMat3:F(),tileMat3:F()}}};const J=1e-6;function Pe(i,e){if(i){const t=i.getLayoutProperty("visibility");if(!t||t.getValue()!==$.NONE&&(i.minzoom===void 0||i.minzoom<e+J)&&(i.maxzoom===void 0||i.maxzoom>=e-J))return!0}return!1}let Zt=class extends _t{constructor(i){super(i),this._backgroundTiles=[],this._computeDisplayInfoView(i)}destroy(){this.removeAllChildren(),this._spriteMosaic?.dispose(),this._spriteMosaic=null,this._glyphMosaic?.dispose(),this._glyphMosaic=null,this._symbolFader!=null&&(this._symbolFader.clear(),this._symbolFader=null),this._styleRepository=null,this._backgroundTiles=[]}get fading(){return this._symbolFader?.fading??!1}get symbolFader(){return this._symbolFader}get symbolRepository(){return this._symbolFader?.symbolRepository}setStyleResources(i,e,t,s){this._spriteMosaic=i,this._glyphMosaic=e,this._styleRepository=t,this.tileInfoView=s,this._computeDisplayInfoView(s),this._symbolFader==null&&(this._symbolFader=new $t(this._styleRepository,this.children)),this._symbolFader.styleRepository=t}setSpriteMosaic(i){this._spriteMosaic?.dispose(),this._spriteMosaic=i}deleteStyleLayers(i){this._symbolFader!=null&&this._symbolFader.deleteStyleLayers(i)}createRenderParams(i){return{...super.createRenderParams(i),renderPass:null,styleLayer:null,styleLayerUID:-1,glyphMosaic:this._glyphMosaic,spriteMosaic:this._spriteMosaic,hasClipping:!!this._clippingInfos}}doRender(i){!this.visible||i.drawPhase!==N.MAP&&i.drawPhase!==N.DEBUG||this._spriteMosaic===void 0||super.doRender(i)}addChild(i){return super.addChild(i),this._symbolFader!=null?this._symbolFader.addTile(i):i.decluttered=!0,this.requestRender(),i}removeChild(i){return this._symbolFader!=null&&this._symbolFader.removeTile(i),this.requestRender(),super.removeChild(i)}renderChildren(i){const{drawPhase:e}=i;e!==N.DEBUG?this._doRender(i):super.renderChildren(i)}removeAllChildren(){for(let i=0;i<this.children.length;i++){const e=this.children[i];this._symbolFader!=null&&this._symbolFader.removeTile(e),e.dispose()}super.removeAllChildren()}getStencilTarget(){return this.children.filter(i=>i.neededForCoverage&&i.hasData())}restartDeclutter(){this._symbolFader!=null&&this._symbolFader.restartDeclutter()}_doRender(i){const{context:e,state:t}=i,s=this._styleRepository;if(!s)return;const r=s.layers,o=this._displayInfo.scaleToZoom(t.scale);s.backgroundBucketIds.length>0&&(i.renderPass="background",this._renderBackgroundLayers(i,s.backgroundBucketIds,o)),super.renderChildren(i),i.drawPhase===N.MAP&&this._fade(o,t);const n=this.children.filter(a=>a.visible&&a.hasData());if(!n||n.length===0)return e.bindVAO(),e.setStencilTestEnabled(!0),void e.setBlendingEnabled(!0);for(const a of n)a.triangleCount=0;e.setStencilWriteMask(0),e.setColorMask(!0,!0,!0,!0),e.setStencilOp(k.KEEP,k.KEEP,k.REPLACE),e.setStencilTestEnabled(!0),e.setBlendingEnabled(!1),e.setDepthTestEnabled(!0),e.setDepthWriteEnabled(!0),e.setDepthFunction(ue.LEQUAL),e.setClearDepth(1),e.clear(e.gl.DEPTH_BUFFER_BIT),i.renderPass="opaque";for(let a=r.length-1;a>=0;a--)this._renderStyleLayer(r[a],i,n);e.setDepthWriteEnabled(!1),e.setBlendingEnabled(!0),e.setBlendFunctionSeparate(B.ONE,B.ONE_MINUS_SRC_ALPHA,B.ONE,B.ONE_MINUS_SRC_ALPHA),i.renderPass="translucent";for(let a=0;a<r.length;a++)this._renderStyleLayer(r[a],i,n);e.bindVAO(),e.setStencilTestEnabled(!0),e.setBlendingEnabled(!0);for(const a of n)a.debugInfo.display.triangleCount=a.triangleCount}_fade(i,e){this._symbolFader!=null&&(this._symbolFader.update(i,e)||this.requestRender())}_renderStyleLayer(i,e,t){const{displayLevel:s,painter:r,renderPass:o}=e;if(i===void 0)return;const n=i.getLayoutProperty("visibility");if(n&&n.getValue()===$.NONE)return;let a;switch(i.type){case M.BACKGROUND:return;case M.FILL:if(o!=="opaque"&&e.renderPass!=="translucent")return;a="vtlFill";break;case M.LINE:if(o!=="translucent")return;a="vtlLine";break;case M.CIRCLE:if(o!=="translucent")return;a="vtlCircle";break;case M.SYMBOL:if(o!=="translucent")return;a="vtlSymbol"}if(t=i.type===M.SYMBOL?t.filter(h=>h.decluttered):t.filter(h=>h.neededForCoverage),a!=="vtlSymbol"&&(t.length===0||i.minzoom!==void 0&&i.minzoom>=s+J||i.maxzoom!==void 0&&i.maxzoom<s-J))return;const l=i.uid;e.styleLayerUID=l,e.styleLayer=i;for(const h of t)if(h.layerData.has(l)){r.renderObjects(e,t,a);break}}_renderBackgroundLayers(i,e,t){const{context:s,painter:r,state:o}=i,n=this._styleRepository;let a=!1;for(const m of e)if(n.getLayerById(m).type===M.BACKGROUND&&Pe(n.getLayerById(m),t)){a=!0;break}if(!a)return;const l=this.tileInfoView,h=l.getTileCoverage(i.state,0,!0,"smallest"),{spans:y,lodInfo:u}=h,{level:d}=u,c=V(),_=[];if(this._renderPasses){const m=this._renderPasses[0];this._clippingInfos!=null&&(m.brushes[0].prepareState(i),m.brushes[0].drawMany(i,this._clippingInfos))}const f=this._backgroundTiles;let p,g=0;for(const{row:m,colFrom:b,colTo:x}of y)for(let S=b;S<=x;S++){if(g<f.length)p=f[g],p.key.set(d,m,u.normalizeCol(S),u.getWorldForColumn(S)),l.getTileBounds(c,p.key,!1),p.x=c[0],p.y=c[3],p.resolution=l.getTileResolution(d);else{const w=new A(d,m,u.normalizeCol(S),u.getWorldForColumn(S)),I=l.getTileBounds(V(),w),E=l.getTileResolution(d);p=new Xt(w,E,I[0],I[3],512,512,4096,4096),f.push(p)}p.setTransform(o),_.push(p),g++}s.setStencilWriteMask(0),s.setColorMask(!0,!0,!0,!0),s.setStencilOp(k.KEEP,k.KEEP,k.REPLACE),s.setStencilFunction(ue.EQUAL,0,255),s.setStencilTestEnabled(!0);for(const m of e){const b=n.getLayerById(m);b.type===M.BACKGROUND&&Pe(b,t)&&(i.styleLayerUID=b.uid,i.styleLayer=b,r.renderObjects(i,_,"vtlBackground"))}_e.pool.release(h)}_computeDisplayInfoView(i){let e=i.tileInfo.lods[0].scale;const t=Math.max(25,i.tileInfo.lods.length),s=[];for(let r=0;r<=t;r++)s.push(e),e/=2;this._displayInfo=ge.create({scales:s,size:512,spatialReference:i.spatialReference,numLODs:t})}};const es=8,ts=512,Ae=4096,ss=(i,e)=>{const t=i.vtlSymbol.sourceTile,s=e.vtlSymbol.sourceTile;return t.level!==s.level?t.level-s.level:t.row!==s.row?t.row-s.row:t.col!==s.col?t.col-s.col:i.styleLayerUID-e.styleLayerUID};class ee{constructor(e,t,s,r,o){this.tileKey=e,this._tileLayerData=t,this._styleRepository=s,this._tileHandler=r,this._parentLayer=o,this._index=null,this._tileKeyToPBF=new Map}static create(e,t,s,r,o){return new ee(e,t,s,r,o)}clear(){this._index?.clear(),this._tileKeyToPBF.clear()}async queryAttributes(e,t,s,r,o){if(this._tileLayerData.size===0||!this._styleRepository||!this._tileHandler)return[];this._index===null&&(this._index=new ft(100,is),await this._indexLayers());const n=[];return this._queryIndex(n,e,t,s,this.tileKey.level,r),o&&o?.length>0&&await this._getSymbolsAttributes(n,o),n}async _indexLayers(){const e=this.tileKey,t=this._styleRepository.layers,s=await this._getTilePayload(e);for(const[r,o]of this._tileLayerData){const n=t[r],a=s.find(y=>y.sourceName===n.source);if(!a)continue;const{protobuff:l,key:h}=a;if(o.type!==R.SYMBOL){const y=1<<e.level-h.level,u=e.row-h.row*y,d=e.col-h.col*y;this._indexLayer(n,l,e.level,y,u,d)}}}_indexLayer(e,t,s,r,o,n){const a=e.sourceLayer,l=e.getFeatureFilter(),h=s,y=s+1,u=lt(h),d=new j(new Uint8Array(t),new DataView(t));for(;d.next();)switch(d.tag()){case 3:{const c=d.getMessage(),_=new me(c);if(c.release(),_.name!==a)continue;const f=_.getData(),p=_.extent/r,g=p*n-u,m=p*o-u,b=g+p+2*u,x=m+p+2*u,S=p/ts,w=Ae/p,I=p*n,E=p*o;for(;f.nextTag(2);){const te=f.getMessage(),q=new be(te,_);if(te.release(),l&&!l.filter(q,s))continue;const se=q.values||{},ie=se._minzoom,re=se._maxzoom;if(ie&&ie>=10*y||re&&re<=10*h)continue;const v=e.getFeatureInflatedBounds(q,h,_.extent,S);v==null||v[0]>b||v[1]>x||v[2]<g||v[3]<m||(v[0]=(v[0]-I)*w,v[1]=(v[1]-E)*w,v[2]=(v[2]-I)*w,v[3]=(v[3]-E)*w,this._index.insert(new pt(e,q,v,w,I,E)))}break}default:d.skip()}}async _getSymbolsAttributes(e,t){if(!t||t.length===0)return e;const s=[];t.sort(ss);let r=t[0].styleLayerUID,o=0;for(let h=0;h<t.length;h++)r!==t[h].styleLayerUID&&(s.push({from:o,to:h,styleLayerUID:r,sourceTileKey:t[h].vtlSymbol.sourceTile}),o=h,r=t[h].styleLayerUID);s.push({from:o,to:t.length,styleLayerUID:r,sourceTileKey:t[t.length-1].vtlSymbol.sourceTile});const n=this._styleRepository.layers;let a,l=null;for(const h of s){const y=await this._getTilePayload(h.sourceTileKey);a=n[h.styleLayerUID],l=!!a&&y.find(u=>u.sourceName===a.source),l&&this._addSymbolsAttributes(e,t.slice(h.from,h.to).map(u=>u.vtlSymbol),r,l)}return e}_addSymbolsAttributes(e,t,s,r){const o=this._styleRepository.layers,n=r.key,a=this.tileKey,l=1<<a.level-n.level,h=a.row-n.row*l,y=a.col-n.col*l;this._getSymbolAttributes(r.protobuff,t,s,l,h,y).forEach(u=>{const{attributes:d,tilePoint:c}=u;e.push({layerId:o[s].id,layerIndex:s,graphic:new le({attributes:d,origin:{type:"vector-tile",layerId:o[s].id,layerIndex:s,layer:this._parentLayer}}),tilePoint:c})})}_getSymbolAttributes(e,t,s,r,o,n){const a=[],l=this._styleRepository.layers;let h=0;t.sort((u,d)=>u.featureIndex-d.featureIndex);const y=new j(new Uint8Array(e),new DataView(e));for(;y.next();)switch(y.tag()){case 3:{const u=y.getMessage(),d=new me(u);if(u.release(),d.name!==l[s].sourceLayer)continue;const c=d.getData(),_=d.extent/r,f=Ae/_,p=_*n,g=_*o;let m=0;for(;c.nextTag(2);){const b=c.getMessage();if(m++===t[h].featureIndex){const x=new be(b,d),S=x.values,w=x.getGeometry(),I=w!=null?[f*(w[0][0].x-p),f*(w[0][0].y-g)]:null;a.push({attributes:S,tilePoint:I}),h++}if(b.release(),h===t.length)return a}break}default:y.skip()}return a}_queryIndex(e,t,s,r,o,n){const a=es*r*(window.devicePixelRatio||1);return this._index?.search({minX:t-a,minY:s-a,maxX:t+a,maxY:s+a},l=>{const{layer:h,feature:y}=l;h.isIntersectingFeature(t,s,r,y,o,n,l)&&e.push({layerId:h.id,layerIndex:h.uid,tilePoint:null,graphic:new le({attributes:y.values,origin:{type:"vector-tile",layerId:l.layer.id,layerIndex:l.layer.uid,layer:this._parentLayer}})})}),e}async _getTilePayload(e){return Ne(this._tileKeyToPBF,e.id,()=>this._tileHandler.fetchTilePBFs(e)).then(t=>t)}}const is=i=>({minX:i.bounds[0],minY:i.bounds[1],maxX:i.bounds[2],maxY:i.bounds[3]});class Le extends tt{constructor(){super(...arguments),this._fullCacheLodInfos=null,this._levelByScale={}}getTileParentId(e){const t=A.pool.acquire(e),s=t.level===0?null:A.getId(t.level-1,t.row>>1,t.col>>1,t.world);return A.pool.release(t),s}getTileCoverage(e,t,s=!0,r){const o=super.getTileCoverage(e,t,s,r);if(!o)return o;const n=1<<o.lodInfo.level;return o.spans=o.spans.filter(a=>a.row>=0&&a.row<n),o}scaleToLevel(e){if(this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos),this._levelByScale[e])return this._levelByScale[e];{const t=this._fullCacheLodInfos;if(e>t[0].scale)return t[0].level;let s,r;for(let o=0;o<t.length-1;o++)if(r=t[o+1],e>r.scale)return s=t[o],s.level+(s.scale-e)/(s.scale-r.scale);return t[t.length-1].level}}_initializeFullCacheLODs(e){let t;if(e[0].level===0)t=e.map(s=>({level:s.level,resolution:s.resolution,scale:s.scale}));else{const s=this.tileInfo.size[0],r=this.tileInfo.spatialReference;t=ge.create({size:s,spatialReference:r}).lods.map(o=>({level:o.level,resolution:o.resolution,scale:o.scale}))}for(let s=0;s<t.length;s++)this._levelByScale[t[s].scale]=t[s].level;this._fullCacheLodInfos=t}}const Z=2,Oe=8,ke=512;let K=class extends bt(gt(mt)){constructor(){super(...arguments),this._styleChanges=[],this._fetchQueue=null,this._parseQueue=null,this._tileHandlerPromise=null,this._isTileHandlerReady=!1,this._styeChanged=!1,this._spriteSourceChanged=!1}get fading(){return this._vectorTileContainer?.fading??!1}get hasVisibleFeatures(){const i=this._vectorTileContainer.children;for(const e of i)if(e.hasFeatures())return!0;return!1}get spriteSourceChanged(){return this._spriteSourceChanged}get styleChanged(){return this._styeChanged}async hitTest(i,e){const t=this._tileHandlerPromise,s=this._vectorTileContainer?.symbolFader;if(!t||!this._isTileHandlerReady||!s)return;await t;let r=null;const o=this._vectorTileContainer?.symbolRepository;o&&(r=o.querySymbols(e,Z,s.decluttererOffset,{}));const n=this.view.state,a=this._tileManager.getIntersectingTiles(e.x,e.y,Z,n,r);if((!a||a.length===0)&&r?.length===0)return null;i=i.clone().normalize();const l=[],h=[];for(const y of a)l.push(this._queryTile(h,i,Z,this.view.state.rotation,y,r?.filter(u=>u.tileKey.id===y.id)));return await Promise.all(l),h}update(i){if(this._tileHandlerPromise&&this._isTileHandlerReady)return i.pixelRatio!==this._tileHandler.devicePixelRatio?(this._start(),void(this._tileHandler.devicePixelRatio=i.pixelRatio)):void(this._styleChanges.length>0?this._tileHandlerPromise=this._applyStyleChanges():(this._pauseQueues(),this._fetchQueue.state=i.state,this._parseQueue.state=i.state,this._tileManager.update(i)||this.requestUpdate(),this._resumeQueues()))}attach(){const{style:i}=this.layer.currentStyleInfo;this._styleRepository=new we(i),this._tileInfoView=new Le(this.layer.tileInfo,this.layer.fullExtent),this._vectorTileContainer=new Zt(this._tileInfoView),this._tileHandler=new Tt(this.layer,this._styleRepository,window.devicePixelRatio||1,this.layer.tileInfo.lods.length-1),this.container.addChild(this._vectorTileContainer),this._start(),this.addAttachHandles([this.layer.on("paint-change",e=>{if(this._styeChanged=!0,e.isDataDriven)this._styleChanges.push({type:T.PAINTER_CHANGED,data:e}),this.requestUpdate();else{const t=this._styleRepository,s=t.getLayerById(e.layer);if(!s)return;const r=s.type===M.SYMBOL;t.setPaintProperties(e.layer,e.paint),r&&this._vectorTileContainer?.restartDeclutter(),this._vectorTileContainer?.requestRender()}}),this.layer.on("layout-change",e=>{const t=this._styleRepository,s=t.getLayerById(e.layer);if(!s)return;this._styeChanged=!0;const r=Ye(s.layout,e.layout);if(r!=null){if(je(r,"visibility")&&rs(r)===1)return t.setLayoutProperties(e.layer,e.layout),s.type===M.SYMBOL&&this._vectorTileContainer?.restartDeclutter(),void this._vectorTileContainer?.requestRender();this._styleChanges.push({type:T.LAYOUT_CHANGED,data:e}),this.requestUpdate()}}),this.layer.on("style-layer-visibility-change",e=>{const t=this._styleRepository,s=t.getLayerById(e.layer);s&&(this._styeChanged=!0,t.setStyleLayerVisibility(e.layer,e.visibility),s.type===M.SYMBOL&&this._vectorTileContainer?.restartDeclutter(),this._vectorTileContainer?.requestRender())}),this.layer.on("style-layer-change",e=>{this._styleChanges.push({type:T.LAYER_CHANGED,data:e}),this._styeChanged=!0,this.requestUpdate()}),this.layer.on("delete-style-layer",e=>{this._styleChanges.push({type:T.LAYER_REMOVED,data:e}),this._styeChanged=!0,this.requestUpdate()}),this.layer.on("load-style",()=>this._loadStyle()),this.layer.on("spriteSource-change",e=>{this._spriteSourceChanged=!0,this._styleChanges.push({type:T.SPRITES_CHANGED,data:e});const t=this._styleRepository.layers;for(const s of t)switch(s.type){case M.SYMBOL:s.getLayoutProperty("icon-image")&&this._styleChanges.push({type:T.LAYOUT_CHANGED,data:{layer:s.id,layout:s.layout}});break;case M.LINE:s.getPaintProperty("line-pattern")&&this._styleChanges.push({type:T.PAINTER_CHANGED,data:{layer:s.id,paint:s.paint,isDataDriven:s.isPainterDataDriven()}});break;case M.FILL:s.getLayoutProperty("fill-pattern")&&this._styleChanges.push({type:T.PAINTER_CHANGED,data:{layer:s.id,paint:s.paint,isDataDriven:s.isPainterDataDriven()}})}this.requestUpdate()})])}detach(){this._stop(),this.container.removeAllChildren(),this._vectorTileContainer=z(this._vectorTileContainer),this._tileHandler=z(this._tileHandler)}viewChange(){this.requestUpdate()}moveEnd(){this.requestUpdate()}supportsSpatialReference(i){return Qe(this.layer.tileInfo?.spatialReference,i)}canResume(){let i=super.canResume();const{currentStyleInfo:e}=this.layer;if(i&&e?.layerDefinition){const t=this.view.scale,{minScale:s,maxScale:r}=e.layerDefinition;e?.layerDefinition&&(s&&s<t&&(i=!1),r&&r>t&&(i=!1))}return i}isUpdating(){return this.fading}acquireTile(i){const e=this._createVectorTile(i);return this._updatingHandles.addPromise(this._fetchQueue.push(e.key).then(t=>this._parseQueue.push({key:e.key,data:t})).then(t=>{e.once("attach",()=>this.requestUpdate()),e.setData(t),this.requestUpdate()}).catch(t=>{G(t)||Y.getLogger(this).error(t)})),e}releaseTile(i){const e=i.key.id;this._fetchQueue.abort(e),this._parseQueue.abort(e),this.requestUpdate()}async doRefresh(){if(!this.attached)return;if(this.suspended)return this._tileManager.clear(),void this.requestUpdate();this._isTileHandlerReady=!1,this._pauseQueues(),this._clearQueues(),this._tileManager.clearCache(),this._resumeQueues();const i=this._vectorTileContainer.children,e=[];try{for(const t of i){const s=this._updatingHandles.addPromise(this._fetchQueue.push(t.key).then(r=>this._parseQueue.push({key:t.key,data:r})).then(r=>t.setData(r)).finally(()=>t.featureIndex=null));e.push(s)}await Promise.all(e)}catch(t){Y.getLogger(this).error("error refreshing vector-tiles layer-view",t),this._resumeQueues(),this._isTileHandlerReady=!0}this._isTileHandlerReady=!0,this.requestUpdate()}_start(){if(this._stop(),this._tileManager=new Ce({acquireTile:t=>this.acquireTile(t),releaseTile:t=>this.releaseTile(t),tileInfoView:this._tileInfoView},this._vectorTileContainer),!this.layer.currentStyleInfo)return;const i=new AbortController,e=this._tileHandler.start({signal:i.signal}).then(()=>{this._fetchQueue=new fe({tileInfoView:this._tileInfoView,process:(t,s)=>this._getTileData(t,s),concurrency:15,scheduler:this.scheduler,priority:Se.MAPVIEW_FETCH_QUEUE}),this._parseQueue=new fe({tileInfoView:this._tileInfoView,process:(t,s)=>this._parseTileData(t,s),concurrency:8,scheduler:this.scheduler,priority:Se.MAPVIEW_VECTOR_TILE_PARSING_QUEUE}),this.requestUpdate(),this._isTileHandlerReady=!0});this._tileHandler.spriteMosaic.then(t=>{this._vectorTileContainer.setStyleResources(t,this._tileHandler.glyphMosaic,this._styleRepository,this._tileInfoView),this.requestUpdate()}),this._tileHandlerAbortController=i,this._tileHandlerPromise=e}_stop(){if(!this._tileHandlerAbortController||!this._vectorTileContainer)return;const i=this._tileHandlerAbortController;i&&i.abort(),this._tileHandlerPromise=null,this._isTileHandlerReady=!1,this._fetchQueue=z(this._fetchQueue),this._parseQueue=z(this._parseQueue),this._tileManager=z(this._tileManager),this._vectorTileContainer.removeAllChildren()}async _getTileData(i,e){return this._tileHandler.fetchTileData(i,e)}async _parseTileData(i,e){return this._tileHandler.parseTileData(i,e)}async _applyStyleChanges(){this._isTileHandlerReady=!1,this._pauseQueues(),this._clearQueues(),this._tileManager.clearCache();const i=this._styleChanges;try{await this._tileHandler.updateStyle(i)}catch(o){Y.getLogger(this).error("error applying vector-tiles style update",o.message),this._resumeQueues(),this._isTileHandlerReady=!0}const e=this._styleRepository,t=new Set;i.forEach(o=>{if(o.type!==T.LAYER_REMOVED)return;const n=o.data,a=e.getLayerById(n.layer);a&&t.add(a.uid)});const s=new Set;i.forEach(o=>{let n;switch(o.type){case T.PAINTER_CHANGED:e.setPaintProperties(o.data.layer,o.data.paint),n=o.data.layer;break;case T.LAYOUT_CHANGED:e.setLayoutProperties(o.data.layer,o.data.layout),n=o.data.layer;break;case T.LAYER_REMOVED:return void e.deleteStyleLayer(o.data.layer);case T.LAYER_CHANGED:e.setStyleLayer(o.data.layer,o.data.index),n=o.data.layer.id;break;case T.SPRITES_CHANGED:this._vectorTileContainer.setSpriteMosaic(this._tileHandler.setSpriteSource(o.data.spriteSource))}if(n){const a=e.getLayerById(n);a&&s.add(a.uid)}});const r=this._vectorTileContainer.children;if(t.size>0){const o=Array.from(t);this._vectorTileContainer.deleteStyleLayers(o);for(const n of r)n.deleteLayerData(o)}if(this._resumeQueues(),s.size>0){const o=Array.from(s),n=[];for(const a of r){const l=this._updatingHandles.addPromise(this._fetchQueue.push(a.key).then(h=>this._parseQueue.push({key:a.key,data:h,styleLayerUIDs:o})).then(h=>a.setData(h)).finally(()=>a.featureIndex=null));n.push(l)}await Promise.all(n)}this._styleChanges=[],this._isTileHandlerReady=!0,this.requestUpdate()}async _loadStyle(){const{style:i}=this.layer.currentStyleInfo,e=We(i);this._isTileHandlerReady=!1,this._pauseQueues(),this._clearQueues(),this._styleRepository=new we(e),this._vectorTileContainer.destroy(),this._tileManager.clear(),this._tileHandlerAbortController.abort(),this._tileHandlerAbortController=new AbortController;const{signal:t}=this._tileHandlerAbortController;try{this._tileHandlerPromise=this._tileHandler.setStyle(this._styleRepository,e,this.layer.tileInfo.lods.length-1),await this._tileHandlerPromise}catch(o){if(!G(o))throw o}if(t.aborted)return this._resumeQueues(),this._isTileHandlerReady=!0,this._styeChanged=!1,this._spriteSourceChanged=!1,void this.requestUpdate();const s=await this._tileHandler.spriteMosaic,r=this._vectorTileContainer;this._tileInfoView=new Le(this.layer.tileInfo,this.layer.fullExtent),r.setStyleResources(s,this._tileHandler.glyphMosaic,this._styleRepository,this._tileInfoView),this._tileManager=new Ce({acquireTile:o=>this.acquireTile(o),releaseTile:o=>this.releaseTile(o),tileInfoView:this._tileInfoView},this._vectorTileContainer),this._resumeQueues(),this._isTileHandlerReady=!0,this.requestUpdate(),this._styeChanged=!1,this._spriteSourceChanged=!1}_createVectorTile(i){const e=this._tileInfoView.getTileBounds(V(),i),t=this._tileInfoView.getTileResolution(i.level);return new Ft(i,t,e[0],e[3],512,512,this._styleRepository)}async _queryTile(i,e,t,s,r,o){if(r.layerData.size===0)return;const n=this._ensureTileIndex(r),a=this._tileInfoView.getTileBounds(V(),r.key,!0),l=Oe*ke*((e.x-a[0])/(a[2]-a[0])),h=Oe*ke*(1-(e.y-a[1])/(a[3]-a[1])),y=await n.queryAttributes(l,h,t,s,o);for(const u of y)u.graphic.geometry=this._tileToMapPoint(u.tilePoint,r.transforms.tileUnitsToPixels),i.push({type:"graphic",layer:this.layer,graphic:u.graphic,mapPoint:e.clone()});i.sort((u,d)=>d.graphic.origin.layerIndex-u.graphic.origin.layerIndex)}_tileToMapPoint(i,e){if(!i)return null;const t=i[0]*e[0]+i[1]*e[3]+e[6],s=i[0]*e[1]+i[1]*e[4]+e[7],r=this.view.state,o=[0,0];return r.toMap(o,[t,s]),new Je({x:o[0],y:o[1],spatialReference:r.spatialReference})}_ensureTileIndex(i){let e=i.featureIndex;return e||(e=ee.create(i.key,i.layerData,this._styleRepository,this._tileHandler,this.layer),i.featureIndex=e),e}_pauseQueues(){this._fetchQueue.pause(),this._parseQueue.pause()}_resumeQueues(){this._fetchQueue.resume(),this._parseQueue.resume()}_clearQueues(){this._fetchQueue.clear(),this._parseQueue.clear()}};function rs(i){if(i==null)return 0;switch(i.type){case"partial":return Object.keys(i.diff).length;case"complete":return Math.max(Object.keys(i.oldValue).length,Object.keys(i.newValue).length);case"collection":return Object.keys(i.added).length+Object.keys(i.changed).length+Object.keys(i.removed).length}}he([Ke()],K.prototype,"_isTileHandlerReady",void 0),K=he([Ge("esri.views.2d.layers.VectorTileLayerView2D")],K);const os=K;export{os as default};
