{"version":3,"file":"index-CfINOE3J.js","sources":["../../src/fixtures/extentguard/api/extentguard.ts","../../src/fixtures/extentguard/index.ts"],"sourcesContent":["import { FixtureInstance } from '@/api';\nimport { useExtentguardStore } from '../store';\nimport type { ExtentguardConfig } from '../store';\n\n/**\n * Will force map extent to remain within the defined maximum extent\n */\nexport class ExtentguardAPI extends FixtureInstance {\n    /**\n     * Parses the extentguard config JSON snippet from the config file and save to the fixture store.\n     *\n     * @param {extentguardConfig} [ExtentguardConfig]\n     * @memberof ExtentguardAPI\n     */\n    _parseConfig(extentguardConfig?: ExtentguardConfig) {\n        // NOTE: do not set store.active in this method.\n        //       it needs to remain inactive so the handler managing code\n        //       can know if it needs to wire up new handlers\n\n        if (extentguardConfig) {\n            const store = useExtentguardStore(this.$vApp.$pinia);\n\n            if (extentguardConfig.alwaysOn) {\n                store.setAlwaysOn(true);\n            }\n\n            const esi = extentguardConfig.extentSetIds;\n            if (esi && Array.isArray(esi) && esi.length > 0) {\n                store.setExtentSetIds(esi);\n            }\n        }\n    }\n\n    get config(): ExtentguardConfig | undefined {\n        return super.config;\n    }\n}\n","import { Extent } from '@/geo/api';\nimport type { BasemapChange } from '@/geo/api';\nimport { ExtentguardAPI } from './api/extentguard';\nimport { type ExtentguardConfig, useExtentguardStore } from './store';\nimport { GlobalEvents } from '@/api';\n\ninterface ClipResult {\n    min: number;\n    max: number;\n    changed: boolean;\n}\n\n/**\n * Compares a range of co-ordinates to a bounding range of co-ordinates. If center of the range falls outside\n * the bounding range, function will return a range that is back inside the bounding range\n *\n * @function clipCoords\n * @param {Number} testMax maximum value of the range to test\n * @param {Number} testMin minimum value of the range to test\n * @param {Number} boundingMax maximum value of the bounding range\n * @param {Number} boundingMin minimum value of the bounding range\n * @return {ClipResult} bundle of information. resulting range and flag if it was adjusted\n */\nfunction clipCoords(testMax: number, testMin: number, boundingMax: number, boundingMin: number): ClipResult {\n    // center co-ord of the  range to test\n    const testLength = testMax - testMin;\n    const middle = testMin + testLength / 2;\n\n    // smallest of the two input ranges.\n    // this is required to avoid a \"washing machine\" effect when the test range\n    // is much larger than the bounding range. Re-adjusting by the test range size can\n    // overshoot the bound and then another bound violation triggers. Which sends it\n    // back too far. Over and over and over.\n    const safeLength = Math.min(testLength, boundingMax - boundingMin);\n\n    if (middle > boundingMax) {\n        // our midpoint is too high\n        return {\n            min: boundingMax - safeLength,\n            max: boundingMax,\n            changed: true\n        };\n    } else if (middle < boundingMin) {\n        // our midpoint is too low\n        return {\n            min: boundingMin,\n            max: boundingMin + safeLength,\n            changed: true\n        };\n    } else {\n        // range was all good\n        return {\n            min: testMin,\n            max: testMax,\n            changed: false\n        };\n    }\n}\n\nclass ExtentguardFixture extends ExtentguardAPI {\n    /**\n     * Schema change event handler name\n     */\n    private schemaEH = '';\n\n    /**\n     * Extent change event handler name\n     */\n    private extentEH = '';\n\n    added(): void {\n        // take in any configuration\n\n        this._parseConfig(this.config);\n\n        // watch for configuration changes\n        const unwatch = this.$vApp.$watch(\n            () => this.config,\n            (value: ExtentguardConfig | undefined) => this._parseConfig(value)\n        );\n\n        // override the removed method here to get access to scope\n        this.removed = () => {\n            // cleanup\n\n            unwatch();\n\n            const store = useExtentguardStore(this.$vApp.$pinia);\n            store.$reset();\n            this.evtOff('schemaEH');\n            this.evtOff('extentEH');\n        };\n\n        // watch for basemap schema changes\n        this.schemaEH = this.$iApi.event.on(GlobalEvents.MAP_BASEMAPCHANGE, (payload: BasemapChange) => {\n            if (payload.schemaChanged) {\n                // make sure new schema wants the fixture active\n                this.checkActive();\n            }\n        });\n\n        // do a status check when map creates, or if map already created\n        if (this.$iApi.geo.map.created) {\n            this.checkActive();\n        } else {\n            this.$iApi.event.once(GlobalEvents.MAP_CREATED, () => {\n                this.checkActive();\n            });\n        }\n    }\n\n    /**\n     * Examines current state of the instance and activates or deactivates appropriately\n     */\n    private checkActive(): void {\n        const store = useExtentguardStore(this.$vApp.$pinia);\n        if (store.alwaysOn || store.extentSetIds.includes(this.$iApi.geo.map.getExtentSet().id)) {\n            if (!store.active) {\n                // turn on, start listening to extent changes\n                store.setActive(true);\n\n                this.extentEH = this.$iApi.event.on(GlobalEvents.MAP_EXTENTCHANGE, (extent: Extent) => {\n                    if (!store.enforcing) {\n                        this.enforceBoundary(extent, false);\n                    }\n                });\n            }\n        } else if (store.active) {\n            // turn off\n            store.setActive(false);\n            this.evtOff('extentEH');\n        }\n    }\n\n    /**\n     * Wraps the act of checking if an event handler exists, and if so, removing it.\n     * Just a reapeated code saver\n     * @param eventPropName property name of this class that can hold an event handler name\n     * @private\n     */\n    private evtOff(eventPropName: 'extentEH' | 'schemaEH'): void {\n        if (this[eventPropName]) {\n            this.$iApi.event.off(this[eventPropName]);\n            this[eventPropName] = '';\n        }\n    }\n\n    /**\n     * Checks if the center of the given extent is outside of the maps maximum extent. If it is,\n     * will pan the map back to something appropriate\n     *\n     * @function enforceBoundary\n     * @param {Extent} extent an extent to adjudicate\n     * @param {boolean} safetyCheck indicates if this enforcement is a check against an original enforcement\n     */\n    private enforceBoundary(extent: Extent, safetyCheck: boolean): void {\n        const maxExtent = this.$iApi.geo.map.getExtentSet().maximumExtent;\n\n        const xTest = clipCoords(extent.xmax, extent.xmin, maxExtent.xmax, maxExtent.xmin);\n\n        const yTest = clipCoords(extent.ymax, extent.ymin, maxExtent.ymax, maxExtent.ymin);\n\n        if (yTest.changed || xTest.changed) {\n            // something was adjusted.\n\n            if (safetyCheck) {\n                // stranded in a stuck zone.\n                // attempting to zoomTo back to a good location will not work. esri map will\n                // just derivate the equivalent co-ord in the stuck zone and stay there.\n                // this hard-resets our view back to a safe zone, then the following zoomTo\n                // will place the map where we wanted it.\n\n                this.$iApi.geo.map.esriView!.extent = maxExtent.toESRI();\n            }\n\n            const respectfulExtent = Extent.fromParams(\n                'extguard',\n                xTest.min,\n                yTest.min,\n                xTest.max,\n                yTest.max,\n                extent.sr\n            );\n\n            const store = useExtentguardStore(this.$vApp.$pinia);\n            store.setEnforcing(true);\n            // timeout due to how spammy extent change events are when mouse-panning.\n            // lets the user pan finish before triggering the snapback.\n            // adjusted animation as the default is pretty aggressive and mildly shocking.\n            // 300ms on linear is also ok. ease-in-out feels a bit more natural to me.\n            setTimeout(() => {\n                this.$iApi.geo.map.zoomMapTo(respectfulExtent, undefined, true, 400, 'ease-in-out').then(() => {\n                    store.setEnforcing(false);\n                    // need to check again. a very wild pan on a wrappable co-ord system\n                    // can strand us in a zone where you get stuck.\n                    // the saftey param gets turned on, will perform rescue moves if\n                    // we're stuck.\n                    this.enforceBoundary(this.$iApi.geo.map.getExtent(), true);\n                });\n            }, 150);\n        }\n    }\n}\n\nexport default ExtentguardFixture;\n"],"names":["ExtentguardAPI","FixtureInstance","extentguardConfig","store","useExtentguardStore","esi","clipCoords","testMax","testMin","boundingMax","boundingMin","testLength","middle","safeLength","ExtentguardFixture","unwatch","value","GlobalEvents","payload","extent","eventPropName","safetyCheck","maxExtent","xTest","yTest","respectfulExtent","Extent"],"mappings":"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"}