import{s as h,t as G}from"./SimpleGeometryCursor-B92kdZ15.js";import{N as m,j as c,a as i,f as y,Y as f,X as d,P as p,q as M,e as s,c as l,n as X,d as Y,s as _,I as q}from"./ProjectionTransformation-DYBnfgxa.js";class v{getOperatorType(){return 10102}supportsCurves(){return!1}accelerateGeometry(r,u,n){return!1}canAccelerateGeometry(r){return!1}executeMany(r,u,n){return new w(u,r,n)}execute(r,u){return C(r)}isConvex(r,u){if(m(r),c(r),r.isEmpty())return!0;const n=r.getGeometryType();if(n===i.enumPoint)return!0;if(n===i.enumEnvelope){const o=r;return o.getXMin()!==o.getXMax()&&o.getYMin()!==o.getYMax()}if(y(n)){const o=r;return!o.getStartXY().equals(o.getEndXY())}if(n===i.enumMultiPoint)return r.getPointCount()===1;if(n===i.enumPolyline){const o=r;return o.getPathCount()===1&&o.getPointCount()===2&&!o.getXY(0).equals(o.getXY(1))}if(n===i.enumGeometryCollection){const o=r;return o.getGeometryCount()===1&&this.isConvex(o.getGeometry(0),u)}const t=r;return!(t.getPathCount()!==1||t.getPointCount()<3)&&f(t,0)}constructOrientedMinimumBoundingBox(r,u,n,t,o){d(r,u,n,t,o)}}class w extends G{constructor(r,u,n){super(),u||p(""),this.m_progressTracker=n,this.m_index=-1,this.m_bMerge=r,this.m_bDone=!1,this.m_inputGeometryCursor=u}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}next(){if(this.m_bMerge){if(!this.m_bDone){const r=x(this.m_inputGeometryCursor);return this.m_bDone=!0,r}return null}if(!this.m_bDone){const r=this.m_inputGeometryCursor.next();if(r!==null)return m(r),c(r),this.m_index=this.m_inputGeometryCursor.getGeometryID(),C(r);this.m_bDone=!0}return null}}function x(e,r){const u=new M;let n;for(;n=e.next();)m(n),c(n),u.addGeometry(n);return u.getBoundingGeometry()}function C(e,r){if(e||p(""),m(e),c(e),e.isEmpty())return e.createInstance();const u=e.getGeometryType();if(y(u)){const n=e;if(n.getStartXY().equals(n.getEndXY())){const t=new s;return n.queryStart(t),t}{const t=new s,o=new l({vd:e.getDescription()});return n.queryStart(t),o.startPathPoint(t),n.queryEnd(t),o.lineToPoint(t),o}}if(u===i.enumEnvelope){const n=e,t=new X;if(n.queryEnvelope(t),t.xmin===t.xmax&&t.ymin===t.ymax){const o=new s;return n.queryCornerByVal(0,o),o}if(t.xmin===t.xmax||t.ymin===t.ymax){const o=new s,g=new l({vd:e.getDescription()});return n.queryCornerByVal(0,o),g.startPathPoint(o),n.queryCornerByVal(1,o),g.lineToPoint(o),g}{const o=new Y({vd:e.getDescription()});return o.addEnvelope(n,!1),o}}if(u===i.enumGeometryCollection)return x(_(e,-1));if(P(e)){if(u===i.enumMultiPoint){const n=e,t=new s;return n.getPointByVal(0,t),t}return e}return q(e)}function P(e,r){if(m(e),c(e),e.isEmpty())return!0;const u=e.getGeometryType();if(u===i.enumPoint)return!0;if(u===i.enumEnvelope){const t=e;return t.getXMin()!==t.getXMax()&&t.getYMin()!==t.getYMax()}if(y(u)){const t=e;return!t.getStartXY().equals(t.getEndXY())}if(u===i.enumMultiPoint)return e.getPointCount()===1;if(u===i.enumPolyline){const t=e;return t.getPathCount()===1&&t.getPointCount()===2&&!t.getXY(0).equals(t.getXY(1))}if(u===i.enumGeometryCollection){const t=e;return t.getGeometryCount()===1&&P(t.getGeometry(0))}const n=e;return!(n.getPathCount()!==1||n.getPointCount()<3)&&f(n,0)}const a=new v;function b(e){return a.execute(e,null)}function B(e,r){const u=a.executeMany(new h(e),r,null);return Array.from(u)}function T(e){return a.isConvex(e,null)}function I(){return a.supportsCurves()}export{b as M,I as X,T as _,B as v};
