import{e as b}from"./TechniqueType-uMFRS8dR.js";import{bq as $,iq as ke,bz as Se,bR as C,ir as Ae,ak as $e,s as De,n as ze}from"./main-D6UWMbWJ.js";import{s as te,t as G}from"./definitions-CPtb4TQS.js";import{c as Le,f as T,m as ge,N as xe,P as H,g as Ee,i as Te,l as Re,a as Be,T as Fe,s as Ce,I as Ge,x as Oe,b as We,h as Ve,u as je,o as Ne,d as qe,e as Ze,j as Ye}from"./PieChartMeshWriter-B_ZNiCv5.js";import{o as R,c as Xe,f as oe,h as E}from"./UpdateTracking2D-DcCsZjDD.js";import{C as S}from"./enums-Dk3osxpS.js";import{M as Q,i as ae}from"./mat2d-D9DBP-jx.js";import{n as B}from"./mat2df32-orApM5a3.js";import{S as ce,o as A,B as le,v as U,u as He,l as he}from"./vec2-maR1OrZI.js";import{t as O}from"./vec2f32-BbH2jxlN.js";import{n as z}from"./vec2f64-DohEyf3f.js";import{m as Qe,u as ue}from"./featureConversionUtils-BOo8MNJa.js";import{e as J}from"./OptimizedGeometry-7XEw-Hai.js";import{b as Ue,c as Je}from"./CIMSymbolHelper-DpGzf4JZ.js";import{i as de}from"./BoundingBox-CnpCxTZE.js";import{r as fe}from"./dataViewUtils-BDSaqIcf.js";import{e as W}from"./rasterizingUtils-BgcDiHpA.js";import{o as ve,e as Ke}from"./grouping-Z6lVmm_8.js";import{t as et}from"./utils-Chf0JPvs.js";import{b as tt}from"./FeatureMetadata-Br60GWzZ.js";let st=class extends Le{};function it(a){const{sprite:e,isMapAligned:t,colorLocked:i,scaleSymbolsProportionally:s,isStroke:n}=a;let r=0;return t&&(r|=T(R.bitset.isMapAligned)),i&&(r|=T(R.bitset.colorLocked)),e.sdf&&(r|=T(R.bitset.isSDF)),s&&(r|=T(R.bitset.scaleSymbolsProportionally)),n&&(r|=T(R.bitset.isStroke)),r}let rt=class extends st{get vertexSpec(){return{createComputedParams:e=>{let{pixelDimensions:t,texelDimensions:i,baseSize:s,referenceSize:n,strokeWidth:r,sizeRatio:o}=e;t||(t=e.sprite.sdf?[0,0]:[e.sprite.width,e.sprite.height]),i||(i=e.sprite.sdf?[0,0]:t),s=$(s),n=$(n),r=$(r);const c=(e.sprite.sdfDecodeCoeff??1)*o;return{...e,pixelDimensions:t,texelDimensions:i,baseSize:s,referenceSize:n,strokeWidth:r,sdfDecodeCoeff:c}},optionalAttributes:{zoomRange:{type:S.SHORT,count:2,packPrecisionFactor:te,pack:({scaleInfo:e},{tileInfo:t})=>ge(e,t)}},attributes:{id:{type:S.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:S.UNSIGNED_BYTE,count:1,pack:it},pos:{type:S.SHORT,count:2,pack:"position",packPrecisionFactor:1},offset:{type:S.FLOAT,count:2,packAlternating:{count:4,pack:e=>{const t=e.texelDimensions;return[[-.5*t[0],-.5*t[1]],[.5*t[0],-.5*t[1]],[-.5*t[0],.5*t[1]],[.5*t[0],.5*t[1]]]}}},uv:{type:S.SHORT,count:2,packPrecisionFactor:1,packAlternating:{count:4,packTessellation:({texXmax:e,texXmin:t,texYmax:i,texYmin:s})=>[[t,s],[e,s],[t,i],[e,i]]}},animationPointerAndBaseSizeAndReferenceSize:{type:S.UNSIGNED_SHORT,count:4,packPrecisionFactor:1,pack:({animations:e,baseSize:t,referenceSize:i})=>[e.dataColumn,e.dataRow,t,i]},sizing:{type:S.UNSIGNED_SHORT,count:4,packPrecisionFactor:8,pack:({strokeWidth:e,pixelDimensions:t,baseSize:i,sprite:s,sizeRatio:n})=>{const r=Math.max(i*s.width/s.height,i),o=s.sdfDecodeCoeff*r*n;return[t[0],t[1],e,o]}},angle:{type:S.BYTE,count:1,packTessellation:({angle:e})=>e}}}}_write(e,t){const i=this.evaluatedMeshParams.sprite,{textureBinding:s}=i;e.recordStart(this.instanceId,this.attributeLayout,s);const n=t.getDisplayId();if(t.geometryType==="esriGeometryPolygon"){const r=t.readCentroidForDisplay();if(!r)return;const[o,c]=r.coords;this._writeQuad(e,n,o,c)}else if(t.geometryType==="esriGeometryPoint"){const r=t.readXForDisplay(),o=t.readYForDisplay();this._writeQuad(e,n,r,o)}else{const r=t.readGeometryForDisplay();if(r){const{angleToLine:o}=this.evaluatedMeshParams;if(o){let c=!0,u=null,d=null;r.forEachVertex((l,h)=>{if(u!=null&&d!=null){const p=Math.atan2(h-d,l-u)/Xe;c&&(this._writeQuad(e,n,u,d,p),c=!1),this._writeQuad(e,n,l,h,p)}u=l,d=h})}else r.forEachVertex((c,u)=>{this._writeQuad(e,n,c,u)})}}e.recordEnd()}_writeQuad(e,t,i,s,n=0){const r=this.evaluatedMeshParams.sprite,{rect:o}=r,c=o.x+G,u=o.y+G,d=o.x+o.width-G,l=o.y+o.height-G,h=e.vertexCount();e.recordBounds(i,s,64,64);const p={texXmin:c,texYmin:u,texXmax:d,texYmax:l,angle:n};for(let y=0;y<4;y++)this._writeVertex(e,t,i,s,p);e.indexEnsureSize(6),e.indexWrite(h),e.indexWrite(h+1),e.indexWrite(h+2),e.indexWrite(h+1),e.indexWrite(h+3),e.indexWrite(h+2)}};function me(a,e,t){return a[0]=e[0]-t[0],a[1]=e[1]-t[1],a}function Me(a,e){return Math.sqrt(a*a+e*e)}function pe(a){const e=Me(a[0],a[1]);a[0]/=e,a[1]/=e}function nt(a,e){return Me(a[0]-e[0],a[1]-e[1])}function ot(a,e){return a[e+1]}function Pe(a){return a.length-1}function at(a){let e=0;for(let t=0;t<Pe(a);t++)e+=ct(a,t);return e}function ct(a,e,t=1){let[i,s]=ot(a,e);return[i,s]=[Math.round(i),Math.round(s)],Math.sqrt(i*i+s*s)*t}class q{constructor(e,t,i,s,n){this._segments=e,this._index=t,this._distance=i,this._xStart=s,this._yStart=n,this._done=!1}static create(e){return new q(e,0,0,e[0][0],e[0][1])}clone(){return new q(this._segments,this._index,this._distance,this.xStart,this.yStart)}equals(e){return this._index===e._index||e._index===this._index-1&&(this._distance===0||e._distance===1)||e._index===this._index+1&&(this._distance===1||e._distance===0)}leq(e){return this._index<e._index||this._index===e._index&&this._distance<=e._distance}geq(e){return this._index>e._index||this._index===e._index&&this._distance>=e._distance}get _segment(){return this._segments[this._index+1]}get angle(){const e=this.dy,t=(0*e+-1*-this.dx)/(1*this.length);let i=Math.acos(t);return e>0&&(i=2*Math.PI-i),i}get xStart(){return this._xStart}get yStart(){return this._yStart}get x(){return this.xStart+this.distance*this.dx}get y(){return this.yStart+this.distance*this.dy}get dx(){return this._segment[0]}get dy(){return this._segment[1]}get xMidpoint(){return this.xStart+.5*this.dx}get yMidpoint(){return this.yStart+.5*this.dy}get xEnd(){return this.xStart+this.dx}get yEnd(){return this.yStart+this.dy}get length(){const{dx:e,dy:t}=this;return Math.sqrt(e*e+t*t)}get remainingLength(){return this.length*(1-this._distance)}get backwardLength(){return this.length*this._distance}get distance(){return this._distance}get done(){return this._done}hasPrev(){return this._index-1>=0}hasNext(){return this._index+1<Pe(this._segments)}next(){return this.hasNext()?(this._xStart+=this.dx,this._yStart+=this.dy,this._distance=0,this._index+=1,this):null}prev(){return this.hasPrev()?(this._index-=1,this._xStart-=this.dx,this._yStart-=this.dy,this._distance=1,this):(this._done=!0,null)}_seekBackwards(e,t){const i=this.backwardLength;if(e<=i)return this._distance=(i-e)/this.length,this;let s=this.backwardLength;for(;this.prev();){if(s+this.length>e)return this._seekBackwards(e-s);s+=this.length}return this._distance=0,t?this:null}seek(e,t=!1){if(e<0)return this._seekBackwards(Math.abs(e),t);if(e<=this.remainingLength)return this._distance=(this.backwardLength+e)/this.length,this;let i=this.remainingLength;for(;this.next();){if(i+this.length>e)return this.seek(e-i,t);i+=this.length}return this._distance=1,t?this:null}}function K(a,e,t,i=!0){const s=at(a),n=q.create(a),r=s/2;if(!i)return n.seek(r),void(Math.abs(n.x)<W&&Math.abs(n.y)<W&&t(n.clone(),0,r+0*e,s));const o=Math.max((s-e)/2,0),c=Math.floor(o/e),u=r-c*e;n.seek(u);for(let d=-c;d<=c;d++)Math.abs(n.x)<W&&Math.abs(n.y)<W&&t(n.clone(),d,r+d*e,s),n.seek(e)}function ee(a,e){const t=e;for(let i=0;i<a.length;i++){let s=a[i];lt(s,t);const n=[];n.push(s[0]);for(let r=1;r<s.length;r++){const[o,c]=s[r-1],[u,d]=s[r],l=u-o,h=d-c;n.push([l,h])}a[i]=n,s=n}return a}function lt(a,e){if(e<=0)return;const i=a.length;if(i<3)return;const s=[];let n=0;s.push(0);for(let l=1;l<i;l++)n+=nt(a[l],a[l-1]),s.push(n);e=Math.min(e,.2*n);const r=[];r.push(a[0][0]),r.push(a[0][1]);const o=a[i-1][0],c=a[i-1][1],u=me([0,0],a[0],a[1]);pe(u),a[0][0]+=e*u[0],a[0][1]+=e*u[1],me(u,a[i-1],a[i-2]),pe(u),a[i-1][0]+=e*u[0],a[i-1][1]+=e*u[1];for(let l=1;l<i;l++)s[l]+=e;s[i-1]+=e;const d=.5*e;for(let l=1;l<i-1;l++){let h=0,p=0,y=0;for(let f=l-1;f>=0&&!(s[f+1]<s[l]-d);f--){const m=d+s[f+1]-s[l],_=s[f+1]-s[f],g=s[l]-s[f]<d?1:m/_;if(Math.abs(g)<1e-6)break;const v=g*g,x=g*m-.5*v*_,M=g*_/e,P=a[f+1],I=a[f][0]-P[0],D=a[f][1]-P[1];h+=M/x*(P[0]*g*m+.5*v*(m*I-_*P[0])-v*g*_*I/3),p+=M/x*(P[1]*g*m+.5*v*(m*D-_*P[1])-v*g*_*D/3),y+=M}for(let f=l+1;f<i&&!(s[f-1]>s[l]+d);f++){const m=d-s[f-1]+s[l],_=s[f]-s[f-1],g=s[f]-s[l]<d?1:m/_;if(Math.abs(g)<1e-6)break;const v=g*g,x=g*m-.5*v*_,M=g*_/e,P=a[f-1],I=a[f][0]-P[0],D=a[f][1]-P[1];h+=M/x*(P[0]*g*m+.5*v*(m*I-_*P[0])-v*g*_*I/3),p+=M/x*(P[1]*g*m+.5*v*(m*D-_*P[1])-v*g*_*D/3),y+=M}r.push(h/y),r.push(p/y)}r.push(o),r.push(c);for(let l=0,h=0;l<i;l++)a[l][0]=r[h++],a[l][1]=r[h++]}const V=1,L=0,ht=128,ut=ke(a=>{let e=0;if(a===0)return 1/0;for(;!(a%2);)e++,a/=2;return e});class dt extends xe{constructor(){super(...arguments),this._zoomLevel=0}_write(e,t,i,s){if(this._zoomLevel=s||0,i!=null)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(t.geometryType){case"esriGeometryPoint":{const n=t.readXForDisplay(),r=t.readYForDisplay();this._writePoint(e,n,r,t);break}case"esriGeometryEnvelope":case"esriGeometryPolygon":case"esriGeometryMultipoint":{const n=t.readCentroidForDisplay();if(!n)return;const[r,o]=n.coords;this._writePoint(e,r,o,t);break}case"esriGeometryPolyline":this._writeLines(e,t)}}_getMetricDir(){const{horizontalAlignment:e,verticalAlignment:t}=this.evaluatedMeshParams;return[e==="center"?0:e==="right"?-1:1,t==="middle"?0:t==="bottom"?-1:1]}_createLineLabelMetric(e,t,i,s){const n=oe(e),[r,o]=this._getMetricDir(),c=this.evaluatedMeshParams.scaleInfo?.maxScale??0,u=this.evaluatedMeshParams.scaleInfo?.minScale??0;return new fe(n,t,i,r,o,c,u,s??null)}_writePoint(e,t,i,s){const n=this._getShaping();if(!n)return;const r=s.getDisplayId(),o=Ue(this.evaluatedMeshParams.horizontalAlignment),c=Je(this.evaluatedMeshParams.verticalAlignment),u=this.evaluatedMeshParams.scaleInfo?.maxScale??0,d=this.evaluatedMeshParams.scaleInfo?.minScale??0,l=oe(s.getDisplayId()),h=this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0};e.metricStart(new fe(l,t,i,o,c,u,d,h)),this._writeGlyphs(e,r,t,i,n,0,h),e.metricBoxWrite(n.boundsT),e.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const e of this._references){const t=e.getBoundsInfo();if(t)return t}return null}_writeLines(e,t){const{scaleInfo:i,verticalAlignment:s}=this.evaluatedMeshParams,n=this.evaluatedMeshParams.repeatLabelDistance||128,r=this._getShaping("middle");if(!r)return;const o=(u,d,l,h)=>this._placeSubdivGlyphs(u,d,l,h),c=(r.bounds.width+n)/(1<<V);this._current={out:e,id:t.getDisplayId(),shaping:r,zoomRange:ge(i,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null},this._verticalPlacement=s==="bottom"?"above":s==="top"?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(t,o,c):this._writeCenterAlong(t,o,c)}_writeAboveAndBelowAlong(e,t,i){const{repeatLabel:s}=this.evaluatedMeshParams,{shaping:n}=this._current,r=n.bounds.halfHeight,o=e.readGeometryForDisplay();if(!o)return;const c=new J;Qe(c,o,!1,!1,"esriGeometryPolyline",1);const u=ye(new J,c,r),d=ye(new J,c,-r),l=ue(d,"esriGeometryPolyline",!1,!1),h=ue(u,"esriGeometryPolyline",!1,!1),p=ee(h.paths,n.bounds.width),y=ee(l.paths,n.bounds.width);this._current.offsetDirection="above";for(const f of p)K(f,i,t,!!s);this._current.offsetDirection="below";for(const f of y)K(f,i,t,!!s)}_writeCenterAlong(e,t,i){const{repeatLabel:s}=this.evaluatedMeshParams,{shaping:n}=this._current,r=ee(e.readLegacyGeometryForDisplay().paths,n.bounds.width);for(const o of r)K(o,i,t,!!s)}_placeSubdivGlyphs(e,t,i,s){const{allowOverrun:n,labelPosition:r,repeatLabelDistance:o}=this.evaluatedMeshParams,c=this._current.zoomRange[0],u=ut(t),d=this._current.shaping.bounds.width/(1<<V),l=Math.sqrt(o||ht)/(1<<V),h=Math.min(i,s-i),p=this._current.shaping.isMultiline?H:Math.log2(h/(l+d/2)),y=t===0?p:Math.min(u,p),f=Math.max(c,this._zoomLevel+V-y),m=this._zoomLevel-f,_=this._current.shaping.bounds.width/2*2**m;this._current.shaping.isMultiline?t===0&&this._placeStraight(e,f):n&&m<0?this._placeStraightAlong(e,c):r==="parallel"?this._placeStraightAlong(e,f):r==="curved"&&this._placeCurved(e,f,_)}_placeStraight(e,t){const{out:i,id:s,shaping:n,referenceBounds:r}=this._current,{x:o,y:c}=e;i.metricStart(this._createLineLabelMetric(s,o,c)),i.metricBoxWrite(n.boundsT);const u=e.angle*(180/Math.PI)%360,d=(e.angle*(180/Math.PI)+180)%360;this._writeGlyphs(i,s,o,c,n,0,r,{clipAngle:u,mapAligned:!0,isLineLabel:!0,minZoom:t}),this._writeGlyphs(i,s,o,c,n,0,r,{clipAngle:d,mapAligned:!0,isLineLabel:!0,minZoom:t}),i.metricEnd()}_placeCurved(e,t,i){const{out:s,id:n}=this._current;s.metricStart(this._createLineLabelMetric(n,e.x,e.y));const r=e.clone(),o=e.angle*(180/Math.PI)%360,c=(e.angle*(180/Math.PI)+180)%360;this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(r,t,1,o),this._placeBack(e,r,t,i,1,o),this._placeForward(e,r,t,i,1,o)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(r,t,0,c),this._placeBack(e,r,t,i,0,c),this._placeForward(e,r,t,i,0,c)),s.metricEnd()}_placeStraightAlong(e,t){const{out:i,id:s,shaping:n,zoomRange:r,referenceBounds:o}=this._current,{boxBorderLineColor:c,boxBackgroundColor:u}=this.evaluatedMeshParams,d=e.clone(),l=e.angle*(180/Math.PI)%360,h=(e.angle*(180/Math.PI)+180)%360,p=n.glyphs.length>0&&!(!c&&!u);if(i.metricStart(this._createLineLabelMetric(s,e.x,e.y)),p){const y=Math.max(t,r[0],0),f=Math.min(H,r[1]),m=Q(B(),-e.angle),_={minZoom:y,maxZoom:f,clipAngle:l,mapAligned:!0,isLineLabel:!0},g=$(this.evaluatedMeshParams.offsetX),v=$(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const x=O(g,-1*v),[M,P]=n.shapeBackground(ae(B(),m,x));i.recordStart(this.instanceId,this.attributeLayout,n.glyphs[0].textureBinding);const I=2*Math.max(M.width,M.height);i.recordBounds(e.x+M.x,e.y+M.y,I,I),this._writeTextBox(i,s,e.x,e.y,P,o,_),i.recordEnd()}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const x=O(g,v),[M,P]=n.shapeBackground(ae(B(),m,x));_.clipAngle=h,i.recordStart(this.instanceId,this.attributeLayout,n.glyphs[0].textureBinding);const I=2*Math.max(M.width,M.height);i.recordBounds(e.x+M.x,e.y+M.y,I,I),this._writeTextBox(i,s,e.x,e.y,P,o,_),i.recordEnd()}}this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(d,t,1,l,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(d,t,0,h,!0),i.metricEnd()}_placeBack(e,t,i,s,n,r){const o=e.clone();let c=e.backwardLength+L;for(;o.prev()&&!(c>=s);)this._placeOnSegment(o,t,c,i,-1,n,r),c+=o.length+L}_placeForward(e,t,i,s,n,r){const o=e.clone();let c=e.remainingLength+L;for(;o.next()&&!(c>=s);)this._placeOnSegment(o,t,c,i,1,n,r),c+=o.length+L}_placeFirst(e,t,i,s,n=!1){const{out:r,id:o,shaping:c,zoomRange:u,referenceBounds:d}=this._current,l=c.glyphs,h=$(this.evaluatedMeshParams.offsetX),p=$(this.evaluatedMeshParams.offsetY),y=O(h,p),f=Q(B(),-e.angle);ce(y,y,f);for(const m of l){const _=m.x>c.bounds.x?i:1-i,g=_*e.remainingLength+(1-_)*e.backwardLength,v=Math.abs(m.x+m.width/2-c.bounds.x),x=Math.max(0,this._zoomLevel+Math.log2(v/(g+L))),M=Math.max(t,n?0:x);if(m.maxZoom=Math.min(u[1],H),m.angle=e.angle+(1-i)*Math.PI,m.minZoom=Math.max(u[0],M),this._writeLineGlyph(r,o,e.x,e.y,c.bounds,m,s,d,!0),(i||this._current.offsetDirection)&&this._isVisible(m.minZoom,m.maxZoom)){const P=new de(m.bounds.x+y[0],m.bounds.y+y[1],m.bounds.width,m.bounds.height);r.metricBoxWrite(P)}}}_placeOnSegment(e,t,i,s,n,r,o){const{out:c,id:u,shaping:d,referenceBounds:l}=this._current,h=d.glyphs,p=e.dx/e.length,y=e.dy/e.length,f={x:e.x+i*-n*p,y:e.y+i*-n*y},m=$(this.evaluatedMeshParams.offsetX),_=$(this.evaluatedMeshParams.offsetY),g=O(m,_),v=Q(B(),-e.angle);ce(g,g,v);for(const x of h){const M=x.x>d.bounds.x?r:1-r;if(!(M&&n===1||!M&&n===-1))continue;const P=Math.abs(x.x+x.width/2-d.bounds.x),I=Math.max(0,this._zoomLevel+Math.log2(P/i)-.1),D=Math.max(s,this._zoomLevel+Math.log2(P/(i+e.length+L)));if(I!==0&&(x.angle=e.angle+(1-r)*Math.PI,x.minZoom=D,x.maxZoom=I,this._writeLineGlyph(c,u,f.x,f.y,d.bounds,x,o,l,!0),(r||this._current.offsetDirection)&&this._isVisible(x.minZoom,x.maxZoom))){const Ie=new de(x.bounds.x+g[0],x.bounds.y+g[1],x.bounds.width,x.bounds.height);c.metricBoxWrite(Ie)}}}_writeLineGlyph(e,t,i,s,n,r,o,c,u){const d=i+n.x,l=s+n.y,h=2*(this.evaluatedMeshParams.minPixelBuffer?this.evaluatedMeshParams.minPixelBuffer/this._textMeshTransformProps.fontSize:1),p=Math.max(n.width,n.height)*h;e.recordStart(this.instanceId,this.attributeLayout,r.textureBinding),e.recordBounds(d,l,p,p);const{texcoords:y,offsets:f}=r,{fontSize:m,haloSize:_,outlineSize:g}=this._textMeshTransformProps;this._writeQuad(e,t,i,s,{texcoords:y,offsets:f,fontSize:m,haloSize:_,outlineSize:g,color:Ee(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:c,minZoom:Math.max(this._current.zoomRange[0],r.minZoom),maxZoom:Math.min(this._current.zoomRange[1],r.maxZoom),clipAngle:o,mapAligned:u,isLineLabel:!0}),e.recordEnd()}_isVisible(e,t){const i=Math.floor(this._zoomLevel*te)/te;return e<=i&&i<=t}}function ye(a,e,t){const{coords:i,lengths:s}=e,n=z(),r=z(),o=z(),c=z(),u=z(),d=z(),l=2;let h=0;for(let p=0;p<s.length;p++){const y=s[p];for(let f=0;f<y;f++){const m=l*(f+h-1),_=l*(f+h),g=l*(f+h+1);f>0?A(n,i[m],i[m+1]):A(n,0,0),A(r,i[_],i[_+1]),f<y-1?A(o,i[g],i[g+1]):A(o,0,0),f===0?A(c,0,0):(le(c,r,n),U(c,c),A(c,c[1],-c[0])),f===y-1?A(u,0,0):(le(u,o,r),U(u,u),A(u,u[1],-u[0])),He(d,c,u),U(d,d);const v=d[0]*u[0]+d[1]*u[1];v!==0&&he(d,d,v),he(d,d,t),a.coords.push(r[0]+d[0],r[1]+d[1])}a.lengths.push(y),h+=y}return a}function Y(a){return a instanceof X?a:typeof a=="object"&&"type"in a?pt[a.type].hydrate(a):new F(a)}class X{constructor(e){this.inputs=e}encode(){const e=[];for(const t of this.inputs)e.push(...t.encode());return e.push(...this.instructions),e}}class F extends X{constructor(e){super([]),this.value=e}simplify(){return this}get instructions(){if(Array.isArray(this.value)){const[e,t,i,s]=this.value;return s!=null?E.vector4.encode([e,t||0,i||0,s]):E.vector3.encode([e,t||0,i||0])}return E.scalar.encode(this.value)}}let ft=class se extends X{constructor(e,t){super([t]),this._config=e,this._parent=t}static hydrate(e){return new se(e,Y(e.parent))}simplify(){if(this._config.relativeTranslation||this._config.absoluteScale)return this;const e=this._parent.simplify();if(!(e instanceof F))return this;const[t,i,s,n]=e.value,r=this._config.translation.from[0],o=this._config.translation.from[1],c=this._config.rotation.from,u=this._config.scale.from;if(r===this._config.translation.to[0]&&o===this._config.translation.to[1]&&c===this._config.rotation.to&&u===this._config.scale.to){const d=s+c,l=n*u,h=Math.sin(s),p=Math.cos(s);return new F([p*n*r-h*n*o+t,h*n*r+p*n*o+i,d,l])}return new se(this._config,e)}get instructions(){return E.animatedTransform.encode(this._config)}},mt=class ie extends X{constructor(e,t){super([t]),this._config=e,this._parent=t}static hydrate(e){return new ie(e,Y(e.parent))}simplify(){const e=this._parent.simplify();if(!(e instanceof F))return this;const[t,i,s,n]=e.value,r=this._config.color.from[0],o=this._config.color.from[1],c=this._config.color.from[2];let u=this._config.color.from[3];const d=this._config.opacity.from;return r===this._config.color.to[0]&&o===this._config.color.to[1]&&c===this._config.color.to[2]&&u===this._config.color.to[3]&&d===this._config.opacity.to?(u*=d,new F([t*r,i*o,s*c,n*u])):new ie(this._config,e)}get instructions(){return E.animatedColor.encode(this._config)}};const pt={AnimatedTransform:ft,AnimatedColor:mt};function yt(a){return be(a.map(e=>w(e)).map(e=>Y(e).simplify()))}function _t(a){const e=[];return e.push(a.transform),e.push(a.fromColor),e.push(a.toColor),e.push(a.colorMix),e.push(a.toOpacity),e.push(a.opacityMix),e}function be(a){const e=[],t=[];let i=0;for(const s of a){const n=[...s.encode(),...E.ret.encode()];e.push([i+a.length,0,0,0]),t.push(...n),i+=n.length}return[...e,...t]}async function re(a,e){const t=a;let i;if(typeof t=="number"||typeof t=="string"||typeof t=="boolean")i=t;else if(Array.isArray(t))i=await Promise.all(t.map(s=>re(s,e)));else if(typeof t=="object")if("valueExpressionInfo"in t){const{valueExpressionInfo:s}=t,{expression:n}=s;i={...t,computed:await e.createComputedField({expression:n})}}else{i={};for(const s in t)i[s]=await re(t[s],e)}return i}function w(a,e,t){function i(r){if(!("computed"in r))return r;let o=r.computed.readWithDefault(e,t,[255*r.defaultValue[0],255*r.defaultValue[1],255*r.defaultValue[2],r.defaultValue[3]]);if(typeof o=="string"){const c=Se.fromString(o);c&&(o=[c.r,c.g,c.b,c.a])}return o}const s=a;let n;if(typeof s=="number"||typeof s=="string"||typeof s=="boolean")n=s;else if(Array.isArray(s))n=s.map(r=>w(r,e,t));else if(typeof s=="object")if("type"in s&&s.type!=null&&s.type==="Process")switch(s.op){case"ArcadeColor":{const r=w(s.value,e,t);j(Array.isArray(r)&&r.length===4),n=[r[0]/255,r[1]/255,r[2]/255,r[3]]}break;case"Transparency":{const r=w(s.value,e,t);j(typeof r=="number"),n=1-r/100}break;case"Divide":case"Add":{const r=w(s.left,e,t);j(typeof r=="number");const o=w(s.right,e,t);switch(j(typeof o=="number"),s.op){case"Divide":n=r/o;break;case"Add":n=r+o}}break;case"Random":{const r=w(s.seed,e,t),o=w(s.min,e,t),c=w(s.max,e,t),u=e.getObjectId(),d=ve(u||0);n=o+Ke(d,r)*(c-o)}break;case"Cond":{const r=w(s.condition,e,t),o=w(s.ifTrue,e,t),c=w(s.ifFalse,e,t);n=r?o:c}break;case"MatchWinding":{const r=w(s.sign,e,t);let o=w(s.angle,e,t);if(r>0)for(;o<0;)o+=2*Math.PI;else for(;o>0;)o-=2*Math.PI;n=o}}else if("computed"in s)n=i(s);else{n={};for(const r in s)n[r]=w(s[r],e,t)}return n}function*k(a){const e=a;if(Array.isArray(e))for(const t of e)yield*k(t);else if(typeof e=="object")if("type"in e&&e.type!=null&&e.type==="Process")switch(e.op){case"ArcadeColor":case"Transparency":yield*k(e.value);break;case"Divide":case"Add":yield*k(e.left),yield*k(e.right);break;case"Random":yield*k(e.seed),yield*k(e.min),yield*k(e.max);break;case"Cond":yield*k(e.condition),yield*k(e.ifTrue),yield*k(e.ifFalse);break;case"MatchWinding":yield*k(e.sign),yield*k(e.angle)}else if("computed"in e)yield e.computed;else for(const t in e)yield*k(e[t])}function j(a){if(!a)throw new Error("Assertion failed.")}class gt extends tt{constructor(e){super(),this._value=e}resize(e){}read(e,t){return this._value}readWithDefault(e,t,i){return this._value}hasArcadeDependency(e){return!1}}const xt=()=>ze.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator");async function N(a,e,t=!1){const{defaultValue:i,valueExpressionInfo:s,value:n}=e;if(s){const{expression:r}=s,o=await a.createComputedField({expression:r},t);return o?{...e,computed:o,defaultValue:i}:null}return{...e,computed:new gt(n),defaultValue:i}}async function _e(a,e){const{valueExpressionInfo:t}=e,{expression:i}=t,s=await a.createComputedField({expression:i});return s?{...e,computed:s}:null}function we(a){return typeof a=="object"&&a!=null&&(!(!("valueExpressionInfo"in a)||!a.valueExpressionInfo)||"type"in a&&a.type==="Process"&&"op"in a&&a.op==="Random")}function Z(a){if(Array.isArray(a)){for(const e of a)if(Z(e))return!0}if(typeof a=="object"){if(we(a))return!0;for(const e in a)if(Z(a[e]))return!0}return!1}class ne{static async create(e,t,i){const s={},n=new Map,r=new Map,o=new Map,c=new Map,u=new Map,d=new Map;for(const l in i){const h=i[l];if(h!=null&&typeof h=="object")if(Array.isArray(h)){if(typeof h[0]=="object")throw new Error(`InternalError: Cannot handle ${l}. Nested array params are not supported`);s[l]=h}else if("valueExpressionInfo"in h){if(h.value){s[l]=h.value;continue}const p=await _e(e,h);if(!p){s[l]=h.defaultValue;continue}n.set(l,p),s[l]=null}else switch(h.type){case"cim-effect-infos":if(h.effectInfos.some(p=>p.overrides.length)){r.set(l,{effects:await Promise.all(h.effectInfos.map(async p=>{const y=p.overrides.map(f=>N(e,f));return{effect:p.effect,compiledOverrides:(await Promise.all(y)).filter(C)}}))});break}s[l]=h.effectInfos.map(p=>p.effect);break;case"cim-marker-placement-param":h.overrides.length&&o.set(l,{placementInfo:h,compiledOverrides:(await Promise.all(h.overrides.map(p=>N(e,p)))).filter(C)}),s[l]=h.placement;break;case"text-rasterization-param":{if(h.overrides.length){const y=h.overrides.map(f=>N(e,f,h.useLegacyLabelEvaluationRules));c.set(l,{compiledOverrides:(await Promise.all(y)).filter(C),rasterizationParam:h,objectIdToResourceId:new Map});continue}const p={type:"cim-rasterization-info",resource:h.resource};s[l]=await t.fetchResourceImmediate(p)??null;break}case"sprite-rasterization-param":{if(h.overrides.length){const y=h.overrides.map(f=>N(e,f));c.set(l,{compiledOverrides:(await Promise.all(y)).filter(C),rasterizationParam:h,objectIdToResourceId:new Map});continue}if(h.resource.type==="animated"){c.set(l,{compiledOverrides:[],rasterizationParam:h,objectIdToResourceId:new Map});continue}const p={type:"cim-rasterization-info",resource:h.resource};s[l]=await t.fetchResourceImmediate(p)??null;break}case"cim-marker-transform-param":{const{params:p}=h;if(Z(p)){const y={compiledMarkerInfos:[]};await Promise.all(p.map(async f=>{const m={props:{}};for(const _ in f)if(we(f[_])){const g=await _e(e,f[_]);m.compiledExpressionMap||(m.compiledExpressionMap=new Map);const v=m.compiledExpressionMap;g&&v.set(_,g)}else m.props[_]=f[_];y.compiledMarkerInfos.push(m)})),u.set(l,y)}else s[l]={type:"cim-marker-transform-info",infos:p};break}case"animation-params":{const{params:p}=h,y=_t(p);if(Z(y)){const f=await Promise.all(y.map(m=>re(m,e)));d.set(l,{params:f,propertyIdToResourceId:new Map,key:l})}else{const f=yt(y),m=await t.fetchResourceImmediate({type:"animation-info",resource:f});m!=null&&m.type==="sprite"&&(s[l]={dataRow:m.rect.y,dataColumn:m.rect.x})}break}default:s[l]=h}else s[l]=h}return new ne(i,s,n,r,o,c,u,d)}constructor(e,t,i,s,n,r,o,c){this.inputMeshParams=e,this._resolvedMeshParams=t,this._dynamicProperties=i,this._dynamicEffectProperties=s,this._dynamicPlacementProperties=n,this._dynamicAsyncProperties=r,this._dynamicTransformProperties=o,this._dynamicAsyncAnimations=c,this.evaluator=u=>u,this._arcadeDependencies=new Set;for(const u of this._expressions())Ae(this._arcadeDependencies,u)}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size||this._dynamicAsyncAnimations.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(e,t,i){for(const s of this._dynamicAsyncProperties.values()){const n=$e(s.rasterizationParam.resource);s.rasterizationParam.resource.type==="animated"&&s.rasterizationParam.resource.randomizeStartTime&&(n.primitiveName="__RESERVED__PRIMITIVE__NAME__",n.startGroup=ve(t.getObjectId()||0));for(const{primitiveName:o,propertyName:c,computed:u,defaultValue:d,valueExpressionInfo:l}of s.compiledOverrides)try{const h=s.rasterizationParam.resource.type==="animated"?n.primitiveName:o;et(n,h,c,u,t,i,d)}catch(h){xt().errorOnce(new De("invalid-arcade-expression",`Encountered an error when evaluating the arcade expression '${l?.expression}' (primitive: '${o}', property: '${c}')`,h))}const r=e.enqueueRequest({type:"cim-rasterization-info",resource:n});s.objectIdToResourceId.set(t.getObjectId(),r)}for(const s of this._dynamicAsyncAnimations.values()){const n=s.params.map(c=>w(c,t,i)).map(Y).map(c=>c.simplify()),r=be(n),o=e.enqueueRequest({type:"animation-info",resource:r});s.propertyIdToResourceId.set(t.getObjectId()+"."+s.key,o)}}evaluateMeshParams(e,t,i){for(const[s,n]of this._dynamicProperties.entries())this._resolvedMeshParams[s]=n.computed.readWithDefault(t,i,n.defaultValue);for(const[s,n]of this._dynamicPlacementProperties.entries())for(const{computed:r,defaultValue:o,propertyName:c}of n.compiledOverrides){const u=r.readWithDefault(t,i,o);n.placementInfo.placement[c]=u,this._resolvedMeshParams[s]=n.placementInfo.placement}for(const[s,n]of this._dynamicEffectProperties.entries())for(const r of n.effects){for(const{computed:o,defaultValue:c,propertyName:u}of r.compiledOverrides){const d=o.readWithDefault(t,i,c);r.effect[u]=d}this._resolvedMeshParams[s]=n.effects.map(o=>o.effect)}for(const[s,n]of this._dynamicTransformProperties.entries()){const r={type:"cim-marker-transform-info",infos:[]};for(const o of n.compiledMarkerInfos){const c={...o.props};if(o.compiledExpressionMap)for(const[u,d]of o.compiledExpressionMap){const l=d.computed.readWithDefault(t,i,d.defaultValue);c[u]=typeof l=="number"||typeof l=="boolean"?l:d.defaultValue}r.infos.push(c)}this._resolvedMeshParams[s]=r}for(const[s,n]of this._dynamicAsyncProperties.entries()){const r=n.objectIdToResourceId.get(t.getObjectId());if(r==null)continue;const o=e.getResource(r);this._resolvedMeshParams[s]=o}for(const[s,n]of this._dynamicAsyncAnimations.entries()){const r=n.propertyIdToResourceId.get(t.getObjectId()+"."+s);if(r==null)continue;const o=e.getResource(r);this._resolvedMeshParams[s]={dataRow:o.rect.y,dataColumn:o.rect.x}}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}hasArcadeDependency(e){return this._arcadeDependencies.has(e)}*_expressions(){for(const e of this._dynamicProperties.values())yield e.computed;for(const e of this._dynamicEffectProperties.values())for(const t of e.effects)for(const i of t.compiledOverrides)yield i.computed;for(const e of this._dynamicPlacementProperties.values())for(const t of e.compiledOverrides)yield t.computed;for(const e of this._dynamicAsyncProperties.values())for(const t of e.compiledOverrides)yield t.computed;for(const e of this._dynamicTransformProperties.values())for(const t of e.compiledMarkerInfos)if(t.compiledExpressionMap!=null)for(const i of t.compiledExpressionMap.values())yield i.computed;for(const e of this._dynamicAsyncAnimations.values())for(const t of e.params)yield*k(t)}}class Vt{async createMeshWriter(e,t,i,s){const n=this._getMeshWriter(s.techniqueType),r=await ne.create(e,t,s.inputParams),o=new n(s.id,r,s.optionalAttributes,i);return await o.loadDependencies(),o}_getMeshWriter(e){switch(e){case b.Fill:return Ye;case b.DotDensity:return Ze;case b.ComplexFill:return qe;case b.PatternFill:return Ne;case b.GradientFill:return je;case b.OutlineFill:return Ve;case b.PatternOutlineFill:return We;case b.ComplexOutlineFill:return Oe;case b.Marker:return Ge;case b.PieChart:return Ce;case b.Text:return xe;case b.Line:return Fe;case b.TexturedLine:return Be;case b.GradientStroke:return Re;case b.Heatmap:return Te;case b.Label:return dt;case b.AnimatedMarker:return rt;default:throw new Error("Internal Error: Mesh writer not in the registry")}}}export{Vt as F,gt as r};
