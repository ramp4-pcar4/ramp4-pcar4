import{n as Y,fy as R,bS as _,ap as Q,aN as Z,c5 as H,O as J,bq as K,s as U}from"./main-D6UWMbWJ.js";import{r as k}from"./TimeExtent-CVFHym4n.js";import{j as W}from"./quantizationUtils-B28qRRbX.js";import{l as X,u as nn}from"./heatmapUtils-D0UuwfRb.js";import{$ as en}from"./utils-Dn8cinQn.js";import{d as tn}from"./ClassBreaksDefinition-Pel3RCn0.js";const ln=()=>Y.getLogger("esri.rest.support.generateRendererUtils");function M(n,e){return Number(n.toFixed(e))}function Jn(n){const e=G(n),t=[],a=e.uniqueValues.length;for(let l=0;l<a;l++){const s=e.uniqueValues[l],r=e.valueFrequency[l],i=s.toString();t.push({value:s,count:r,label:i})}return{uniqueValues:t}}function an(n,e){const{normalizationTotal:t}=n;return{classBreaks:on(n,e),normalizationTotal:t}}function on(n,e){const t=n.definition,{classificationMethod:a,normalizationType:l,definedInterval:s}=t,r=t.breakCount??1,i=[];let c=n.values;if(c.length===0)return[];c=c.sort((f,o)=>f-o);const[h,d]=e??[c.at(0),c.at(-1)];if(a==="equal-interval")if(c.length>=r){const f=(d-h)/r;let o=h;for(let u=1;u<r;u++){const m=M(h+u*f,6);i.push({minValue:o,maxValue:m,label:v(o,m,l)}),o=m}i.push({minValue:o,maxValue:d,label:v(o,d,l)})}else c.forEach(f=>{i.push({minValue:f,maxValue:f,label:v(f,f,l)})});else if(a==="natural-breaks"){const f=G(c),o=n.valueFrequency||f.valueFrequency,u=un(f.uniqueValues,o,r);let m=h;for(let p=1;p<r;p++)if(f.uniqueValues.length>p){const g=M(f.uniqueValues[u[p]],6);i.push({minValue:m,maxValue:g,label:v(m,g,l)}),m=g}i.push({minValue:m,maxValue:d,label:v(m,d,l)})}else if(a==="quantile")if(c.length>=r&&h!==d){let f=h,o=Math.ceil(c.length/r),u=0;for(let m=1;m<r;m++){let p=o+u-1;p>c.length&&(p=c.length-1),p<0&&(p=0),i.push({minValue:f,maxValue:c[p],label:v(f,c[p],l)}),f=c[p],u+=o,o=Math.ceil((c.length-u)/(r-m))}i.push({minValue:f,maxValue:d,label:v(f,d,l)})}else{let f=-1;for(let o=0;o<c.length;o++){const u=c[o];u!==f&&(f=u,i.push({minValue:f,maxValue:u,label:v(f,u,l)}),f=u)}}else if(a==="standard-deviation"){const f=cn(c),o=fn(c,f);if(o===0)i.push({minValue:c[0],maxValue:c[0],label:v(c[0],c[0],l)});else{const u=sn(h,d,r,f,o)*o;let m=0,p=h;for(let V=r;V>=1;V--){const x=M(f-(V-.5)*u,6);i.push({minValue:p,maxValue:x,label:v(p,x,l)}),p=x,m++}let g=M(f+.5*u,6);i.push({minValue:p,maxValue:g,label:v(p,g,l)}),p=g,m++;for(let V=1;V<=r;V++)g=m===2*r?d:M(f+(V+.5)*u,6),i.push({minValue:p,maxValue:g,label:v(p,g,l)}),p=g,m++}}else if(a==="defined-interval"){if(!s)return i;const[f,o]=e??[c.at(0),c.at(-1)],u=Math.ceil((o-f)/s);let m=f;for(let p=1;p<u;p++){const g=M(f+p*s,6);i.push({minValue:m,maxValue:g,label:v(m,g,l)}),m=g}i.push({minValue:m,maxValue:o,label:v(m,o,l)})}return i}function v(n,e,t){let a=null;return a=n===e?t&&t==="percent-of-total"?n+"%":n.toString():t&&t==="percent-of-total"?n+"% - "+e+"%":n+" - "+e,a}function G(n){const e=[],t=[];let a=Number.MIN_VALUE,l=1,s=-1;for(let r=0;r<n.length;r++){const i=n[r];i===a?(l++,t[s]=l):i!==null&&(e.push(i),a=i,l=1,t.push(l),s++)}return{uniqueValues:e,valueFrequency:t}}function un(n,e,t){const a=n.length,l=[];t>a&&(t=a);for(let r=0;r<t;r++)l.push(Math.round(r*a/t-1));l.push(a-1);let s=O(l,n,e,t);return rn(s.mean,s.sdcm,l,n,e,t)&&(s=O(l,n,e,t)),l}function O(n,e,t,a){let l=[],s=[],r=[],i=0;const c=[],h=[];for(let u=0;u<a;u++){const m=N(u,n,e,t);c.push(m.sbMean),h.push(m.sbSdcm),i+=h[u]}let d,f=i,o=!0;for(;o||i<f;){o=!1,l=[];for(let u=0;u<a;u++)l.push(n[u]);for(let u=0;u<a;u++)for(let m=n[u]+1;m<=n[u+1];m++)if(d=e[m],u>0&&m!==n[u+1]&&Math.abs(d-c[u])>Math.abs(d-c[u-1]))n[u]=m;else if(u<a-1&&n[u]!==m-1&&Math.abs(d-c[u])>Math.abs(d-c[u+1])){n[u+1]=m-1;break}f=i,i=0,s=[],r=[];for(let u=0;u<a;u++){s.push(c[u]),r.push(h[u]);const m=N(u,n,e,t);c[u]=m.sbMean,h[u]=m.sbSdcm,i+=h[u]}}if(i>f){for(let u=0;u<a;u++)n[u]=l[u],c[u]=s[u],h[u]=r[u];i=f}return{mean:c,sdcm:h}}function rn(n,e,t,a,l,s){let r=0,i=0,c=0,h=0,d=!0;for(let f=0;f<2&&d;f++){f===0&&(d=!1);for(let o=0;o<s-1;o++)for(;t[o+1]+1!==t[o+2];){t[o+1]=t[o+1]+1;const u=N(o,t,a,l);c=u.sbMean,r=u.sbSdcm;const m=N(o+1,t,a,l);if(h=m.sbMean,i=m.sbSdcm,!(r+i<e[o]+e[o+1])){t[o+1]=t[o+1]-1;break}e[o]=r,e[o+1]=i,n[o]=c,n[o+1]=h,d=!0}for(let o=s-1;o>0;o--)for(;t[o]!==t[o-1]+1;){t[o]=t[o]-1;const u=N(o-1,t,a,l);c=u.sbMean,r=u.sbSdcm;const m=N(o,t,a,l);if(h=m.sbMean,i=m.sbSdcm,!(r+i<e[o-1]+e[o])){t[o]=t[o]+1;break}e[o-1]=r,e[o]=i,n[o-1]=c,n[o]=h,d=!0}}return d}function sn(n,e,t,a,l){let s=Math.max(a-n,e-a)/l/t;return s=s>=1?1:s>=.5?.5:.25,s}function cn(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e/=n.length,e}function fn(n,e){let t=0;for(let a=0;a<n.length;a++){const l=n[a];t+=(l-e)*(l-e)}return t/=n.length,Math.sqrt(t)}function N(n,e,t,a){let l=0,s=0;for(let c=e[n]+1;c<=e[n+1];c++){const h=a[c];l+=t[c]*h,s+=h}s<=0&&ln().warn("Exception in Natural Breaks calculation");const r=l/s;let i=0;for(let c=e[n]+1;c<=e[n+1];c++)i+=a[c]*(t[c]-r)**2;return{sbMean:r,sbSdcm:i}}const mn="<Null>",dn="equal-interval",pn=1,hn=5,gn=10,bn=/\s*(\+|-)?((\d+(\.\d+)?)|(\.\d+))\s*/gi,Vn=new Set(["esriFieldTypeDate","esriFieldTypeInteger","esriFieldTypeSmallInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeOID","esriFieldTypeBigInteger"]),vn=new Set(["esriFieldTypeTimeOnly","esriFieldTypeDateOnly"]),xn=["min","max","avg","stddev","count","sum","variance","nullcount","median"];function T(n){return n==null||typeof n=="string"&&!n?mn:n}function yn(n){const e=n.normalizationField!=null||n.normalizationType!=null,t=n.minValue!=null||n.maxValue!=null,a=!!n.sqlExpression&&n.supportsSQLExpression;return!e&&!t&&!a}function Kn(n){const{outStatisticTypes:e}=n,t=n.returnDistinct?[...new Set(n.values)]:n.values,a=t.filter(r=>r!=null).sort(),l=a.length,s={count:l,min:a[0],max:a[l-1]};return n.supportsNullCount&&(s.nullcount=t.length-l),!n.percentileParams||e?.include?.length&&!e.include.includes("median")||e?.exclude?.length&&e.exclude.includes("median")||(s.median=P(t,n.percentileParams)),s}function $n(n){const{values:e,useSampleStdDev:t,supportsNullCount:a,outStatisticTypes:l}=n;let s=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY,i=null,c=null,h=null,d=null,f=0;const o=n.minValue==null?-1/0:n.minValue,u=n.maxValue==null?1/0:n.maxValue;for(const p of e)Number.isFinite(p)?p>=o&&p<=u&&(i=i===null?p:i+p,s=Math.min(s,p),r=Math.max(r,p),f++):typeof p=="string"&&f++;if(f&&i!=null){c=i/f;let p=0;for(const g of e)Number.isFinite(g)&&g>=o&&g<=u&&(p+=(g-c)**2);d=t?f>1?p/(f-1):0:f>0?p/f:0,h=Math.sqrt(d)}else s=null,r=null;const m={avg:c,count:f,max:r,min:s,stddev:h,sum:i,variance:d};return a&&(m.nullcount=e.length-f),!n.percentileParams||l?.include?.length&&!l.include.includes("median")||l?.exclude?.length&&l.exclude.includes("median")||(m.median=P(e,n.percentileParams)),m}function P(n,e){const{fieldType:t,value:a,orderBy:l,isDiscrete:s}=e,r=Tn(t,l==="desc");if((n=[...n].filter(u=>u!=null).sort((u,m)=>r(u,m))).length===0)return null;if(a<=0)return n[0];if(a>=1)return n[n.length-1];const i=(n.length-1)*a,c=Math.floor(i),h=c+1,d=i%1,f=n[c],o=n[h];return h>=n.length||s||typeof f=="string"||typeof o=="string"?f:f*(1-d)+o*d}function Tn(n,e){if(n){if(Vn.has(n))return j(e);if(vn.has(n))return C(e,!1);if(n==="esriFieldTypeTimestampOffset")return Mn(e);const r=C(e,!0);if(n==="esriFieldTypeString")return r;if(n==="esriFieldTypeGUID"||n==="esriFieldTypeGlobalID")return(i,c)=>r(B(i),B(c))}const t=e?1:-1,a=j(e),l=C(e,!0),s=L(e);return(r,i)=>typeof r=="number"&&typeof i=="number"?a(r,i):typeof r=="string"&&typeof i=="string"?l(r,i):s(r,i)??t}const w=(n,e)=>n==null?e==null?0:1:e==null?-1:null,D=(n,e)=>n==null?e==null?0:-1:e==null?1:null;function L(n){return n?w:D}const Fn=(n,e)=>D(n,e)??(n===e?0:new Date(n).getTime()-new Date(e).getTime()),In=(n,e)=>w(n,e)??(n===e?0:new Date(e).getTime()-new Date(n).getTime());function Mn(n){return n?In:Fn}const Nn=(n,e)=>D(n,e)??(n===e?0:n<e?-1:1),zn=(n,e)=>w(n,e)??(n===e?0:n<e?1:-1);function C(n,e){if(!e)return n?zn:Nn;const t=L(n);return n?(a,l)=>{const s=t(a,l);return s??((a=a.toUpperCase())>(l=l.toUpperCase())?-1:a<l?1:0)}:(a,l)=>{const s=t(a,l);return s??((a=a.toUpperCase())<(l=l.toUpperCase())?-1:a>l?1:0)}}const Sn=(n,e)=>w(n,e)??e-n,wn=(n,e)=>D(n,e)??n-e;function j(n){return n?Sn:wn}function B(n){return n.slice(24,36)+n.slice(19,23)+n.slice(16,18)+n.slice(14,16)+n.slice(11,13)+n.slice(9,11)+n.slice(6,8)+n.slice(4,6)+n.slice(2,4)+n.slice(0,2)}function Wn(n,e,t){let a;for(a in n)e?.include?.length&&!e.include.includes(a)||e?.exclude?.length&&e.exclude.includes(a)?delete n[a]:xn.includes(a)&&(Number.isFinite(n[a])||(n[a]=null));return t&&["avg","stddev","variance"].forEach(l=>{n[l]!=null&&(n[l]=Math.ceil(n[l]??0))}),n}function Xn(n){const e={};for(let t of n)(t==null||typeof t=="string"&&t.trim()==="")&&(t=null),e[t]==null?e[t]={count:1,data:t}:e[t].count++;return{count:e}}function E(n){return n?.type!=="coded-value"?[]:n.codedValues.map(e=>e.code)}function ne(n,e,t,a){const l=n.count,s=[];if(t&&e){const r=[],i=E(e[0]);for(const c of i)if(e[1]){const h=E(e[1]);for(const d of h)if(e[2]){const f=E(e[2]);for(const o of f)r.push(`${T(c)}${a}${T(d)}${a}${T(o)}`)}else r.push(`${T(c)}${a}${T(d)}`)}else r.push(c);for(const c of r)l.hasOwnProperty(c)||(l[c]={data:c,count:0})}for(const r in l){const i=l[r];s.push({value:i.data,count:i.count,label:i.label})}return{uniqueValueInfos:s}}function Dn(n,e,t,a){let l=null;switch(e){case"log":n!==0&&(l=Math.log(n)*Math.LOG10E);break;case"percent-of-total":Number.isFinite(a)&&a!==0&&(l=n/a*100);break;case"field":Number.isFinite(t)&&t!==0&&(l=n/t);break;case"natural-log":n>0&&(l=Math.log(n));break;case"square-root":n>0&&(l=n**.5)}return l}function qn(n,e,t){const a=Cn({field:e.field,normalizationType:e.normalizationType,normalizationField:e.normalizationField,classificationMethod:e.classificationMethod,standardDeviationInterval:e.standardDeviationInterval,definedInterval:e.definedInterval,breakCount:e.numClasses||hn});return n=kn(n,e.minValue,e.maxValue),an({definition:a,values:n,normalizationTotal:e.normalizationTotal},t)}function kn(n,e,t){const a=e??-1/0,l=t??1/0;return n.filter(s=>Number.isFinite(s)&&s>=a&&s<=l)}function Cn(n){const{breakCount:e,field:t,normalizationField:a,normalizationType:l}=n,s=n.classificationMethod||dn,r=s==="standard-deviation"?n.standardDeviationInterval||pn:void 0,i=s==="defined-interval"?n.definedInterval:void 0;return new tn({breakCount:e,classificationField:t,classificationMethod:s,normalizationField:l==="field"?a:void 0,normalizationType:l,standardDeviationInterval:r,definedInterval:i})}function ee(n,e){let t=n.classBreaks;const a=t.length,l=t[0]?.minValue,s=t[a-1]?.maxValue,r=e==="standard-deviation",i=bn;return t=t.map(c=>{const h=c.label,d={minValue:c.minValue,maxValue:c.maxValue,label:h};if(r&&h){const f=h.match(i),o=f?.map(u=>+u.trim())??[];o.length===2?(d.minStdDev=o[0],d.maxStdDev=o[1],o[0]<0&&o[1]>0&&(d.hasAvg=!0)):o.length===1&&(h.includes("<")?(d.minStdDev=null,d.maxStdDev=o[0]):h.includes(">")&&(d.minStdDev=o[0],d.maxStdDev=null))}return d}),{minValue:l,maxValue:s,classBreakInfos:t,normalizationTotal:n.normalizationTotal}}function te(n,e){const t=En(n,e);if(t.min==null&&t.max==null)return{bins:[],minValue:t.min,maxValue:t.max,normalizationTotal:e.normalizationTotal};const a=t.intervals,l=t.min??0,s=t.max??0,r=a.map((i,c)=>({minValue:a[c][0],maxValue:a[c][1],count:0}));for(const i of n)if(i!=null&&i>=l&&i<=s){const c=Un(a,i);c>-1&&r[c].count++}return{bins:r,minValue:l,maxValue:s,normalizationTotal:e.normalizationTotal}}function En(n,e,t=!1){const{field:a,classificationMethod:l,standardDeviationInterval:s,definedInterval:r,normalizationType:i,normalizationField:c,normalizationTotal:h,minValue:d,maxValue:f}=e,o=e.numBins||gn;let u=null,m=null,p=null;if((!l||l==="equal-interval")&&!i){if(d!=null&&f!=null)u=d,m=f;else{const g=$n({values:n,minValue:d,maxValue:f,useSampleStdDev:!i,supportsNullCount:yn({normalizationType:i,normalizationField:c,minValue:d,maxValue:f})});u=g.min??null,m=g.max??null}p=On(u??0,m??0,o)}else{const{classBreaks:g}=qn(n,{field:a,normalizationType:i,normalizationField:c,normalizationTotal:h,classificationMethod:l,standardDeviationInterval:s,definedInterval:r,minValue:d,maxValue:f,numClasses:o},d!=null&&f!=null?[d,f]:void 0);u=g[0]?.minValue,m=g[g.length-1]?.maxValue,p=g.map(V=>[V.minValue,V.maxValue])}if(t){const g=p.at(-1)[1];p.push([g,g])}return{min:u,max:m,intervals:p}}function Un(n,e){let t=-1;for(let a=n.length-1;a>=0;a--)if(e>=n[a][0]){t=a;break}return t}function On(n,e,t){const a=(e-n)/t,l=[];let s,r=n;for(let i=1;i<=t;i++)s=r+a,s=Number(s.toFixed(16)),l.push([r,i===t?e:s]),r=s;return l}let $=null;const jn=/^(?<hh>([0-1][0-9])|([2][0-3])):(?<mm>[0-5][0-9])(:(?<ss>[0-5][0-9]))?([.](?<ms>\d+))?$/;function Bn(n,e,t){return n.x<0?n.x+=e:n.x>t&&(n.x-=e),n}function le(n,e,t,a){const l=R(t)?_(t):null,s=l?Math.round((l.valid[1]-l.valid[0])/e.scale[0]):null;return n.map(r=>{const i=new Q(r.geometry);return W(e,i,i),r.geometry=l?Bn(i,s??0,a[0]):i,r})}function ae(n,e=18,t,a,l){const s=new Float64Array(a*l);e=Math.round(K(e));let r=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY;const c=nn(t);for(const{geometry:h,attributes:d}of n){const{x:f,y:o}=h,u=Math.max(0,f-e),m=Math.max(0,o-e),p=Math.min(l,o+e),g=Math.min(a,f+e),V=+c(d);for(let x=m;x<p;x++)for(let F=u;F<g;F++){const z=x*a+F,S=X(F-f,x-o,e)*V,y=s[z]+=S;r=Math.min(r,y),i=Math.max(i,y)}}return{min:r,max:i}}function Gn(n){const e=jn.exec(n);if(!e)return null;const{hh:t,mm:a,ss:l,ms:s}=e.groups;return Number(t)*k.hours+Number(a)*k.minutes+Number(l)*k.seconds+Number(s||0)}async function ie(n,e,t=!0){if(!e)return[];const{field:a,field2:l,field3:s,fieldDelimiter:r,fieldInfos:i,timeZone:c}=n,h=a&&i?.find(y=>y.name.toLowerCase()===a.toLowerCase()),d=!!h&&Z(h),f=!!h&&en(h),o=n.valueExpression,u=n.normalizationType,m=n.normalizationField,p=n.normalizationTotal,g=[],V=n.viewInfoParams;let x=null,F=null;if(o){if(!$){const{arcadeUtils:y}=await H();$=y}$.hasGeometryOperations(o)&&await $.enableGeometryOperations(),x=$.createFunction(o),F=V?$.getViewInfo({viewingMode:V.viewingMode,scale:V.scale,spatialReference:new J(V.spatialReference)}):null}const z=n.fieldInfos,S=!(e[0]&&"declaredClass"in e[0]&&e[0].declaredClass==="esri.Graphic")&&z?{fields:z}:null;return e.forEach(y=>{const I=y.attributes;let b;if(o){const q=S?{...y,layer:S}:y,A=$.createExecContext(q,F,c);b=$.executeFunction(x,A)}else I&&(b=I[a],l?(b=`${T(b)}${r}${T(I[l])}`,s&&(b=`${b}${r}${T(I[s])}`)):typeof b=="string"&&t&&(f?b=b?new Date(b).getTime():null:d&&(b=b?Gn(b):null)));if(u&&typeof b=="number"&&isFinite(b)){const q=I&&parseFloat(I[m]);b=Dn(b,u,q,p)}g.push(b)}),g}function oe(n){const e=n.field,t=n.normalizationType,a=n.normalizationField;let l;return t==="field"?l="(NOT "+a+" = 0)":t!=="log"&&t!=="natural-log"&&t!=="square-root"||(l=`(${e} > 0)`),l}function ue(n,e,t){const a=e!=null?n+" >= "+e:"",l=t!=null?n+" <= "+t:"";let s="";return s=a&&l?Pn(a,l):a||l,s?"("+s+")":""}function Pn(n,e){let t=n??"";return e!=null&&e&&(t=t?"("+t+") AND ("+e+")":e),t}function re(n,e){if(n&&n.spatialRelationship!=="intersects")return new U(e,"Only 'intersects' spatialRelationship is supported for featureFilter")}function se(n,e,t){const a=Ln({layer:n,fields:e});if(a.length)return new U(t,"Unknown fields: "+a.join(", ")+". You can only use fields defined in the layer schema");const l=An({layer:n,fields:e});return l.length?new U(t,"Unsupported fields: "+l.join(", ")+". You can only use fields that can be fetched i.e. AdapterFieldUsageInfo.supportsStatistics must be true"):void 0}function Ln(n){const e=n.layer;return n.fields.filter(t=>!e.getField(t))}function An(n){const e=n.layer;return n.fields.filter(t=>{const a=e.getFieldUsageInfo(t);return!a||!a.supportsStatistics})}export{ne as $,Dn as B,Wn as C,qn as E,oe as F,En as G,Gn as I,Un as L,re as M,ue as N,ee as P,se as T,te as U,Pn as a,ie as b,xn as c,yn as d,an as e,Kn as f,Tn as g,On as j,Xn as k,T as m,Jn as n,$n as p,Cn as q,P as v,ae as w,le as x};
