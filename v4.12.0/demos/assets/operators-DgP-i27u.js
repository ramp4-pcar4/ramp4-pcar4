const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./apiConverter-DyLGqvDr.js","./ProjectionTransformation-DYBnfgxa.js","./SimpleGeometryCursor-B92kdZ15.js","./main-D6UWMbWJ.js","./preload-helper-ExcqyqRp.js","./main-DCJluy1C.css","./jsonConverter-CxSHL2F-.js","./OperatorGeodeticArea-CTojdVj6.js","./OperatorShapePreservingLength-D45tgs7e.js","./OperatorGeodeticLength-BbVoERGy.js"])))=>i.map(i=>d[i]);
import{aX as Ee,bR as F,ix as Jt,Z as L,bs as Kt,dC as R,dz as rt,dA as st,dB as te,cG as yt,cH as dt,cI as _t}from"./main-D6UWMbWJ.js";import{t as de,s as V}from"./SimpleGeometryCursor-B92kdZ15.js";import{ac as en,b as y,j as K,a as h,H as he,aZ as k,y as tn,u as nn,c as ne,bk as rn,a3 as Me,d as J,ax as me,ah as le,bl as xt,bm as ge,bn as pe,bo as fe,bp as sn,bh as De,bq as on,w as un,ad as an,v as cn,e as j,n as E,r as ot,br as z,a$ as A,bs as re,aw as se,bb as it,ay as mn,bt as ut,L as vt,bu as ln,bv as oe,B as gn,V as pn,f as fn,P as B,h as Ce,bw as hn,bx as yn,by as Se,bz as dn,b3 as _n,ab as xn,bA as vn,bB as bn,bC as $n,bD as Pn,bE as Nn,a2 as bt,C as Dn}from"./ProjectionTransformation-DYBnfgxa.js";import{getSpatialReference as v,toGeometry as w,fromGeometry as f,toPolygon as $t,fromSpatialReference as N,toPoint as _e,fromExtent as Pt,fromPolyline as Cn,fromPoint as Te}from"./apiConverter-DyLGqvDr.js";import{_ as H}from"./preload-helper-ExcqyqRp.js";import{u as Sn,a as wn,i as En,c as Mn,s as Tn}from"./operatorGeodesicBuffer-BVMLSYfM.js";import{e as ee}from"./geodeticCurveType-CirnHLSB.js";import{i as In,a as Gn,u as An,c as qn,s as On}from"./operatorGeodeticDensify-DEKE_suG.js";import{x as jn,f as Rn,l as Vn,P as Xn}from"./operatorBuffer-DAos-NC6.js";import{X as Yn,M as Bn,v as zn,_ as Ln}from"./operatorConvexHull-Bwb8xQX0.js";import{t as kn}from"./OperatorCrosses-rMqinonO.js";import{s as Fn,t as Un,o as Hn,u as Qn}from"./operatorIntersection-lwEZOiuF.js";import{t as Wn}from"./OperatorIntersects-hwzo1Ls1.js";import{D as Zn,w as Jn,j as Kn}from"./operatorOffset-DEyLTuUd.js";import{t as er}from"./OperatorOverlaps-BtZeP03Z.js";import{s as tr,t as nr,o as rr,u as sr}from"./operatorSimplify-B17Hx2_e.js";import{t as or}from"./OperatorTouches-Cmi6jtzs.js";import{s as ir,o as ur,t as ar}from"./operatorUnion-Di3B4FYi.js";import{t as cr}from"./OperatorWithin-BDVBEgCz.js";const mr={uniform:0,conformal:1,rigid:2,"rigid-motion":3,general:4},ie=t=>t.map(e=>new y(e.x,e.y));let Nt=class{constructor(){this.transform=new en}calculateErrors(e,n){const r=e.length,s=n.length;if(r!==s)throw new Error(`The input length (${r}) is not the same as output length (${s})`);const o=[];return{rms:this.transform.calculateErrors(r,ie(e),ie(n),o),errorsOut:o}}flipX(e,n){return this.transform.flipX(e,n),this}flipY(e,n){return this.transform.flipY(e,n),this}initializeFromControlPoints(e,n,r,s){const o=n.length,i=r.length;if(o!==i)throw new Error(`The input length (${o}) is not the same as output length (${i})`);this.transform.initializeFromControlPoints(mr[e],o,ie(n),ie(r),s?.transform)}isIdentity(){return this.transform.isIdentity()}rotate(e,n,r){const s=Ee(e);return n!=null&&r!=null?this.transform.rotateAngleAbout(s,new y(n,r)):this.transform.rotateAngle(s),this}scale(e,n){return this.transform.scale(e,n),this}setIdentity(){this.transform.setIdentity()}setSwapCoordinates(){return this.transform.setSwapCoordinates(),this}shear(e,n){return this.transform.shear(e,n),this}shift(e,n){return this.transform.shiftCoords(e,n),this}};const Ki=Object.freeze(Object.defineProperty({__proto__:null,default:Nt},Symbol.toStringTag,{value:"Module"}));let lr=class{getOperatorType(){return 10303}supportsCurves(){return!0}accelerateGeometry(e,n,r){return!1}canAccelerateGeometry(e){return!1}executeMany(e,n,r){return new gr(e,n,r)}execute(e,n,r){const s=e.clone();return s.applyTransformation(n),s}},gr=class extends de{constructor(e,n,r){super(),this.m_index=-1,this.m_transformation=n.clone(),this.m_inputGeometryCursor=e}next(){let e;if(e=this.m_inputGeometryCursor.next()){K(e),this.m_index=this.m_inputGeometryCursor.getGeometryID();const n=e.clone();return n.applyTransformation(this.m_transformation),n}return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}};const Ie=new lr;function pr(t,e){return Ie.execute(t,e,null)}function fr(t,e){const n=Ie.executeMany(new V(t),e,null);return Array.from(n)}function hr(){return Ie.supportsCurves()}function Dt(t,e){const n=v(t);return w(pr(f(t),e.transform),n)}function yr(t,e){const n=t.map(f),r=v(t);return fr(n,e.transform).map(s=>w(s,r)).filter(F)}const dr=hr(),nu=Object.freeze(Object.defineProperty({__proto__:null,execute:Dt,executeMany:yr,supportsCurves:dr},Symbol.toStringTag,{value:"Module"}));function _r(t,e={}){const{unit:n}=e;let r=f(t).calculateArea2D();if(r&&n){const s=v(t);if(s.isGeographic)throw new Error("Unable to convert from an angular area unit to a linear area unit.");const o=Jt(s);o!==n&&(o?r=L(r,o,n):(r=Math.sqrt(r),r*=Kt(s),r**=2,r=L(r,"square-meters",n)))}return r}const xr=!0,vr=Object.freeze(Object.defineProperty({__proto__:null,execute:_r,supportsCurves:xr},Symbol.toStringTag,{value:"Module"}));function br(t,e,n={}){const{unit:r}=n,s=v(t);return r&&(e=R(e,r,s)),$t(Rn(f(t),N(s),e),s)}function $r(t,e,n={}){let{maxDeviation:r=NaN,maxVerticesInFullCircle:s=96,union:o=!1,unit:i}=n;const u=v(t);i&&(e=e.map(c=>R(c,i,u)),r&&(r=R(r,i,u)));const a=t.map(f);return Vn(a,N(u),e,r,s,o).map(c=>$t(c,u)).filter(F)}const Pr=jn(),Nr=Object.freeze(Object.defineProperty({__proto__:null,execute:br,executeMany:$r,supportsCurves:Pr},Symbol.toStringTag,{value:"Module"}));function Dr(t,e){if(!t.isEmpty())switch(t.getGeometryType()){case h.enumPolygon:return Ct(t);case h.enumPolyline:return Sr(t);case h.enumLine:case h.enumBezier:case h.enumEllipticArc:return wr(t);case h.enumMultiPoint:return Er(t);case h.enumEnvelope:return t.getCenterXY();case h.enumPoint:return t.getXY();default:return y.construct(Number.NaN,Number.NaN)}return y.construct(Number.NaN,Number.NaN)}function Cr(t,e){return Ct(t,e)}function Ct(t,e=-1){const n=new k(0),r=new k(0),s=t.getImpl();let o;const i=s.hasNonLinearSegments();let u;const a=s.getXY(0);if(e===-1){if(u=s.calculateArea2D(),u===0)return mt(t);i&&(o=s.querySegmentIterator());for(let l=0,p=s.getPathCount();l<p;l++)at(a,s,l,n,r),i&&ct(a,o,n,r)}else{if(u=s.calculateRingArea2D(e),u===0)return mt(t,e);i&&(o=s.querySegmentIterator(),o.resetToPath(e)),at(a,s,e,n,r),i&&ct(a,o,n,r)}const c=new y,m=new y;return c.setCoords(n.getResult(),r.getResult()),m.assign(c.mul(1/u).add(a)),m}function at(t,e,n,r,s){const o=e.getPathStart(n),i=e.getPathEnd(n);if(i-o<3)return;const u=e.getAttributeStreamRef(0),a=u.readPoint2D(2*o),c=u.readPoint2D(2*(o+1));c.subThis(a);const m=new k(0),l=e.hasNonLinearSegments(),p=1/3,g=new y;for(let P=o+2;P<i;P++){u.queryPoint2D(2*P,g),g.subThis(a);const $=.5*g.crossProduct(c);l&&m.add($);const x=p*$;r.add((c.x+g.x)*x),s.add((c.y+g.y)*x),c.setCoordsPoint2D(g)}const _=l?m.getResult():e.calculateRingArea2D(n),d=a.sub(t).mul(_);r.add(d.x),s.add(d.y)}function ct(t,e,n,r){let s;for(e.nextPath()||he("centroid");(s=e.nextCurve())!==null;){const o=s.calculateWeightedAreaCentroid2D(t);n.add(o.x),r.add(o.y)}}function Sr(t){return St(t.getImpl())}function wr(t){const e=t.calculateLength2D();return e===0?t.getStartXY():t.calculateWeightedCentroid2D().mul(1/e)}function Er(t){const e=new k(0),n=new k(0),r=t.getImpl(),s=r.getAttributeStreamRef(0),o=r.getPointCount(),i=new y;for(let a=0;a<o;a++)s.queryPoint2D(2*a,i),e.add(i.x),n.add(i.y);const u=new y;return u.setCoords(e.getResult(),n.getResult()),u.divThis(o)}function mt(t,e=-1){return St(t.getImpl(),e)}function St(t,e=-1){const n=e===-1?t.calculateLength2D():t.calculatePathLength2D(e);if(n===0)return Mr(t,e);const r=new k(0),s=new k(0),o=t.querySegmentIterator();for(e!==-1&&o.resetToPath(e);o.nextPath();){const u=o.getPathIndex(),a=t.getXY(t.getPathStart(u));for(;o.hasNextSegment();){const m=o.nextSegment(),l=m.calculateLength2D();if(l===0)continue;const p=m.calculateWeightedCentroid2D().sub(a.mul(l));r.add(p.x),s.add(p.y)}const c=a.mul(t.calculatePathLength2D(u));if(r.add(c.x),s.add(c.y),e!==-1)break}const i=new y;return i.setCoords(r.getResult(),s.getResult()),i.mul(1/n)}function Mr(t,e=-1){if(e!==-1)return t.getXY(t.getPathStart(e));const n=new k(0),r=new k(0);for(let s=0;s<t.getPathCount();++s){const o=t.getXY(t.getPathStart(s));n.add(o.x),r.add(o.y)}return y.construct(n.getResult(),r.getResult()).mul(1/t.getPathCount())}let Tr=class{getOperatorType(){return 10205}accelerateGeometry(e,n,r){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}execute(e,n){return Dr(e)}};const wt=new Tr;function Ir(t){const e=wt.execute(f(t),null);return _e(e,v(t))}const Gr=wt.supportsCurves(),Ar=Object.freeze(Object.defineProperty({__proto__:null,execute:Ir,supportsCurves:Gr},Symbol.toStringTag,{value:"Module"})),Ge=new tn;function qr(t,e,n){return Ge.execute(t,e,n,null)}function Or(t,e,n){const r=Ge.executeMany(new V(t),e,n,null);return Array.from(r)}function jr(){return Ge.supportsCurves()}function Rr(t,e){const n=v(t),r=Pt(e).asEnvelope2D();return w(qr(f(t),r,N(n)),n)}function Vr(t,e){const n=t.map(f),r=v(t),s=Pt(e).asEnvelope2D();return Or(n,s,N(r)).map(o=>w(o,r))}const Xr=jr(),Yr=Object.freeze(Object.defineProperty({__proto__:null,execute:Rr,executeMany:Vr,supportsCurves:Xr},Symbol.toStringTag,{value:"Module"})),Ae=new nn;function Br(t){const e=v(t);return Ae.accelerateGeometry(f(t),N(e),1)}function zr(t,e){return Ae.execute(f(t),f(e),N(t.spatialReference),null)}const Lr=Ae.supportsCurves(),kr=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Br,execute:zr,supportsCurves:Lr},Symbol.toStringTag,{value:"Module"}));function Fr(t){const e=v(t);return w(Bn(f(t)),e)}function Ur(t,e={}){const{merge:n=!1}=e,r=t.map(f),s=v(t);return zn(r,n).map(o=>w(o,s))}function Hr(t){return Ln(f(t))}const Qr=Yn(),Wr=Object.freeze(Object.defineProperty({__proto__:null,execute:Fr,executeMany:Ur,isConvex:Hr,supportsCurves:Qr},Symbol.toStringTag,{value:"Module"})),qe=new kn;function Zr(t){const e=v(t);return qe.accelerateGeometry(f(t),N(e),1)}function Jr(t,e){return qe.execute(f(t),f(e),N(t.spatialReference),null)}const Kr=qe.supportsCurves(),es=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Zr,execute:Jr,supportsCurves:Kr},Symbol.toStringTag,{value:"Module"}));var Et=on;function U(t,e){return{m_geometry:t,m_side:e}}function ts(t,e,n,r,s,o){if(e.isEmpty()){const a=U(e,0);return void s.push(a)}if(n.isEmpty()){const a=U(e,0);return void s.push(a)}const i=[],u=new le;{const a=u.createGeometryUserIndex(),c=u.addGeometry(e),m=u.addGeometry(n),l=new xt(o);let p=0,g=null;if(u.hasCurves()){g=new Et;const _=u.getEnvelope2D(o);p=ge(r.total());const d=pe(r.total(),_);fe(u,d,r.total(),12e3,g,null,o)}u.dbgVerifyCurves(),l.setEditShapeCrackAndCluster(u,r),l.cut(t,a,c,m,i);for(const _ of i){g!==null&&g.stitchCurves(u,_,p,!1);const d=U(u.getGeometry(_),sn(u.getGeometryUserIndex(_,a)));s.push(d)}g!==null&&g.clearStitcher(u)}}function ns(t,e,n,r,s,o){if(e.isEmpty()){const a=U(e,0);return void s.push(a)}if(n.isEmpty()){const a=U(e,0);return void s.push(a)}const i=[],u=new le;{const a=u.createGeometryUserIndex(),c=u.addGeometry(e),m=u.addGeometry(n),l=new xt(o);let p=0,g=null;if(u.hasCurves()){g=new Et;const x=u.getEnvelope2D(o);p=ge(r.total());const D=pe(r.total(),x);fe(u,D,r.total(),12e3,g,null,o)}u.dbgVerifyCurves(),l.setEditShapeCrackAndCluster(u,r),l.cut(!1,a,c,m,i),g!==null&&g.stitchCurves(u,De,p,!0);let _=u.getGeometry(c);const d=new J,P=new J,$=[];for(let x=0;x<i.length;x++){let D=null;{const C=new le,M=C.addGeometry(_),S=C.addGeometry(u.getGeometry(i[x]));if(C.hasCurves()){const X=C.getEnvelope2D(o);p=ge(r.total());const Y=pe(r.total(),X);fe(C,Y,r.total(),12e3,g,null,o)}l.setEditShapeCrackAndCluster(C,r);const G=l.intersection(M,S);if(g!==null&&g.stitchCurves(C,De,p,!0),D=C.getGeometry(G),D.isEmpty())continue;const q=u.getGeometryUserIndex(i[x],a);q===2?d.add(D,!1):q===1?P.add(D,!1):$.push(D)}{const C=new le,M=C.addGeometry(_),S=C.addGeometry(u.getGeometry(i[x]));if(C.hasCurves()){const q=C.getEnvelope2D(o);p=ge(r.total());const X=pe(r.total(),q);fe(C,X,r.total(),12e3,g,null,o)}l.setEditShapeCrackAndCluster(C,r);const G=l.difference(M,S);g!==null&&g.stitchCurves(C,De,p,!0),_=C.getGeometry(G)}}if(!_.isEmpty()&&i.length>0&&$.push(_),d.isEmpty()&&P.isEmpty())return;if(!d.isEmpty()){const x=U(d,1);s.push(x)}if(!P.isEmpty()){const x=U(P,2);s.push(x)}for(let x=0,D=$.length;x<D;++x){const C=U($[x],3);s.push(C)}}}let rs=class{getOperatorType(){return 10005}accelerateGeometry(e,n,r){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}execute(e,n,r,s,o){return new ss(e,n,r,s,o)}},ss=class extends de{constructor(e,n,r,s,o){super(),this.m_cutIndex=-1,this.m_cuts=[],this.m_progressTracker=o,this.m_cuttee=n.clone(),this.m_cutter=new ne({copy:r}),this.m_bConsiderTouch=e;const i=rn(n,r);this.m_tolerance=Me(s,i,!0)}next(){return this.m_cutIndex===-1&&this.generateCuts(),++this.m_cutIndex<this.m_cuts.length?this.m_cuts[this.m_cutIndex]:null}getGeometryID(){return this.m_cutIndex}tock(){return!0}getRank(){return 1}generateCuts(){switch(this.m_cuttee.getGeometryType()){case h.enumPolyline:this.generatePolylineCuts();break;case h.enumPolygon:this.generatePolygonCuts()}}generatePolylineCuts(){const e=new ne,n=new ne,r=new ne;this.m_cuts.length=0,this.m_cuts.push(e),this.m_cuts.push(n);const s=[];ts(this.m_bConsiderTouch,this.m_cuttee,this.m_cutter,this.m_tolerance,s,this.m_progressTracker);for(let o=0;o<s.length;o++){const i=s[o];i.m_side===1?e.add(i.m_geometry,!1):i.m_side===2||i.m_side===4?n.add(i.m_geometry,!1):i.m_side===3?this.m_cuts.push(i.m_geometry):i.m_side===0?r.add(i.m_geometry,!1):he("")}r.isEmpty()||e.isEmpty()&&n.isEmpty()&&!(this.m_cuts.length>=3)||this.m_cuts.push(r),e.isEmpty()&&n.isEmpty()&&this.m_cuts.length<3&&(this.m_cuts.length=0)}generatePolygonCuts(){const e=new J,n=new J,r=new J;this.m_cuts.length=0,this.m_cuts.push(e),this.m_cuts.push(n);const s=[];ns(this.m_bConsiderTouch,this.m_cuttee,this.m_cutter,this.m_tolerance,s,this.m_progressTracker);for(let o=0;o<s.length;o++){const i=s[o];i.m_side===1?e.add(i.m_geometry,!1):i.m_side===2?n.add(i.m_geometry,!1):i.m_side===3?this.m_cuts.push(i.m_geometry):i.m_side===0?r.add(i.m_geometry,!1):he("")}me(r.isEmpty()||s.length===1),e.isEmpty()&&n.isEmpty()&&this.m_cuts.length<3&&(this.m_cuts.length=0)}};const Mt=new rs;function os(t,e,n){const r=Mt.execute(!0,t,e,n,null);return Array.from(r)}function is(){return Mt.supportsCurves()}function us(t,e){const n=v(t);return os(f(t),Cn(e),N(n)).map(r=>w(r,n)).filter(F)}const as=is(),cs=Object.freeze(Object.defineProperty({__proto__:null,execute:us,supportsCurves:as},Symbol.toStringTag,{value:"Module"})),Oe=new un;function ms(t,e,n,r){return Oe.execute(t,e,n,r,null)}function ls(t,e,n,r){const s=Oe.executeMany(new V(t),e,n,r,null);return Array.from(s)}function gs(){return Oe.supportsCurves()}function ps(t,e,n={}){let{maxAngleInDegrees:r=0,maxDeviation:s=0,unit:o}=n;const i=v(t);return o&&(e=R(e,o,i),s&&(s=R(s,o,i))),w(ms(f(t),e,s,Ee(r)),i)}function fs(t,e,n={}){let{maxAngleInDegrees:r=0,maxDeviation:s=0,unit:o}=n;const i=t.map(f),u=v(t);return o&&(e=R(e,o,u),s&&(s=R(s,o,u))),ls(i,e,s,Ee(r)).map(a=>w(a,u)).filter(F)}const hs=gs(),ys=Object.freeze(Object.defineProperty({__proto__:null,execute:ps,executeMany:fs,supportsCurves:hs},Symbol.toStringTag,{value:"Module"})),je=new an;function ds(t,e,n){return je.execute(t,e,n,null)}function _s(t,e,n){const r=je.executeMany(new V(t),new V([e]),n,null);return Array.from(r)}function xs(){return je.supportsCurves()}function vs(t,e){const n=v(t);return w(ds(f(t),f(e),N(n)),n)}function bs(t,e){const n=t.map(f),r=v(t);return _s(n,f(e),N(r)).map(s=>w(s,r))}const $s=xs(),Ps=Object.freeze(Object.defineProperty({__proto__:null,execute:vs,executeMany:bs,supportsCurves:$s},Symbol.toStringTag,{value:"Module"})),Re=new cn;function Ns(t){const e=v(t);return Re.accelerateGeometry(f(t),N(e),1)}function Ds(t,e){return Re.execute(f(t),f(e),N(t.spatialReference))}const Cs=Re.supportsCurves(),Ss=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Ns,execute:Ds,supportsCurves:Cs},Symbol.toStringTag,{value:"Module"}));function we(){return{outPoint:new y,index:-1,t:Number.NaN}}function ue(t,e,n){return{outPoint:t.clone(),index:e,t:n}}function T(t,e,n,r){t.outPoint.assign(e),t.index=n,t.t=r}function Z(t,e){t.outPoint.assign(e.outPoint),t.index=e.index,t.t=e.t}function lt(t,e,n,r){t.index=n,t.t=r,e.queryCoord2D(t.t,t.outPoint)}function ae(t,e){const n=we();Z(n,t),Z(t,e),Z(e,n)}function ws(t,e,n,r,s,o){if(t.getGeometryType()===h.enumPolygon){for(;r.nextPath();)if(r.hasNextSegment()){const i=r.nextSegment();if(z(t,i.getEndXY(),0)!==0)return T(s,i.getEndXY(),-1,Number.NaN),T(o,i.getEndXY(),-1,Number.NaN),!0}r.resetToFirstPath()}if(e.getGeometryType()===h.enumPolygon){for(;n.nextPath();)if(n.hasNextSegment()){const i=n.nextSegment();if(z(e,i.getEndXY(),0)!==0)return T(s,i.getEndXY(),-1,Number.NaN),T(o,i.getEndXY(),-1,Number.NaN),!0}n.resetToFirstPath()}return!1}function Es(t){const e=t.getPathCount(),n=vt(t.getSegmentCount(),0);let r=0;for(let s=0;s<e;++s){const o=r+t.getSegmentCountPath(s);for(let i=r,u=t.getPathStart(s);i<o;++i,++u)n[i]=u;r=o}return ln(t.getPointCount(),n),n}function gt(t,e){return!!Number.isNaN(e)||t<=e}function ce(t){const e=new J;return e.addEnvelope(t,!1),e}let Ms=class{constructor(e,n){if(this.m_env2DgeometryA=null,this.m_env2DgeometryB=null,this.m_progressCounter=0,this.m_progressTracker=n,this.m_maxSqrDistance=e*e,this.m_maxDistance=e,this.m_bIsNearCalc=!1,Number.isNaN(this.m_maxDistance)?this.m_maxDistance=Number.POSITIVE_INFINITY:this.m_maxDistance=e,this.m_maxSqrDistance=this.m_maxDistance*this.m_maxDistance,Number.isFinite(this.m_maxSqrDistance)){let r=Math.sqrt(this.m_maxSqrDistance);for(;r<this.m_maxDistance;)this.m_maxSqrDistance*=1+Number.EPSILON,r=Math.sqrt(this.m_maxSqrDistance)}}calculate(e,n,r,s){if((e.getGeometryType()!==j.type||n.getGeometryType()!==j.type)&&(this.m_env2DgeometryA=new E,this.m_env2DgeometryB=new E,e.queryEnvelope(this.m_env2DgeometryA),n.queryEnvelope(this.m_env2DgeometryB),!gt(this.m_env2DgeometryA.distanceFromEnvelope(this.m_env2DgeometryB),this.m_maxDistance)))return Number.POSITIVE_INFINITY;const o=ue(new y,oe(),Number.NaN),i=ue(new y,oe(),Number.NaN),u=this._ExecuteBruteForce(e,n,o,i);return gt(u,this.m_maxDistance)?(r!==null&&Z(r,o),s!==null&&Z(s,i),u):Number.POSITIVE_INFINITY}isNear(e,n){if(this.m_bIsNearCalc=!0,e.isEmpty()||n.isEmpty())return!1;if(e===n)return!0;let r=!0;if(e.getGeometryType()!==j.type&&e.getGeometryType()!==ot.type||n.getGeometryType()!==j.type&&n.getGeometryType()!==ot.type||(r=!1),r){if(this.m_env2DgeometryA=new E,this.m_env2DgeometryB=new E,e.queryEnvelope(this.m_env2DgeometryA),n.queryEnvelope(this.m_env2DgeometryB),!(this.m_env2DgeometryA.sqrMaxMinDistanceEnvelope(this.m_env2DgeometryB)>this.m_maxSqrDistance))return!0;if(this.m_env2DgeometryA.sqrDistanceEnvelope(this.m_env2DgeometryB,null,null)>this.m_maxSqrDistance)return!1}const s=ue(new y,oe(),Number.NaN),o=ue(new y,oe(),Number.NaN);return this._ExecuteBruteForce(e,n,s,o)<=this.m_maxDistance}progress_(e=!1){}_ExecuteBruteForce(e,n,r,s){switch(e.getGeometryType()){case h.enumPoint:return this.distancePointGeometry(e,n,r,s);case h.enumMultiPoint:return this.distanceMultipointGeometry(e,n,r,s);case h.enumEnvelope:return this.distanceEnvelopeGeometry(e,n,r,s);case h.enumPolyline:case h.enumPolygon:return this.distanceMultipathGeometry(e,n,r,s);default:return Number.NaN}}distancePointGeometry(e,n,r,s){switch(n.getGeometryType()){case h.enumPoint:return this.distancePointPoint(e,n,r,s);case h.enumMultiPoint:return this.distancePointMultipoint(e,n,r,s);case h.enumPolyline:case h.enumPolygon:return this.distancePointMultipath(e,n,r,s);case h.enumEnvelope:return this.distancePointEnvelope(e,n,r,s);default:return Number.NaN}}distancePointPoint(e,n,r,s){const o=e.getXY(),i=n.getXY();return T(r,o,0,0),T(s,i,0,0),Math.sqrt(y.sqrDistance(o,i))}distancePointMultipoint(e,n,r,s){const o=e.getXY();let i=this.m_maxSqrDistance,u=i,a=!1;const c=n.getPointCount(),m=new y;for(let l=0;l<c;++l)if(n.queryXY(l,m),u=y.sqrDistance(o,m),this.m_bIsNearCalc){if(u<=i)return 0}else if(!(u>i)&&(!a&&u===i||u<i)&&(i=u,T(r,o,0,0),T(s,m,l,0),a=!0,i===0))return 0;return a?Math.sqrt(i):Number.POSITIVE_INFINITY}distancePointMultipath(e,n,r,s){const o=!this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB),i=e.getXY();if(!o&&n.getGeometryType()===h.enumPolygon&&z(n,i,0)!==0)return T(r,i,0,0),T(s,i,-1,Number.NaN),0;n.getImpl().getAccelerators();let u=this.m_maxSqrDistance,a=u,c=-1;const m=new E,l=n.querySegmentIterator();let p=!1;for(;l.nextPath();)for(;l.hasNextSegment();){const g=l.nextSegment();g.queryEnvelope(m);const _=m.sqrDistance(i);if(_>u||!this.m_bIsNearCalc&&p&&_===u)continue;c=g.getClosestCoordinate(i,!1);const d=g.getCoord2D(c);if(a=y.sqrDistance(i,d),this.m_bIsNearCalc){if(a<=u)return 0}else if(!(a>u)&&(!p||a<u)&&(u=a,T(r,i,0,0),T(s,d,l.getStartPointIndex(),c),p=!0,u===0))return 0}return p?Math.sqrt(u):Number.POSITIVE_INFINITY}distancePointEnvelope(e,n,r,s){const o=e.getXY();T(r,o,0,0),T(s,o,-1,Number.NaN);const i=n.asEnvelope2D();return i.contains(o)?0:Math.sqrt(i.sqrDistance(o,s.outPoint))}distanceMultipointGeometry(e,n,r,s){switch(n.getGeometryType()){case h.enumPoint:{this.m_env2DgeometryB=A(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const o=this.distancePointMultipoint(n,e,s,r);return this.m_env2DgeometryB=A(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),o}case h.enumMultiPoint:return this.distanceMultipointMultipoint(e,n,r,s,1,1);case h.enumPolyline:case h.enumPolygon:return this.distanceMultipointMultipath(e,n,r,s);case h.enumEnvelope:return this.distanceMultipointMultipath(e,ce(n),r,s);default:return Number.NaN}}distanceMultipointMultipoint(e,n,r,s,o,i){const u={stack:[],error:void 0,hasError:!1};try{if(this.m_bIsNearCalc&&o===1&&i===1){const C=Math.trunc(re(Math.sqrt(e.getPointCount())+1,1,se())),M=Math.trunc(re(Math.sqrt(n.getPointCount())+1,1,se()));if((C>=4||M>=4)&&this.distanceMultipointMultipoint(e,n,r,s,C,M)<=this.m_maxSqrDistance)return 0}let a=this.m_maxSqrDistance;const c=[e],m=[n],l=this.swapGeometriesIfBGtA(c,m);l&&(this.m_env2DgeometryB=A(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),i=A(o,o=i),ae(r,s)),rt(u,it(()=>{ae(r,s),this.m_env2DgeometryB=A(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB)},!l),!1);const p=c[0].getImpl(),g=m[0].getImpl(),_=p.getPointCount(),d=g.getPointCount(),P=d>1;let $=!1;const x=new y,D=new y;for(let C=0;C<_;C+=o){if(p.queryXY(C,x),P){const M=this.m_env2DgeometryB.sqrDistance(x);if(this.m_bIsNearCalc){if(M>a)continue;if(this.m_env2DgeometryB.sqrMaxMinDistance(x)<=a)return 0}else if(M>=a)continue}for(let M=0;M<d;M+=i){g.queryXY(M,D);const S=y.sqrDistance(x,D);if(this.m_bIsNearCalc){if(S<=a)return 0}else if(!(S>a||$&&S===a)&&(!$||S<a)&&(T(r,x,C,0),T(s,D,M,0),$=!0,a=S,a===0))return $?Math.sqrt(a):Number.POSITIVE_INFINITY}}return $?Math.sqrt(a):Number.POSITIVE_INFINITY}catch(a){u.error=a,u.hasError=!0}finally{st(u)}}distanceMultipointMultipath(e,n,r,s){let o=!!this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB)&&n.getGeometryType()===h.enumPolygon;const i=n.querySegmentIterator();i.stripAttributes();const u=new E,a=new y;let c=this.m_maxSqrDistance;const m=e.getImpl(),l=m.getPointCount(),p=l>1;let g=!1;for(;i.nextPath();)for(;i.hasNextSegment();){const _=i.nextSegment();if(_.queryLooseEnvelope(u),p){const d=u.sqrDistanceEnvelope(this.m_env2DgeometryA,null,null);if(this.m_bIsNearCalc){if(d>c)continue}else if(d>c||g&&d===c)continue}for(let d=0;d<l;d++){if(m.queryXY(d,a),o&&z(n,a,0)!==0)return T(r,a,-1,Number.NaN),T(s,a,d,0),0;{const D=u.sqrDistance(a);if(this.m_bIsNearCalc){if(D>c)continue}else if(D>c)continue}const P=_.getClosestCoordinate(a,!1),$=_.getCoord2D(P);a.subThis($);const x=a.sqrLength();if(this.m_bIsNearCalc){if(x<=c)return 0}else if(!(x>c)&&(!g||x<c)&&(c=x,T(r,m.getXY(d),d,0),T(s,$,i.getStartPointIndex(),P),g=!0,c===0))return 0}o=!1}return g?Math.sqrt(c):Number.POSITIVE_INFINITY}distanceEnvelopeGeometry(e,n,r,s){switch(n.getGeometryType()){case h.enumPoint:return this.distancePointEnvelope(n,e,s,r);case h.enumMultiPoint:{this.m_env2DgeometryB=A(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const o=this.distanceMultipointMultipath(n,ce(e),s,r);return this.m_env2DgeometryB=A(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),o}case h.enumPolyline:case h.enumPolygon:return this.distanceMultipathMultipath(ce(e),n,r,s);case h.enumEnvelope:return this.distanceEnvelopeEnvelope(e,n,r,s);default:return Number.NaN}}distanceEnvelopeEnvelope(e,n,r,s){r.t=Number.NaN,r.index=-1,s.t=Number.NaN,s.index=-1;const o=e.asEnvelope2D(),i=n.asEnvelope2D();return Math.sqrt(o.sqrDistanceEnvelope(i,r.outPoint,s.outPoint))}distanceMultipathGeometry(e,n,r,s){switch(n.getGeometryType()){case h.enumPoint:{this.m_env2DgeometryB=A(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const o=this.distancePointMultipath(n,e,s,r);return this.m_env2DgeometryB=A(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),o}case h.enumMultiPoint:{this.m_env2DgeometryB=A(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const o=this.distanceMultipointMultipath(n,e,s,r);return this.m_env2DgeometryB=A(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),o}case h.enumPolyline:case h.enumPolygon:return this.distanceMultipathMultipath(e,n,r,s);case h.enumEnvelope:return this.distanceMultipathMultipath(e,ce(n),r,s);default:return Number.NaN}}distanceMultipathMultipath(e,n,r,s){const o={stack:[],error:void 0,hasError:!1};try{const i=[e],u=[n],a=this.swapGeometriesIfAGtB(i,u);a&&(this.m_env2DgeometryB=A(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),ae(r,s)),rt(o,it(()=>{ae(r,s),this.m_env2DgeometryB=A(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB)},!a),!1);const c=i[0],m=u[0],l=c.querySegmentIterator();l.stripAttributes();const p=m.querySegmentIterator();if(p.stripAttributes(),this.m_bIsNearCalc&&this.m_env2DgeometryA.sqrMaxMinDistanceEnvelope(this.m_env2DgeometryB)<=this.m_maxSqrDistance)return 0;if(this.m_bIsNearCalc){const S=Math.trunc(re(Math.sqrt(c.getPointCount())+1,1,se())),G=Math.trunc(re(Math.sqrt(c.getPointCount())+1,1,se()));if(this.distanceMultipointMultipoint(c,m,r,s,S,G)<=this.m_maxSqrDistance)return 0}if(this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB)){const S=we(),G=we();if(ws(c,m,l,p,S,G))return Z(r,S),Z(s,G),0}const g=Es(c),_=[],d=new mn,P=new E,$=new E,x=new E;let D=this.m_maxSqrDistance,C=!0,M=!1;for(let S=0,G=g.length;S<G;++S){c.querySegment(g[S],d,!0);const q=d.get();if(q.queryEnvelope(P),!(P.sqrDistanceEnvelope(this.m_env2DgeometryB,null,null)>D)){if(this.m_bIsNearCalc&&P.sqrMaxDistanceEnvelope(this.m_env2DgeometryB)<=D)return 0;for(;p.nextPath();){if(this.progress_(),C)m.queryPathEnvelope(p.getPathIndex(),x),_[p.getPathIndex()]=x.clone();else if(P.sqrDistanceEnvelope(_[p.getPathIndex()],null,null)>D)continue;for(;p.hasNextSegment();){const X=p.nextSegment();if(X.queryEnvelope($),P.sqrDistanceEnvelope($,null,null)<=D){const Y=!P.isIntersecting($),b=[0],I=[0];let O=q.distance(X,Y,b,I);if(O*=O,this.m_bIsNearCalc&&O<=this.m_maxSqrDistance)return 0;if(O<D||O===D&&g[S]<r.index){if(M=!0,lt(r,q,g[S],b[0]),lt(s,X,p.getStartPointIndex(),I[0]),O===0)return 0;D=O}}}}p.resetToFirstPath(),C=!1}}return M?Math.sqrt(D):Number.POSITIVE_INFINITY}catch(i){o.error=i,o.hasError=!0}finally{st(o)}}swapGeometriesIfAGtB(e,n){return ut(e[0])>ut(n[0])&&(n[0]=A(e[0],e[0]=n[0]),!0)}swapGeometriesIfBGtA(e,n){return this.swapGeometriesIfAGtB(n,e)}},Ts=class{getOperatorType(){return 10100}supportsCurves(){return!0}accelerateGeometry(e,n,r){return!1}canAccelerateGeometry(e){return!1}execute(e,n,r){return this.executeEx(e,n,r,null,null,Number.NaN)}executeEx(e,n,r,s,o,i){if(e.isEmpty()||n.isEmpty())return Number.NaN;K(e),K(n);const u=e,a=n;Number.isNaN(i)&&(i=Number.POSITIVE_INFINITY);const c=new Ms(i,r).calculate(u,a,s,o);return Number.isFinite(c)?c:Number.NaN}};const Tt=new Ts;function Is(t,e,n={}){const{unit:r}=n;let s=Tt.execute(f(t),f(e),null);if(s&&r){const o=v(t);s=te(s,o,r)}return s}const Gs=Tt.supportsCurves(),As=Object.freeze(Object.defineProperty({__proto__:null,execute:Is,supportsCurves:Gs},Symbol.toStringTag,{value:"Module"}));let qs=class extends gn{getOperatorType(){return 2}execute(e,n,r,s){return pn(e,n,r,3,s)}};const Ve=new qs;function Os(t){const e=v(t);return Ve.accelerateGeometry(f(t),N(e),1)}function js(t,e){return Ve.execute(f(t),f(e),N(t.spatialReference),null)}const Rs=Ve.supportsCurves(),Vs=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Os,execute:js,supportsCurves:Rs},Symbol.toStringTag,{value:"Module"})),Xe=new Xn;function Xs(t,e,n){return Xe.execute(t,e,n,null)}function Ys(t,e,n){const r=Xe.executeMany(new V(t),e,n,null);return Array.from(r)}function Bs(){return Xe.supportsCurves()}function zs(t,e,n={}){const{removeDegenerateParts:r=!1,unit:s}=n,o=v(t);return s&&(e=R(e,s,o)),w(Xs(f(t),e,r),o)}function Ls(t,e,n={}){const{removeDegenerateParts:r=!1,unit:s}=n,o=t.map(f),i=v(t);return s&&(e=R(e,s,i)),Ys(o,e,r).map(u=>w(u,i)).filter(F)}const ks=Bs(),Fs=Object.freeze(Object.defineProperty({__proto__:null,execute:zs,executeMany:Ls,supportsCurves:ks},Symbol.toStringTag,{value:"Module"}));let xe,Ye,Be,ze,It;function Gt(){return!!xe&&Tn()}async function At(){if(!Gt()){const[t]=await Promise.all([H(()=>import("./apiConverter-DyLGqvDr.js"),__vite__mapDeps([0,1,2,3,4,5,6]),import.meta.url),Sn()]);xe=t.fromGeometry,Ye=t.fromSpatialReference,Be=t.getSpatialReference,ze=t.toPolygon,It=wn()}}function Us(t,e,n={}){let{curveType:r="geodesic",maxDeviation:s=NaN,unit:o}=n;o&&(e=L(e,o,"meters"),s&&(s=L(s,o,"meters")));const i=Be(t);return ze(En(xe(t),Ye(i),ee[r],e,s),i)}function Hs(t,e,n={}){let{curveType:r="geodesic",maxDeviation:s=NaN,union:o=!1,unit:i}=n;i&&(e=e.map(c=>L(c,i,"meters")),s&&(s=L(s,i,"meters")));const u=t.map(xe),a=Be(t);return Mn(u,Ye(a),ee[r],e,s,o).map(c=>ze(c,a)).filter(F)}const Qs=Object.freeze(Object.defineProperty({__proto__:null,execute:Us,executeMany:Hs,isLoaded:Gt,load:At,get supportsCurves(){return It}},Symbol.toStringTag,{value:"Module"}));let ve;function qt(){return!!ve&&_t()}async function Ws(){if(!qt()){const[t,e]=await Promise.all([H(()=>import("./OperatorGeodeticArea-CTojdVj6.js"),__vite__mapDeps([7,1,2,3,4,5,8]),import.meta.url),H(()=>import("./ProjectionTransformation-DYBnfgxa.js").then(n=>n.bF),__vite__mapDeps([1,2,3,4,5]),import.meta.url).then(n=>n.aG).then(({injectPe:n})=>n),yt()]);ve=new t.OperatorGeodeticArea,e(dt)}}function Zs(t,e,n){return ve.execute(t,e,n,null)}function Js(){return ve.supportsCurves()}let Le,Ot,jt,Rt;function Vt(){return!!Le&&qt()}async function Xt(){if(!Vt()){const[t]=await Promise.all([H(()=>import("./apiConverter-DyLGqvDr.js"),__vite__mapDeps([0,1,2,3,4,5,6]),import.meta.url),Ws()]);Le=t.fromGeometry,Ot=t.fromSpatialReference,jt=t.getSpatialReference,Rt=Js()}}function Ks(t,e={}){const{curveType:n="geodesic",unit:r}=e,s=jt(t);let o=Zs(Le(t),Ot(s),ee[n]);return o&&r&&(o=L(o,"square-meters",r)),o}const eo=Object.freeze(Object.defineProperty({__proto__:null,execute:Ks,isLoaded:Vt,load:Xt,get supportsCurves(){return Rt}},Symbol.toStringTag,{value:"Module"}));let be,ke,Fe,Ue,Yt;function Bt(){return!!be&&On()}async function zt(){if(!Bt()){const[t]=await Promise.all([H(()=>import("./apiConverter-DyLGqvDr.js"),__vite__mapDeps([0,1,2,3,4,5,6]),import.meta.url),In()]);be=t.fromGeometry,ke=t.fromSpatialReference,Fe=t.getSpatialReference,Ue=t.toGeometry,Yt=Gn()}}function to(t,e,n={}){const{curveType:r="geodesic",unit:s}=n;s&&(e=L(e,s,"meters"));const o=Fe(t);return Ue(An(be(t),e,ke(o),ee[r]),o)}function no(t,e,n={}){const{curveType:r="geodesic",unit:s}=n;s&&(e=L(e,s,"meters"));const o=t.map(be),i=Fe(t);return qn(o,e,ke(i),ee[r]).map(u=>Ue(u,i))}const ro=Object.freeze(Object.defineProperty({__proto__:null,execute:to,executeMany:no,isLoaded:Bt,load:zt,get supportsCurves(){return Yt}},Symbol.toStringTag,{value:"Module"}));let $e;function Lt(){return!!$e&&_t()}async function so(){if(!Lt()){const[t,e]=await Promise.all([H(()=>import("./OperatorGeodeticLength-BbVoERGy.js"),__vite__mapDeps([9,3,4,5,1,2,8]),import.meta.url),H(()=>import("./ProjectionTransformation-DYBnfgxa.js").then(n=>n.bF),__vite__mapDeps([1,2,3,4,5]),import.meta.url).then(n=>n.aG).then(({injectPe:n})=>n),yt()]);$e=new t.OperatorGeodeticLength,e(dt)}}function oo(t,e,n){return $e.execute(t,e,n,null)}function io(){return $e.supportsCurves()}let He,kt,Ft,Ut;function Ht(){return!!He&&Lt()}async function Qt(){if(!Ht()){const[t]=await Promise.all([H(()=>import("./apiConverter-DyLGqvDr.js"),__vite__mapDeps([0,1,2,3,4,5,6]),import.meta.url),so()]);He=t.fromGeometry,kt=t.fromSpatialReference,Ft=t.getSpatialReference,Ut=io()}}function uo(t,e={}){const{curveType:n="geodesic",unit:r}=e,s=Ft(t);let o=oo(He(t),kt(s),ee[n]);return o&&r&&(o=L(o,"meters",r)),o}const ao=Object.freeze(Object.defineProperty({__proto__:null,execute:uo,isLoaded:Ht,load:Qt,get supportsCurves(){return Ut}},Symbol.toStringTag,{value:"Module"}));function co(t){const e=v(t);return Un(f(t),N(e))}function mo(t,e){const n=v(t);return w(Hn(f(t),f(e),N(n)),n)}function lo(t,e){const n=t.map(f),r=v(t);return Qn(n,f(e),N(r),7).map(s=>w(s,r)).filter(F)}const go=Fn(),po=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:co,execute:mo,executeMany:lo,supportsCurves:go},Symbol.toStringTag,{value:"Module"})),Qe=new Wn;function fo(t){const e=v(t);return Qe.accelerateGeometry(f(t),N(e),1)}function ho(t,e){return Qe.execute(f(t),f(e),N(t.spatialReference),null)}const yo=Qe.supportsCurves(),_o=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:fo,execute:ho,supportsCurves:yo},Symbol.toStringTag,{value:"Module"}));function pt(){return Q(new y,-1,Number.NaN)}function Q(t,e,n){return{m_coordinate:t.clone(),m_vertexIndex:e,m_geometryIndex:0,m_distance:n,m_bRightSide:!1,isEmpty:xo}}function xo(){return Number.isNaN(this.m_distance)}function ye(t,e,n=-1,r=-1){if(t.isEmpty())return 3;const s=t.getGeometryType();if(fn(s))return vo(t,e,n,r);if(s===h.enumPolygon)return bo(t,e,n,r);if(s===h.enumPolyline)return $o(t,e,n,r);if(s===h.enumEnvelope){const o=new E;return t.queryEnvelope(o),o.contains(e)?o.containsExclusive(e)?1:2:0}return 3}function vo(t,e,n,r){if(n>=0||r>=0)return B("");if(t.isDegenerate(0))return t.getStartXY().equals(e)?2:3;if(!t.isCurve()){const a=y.orientationRobust(e,t.getStartXY(),t.getEndXY());return a<0?1:a>0?0:2}const s=t.getClosestCoordinate(e,!1),o=t.getTangent(s),i=t.getCoord2D(s),u=y.orientationRobust(e,i,i.add(o));return u<0?1:u>0?0:2}function bo(t,e,n,r){(n>=0||r>=0)&&B("");const s=new E;t.queryEnvelope(s);const o=z(t,e,0);return o===0?0:o===1?1:2}function $o(t,e,n,r){(n<0&&r>=0||n>=0&&r<0)&&B("");const s=t.querySegmentIterator();if(n<0){let i=Number.MAX_VALUE,u=0;for(;s.nextPath();)for(;s.hasNextSegment();){const a=s.nextSegment(),c=a.getClosestCoordinate(e,!1),m=a.getCoord2D(c),l=y.sqrDistance(m,e);l<i?(u=1,n=s.getStartPointIndex(),r=s.getPathIndex(),i=l):l===i&&u++}if(u===0)return 3;if(u===1)return s.resetToVertex(n,r),ye(s.nextSegment(),e)}const o=Co(e,s,n,r);if(o.i1!==-1&&o.i2===-1)return o.bRight1?1:0;if(o.i1!==-1&&o.i2!==-1){if(o.bRight1===o.bRight2)return o.bRight1?1:0;{s.resetToVertex(o.i1,-1);const i=s.nextSegment().getTangent(1);s.resetToVertex(o.i2,-1);const u=s.nextSegment().getTangent(0);return i.crossProduct(u)>=0?1:0}}return s.resetToVertex(n,r),ye(s.nextSegment(),e)}function Po(t,e,n){for(t.resetToVertex(e,n);t.hasNextSegment();)if(!t.nextSegment().isDegenerate(0))return t.getStartPointIndex();for(t.resetToVertex(e,n);t.hasPreviousSegment();)if(!t.previousSegment().isDegenerate(0))return t.getStartPointIndex();return-1}function No(t,e){for(t.resetToVertex(e,-1),t.nextSegment();t.hasNextSegment();)if(!t.nextSegment().isDegenerate(0))return t.getStartPointIndex();return-1}function Do(t,e){for(t.resetToVertex(e,-1);t.hasPreviousSegment();)if(!t.previousSegment().isDegenerate(0))return t.getStartPointIndex();return-1}function Co(t,e,n,r){const s={i1:-1,i2:-1,bRight1:!1,bRight2:!1};if(s.i1=Po(e,n,r),s.i1!==-1){e.resetToVertex(s.i1,-1);const o=e.nextSegment(),i=o.getClosestCoordinate(t,!1),u=o.getCoord2D(i),a=y.sqrDistance(u,t);{const c=u.clone();c.subThis(o.getStartXY());const m=t.clone();m.subThis(o.getStartXY()),s.bRight1=c.crossProduct(m)<0}if(s.i2=No(e,s.i1),s.i2!==-1){e.resetToVertex(s.i2,-1);const c=e.nextSegment(),m=c.getClosestCoordinate(t,!1),l=c.getCoord2D(m);if(y.sqrDistance(l,t)>a)s.i2=-1;else{const p=l.clone();p.subThis(c.getStartXY());const g=t.clone();g.subThis(c.getStartXY()),s.bRight2=p.crossProduct(g)<0}}if(s.i2===-1&&(s.i2=Do(e,s.i1),s.i2!==-1)){e.resetToVertex(s.i2,-1);const c=e.nextSegment(),m=c.getClosestCoordinate(t,!1),l=c.getCoord2D(m);if(y.sqrDistance(l,t)>a)s.i2=-1;else{const p=l.clone();p.subThis(c.getStartXY());const g=t.clone();g.subThis(c.getStartXY()),s.bRight2=p.crossProduct(g)<0;const _=s.i1;s.i1=s.i2,s.i2=_;const d=s.bRight1;s.bRight1=s.bRight2,s.bRight2=d}}}return s}let W=class{getOperatorType(){return 10500}accelerateGeometry(e,n,r){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}getNearestCoordinate(e,n,r,s){if(n.isNAN()&&B("NAN xy coordinates are not allowed"),e.isEmpty())return pt();switch(e.getGeometryType()){case h.enumPoint:return this.pointGetNearestVertex(e,n);case h.enumMultiPoint:return this.multiVertexGetNearestVertex(e,n);case h.enumPolyline:case h.enumPolygon:return this.multiPathGetNearestCoordinate(e,n,r,s);default:Ce("")}}getNearestVertex(e,n){if(n.isNAN()&&B("NAN xy coordinates are not allowed"),e.isEmpty())return pt();switch(e.getGeometryType()){case h.enumPoint:return this.pointGetNearestVertex(e,n);case h.enumMultiPoint:case h.enumPolyline:case h.enumPolygon:return this.multiVertexGetNearestVertex(e,n);default:Ce("")}}getNearestVertices(e,n,r,s){if(s===0&&B(""),n.isNAN()&&B("NAN xy coordinates are not allowed"),e.isEmpty())return[];switch(e.getGeometryType()){case h.enumPoint:return this.pointGetNearestVertices(e,n,r,s);case h.enumMultiPoint:case h.enumPolyline:case h.enumPolygon:return this.multiVertexGetNearestVertices(e,n,r,s);default:Ce("")}}multiPathGetNearestCoordinate(e,n,r,s){if(e.getGeometryType()===h.enumPolygon&&r){const p=new E;e.queryEnvelope(p);const g=hn(null,p,!1);let _;if(_=z(e,n,s?0:g),_!==0){const d=Q(n,-1,0);return s&&(d.m_bRightSide=!0),d}}const o=e.querySegmentIterator(),i=new y;let u=-1,a=-1,c=Number.MAX_VALUE,m=0;for(;o.nextPath();)for(;o.hasNextSegment();){const p=o.nextSegment(),g=p.getClosestCoordinate(n,!1),_=p.getCoord2D(g),d=y.sqrDistance(_,n);d<c?(m=1,i.assign(_),u=o.getStartPointIndex(),a=o.getPathIndex(),c=d):d===c&&m++}u===-1&&B("");const l=Q(i,u,Math.sqrt(c));if(s)if(e.getGeometryType()!==h.enumPolygon){let p=!1;if(m>1){const g=ye(e,n,u,a);p=g!==0&&g!==3}else{o.resetToVertex(u,a);const g=o.nextSegment();p=ye(g,n)!==0}l.m_bRightSide=p}else r||z(e,n,0)!==0&&(l.m_bRightSide=!0);return l}pointGetNearestVertex(e,n){const r=e.getXY(),s=y.distance(r,n);return Q(r,0,s)}multiVertexGetNearestVertex(e,n){const r=e.getAttributeStreamRef(0),s=e.getPointCount();let o=-1;const i=new y;let u=Number.MAX_VALUE;const a=new y;for(let c=0;c<s;c++){r.queryPoint2D(2*c,a);const m=y.sqrDistance(a,n);m<u&&(i.assign(a),o=c,u=m)}return Q(i,o,Math.sqrt(u))}pointGetNearestVertices(e,n,r,s){const o=[];if(s!==0){const i=r*r,u=e.getXY(),a=y.sqrDistance(u,n);a<=i&&o.push(Q(u,0,Math.sqrt(a)))}return o}multiVertexGetNearestVertices(e,n,r,s){const o=[];if(s!==0){const i=e.getAttributeStreamRef(0),u=e.getPointCount();o.length=s+1;const a=r*r;for(let c=0;c<u;c++){const m=i.read(2*c),l=i.read(2*c+1),p=n.x-m,g=n.y-l,_=p*p+g*g;_<=a&&o.push(Q(y.construct(m,l),c,Math.sqrt(_)))}o.sort((c,m)=>c.m_distance-m.m_distance)}return o.slice(0,s)}},So=class{getOperatorType(){return 10203}accelerateGeometry(e,n,r){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}executeMany(e,n){return new ft(e,n)}execute(e,n){return new ft(null,n).labelPoint(e)}},ft=class extends de{progress_(){}tock(){return!0}getRank(){return 1}constructor(e,n){super(),this.m_index=-1,this.m_progressCounter=0,this.m_progressTracker=n,this.m_inputGeoms=e}next(){const e=this.m_inputGeoms.next();return e?(K(e),this.m_index=this.m_inputGeoms.getGeometryID(),this.labelPoint(e)):null}getGeometryID(){return this.m_index}labelPoint(e){if(e===null&&B("null pointer is not allowed"),e.getGeometryType()===h.enumPoint)return e;if(e.isEmpty())return new j({vd:e.getDescription()});switch(e.getGeometryType()){case h.enumPolygon:return this.labelPointPolygon(e);case h.enumPolyline:return this.labelPointPolyline(e);case h.enumMultiPoint:return this.labelPointMultiPoint(e);case h.enumEnvelope:return this.labelPointEnvelope(e);default:B("geometry is not supported")}}labelPointPolygon(e){const n=new E;e.queryEnvelope(n);const r=Me(null,n,!0).total();let s=null,o=e;if(e.hasNonLinearSegments()){const b=new J({copy:e}),I=yn(b,.25*r,r);me(I!==e),s=I,o=s}let i=0,u=0;for(let b=0,I=o.getPathCount();b<I;++b){const O=Math.abs(o.calculateRingArea2D(b));O>u&&(u=O,i=b)}const a=new y;if(Math.abs(u)<=2*r*r?a.setNAN():a.assign(Cr(o,i)),Number.isNaN(a.x)){const b=new E;return o.queryPathEnvelope(i,b),new j({pt:b.getCenter()})}if(o.getPointCount()<4)return new j({x:a.x,y:a.y});const c=y.getNAN(),m=[c.clone(),c.clone(),c.clone(),c.clone()],l=[Number.NaN,Number.NaN,Number.NaN,Number.NaN],p=[Number.NaN,Number.NaN,Number.NaN,Number.NaN];let g=!1,_=new W().getNearestCoordinate(o,a,!0,!1);if(_.m_distance===0&&(g=!0,m[0]=a,_=new W().getNearestCoordinate(o,a,!1,!1),_.m_distance>.25*n.minDimension()*1.66666666))return new j({x:a.x,y:a.y});l[0]=_.m_distance,p[0]=0;const d=new y;let P=!1,$=.25,x=-1;const D=new E;o.queryPathEnvelope(i,D);do{let b=Number.NaN;if(m[1]=this.calculateParacentroid_(o,Se(D.xmin,D.xmax,$),r),m[1].isNAN()||(_=new W().getNearestCoordinate(o,m[1],!1,!1),b=_.m_distance),b>r&&z(o,m[1],r)===1)P=!0,l[1]=b,p[1]=y.sqrDistance(m[1],a);else if(b>x&&(x=b,d.setCoordsPoint2D(m[1])),$-=.01,$<.1){if(!(x>=0))break;P=!0,l[1]=x,m[1]=d,p[1]=y.sqrDistance(m[1],a)}}while(!P);P=!1,$=.5,x=-1;let C=.01,M=1;do{let b=Number.NaN;if(m[2]=this.calculateParacentroid_(o,Se(D.xmin,D.xmax,$),r),m[2].isNAN()||(_=new W().getNearestCoordinate(o,m[2],!1,!1),b=_.m_distance),b>r&&z(o,m[2],r)===1)P=!0,l[2]=b,p[2]=y.sqrDistance(m[2],a);else if(b>x&&(x=b,d.setCoordsPoint2D(m[2])),$=.5+C*M,C+=.01,M*=-1,$<.3||$>.7){if(!(x>=0))break;P=!0,l[2]=x,m[2]=d,p[2]=y.sqrDistance(m[2],a)}}while(!P);P=!1,$=.75,x=-1;do{let b=Number.NaN;if(m[3]=this.calculateParacentroid_(o,Se(D.xmin,D.xmax,$),r),m[3].isNAN()||(_=new W().getNearestCoordinate(o,m[3],!1,!1),b=_.m_distance),b>r&&z(o,m[3],r)===1)P=!0,l[3]=b,p[3]=y.sqrDistance(m[3],a);else if(b>x&&(x=b,d.setCoordsPoint2D(m[3])),$+=.01,$>.9){if(!(x>=0))break;P=!0,l[3]=x,m[3]=d,p[3]=y.sqrDistance(m[3],a)}}while(!P);const S=[0,1,2,3],G=g?0:1;for(let b=G;b<4;b++)for(let I=G;I<3;I++){const O=p[I],nt=p[I+1];if(dn(O,nt)>0){const Zt=S[I];S[I]=S[I+1],S[I+1]=Zt,p[I]=nt,p[I+1]=O}}let q=G,X=0,Y=0;for(let b=G;b<4;b++){switch(b){case 0:Y=2*l[S[b]];break;case 1:Y=1.66666666*l[S[b]];break;case 2:Y=1.33333333*l[S[b]];break;case 3:Y=l[S[b]]}Y>X&&(X=Y,q=S[b])}return me(!m[q].isNAN()),new j({x:m[q].x,y:m[q].y})}labelPointPolyline(e){const n=new y;if(e.getPointCount()>2*e.getPathCount()){let r=-1,s=-Number.MAX_VALUE;for(let a=0,c=e.getPathCount();a<c;a++)if(e.getPathSize(a)>2){const m=e.calculatePathLength2D(a);m>s&&(s=m,r=a)}const o=e.getPathStart(r),i=e.getPathEnd(r),u=Math.trunc((o+i)/2);n.assign(e.getXY(u))}else{let r=-Number.MAX_VALUE;const s=e.querySegmentIterator();for(;s.nextPath();)if(s.hasNextSegment()){const o=s.nextSegment(),i=o.calculateLength2D();i>r&&(r=i,n.assign(o.getCoord2D(o.lengthToT(.5*i))))}}return new j({x:n.x,y:n.y})}labelPointMultiPoint(e){const n=new E;e.queryEnvelope(n);const r=n.getCenter(),s=new W().getNearestCoordinate(e,r,!1,!1).m_coordinate;return new j({x:s.x,y:s.y})}labelPointEnvelope(e){const n=e.getCenterXY();return new j({x:n.x,y:n.y})}calculateParacentroid_(e,n,r){const s=new E;e.queryEnvelope(s);const o=new y(n,0);let i=Number.MAX_VALUE,u=Number.MAX_VALUE,a=!1,c=!1;const m=new _n;m.setStartXYCoords(o.x,s.ymin-1),m.setEndXYCoords(o.x,s.ymax+1);const l=new E,p=new y,g=new y,_=xn(y,2),d=e.querySegmentIterator();for(;d.nextPath();)for(;d.hasNextSegment();){const P=d.nextSegment();if(P.queryEnvelope(l),me(P.isMonotoneQuickAndDirty()),p.setCoordsPoint2D(m.getStartXY()),g.setCoordsPoint2D(m.getEndXY()),l.clipLine(p,g)===0||m.intersect(P,_,null,null,r)!==1)continue;const $=_[0].y;i>u?$<i&&(i=$,a=!0):$<u&&(u=$,c=!0)}return a&&c?o.y=(i+u)/2:o.setNAN(),o}};const We=new So;function wo(t){return We.execute(t,null)}function Eo(t){const e=We.executeMany(new V(t),null);return Array.from(e)}function Mo(){return We.supportsCurves()}function To(t){return _e(wo(f(t)),v(t))}function Io(t){const e=t.map(f),n=v(t);return Eo(e).map(r=>_e(r,n))}const Go=Mo(),Ao=Object.freeze(Object.defineProperty({__proto__:null,execute:To,executeMany:Io,supportsCurves:Go},Symbol.toStringTag,{value:"Module"}));function qo(t,e={}){const{unit:n}=e;let r=f(t).calculateLength2D();if(r&&n){const s=v(t);r=te(r,s,n)}return r}const Oo=!0,jo=Object.freeze(Object.defineProperty({__proto__:null,execute:qo,supportsCurves:Oo},Symbol.toStringTag,{value:"Module"})),Wt={round:0,bevel:1,miter:2,square:3};function Ro(t,e,n={}){const{miterLimit:r=10,flattenError:s=0,joins:o="round",unit:i}=n,u=v(t);return i&&(e=R(e,i,u)),w(Jn(f(t),N(u),e,Wt[o],r,s),u)}function Vo(t,e,n={}){const{miterLimit:r=10,flattenError:s=0,joins:o="round",unit:i}=n,u=v(t);i&&(e=R(e,i,u));const a=t.map(f);return Kn(a,N(u),e,Wt[o],r,s).map(c=>w(c,u)).filter(F)}const Xo=Zn(),Yo=Object.freeze(Object.defineProperty({__proto__:null,execute:Ro,executeMany:Vo,supportsCurves:Xo},Symbol.toStringTag,{value:"Module"})),Ze=new er;function Bo(t){const e=v(t);return Ze.accelerateGeometry(f(t),N(e),1)}function zo(t,e){return Ze.execute(f(t),f(e),N(t.spatialReference),null)}const Lo=Ze.supportsCurves(),ko=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Bo,execute:zo,supportsCurves:Lo},Symbol.toStringTag,{value:"Module"}));function Je(t,e,n=!1){const r=_e(t.m_coordinate,v(e)),s=t.m_distance,o=t.isEmpty(),i=t.m_bRightSide;return{coordinate:r,distance:s,isEmpty:o,...n&&{isRightSide:i},vertexIndex:t.m_vertexIndex}}const Pe=new W;function Fo(t,e,n={}){const{calculateLeftRightSide:r=!1,testPolygonInterior:s=!0,unit:o}=n,i=Pe.getNearestCoordinate(f(t),Te(e).getXY(),s,r);if(o&&i.m_distance){const u=v(t);i.m_distance=te(i.m_distance,u,o)}return Je(i,t,r)}function Uo(t,e,n={}){const{unit:r}=n,s=Pe.getNearestVertex(f(t),Te(e).getXY());if(r&&s.m_distance){const o=v(t);s.m_distance=te(s.m_distance,o,r)}return Je(s,t)}function Ho(t,e,n,r,s={}){const{unit:o}=s,i=v(t);return o&&n&&(n=R(n,o,i)),Pe.getNearestVertices(f(t),Te(e).getXY(),n,r).map(u=>(o&&u.m_distance&&(u.m_distance=te(u.m_distance,i,o)),Je(u,t)))}const Qo=Pe.supportsCurves(),Wo=Object.freeze(Object.defineProperty({__proto__:null,getNearestCoordinate:Fo,getNearestVertex:Uo,getNearestVertices:Ho,supportsCurves:Qo},Symbol.toStringTag,{value:"Module"}));let Zo=class{supportsCurves(){return!0}getOperatorType(){return 1}execute(e,n,r,s,o){return vn(e,n,r,s,o)}isValidDE9IM(e){return bn(e)===0}accelerateGeometry(e,n,r){return $n(e,n,r)}canAccelerateGeometry(e){return Pn(e)}};const Ne=new Zo;function Jo(t){const e=v(t);return Ne.accelerateGeometry(f(t),N(e),1)}function Ko(t,e,n){return Ne.execute(f(t),f(e),N(t.spatialReference),n,null)}function ei(t){return Ne.isValidDE9IM(t)}const ti=Ne.supportsCurves(),ni=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Jo,execute:Ko,isValidDE9IM:ei,supportsCurves:ti},Symbol.toStringTag,{value:"Module"}));function ri(t){const e=v(t);return w(nr(f(t),N(e),!1),e)}function si(t){const e=t.map(f),n=v(t);return rr(e,N(n),!1).map(r=>w(r,n))}function oi(t){return sr(f(t),N(v(t)),!1)}const ii=tr(),ui=Object.freeze(Object.defineProperty({__proto__:null,execute:ri,executeMany:si,isSimple:oi,supportsCurves:ii},Symbol.toStringTag,{value:"Module"}));class ai{getOperatorType(){return 10003}supportsCurves(){return!0}accelerateGeometry(e,n,r){return!1}canAccelerateGeometry(e){return!1}executeMany(e,n,r,s){return new li(e,n,r,s)}execute(e,n,r,s){const o=new V([e]),i=new V([n]),u=this.executeMany(o,i,r,s).next();return u||he("null output"),u}}function ci(t,e,n,r){const s=t.getDimension(),o=e.getDimension();if(s!==o)return s>o?t:e;if(t.isEmpty())return e;if(e.isEmpty())return t;const i=new E,u=new E,a=new E;t.queryEnvelope(i),e.queryEnvelope(u),a.setCoords({env2D:i}),a.mergeEnvelope2D(u);const c=Me(n,a,!0),m=t.getGeometryType(),l=e.getGeometryType();return m===h.enumPoint&&l===h.enumPoint?mi(t,e,c):m===h.enumPoint&&l===h.enumMultiPoint?ht(e,t,c):m===h.enumMultiPoint&&l===h.enumPoint?ht(t,e,c):Nn(t,e,n,r)}function mi(t,e,n,r){const s=bt(n),o=s*s,i=t.getXY(),u=e.getXY(),a=new Dn({vd:t.getDescription()});return y.sqrDistance(i,u)>o&&(a.add(t),a.add(e)),a}function ht(t,e,n,r){const s=t.getImpl().getAttributeStreamRef(0),o=t.getPointCount(),i=e.getXY(),u=t.createInstance(),a=bt(n),c=new E;if(t.queryEnvelope(c),c.inflateCoords(a,a),c.contains(i)){const m=a*a;let l=!1;const p=vt(o,!1);for(let g=0;g<o;g++){const _=s.read(2*g),d=s.read(2*g+1),P=_-i.x,$=d-i.y;P*P+$*$<=m&&(l=!0,p[g]=!0)}if(l)for(let g=0;g<o;g++)p[g]||u.addPoints(t,g,g+1);else u.addPoints(t,0,o),u.add(e)}else u.addPoints(t,0,o),u.add(e);return u}class li extends de{constructor(e,n,r,s){super(),this.m_progressTracker=s,this.m_index=-1,this.m_inputGeoms=e,this.m_spatialReference=r,this.m_rightGeom=n.next(),this.m_bEmpty=!this.m_rightGeom,K(this.m_rightGeom)}tock(){return!0}getRank(){return 1}next(){if(this.m_bEmpty)return null;const e=this.m_inputGeoms.next();return e?(K(e),this.m_index=this.m_inputGeoms.getGeometryID(),ci(e,this.m_rightGeom,this.m_spatialReference,this.m_progressTracker)):null}getGeometryID(){return this.m_index}}const Ke=new ai;function gi(t,e,n){return Ke.execute(t,e,n,null)}function pi(t,e,n){const r=Ke.executeMany(new V(t),new V([e]),n,null);return Array.from(r)}function fi(){return Ke.supportsCurves()}function hi(t,e){const n=v(t);return w(gi(f(t),f(e),N(n)),n)}function yi(t,e){const n=t.map(f),r=v(t);return pi(n,f(e),N(r)).map(s=>w(s,r)).filter(F)}const di=fi(),_i=Object.freeze(Object.defineProperty({__proto__:null,execute:hi,executeMany:yi,supportsCurves:di},Symbol.toStringTag,{value:"Module"})),et=new or;function xi(t){const e=v(t);return et.accelerateGeometry(f(t),N(e),1)}function vi(t,e){return et.execute(f(t),f(e),N(t.spatialReference),null)}const bi=et.supportsCurves(),$i=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:xi,execute:vi,supportsCurves:bi},Symbol.toStringTag,{value:"Module"}));function Pi(t,e){const n=v(t);return w(ur(f(t),f(e),N(n)),n)}function Ni(t){const e=t.map(f),n=v(t);return w(ar(e,N(n)),n)}const Di=ir(),Ci=Object.freeze(Object.defineProperty({__proto__:null,execute:Pi,executeMany:Ni,supportsCurves:Di},Symbol.toStringTag,{value:"Module"})),tt=new cr;function Si(t){const e=v(t);return tt.accelerateGeometry(f(t),N(e),1)}function wi(t,e){return tt.execute(f(t),f(e),N(t.spatialReference),null)}const Ei=tt.supportsCurves(),Mi=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Si,execute:wi,supportsCurves:Ei},Symbol.toStringTag,{value:"Module"}));function Ti(t,e,n,r){const s=new Nt().rotate(e,n,r);return Dt(t,s)}async function Ii(){await Promise.all([Xt(),At(),zt(),Qt()])}const pu=Object.freeze(Object.defineProperty({__proto__:null,area:vr,buffer:Nr,centroid:Ar,clip:Yr,contains:kr,convexHull:Wr,crosses:es,cut:cs,densify:ys,difference:Ps,disjoint:Ss,distance:As,equals:Vs,generalize:Fs,geodesicBuffer:Qs,geodeticArea:eo,geodeticDensify:ro,geodeticLength:ao,intersection:po,intersects:_o,labelPoint:Ao,length:jo,loadAll:Ii,offset:Yo,overlaps:ko,proximity:Wo,relate:ni,rotate:Ti,simplify:ui,symmetricDifference:_i,touches:$i,union:Ci,within:Mi},Symbol.toStringTag,{value:"Module"}));export{Rt as A,to as B,no as C,Bt as D,zt as E,Yt as F,uo as G,Ht as H,Qt as I,Ut as J,To as K,Io as L,Go as M,Fo as N,Uo as O,Ho as P,Qo as Q,Jo as R,Ko as S,ei as T,ti as U,hi as V,yi as W,di as X,Ki as Y,nu as Z,pu as _,Ir as a,Vr as b,Gr as c,us as d,as as e,fs as f,hs as g,vs as h,bs as i,$s as j,Is as k,Gs as l,Xr as m,_r as n,Os as o,ps as p,js as q,Rs as r,xr as s,zs as t,Rr as u,Ls as v,ks as w,Ks as x,Vt as y,Xt as z};
