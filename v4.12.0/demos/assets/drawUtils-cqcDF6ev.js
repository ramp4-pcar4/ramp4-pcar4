import{cD as Z,cc as k,cE as w,aT as H}from"./main-D6UWMbWJ.js";function E(n,e,a,o){if(n.type==="point")return n.x+=e,n.y+=a,n.hasZ&&o!=null&&(n.z+=o),n;if(n.type==="multipoint"){const x=n.points;for(let r=0;r<x.length;r++)x[r]=A(x[r],e,a,o);return n}if(n.type==="extent")return n.xmin+=e,n.xmax+=e,n.ymin+=a,n.ymax+=a,n;const m=Z(n),t=n.type==="polyline"?n.paths:n.rings;for(let x=0;x<m.length;x++){const r=m[x];for(let s=0;s<r.length;s++)r[s]=A(r[s],e,a,o)}return"paths"in n?n.paths=t:n.rings=t,n}function J(n,e,a,o,m){const t=n.clone(),x=o.resolution;if(t.type==="point"){if(m)E(t,e*x,-a*x);else{const r=o.state.transform,s=o.state.inverseTransform,l=r[0]*t.x+r[2]*t.y+r[4],y=r[1]*t.x+r[3]*t.y+r[5];t.x=s[0]*(l+e)+s[2]*(y+a)+s[4],t.y=s[1]*(l+e)+s[3]*(y+a)+s[5]}return t}if(t.type==="multipoint"){if(m)E(t,e*x,-a*x);else{const r=t.points,s=o.state.transform,l=o.state.inverseTransform;for(let y=0;y<r.length;y++){const p=r[y],f=s[0]*p[0]+s[2]*p[1]+s[4],M=s[1]*p[0]+s[3]*p[1]+s[5],c=l[0]*(f+e)+l[2]*(M+a)+l[4],u=l[1]*(f+e)+l[3]*(M+a)+l[5];r[y]=z(p,c,u,void 0)}}return t}if(t.type==="extent"){if(m)E(t,e*x,-a*x);else{const r=o.state.transform,s=o.state.inverseTransform,l=r[0]*t.xmin+r[2]*t.ymin+r[4],y=r[1]*t.xmin+r[3]*t.ymin+r[5],p=r[0]*t.xmax+r[2]*t.ymax+r[4],f=r[1]*t.xmax+r[3]*t.ymax+r[5];t.xmin=s[0]*(l+e)+s[2]*(y+a)+s[4],t.ymin=s[1]*(l+e)+s[3]*(y+a)+s[5],t.xmax=s[0]*(p+e)+s[2]*(f+a)+s[4],t.ymax=s[1]*(p+e)+s[3]*(f+a)+s[5]}return t}if(m)E(t,e*x,-a*x);else{const r=Z(t),s=t.type==="polyline"?t.paths:t.rings,l=o.state.transform,y=o.state.inverseTransform;for(let p=0;p<r.length;p++){const f=r[p];for(let M=0;M<f.length;M++){const c=f[M],u=l[0]*c[0]+l[2]*c[1]+l[4],h=l[1]*c[0]+l[3]*c[1]+l[5],v=y[0]*(u+e)+y[2]*(h+a)+y[4],g=y[1]*(u+e)+y[3]*(h+a)+y[5];f[M]=z(c,v,g,void 0)}}"paths"in t?t.paths=s:t.rings=s}return t}function K(n,e,a,o){if(n.type==="point"){const{x:c,y:u}=n,h=o?o[0]:c,v=o?o[1]:u,g=n.clone(),d=(c-h)*e+h,i=(u-v)*a+v;return g.x=d,g.y=i,g}if(n.type==="multipoint"){const c=Z(n),u=k(),[h,v,g,d]=w(u,[c]),i=o?o[0]:(h+g)/2,T=o?o[1]:(d+v)/2,q=n.clone(),b=q.points;for(let D=0;D<b.length;D++){const j=b[D],[B,C]=j,F=(B-i)*e+i,G=(C-T)*a+T;b[D]=z(j,F,G,void 0)}return q}if(n.type==="extent"){const{xmin:c,xmax:u,ymin:h,ymax:v}=n,g=o?o[0]:(c+u)/2,d=o?o[1]:(v+h)/2,i=n.clone();if(i.xmin=(c-g)*e+g,i.ymax=(v-d)*a+d,i.xmax=(u-g)*e+g,i.ymin=(h-d)*a+d,i.xmin>i.xmax){const T=i.xmin,q=i.xmax;i.xmin=q,i.xmax=T}if(i.ymin>i.ymax){const T=i.ymin,q=i.ymax;i.ymin=q,i.ymax=T}return i}const m=Z(n),t=k(),[x,r,s,l]=w(t,m),y=o?o[0]:(x+s)/2,p=o?o[1]:(l+r)/2,f=n.clone(),M=f.type==="polyline"?f.paths:f.rings;for(let c=0;c<m.length;c++){const u=m[c];for(let h=0;h<u.length;h++){const v=u[h],[g,d]=v,i=(g-y)*e+y,T=(d-p)*a+p;M[c][h]=z(v,i,T,void 0)}}return"paths"in f?f.paths=M:f.rings=M,f}function L(n,e,a,o,m,t){const x=Math.sqrt((a-n)*(a-n)+(o-e)*(o-e));return Math.sqrt((m-n)*(m-n)+(t-e)*(t-e))/x}function N(n,e,a,o=!1){const m=Math.atan2(e.y-a.y,e.x-a.x)-Math.atan2(n.y-a.y,n.x-a.x),t=Math.atan2(Math.sin(m),Math.cos(m));return o?t:H(t)}function A(n,e,a,o){return z(n,n[0]+e,n[1]+a,n[2]!=null&&o!=null?n[2]+o:void 0)}function z(n,e,a,o){const m=[e,a];return n.length>2&&m.push(o??n[2]),n.length>3&&m.push(n[3]),m}export{L as a,J as i,N as m,K as s};
