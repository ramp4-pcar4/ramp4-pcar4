import{$ as o,bP as x}from"./main-DnzmeE4U.js";import{u as g,i as v,c as G,s as N}from"./operatorGeodesicBuffer-CkCgXz8c.js";import{e as l}from"./geodeticCurveType-D_etKnbP.js";let u,y,f;function d(){return!!u&&N()}async function T(){if(!d()){const[t]=await Promise.all([import("./jsonConverter-DldrjI06.js"),g()]);u=t.fromGeometries,y=t.fromGeometry,f=t.toGeometry}}function b(t,r,m={}){let{curveType:n="geodesic",maxDeviation:e=NaN,unit:i}=m;i&&(r=o(r,i,"meters"),e&&(e=o(e,i,"meters")));const a=y(t),s=a.getSpatialReference();return f(v(a.getGeometry(),s,l[n],r,e),s)}function w(t,r,m={}){let{curveType:n="geodesic",maxDeviation:e=NaN,union:i=!1,unit:a}=m;a&&(r=r.map(c=>o(c,a,"meters")),e&&(e=o(e,a,"meters")));const[s,p]=u(t);return G(s,p,l[n],r,e,i).map(c=>f(c,p)).filter(x)}export{b as execute,w as executeMany,d as isLoaded,T as load};
