import{C as h}from"./enums-DBi1-Mm2.js";import{jQ as pe,bC as de,bx as fe,s as xe,n as Et,bo as m,aV as me,bp as zt}from"./main-DnzmeE4U.js";import{Z as At,A as Dt,s as It,d as T,g as ye,j as ge,k as _e,O as Se}from"./CIMSymbolHelper-Bcp4nGf3.js";import{c as Nt,i as Lt,l as ke}from"./Rect-KI3be8Nv.js";import{C as be,q as Yt,B as Bt,K as J,L as Ft,r as lt,e as Gt,F as Pe,H as ve,a as ht,D as we,E as Te,o as X}from"./UpdateTracking2D-CaPtqow6.js";import{w as C,e as pt,G as dt,a as ft,n as K,i as Rt}from"./enums-f9UUstHQ.js";import{a as $,s as tt,t as P,R as Me,c as et,e as Ee,f as ze,G as Ae,A as De}from"./definitions-CBIQmVpq.js";import{a as Ie,i as Ne,c as Le}from"./libtess-D7mkf7O_.js";import{r as Ye,a as Ct}from"./utils-BddLNd1v.js";import{E as Ot}from"./utils-BYqzY6_X.js";import"./earcut-XDcq3zAf.js";import{e as Be}from"./OptimizedGeometry-1qDYm3YK.js";import{a as Fe,i as Ge,s as Re}from"./mat2d-BQA-1WB-.js";import{n as Ce}from"./mat2df32-BCnkwMW8.js";import{S as st}from"./vec2-BnynUbeJ.js";import{e as rt}from"./rasterizingUtils-B8CPqgVl.js";import{a as Oe,b as Ue}from"./dataViewUtils-xig9T3UA.js";function We(t,e,s,r,i,n,o){yt=0;const a=(r-s)*n,c=i&&i.length,u=c?(i[0]-s)*n:a;let l,d,x,p,f,y=Ut(e,s,r,0,u,n,!0);if(y&&y.next!==y.prev){if(c&&(y=Ze(e,s,r,i,y,n)),a>80*n){l=x=e[0+s*n],d=p=e[1+s*n];for(let g=n;g<u;g+=n){const k=e[g+s*n],b=e[g+1+s*n];l=Math.min(l,k),d=Math.min(d,b),x=Math.max(x,k),p=Math.max(p,b)}f=Math.max(x-l,p-d),f=f!==0?1/f:0}Z(y,t,n,l,d,f,o,0)}}function Ut(t,e,s,r,i,n,o){let a;if(o===Ke(t,e,s,r,i,n)>0)for(let c=r;c<i;c+=n)a=Wt(c+e*n,t[c+e*n],t[c+1+e*n],a);else for(let c=i-n;c>=r;c-=n)a=Wt(c+e*n,t[c+e*n],t[c+1+e*n],a);return a&&N(a,a.next)&&(q(a),a=a.next),a}function V(t,e=t){if(!t)return t;let s,r=t;do if(s=!1,r.steiner||!N(r,r.next)&&S(r.prev,r,r.next)!==0)r=r.next;else{if(q(r),r=e=r.prev,r===r.next)break;s=!0}while(s||r!==e);return e}function Z(t,e,s,r,i,n,o,a){if(!t)return;!a&&n&&(t=Ht(t,r,i,n));let c=t;for(;t.prev!==t.next;){const u=t.prev,l=t.next;if(n?Xe(t,r,i,n):He(t))e.push(u.index/s+o),e.push(t.index/s+o),e.push(l.index/s+o),q(t),t=l.next,c=l.next;else if((t=l)===c){a?a===1?Z(t=ts(t,e,s,o),e,s,r,i,n,o,2):a===2&&es(t,e,s,r,i,n,o):Z(V(t),e,s,r,i,n,o,1);break}}}function He(t){const e=t.prev,s=t,r=t.next;if(S(e,s,r)>=0)return!1;let i=t.next.next;const n=i;let o=0;for(;i!==t.prev&&(o===0||i!==n);){if(o++,O(e.x,e.y,s.x,s.y,r.x,r.y,i.x,i.y)&&S(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function Xe(t,e,s,r){const i=t.prev,n=t,o=t.next;if(S(i,n,o)>=0)return!1;const a=i.x<n.x?i.x<o.x?i.x:o.x:n.x<o.x?n.x:o.x,c=i.y<n.y?i.y<o.y?i.y:o.y:n.y<o.y?n.y:o.y,u=i.x>n.x?i.x>o.x?i.x:o.x:n.x>o.x?n.x:o.x,l=i.y>n.y?i.y>o.y?i.y:o.y:n.y>o.y?n.y:o.y,d=xt(a,c,e,s,r),x=xt(u,l,e,s,r);let p=t.prevZ,f=t.nextZ;for(;p&&p.z>=d&&f&&f.z<=x;){if(p!==t.prev&&p!==t.next&&O(i.x,i.y,n.x,n.y,o.x,o.y,p.x,p.y)&&S(p.prev,p,p.next)>=0||(p=p.prevZ,f!==t.prev&&f!==t.next&&O(i.x,i.y,n.x,n.y,o.x,o.y,f.x,f.y)&&S(f.prev,f,f.next)>=0))return!1;f=f.nextZ}for(;p&&p.z>=d;){if(p!==t.prev&&p!==t.next&&O(i.x,i.y,n.x,n.y,o.x,o.y,p.x,p.y)&&S(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;f&&f.z<=x;){if(f!==t.prev&&f!==t.next&&O(i.x,i.y,n.x,n.y,o.x,o.y,f.x,f.y)&&S(f.prev,f,f.next)>=0)return!1;f=f.nextZ}return!0}function Wt(t,e,s,r){const i=H.create(t,e,s);return r?(i.next=r.next,i.prev=r,r.next.prev=i,r.next=i):(i.prev=i,i.next=i),i}function q(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function Ve(t){let e=t,s=t;do(e.x<s.x||e.x===s.x&&e.y<s.y)&&(s=e),e=e.next;while(e!==t);return s}function Ze(t,e,s,r,i,n){const o=new Array;for(let a=0,c=r.length;a<c;a++){const u=Ut(t,e,s,r[a]*n,a<c-1?r[a+1]*n:s*n,n,!1);u===u.next&&(u.steiner=!0),o.push(Ve(u))}o.sort($e);for(const a of o)i=qe(a,i);return i}function qe(t,e){const s=Qe(t,e);if(!s)return e;const r=Vt(s,t);return V(r,r.next),V(s,s.next)}function Qe(t,e){let s=e;const r=t.x,i=t.y;let n,o=-1/0;do{if(i<=s.y&&i>=s.next.y&&s.next.y!==s.y){const x=s.x+(i-s.y)*(s.next.x-s.x)/(s.next.y-s.y);if(x<=r&&x>o){if(o=x,x===r){if(i===s.y)return s;if(i===s.next.y)return s.next}n=s.x<s.next.x?s:s.next}}s=s.next}while(s!==e);if(!n)return null;if(r===o)return n.prev;const a=n,c=n.x,u=n.y;let l,d=1/0;for(s=n.next;s!==a;)r>=s.x&&s.x>=c&&r!==s.x&&O(i<u?r:o,i,c,u,i<u?o:r,i,s.x,s.y)&&(l=Math.abs(i-s.y)/(r-s.x),(l<d||l===d&&s.x>n.x)&&Q(s,t)&&(n=s,d=l)),s=s.next;return n}function Ht(t,e,s,r){let i;for(;i!==t;i=i.next){if(i=i||t,i.z===null&&(i.z=xt(i.x,i.y,e,s,r)),i.prev.next!==i||i.next.prev!==i)return i.prev.next=i,i.next.prev=i,Ht(t,e,s,r);i.prevZ=i.prev,i.nextZ=i.next}return t.prevZ.nextZ=null,t.prevZ=null,je(t)}function je(t){let e,s=1;for(;;){let r,i=t;t=null,e=null;let n=0;for(;i;){n++,r=i;let o=0;for(;o<s&&r;o++)r=r.nextZ;let a=s;for(;o>0||a>0&&r;){let c;o===0?(c=r,r=r.nextZ,a--):a!==0&&r?i.z<=r.z?(c=i,i=i.nextZ,o--):(c=r,r=r.nextZ,a--):(c=i,i=i.nextZ,o--),e?e.nextZ=c:t=c,c.prevZ=e,e=c}i=r}if(e.nextZ=null,s*=2,n<2)return t}}function S(t,e,s){return(e.y-t.y)*(s.x-e.x)-(e.x-t.x)*(s.y-e.y)}function Xt(t,e,s,r){return!!(N(t,e)&&N(s,r)||N(t,r)&&N(s,e))||S(t,e,s)>0!=S(t,e,r)>0&&S(s,r,t)>0!=S(s,r,e)>0}function Je(t,e){let s=t;do{if(s.index!==t.index&&s.next.index!==t.index&&s.index!==e.index&&s.next.index!==e.index&&Xt(s,s.next,t,e))return!0;s=s.next}while(s!==t);return!1}function Ke(t,e,s,r,i,n){let o=0;for(let a=r,c=i-n;a<i;a+=n)o+=(t[c+e*n]-t[a+e*n])*(t[a+1+e*n]+t[c+1+e*n]),c=a;return o}function O(t,e,s,r,i,n,o,a){return(i-o)*(e-a)-(t-o)*(n-a)>=0&&(t-o)*(r-a)-(s-o)*(e-a)>=0&&(s-o)*(n-a)-(i-o)*(r-a)>=0}function Q(t,e){return S(t.prev,t,t.next)<0?S(t,e,t.next)>=0&&S(t,t.prev,e)>=0:S(t,e,t.prev)<0||S(t,t.next,e)<0}function xt(t,e,s,r,i){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-s)*i)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-r)*i)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function N(t,e){return t.x===e.x&&t.y===e.y}function $e(t,e){return t.x-e.x}function ts(t,e,s,r){let i=t;do{const n=i.prev,o=i.next.next;!N(n,o)&&Xt(n,i,i.next,o)&&Q(n,o)&&Q(o,n)&&(e.push(n.index/s+r),e.push(i.index/s+r),e.push(o.index/s+r),q(i),q(i.next),i=t=o),i=i.next}while(i!==t);return i}function es(t,e,s,r,i,n,o){let a=t;do{let c=a.next.next;for(;c!==a.prev;){if(a.index!==c.index&&ss(a,c)){let u=Vt(a,c);return a=V(a,a.next),u=V(u,u.next),Z(a,e,s,r,i,n,o,0),void Z(u,e,s,r,i,n,o,0)}c=c.next}a=a.next}while(a!==t)}function ss(t,e){return t.next.index!==e.index&&t.prev.index!==e.index&&!Je(t,e)&&Q(t,e)&&Q(e,t)&&rs(t,e)}function rs(t,e){let s=t,r=!1;const i=(t.x+e.x)/2,n=(t.y+e.y)/2;do s.y>n!=s.next.y>n&&s.next.y!==s.y&&i<(s.next.x-s.x)*(n-s.y)/(s.next.y-s.y)+s.x&&(r=!r),s=s.next;while(s!==t);return r}function Vt(t,e){const s=H.create(t.index,t.x,t.y),r=H.create(e.index,e.x,e.y),i=t.next,n=e.prev;return t.next=e,e.prev=t,s.next=i,i.prev=s,r.next=s,s.prev=r,n.next=r,r.prev=n,r}class H{constructor(){this.index=0,this.x=0,this.y=0,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}static create(e,s,r){const i=yt<mt.length?mt[yt++]:new H;return i.index=e,i.x=s,i.y=r,i.prev=null,i.next=null,i.z=null,i.prevZ=null,i.nextZ=null,i.steiner=!1,i}}const mt=[],is=8096;let yt=0;for(let t=0;t<is;t++)mt.push(new H);const ns=1e-5,L=new Nt(0,0,0,1,0),gt=new Nt(0,0,0,1,0);function Zt(t,e,s){let r=0;for(let i=1;i<s;i++){const n=t[2*(e+i-1)],o=t[2*(e+i-1)+1];r+=(t[2*(e+i)]-n)*(t[2*(e+i)+1]+o)}return r}function os(t,e,s,r,i){let n=0;const o=2;for(let a=s;a<r;a+=3){const c=(t[a]-i)*o,u=(t[a+1]-i)*o,l=(t[a+2]-i)*o;n+=Math.abs((e[c]-e[l])*(e[u+1]-e[c+1])-(e[c]-e[u])*(e[l+1]-e[c+1]))}return n}function as(t,e){const{coords:s,lengths:r}=e,i=0,n=t;let o=0;for(let a=0;a<r.length;){let c=a,u=r[a],l=Zt(s,o,u);const d=[];for(;++c<r.length;){const y=r[c],g=Zt(s,o+u,y);if(!(g>0))break;l+=g,d.push(o+u),u+=y}const x=n.length;We(n,s,o,o+u,d,2,i);const p=os(n,s,x,n.length,i),f=Math.abs(l);if(Math.abs((p-f)/Math.max(1e-7,f))>ns)return n.length=0,!1;a=c,o+=u}return!0}function cs(t){const{coords:e,lengths:s}=t,{buffer:r}=Ie(e,s);return r}function us(t,e,s){let r=0;for(let i=0;i<t.lengths.length;i++){const n=t.lengths[i];for(let o=0;o<n;o++){const a=t.coords[2*(o+r)],c=t.coords[2*(o+r)+1];if(a<e||a>s||c<e||c>s)return!0}r+=n}return!1}function qt(t,e){if(t==null)return null;if(!us(t,-128,$+128))return t;L.setPixelMargin(e),L.reset(Lt.Polygon);let s=0;for(let o=0;o<t.lengths.length;o++){const a=t.lengths[o];let c=t.coords[2*(0+s)],u=t.coords[2*(0+s)+1];L.moveTo(c,u);for(let l=1;l<a;l++)c=t.coords[2*(l+s)],u=t.coords[2*(l+s)+1],L.lineTo(c,u);L.close(),s+=a}const r=L.result(!1);if(!r)return null;const i=[],n=[];for(const o of r){let a=0;for(const c of o)n.push(c.x),n.push(c.y),a++;i.push(a)}return new Be(i,n)}function ls(t,e){gt.setPixelMargin(e);const s=gt,r=-e,i=$+e;let n=[],o=!1;if(!t.nextPath())return null;let a=t.pathLength(),c=!0;for(;c;){t.seekPathStart();const u=[];if(!t.pathSize)return null;s.reset(Lt.LineString),t.nextPoint();let l=t.x,d=t.y;if(o)s.moveTo(l,d);else{if(l<r||l>i||d<r||d>i){o=!0;continue}u.push({x:l,y:d})}let x=!1;for(;t.nextPoint();)if(l=t.x,d=t.y,o)s.lineTo(l,d);else{if(l<r||l>i||d<r||d>i){x=!0;break}u.push({x:l,y:d})}if(x)o=!0;else{if(o){const p=s.resultWithStarts();if(p)for(const f of p)n.push({...f,pathLength:a})}else n.push({line:u,start:0,pathLength:a});c=t.nextPath(),a=c?t.pathLength():0,o=!1}}return n=n.filter(u=>u.line.length>1),n.length===0?null:n}L.setExtent($),gt.setExtent($);const hs=96/72;let Qt=class{static executeEffects(t,e,s,r,i){const n=hs,o=At(t);let a=new It(e);for(const c of t){const u=Dt(c);u&&(a=u.execute(a,c,n,s,r,o,i))}return a}static applyEffects(t,e,s){if(!t)return e;const r=At(t);let i,n=new It(T.fromJSONCIM(e));for(const c of t){const u=Dt(c);u&&(n=u.execute(n,c,1,null,s,r,!1))}const o=[];let a=null;for(;i=n.next();)o.push(...pe(i)),a=i.geometryType;return o.length===0||a===null?null:a==="esriGeometryPolygon"?{rings:o}:{paths:o}}},jt=null;function _t(){return jt}async function ps(){jt=await import("./geometryEngineJSON-CGn_tfx8.js").then(t=>t.g)}function Jt(t){switch(t){case h.BYTE:case h.UNSIGNED_BYTE:return 1;case h.SHORT:case h.UNSIGNED_SHORT:case h.HALF_FLOAT:return 2;case h.FLOAT:case h.INT:case h.UNSIGNED_INT:return 4}}function ds(t){const e=[],s=[],r=[];for(const i of t){const n=Jt(i.type)*i.count;switch(n%2||n%4||4){case 4:e.push(i);continue;case 2:s.push(i);continue;case 1:r.push(i);continue;default:throw new Error("Found unexpected dataType byte count")}}return e.push(...s),e.push(...r),e}let fs=class le{static fromVertexSpec(e,s){const{attributes:r,optionalAttributes:i}=e;let n,o,a;const c=[];for(const y in r){const g=r[y];g.pack==="position"?n={...g,name:y,offset:0}:g.pack==="id"?o={...g,name:y,offset:4}:y==="bitset"?a={...g,name:y,offset:7}:c.push({...g,name:y})}for(const y in i)if(s[y]===!0){const g=i[y];c.push({...g,name:y})}const u=ds(c),l=[];let d=8,x=1;for(const y of u)l.push({...y,offset:d}),d+=Jt(y.type)*y.count,y.packAlternating&&(x=Math.max(y.packAlternating.count,x));const p=Uint32Array.BYTES_PER_ELEMENT,f=d%p;return new le(n,o,a,l,d+(f?p-f:0),x)}constructor(e,s,r,i,n,o){this.position=e,this.id=s,this.bitset=r,this.standardAttributes=i,this.stride=n,this.packVertexCount=o,i.push(r),this._attributes=[e,s,r,...i]}get attributeLayout(){if(!this._attributeLayout){const e=Ye(this._attributes),s=this._attributes.map(r=>({name:r.name,count:r.count,offset:r.offset,type:r.type,packPrecisionFactor:r.packPrecisionFactor,normalized:r.normalized??!1}));this._attributeLayout={attributes:s,hash:e,stride:this.stride}}return this._attributeLayout}},xs=class he{static fromVertexSpec(e,s){const r=fs.fromVertexSpec(e,s);return new he(r)}constructor(e){this._spec=e,this._packed=new Uint8Array(this._spec.stride*this._spec.packVertexCount),this._packedU32View=new Uint32Array(this._packed.buffer),this._dataView=new DataView(this._packed.buffer)}get attributeLayout(){return this._spec.attributeLayout}get stride(){return this._spec.stride}writeVertex(e,s,r,i,n,o){for(let a=0;a<this._spec.packVertexCount;a++){const c=a*this._spec.stride;this._packPosition(r,i,c),this._packId(s,c);const u=this._spec.bitset;if(o){if(u.packTessellation){const l=u.packTessellation(o,n,r,i);this._pack(l,u,c)}for(const l of this._spec.standardAttributes)if(l.packTessellation!=null){const d=l.packTessellation(o,n,r,i);this._pack(d,l,c)}else if(l.packAlternating?.packTessellation){const d=l.packAlternating.packTessellation(o,n,r,i);for(let x=0;x<this._spec.packVertexCount;x++){const p=d[x];this._pack(p,l,x*this._spec.stride)}}}}e.vertexWriteRegion(this._packedU32View)}pack(e,s){for(const r of this._spec.standardAttributes)if(r.pack&&typeof r.pack!="string"){const i=r.pack(e,s);for(let n=0;n<this._spec.packVertexCount;n++)this._pack(i,r,n*this._spec.stride)}else if(r.packAlternating?.pack){const i=r.packAlternating.pack(e,s);for(let n=0;n<this._spec.packVertexCount;n++){const o=i[n];this._pack(o,r,n*this._spec.stride)}}}_packPosition(e,s,r){const{offset:i}=this._spec.position,n=this._spec.position.packPrecisionFactor??1,o=Ue(e*n,s*n);this._dataView.setUint32(r+i,o,!0)}_packId(e,s){const r=e*(this._spec.id.packPrecisionFactor??1),i=4278190080&this._dataView.getUint32(s+this._spec.id.offset,!0);this._dataView.setUint32(s+this._spec.id.offset,r|i,!0)}_pack(e,s,r){Oe(this._dataView,e,s,r)}};function ms(t){if(!t)return!1;for(const e of t)switch(e.effect.type){case"CIMGeometricEffectBuffer":case"CIMGeometricEffectOffset":case"CIMGeometricEffectDonut":return!0}return!1}let Y=class{constructor(t,e,s,r){this._instanceId=t,this._evaluator=e,this._enabledOptionalAttributes=s,this._viewParams=r,this._evaluator.evaluator=i=>this.vertexSpec.createComputedParams(i)}get _vertexPack(){if(!this._cachedVertexPack){const t=xs.fromVertexSpec(this.vertexSpec,this._enabledOptionalAttributes);this._evaluator.hasDynamicProperties||t.pack(this._evaluator.evaluatedMeshParams,this._viewParams),this._cachedVertexPack=t}return this._cachedVertexPack}get evaluatedMeshParams(){return this._evaluator.evaluatedMeshParams}get hasEffects(){return!!this.evaluatedMeshParams.effects}get instanceId(){return this._instanceId}get attributeLayout(){return this._vertexPack.attributeLayout}get _preventEffectClipping(){return!1}setReferences(t){this._references=t}getBoundsInfo(){return null}getTileInfo(){return this._viewParams.tileInfo}async loadDependencies(){ms(this._evaluator.inputMeshParams.effects?.effectInfos)&&await ps()}enqueueRequest(t,e,s){this._evaluator.hasDynamicProperties&&this._evaluator.enqueueRequest(t,e,s)}write(t,e,s,r,i){this.ensurePacked(e,s,r);const n=this.evaluatedMeshParams.effects;if(!n||n.length===0)return void this._write(t,s,void 0,i);const o=s.readGeometryForDisplay()?.clone();if(!o)return;const a=T.fromOptimizedCIM(o,s.geometryType),c=_t();a.invertY();const u=t.id||"",l=Qt.executeEffects(n,a,u,c,this._preventEffectClipping);let d;for(;d=l.next();)d.invertY(),this._write(t,s,d,i)}ensurePacked(t,e,s){if(!this._evaluator.hasDynamicProperties)return;const r=this._evaluator.evaluateMeshParams(t,e,s);this._vertexPack.pack(r,this._viewParams)}hasArcadeDependency(t){return this._evaluator.hasArcadeDependency(t)}_writeVertex(t,e,s,r,i){const n=this.evaluatedMeshParams;this._vertexPack.writeVertex(t,e,s,r,n,i)}};const ys=100,gs=de("featurelayer-fast-triangulation-enabled");let St=class extends Y{async loadDependencies(){await Promise.all([super.loadDependencies(),Ne()])}_write(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);i&&(t.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(t,e,i),t.recordEnd())}_clip(t){if(!t)return null;const e=this.hasEffects;return qt(t,e?256:8)}_writeGeometry(t,e,s){const r=s.maxLength>ys,i=[],n=this.createTesselationParams(e);if(!r&&gs&&as(i,s))return void(i.length&&this._writeVertices(t,e,s.coords,n,i));const o=cs(s);this._writeVertices(t,e,o,n)}_writeVertices(t,e,s,r,i){const n=e.getDisplayId(),o=t.vertexCount(),a=this.hasEffects;let c=0;if(i)for(const u of i){const l=s[2*u],d=s[2*u+1];a&&t.recordBounds(l,d,0,0),this._writeVertex(t,n,l,d,r),c++}else for(let u=0;u<s.length;u+=2){const l=Math.round(s[u]),d=Math.round(s[u+1]);a&&t.recordBounds(l,d,0,0),this._writeVertex(t,n,l,d,r),c++}t.indexEnsureSize(c);for(let u=0;u<c;u++)t.indexWrite(u+o)}};const _s={createComputedParams:t=>t,optionalAttributes:{},attributes:{id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1},pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},inverseArea:{type:h.FLOAT,count:1,packTessellation:({inverseArea:t})=>t}}};let Ss=class extends St{constructor(){super(...arguments),this.vertexSpec=_s}createTesselationParams(t){return{inverseArea:1/t.readGeometryArea()}}};const ks=()=>Et.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.meshWriterUtils"),bs=0,Ps=100;function U(t,e){return[!!t?.minScale&&e.scaleToZoom(t.minScale)||bs,!!t?.maxScale&&e.scaleToZoom(t.maxScale)||Ps]}function A(t){return 1<<t}function W(t){let e=0;for(const[s,r]of t)r&&(e|=1<<s);return e}function _(t){let e;if(!t)return[0,0,0,0];if(typeof t=="string"){const o=fe.fromString(t);if(!o)return ks().errorOnce(new xe("mapview:mesh-processing","Unable to parse string into color",{color:t})),[0,0,0,0];e=o.toArray()}else e=t;const[s,r,i,n]=e;return[s*(n/255),r*(n/255),i*(n/255),n]}function vs(t){switch(t){case"butt":case C.Butt:return pt.BUTT;case"round":case C.Round:return pt.ROUND;case"square":case C.Square:return pt.SQUARE}}function ws(t){switch(t){case"bevel":case dt.Bevel:return ft.BEVEL;case"miter":case dt.Miter:return ft.MITER;case"round":case dt.Round:return ft.ROUND}}function kt(t,e){return Math.round(Math.min(Math.sqrt(t*e),255))}function it(t,e){return Math.round(t*e)/e}const j={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:h.SHORT,count:2,packPrecisionFactor:tt,pack:({scaleInfo:t},{tileInfo:e})=>U(t,e)}},attributes:{id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1},pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>_(t)}}};let bt=class extends St{constructor(){super(...arguments),this.vertexSpec=j}createTesselationParams(t){return null}};const B={createComputedParams:t=>t,optionalAttributes:j.optionalAttributes,attributes:{...j.attributes,tlbr:{count:4,type:h.UNSIGNED_SHORT,pack:({sprite:t})=>{const{rect:e,width:s,height:r}=t,i=e.x+P,n=e.y+P;return[i,n,i+s,n+r]}},inverseRasterizationScale:{count:1,type:h.BYTE,packPrecisionFactor:16,pack:({sprite:t})=>1/t.rasterizationScale}}};let Kt=class extends bt{constructor(){super(...arguments),this.vertexSpec=B}_write(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);if(!i)return;const n=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(t,e,i),t.recordEnd()}};function nt(t){const{sprite:e,aspectRatio:s,scaleProportionally:r}=t,i=m(t.height),n=i>0?i:e.height;let o=i*s;return o<=0?o=e.width:r&&(o*=e.width/e.height),{width:o,height:n}}function $t(t){const{applyRandomOffset:e,sampleAlphaOnly:s}=t;return W([[be,e],[Yt,s]])}const te={createComputedParams:t=>t,optionalAttributes:B.optionalAttributes,attributes:{...B.attributes,bitset:{count:1,type:h.UNSIGNED_BYTE,pack:$t},width:{count:1,type:h.HALF_FLOAT,pack:t=>nt(t).width},height:{count:1,type:h.HALF_FLOAT,pack:t=>nt(t).height},offset:{count:2,type:h.HALF_FLOAT,pack:({offsetX:t,offsetY:e})=>[m(t),-m(e)]},scale:{count:2,type:h.UNSIGNED_BYTE,packPrecisionFactor:16,pack:({scaleX:t,scaleY:e})=>[t,e]},angle:{count:1,type:h.UNSIGNED_BYTE,pack:({angle:t})=>ke(t)}}};let Ts=class extends Kt{constructor(){super(...arguments),this.vertexSpec=te}},Ms=class{constructor(){this.extrusionOffsetX=0,this.extrusionOffsetY=0,this.normalX=0,this.normalY=0,this.directionX=0,this.directionY=0,this.distance=0,this.pathLength=0}};const E={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:h.SHORT,count:2,packPrecisionFactor:tt,pack:({scaleInfo:t},{tileInfo:e})=>U(t,e)}},attributes:{id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},bitset:{type:h.UNSIGNED_BYTE,count:1},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>_(t)},offset:{type:h.BYTE,count:2,packPrecisionFactor:16,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e})=>[it(t,16),it(e,16)]},normal:{type:h.BYTE,count:2,packPrecisionFactor:16,packTessellation:({normalX:t,normalY:e})=>[it(t,16),it(e,16)]},halfWidth:{type:h.HALF_FLOAT,count:1,pack:({width:t})=>m(.5*t)},referenceHalfWidth:{type:h.HALF_FLOAT,count:1,pack:({referenceWidth:t})=>m(.5*t)}}};let Es=class{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0}};const ee=65535;let ot=class extends Y{constructor(t,e,s,r){super(t,e,s,r),this.vertexSpec=E,this._currentWrite=new Es,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:ee,textured:!1},this._tessParams=new Ms,this._initializeTessellator()}writeLineVertices(t,e,s){const r=this._getLines(e);r!=null&&this._writeVertices(t,s,r)}_initializeTessellator(){this._lineTessellator=new Le(this._writeTesselatedVertex.bind(this),this._writeTriangle.bind(this),!0)}_write(t,e,s){const r=s??T.fromFeatureSetReaderCIM(e);r&&this._writeGeometry(t,e,r)}_writeGeometry(t,e,s,r){t.recordStart(this.instanceId,this.attributeLayout,r),this.writeLineVertices(t,s,e),t.recordEnd()}_getLines(t){return ls(t,Ct(this.evaluatedMeshParams))}_writeVertices(t,e,s){const{_currentWrite:r,_tessellationOptions:i,evaluatedMeshParams:n}=this,{width:o,capType:a,joinType:c,miterLimit:u,hasSizeVV:l}=n,d=m(.5*o);i.halfWidth=d,i.capType=vs(a),i.joinType=ws(c),i.miterLimit=u;const x=!l;r.out=t,r.id=e.getDisplayId(),r.vertexCount=0,r.indexCount=0,r.vertexFrom=t.vertexCount(),r.vertexBounds=x&&d<Me?0:1;for(const{line:p,start:f,pathLength:y}of s)i.initialDistance=f%ee,r.pathLength=y,this._lineTessellator.tessellate(p,i,x)}_writeTesselatedVertex(t,e,s,r,i,n,o,a,c,u,l){const{out:d,id:x,vertexBounds:p,pathLength:f}=this._currentWrite;return this.hasEffects&&d.recordBounds(t,e,p,p),this._tessParams.extrusionOffsetX=o,this._tessParams.extrusionOffsetY=a,this._tessParams.normalX=c,this._tessParams.normalY=u,this._tessParams.directionX=i,this._tessParams.directionY=n,this._tessParams.distance=l,this._tessParams.pathLength=f,this._writeVertex(d,x,t,e,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(t,e,s){const{out:r}=this._currentWrite;r.indexEnsureSize(3),r.indexWrite(t),r.indexWrite(e),r.indexWrite(s),this._currentWrite.indexCount+=3}};const se={createComputedParams:t=>t,optionalAttributes:E.optionalAttributes,attributes:{...E.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:t=>0},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>_(t)}}},Pt={createComputedParams:t=>t,optionalAttributes:E.optionalAttributes,attributes:{...E.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:t=>W([[Bt,!0]])},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>_(t)}}};let vt=class extends ot{constructor(){super(...arguments),this.vertexSpec=Pt}},wt=class extends bt{constructor(t,e,s,r){super(t,e,s,r),this.vertexSpec=se,this._lineMeshWriter=this._createOutlineWriter(t,e,s,r)}_createOutlineWriter(t,e,s,r){return new vt(t,e,s,r)}_write(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);i&&(t.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(t,e,i),this._lineMeshWriter.writeLineVertices(t,T.fromOptimizedCIM(i,"esriGeometryPolyline"),e),t.recordEnd())}_clip(t){return t?qt(t,Ct(this.evaluatedMeshParams)):null}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._lineMeshWriter.ensurePacked(t,e,s)}enqueueRequest(t,e,s){super.enqueueRequest(t,e,s),this._lineMeshWriter.enqueueRequest(t,e,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}};const at=te,zs=Pt,As={createComputedParams:t=>t,optionalAttributes:at.optionalAttributes,attributes:{...at.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:t=>$t(t)},aux1:{count:1,type:h.HALF_FLOAT,pack:t=>nt(t).width},aux2:{count:1,type:h.HALF_FLOAT,pack:t=>nt(t).height},aux3:{count:2,type:h.HALF_FLOAT,pack:({offsetX:t,offsetY:e})=>[m(t),m(e)]},aux4:{count:2,type:h.UNSIGNED_BYTE,pack:({scaleX:t,scaleY:e})=>[t*J,e*J]}}},Ds={createComputedParams:t=>t,optionalAttributes:at.optionalAttributes,attributes:{...at.attributes,color:zs.attributes.color,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:t=>W([[Bt,!0]])},aux1:{count:1,type:h.HALF_FLOAT,pack:t=>m(.5*t.width)},aux2:{count:1,type:h.HALF_FLOAT,pack:t=>m(.5*t.referenceWidth)},aux3:{count:2,type:h.HALF_FLOAT,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e})=>[t,e]},aux4:{count:2,type:h.UNSIGNED_BYTE,packTessellation:({normalX:t,normalY:e})=>[t*J+Ft,e*J+Ft]}}};let Is=class extends vt{constructor(){super(...arguments),this.vertexSpec=Ds}},Ns=class extends wt{constructor(){super(...arguments),this.vertexSpec=As}_createOutlineWriter(t,e,s,r){return new Is(t,e,s,r)}_write(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);if(!i)return;const n=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(t,e,i),this._lineMeshWriter.writeLineVertices(t,T.fromOptimizedCIM(i,"esriGeometryPolyline"),e),t.recordEnd()}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._lineMeshWriter.ensurePacked(t,e,s)}enqueueRequest(t,e,s){super.enqueueRequest(t,e,s),this._lineMeshWriter.enqueueRequest(t,e,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}};const Ls=()=>Et.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.fill.GradientSizeHelper");let Ys=class{constructor(t,e){this._size=t,this._sizeUnits=e,this._relativeSize=null}get relativeSize(){return this._relativeSize??=this.calculateRelativeSize(),this._relativeSize}calculateRelativeSize(){if(this._sizeUnits===K.Relative){const t=Math.min(this._size/100,1);return[t,t]}return this.calculateRelativeSizeFromAbsolute()}},Tt=class extends Ys{constructor(t,e,s,r){super(e,s),this.rotationMatrix00=1,this.rotationMatrix01=0,this.rotationMatrix10=0,this.rotationMatrix11=1,this.bounds={xmin:1/0,ymin:1/0,xmax:-1/0,ymax:-1/0},this.rotationMatrix00=Math.cos(r),this.rotationMatrix01=-Math.sin(r),this.rotationMatrix10=-this.rotationMatrix01,this.rotationMatrix11=this.rotationMatrix00;const{bounds:i,rotationMatrix00:n,rotationMatrix01:o,rotationMatrix10:a,rotationMatrix11:c}=this;t.forEachVertex((u,l)=>{const d=u*n+l*o,x=u*a+l*c;i.xmin=Math.min(i.xmin,d),i.ymin=Math.min(i.ymin,x),i.xmax=Math.max(i.xmax,d),i.ymax=Math.max(i.ymax,x)}),this.center=[(i.xmin+i.xmax)/2,(i.ymin+i.ymax)/2]}},Bs=class extends Tt{constructor(t,e,s,r){super(t,e,s,r),this.method="linear"}getRelativePosition(t,e){const{rotationMatrix00:s,rotationMatrix01:r,bounds:i}=this,{xmin:n,xmax:o}=i;return[(t*s+e*r-n)/(o-n),0]}calculateRelativeSizeFromAbsolute(){const{_size:t,bounds:e}=this,{xmin:s,xmax:r}=e;return[m(t)/(r-s),0]}},Fs=class extends Tt{constructor(t,e,s,r){super(t,e,s,r),this.method="rectangular"}getRelativePosition(t,e){const{bounds:s,center:r,rotationMatrix00:i,rotationMatrix01:n,rotationMatrix10:o,rotationMatrix11:a}=this,c=t*o+e*a,u=t*i+e*n-r[0],l=c-r[1];return[u*(2/(s.xmax-s.xmin)),-l*(2/(s.ymax-s.ymin))]}calculateRelativeSizeFromAbsolute(){const{_size:t,bounds:e}=this,{xmin:s,ymin:r,xmax:i,ymax:n}=e;return[m(2*t)/(i-s),m(2*t)/(n-r)]}};class Gs extends Tt{constructor(e,s,r){super(e,s,r,0),this.method="circular";const{xmin:i,xmax:n,ymin:o,ymax:a}=this.bounds,c=n-i,u=a-o;this.radius=Math.sqrt(c*c+u*u)/2}getRelativePosition(e,s){const{center:r,radius:i}=this;return[(e-r[0])/i,-((s-r[1])/i)]}calculateRelativeSizeFromAbsolute(){const{_size:e}=this;return[m(e)/this.radius,0]}}function Rs(t,e){if(t==null)return null;const s=me(e.angle),r=e.gradientSize,i=e.gradientSizeUnits;switch(e.gradientMethod.toLowerCase()){case"linear":return new Bs(t,r,i,s);case"rectangular":return new Fs(t,r,i,s);case"circular":return new Gs(t,r,i);default:return Ls().errorOnce(`Gradient fill method "${e.gradientMethod}" currently unsupported.`),null}}const Cs={createComputedParams:t=>t,optionalAttributes:j.optionalAttributes,attributes:{...j.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:({gradientSizeUnits:t,gradientType:e})=>{let s=0;return t===K.Absolute&&(s|=A(Gt.isAbsolute)),e.toLowerCase()==="discrete"&&(s|=A(Gt.isDiscrete)),s}},tlbr:{count:4,type:h.UNSIGNED_SHORT,pack:({sprite:t})=>{const{rect:e,width:s,height:r}=t,i=e.x+P+et,n=e.y+P;return[i,n,i+s-2*et,n+r]}},relativePosition:{count:2,type:h.HALF_FLOAT,packTessellation:({gradientStats:t},e,s,r)=>t?.getRelativePosition(s,r)??[0,0]},relativeGradientSize:{count:2,type:h.HALF_FLOAT,packTessellation:({gradientStats:t})=>t?.relativeSize??[1,1]},gradientMethod:{count:1,type:h.UNSIGNED_BYTE,pack:({gradientMethod:t})=>{switch(t.toLowerCase()){case"rectangular":return lt.rectangular;case"circular":return lt.circular;default:return lt.linear}}}}};let Os=class extends St{constructor(){super(...arguments),this.vertexSpec=Cs}get _preventEffectClipping(){return!0}createTesselationParams(t){return{gradientStats:Rs(t.readGeometryForDisplay(),this.evaluatedMeshParams)}}_write(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);if(!i)return;const n=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(t,e,i),t.recordEnd()}};const Us={optionalAttributes:B.optionalAttributes,createComputedParams:t=>t,attributes:{...B.attributes,...se.attributes}},Ws={optionalAttributes:B.optionalAttributes,createComputedParams:t=>t,attributes:{...B.attributes,...Pt.attributes}};class Hs extends vt{constructor(){super(...arguments),this.vertexSpec=Ws}}class Xs extends wt{constructor(){super(...arguments),this.vertexSpec=Us}_createOutlineWriter(e,s,r,i){return new Hs(e,s,r,i)}_write(e,s,r){const i=r?.asOptimized()??s.readGeometryForDisplay(),n=this._clip(i);if(!n)return;const o=this.evaluatedMeshParams.sprite?.textureBinding;e.recordStart(this.instanceId,this.attributeLayout,o),this._writeGeometry(e,s,n),this._lineMeshWriter.writeLineVertices(e,T.fromOptimizedCIM(n,"esriGeometryPolyline"),s),e.recordEnd()}ensurePacked(e,s,r){super.ensurePacked(e,s,r),this._lineMeshWriter.ensurePacked(e,s,r)}enqueueRequest(e,s,r){super.enqueueRequest(e,s,r),this._lineMeshWriter.enqueueRequest(e,s,r)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const Vs={createComputedParams:t=>t,optionalAttributes:{},attributes:{pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1},offset:{type:h.BYTE,count:2,packAlternating:{count:4,pack:()=>[[-1,-1],[1,-1],[-1,1],[1,1]]}}}};let Zs=class extends Y{constructor(){super(...arguments),this.vertexSpec=Vs}_write(t,e){t.recordStart(this.instanceId,this.attributeLayout);const s=e.getDisplayId();if(e.geometryType==="esriGeometryPoint"){const r=e.readXForDisplay(),i=e.readYForDisplay();this._writeQuad(t,s,r,i)}else e.geometryType==="esriGeometryMultipoint"&&e.readGeometryForDisplay()?.forEachVertex((r,i)=>{r>=0&&r<=512&&i>=0&&i<=512&&this._writeQuad(t,s,r,i)});t.recordEnd()}_writeQuad(t,e,s,r){const i=t.vertexCount();this._writeVertex(t,e,s,r),t.indexWrite(i+0),t.indexWrite(i+1),t.indexWrite(i+2),t.indexWrite(i+1),t.indexWrite(i+3),t.indexWrite(i+2)}};class re{static getPlacement(e,s,r,i,n,o){const a=ye(r);return a?(s===-1&&e.invertY(),a.execute(e,r,i,n,o)):null}}const ie=96;class qs{constructor(e){const{offsetX:s,offsetY:r,postAngle:i,fontSize:n,haloSize:o,outlineSize:a,scaleFactor:c,transforms:u}=e;if(this.offsetX=s,this.offsetY=r,this.postAngle=i,this.fontSize=Math.min(n,ie),this.haloSize=o??0,this.outlineSize=a??0,this.transforms=u,u&&u.infos.length>1){const l=Ot(n,i,!1,s,r,u,!1);this.fontSize=Math.min(l.size,ie);const d=l.size/n;this.haloSize*=d,this.outlineSize*=d,this.postAngle=l.rotation,this.offsetX=l.offsetX,this.offsetY=l.offsetY}c&&(this.fontSize*=c,this.offsetX*=c,this.offsetY*=c)}}const ne=28,D=[4,4],ct=[16,4],Qs={topLeft:ct,topRight:ct,bottomLeft:ct,bottomRight:ct},ut=[4,2],v=[4,6],oe={topLeft:ut,topRight:ut,bottomLeft:v,bottomRight:v},ae={topLeft:ut,topRight:v,bottomLeft:ut,bottomRight:v},js={topLeft:v,topRight:v,bottomLeft:D,bottomRight:D},Js={topLeft:D,topRight:D,bottomLeft:v,bottomRight:v},Ks={topLeft:v,topRight:D,bottomLeft:v,bottomRight:D},$s={topLeft:D,topRight:v,bottomLeft:D,bottomRight:v},tr={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:h.UNSIGNED_SHORT,count:2,packPrecisionFactor:tt,packTessellation:({minZoom:t,maxZoom:e})=>[t||0,e||ne]},clipAngle:{type:h.UNSIGNED_BYTE,count:1,packTessellation:({clipAngle:t})=>sr(t||0)},referenceSymbol:{type:h.BYTE,count:4,packPrecisionFactor:1,packTessellation:(t,e)=>{const s=t.isLineLabel||!t.referenceBounds,r=ge(s?"center":e.horizontalAlignment),i=_e(s?"middle":e.verticalAlignment),{offsetX:n,offsetY:o,size:a}=s?{offsetX:0,offsetY:0,size:0}:t.referenceBounds;return[m(n),-m(o),Math.round(m(a)),r+1<<2|i+1]}}},attributes:{pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1,packTessellation:({isBackground:t,mapAligned:e})=>W([[Pe,t],[ve,!!e]])},offset:{type:h.SHORT,count:2,packPrecisionFactor:8,packAlternating:{count:4,packTessellation:({offsets:t})=>{const{bottomLeft:e,bottomRight:s,topLeft:r,topRight:i}=t;return[r,i,e,s]}}},textureUV:{type:h.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,packTessellation:({texcoords:t})=>{const{bottomLeft:e,bottomRight:s,topLeft:r,topRight:i}=t;return[r,i,e,s]}}},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,packTessellation:({color:t})=>t},fontSize:{type:h.UNSIGNED_SHORT,count:1,packPrecisionFactor:4,packTessellation:({fontSize:t})=>Math.round(m(t))},referenceSize:{type:h.UNSIGNED_BYTE,count:1,packPrecisionFactor:4,packTessellation:({fontSize:t},{referenceSize:e})=>Math.round(m(e??t))},outlineColor:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>_(t)},haloColor:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({haloColor:t})=>_(t)},outlineAndHaloSize:{type:h.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({outlineSize:t,haloSize:e})=>[Math.round(m(t)),Math.round(m(e))]}}};class er extends Y{constructor(){super(...arguments),this.vertexSpec=tr,this._textMeshParamsPropsInitialized=!1}ensurePacked(e,s,r){super.ensurePacked(e,s,r),this._textMeshParamsPropsInitialized&&!this._evaluator.hasDynamicProperties||(this._textMeshTransformProps=new qs(this.evaluatedMeshParams),this._textMeshParamsPropsInitialized=!0)}_write(e,s,r){const i=this._getShaping();if(!i)return;const n=s.getDisplayId();if(this.evaluatedMeshParams.placement!=null)return this._writePlacedTextMarkers(e,s,i,r);if(r?.nextPath())return r.nextPoint(),this._writeGlyphs(e,n,r.x,r.y,i,0);if(s.geometryType==="esriGeometryPolygon"){const c=s.readCentroidForDisplay();if(!c)return;const[u,l]=c.coords;return this._writeGlyphs(e,n,u,l,i,0)}if(s.geometryType==="esriGeometryMultipoint")return void s.readGeometryForDisplay()?.forEachVertex((c,u)=>this._writeGlyphs(e,n,c,u,i,0));const o=s.readXForDisplay(),a=s.readYForDisplay();return this._writeGlyphs(e,n,o,a,i,0)}_writePlacedTextMarkers(e,s,r,i){const n=i??T.fromFeatureSetReaderCIM(s);if(!n)return;const o=-1,a=re.getPlacement(n,o,this.evaluatedMeshParams.placement,m(1),e.id,_t());if(!a)return;const c=s.getDisplayId();let u=a.next();for(;u!=null;){const l=u.tx,d=-u.ty,x=-u.getAngle();this._writeGlyphs(e,c,l,d,r,x),u=a.next()}}_getShaping(e){const s=this._textMeshTransformProps,r=this.evaluatedMeshParams;if(!r.glyphs?.glyphs.length)return null;const i=m(s.fontSize),n=m(s.offsetX),o=m(s.offsetY),a=zt(m(r.lineWidth),ze,Ee),c=Ae*zt(r.lineHeightRatio,.25,4);return Se(r.glyphs,{scale:i/De,angle:s.postAngle,xOffset:n,yOffset:o,horizontalAlignment:r.horizontalAlignment,verticalAlignment:e||r.verticalAlignment,maxLineWidth:a,lineHeight:c,decoration:r.decoration,borderLineSizePx:m(r.boxBorderLineSize),hasBackground:!!r.boxBackgroundColor,useCIMAngleBehavior:r.useCIMAngleBehavior})}_writeGlyphs(e,s,r,i,n,o,a,c){const u=this.evaluatedMeshParams,l=this._textMeshTransformProps,d=m(l.fontSize),x=l.haloSize,p=l.outlineSize,f=m(l.offsetX),y=m(l.offsetY),[g,k]=U(u.scaleInfo,this.getTileInfo());o!==0&&n.setRotation(o);const b=n.bounds,I=r+b.x+f,M=i+b.y-y,F=2*(u.minPixelBuffer?u.minPixelBuffer/d:1),w=Math.max(b.width,b.height)*F;n.textBox&&(e.recordStart(this.instanceId,this.attributeLayout,n.glyphs[0].textureBinding),e.recordBounds(I,M,w,w),this._writeTextBox(e,s,r,i,n.textBox,a,c),e.recordEnd());for(const z of n.glyphs){e.recordStart(this.instanceId,this.attributeLayout,z.textureBinding),e.recordBounds(I,M,w,w);const{texcoords:G,offsets:R}=z;this._writeQuad(e,s,r,i,{texcoords:G,offsets:R,fontSize:d,haloSize:x,outlineSize:p,color:_(u.color),isBackground:!1,referenceBounds:a,minZoom:g,maxZoom:k,...c}),e.recordEnd()}o!==0&&n.setRotation(-o)}_writeTextBox(e,s,r,i,n,o,a){const c=this.evaluatedMeshParams,{fontSize:u,haloSize:l,outlineSize:d}=this._textMeshTransformProps,{boxBackgroundColor:x,boxBorderLineColor:p}=c,f={isBackground:!0,fontSize:u,haloSize:l,outlineSize:d,referenceBounds:o,...a};x&&(this._writeQuad(e,s,r,i,{texcoords:Qs,offsets:n.main,color:_(x),...f}),p||(this._writeQuad(e,s,r,i,{texcoords:js,offsets:n.top,color:_(x),...f}),this._writeQuad(e,s,r,i,{texcoords:Js,offsets:n.bot,color:_(x),...f}),this._writeQuad(e,s,r,i,{texcoords:Ks,offsets:n.left,color:_(x),...f}),this._writeQuad(e,s,r,i,{texcoords:$s,offsets:n.right,color:_(x),...f}))),p&&(this._writeQuad(e,s,r,i,{texcoords:oe,offsets:n.top,color:_(p),...f}),this._writeQuad(e,s,r,i,{texcoords:oe,offsets:n.bot,color:_(p),...f}),this._writeQuad(e,s,r,i,{texcoords:ae,offsets:n.left,color:_(p),...f}),this._writeQuad(e,s,r,i,{texcoords:ae,offsets:n.right,color:_(p),...f}))}_writeQuad(e,s,r,i,n){const o=e.vertexCount();this._writeVertex(e,s,r,i,n),e.indexWrite(o+0),e.indexWrite(o+1),e.indexWrite(o+2),e.indexWrite(o+1),e.indexWrite(o+3),e.indexWrite(o+2)}}const sr=t=>Math.round(t*(254/360)),rr={createComputedParams:t=>t,optionalAttributes:E.optionalAttributes,attributes:{...E.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:({gradientMethod:t,gradientSizeUnits:e,gradientType:s})=>W([[ht.isAlongLine,t.toLowerCase()==="alongline"],[ht.isAbsoluteSize,e===K.Absolute],[ht.isDiscrete,s.toLowerCase()==="discrete"]])},tlbr:{type:h.UNSIGNED_SHORT,count:4,pack:({sprite:t})=>{const{rect:e,width:s,height:r}=t,i=e.x+P+et,n=e.y+P;return[i,n,i+s-2*et,n+r]}},accumulatedDistance:{type:h.UNSIGNED_SHORT,count:1,packTessellation:({distance:t})=>t},gradientSize:{type:h.HALF_FLOAT,count:1,pack:({gradientSize:t,gradientSizeUnits:e})=>e===K.Relative?t/100:m(t)},totalLength:{type:h.HALF_FLOAT,count:1,packTessellation:({pathLength:t})=>t},segmentDirection:{type:h.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:t,directionY:e})=>[t,e]}}};let ir=class extends ot{get _preventEffectClipping(){return!0}constructor(t,e,s,r){super(t,e,s,r),this.vertexSpec=rr,this._tessellationOptions.textured=!0}_write(t,e,s){const r=s??T.fromFeatureSetReaderCIM(e);if(!r)return;const{sprite:i}=this.evaluatedMeshParams;this._writeGeometry(t,e,r,i?.textureBinding)}};const nr={createComputedParams:t=>t,optionalAttributes:E.optionalAttributes,attributes:{...E.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:({shouldSampleAlphaOnly:t,shouldScaleDash:e,isSDF:s})=>W([[Yt,t],[we,e],[Te,s]])},tlbr:{type:h.UNSIGNED_SHORT,count:4,pack:({sprite:t})=>{const{rect:e,width:s,height:r}=t,i=e.x+P,n=e.y+P;return[i,n,i+s,n+r]}},accumulatedDistance:{type:h.UNSIGNED_SHORT,count:1,packTessellation:({distance:t})=>t},segmentDirection:{type:h.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:t,directionY:e})=>[t,e]},offsetAlongLine:{type:h.HALF_FLOAT,count:1,pack:({offsetAlongLine:t})=>m(t)},capType:{type:h.UNSIGNED_BYTE,count:1,pack:({capType:t})=>{switch(t){case C.Butt:case"butt":return 0;case C.Square:case"square":return 1;case C.Round:case"round":return 2;default:return 0}}}}};class or extends ot{constructor(e,s,r,i){super(e,s,r,i),this.vertexSpec=nr,this._tessellationOptions.textured=!0}_write(e,s,r){const i=r??T.fromFeatureSetReaderCIM(s);if(!i)return;const{sprite:n}=this.evaluatedMeshParams;this._writeGeometry(e,s,i,n?.textureBinding)}}let ar=class Mt{static from(e){return"width"in e?this.fromSimpleMeshParams(e):this.fromComplexMeshParams(e)}static fromSimpleMeshParams(e){const s=new Mt(e.sprite,e.color,e.outlineColor,e.minPixelBuffer,e.placement,e.scaleInfo,e.effects),{type:r,width:i,height:n,angle:o,alignment:a,outlineSize:c,referenceSize:u,sprite:l,overrideOutlineColor:d}=e;return s.rawWidth=m(i),s.rawHeight=m(n),s.angle=o,s.alignment=a,s.outlineSize=m(c),s.referenceSize=m(u),s.overrideOutlineColor=d,s.offsetX=m(e.offsetX),s.offsetY=m(e.offsetY),r!=="simple"||l.sdf||(s.rawWidth=l.width,s.rawHeight=l.height),s._computeSize(e,!1),s}static fromComplexMeshParams(e){const s=new Mt(e.sprite,e.color,e.outlineColor,e.minPixelBuffer,e.placement,e.scaleInfo,e.effects);let{alignment:r,transforms:i,size:n,scaleX:o,anchorX:a,anchorY:c,angle:u,colorLocked:l,frameHeight:d,widthRatio:x,offsetX:p,offsetY:f,outlineSize:y,referenceSize:g,scaleFactor:k,sizeRatio:b,isAbsoluteAnchorPoint:I,rotateClockwise:M,scaleSymbolsProportionally:F,sprite:w}=e;if(i&&i.infos.length>0){const R=Ot(n,u,M,p,f,i);n=R.size,u=R.rotation,p=R.offsetX,f=R.offsetY,M=!1}k&&(n*=k,p*=k,f*=k);const z=o*(w.width/w.height);s.alignment=r,s.rawHeight=m(n),s.rawWidth=s.rawHeight*z,s.referenceSize=m(g),s.sizeRatio=b,s.sdfDecodeCoeff=(w.sdfDecodeCoeff??1)*b,s.angle=u,s.rotateClockwise=M,s.anchorX=a,s.anchorY=c,s.offsetX=m(p),s.offsetY=m(f),I&&n&&(w.sdf?s.anchorX=a/(n*x):s.anchorX=a/(n*z),s.anchorY=c/n);const G=F&&d?n/d:1;return s.outlineSize=y===0||isNaN(y)?0:m(y)*G,s.scaleSymbolsProportionally=F,s.colorLocked=l,s._computeSize(e,!0),s}constructor(e,s,r,i,n,o,a){this.sprite=e,this.color=s,this.outlineColor=r,this.minPixelBuffer=i,this.placement=n,this.scaleInfo=o,this.effects=a,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.sdfDecodeCoeff=1,this.alignment=Rt.SCREEN,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize(e,s){const{sprite:r,hasSizeVV:i}=e,n=!!r.sdf,o=r.sdfPaddingRatio??.5,{rawWidth:a,rawHeight:c,sizeRatio:u,outlineSize:l}=this,d=r.rect;let x=a*u,p=c*u,f=0,y=0;if(n){const M=1/(1-o);if(x*=M,p*=M,i)this.computedWidth=x,this.computedHeight=p;else{const F=s&&a>c?x:a,w=c,z=l+2*1;this.computedWidth=Math.min(F+z,x),this.computedHeight=Math.min(w+z,p);const G=Math.max(r.width,r.height)/Math.max(x,p);f=(this.computedWidth-x)*G,y=(this.computedHeight-p)*G}}else this.computedWidth=x*(d.width/r.width),this.computedHeight=p*(d.height/r.height),f=2*P,y=2*P;const g=d.x+P-f/2,k=d.y+P-y/2,b=g+r.width+f,I=k+r.height+y;this.texXmin=ce(g),this.texYmin=ce(k),this.texXmax=ue(b),this.texYmax=ue(I),this.computedWidth*=(this.texXmax-this.texXmin)/(b-g),this.computedHeight*=(this.texYmax-this.texYmin)/(I-k),this.anchorX*=x/this.computedWidth,this.anchorY*=p/this.computedHeight}};function ce(t,e=1e-7){const s=Math.ceil(t);return s-t<e?s:Math.floor(t)}function ue(t,e=1e-7){const s=Math.floor(t);return t-s<e?s:Math.ceil(t)}const cr=3.14159265359/180,ur=128/Math.PI;function lr(t,e){return t%=e,Math.abs(t>=0?t:t+e)}function hr(t){return lr(t*ur,256)}function pr(t,e,s,r,i=!1){const n=Ce(),o=i?1:-1;return Fe(n),(e||s)&&Ge(n,n,[e,-s]),r&&Re(n,n,o*cr*-r),n}const dr={createComputedParams:t=>ar.from(t),optionalAttributes:{zoomRange:{type:h.SHORT,count:2,packPrecisionFactor:tt,pack:({scaleInfo:t},{tileInfo:e})=>U(t,e)}},attributes:{pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1,pack:({sprite:t,alignment:e,scaleSymbolsProportionally:s,overrideOutlineColor:r,colorLocked:i})=>{let n=0;return t.sdf&&(n|=A(X.bitset.isSDF)),e===Rt.MAP&&(n|=A(X.bitset.isMapAligned)),s&&(n|=A(X.bitset.scaleSymbolsProportionally)),r&&(n|=A(X.bitset.overrideOutlineColor)),i&&(n|=A(X.bitset.colorLocked)),n}},offset:{type:h.HALF_FLOAT,count:2,packAlternating:{count:4,pack:({angle:t,computedWidth:e,computedHeight:s,anchorX:r,anchorY:i,offsetX:n,offsetY:o,rotateClockwise:a})=>{const c=pr(0,n,o,-t,a),u=-(.5+r)*e,l=-(.5-i)*s,d=[u,l],x=[u+e,l],p=[u,l+s],f=[u+e,l+s];return st(d,d,c),st(x,x,c),st(p,p,c),st(f,f,c),[d,x,p,f]}}},textureUV:{type:h.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({texXmax:t,texXmin:e,texYmax:s,texYmin:r})=>[[e,r],[t,r],[e,s],[t,s]]}},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>_(t)},outlineColor:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>_(t)},sizing:{type:h.UNSIGNED_BYTE,count:4,pack:({rawWidth:t,rawHeight:e,outlineSize:s,referenceSize:r})=>{const i=Math.max(t,e);return[kt(i,128),kt(s,128),kt(r,128),0]}},placementAngle:{type:h.UNSIGNED_BYTE,count:1,packTessellation:({placementAngle:t})=>hr(t)},sdfDecodeCoeff:{type:h.UNSIGNED_SHORT,count:1,packPrecisionFactor:64,pack:({sdfDecodeCoeff:t})=>t}}};class fr extends Y{constructor(){super(...arguments),this.vertexSpec=dr}getBoundsInfo(){return this.evaluatedMeshParams.boundsInfo}_write(e,s,r){const i=this.evaluatedMeshParams.sprite?.textureBinding,n=s.getDisplayId();e.recordStart(this.instanceId,this.attributeLayout,i);const o=this.evaluatedMeshParams.minPixelBuffer,a=Math.max(this.evaluatedMeshParams.computedWidth,o),c=Math.max(this.evaluatedMeshParams.computedHeight,o),u=-this.evaluatedMeshParams.anchorX*this.evaluatedMeshParams.computedWidth,l=this.evaluatedMeshParams.anchorY*this.evaluatedMeshParams.computedHeight,d=this.evaluatedMeshParams.offsetX+u,x=-this.evaluatedMeshParams.offsetY+l;if(this.evaluatedMeshParams.placement!=null)this._writePlacedMarkers(e,s,r,a,c);else if(r?.nextPath()){r.nextPoint();const p=r.x,f=r.y;e.recordBounds(p+d,f+x,a,c),this._writeQuad(e,n,p,f)}else if(s.geometryType==="esriGeometryPolygon"){const p=s.readCentroidForDisplay();if(!p)return;const[f,y]=p.coords;e.recordBounds(f+d,y+x,a,c),this._writeQuad(e,n,f,y)}else if(s.geometryType==="esriGeometryPoint"){const p=s.readXForDisplay(),f=s.readYForDisplay();e.recordBounds(p+d,f+x,a,c),this._writeQuad(e,n,p,f)}else s.readGeometryForDisplay()?.forEachVertex((p,f)=>{e.recordBounds(p+d,f+x,a,c),Math.abs(p)>rt||Math.abs(f)>rt||this._writeQuad(e,n,p,f)});e.recordEnd()}_writePlacedMarkers(e,s,r,i,n){const o=r??T.fromFeatureSetReaderCIM(s)?.clone();if(!o)return;const a=-1,c=re.getPlacement(o,a,this.evaluatedMeshParams.placement,m(1),e.id,_t());if(!c)return;const u=s.getDisplayId();let l=c.next();const d=this.evaluatedMeshParams.offsetX,x=-this.evaluatedMeshParams.offsetY;for(;l!=null;){const p=l.tx,f=-l.ty;if(Math.abs(p)>rt||Math.abs(f)>rt){l=c.next();continue}const y=-l.getAngle();e.recordBounds(p+d,f+x,i,n),this._writeQuad(e,u,p,f,y),l=c.next()}}_writeQuad(e,s,r,i,n){const o=e.vertexCount(),a=n==null?null:{placementAngle:n};this._writeVertex(e,s,r,i,a),e.indexWrite(o+0),e.indexWrite(o+1),e.indexWrite(o+2),e.indexWrite(o+1),e.indexWrite(o+3),e.indexWrite(o+2)}}const xr={createComputedParams:t=>t,optionalAttributes:{},attributes:{pos:{type:h.SHORT,count:2,packPrecisionFactor:10,pack:"position"},id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1,pack:t=>0},offset:{type:h.SHORT,count:2,packPrecisionFactor:16,packAlternating:{count:4,pack:({size:t})=>{const e=m(t),s=-e/2,r=-e/2;return[[s,r],[s+e,r],[s,r+e],[s+e,r+e]]}}},texCoords:{type:h.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:()=>[[0,1],[1,1],[0,0],[1,0]]}},size:{type:h.UNSIGNED_BYTE,count:2,pack:({size:t})=>[t,t]},referenceSize:{type:h.UNSIGNED_BYTE,count:1,pack:({size:t})=>m(t)},zoomRange:{type:h.UNSIGNED_BYTE,count:2,pack:({scaleInfo:t},{tileInfo:e})=>U(t,e)}}};class mr extends Y{constructor(){super(...arguments),this.vertexSpec=xr}_write(e,s){const r=s.getDisplayId(),i=this.evaluatedMeshParams.minPixelBuffer,n=Math.max(m(this.evaluatedMeshParams.size),i);let o,a;if(s.geometryType==="esriGeometryPoint")o=s.readXForDisplay(),a=s.readYForDisplay();else{const u=s.readCentroidForDisplay();if(!u)return;o=u?.coords[0],a=u?.coords[1]}e.recordStart(this.instanceId,this.attributeLayout),e.recordBounds(o,a,n,n);const c=e.vertexCount();this._writeVertex(e,r,o,a),e.indexWrite(c+0),e.indexWrite(c+1),e.indexWrite(c+2),e.indexWrite(c+1),e.indexWrite(c+3),e.indexWrite(c+2),e.recordEnd()}}export{fr as I,er as N,ne as P,ot as T,or as a,Xs as b,Y as c,Ts as d,Ss as e,A as f,_ as g,wt as h,Zs as i,bt as j,Qt as k,ir as l,U as m,Kt as o,mr as s,Os as u,Ns as x};
