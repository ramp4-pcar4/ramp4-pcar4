import{C as ft,E as wt,g as pt,p as dt,B as ht,f as gt,o as _,y as yt,e as Z,s as mt,a as T,_ as y,I as G,v as w,G as v,Y as m,L as E,b as bt,c as S,d as f,H as z,h as R,n as h,W as D,i as L,j as C,k as vt,m as q,l as St,A as xt,D as H,q as It,r as P,t as Ft,u as Y,w as Q,U as J,x as X}from"./arcade-Dg73dEoh.js";import{a as i,r as l,u as $}from"./unitConversion-BXECx7w3.js";import{registerFunctions as kt}from"./geomasync-Bqcib6TP.js";import{d9 as k,Q as tt,da as p,db as O,dc as A,dd as et,de as Mt}from"./main-DnzmeE4U.js";async function V(e,t){const a=[];for(let o=0;o<t.arguments.length;o++)a.push(await u(e,t.arguments[o]));return a}async function I(e,t,a){return t.preparsed===!0?a(e,null,t.arguments):a(e,t,await V(e,t))}class Rt extends Ft{constructor(t,a){super(),this.definition=null,this.context=null,this.definition=t,this.context=a}createFunction(t){return(...a)=>{const o={spatialReference:this.context.spatialReference,console:this.context.console,lrucache:this.context.lrucache,timeZone:this.context.timeZone??null,exports:this.context.exports,libraryResolver:this.context.libraryResolver,interceptor:this.context.interceptor,localScope:{},depthCounter:{depth:t.depthCounter+1},globalScope:this.context.globalScope};if(o.depthCounter.depth>64)throw new i(t,l.MaximumCallDepth,null);return W(this.definition,o,a,null)}}call(t,a){return N(t,a,(o,r,n)=>{const s={spatialReference:t.spatialReference,services:t.services,console:t.console,libraryResolver:t.libraryResolver,exports:t.exports,lrucache:t.lrucache,timeZone:t.timeZone??null,interceptor:t.interceptor,localScope:{},abortSignal:t.abortSignal,globalScope:t.globalScope,depthCounter:{depth:t.depthCounter.depth+1}};if(s.depthCounter.depth>64)throw new i(t,l.MaximumCallDepth,a);return W(this.definition,s,n,a)})}marshalledCall(t,a,o,r){return r(t,a,async(n,s,c)=>{const x={spatialReference:t.spatialReference,globalScope:o.globalScope,depthCounter:{depth:t.depthCounter.depth+1},libraryResolver:t.libraryResolver,exports:t.exports,console:t.console,abortSignal:t.abortSignal,lrucache:t.lrucache,timeZone:t.timeZone??null,interceptor:t.interceptor,localScope:{}};return c=c.map(b=>!v(b)||b instanceof P?b:Y(b,t,r)),Y(await W(this.definition,x,c,a),o,r)})}}class M extends It{constructor(t){super(),this.source=t}global(t){const a=this.executingContext.globalScope[h(t)];if(v(a.value)&&!(a.value instanceof P)){const o=new P;o.fn=a.value,o.parameterEvaluator=N,o.context=this.executingContext,a.value=o}return a.value}setGlobal(t,a){if(v(a))throw new i(null,l.AssignModuleFunction,null);this.executingContext.globalScope[h(t)]={value:a}}hasGlobal(t){return this.executingContext.exports[t]===void 0&&(t=h(t)),this.executingContext.exports[t]!==void 0}async loadModule(t){let a=t.spatialReference;a==null&&(a=new tt({wkid:102100})),this.moduleScope=st({},t.customfunctions,t.timeZone),this.executingContext={spatialReference:a,services:t.services,libraryResolver:new T(t.libraryResolver._moduleSingletons,this.source.syntax.loadedModules),exports:{},abortSignal:t.abortSignal===void 0||t.abortSignal===null?{aborted:!1}:t.abortSignal,globalScope:this.moduleScope,console:t.console??ct,lrucache:t.lrucache,timeZone:t.timeZone??null,interceptor:t.interceptor,localScope:null,depthCounter:{depth:1}},await j(this.executingContext,this.source.syntax)}}async function N(e,t,a){return t.preparsed===!0?a(e,null,t.arguments):a(e,t,await V(e,t))}async function u(e,t){t.breakpoint&&await t.breakpoint();try{switch(t.type){case"UpdateExpression":return await Kt(e,t);case"AssignmentExpression":return await Ut(e,t);case"TemplateLiteral":return await Qt(e,t);case"Identifier":return U(e,t);case"MemberExpression":return await Wt(e,t);case"Literal":return t.value;case"CallExpression":return await Yt(e,t);case"UnaryExpression":return await _t(e,t);case"BinaryExpression":return await zt(e,t);case"LogicalExpression":return await Ht(e,t);case"ArrayExpression":return await Tt(e,t);case"ObjectExpression":return await Ct(e,t);default:throw new i(e,l.Unrecognized,t)}}catch(a){throw $(e,t,a)}}async function g(e,t){t.breakpoint&&await t.breakpoint();try{switch(t.type){case"ImportDeclaration":return await Pt(e,t);case"ExportNamedDeclaration":return await Vt(e,t);case"VariableDeclaration":return await nt(e,t,0);case"BlockStatement":return await j(e,t);case"FunctionDeclaration":return await qt(e,t);case"ReturnStatement":return await Lt(e,t);case"IfStatement":return await Gt(e,t);case"ExpressionStatement":return await Zt(e,t);case"ForStatement":return await At(e,t);case"WhileStatement":return await Ot(e,t);case"ForInStatement":return await Et(e,t);case"ForOfStatement":return await Dt(e,t);case"BreakStatement":return m;case"EmptyStatement":return w;case"ContinueStatement":return E;default:throw new i(e,l.Unrecognized,t)}}catch(a){throw $(e,t,a)}}async function Ct(e,t){const a=[];for(let s=0;s<t.properties.length;s++){const c=t.properties[s],x=await u(e,c.value),b=c.key.type==="Identifier"?c.key.name:await u(e,c.key);a[s]={key:b,value:x}}const o={},r=new Map;for(let s=0;s<a.length;s++){const c=a[s];if(v(c.value))throw new i(e,l.NoFunctionInDictionary,t);if(p(c.key)===!1)throw new i(e,l.KeyMustBeString,t);let x=c.key.toString();const b=x.toLowerCase();r.has(b)?x=r.get(b):r.set(b,x),c.value===w?o[x]=null:o[x]=c.value}const n=new S(o);return n.immutable=!1,n}async function Ot(e,t){let a=await u(e,t.test);if(a===!1)return w;if(a!==!0)throw new i(e,l.BooleanConditionRequired,t);for(;a===!0;){const o=await g(e,t.body);if(o===m)break;if(o instanceof y)return o;if(a=await u(e,t.test),a!==!0&&a!==!1)throw new i(e,l.BooleanConditionRequired,t)}return w}async function At(e,t){try{for(t.init!==null&&(t.init.type==="VariableDeclaration"?await g(e,t.init):await u(e,t.init));;){if(t.test!==null){const o=await u(e,t.test);if(e.abortSignal?.aborted===!0)throw new i(e,l.Cancelled,t);if(o===!1)break;if(o!==!0)throw new i(e,l.BooleanConditionRequired,t)}const a=await g(e,t.body);if(a===m)break;if(a instanceof y)return a;t.update!==null&&await u(e,t.update)}return w}catch(a){throw a}}async function K(e,t,a,o,r="i"){const n=a.length;for(let s=0;s<n;s++){if(r==="k"){if(s>=a.length)throw new i(e,l.OutOfBounds,t);o.value=a[s]}else o.value=s;const c=await g(e,t.body);if(c===m)break;if(c instanceof y)return c}return w}async function at(e,t,a,o,r="i"){const n=a.length();for(let s=0;s<n;s++){o.value=r==="k"?a.get(s):s;const c=await g(e,t.body);if(c===m)break;if(c instanceof y)return c}return w}async function ot(e,t,a,o){const r=a.iterator(e.abortSignal);let n;for(;(n=await r.next())!=null;){const s=H.createFromGraphicLikeObject(n.geometry,n.attributes,a,e.timeZone);s._underlyingGraphic=n,o.value=s;const c=await g(e,t.body);if(c===m)break;if(c instanceof y)return c}return w}async function Nt(e,t,a,o){for(const r of a.keys()){const n=a.field(r);o.value=new S({key:r,value:n});const s=await g(e,t.body);if(s===m)break;if(s instanceof y)return s}return w}async function Bt(e,t,a,o){for(const r of X(a)){const n=L(a,r,e,t,1);o.value=new S({key:r,value:n});const s=await g(e,t.body);if(s===m)break;if(s instanceof y)return s}return w}async function Et(e,t){const a=await u(e,t.right);t.left.type==="VariableDeclaration"&&await g(e,t.left);const o=h(t.left.type==="VariableDeclaration"?t.left.declarations[0].id:t.left);let r=null;if(e.localScope!=null&&e.localScope[o]!==void 0&&(r=e.localScope[o]),r===null&&e.globalScope[o]!==void 0&&(r=e.globalScope[o]),r===null)throw new i(e,l.InvalidIdentifier,t);return O(a)||p(a)?await K(e,t,a,r):R(a)?await at(e,t,a,r):a instanceof S||D(a)?await K(e,t,a.keys(),r,"k"):Q(a)?await ot(e,t,a,r):J(a)?await K(e,t,X(a),r,"k"):w}async function Dt(e,t){const a=await u(e,t.right);t.left.type==="VariableDeclaration"&&await g(e,t.left);const o=h(t.left.type==="VariableDeclaration"?t.left.declarations[0].id:t.left);let r=null;if(e.localScope!=null&&e.localScope[o]!==void 0&&(r=e.localScope[o]),r===null&&e.globalScope[o]!==void 0&&(r=e.globalScope[o]),r===null)throw new i(e,l.InvalidIdentifier,t);return O(a)||p(a)?await K(e,t,a,r,"k"):R(a)?await at(e,t,a,r,"k"):a instanceof S||D(a)?await Nt(e,t,a,r):Q(a)?await ot(e,t,a,r):J(a)?await Bt(e,t,a,r):w}async function Kt(e,t){const a=t.argument;if(a.type==="CallExpression")throw new i(e,l.NeverReach,t);if(a.type==="MemberExpression"){const n=await u(e,a.object);let s,c;if(a.computed===!0)s=await u(e,a.property);else{if(a.property.type!=="Identifier")throw new i(e,l.Unrecognized,t);s=a.property.name}if(O(n)){if(!A(s))throw new i(e,l.ArrayAccessorMustBeNumber,t);if(s<0&&(s=n.length+s),s<0||s>=n.length)throw new i(e,l.OutOfBounds,t);c=f(n[s]),n[s]=t.operator==="++"?c+1:c-1}else if(n instanceof S){if(p(s)===!1)throw new i(e,l.KeyAccessorMustBeString,t);if(n.hasField(s)!==!0)throw new i(e,l.FieldNotFound,t,{key:s});c=f(n.field(s)),n.setField(s,t.operator==="++"?c+1:c-1)}else if(n instanceof M){if(p(s)===!1)throw new i(e,l.ModuleAccessorMustBeString,t);if(n.hasGlobal(s)!==!0)throw new i(e,l.ModuleExportNotFound,t);c=f(n.global(s)),n.setGlobal(s,t.operator==="++"?c+1:c-1)}else{if(!z(n))throw R(n)?new i(e,l.Immutable,t):new i(e,l.InvalidParameter,t);if(p(s)===!1)throw new i(e,l.KeyAccessorMustBeString,t);if(n.hasField(s)!==!0)throw new i(e,l.FieldNotFound,t,{key:s});c=f(n.field(s)),n.setField(s,t.operator==="++"?c+1:c-1)}return t.prefix===!1?c:t.operator==="++"?c+1:c-1}const o=h(a);let r;if(e.localScope!=null&&e.localScope[o]!==void 0)return r=f(e.localScope[o].value),e.localScope[o]={value:t.operator==="++"?r+1:r-1},t.prefix===!1?r:t.operator==="++"?r+1:r-1;if(e.globalScope[o]!==void 0)return r=f(e.globalScope[o].value),e.globalScope[o]={value:t.operator==="++"?r+1:r-1},t.prefix===!1?r:t.operator==="++"?r+1:r-1;throw new i(e,l.InvalidIdentifier,t)}function F(e,t,a,o,r){switch(t){case"=":return e===w?null:e;case"/=":return f(a)/f(e);case"*=":return f(a)*f(e);case"-=":return f(a)-f(e);case"+=":return p(a)||p(e)?C(a)+C(e):f(a)+f(e);case"%=":return f(a)%f(e);default:throw new i(r,l.UnsupportedOperator,o)}}async function Ut(e,t){const a=t.left;if(a.type==="MemberExpression"){const r=await u(e,a.object);let n;if(a.computed===!0)n=await u(e,a.property);else{if(a.property.type!=="Identifier")throw new i(e,l.InvalidIdentifier,t);n=a.property.name}const s=await u(e,t.right);if(O(r)){if(!A(n))throw new i(e,l.ArrayAccessorMustBeNumber,t);if(n<0&&(n=r.length+n),n<0||n>r.length)throw new i(e,l.OutOfBounds,t);if(n===r.length){if(t.operator!=="=")throw new i(e,l.OutOfBounds,t);r[n]=F(s,t.operator,r[n],t,e)}else r[n]=F(s,t.operator,r[n],t,e)}else if(r instanceof S){if(p(n)===!1)throw new i(e,l.KeyAccessorMustBeString,t);if(r.hasField(n)===!0)r.setField(n,F(s,t.operator,r.field(n),t,e));else{if(t.operator!=="=")throw new i(e,l.FieldNotFound,t,{key:n});r.setField(n,F(s,t.operator,null,t,e))}}else if(r instanceof M){if(p(n)===!1)throw new i(e,l.KeyAccessorMustBeString,t);if(r.hasGlobal(n)!==!0)throw new i(e,l.ModuleExportNotFound,t);r.setGlobal(n,F(s,t.operator,r.global(n),t,e))}else{if(!z(r))throw R(r)?new i(e,l.Immutable,t):new i(e,l.InvalidParameter,t);if(p(n)===!1)throw new i(e,l.KeyAccessorMustBeString,t);if(r.hasField(n)===!0)r.setField(n,F(s,t.operator,r.field(n),t,e));else{if(t.operator!=="=")throw new i(e,l.FieldNotFound,t,{key:n});r.setField(n,F(s,t.operator,null,t,e))}}return w}const o=h(a);if(e.localScope!=null&&e.localScope[o]!==void 0){const r=await u(e,t.right);return e.localScope[o]={value:F(r,t.operator,e.localScope[o].value,t,e)},w}if(e.globalScope[o]!==void 0){const r=await u(e,t.right);return e.globalScope[o]={value:F(r,t.operator,e.globalScope[o].value,t,e)},w}throw new i(e,l.InvalidIdentifier,t)}async function Zt(e,t){const a=await u(e,t.expression);return a===w?w:new G(a)}async function Gt(e,t){const a=await u(e,t.test);if(a===!0)return g(e,t.consequent);if(a===!1)return t.alternate!==null?g(e,t.alternate):w;throw new i(e,l.BooleanConditionRequired,t)}async function j(e,t){return rt(e,t,0)}async function rt(e,t,a){if(a>=t.body.length)return w;const o=await g(e,t.body[a]);return o instanceof y||o===m||o===E||a===t.body.length-1?o:rt(e,t,a+1)}async function Lt(e,t){if(t.argument===null)return new y(w);const a=await u(e,t.argument);return new y(a)}async function qt(e,t){const a=h(t.id);return e.globalScope[a]={value:new Rt(t,e)},w}async function Pt(e,t){const a=h(t.specifiers[0].local),o=e.libraryResolver.loadLibrary(a);let r;return e.libraryResolver._moduleSingletons?.has(o.uri)?r=e.libraryResolver._moduleSingletons.get(o.uri):(r=new M(o),await r.loadModule(e),e.libraryResolver._moduleSingletons?.set(o.uri,r)),e.globalScope[a]={value:r},w}async function Vt(e,t){if(await g(e,t.declaration),t.declaration.type==="FunctionDeclaration")e.exports[h(t.declaration.id)]="function";else if(t.declaration.type==="VariableDeclaration")for(const a of t.declaration.declarations)e.exports[h(a.id)]="variable";return w}async function nt(e,t,a){return a>=t.declarations.length?w:(await jt(e,t.declarations[a]),a===t.declarations.length-1||await nt(e,t,a+1),w)}async function jt(e,t){let a=null;if(a=t.init===null?null:await u(e,t.init),e.localScope!==null){if(a===w&&(a=null),t.id.type!=="Identifier")throw new i(e,l.InvalidIdentifier,t);const r=h(t.id);return void(e.localScope!=null&&(e.localScope[r]={value:a}))}if(t.id.type!=="Identifier")throw new i(e,l.InvalidIdentifier,t);const o=h(t.id);a===w&&(a=null),e.globalScope[o]={value:a}}async function Wt(e,t){const a=await u(e,t.object);if(a===null)throw new i(e,l.MemberOfNull,t);if(t.computed===!1){if(t.property.type==="Identifier"){if(a instanceof S||D(a))return a.field(t.property.name);if(a instanceof et)return L(a,t.property.name,e,t);if(a instanceof M){if(!a.hasGlobal(t.property.name))throw new i(e,l.InvalidIdentifier,t);return a.global(t.property.name)}throw new i(e,l.InvalidMemberAccessKey,t)}throw new i(e,l.InvalidMemberAccessKey,t)}let o=await u(e,t.property);if(a instanceof S||D(a)){if(p(o))return a.field(o);throw new i(e,l.InvalidMemberAccessKey,t)}if(a instanceof M){if(p(o))return a.global(o);throw new i(e,l.InvalidMemberAccessKey,t)}if(a instanceof et){if(p(o))return L(a,o,e,t);throw new i(e,l.InvalidMemberAccessKey,t)}if(O(a)){if(A(o)&&isFinite(o)&&Math.floor(o)===o){if(o<0&&(o=a.length+o),o>=a.length||o<0)throw new i(e,l.OutOfBounds,t);return a[o]}throw new i(e,l.InvalidMemberAccessKey,t)}if(R(a)){if(A(o)&&isFinite(o)&&Math.floor(o)===o){if(o<0&&(o=a.length()+o),o>=a.length()||o<0)throw new i(e,l.OutOfBounds,t);return a.get(o)}throw new i(e,l.InvalidMemberAccessKey,t)}if(p(a)){if(A(o)&&isFinite(o)&&Math.floor(o)===o){if(o<0&&(o=a.length+o),o>=a.length||o<0)throw new i(e,l.OutOfBounds,t);return a[o]}throw new i(e,l.InvalidMemberAccessKey,t)}throw new i(e,l.InvalidMemberAccessKey,t)}async function _t(e,t){const a=await u(e,t.argument);if(k(a)){if(t.operator==="!")return!a;if(t.operator==="-")return-1*f(a);if(t.operator==="+")return 1*f(a);if(t.operator==="~")return~f(a);throw new i(e,l.UnsupportedUnaryOperator,t)}if(t.operator==="-")return-1*f(a);if(t.operator==="+")return 1*f(a);if(t.operator==="~")return~f(a);throw new i(e,l.UnsupportedUnaryOperator,t)}async function Tt(e,t){const a=[];for(let o=0;o<t.elements.length;o++)a.push(await u(e,t.elements[o]));for(let o=0;o<a.length;o++){if(v(a[o]))throw new i(e,l.NoFunctionInArray,t);a[o]===w&&(a[o]=null)}return a}async function zt(e,t){const a=await u(e,t.left),o=await u(e,t.right);switch(t.operator){case"|":case"<<":case">>":case">>>":case"^":case"&":return St(f(a),f(o),t.operator);case"==":return q(a,o);case"!=":return!q(a,o);case"<":case">":case"<=":case">=":return vt(a,o,t.operator);case"+":return p(a)||p(o)?C(a)+C(o):f(a)+f(o);case"-":return f(a)-f(o);case"*":return f(a)*f(o);case"/":return f(a)/f(o);case"%":return f(a)%f(o);default:throw new i(e,l.UnsupportedOperator,t)}}async function Ht(e,t){const a=await u(e,t.left);if(!k(a))throw new i(e,l.LogicalExpressionOnlyBoolean,t);switch(t.operator){case"||":{if(a===!0)return a;const o=await u(e,t.right);if(k(o))return o;throw new i(e,l.LogicExpressionOrAnd,t)}case"&&":{if(a===!1)return a;const o=await u(e,t.right);if(k(o))return o;throw new i(e,l.LogicExpressionOrAnd,t)}default:throw new i(e,l.LogicExpressionOrAnd,t)}}function U(e,t){const a=h(t);if(e.localScope!=null&&e.localScope[a]!==void 0)return e.localScope[a].value;if(e.globalScope[a]!==void 0)return e.globalScope[a].value;throw new i(e,l.InvalidIdentifier,t)}async function Yt(e,t){if(t.callee.type==="MemberExpression"){const o=await u(e,t.callee.object);if(!(o instanceof M))throw new i(e,l.FunctionNotFound,t);const r=t.callee.computed===!1?t.callee.property.name:await u(e,t.callee.property);if(!o.hasGlobal(r))throw new i(e,l.FunctionNotFound,t);const n=o.global(r);if(!v(n))throw new i(e,l.CallNonFunction,t);return n.call(e,t)}if(t.callee.type!=="Identifier")throw new i(e,l.FunctionNotFound,t);const a=h(t.callee);if(e.localScope!=null&&e.localScope[a]!==void 0){const o=e.localScope[a];if(v(o.value))return o.value.call(e,t);throw new i(e,l.CallNonFunction,t)}if(e.globalScope[a]!==void 0){const o=e.globalScope[a];if(v(o.value))return o.value.call(e,t);throw new i(e,l.CallNonFunction,t)}throw new i(e,l.FunctionNotFound,t)}async function Qt(e,t){let a="",o=0;for(const r of t.quasis)if(a+=r.value?r.value.cooked:"",r.tail===!1){if(t.expressions[o]){const n=await u(e,t.expressions[o]);if(v(n))throw new i(e,l.NoFunctionInTemplateLiteral,t);a+=C(n)}o++}return a}const d={};async function it(e,t,a,o){const r=await u(e,t.arguments[a]);if(q(r,o))return u(e,t.arguments[a+1]);const n=t.arguments.length-a;return n===1?u(e,t.arguments[a]):n===2?null:n===3?u(e,t.arguments[a+2]):it(e,t,a+2,o)}async function lt(e,t,a,o){if(o===!0)return u(e,t.arguments[a+1]);if(t.arguments.length-a===3)return u(e,t.arguments[a+2]);const r=await u(e,t.arguments[a+2]);if(k(r)===!1)throw new i(e,l.ModuleExportNotFound,t.arguments[a+2]);return lt(e,t,a+2,r)}async function W(e,t,a,o){const r=e.body;if(a.length!==e.params.length)throw new i(t,l.WrongNumberOfParameters,null);for(let s=0;s<a.length;s++){const c=e.params[s];c.type==="Identifier"&&t.localScope!=null&&(t.localScope[h(c)]={value:a[s]})}const n=await g(t,r);if(n instanceof y)return n.value;if(n===m)throw new i(t,l.UnexpectedToken,o);if(n===E)throw new i(t,l.UnexpectedToken,o);return n instanceof G?n.value:n}ft(d,I),wt(d,I),pt(d,I,U),dt(d,I),ht(d,I),gt(d,I),kt({functions:d,compiled:!1,signatures:null,evaluateIdentifier:null,mode:"async",standardFunction:I,standardFunctionAsync:N}),d.iif=async function(e,t){_(t.arguments===null?[]:t.arguments,3,3,e,t);const a=await u(e,t.arguments[0]);if(k(a)===!1)throw new i(e,l.BooleanConditionRequired,t);return u(e,a?t.arguments[1]:t.arguments[2])},d.defaultvalue=async function(e,t){_(t.arguments===null?[]:t.arguments,2,3,e,t);const a=await u(e,t.arguments[0]);if(t.arguments.length===3){const o=await u(e,t.arguments[1]),r=yt(a,o);return r!=null&&r!==""?r:u(e,t.arguments[2])}return a==null||a===""?u(e,t.arguments[1]):a},d.decode=async function(e,t){if(t.arguments.length<2)throw new i(e,l.WrongNumberOfParameters,t);if(t.arguments.length===2)return u(e,t.arguments[1]);if((t.arguments.length-1)%2==0)throw new i(e,l.WrongNumberOfParameters,t);return it(e,t,1,await u(e,t.arguments[0]))},d.when=async function(e,t){if(t.arguments.length<3)throw new i(e,l.WrongNumberOfParameters,t);if(t.arguments.length%2==0)throw new i(e,l.WrongNumberOfParameters,t);const a=await u(e,t.arguments[0]);if(k(a)===!1)throw new i(e,l.BooleanConditionRequired,t.arguments[0]);return lt(e,t,0,a)};const Jt={fixSpatialReference:xt,parseArguments:V,standardFunction:I,standardFunctionAsync:N,evaluateIdentifier:U};for(const e in d)d[e]={value:new Z(d[e])};const B=function(){};function st(e,t,a){const o=new B;e==null&&(e={}),t==null&&(t={});const r=new S({newline:`
`,tab:"	",singlequote:"'",doublequote:'"',forwardslash:"/",backwardslash:"\\"});r.immutable=!1,o.textformatting={value:r};for(const n in t)o[n]={value:new Z(t[n])};for(const n in e)o[n]={value:Mt(e[n])?H.createFromGraphic(e[n],a):e[n]};return o}function ct(e){console.log(e)}B.prototype=d,B.prototype.infinity={value:Number.POSITIVE_INFINITY},B.prototype.pi={value:Math.PI};const Xt=Jt;function ut(e){const t={mode:"async",compiled:!1,functions:{},signatures:[],standardFunction:I,standardFunctionAsync:N,evaluateIdentifier:U};for(let a=0;a<e.length;a++)e[a].registerFunctions(t);for(const a in t.functions)d[a]={value:new Z(t.functions[a])},B.prototype[a]=d[a];for(let a=0;a<t.signatures.length;a++)mt(t.signatures[a],"async")}async function $t(e,t){let a=t.spatialReference;a==null&&(a=new tt({wkid:102100}));let o=null;e.usesModules&&(o=new T(new Map,e.loadedModules));const r=st(t.vars,t.customfunctions,t.timeZone),n={spatialReference:a,services:t.services,exports:{},libraryResolver:o,abortSignal:t.abortSignal===void 0||t.abortSignal===null?{aborted:!1}:t.abortSignal,globalScope:r,console:t.console??ct,timeZone:t.timeZone??null,lrucache:t.lrucache,interceptor:t.interceptor,localScope:null,depthCounter:{depth:1}},s=await j(n,e);if(s instanceof y||s instanceof G){const c=s.value;if(c===w)return null;if(v(c))throw new i(n,l.IllegalResult,null);return c}if(s===w)return null;throw s===m?new i(n,l.IllegalResult,null):s===E?new i(n,l.IllegalResult,null):new i(n,l.NeverReach,null)}ut([bt]);export{$t as executeScript,ut as extend,Xt as functionHelper};
