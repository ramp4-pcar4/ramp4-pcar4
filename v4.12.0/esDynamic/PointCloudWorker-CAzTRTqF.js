import{x as i,z as c,K as g,G as I,af as Y,bj as q,v as le,ai as h,bx as Z,by as L,j1 as ae,bP as ue,Q as $}from"./main-DnzmeE4U.js";import{O as pe}from"./quat-D8L_R4I0.js";import{e as de}from"./quatf64-C16JxGFv.js";import{Q as ce}from"./vec32-BuqRmYBM.js";import{t as H,n as ee}from"./vec3f32-BS0cezmI.js";import{o as fe}from"./projection-m8vi7Cxv.js";import{u as M}from"./RendererLegendOptions-f5mIImtQ.js";import{a as ye}from"./ColorStop-DoHCvOqO.js";import{w as be,l as he,c as me,I as ve}from"./I3SBinaryReader-CyBOtojY.js";import{I as ge}from"./orientedBoundingBox-CTsjUkMw.js";var k;let j=k=class extends I{constructor(){super(...arguments),this.field=null,this.minValue=0,this.maxValue=255}clone(){return new k({field:this.field,minValue:this.minValue,maxValue:this.maxValue})}};i([c({type:String,json:{write:{isRequired:!0}}})],j.prototype,"field",void 0),i([c({type:Number,nonNullable:!0,json:{write:{isRequired:!0}}})],j.prototype,"minValue",void 0),i([c({type:Number,nonNullable:!0,json:{write:{isRequired:!0}}})],j.prototype,"maxValue",void 0),j=k=i([g("esri.renderers.support.pointCloud.ColorModulation")],j);const we=j,N=new Y({pointCloudFixedSizeAlgorithm:"fixed-size",pointCloudSplatAlgorithm:"splat"});let O=class extends I{};i([c({type:N.apiValues,readOnly:!0,nonNullable:!0,json:{type:N.jsonValues,read:!1,write:{writer:N.write,isRequired:!0}}})],O.prototype,"type",void 0),O=i([g("esri.renderers.support.pointCloud.PointSizeAlgorithm")],O);const B=O;var P;let x=P=class extends B{constructor(){super(...arguments),this.type="fixed-size",this.size=0,this.useRealWorldSymbolSizes=null}clone(){return new P({size:this.size,useRealWorldSymbolSizes:this.useRealWorldSymbolSizes})}};i([q({pointCloudFixedSizeAlgorithm:"fixed-size"})],x.prototype,"type",void 0),i([c({type:Number,nonNullable:!0,json:{write:{isRequired:!0}}})],x.prototype,"size",void 0),i([c({type:Boolean,json:{write:!0}})],x.prototype,"useRealWorldSymbolSizes",void 0),x=P=i([g("esri.renderers.support.pointCloud.PointSizeFixedSizeAlgorithm")],x);const Te=x;var F;let A=F=class extends B{constructor(){super(...arguments),this.type="splat",this.scaleFactor=1}clone(){return new F({scaleFactor:this.scaleFactor})}};i([q({pointCloudSplatAlgorithm:"splat"})],A.prototype,"type",void 0),i([c({type:Number,value:1,nonNullable:!0,json:{write:{isRequired:!0}}})],A.prototype,"scaleFactor",void 0),A=F=i([g("esri.renderers.support.pointCloud.PointSizeSplatAlgorithm")],A);const Se=A,Ve={key:"type",base:B,typeMap:{"fixed-size":Te,splat:Se}},U=le()({pointCloudClassBreaksRenderer:"point-cloud-class-breaks",pointCloudRGBRenderer:"point-cloud-rgb",pointCloudStretchRenderer:"point-cloud-stretch",pointCloudUniqueValueRenderer:"point-cloud-unique-value"});let w=class extends I{constructor(n){super(n),this.type=void 0,this.pointSizeAlgorithm=null,this.colorModulation=null,this.pointsPerInch=10}clone(){return console.warn(".clone() is not implemented for "+this.declaredClass),null}cloneProperties(){return{pointSizeAlgorithm:h(this.pointSizeAlgorithm),colorModulation:h(this.colorModulation),pointsPerInch:h(this.pointsPerInch)}}};i([c({type:U.apiValues,readOnly:!0,nonNullable:!0,json:{type:U.jsonValues,read:!1,write:{writer:U.write,isRequired:!0}}})],w.prototype,"type",void 0),i([c({types:Ve,json:{write:!0}})],w.prototype,"pointSizeAlgorithm",void 0),i([c({type:we,json:{write:!0}})],w.prototype,"colorModulation",void 0),i([c({json:{write:!0},nonNullable:!0,type:Number})],w.prototype,"pointsPerInch",void 0),w=i([g("esri.renderers.PointCloudRenderer")],w),function(n){n.fieldTransformTypeKebabDict=new Y({none:"none",lowFourBit:"low-four-bit",highFourBit:"high-four-bit",absoluteValue:"absolute-value",moduloTen:"modulo-ten"})}(w||(w={}));const m=w;var K;let T=K=class extends I{constructor(){super(...arguments),this.description=null,this.label=null,this.minValue=0,this.maxValue=0,this.color=null}clone(){return new K({description:this.description,label:this.label,minValue:this.minValue,maxValue:this.maxValue,color:h(this.color)})}};i([c({type:String,json:{write:!0}})],T.prototype,"description",void 0),i([c({type:String,json:{write:!0}})],T.prototype,"label",void 0),i([c({type:Number,json:{read:{source:"classMinValue"},write:{target:"classMinValue",isRequired:!0}}})],T.prototype,"minValue",void 0),i([c({type:Number,json:{read:{source:"classMaxValue"},write:{target:"classMaxValue",isRequired:!0}}})],T.prototype,"maxValue",void 0),i([c({type:Z,json:{type:[L],write:{isRequired:!0}}})],T.prototype,"color",void 0),T=K=i([g("esri.renderers.support.pointCloud.ColorClassBreakInfo")],T);const Ce=T;var J;let S=J=class extends m{constructor(n){super(n),this.type="point-cloud-class-breaks",this.field=null,this.legendOptions=null,this.fieldTransformType=null,this.colorClassBreakInfos=null}clone(){return new J({...this.cloneProperties(),field:this.field,fieldTransformType:this.fieldTransformType,colorClassBreakInfos:h(this.colorClassBreakInfos),legendOptions:h(this.legendOptions)})}};i([q({pointCloudClassBreaksRenderer:"point-cloud-class-breaks"})],S.prototype,"type",void 0),i([c({json:{write:{isRequired:!0}},type:String})],S.prototype,"field",void 0),i([c({type:M,json:{write:!0}})],S.prototype,"legendOptions",void 0),i([c({type:m.fieldTransformTypeKebabDict.apiValues,json:{type:m.fieldTransformTypeKebabDict.jsonValues,read:m.fieldTransformTypeKebabDict.read,write:m.fieldTransformTypeKebabDict.write}})],S.prototype,"fieldTransformType",void 0),i([c({type:[Ce],json:{write:{isRequired:!0}}})],S.prototype,"colorClassBreakInfos",void 0),S=J=i([g("esri.renderers.PointCloudClassBreaksRenderer")],S);const te=S;var _;let V=_=class extends m{constructor(n){super(n),this.type="point-cloud-stretch",this.field=null,this.legendOptions=null,this.fieldTransformType=null,this.stops=null}clone(){return new _({...this.cloneProperties(),field:h(this.field),fieldTransformType:h(this.fieldTransformType),stops:h(this.stops),legendOptions:h(this.legendOptions)})}};i([q({pointCloudStretchRenderer:"point-cloud-stretch"})],V.prototype,"type",void 0),i([c({json:{write:{isRequired:!0}},type:String})],V.prototype,"field",void 0),i([c({type:M,json:{write:!0}})],V.prototype,"legendOptions",void 0),i([c({type:m.fieldTransformTypeKebabDict.apiValues,json:{type:m.fieldTransformTypeKebabDict.jsonValues,read:m.fieldTransformTypeKebabDict.read,write:m.fieldTransformTypeKebabDict.write}})],V.prototype,"fieldTransformType",void 0),i([c({type:[ye],json:{write:{isRequired:!0}}})],V.prototype,"stops",void 0),V=_=i([g("esri.renderers.PointCloudStretchRenderer")],V);const oe=V;var G;let R=G=class extends I{constructor(){super(...arguments),this.description=null,this.label=null,this.values=null,this.color=null}clone(){return new G({description:this.description,label:this.label,values:h(this.values),color:h(this.color)})}};i([c({type:String,json:{write:!0}})],R.prototype,"description",void 0),i([c({type:String,json:{write:!0}})],R.prototype,"label",void 0),i([c({type:[String],json:{write:{isRequired:!0}}})],R.prototype,"values",void 0),i([c({type:Z,json:{type:[L],write:{isRequired:!0}}})],R.prototype,"color",void 0),R=G=i([g("esri.renderers.support.pointCloud.ColorUniqueValueInfo")],R);const Re=R;var W;let C=W=class extends m{constructor(n){super(n),this.type="point-cloud-unique-value",this.field=null,this.fieldTransformType=null,this.colorUniqueValueInfos=null,this.legendOptions=null}clone(){return new W({...this.cloneProperties(),field:h(this.field),fieldTransformType:h(this.fieldTransformType),colorUniqueValueInfos:h(this.colorUniqueValueInfos),legendOptions:h(this.legendOptions)})}};i([q({pointCloudUniqueValueRenderer:"point-cloud-unique-value"})],C.prototype,"type",void 0),i([c({json:{write:{isRequired:!0}},type:String})],C.prototype,"field",void 0),i([c({type:m.fieldTransformTypeKebabDict.apiValues,json:{type:m.fieldTransformTypeKebabDict.jsonValues,read:m.fieldTransformTypeKebabDict.read,write:m.fieldTransformTypeKebabDict.write}})],C.prototype,"fieldTransformType",void 0),i([c({type:[Re],json:{write:{isRequired:!0}}})],C.prototype,"colorUniqueValueInfos",void 0),i([c({type:M,json:{write:!0}})],C.prototype,"legendOptions",void 0),C=W=i([g("esri.renderers.PointCloudUniqueValueRenderer")],C);const re=C;function je(n,e,l,s){const{rendererJSON:f,isRGBRenderer:b}=n;let o=null,u=null;if(e&&b)o=e;else if(e&&f?.type==="pointCloudUniqueValueRenderer"){u=re.fromJSON(f);const t=u.colorUniqueValueInfos;o=new Uint8Array(3*s);const d=E(u.fieldTransformType);for(let r=0;r<s;r++){const a=(d?d(e[r]):e[r])+"";for(let p=0;p<t.length;p++)if(t[p].values.includes(a)){o[3*r]=t[p].color.r,o[3*r+1]=t[p].color.g,o[3*r+2]=t[p].color.b;break}}}else if(e&&f?.type==="pointCloudStretchRenderer"){u=oe.fromJSON(f);const t=u.stops;o=new Uint8Array(3*s);const d=E(u.fieldTransformType);for(let r=0;r<s;r++){const a=d?d(e[r]):e[r],p=t.length-1;if(a<t[0].value)o[3*r]=t[0].color.r,o[3*r+1]=t[0].color.g,o[3*r+2]=t[0].color.b;else if(a>=t[p].value)o[3*r]=t[p].color.r,o[3*r+1]=t[p].color.g,o[3*r+2]=t[p].color.b;else for(let y=1;y<t.length;y++)if(a<t[y].value){const v=(a-t[y-1].value)/(t[y].value-t[y-1].value);o[3*r]=t[y].color.r*v+t[y-1].color.r*(1-v),o[3*r+1]=t[y].color.g*v+t[y-1].color.g*(1-v),o[3*r+2]=t[y].color.b*v+t[y-1].color.b*(1-v);break}}}else if(e&&f?.type==="pointCloudClassBreaksRenderer"){u=te.fromJSON(f);const t=u.colorClassBreakInfos;o=new Uint8Array(3*s);const d=E(u.fieldTransformType);for(let r=0;r<s;r++){const a=d?d(e[r]):e[r];for(let p=0;p<t.length;p++)if(a>=t[p].minValue&&a<=t[p].maxValue){o[3*r]=t[p].color.r,o[3*r+1]=t[p].color.g,o[3*r+2]=t[p].color.b;break}}}else o=new Uint8Array(3*s).fill(255);if(l&&u?.colorModulation){const t=u.colorModulation.minValue,d=u.colorModulation.maxValue,r=.3;for(let a=0;a<s;a++){const p=l[a],y=p>=d?1:p<=t?r:r+(1-r)*(p-t)/(d-t);o[3*a]=y*o[3*a],o[3*a+1]=y*o[3*a+1],o[3*a+2]=y*o[3*a+2]}}return o}function xe(n,e){if(n.encoding==null||n.encoding===""){const l=be(e,n);if(l.vertexAttributes.position==null)return;const s=he(e,l.vertexAttributes.position),f=l.header.fields,b=[f.offsetX,f.offsetY,f.offsetZ],o=[f.scaleX,f.scaleY,f.scaleZ],u=s.length/3,t=new Float64Array(3*u);for(let d=0;d<u;d++)t[3*d]=s[3*d]*o[0]+b[0],t[3*d+1]=s[3*d+1]*o[1]+b[1],t[3*d+2]=s[3*d+2]*o[2]+b[2];return t}if(n.encoding==="lepcc-xyz")return me(e).result}function D(n,e,l){return n?.attributeInfo.useElevation?e?Ie(e,l):null:n?.attributeInfo.storageInfo?ve(n.attributeInfo.storageInfo,n.buffer,l):null}function Ie(n,e){const l=new Float64Array(e);for(let s=0;s<e;s++)l[s]=n[3*s+2];return l}function qe(n,e,l,s,f){const b=n.length/3;let o=0;for(let u=0;u<b;u++){let t=!0;for(let d=0;d<s.length&&t;d++){const{filterJSON:r}=s[d],a=f[d].values[u];switch(r.type){case"pointCloudValueFilter":{const p=r.mode==="exclude";r.values.includes(a)===p&&(t=!1);break}case"pointCloudBitfieldFilter":{const p=ie(r.requiredSetBits),y=ie(r.requiredClearBits);((a&p)!==p||a&y)&&(t=!1);break}case"pointCloudReturnFilter":{const p=15&a,y=a>>>4&15,v=y>1,se=p===1,Q=p===y;let X=!1;for(const z of r.includedReturns)if(z==="last"&&Q||z==="firstOfMany"&&se&&v||z==="lastOfMany"&&Q&&v||z==="single"&&!v){X=!0;break}X||(t=!1);break}}}t&&(l[o]=u,n[3*o]=n[3*u],n[3*o+1]=n[3*u+1],n[3*o+2]=n[3*u+2],e[3*o]=e[3*u],e[3*o+1]=e[3*u+1],e[3*o+2]=e[3*u+2],o++)}return o}function E(n){switch(n){default:case null:case"none":return e=>e;case"low-four-bit":return e=>15&e;case"high-four-bit":return e=>(240&e)>>4;case"absolute-value":return e=>Math.abs(e);case"modulo-ten":return e=>e%10}}function ie(n){let e=0;for(const l of n||[])e|=1<<l;return e}class Ae{transform(e){const l=this._transform(e),s=[l.points.buffer,l.rgb.buffer];l.pointIdFilterMap!=null&&s.push(l.pointIdFilterMap.buffer);for(const f of l.attributes)"buffer"in f.values&&ae(f.values.buffer)&&f.values.buffer!==l.rgb.buffer&&s.push(f.values.buffer);return Promise.resolve({result:l,transferList:s})}_transform(e){const l=xe(e.schema,e.geometryBuffer);let s=l.length/3,f=null;const b=new Array,o=D(e.primaryAttributeData,l,s);e.primaryAttributeData!=null&&o&&b.push({attributeInfo:e.primaryAttributeData.attributeInfo,values:o});const u=D(e.modulationAttributeData,l,s);e.modulationAttributeData!=null&&u&&b.push({attributeInfo:e.modulationAttributeData.attributeInfo,values:u});let t=je(e.rendererInfo,o,u,s);if(e.filterInfo&&e.filterInfo.length>0&&e.filterAttributesData!=null){const r=e.filterAttributesData.filter(ue).map(a=>{const p=D(a,l,s),y={attributeInfo:a.attributeInfo,values:p};return b.push(y),y});f=new Uint32Array(s),s=qe(l,t,f,e.filterInfo,r)}for(const r of e.userAttributesData){const a=D(r,l,s);b.push({attributeInfo:r.attributeInfo,values:a})}3*s<t.length&&(t=new Uint8Array(t.buffer.slice(0,3*s))),Oe(l,s,e.elevationOffset);const d=ze(l,s,ge.fromData(e.obbData),$.fromJSON(e.inSR),$.fromJSON(e.outSR));return{obbData:e.obbData,points:d,rgb:t,attributes:b,pointIdFilterMap:f}}}function ze(n,e,l,s,f){if(!fe(n,s,0,n,f,0,e))throw new Error("Can't reproject");const b=H(l.center),o=ee(),u=ee(),t=H(l.halfSize);pe(ne,l.quaternion);const d=new Float32Array(3*e);for(let r=0;r<e;r++){let a=3*r;o[0]=n[a]-b[0],o[1]=n[a+1]-b[1],o[2]=n[a+2]-b[2],ce(u,o,ne),t[0]=Math.max(t[0],Math.abs(u[0])),t[1]=Math.max(t[1],Math.abs(u[1])),t[2]=Math.max(t[2],Math.abs(u[2])),d[a++]=o[0],d[a++]=o[1],d[a]=o[2]}return l.halfSize=t,d}function Oe(n,e,l){if(l!==0)for(let s=0;s<e;s++)n[3*s+2]+=l}const ne=de();function De(){return new Ae}const Me=Object.freeze(Object.defineProperty({__proto__:null,default:De},Symbol.toStringTag,{value:"Module"}));export{Me as P,te as a,oe as b,re as c,m as d};
