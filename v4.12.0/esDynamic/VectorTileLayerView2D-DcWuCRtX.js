import{b7 as Ee,fT as Ve,gA as ne,hc as ze,bc as Fe,ba as Y,f8 as ae,ay as He,ca as V,h2 as qe,f2 as O,ah as le,aJ as Be,d5 as z,bE as Ne,n as j,ai as Qe,an as We,x as he,z as Je,K as Ke}from"./main-DnzmeE4U.js";import{y as Ge,p as Ye}from"./diffUtils-BSe9IE26.js";import{E as M,I as x}from"./enums-qHpGJ28Q.js";import{p as je}from"./workers-0oosFQiO.js";import{w as $e,t as P,d as Xe}from"./Rect-KI3be8Nv.js";import{G as Ze,D as ce,F as v,I as k,O as ue,R as B}from"./enums-DBi1-Mm2.js";import{p as ye,w as de}from"./Texture-DXSFJsEu.js";import{a as $}from"./pbf-Ijhb7ANA.js";import{u as et}from"./rasterizingUtils-B8CPqgVl.js";import{e as A,s as _e,h as tt,p as fe}from"./Tile-DvzRai0K.js";import{e as st}from"./LRUCache-BLmkvs7b.js";import{o as it,M as rt,h as ot,f as nt}from"./mat3-DOnW3DjW.js";import{r as at,e as F,E as N}from"./MapView-BcnxJC0k.js";import{i as pe}from"./memoryEstimations-iHVpvWPf.js";import{E as C,o as U}from"./VertexArrayObject-DTkLCIKs.js";import{t as lt,n as ht,l as L,r as ct,e as Q,i as X,c as ut,b as D}from"./config-DB0LnTDt.js";import{r as ge}from"./WGLContainer-CF3AeUnM.js";import{z as me}from"./TileInfo-owTCOSRx.js";import{r as yt}from"./signal-DxzURL18.js";import{i as dt}from"./TileContainer-Dc8VVA_r.js";import{s as _t}from"./PooledRBush-J5-OtqBl.js";import{e as be,s as we,L as ft,l as Se}from"./SourceLayerData-DFLKou4m.js";import{S as pt}from"./LayerView2D-CCfp06E-.js";import{y as gt}from"./LayerView-D3XoMhlx.js";import{i as mt}from"./RefreshableLayerView-CB9NNXxL.js";import{g as xe}from"./Scheduler-Br-2v2ys.js";let bt=class{constructor(i,e){this.sourceTile=e,this.xTile=0,this.yTile=0,this.hash=0,this.priority=1,this.featureIndex=0,this.colliders=[],this.textVertexRanges=[],this.iconVertexRanges=[],this.tile=i}},wt=class{constructor(){this.tileSymbols=[],this.parts=[{startTime:0,startOpacity:0,targetOpacity:0,show:!1},{startTime:0,startOpacity:0,targetOpacity:0,show:!1}],this.show=!1}};function Te(i,e,s,t,r,o){const a=s-r;if(a>=0)return(e>>a)+(t-(o<<a))*(i>>a);const n=-a;return e-(o-(t<<n))*(i>>n)<<n}let Ie=class{constructor(i,e,s){this._rows=Math.ceil(e/s),this._columns=Math.ceil(i/s),this._cellSize=s,this.cells=new Array(this._rows);for(let t=0;t<this._rows;t++){this.cells[t]=new Array(this._columns);for(let r=0;r<this._columns;r++)this.cells[t][r]=[]}}getCell(i,e){const s=Math.min(Math.max(Math.floor(e/this._cellSize),0),this._rows-1),t=Math.min(Math.max(Math.floor(i/this._cellSize),0),this._columns-1);return this.cells[s]&&this.cells[s][t]||null}getCellSpan(i,e,s,t){return[Math.min(Math.max(Math.floor(i/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(e/this._cellSize),0),this.rows-1),Math.min(Math.max(Math.floor(s/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(t/this._cellSize),0),this.rows-1)]}get cellSize(){return this._cellSize}get columns(){return this._columns}get rows(){return this._rows}};function St(i,e,s,t,r,o,a){const n=e[t++];for(let l=0;l<n;l++){const h=new bt(o,a);h.xTile=e[t++],h.yTile=e[t++],h.hash=e[t++],h.priority=e[t++],h.featureIndex=e[t++];const c=e[t++];for(let y=0;y<c;y++){const f=e[t++],p=e[t++],_=e[t++],m=e[t++],g=!!e[t++],b=e[t++],T=s[t++],S=s[t++],w=e[t++],R=e[t++];h.colliders.push({xTile:f,yTile:p,dxPixels:_,dyPixels:m,hard:g,partIndex:b,width:w,height:R,minLod:T,maxLod:S})}const u=i[t++];for(let y=0;y<u;y++)h.textVertexRanges.push([i[t++],i[t++]]);const d=i[t++];for(let y=0;y<d;y++)h.iconVertexRanges.push([i[t++],i[t++]]);r.push(h)}return t}function xt(i,e,s){for(const[t,r]of i.symbols)Tt(i,e,s,r,t)}function Tt(i,e,s,t,r){const o=i.layerData.get(r);if(o.type===M.SYMBOL){for(const a of t){const n=a.unique;let l;if(a.selectedForRendering){const h=n.parts[0],c=h.startOpacity,u=h.targetOpacity;i.allSymbolsFadingOut=i.allSymbolsFadingOut&&u===0;const d=Math.floor(127*c)|u<<7;l=d<<24|d<<16|d<<8|d}else l=0;for(const[h,c]of a.iconVertexRanges)for(let u=h;u<h+c;u+=4)o.iconOpacity[u/4]=l;if(a.selectedForRendering){const h=n.parts[1],c=h.startOpacity,u=h.targetOpacity;i.allSymbolsFadingOut=i.allSymbolsFadingOut&&u===0;const d=Math.floor(127*c)|u<<7;l=d<<24|d<<16|d<<8|d}else l=0;for(const[h,c]of a.textVertexRanges)for(let u=h;u<h+c;u+=4)o.textOpacity[u/4]=l}o.lastOpacityUpdate=e,o.opacityChanged=!0}}function It(i,e,s,t){const r=i.colliders;let o,a,n,l;for(const h of r)if(i.unique.show&&i.unique.parts[h.partIndex].show&&(o=h.xScreen-t[0]+h.dxScreen,a=h.yScreen-t[1]+h.dyScreen,n=o+h.width,l=a+h.height,$e(s,e.x,e.y,o,a,n,l)))return!0;return!1}function vt(i,e,s,t,r,o){const{iconRotationAlignment:a,textRotationAlignment:n,iconTranslate:l,iconTranslateAnchor:h,textTranslate:c,textTranslateAnchor:u}=t;let d=0;for(const y of i.colliders){const[f,p]=y.partIndex===0?l:c,_=y.partIndex===0?h:u,m=y.minLod<=o&&o<=y.maxLod;d+=m?0:1,y.enabled=m,y.xScreen=y.xTile*r[0]+y.yTile*r[3]+r[6],y.yScreen=y.xTile*r[1]+y.yTile*r[4]+r[7],_===ct.MAP?(y.xScreen+=s*f-e*p,y.yScreen+=e*f+s*p):(y.xScreen+=f,y.yScreen+=p),L.VIEWPORT===(y.partIndex===0?a:n)?(y.dxScreen=y.dxPixels,y.dyScreen=y.dyPixels):(y.dxScreen=s*(y.dxPixels+y.width/2)-e*(y.dyPixels+y.height/2)-y.width/2,y.dyScreen=e*(y.dxPixels+y.width/2)+s*(y.dyPixels+y.height/2)-y.height/2)}i.colliders.length>0&&d===i.colliders.length&&(i.unique.show=!1)}let Ct=class{constructor(i,e,s,t,r,o){this._symbols=i,this._styleRepository=t,this._zoom=r,this._currentLayerCursor=0,this._currentSymbolCursor=0,this._styleProps=new Map,this._allNeededMatrices=new Map,this._gridIndex=new Ie(e,s,lt),this._si=Math.sin(Math.PI*o/180),this._co=Math.cos(Math.PI*o/180);for(const a of i)for(const n of a.symbols)this._allNeededMatrices.has(n.tile)||this._allNeededMatrices.set(n.tile,at(n.tile.transforms.tileUnitsToPixels))}work(i){const e=this._gridIndex;function s(r){const o=r.xScreen+r.dxScreen,a=r.yScreen+r.dyScreen,n=o+r.width,l=a+r.height,[h,c,u,d]=e.getCellSpan(o,a,n,l);for(let y=c;y<=d;y++)for(let f=h;f<=u;f++){const p=e.cells[y][f];for(const _ of p){const m=_.xScreen+_.dxScreen,g=_.yScreen+_.dyScreen,b=m+_.width,T=g+_.height;if(!(n<m||o>b||l<g||a>T))return!0}}return!1}const t=performance.now();for(;this._currentLayerCursor<this._symbols.length;this._currentLayerCursor++,this._currentSymbolCursor=0){const r=this._symbols[this._currentLayerCursor],o=this._getProperties(r.styleLayerUID);for(;this._currentSymbolCursor<r.symbols.length;this._currentSymbolCursor++){if(this._currentSymbolCursor%100==99&&performance.now()-t>i)return!1;const a=r.symbols[this._currentSymbolCursor];if(!a.unique.show)continue;vt(a,this._si,this._co,o,this._allNeededMatrices.get(a.tile),this._zoom);const n=a.unique;if(!n.show)continue;const{iconAllowOverlap:l,iconIgnorePlacement:h,textAllowOverlap:c,textIgnorePlacement:u}=o;for(const d of a.colliders){if(!d.enabled)continue;const y=n.parts[d.partIndex];y.show&&!(d.partIndex?c:l)&&s(d)&&(d.hard?n.show=!1:y.show=!1)}if(n.show)for(const d of a.colliders){if(!d.enabled||(d.partIndex?u:h)||!n.parts[d.partIndex].show)continue;const y=d.xScreen+d.dxScreen,f=d.yScreen+d.dyScreen,p=y+d.width,_=f+d.height,[m,g,b,T]=this._gridIndex.getCellSpan(y,f,p,_);for(let S=g;S<=T;S++)for(let w=m;w<=b;w++)this._gridIndex.cells[S][w].push(d)}}}return!0}_getProperties(i){const e=this._styleProps.get(i);if(e)return e;const s=this._zoom,t=this._styleRepository.getStyleLayerByUID(i),r=t.getLayoutValue("symbol-placement",s)!==ht.POINT;let o=t.getLayoutValue("icon-rotation-alignment",s);o===L.AUTO&&(o=r?L.MAP:L.VIEWPORT);let a=t.getLayoutValue("text-rotation-alignment",s);a===L.AUTO&&(a=r?L.MAP:L.VIEWPORT);const n=t.getPaintValue("icon-translate",s),l=t.getPaintValue("icon-translate-anchor",s),h=t.getPaintValue("text-translate",s),c=t.getPaintValue("text-translate-anchor",s),u={iconAllowOverlap:t.getLayoutValue("icon-allow-overlap",s),iconIgnorePlacement:t.getLayoutValue("icon-ignore-placement",s),textAllowOverlap:t.getLayoutValue("text-allow-overlap",s),textIgnorePlacement:t.getLayoutValue("text-ignore-placement",s),iconRotationAlignment:o,textRotationAlignment:a,iconTranslateAnchor:l,iconTranslate:n,textTranslateAnchor:c,textTranslate:h};return this._styleProps.set(i,u),u}};function Dt(i,e){if(i.priority-e.priority)return i.priority-e.priority;const s=i.tile.key,t=e.tile.key;return s.world-t.world?s.world-t.world:s.level-t.level?s.level-t.level:s.row-t.row?s.row-t.row:s.col-t.col?s.col-t.col:i.xTile-e.xTile?i.xTile-e.xTile:i.yTile-e.yTile}let Mt=class{get running(){return this._running}constructor(i,e,s,t,r,o){this._visibleTiles=i,this._symbolRepository=e,this._createCollisionJob=s,this._assignTileSymbolsOpacity=t,this._symbolLayerSorter=r,this._isLayerVisible=o,this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}setScreenSize(i,e){this._screenWidth===i&&this._screenHeight===e||this.restart(),this._screenWidth=i,this._screenHeight=e}restart(){this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}continue(i){if(this._selectionJob||(this._selectionJob=this._createSelectionJob()),!this._selectionJobCompleted){const e=performance.now();if(!this._selectionJob.work(i)||(this._selectionJobCompleted=!0,(i=Math.max(0,i-(performance.now()-e)))===0))return!1}if(this._collisionJob||(this._collisionJob=this._createCollisionJob(this._selectionJob.sortedSymbols,this._screenWidth,this._screenHeight)),!this._collisionJobCompleted){const e=performance.now();if(!this._collisionJob.work(i)||(this._collisionJobCompleted=!0,(i=Math.max(0,i-(performance.now()-e)))===0))return!1}if(this._opacityJob||(this._opacityJob=this._createOpacityJob()),!this._opacityJobCompleted){const e=performance.now();if(!this._opacityJob.work(i)||(this._opacityJobCompleted=!0,(i=Math.max(0,i-(performance.now()-e)))===0))return!1}return this._running=!1,!0}_createSelectionJob(){const i=this._symbolRepository.uniqueSymbols;for(let n=0;n<i.length;n++){const l=i[n];for(let h=0;h<l.uniqueSymbols.length;h++){const c=l.uniqueSymbols[h];for(const u of c.tileSymbols)u.selectedForRendering=!1}}const e=[];let s=0,t=0;const r=this._isLayerVisible;function o(n){let l;const h=performance.now();for(;t<i.length;t++,s=0){const c=i[t],u=c.styleLayerUID;if(!r(u)){e[t]||(e[t]={styleLayerUID:u,symbols:[]});continue}e[t]=e[t]||{styleLayerUID:u,symbols:[]};const d=e[t];for(;s<c.uniqueSymbols.length;s++){if(l=c.uniqueSymbols[s],s%100==99&&performance.now()-h>n)return!1;let y=null,f=!1,p=!1;for(const _ of l.tileSymbols)if(!p||!f){const m=_.tile;(!y||m.isCoverage||m.neededForCoverage&&!f)&&(y=_,(m.neededForCoverage||m.isCoverage)&&(p=!0),m.isCoverage&&(f=!0))}if(y.selectedForRendering=!0,p){d.symbols.push(y),l.show=!0;for(const _ of l.parts)_.show=!0}else l.show=!1}}for(const c of e)c.symbols.sort(Dt);return!0}const a=this._symbolLayerSorter;return{work:o,get sortedSymbols(){return e.sort(a)}}}_createOpacityJob(){const i=this._assignTileSymbolsOpacity,e=this._visibleTiles;let s=0;function t(r,o){for(const a of r.symbols.values())Rt(a,o);i(r,o);for(const a of r.childrenTiles)t(a,o)}return{work(r){const o=performance.now();for(;s<e.length;s++){if(performance.now()-o>r)return!1;const a=e[s];a.parentTile==null&&t(a,performance.now())}return!0}}}};function Rt(i,e){for(const s of i){const t=s.unique;for(const r of t.parts){const o=r.targetOpacity>.5?1:-1;r.startOpacity+=o*((e-r.startTime)/Q),r.startOpacity=Math.min(Math.max(r.startOpacity,0),1),r.startTime=e,r.targetOpacity=t.show&&r.show?1:0}}}const Pt=32,At=8,Lt=64,Ot=20;let kt=class{constructor(i,e,s){this.tileCoordRange=i,this._visibleTiles=e,this._createUnique=s,this._tiles=new Map,this._uniqueSymbolsReferences=new Map}get uniqueSymbols(){return this._uniqueSymbolLayerArray==null&&(this._uniqueSymbolLayerArray=this._createUniqueSymbolLayerArray()),this._uniqueSymbolLayerArray}get uniqueSymbolsReferences(){return this._uniqueSymbolsReferences}add(i,e){this._uniqueSymbolLayerArray=null;let s=this._tiles.get(i.id);s||(s={symbols:new Map},this._tiles.set(i.id,s));const t=new Map;if(e)for(const a of e)s.symbols.has(a)&&(t.set(a,s.symbols.get(a)),s.symbols.delete(a));else for(const[a,n]of i.layerData)s.symbols.has(a)&&(t.set(a,s.symbols.get(a)),s.symbols.delete(a));this._removeSymbols(t);const r=i.symbols,o=new Map;for(const[a,n]of r){let l=n.length;if(l>=Pt){let h=this.tileCoordRange;do h/=2,l/=4;while(l>At&&h>Lt);const c=new Ie(this.tileCoordRange,this.tileCoordRange,h);o.set(a,{flat:n,index:c}),s.symbols.set(a,{flat:n,index:c});for(const u of n)c.getCell(u.xTile,u.yTile).push(u)}else o.set(a,{flat:n}),s.symbols.set(a,{flat:n})}this._addSymbols(i.key,r)}deleteStyleLayers(i){this._uniqueSymbolLayerArray=null;for(const[e,s]of this._tiles){const t=new Map;for(const r of i)s.symbols.has(r)&&(t.set(r,s.symbols.get(r)),s.symbols.delete(r));this._removeSymbols(t),s.symbols.size===0&&this._tiles.delete(e)}}removeTile(i){this._uniqueSymbolLayerArray=null;const e=this._tiles.get(i.id);if(!e)return;const s=new Map;for(const[t,r]of i.symbols)e.symbols.has(t)&&(s.set(t,e.symbols.get(t)),e.symbols.delete(t));this._removeSymbols(s),e.symbols.size===0&&this._tiles.delete(i.id)}querySymbols(i,e,s,t){const r=[],o=this.uniqueSymbols;for(const a of o){const n=a.styleLayerUID,l=a.uniqueSymbols;for(const h of l){const c=h.tileSymbols.find(u=>u.selectedForRendering);c&&It(c,i,e*(window.devicePixelRatio||1),s)&&r.push({vtlSymbol:c,styleLayerUID:n,tileKey:c.tile.key})}}return r}_removeSymbols(i){for(const[e,{flat:s}]of i)for(const t of s){const r=t.unique,o=r.tileSymbols,a=o.length-1;for(let n=0;n<a;n++)if(o[n]===t){o[n]=o[a];break}if(o.length=a,a===0){const n=this._uniqueSymbolsReferences.get(e);n.delete(r),n.size===0&&this._uniqueSymbolsReferences.delete(e)}t.unique=null}}_addSymbols(i,e){if(e.size===0)return;const s=this._visibleTiles;for(const t of s)t.parentTile||t.key.world!==i.world||t.key.level===i.level&&!t.key.equals(i)||this._matchSymbols(t,i,e);for(const[t,r]of e)for(const o of r)if(o.unique==null){const a=this._createUnique();o.unique=a,a.tileSymbols.push(o);let n=this._uniqueSymbolsReferences.get(t);n||(n=new Set,this._uniqueSymbolsReferences.set(t,n)),n.add(a)}}_matchSymbols(i,e,s){if(i.key.level>e.level){const r=i.key.level-e.level;if(i.key.row>>r!==e.row||i.key.col>>r!==e.col)return}if(e.level>i.key.level){const r=e.level-i.key.level;if(e.row>>r!==i.key.row||e.col>>r!==i.key.col)return}if(e.equals(i.key)){for(const r of i.childrenTiles)this._matchSymbols(r,e,s);return}const t=new Map;for(const[r,o]of s){const a=[];for(const c of o){const u=Te(this.tileCoordRange,c.xTile,e.level,e.col,i.key.level,i.key.col),d=Te(this.tileCoordRange,c.yTile,e.level,e.row,i.key.level,i.key.row);u>=0&&u<this.tileCoordRange&&d>=0&&d<this.tileCoordRange&&a.push({symbol:c,xTransformed:u,yTransformed:d})}const n=[],l=(i.key.level<e.level?1:1<<i.key.level-e.level)+Ot,h=this._tiles.get(i.id).symbols.get(r);if(h){const c=h.flat;for(const u of a){let d,y=!1;const f=u.xTransformed,p=u.yTransformed;d=h.index!=null?h.index.getCell(f,p):c;const _=u.symbol,m=_.hash;for(const g of d)if(m===g.hash&&Math.abs(f-g.xTile)<=l&&Math.abs(p-g.yTile)<=l){const b=g.unique;_.unique=b,b.tileSymbols.push(_),y=!0;break}y||n.push(_)}}n.length>0&&t.set(r,n)}for(const r of i.childrenTiles)this._matchSymbols(r,e,t)}_createUniqueSymbolLayerArray(){const i=this._uniqueSymbolsReferences,e=new Array(i.size);let s,t=0;for(const[r,o]of i){const a=new Array(o.size);s=0;for(const n of o)a[s++]=n;e[t]={styleLayerUID:r,uniqueSymbols:a},t++}return e}},Ut=class extends ge{_createTransforms(){return{displayViewScreenMat3:F(),tileMat3:F()}}};class H{constructor(e,s){this._width=0,this._height=0,this._free=[],this._width=e,this._height=s,this._free.push(new P(0,0,e,s))}get width(){return this._width}get height(){return this._height}allocate(e,s){if(e>this._width||s>this._height)return new P;let t=null,r=-1;for(let o=0;o<this._free.length;++o){const a=this._free[o];e<=a.width&&s<=a.height&&(t===null||a.y<=t.y&&a.x<=t.x)&&(t=a,r=o)}return t===null?new P:(this._free.splice(r,1),t.width<t.height?(t.width>e&&this._free.push(new P(t.x+e,t.y,t.width-e,s)),t.height>s&&this._free.push(new P(t.x,t.y+s,t.width,t.height-s))):(t.width>e&&this._free.push(new P(t.x+e,t.y,t.width-e,t.height)),t.height>s&&this._free.push(new P(t.x,t.y+s,e,t.height-s))),new P(t.x,t.y,e,s))}release(e){for(let s=0;s<this._free.length;++s){const t=this._free[s];if(t.y===e.y&&t.height===e.height&&t.x+t.width===e.x)t.width+=e.width;else if(t.x===e.x&&t.width===e.width&&t.y+t.height===e.y)t.height+=e.height;else if(e.y===t.y&&e.height===t.height&&e.x+e.width===t.x)t.x=e.x,t.width+=e.width;else{if(e.x!==t.x||e.width!==t.width||e.y+e.height!==t.y)continue;t.y=e.y,t.height+=e.height}this._free.splice(s,1),this.release(e)}this._free.push(e)}}let ve=class{constructor(i,e,s){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=i,this.height=e,this._glyphSource=s,this._binPack=new H(i-4,e-4),this._glyphData.push(new Uint8Array(i*e)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(i,e){const s=[],t=this._glyphSource,r=new Set,o=1/256;for(const n of e){const l=Math.floor(n*o);r.add(l)}const a=[];return r.forEach(n=>{const l=i+n;if(this._rangePromises.has(l))a.push(this._rangePromises.get(l));else{const h=t.getRange(i,n).then(()=>{this._rangePromises.delete(l)},()=>{this._rangePromises.delete(l)});this._rangePromises.set(l,h),a.push(h)}}),Promise.all(a).then(()=>{let n=this._glyphIndex[i];n||(n={},this._glyphIndex[i]=n);for(const l of e){const h=n[l];if(h){s[l]={sdf:!0,rect:h.rect,metrics:h.metrics,page:h.page,code:l};continue}const c=t.getGlyph(i,l);if(!c?.metrics)continue;const u=c.metrics;let d;if(u.width===0)d=new P(0,0,0,0);else{const y=u.width+6,f=u.height+2*3;let p=y%4?4-y%4:4,_=f%4?4-f%4:4;p===1&&(p=5),_===1&&(_=5),d=this._binPack.allocate(y+p,f+_),d.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new H(this.width-4,this.height-4),d=this._binPack.allocate(y+p,f+_));const m=this._glyphData[this._currentPage],g=c.bitmap;let b,T;if(g)for(let S=0;S<f;S++){b=y*S,T=this.width*(d.y+S+1)+d.x;for(let w=0;w<y;w++)m[T+w+1]=g.at(b+w)}}n[l]={rect:d,metrics:u,tileIDs:null,page:this._currentPage},s[l]={sdf:!0,rect:d,metrics:u,page:this._currentPage,code:l},this._dirties[this._currentPage]=!0}return s})}removeGlyphs(i){for(const e in this._glyphIndex){const s=this._glyphIndex[e];if(!s)continue;let t;for(const r in s)if(t=s[r],t.tileIDs.delete(i),t.tileIDs.size===0){const o=this._glyphData[t.page],a=t.rect;let n,l;for(let h=0;h<a.height;h++)for(n=this.width*(a.y+h)+a.x,l=0;l<a.width;l++)o[n+l]=0;delete s[r],this._dirties[t.page]=!0}}}bind(i,e,s,t=0){if(!this._textures[s]){const o=new ye;o.pixelFormat=Ze.ALPHA,o.wrapMode=ce.CLAMP_TO_EDGE,o.width=this.width,o.height=this.height,this._textures[s]=new de(i,o,new Uint8Array(this.width*this.height))}const r=this._textures[s];r.setSamplingMode(e),this._dirties[s]&&r.setData(this._glyphData[s]),i.bindTexture(r,t),this._dirties[s]=!1}destroy(){this.dispose()}dispose(){this._glyphData.length=0,this._binPack=null;for(const i of this._textures)i&&i.dispose();this._textures.length=0}};class Z{constructor(e){if(this._metrics=[],!e)return void(this._allBitmaps=null);const s=new Map;let t=0;for(;e.next();)switch(e.tag()){case 1:{const a=e.getMessage();for(;a.next();)switch(a.tag()){case 3:{const n=a.getMessage();let l,h,c,u,d,y,f;for(;n.next();)switch(n.tag()){case 1:l=n.getUInt32();break;case 2:h=n.getBytes();break;case 3:c=n.getUInt32();break;case 4:u=n.getUInt32();break;case 5:d=n.getSInt32();break;case 6:y=n.getSInt32();break;case 7:f=n.getUInt32();break;default:n.skip()}if(n.release(),l){const p=h?.length??0;this._metrics[l]={width:c,height:u,left:d,top:y,advance:f,startOffset:t,length:p},s.set(l,h),t+=p}break}default:a.skip()}a.release();break}default:e.skip()}const r=new Uint8Array(t),o=this._metrics;for(const[a,n]of s){const{startOffset:l,length:h}=o[a];if(n)for(let c=0;c<h;++c)r[l+c]=n[c]}this._allBitmaps=r}getMetrics(e){return this._metrics[e]}getBitmap(e){if(!this._allBitmaps)return;const s=this._metrics[e];if(s===void 0)return;const{startOffset:t,length:r}=s;return r!==0?new Vt(this._allBitmaps,t,r):void 0}}let Et=class{constructor(){this._ranges=[]}get ranges(){return this._ranges}getRange(i){return this._ranges[i]}addRange(i,e){this._ranges[i]=e}},Ce=class{constructor(i){this._glyphInfo={},this._baseURL=i}getRange(i,e){const s=this._getFontStack(i);if(s.getRange(e))return Promise.resolve();const t=256*e,r=t+255;if(this._baseURL){const o=this._baseURL.replace("{fontstack}",i).replace("{range}",t+"-"+r);return Ee(o,{responseType:"array-buffer"}).then(a=>{s.addRange(e,new Z(new $(new Uint8Array(a.data),new DataView(a.data))))}).catch(()=>{s.addRange(e,new Z)})}return s.addRange(e,new Z),Promise.resolve()}getGlyph(i,e){const s=this._getFontStack(i);if(!s)return;const t=Math.floor(e/256),r=s.getRange(t);return r?{metrics:r.getMetrics(e),bitmap:r.getBitmap(e)}:void 0}_getFontStack(i){let e=this._glyphInfo[i];return e||(e=this._glyphInfo[i]=new Et),e}},Vt=class{constructor(i,e,s){this._array=i,this._start=e,this.length=s}at(i){return 0<=i&&i<this.length?this._array[this._start+i]:void 0}};const zt="dasharray-";class G{constructor(e,s,t=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,s<=0&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=e,this._pageHeight=s,t>0&&(this._maxItemSize=t),this._binPack=new H(e-4,s-4)}destroy(){this.dispose()}dispose(){this._binPack=null,this._mosaicsData.length=0,this._mosaicRects={};for(const e of this._textures)e&&e.dispose();this._textures.length=0}getWidth(e){return e>=this._size.length?-1:this._size[e][0]}getHeight(e){return e>=this._size.length?-1:this._size[e][1]}getPageSize(e){return e>=this._size.length?null:this._size[e]}setSpriteSource(e){if(this.dispose(),this.pixelRatio=e.devicePixelRatio,this._mosaicsData.length===0){this._binPack=new H(this._pageWidth-4,this._pageHeight-4);const s=Math.floor(this._pageWidth),t=Math.floor(this._pageHeight),r=new Uint32Array(s*t);this._mosaicsData[0]=r,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=e}getSpriteItem(e,s=!1){let t,r,o=this._mosaicRects[e];if(o)return o;if(!this._sprites||this._sprites.loadStatus!=="loaded"||(e&&e.startsWith(zt)?([t,r]=this._rasterizeDash(e),s=!0):t=this._sprites.getSpriteInfo(e),!t?.width||!t.height||t.width<0||t.height<0))return null;const a=t.width,n=t.height,[l,h,c]=this._allocateImage(a,n);return l.width<=0?null:(this._copy(l,t,h,c,s,r),o={type:"sprite",rect:l,width:a,height:n,sdf:t.sdf,simplePattern:!1,rasterizationScale:t.pixelRatio??1,samplingMode:"Linear",page:h},this._mosaicRects[e]=o,o)}getSpriteItems(e){const s={};for(const t of e)s[t.name]=this.getSpriteItem(t.name,t.repeat);return s}getMosaicItemPosition(e,s){const t=this.getSpriteItem(e,s),r=t?.rect;if(!r)return null;r.width=t.width,r.height=t.height;const o=t.width,a=t.height,n=2;return{tl:[r.x+n,r.y+n],br:[r.x+n+o,r.y+n+a],page:t.page}}bind(e,s,t=0,r=0){if(t>=this._size.length||t>=this._mosaicsData.length)return;if(!this._textures[t]){const a=new ye;a.wrapMode=ce.CLAMP_TO_EDGE,a.width=this._size[t][0],a.height=this._size[t][1],this._textures[t]=new de(e,a,new Uint8Array(this._mosaicsData[t].buffer))}const o=this._textures[t];o.setSamplingMode(s),this._dirties[t]&&o.setData(new Uint8Array(this._mosaicsData[t].buffer)),e.bindTexture(o,r),this._dirties[t]=!1}static _copyBits(e,s,t,r,o,a,n,l,h,c,u){let d=r*s+t,y=l*a+n;if(u){y-=a;for(let f=-1;f<=c;f++,d=((f+c)%c+r)*s+t,y+=a)for(let p=-1;p<=h;p++)o[y+p]=e[d+(p+h)%h]}else for(let f=0;f<c;f++){for(let p=0;p<h;p++)o[y+p]=e[d+p];d+=s,y+=a}}_copy(e,s,t,r,o,a){if(!this._sprites||this._sprites.loadStatus!=="loaded"||t>=this._mosaicsData.length)return;const n=new Uint32Array(a?a.buffer:this._sprites.image.buffer),l=this._mosaicsData[t],h=2,c=a?s.width:this._sprites.width;G._copyBits(n,c,s.x,s.y,l,r[0],e.x+h,e.y+h,s.width,s.height,o),this._dirties[t]=!0}_allocateImage(e,s){e+=2,s+=2;const t=Math.max(e,s);if(this._maxItemSize&&this._maxItemSize<t){const n=new P(0,0,e,s);return this._mosaicsData.push(new Uint32Array(e*s)),this._dirties.push(!0),this._size.push([e,s]),this._textures.push(void 0),[n,this._mosaicsData.length-1,[e,s]]}let r=e%4?4-e%4:4,o=s%4?4-s%4:4;r===1&&(r=5),o===1&&(o=5);const a=this._binPack.allocate(e+r,s+o);return a.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new H(this._pageWidth-4,this._pageHeight-4),this._allocateImage(e,s)):[a,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(e){const s=/\[(.*?)\]/,t=e.match(s);if(!t)return null;const r=t[1].split(",").map(Number),o=e.slice(e.lastIndexOf("-")+1),[a,n,l]=et(r,o);return[{x:0,y:0,width:n,height:l,sdf:!0,pixelRatio:1},new Uint8Array(a.buffer)]}}let Ft=class{constructor(i,e,s,t){this._layer=i,this._styleRepository=e,this.devicePixelRatio=s,this._sourceDataMaxLOD=t,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._spriteSourceAbortController=null,this._startOptionsInputSignal=null,this._inputSignalEventListener=null}destroy(){this._connection?.close(),this._connection=null,this._styleRepository=null,this._layer=null,this._spriteMosaic?.destroy(),this._spriteMosaic=null,this._glyphMosaic=null,this._spriteSourceAbortController=Ve(this._spriteSourceAbortController),this._spriteSourcePromise=null,this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,this._inputSignalEventListener=null}get spriteMosaic(){return this._spriteSourcePromise.then(()=>this._spriteMosaic)}get glyphMosaic(){return this._glyphMosaic}async start(i){this._requestSprite(i);const e=this._layer.currentStyleInfo.glyphsUrl,s=new Ce(e?ne(e,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new ve(1024,1024,s),this._broadcastPromise=je("WorkerTileHandler",{client:this,schedule:i.schedule,signal:i.signal}).then(t=>{if(this._layer&&(this._connection?.close(),this._connection=t,this._layer&&!this._connection.closed)){const r=t.broadcast("setStyle",{style:this._layer.currentStyleInfo.style,sourceDataMaxLOD:this._sourceDataMaxLOD},i);Promise.all(r).catch(o=>ze(o))}})}_requestSprite(i){this._spriteSourceAbortController?.abort();const e=new AbortController;this._spriteSourceAbortController=e;const s=i?.signal;this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,s&&(this._inputSignalEventListener=Ht(e),s.addEventListener("abort",this._inputSignalEventListener,{once:!0}));const{signal:t}=e,r={...i,signal:t};this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,r),this._spriteSourcePromise.then(o=>{Fe(t),this._spriteMosaic=new G(1024,1024,250),this._spriteMosaic.setSpriteSource(o)})}async updateStyle(i){const e=[];for(const s of i)s.type===x.SPRITES_CHANGED?e.push({type:x.SPRITES_CHANGED,data:{spriteSource:null}}):e.push(s);return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",e)),this._broadcastPromise}setSpriteSource(i){const e=new G(1024,1024,250);return e.setSpriteSource(i),this._spriteMosaic=e,this._spriteSourcePromise=Promise.resolve(i),this._spriteSourceAbortController=null,e}async setStyle(i,e,s){await this._broadcastPromise,this._styleRepository=i,this._sourceDataMaxLOD=s,this._requestSprite();const t=new Ce(this._layer.currentStyleInfo.glyphsUrl?ne(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);return this._glyphMosaic=new ve(1024,1024,t),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",{style:e,sourceDataMaxLOD:this._sourceDataMaxLOD})),this._broadcastPromise}async fetchTileData(i,e){const s=await this._getRefKeys(i,e);return this._getSourcesData(Object.keys(this._layer.sourceNameToSource),s,e)}async fetchTilePBFs(i){const e=Object.keys(this._layer.sourceNameToSource),s={},t=await this._getRefKeys(i,s),r=[],o=[];for(let a=0;a<t.length;a++)if(t[a].value==null||e[a]==null)o.push(null);else{const n=t[a].value,l=this._getTilePayload(n,e[a],s);l.then(h=>{r.push({...h,key:n})}),o.push(l)}return Promise.all(o).then(()=>r)}async parseTileData(i,e){const s=i&&i.data;if(!s)return null;const{sourceName2DataAndRefKey:t,transferList:r}=s;return Object.keys(t).length===0?null:this._broadcastPromise.then(()=>this._connection.invoke("createTileAndParse",{key:i.key.id,sourceName2DataAndRefKey:t,styleLayerUIDs:i.styleLayerUIDs},{...e,transferList:r}))}async getSprites(i){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(i)}getGlyphs(i){return this._glyphMosaic.getGlyphItems(i.font,i.codePoints)}async _getTilePayload(i,e,s){const t=A.pool.acquire(i.id),r=this._layer.sourceNameToSource[e],{level:o,row:a,col:n}=t;A.pool.release(t);try{return{protobuff:await r.requestTile(o,a,n,s),sourceName:e}}catch(l){if(Y(l))throw l;return{protobuff:null,sourceName:e}}}async _getRefKeys(i,e){const s=this._layer.sourceNameToSource,t=new Array;for(const r in s){const o=s[r].getRefKey(i,e);t.push(o)}return ae(t)}_getSourcesData(i,e,s){const t=[];for(let r=0;r<e.length;r++)if(e[r].value==null||i[r]==null)t.push(null);else{const o=e[r].value,a=this._getTilePayload(o,i[r],s);t.push(a)}return ae(t).then(r=>{const o={},a=[];for(let n=0;n<r.length;n++){const l=r[n].value;if(l&&l.protobuff&&l.protobuff.byteLength>0){const h=e[n].value.id;o[l.sourceName]={refKey:h,protobuff:l.protobuff},a.push(l.protobuff)}}return{sourceName2DataAndRefKey:o,transferList:a}})}};function Ht(i){return()=>i.abort()}const De=512,qt=1e-6,Bt=(i,e)=>i+1/(1<<2*e);let Me=class{constructor(i,e){this._tiles=new Map,this._tileCache=new st(40,s=>s.dispose()),this._viewSize=[0,0],this._visibleTiles=new Map,this.acquireTile=i.acquireTile,this.releaseTile=i.releaseTile,this.tileInfoView=i.tileInfoView,this._container=e}destroy(){for(const i of this._tiles.values())i.dispose();this._tiles=null,this._tileCache.clear(),this._tileCache=null}update(i){this._updateCacheSize(i);const e=this.tileInfoView,s=e.getTileCoverage(i.state,0,!0,"smallest");if(!s)return!0;const{spans:t,lodInfo:r}=s,{level:o}=r,a=this._tiles,n=new Set,l=new Set;for(const{row:c,colFrom:u,colTo:d}of t)for(let y=u;y<=d;y++){const f=A.getId(o,c,r.normalizeCol(y),r.getWorldForColumn(y)),p=this._getOrAcquireTile(f);n.add(f),p.processed()?this._addToContainer(p):l.add(new A(f))}for(const[c,u]of a)u.isCoverage=n.has(c);for(const c of l)this._findPlaceholdersForMissingTiles(c,n);let h=!1;for(const[c,u]of a)u.neededForCoverage=n.has(c),u.neededForCoverage||u.isHoldingForFade&&e.intersects(s,u.key)&&n.add(c),u.isFading&&(h=!0);for(const c of this._tiles.keys())n.has(c)||this._releaseTile(c);return _e.pool.release(s),!h}clear(){this._tiles.clear(),this._tileCache.clear(),this._visibleTiles.clear()}clearCache(){this._tileCache.clear()}getIntersectingTiles(i,e,s,t,r){const o=[0,0],a=[0,0];t.toMap(o,i-s,e+s),t.toMap(a,i+s,e-s);const n=Math.min(o[0],a[0]),l=Math.min(o[1],a[1]),h=Math.max(o[0],a[0]),c=Math.max(o[1],a[1]),u=He(n,l,h,c),d=V(),y=[];for(const f of this._visibleTiles.values())this.tileInfoView.getTileBounds(d,f.key),qe(u,d)&&y.push(f);if(r!=null&&r.length>0){const f=new Set(y.map(_=>_.id)),p=r.filter(_=>!f.has(_.tileKey.id)).map(_=>this._visibleTiles.get(_.tileKey.id)).filter(_=>_!==void 0);y.push(...p)}return y}_findPlaceholdersForMissingTiles(i,e){const s=[];for(const r of this._tiles.values())this._addPlaceholderChild(s,r,i,e);const t=s.reduce(Bt,0);Math.abs(1-t)<qt||this._addPlaceholderParent(i.id,e)}_addPlaceholderChild(i,e,s,t){e.key.level<=s.level||!e.hasData()||Qt(s,e.key)&&(this._addToContainer(e),t.add(e.id),i.push(e.key.level-s.level))}_addPlaceholderParent(i,e){const s=this._tiles;let t=i;for(;;){if(t=Nt(t),!t||e.has(t))return;const r=s.get(t);if(r?.hasData())return this._addToContainer(r),void e.add(r.id)}}_getOrAcquireTile(i){let e=this._tiles.get(i);return e||(e=this._tileCache.pop(i),e||(e=this.acquireTile(new A(i))),this._tiles.set(i,e),e)}_releaseTile(i){const e=this._tiles.get(i);this.releaseTile(e),this._removeFromContainer(e),this._tiles.delete(i),e.hasData()?this._tileCache.put(i,e,1):e.dispose()}_addToContainer(i){let e;const s=[],t=this._container;if(t.contains(i))return;const r=this._visibleTiles;for(const o of r.values())this._canConnectDirectly(i,o)&&s.push(o),e==null&&this._canConnectDirectly(o,i)&&(e=o);if(e!=null){for(const o of s)e.childrenTiles.delete(o),i.childrenTiles.add(o),o.parentTile=i;e.childrenTiles.add(i),i.parentTile=e}else for(const o of s)i.childrenTiles.add(o),o.parentTile=i;r.set(i.id,i),t.addChild(i)}_removeFromContainer(i){if(this._visibleTiles.delete(i.id),this._container.removeChild(i),i.parentTile!=null){i.parentTile.childrenTiles.delete(i);for(const e of i.childrenTiles)i.parentTile!=null&&i.parentTile.childrenTiles.add(e)}for(const e of i.childrenTiles)e.parentTile=i.parentTile;i.parentTile=null,i.childrenTiles.clear()}_canConnectDirectly(i,e){const s=i.key;let{level:t,row:r,col:o,world:a}=e.key;const n=this._visibleTiles;for(;t>0;){if(t--,r>>=1,o>>=1,s.level===t&&s.row===r&&s.col===o&&s.world===a)return!0;if(n.has(`${t}/${r}/${o}/${a}`))return!1}return!1}_updateCacheSize(i){const e=i.state.size;if(e[0]===this._viewSize[0]&&e[1]===this._viewSize[1])return;const s=Math.ceil(e[0]/De)+1,t=Math.ceil(e[1]/De)+1;this._viewSize[0]=e[0],this._viewSize[1]=e[1],this._tileCache.maxSize=5*s*t}};function Nt(i){const[e,s,t,r]=i.split("/"),o=parseInt(e,10);return o===0?null:`${o-1}/${parseInt(s,10)>>1}/${parseInt(t,10)>>1}/${parseInt(r,10)}`}function Qt(i,e){const s=e.level-i.level;return i.row===e.row>>s&&i.col===e.col>>s&&i.world===e.world}let W=class{constructor(i,e){this.layerUIDs=[],this.isDestroyed=!1,this._data=i;let s=1;const t=new Uint32Array(i);this.layerUIDs=[];const r=t[s++];for(let o=0;o<r;o++)this.layerUIDs[o]=t[s++];this.bufferDataOffset=s,e&&(this.layer=e.getStyleLayerByUID(this.layerUIDs[0]))}get isPreparedForRendering(){return this._data==null}get offset(){return this.bufferDataOffset}get data(){return this._data}destroy(){this.isDestroyed||(this.doDestroy(),this._data=null,this.isDestroyed=!0)}prepareForRendering(i){this._data!=null&&(this.doPrepareForRendering(i,this._data,this.bufferDataOffset),this._data=null)}},Wt=class extends W{constructor(i,e){super(i,e),this.type=M.LINE,this.lineIndexStart=0,this.lineIndexCount=0;const s=new Uint32Array(i);let t=this.bufferDataOffset;this.lineIndexStart=s[t++],this.lineIndexCount=s[t++];const r=s[t++];if(r>0){this.patternMap=new Map;for(let o=0;o<r;o++){const a=s[t++],n=s[t++],l=s[t++];this.patternMap.set(a,[n,l])}}this.bufferDataOffset=t}get usedMemory(){return(this.data?.byteLength??0)+(this.vao?.cachedMemory??0)}hasData(){return this.lineIndexCount>0}triangleCount(){return this.lineIndexCount/3}doDestroy(){this.vao=O(this.vao)}doPrepareForRendering(i,e,s){const t=new Uint32Array(e),r=new Int32Array(t.buffer),o=t[s++],a=C.createVertex(i,v.STATIC_DRAW,new Int32Array(r.buffer,4*s,o));s+=o;const n=t[s++],l=C.createIndex(i,v.STATIC_DRAW,new Uint32Array(t.buffer,4*s,n));s+=n;const h=this.layer.lineMaterial;this.vao=new U(i,h.getAttributeLocations(),h.getLayoutInfo(),new Map([["geometry",a]]),l)}};class Jt extends W{constructor(e,s){super(e,s),this.type=M.FILL,this.fillIndexStart=0,this.fillIndexCount=0,this.outlineIndexStart=0,this.outlineIndexCount=0;const t=new Uint32Array(e);let r=this.bufferDataOffset;this.fillIndexStart=t[r++],this.fillIndexCount=t[r++],this.outlineIndexStart=t[r++],this.outlineIndexCount=t[r++];const o=t[r++];if(o>0){this.patternMap=new Map;for(let a=0;a<o;a++){const n=t[r++],l=t[r++],h=t[r++];this.patternMap.set(n,[l,h])}}this.bufferDataOffset=r}get usedMemory(){return(this.data?.byteLength??0)+(this.fillVAO?.cachedMemory??0)+(this.outlineVAO?.cachedMemory??0)}hasData(){return this.fillIndexCount>0||this.outlineIndexCount>0}triangleCount(){return(this.fillIndexCount+this.outlineIndexCount)/3}doDestroy(){this.fillVAO=O(this.fillVAO),this.outlineVAO=O(this.outlineVAO)}doPrepareForRendering(e,s,t){const r=new Uint32Array(s),o=new Int32Array(r.buffer),a=r[t++],n=C.createVertex(e,v.STATIC_DRAW,new Int32Array(o.buffer,4*t,a));t+=a;const l=r[t++],h=C.createIndex(e,v.STATIC_DRAW,new Uint32Array(r.buffer,4*t,l));t+=l;const c=r[t++],u=C.createVertex(e,v.STATIC_DRAW,new Int32Array(o.buffer,4*t,c));t+=c;const d=r[t++],y=C.createIndex(e,v.STATIC_DRAW,new Uint32Array(r.buffer,4*t,d));t+=d;const f=this.layer,p=f.fillMaterial,_=f.outlineMaterial;this.fillVAO=new U(e,p.getAttributeLocations(),p.getLayoutInfo(),new Map([["geometry",n]]),h),this.outlineVAO=new U(e,_.getAttributeLocations(),_.getLayoutInfo(),new Map([["geometry",u]]),y)}}class Kt extends W{constructor(e,s,t){super(e,s),this.type=M.SYMBOL,this.iconPerPageElementsMap=new Map,this.glyphPerPageElementsMap=new Map,this.symbolInstances=[],this.isIconSDF=!1,this.opacityChanged=!1,this.lastOpacityUpdate=0,this.symbols=[];const r=new Uint32Array(e),o=new Int32Array(e),a=new Float32Array(e);let n=this.bufferDataOffset;this.isIconSDF=!!r[n++];const l=r[n++],h=r[n++],c=r[n++],u=new A(l,h,c,0),d=r[n++];for(let _=0;_<d;_++){const m=r[n++],g=r[n++],b=r[n++];this.iconPerPageElementsMap.set(m,[g,b])}const y=r[n++];for(let _=0;_<y;_++){const m=r[n++],g=r[n++],b=r[n++];this.glyphPerPageElementsMap.set(m,[g,b])}const f=r[n++],p=r[n++];this.iconOpacity=new Int32Array(f),this.textOpacity=new Int32Array(p),n=St(r,o,a,n,this.symbols,t,u),this.bufferDataOffset=n}get usedMemory(){return(this.data?.byteLength??0)+(this.iconVAO?.cachedMemory??0)+(this.textVAO?.cachedMemory??0)+pe(this.iconOpacity)+pe(this.textOpacity)}hasData(){return this.iconPerPageElementsMap.size>0||this.glyphPerPageElementsMap.size>0}triangleCount(){let e=0;for(const s of this.iconPerPageElementsMap.values())e+=s[1];for(const s of this.glyphPerPageElementsMap.values())e+=s[1];return e/3}doDestroy(){this.iconVAO=O(this.iconVAO),this.textVAO=O(this.textVAO)}updateOpacityInfo(){if(!this.opacityChanged)return;this.opacityChanged=!1;const e=this.iconOpacity,s=this.iconVAO.vertexBuffers.get("opacity");e.length>0&&e.byteLength===s.usedMemory&&s.setSubData(e,0,0,e.length);const t=this.textOpacity,r=this.textVAO.vertexBuffers.get("opacity");t.length>0&&t.byteLength===r.usedMemory&&r.setSubData(t,0,0,t.length)}doPrepareForRendering(e,s,t){const r=new Uint32Array(s),o=new Int32Array(r.buffer),a=r[t++],n=C.createVertex(e,v.STATIC_DRAW,new Int32Array(o.buffer,4*t,a));t+=a;const l=r[t++],h=C.createIndex(e,v.STATIC_DRAW,new Uint32Array(r.buffer,4*t,l));t+=l;const c=r[t++],u=C.createVertex(e,v.STATIC_DRAW,new Int32Array(o.buffer,4*t,c));t+=c;const d=r[t++],y=C.createIndex(e,v.STATIC_DRAW,new Uint32Array(r.buffer,4*t,d));t+=d;const f=C.createVertex(e,v.STATIC_DRAW,this.iconOpacity.buffer),p=C.createVertex(e,v.STATIC_DRAW,this.textOpacity.buffer),_=this.layer,m=_.iconMaterial,g=_.textMaterial;this.iconVAO=new U(e,m.getAttributeLocations(),m.getLayoutInfo(),new Map([["geometry",n],["opacity",f]]),h),this.textVAO=new U(e,g.getAttributeLocations(),g.getLayoutInfo(),new Map([["geometry",u],["opacity",p]]),y)}}let Gt=class extends W{constructor(i,e){super(i,e),this.type=M.CIRCLE,this.circleIndexStart=0,this.circleIndexCount=0;const s=new Uint32Array(i);let t=this.bufferDataOffset;this.circleIndexStart=s[t++],this.circleIndexCount=s[t++],this.bufferDataOffset=t}get usedMemory(){return(this.data?.byteLength??0)+(this.vao?.cachedMemory??0)}hasData(){return this.circleIndexCount>0}triangleCount(){return this.circleIndexCount/3}doDestroy(){this.vao=O(this.vao)}doPrepareForRendering(i,e,s){const t=new Uint32Array(e),r=new Int32Array(t.buffer),o=t[s++],a=C.createVertex(i,v.STATIC_DRAW,new Int32Array(r.buffer,4*s,o));s+=o;const n=t[s++],l=C.createIndex(i,v.STATIC_DRAW,new Uint32Array(t.buffer,4*s,n));s+=n;const h=this.layer.circleMaterial;this.vao=new U(i,h.getAttributeLocations(),h.getLayoutInfo(),new Map([["geometry",a]]),l)}},Yt=class Ue extends ge{constructor(e,s,t,r,o,a,n,l=null){super(e,s,t,r,o,a,4096,4096),this.styleRepository=n,this._memCache=l,this.type="vector-tile",this._referenced=1,this._hasSymbolBuckets=!1,this._usedMemory=256,this.layerData=new Map,this.status="loading",this.allSymbolsFadingOut=!1,this.lastOpacityUpdate=0,this.symbols=new Map,this.isCoverage=!1,this.neededForCoverage=!1,this.decluttered=!1,this.parentTile=null,this.childrenTiles=new Set,this.featureIndex=null,this.triangleCount=0,this._processed=!1,this.id=e.id}get hasSymbolBuckets(){return this._hasSymbolBuckets}get isFading(){return this._hasSymbolBuckets&&performance.now()-this.lastOpacityUpdate<Q}get isHoldingForFade(){return this._hasSymbolBuckets&&(!this.allSymbolsFadingOut||performance.now()-this.lastOpacityUpdate<Q)}get wasRequested(){return this.status==="errored"||this.status==="loaded"||this.status==="reloading"}setData(e){this.changeDataImpl(e),this.requestRender(),this.ready(),this._processed=!0}deleteLayerData(e){let s=!1;for(const t of e){const r=this.layerData.get(t);r&&(this._usedMemory-=r.usedMemory,r.type===M.SYMBOL&&this.symbols.delete(t)&&(s=!0),r.destroy(),this.layerData.delete(t))}this._memCache?.updateSize(this.key.id,this),s&&(this.featureIndex?.clear(),this.emit("symbols-changed")),this.requestRender()}processed(){return this._processed}hasData(){return this.layerData.size>0}hasFeatures(){const e=this.layerData.values();for(const s of e)if(s.hasData())return!0;return!1}dispose(){this.status!=="unloaded"&&(Ue._destroyRenderBuckets(this.layerData),this.layerData.clear(),this.featureIndex=null,this._usedMemory=0,this.destroy(),this.status="unloaded")}release(){--this._referenced==0&&(this.dispose(),this.stage=null)}retain(){++this._referenced}get cachedMemory(){return this._usedMemory}get usedMemory(){return this._usedMemory}get usedMemoryPerReference(){return this._usedMemory/(this._referenced||1)}changeDataImpl(e){this.featureIndex?.clear();let s=!1;if(e){const{bucketsWithData:t,emptyBuckets:r}=e,o=this._createRenderBuckets(t);if(r&&r.byteLength>0){const a=new Uint32Array(r);for(const n of a)this._deleteLayerData(n)}for(const[a,n]of o)this._deleteLayerData(a),n.type===M.SYMBOL&&(this.symbols.set(a,n.symbols),s=!0),this._usedMemory+=n.usedMemory,this.layerData.set(a,n);this._memCache?.updateSize(this.key.id,this)}this._hasSymbolBuckets=!1;for(const t of this.layerData.values())t.type===M.SYMBOL&&(this._hasSymbolBuckets=!0);s&&this.emit("symbols-changed")}attachWithContext(e){this.stage={context:e,trashDisplayObject(s){s.processDetach()},untrashDisplayObject:()=>!1}}setTransform(e){super.setTransform(e);const s=this.resolution/(e.resolution*e.pixelRatio),t=this.width/this.rangeX*s,r=this.height/this.rangeY*s,o=[0,0];e.toScreen(o,[this.x,this.y]);const a=this.transforms.tileUnitsToPixels;it(a),rt(a,a,o),ot(a,a,Math.PI*e.rotation/180),nt(a,a,[t,r,1])}_createTransforms(){return{displayViewScreenMat3:F(),tileMat3:F(),tileUnitsToPixels:F()}}static _destroyRenderBuckets(e){if(!e)return;const s=new Set;for(const t of e.values())s.has(t)||(t.destroy(),s.add(t));e.clear()}_createRenderBuckets(e){const s=new Map,t=new Map;for(const r of e){const o=this._deserializeBucket(r,t);for(const a of o.layerUIDs)s.set(a,o)}return s}_deserializeBucket(e,s){let t=s.get(e);if(t)return t;switch(new Uint32Array(e)[0]){case M.FILL:t=new Jt(e,this.styleRepository);break;case M.LINE:t=new Wt(e,this.styleRepository);break;case M.SYMBOL:t=new Kt(e,this.styleRepository,this);break;case M.CIRCLE:t=new Gt(e,this.styleRepository)}return s.set(e,t),t}_deleteLayerData(e){if(!this.layerData.has(e))return;const s=this.layerData.get(e);this._usedMemory-=s.usedMemory,s.destroy(),this.layerData.delete(e)}};const jt=.5,Re=1e-6;class $t{constructor(e,s){this.styleRepository=e,this._tileToHandle=new Map,this._viewState={scale:0,rotation:0,center:[0,0],size:[0,0]},this._declutterViewState={scale:0,rotation:0,center:[0,0],size:[0,0]},this._offsetFromScreenCenter=[0,0],this._completed=!1,this._fading=yt(!1),this._symbolRepository=new kt(4096,s,()=>new wt),this._symbolDeclutterer=new Mt(s,this._symbolRepository,(t,r,o)=>this._createCollisionJob(t,r,o),(t,r)=>{t.allSymbolsFadingOut=!0,t.lastOpacityUpdate=r,xt(t,r,!0),t.decluttered=!0,t.requestRender()},(t,r)=>this.styleRepository.getStyleLayerByUID(t.styleLayerUID).z-this.styleRepository.getStyleLayerByUID(r.styleLayerUID).z,t=>{const r=this.styleRepository.getStyleLayerByUID(t);if(this._zoom+Re<r.minzoom||this._zoom-Re>=r.maxzoom)return!1;const o=r.getLayoutProperty("visibility");return!o||o.getValue()!==X.NONE})}get symbolRepository(){return this._symbolRepository}_createCollisionJob(e,s,t){return this.updateDecluttererViewState(),new Ct(e,s,t,this.styleRepository,this._zoom,this._viewState.rotation)}get fading(){return this._fading.value}get decluttererOffset(){return this._offsetFromScreenCenter}addTile(e){e.decluttered=!1,this._tileToHandle.set(e,e.on("symbols-changed",()=>{this._symbolRepository.add(e),this.restartDeclutter()})),this._symbolRepository.add(e),this.restartDeclutter()}removeTile(e){const s=this._tileToHandle.get(e);s&&(this._symbolRepository.removeTile(e),this.restartDeclutter(),s.remove(),this._tileToHandle.delete(e))}update(e,s){this._zoom=e,this._viewState={scale:s.scale,rotation:s.rotation,center:[s.center[0],s.center[1]],size:[s.size[0],s.size[1]]};const t=[0,0];s.toScreen(t,s.center);const r=[0,0];return s.toScreen(r,this._declutterViewState.center),this._offsetFromScreenCenter[0]=t[0]-r[0],this._offsetFromScreenCenter[1]=t[1]-r[1],this._continueDeclutter(),this._completed}restartDeclutter(){this._completed=!1,this._symbolDeclutterer.restart(),this._notifyUnstable()}clear(){this._completed=!1,this._symbolRepository=null,this._symbolDeclutterer.restart(),this._tileToHandle.forEach(e=>e.remove()),this._tileToHandle.clear()}get stale(){return this._zoom!==this._declutterZoom||this._viewState.size[0]!==this._declutterViewState.size[0]||this._viewState.size[1]!==this._declutterViewState.size[1]||this._viewState.scale!==this._declutterViewState.scale||this._viewState.rotation!==this._declutterViewState.rotation}deleteStyleLayers(e){this._symbolRepository.deleteStyleLayers(e)}_continueDeclutter(){this._completed&&!this.stale||(this._symbolDeclutterer.running||(this.updateDecluttererViewState(),this._symbolDeclutterer.restart()),this._symbolDeclutterer.setScreenSize(this._viewState.size[0],this._viewState.size[1]),this._completed=this._symbolDeclutterer.continue(ut),this._completed&&this._scheduleNotifyStable())}_scheduleNotifyStable(){this._stableNotificationHandle!=null&&clearTimeout(this._stableNotificationHandle),this._stableNotificationHandle=setTimeout(()=>{this._stableNotificationHandle=null,this._fading.value=!1},(1+jt)*Q)}_notifyUnstable(){this._stableNotificationHandle!=null&&(clearTimeout(this._stableNotificationHandle),this._stableNotificationHandle=null),this._fading.value=!0}updateDecluttererViewState(){this._declutterZoom=this._zoom,this._declutterViewState.center[0]=this._viewState.center[0],this._declutterViewState.center[1]=this._viewState.center[1],this._declutterViewState.rotation=this._viewState.rotation,this._declutterViewState.scale=this._viewState.scale,this._declutterViewState.size[0]=this._viewState.size[0],this._declutterViewState.size[1]=this._viewState.size[1],this._offsetFromScreenCenter[0]=0,this._offsetFromScreenCenter[1]=0}}const J=1e-6;function Pe(i,e){if(i){const s=i.getLayoutProperty("visibility");if(!s||s.getValue()!==X.NONE&&(i.minzoom===void 0||i.minzoom<e+J)&&(i.maxzoom===void 0||i.maxzoom>=e-J))return!0}return!1}let Xt=class extends dt{constructor(i){super(i),this._backgroundTiles=[],this._computeDisplayInfoView(i)}destroy(){this.removeAllChildren(),this._spriteMosaic?.dispose(),this._spriteMosaic=null,this._glyphMosaic?.dispose(),this._glyphMosaic=null,this._symbolFader!=null&&(this._symbolFader.clear(),this._symbolFader=null),this._styleRepository=null,this._backgroundTiles=[]}get fading(){return this._symbolFader?.fading??!1}get symbolFader(){return this._symbolFader}get symbolRepository(){return this._symbolFader?.symbolRepository}setStyleResources(i,e,s,t){this._spriteMosaic=i,this._glyphMosaic=e,this._styleRepository=s,this.tileInfoView=t,this._computeDisplayInfoView(t),this._symbolFader==null&&(this._symbolFader=new $t(this._styleRepository,this.children)),this._symbolFader.styleRepository=s}setSpriteMosaic(i){this._spriteMosaic?.dispose(),this._spriteMosaic=i}deleteStyleLayers(i){this._symbolFader!=null&&this._symbolFader.deleteStyleLayers(i)}createRenderParams(i){return{...super.createRenderParams(i),renderPass:null,styleLayer:null,styleLayerUID:-1,glyphMosaic:this._glyphMosaic,spriteMosaic:this._spriteMosaic,hasClipping:!!this._clippingInfos}}doRender(i){!this.visible||i.drawPhase!==N.MAP&&i.drawPhase!==N.DEBUG||this._spriteMosaic===void 0||super.doRender(i)}addChild(i){return super.addChild(i),this._symbolFader!=null?this._symbolFader.addTile(i):i.decluttered=!0,this.requestRender(),i}removeChild(i){return this._symbolFader!=null&&this._symbolFader.removeTile(i),this.requestRender(),super.removeChild(i)}renderChildren(i){const{drawPhase:e}=i;e!==N.DEBUG?this._doRender(i):super.renderChildren(i)}removeAllChildren(){for(let i=0;i<this.children.length;i++){const e=this.children[i];this._symbolFader!=null&&this._symbolFader.removeTile(e),e.dispose()}super.removeAllChildren()}getStencilTarget(){return this.children.filter(i=>i.neededForCoverage&&i.hasData())}restartDeclutter(){this._symbolFader!=null&&this._symbolFader.restartDeclutter()}_doRender(i){const{context:e,state:s}=i,t=this._styleRepository;if(!t)return;const r=t.layers,o=this._displayInfo.scaleToZoom(s.scale);t.backgroundBucketIds.length>0&&(i.renderPass="background",this._renderBackgroundLayers(i,t.backgroundBucketIds,o)),super.renderChildren(i),i.drawPhase===N.MAP&&this._fade(o,s);const a=this.children.filter(n=>n.visible&&n.hasData());if(!a||a.length===0)return e.bindVAO(),e.setStencilTestEnabled(!0),void e.setBlendingEnabled(!0);for(const n of a)n.triangleCount=0;e.setStencilWriteMask(0),e.setColorMask(!0,!0,!0,!0),e.setStencilOp(k.KEEP,k.KEEP,k.REPLACE),e.setStencilTestEnabled(!0),e.setBlendingEnabled(!1),e.setDepthTestEnabled(!0),e.setDepthWriteEnabled(!0),e.setDepthFunction(ue.LEQUAL),e.setClearDepth(1),e.clear(e.gl.DEPTH_BUFFER_BIT),i.renderPass="opaque";for(let n=r.length-1;n>=0;n--)this._renderStyleLayer(r[n],i,a);e.setDepthWriteEnabled(!1),e.setBlendingEnabled(!0),e.setBlendFunctionSeparate(B.ONE,B.ONE_MINUS_SRC_ALPHA,B.ONE,B.ONE_MINUS_SRC_ALPHA),i.renderPass="translucent";for(let n=0;n<r.length;n++)this._renderStyleLayer(r[n],i,a);e.bindVAO(),e.setStencilTestEnabled(!0),e.setBlendingEnabled(!0);for(const n of a)n.debugInfo.display.triangleCount=n.triangleCount}_fade(i,e){this._symbolFader!=null&&(this._symbolFader.update(i,e)||this.requestRender())}_renderStyleLayer(i,e,s){const{displayLevel:t,painter:r,renderPass:o}=e;if(i===void 0)return;const a=i.getLayoutProperty("visibility");if(a&&a.getValue()===X.NONE)return;let n;switch(i.type){case D.BACKGROUND:return;case D.FILL:if(o!=="opaque"&&e.renderPass!=="translucent")return;n="vtlFill";break;case D.LINE:if(o!=="translucent")return;n="vtlLine";break;case D.CIRCLE:if(o!=="translucent")return;n="vtlCircle";break;case D.SYMBOL:if(o!=="translucent")return;n="vtlSymbol"}if(s=i.type===D.SYMBOL?s.filter(h=>h.decluttered):s.filter(h=>h.neededForCoverage),n!=="vtlSymbol"&&(s.length===0||i.minzoom!==void 0&&i.minzoom>=t+J||i.maxzoom!==void 0&&i.maxzoom<t-J))return;const l=i.uid;e.styleLayerUID=l,e.styleLayer=i;for(const h of s)if(h.layerData.has(l)){r.renderObjects(e,s,n);break}}_renderBackgroundLayers(i,e,s){const{context:t,painter:r,state:o}=i,a=this._styleRepository;let n=!1;for(const g of e)if(a.getLayerById(g).type===D.BACKGROUND&&Pe(a.getLayerById(g),s)){n=!0;break}if(!n)return;const l=this.tileInfoView,h=l.getTileCoverage(i.state,0,!0,"smallest"),{spans:c,lodInfo:u}=h,{level:d}=u,y=V(),f=[];if(this._renderPasses){const g=this._renderPasses[0];this._clippingInfos!=null&&(g.brushes[0].prepareState(i),g.brushes[0].drawMany(i,this._clippingInfos))}const p=this._backgroundTiles;let _,m=0;for(const{row:g,colFrom:b,colTo:T}of c)for(let S=b;S<=T;S++){if(m<p.length)_=p[m],_.key.set(d,g,u.normalizeCol(S),u.getWorldForColumn(S)),l.getTileBounds(y,_.key,!1),_.x=y[0],_.y=y[3],_.resolution=l.getTileResolution(d);else{const w=new A(d,g,u.normalizeCol(S),u.getWorldForColumn(S)),R=l.getTileBounds(V(),w),E=l.getTileResolution(d);_=new Ut(w,E,R[0],R[3],512,512,4096,4096),p.push(_)}_.setTransform(o),f.push(_),m++}t.setStencilWriteMask(0),t.setColorMask(!0,!0,!0,!0),t.setStencilOp(k.KEEP,k.KEEP,k.REPLACE),t.setStencilFunction(ue.EQUAL,0,255),t.setStencilTestEnabled(!0);for(const g of e){const b=a.getLayerById(g);b.type===D.BACKGROUND&&Pe(b,s)&&(i.styleLayerUID=b.uid,i.styleLayer=b,r.renderObjects(i,f,"vtlBackground"))}_e.pool.release(h)}_computeDisplayInfoView(i){let e=i.tileInfo.lods[0].scale;const s=Math.max(25,i.tileInfo.lods.length),t=[];for(let r=0;r<=s;r++)t.push(e),e/=2;this._displayInfo=me.create({scales:t,size:512,spatialReference:i.spatialReference,numLODs:s})}};const Zt=8,es=512,Ae=4096,ts=(i,e)=>{const s=i.vtlSymbol.sourceTile,t=e.vtlSymbol.sourceTile;return s.level!==t.level?s.level-t.level:s.row!==t.row?s.row-t.row:s.col!==t.col?s.col-t.col:i.styleLayerUID-e.styleLayerUID};class te{constructor(e,s,t,r,o){this.tileKey=e,this._tileLayerData=s,this._styleRepository=t,this._tileHandler=r,this._parentLayer=o,this._index=null,this._tileKeyToPBF=new Map}static create(e,s,t,r,o){return new te(e,s,t,r,o)}clear(){this._index?.clear(),this._tileKeyToPBF.clear()}async queryAttributes(e,s,t,r,o){if(this._tileLayerData.size===0||!this._styleRepository||!this._tileHandler)return[];this._index===null&&(this._index=new _t(100,ss),await this._indexLayers());const a=[];return this._queryIndex(a,e,s,t,this.tileKey.level,r),o&&o?.length>0&&await this._getSymbolsAttributes(a,o),a}async _indexLayers(){const e=this.tileKey,s=this._styleRepository.layers,t=await this._getTilePayload(e);for(const[r,o]of this._tileLayerData){const a=s[r],n=t.find(c=>c.sourceName===a.source);if(!n)continue;const{protobuff:l,key:h}=n;if(o.type!==M.SYMBOL){const c=1<<e.level-h.level,u=e.row-h.row*c,d=e.col-h.col*c;this._indexLayer(a,l,e.level,c,u,d)}}}_indexLayer(e,s,t,r,o,a){const n=e.sourceLayer,l=e.getFeatureFilter(),h=t,c=t+1,u=Xe(h),d=new $(new Uint8Array(s),new DataView(s));for(;d.next();)switch(d.tag()){case 3:{const y=d.getMessage(),f=new be(y);if(y.release(),f.name!==n)continue;const p=f.getData(),_=f.extent/r,m=_*a-u,g=_*o-u,b=m+_+2*u,T=g+_+2*u,S=_/es,w=Ae/_,R=_*a,E=_*o;for(;p.nextTag(2);){const se=p.getMessage(),q=new we(se,f);if(se.release(),l&&!l.filter(q,t))continue;const ie=q.values||{},re=ie._minzoom,oe=ie._maxzoom;if(re&&re>=10*c||oe&&oe<=10*h)continue;const I=e.getFeatureInflatedBounds(q,h,f.extent,S);I==null||I[0]>b||I[1]>T||I[2]<m||I[3]<g||(I[0]=(I[0]-R)*w,I[1]=(I[1]-E)*w,I[2]=(I[2]-R)*w,I[3]=(I[3]-E)*w,this._index.insert(new ft(e,q,I,w,R,E)))}break}default:d.skip()}}async _getSymbolsAttributes(e,s){if(!s||s.length===0)return e;const t=[];s.sort(ts);let r=s[0].styleLayerUID,o=0;for(let n=0;n<s.length;n++)r!==s[n].styleLayerUID&&(t.push({from:o,to:n,styleLayerUID:r,sourceTileKey:s[n].vtlSymbol.sourceTile}),o=n,r=s[n].styleLayerUID);t.push({from:o,to:s.length,styleLayerUID:r,sourceTileKey:s[s.length-1].vtlSymbol.sourceTile});const a=this._styleRepository.layers;for(const n of t){const l=await this._getTilePayload(n.sourceTileKey),h=a[n.styleLayerUID],c=!!h&&l.find(u=>u.sourceName===h.source);c&&this._addSymbolsAttributes(e,s.slice(n.from,n.to).map(u=>u.vtlSymbol),r,c)}return e}_addSymbolsAttributes(e,s,t,r){const o=this._styleRepository.layers,a=r.key,n=this.tileKey,l=1<<n.level-a.level,h=n.row-a.row*l,c=n.col-a.col*l;this._getSymbolAttributes(r.protobuff,s,t,l,h,c).forEach(u=>{const{attributes:d,tilePoint:y}=u;e.push({layerId:o[t].id,layerIndex:t,graphic:new le({attributes:d,origin:{type:"vector-tile",layerId:o[t].id,layerIndex:t,layer:this._parentLayer}}),tilePoint:y})})}_getSymbolAttributes(e,s,t,r,o,a){const n=[],l=this._styleRepository.layers;let h=0;s.sort((u,d)=>u.featureIndex-d.featureIndex);const c=new $(new Uint8Array(e),new DataView(e));for(;c.next();)switch(c.tag()){case 3:{const u=c.getMessage(),d=new be(u);if(u.release(),d.name!==l[t].sourceLayer)continue;const y=d.getData(),f=d.extent/r,p=Ae/f,_=f*a,m=f*o;let g=0;for(;y.nextTag(2);){const b=y.getMessage();if(g++===s[h].featureIndex){const T=new we(b,d),S=T.values,w=T.getGeometry(),R=w!=null?[p*(w[0][0].x-_),p*(w[0][0].y-m)]:null;n.push({attributes:S,tilePoint:R}),h++}if(b.release(),h===s.length)return n}break}default:c.skip()}return n}_queryIndex(e,s,t,r,o,a){const n=Zt*r*(window.devicePixelRatio||1);return this._index?.search({minX:s-n,minY:t-n,maxX:s+n,maxY:t+n},l=>{const{layer:h,feature:c}=l;h.isIntersectingFeature(s,t,r,c,o,a,l)&&e.push({layerId:h.id,layerIndex:h.uid,tilePoint:null,graphic:new le({attributes:c.values,origin:{type:"vector-tile",layerId:l.layer.id,layerIndex:l.layer.uid,layer:this._parentLayer}})})}),e}async _getTilePayload(e){return Be(this._tileKeyToPBF,e.id,()=>this._tileHandler.fetchTilePBFs(e)).then(s=>s)}}const ss=i=>({minX:i.bounds[0],minY:i.bounds[1],maxX:i.bounds[2],maxY:i.bounds[3]});class Le extends tt{constructor(){super(...arguments),this._fullCacheLodInfos=null,this._levelByScale={}}getTileParentId(e){const s=A.pool.acquire(e),t=s.level===0?null:A.getId(s.level-1,s.row>>1,s.col>>1,s.world);return A.pool.release(s),t}getTileCoverage(e,s,t=!0,r){const o=super.getTileCoverage(e,s,t,r);if(!o)return o;const a=1<<o.lodInfo.level;return o.spans=o.spans.filter(n=>n.row>=0&&n.row<a),o}scaleToLevel(e){if(this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos),this._levelByScale[e])return this._levelByScale[e];{const s=this._fullCacheLodInfos;if(e>s[0].scale)return s[0].level;let t,r;for(let o=0;o<s.length-1;o++)if(r=s[o+1],e>r.scale)return t=s[o],t.level+(t.scale-e)/(t.scale-r.scale);return s[s.length-1].level}}_initializeFullCacheLODs(e){let s;if(e[0].level===0)s=e.map(t=>({level:t.level,resolution:t.resolution,scale:t.scale}));else{const t=this.tileInfo.size[0],r=this.tileInfo.spatialReference;s=me.create({size:t,spatialReference:r}).lods.map(o=>({level:o.level,resolution:o.resolution,scale:o.scale}))}for(let t=0;t<s.length;t++)this._levelByScale[s[t].scale]=s[t].level;this._fullCacheLodInfos=s}}const ee=2,Oe=8,ke=512;let K=class extends mt(pt(gt)){constructor(){super(...arguments),this._styleChanges=[],this._fetchQueue=null,this._parseQueue=null,this._tileHandlerPromise=null,this._isTileHandlerReady=!1,this._styeChanged=!1,this._spriteSourceChanged=!1}get fading(){return this._vectorTileContainer?.fading??!1}get hasVisibleFeatures(){const i=this._vectorTileContainer.children;for(const e of i)if(e.hasFeatures())return!0;return!1}get spriteSourceChanged(){return this._spriteSourceChanged}get styleChanged(){return this._styeChanged}async hitTest(i,e){const s=this._tileHandlerPromise,t=this._vectorTileContainer?.symbolFader;if(!s||!this._isTileHandlerReady||!t)return;await s;let r=null;const o=this._vectorTileContainer?.symbolRepository;o&&(r=o.querySymbols(e,ee,t.decluttererOffset,{}));const a=this.view.state,n=this._tileManager.getIntersectingTiles(e.x,e.y,ee,a,r);if((!n||n.length===0)&&r?.length===0)return null;i=i.clone().normalize();const l=[],h=[];for(const c of n)l.push(this._queryTile(h,i,ee,this.view.state.rotation,c,r?.filter(u=>u.tileKey.id===c.id)));return await Promise.all(l),h}update(i){if(this._tileHandlerPromise&&this._isTileHandlerReady)return i.pixelRatio!==this._tileHandler.devicePixelRatio?(this._start(),void(this._tileHandler.devicePixelRatio=i.pixelRatio)):void(this._styleChanges.length>0?this._tileHandlerPromise=this._applyStyleChanges():(this._pauseQueues(),this._fetchQueue.state=i.state,this._parseQueue.state=i.state,this._tileManager.update(i)||this.requestUpdate(),this._resumeQueues()))}attach(){const{style:i}=this.layer.currentStyleInfo;this._styleRepository=new Se(i),this._tileInfoView=new Le(this.layer.tileInfo,this.layer.fullExtent),this._vectorTileContainer=new Xt(this._tileInfoView),this._tileHandler=new Ft(this.layer,this._styleRepository,window.devicePixelRatio||1,this.layer.tileInfo.lods.length-1),this.container.addChild(this._vectorTileContainer),this._start(),this.addAttachHandles([this.layer.on("paint-change",e=>{if(this._styeChanged=!0,e.isDataDriven)this._styleChanges.push({type:x.PAINTER_CHANGED,data:e}),this.requestUpdate();else{const s=this._styleRepository,t=s.getLayerById(e.layer);if(!t)return;const r=t.type===D.SYMBOL;s.setPaintProperties(e.layer,e.paint),r&&this._vectorTileContainer?.restartDeclutter(),this._vectorTileContainer?.requestRender()}}),this.layer.on("layout-change",e=>{const s=this._styleRepository,t=s.getLayerById(e.layer);if(!t)return;this._styeChanged=!0;const r=Ge(t.layout,e.layout);if(r!=null){if(Ye(r,"visibility")&&is(r)===1)return s.setLayoutProperties(e.layer,e.layout),t.type===D.SYMBOL&&this._vectorTileContainer?.restartDeclutter(),void this._vectorTileContainer?.requestRender();this._styleChanges.push({type:x.LAYOUT_CHANGED,data:e}),this.requestUpdate()}}),this.layer.on("style-layer-visibility-change",e=>{const s=this._styleRepository,t=s.getLayerById(e.layer);t&&(this._styeChanged=!0,s.setStyleLayerVisibility(e.layer,e.visibility),t.type===D.SYMBOL&&this._vectorTileContainer?.restartDeclutter(),this._vectorTileContainer?.requestRender())}),this.layer.on("style-layer-change",e=>{this._styleChanges.push({type:x.LAYER_CHANGED,data:e}),this._styeChanged=!0,this.requestUpdate()}),this.layer.on("delete-style-layer",e=>{this._styleChanges.push({type:x.LAYER_REMOVED,data:e}),this._styeChanged=!0,this.requestUpdate()}),this.layer.on("load-style",()=>this._loadStyle()),this.layer.on("spriteSource-change",e=>{this._spriteSourceChanged=!0,this._styleChanges.push({type:x.SPRITES_CHANGED,data:e});const s=this._styleRepository.layers;for(const t of s)switch(t.type){case D.SYMBOL:t.getLayoutProperty("icon-image")&&this._styleChanges.push({type:x.LAYOUT_CHANGED,data:{layer:t.id,layout:t.layout}});break;case D.LINE:t.getPaintProperty("line-pattern")&&this._styleChanges.push({type:x.PAINTER_CHANGED,data:{layer:t.id,paint:t.paint,isDataDriven:t.isPainterDataDriven()}});break;case D.FILL:t.getLayoutProperty("fill-pattern")&&this._styleChanges.push({type:x.PAINTER_CHANGED,data:{layer:t.id,paint:t.paint,isDataDriven:t.isPainterDataDriven()}})}this.requestUpdate()})])}detach(){this._stop(),this.container.removeAllChildren(),this._vectorTileContainer=z(this._vectorTileContainer),this._tileHandler=z(this._tileHandler)}viewChange(){this.requestUpdate()}moveEnd(){this.requestUpdate()}supportsSpatialReference(i){return Ne(this.layer.tileInfo?.spatialReference,i)}canResume(){let i=super.canResume();const{currentStyleInfo:e}=this.layer;if(i&&e?.layerDefinition){const s=this.view.scale,{minScale:t,maxScale:r}=e.layerDefinition;e?.layerDefinition&&(t&&t<s&&(i=!1),r&&r>s&&(i=!1))}return i}isUpdating(){return this.fading}acquireTile(i){const e=this._createVectorTile(i);return this._updatingHandles.addPromise(this._fetchQueue.push(e.key).then(s=>this._parseQueue.push({key:e.key,data:s})).then(s=>{e.once("attach",()=>this.requestUpdate()),e.setData(s),this.requestUpdate()}).catch(s=>{Y(s)||j.getLogger(this).error(s)})),e}releaseTile(i){const e=i.key.id;this._fetchQueue.abort(e),this._parseQueue.abort(e),this.requestUpdate()}async doRefresh(){if(!this.attached)return;if(this.suspended)return this._tileManager.clear(),void this.requestUpdate();this._isTileHandlerReady=!1,this._pauseQueues(),this._clearQueues(),this._tileManager.clearCache(),this._resumeQueues();const i=this._vectorTileContainer.children,e=[];try{for(const s of i){const t=this._updatingHandles.addPromise(this._fetchQueue.push(s.key).then(r=>this._parseQueue.push({key:s.key,data:r})).then(r=>s.setData(r)).finally(()=>s.featureIndex=null));e.push(t)}await Promise.all(e)}catch(s){j.getLogger(this).error("error refreshing vector-tiles layer-view",s),this._resumeQueues(),this._isTileHandlerReady=!0}this._isTileHandlerReady=!0,this.requestUpdate()}_start(){if(this._stop(),this._tileManager=new Me({acquireTile:s=>this.acquireTile(s),releaseTile:s=>this.releaseTile(s),tileInfoView:this._tileInfoView},this._vectorTileContainer),!this.layer.currentStyleInfo)return;const i=new AbortController,e=this._tileHandler.start({signal:i.signal}).then(()=>{this._fetchQueue=new fe({tileInfoView:this._tileInfoView,process:(s,t)=>this._getTileData(s,t),concurrency:15,scheduler:this.scheduler,priority:xe.MAPVIEW_FETCH_QUEUE}),this._parseQueue=new fe({tileInfoView:this._tileInfoView,process:(s,t)=>this._parseTileData(s,t),concurrency:8,scheduler:this.scheduler,priority:xe.MAPVIEW_VECTOR_TILE_PARSING_QUEUE}),this.requestUpdate(),this._isTileHandlerReady=!0});this._tileHandler.spriteMosaic.then(s=>{this._vectorTileContainer.setStyleResources(s,this._tileHandler.glyphMosaic,this._styleRepository,this._tileInfoView),this.requestUpdate()}),this._tileHandlerAbortController=i,this._tileHandlerPromise=e}_stop(){if(!this._tileHandlerAbortController||!this._vectorTileContainer)return;const i=this._tileHandlerAbortController;i&&i.abort(),this._tileHandlerPromise=null,this._isTileHandlerReady=!1,this._fetchQueue=z(this._fetchQueue),this._parseQueue=z(this._parseQueue),this._tileManager=z(this._tileManager),this._vectorTileContainer.removeAllChildren()}async _getTileData(i,e){return this._tileHandler.fetchTileData(i,e)}async _parseTileData(i,e){return this._tileHandler.parseTileData(i,e)}async _applyStyleChanges(){this._isTileHandlerReady=!1,this._pauseQueues(),this._clearQueues(),this._tileManager.clearCache();const i=this._styleChanges;try{await this._tileHandler.updateStyle(i)}catch(o){j.getLogger(this).error("error applying vector-tiles style update",o.message),this._resumeQueues(),this._isTileHandlerReady=!0}const e=this._styleRepository,s=new Set;i.forEach(o=>{if(o.type!==x.LAYER_REMOVED)return;const a=o.data,n=e.getLayerById(a.layer);n&&s.add(n.uid)});const t=new Set;i.forEach(o=>{let a;switch(o.type){case x.PAINTER_CHANGED:e.setPaintProperties(o.data.layer,o.data.paint),a=o.data.layer;break;case x.LAYOUT_CHANGED:e.setLayoutProperties(o.data.layer,o.data.layout),a=o.data.layer;break;case x.LAYER_REMOVED:return void e.deleteStyleLayer(o.data.layer);case x.LAYER_CHANGED:e.setStyleLayer(o.data.layer,o.data.index),a=o.data.layer.id;break;case x.SPRITES_CHANGED:this._vectorTileContainer.setSpriteMosaic(this._tileHandler.setSpriteSource(o.data.spriteSource))}if(a){const n=e.getLayerById(a);n&&t.add(n.uid)}});const r=this._vectorTileContainer.children;if(s.size>0){const o=Array.from(s);this._vectorTileContainer.deleteStyleLayers(o);for(const a of r)a.deleteLayerData(o)}if(this._resumeQueues(),t.size>0){const o=Array.from(t),a=[];for(const n of r){const l=this._updatingHandles.addPromise(this._fetchQueue.push(n.key).then(h=>this._parseQueue.push({key:n.key,data:h,styleLayerUIDs:o})).then(h=>n.setData(h)).finally(()=>n.featureIndex=null));a.push(l)}await Promise.all(a)}this._styleChanges=[],this._isTileHandlerReady=!0,this.requestUpdate()}async _loadStyle(){const{style:i}=this.layer.currentStyleInfo,e=Qe(i);this._isTileHandlerReady=!1,this._pauseQueues(),this._clearQueues(),this._styleRepository=new Se(e),this._vectorTileContainer.destroy(),this._tileManager.clear(),this._tileHandlerAbortController.abort(),this._tileHandlerAbortController=new AbortController;const{signal:s}=this._tileHandlerAbortController;try{this._tileHandlerPromise=this._tileHandler.setStyle(this._styleRepository,e,this.layer.tileInfo.lods.length-1),await this._tileHandlerPromise}catch(o){if(!Y(o))throw o}if(s.aborted)return this._resumeQueues(),this._isTileHandlerReady=!0,this._styeChanged=!1,this._spriteSourceChanged=!1,void this.requestUpdate();const t=await this._tileHandler.spriteMosaic,r=this._vectorTileContainer;this._tileInfoView=new Le(this.layer.tileInfo,this.layer.fullExtent),r.setStyleResources(t,this._tileHandler.glyphMosaic,this._styleRepository,this._tileInfoView),this._tileManager=new Me({acquireTile:o=>this.acquireTile(o),releaseTile:o=>this.releaseTile(o),tileInfoView:this._tileInfoView},this._vectorTileContainer),this._resumeQueues(),this._isTileHandlerReady=!0,this.requestUpdate(),this._styeChanged=!1,this._spriteSourceChanged=!1}_createVectorTile(i){const e=this._tileInfoView.getTileBounds(V(),i),s=this._tileInfoView.getTileResolution(i.level);return new Yt(i,s,e[0],e[3],512,512,this._styleRepository)}async _queryTile(i,e,s,t,r,o){if(r.layerData.size===0)return;const a=this._ensureTileIndex(r),n=this._tileInfoView.getTileBounds(V(),r.key,!0),l=Oe*ke*((e.x-n[0])/(n[2]-n[0])),h=Oe*ke*(1-(e.y-n[1])/(n[3]-n[1])),c=await a.queryAttributes(l,h,s,t,o);for(const u of c)u.graphic.geometry=this._tileToMapPoint(u.tilePoint,r.transforms.tileUnitsToPixels),i.push({type:"graphic",layer:this.layer,graphic:u.graphic,mapPoint:e.clone()});i.sort((u,d)=>d.graphic.origin.layerIndex-u.graphic.origin.layerIndex)}_tileToMapPoint(i,e){if(!i)return null;const s=i[0]*e[0]+i[1]*e[3]+e[6],t=i[0]*e[1]+i[1]*e[4]+e[7],r=this.view.state,o=[0,0];return r.toMap(o,[s,t]),new We({x:o[0],y:o[1],spatialReference:r.spatialReference})}_ensureTileIndex(i){let e=i.featureIndex;return e||(e=te.create(i.key,i.layerData,this._styleRepository,this._tileHandler,this.layer),i.featureIndex=e),e}_pauseQueues(){this._fetchQueue.pause(),this._parseQueue.pause()}_resumeQueues(){this._fetchQueue.resume(),this._parseQueue.resume()}_clearQueues(){this._fetchQueue.clear(),this._parseQueue.clear()}};function is(i){if(i==null)return 0;switch(i.type){case"partial":return Object.keys(i.diff).length;case"complete":return Math.max(Object.keys(i.oldValue).length,Object.keys(i.newValue).length);case"collection":return Object.keys(i.added).length+Object.keys(i.changed).length+Object.keys(i.removed).length}}he([Je()],K.prototype,"_isTileHandlerReady",void 0),K=he([Ke("esri.views.2d.layers.VectorTileLayerView2D")],K);const rs=K;export{rs as default};
