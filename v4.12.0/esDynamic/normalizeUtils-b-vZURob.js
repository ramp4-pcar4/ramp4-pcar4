import{ad as L,Q as W,at as B,c8 as T,bJ as k,b7 as G,aj as E,I as H,cn as K,bQ as z,gz as J,ae as O,O as V,n as Y,s as Z}from"./main-DnzmeE4U.js";import{f as tt}from"./utils-DuaeuwP5.js";import{r as et,o as st}from"./utils-Jw-4AGsF.js";const X={102100:{maxX:20037508342788905e-9,minX:-20037508342788905e-9,plus180Line:new L({paths:[[[20037508342788905e-9,-20037508342788905e-9],[20037508342788905e-9,20037508342788905e-9]]],spatialReference:W.WebMercator}),minus180Line:new L({paths:[[[-20037508342788905e-9,-20037508342788905e-9],[-20037508342788905e-9,20037508342788905e-9]]],spatialReference:W.WebMercator})},4326:{maxX:180,minX:-180,plus180Line:new L({paths:[[[180,-180],[180,180]]],spatialReference:W.WGS84}),minus180Line:new L({paths:[[[-180,-180],[-180,180]]],spatialReference:W.WGS84})}};function w(t,s){return Math.ceil((t-s)/(2*s))}function F(t,s){const i=q(t);for(const n of i)for(const e of n)e[0]+=s;return t}function q(t){return B(t)?t.rings:t.paths}async function nt(t,s,i,n){const e=tt(t),a=s[0].spatialReference,o={...n,responseType:"json",query:{...e.query,f:"json",sr:T(a),target:JSON.stringify({geometryType:k(s[0]),geometries:s}),cutter:JSON.stringify(i)}},r=await G(e.path+"/cut",o),{cutIndexes:c,geometries:f=[]}=r.data;return{cutIndexes:c,geometries:f.map(u=>{const m=E(u);return m.spatialReference=a,m})}}async function rt(t,s,i){const n=typeof t=="string"?H(t):t,e=s[0].spatialReference,a=k(s[0]),o={...i,query:{...n.query,f:"json",sr:T(e),geometries:JSON.stringify(et(s))}},{data:r}=await G(n.path+"/simplify",o);return st(r.geometries,a,e)}const Q=()=>Y.getLogger("esri.geometry.support.normalizeUtils");function ot(t){return t.type==="polygon"}function it(t){return t[0].type==="polygon"}function at(t){return t[0].type==="polyline"}function U(t){const s=[];let i=0,n=0;for(let e=0;e<t.length;e++){const a=t[e];let o=null;for(let r=0;r<a.length;r++)o=a[r],s.push(o),r===0?(i=o[0],n=i):(i=Math.min(i,o[0]),n=Math.max(n,o[0]));o&&s.push([(i+n)/2,0])}return s}function C(t,s){if(!(t instanceof L||t instanceof O)){const e="straightLineDensify: the input geometry is neither polyline nor polygon";throw Q().error(e),new Z(e)}const i=q(t),n=[];for(const e of i){const a=[];n.push(a),a.push([e[0][0],e[0][1]]);for(let o=0;o<e.length-1;o++){const r=e[o][0],c=e[o][1],f=e[o+1][0],u=e[o+1][1],m=Math.sqrt((f-r)*(f-r)+(u-c)*(u-c)),p=(u-c)/m,d=(f-r)/m,g=m/s;if(g>1){for(let S=1;S<=g-1;S++){const j=S*s,l=d*j+r,h=p*j+c;a.push([l,h])}const b=(m+Math.floor(g-1)*s)/2,I=d*b+r,A=p*b+c;a.push([I,A])}a.push([f,u])}}return ot(t)?new O({rings:n,spatialReference:t.spatialReference}):new L({paths:n,spatialReference:t.spatialReference})}function D(t,s,i){if(s){const n=C(t,1e6);t=V(n,!0)}return i&&(t=F(t,i)),t}function _(t,s,i){if(Array.isArray(t)){const n=t[0];if(n>s){const e=w(n,s);t[0]=n+e*(-2*s)}else if(n<i){const e=w(n,i);t[0]=n+e*(-2*i)}}else{const n=t.x;if(n>s){const e=w(n,s);t=t.clone().offset(e*(-2*s),0)}else if(n<i){const e=w(n,i);t=t.clone().offset(e*(-2*i),0)}}return t}function ct(t,s){let i=-1;for(let n=0;n<s.cutIndexes.length;n++){const e=s.cutIndexes[n],a=s.geometries[n],o=q(a);for(let r=0;r<o.length;r++){const c=o[r];c.some(f=>{if(f[0]<180)return!0;{let u=0;for(let p=0;p<c.length;p++){const d=c[p][0];u=d>u?d:u}u=Number(u.toFixed(9));const m=-360*w(u,180);for(let p=0;p<c.length;p++){const d=a.getPoint(r,p);a.setPoint(r,p,d.clone().offset(m,0))}return!0}})}if(e===i){if(it(t))for(const r of q(a))t[e]=t[e].addRing(r);else if(at(t))for(const r of q(a))t[e]=t[e].addPath(r)}else i=e,t[e]=a}return t}async function $(t,s,i){if(!Array.isArray(t))return $([t],s);s&&typeof s!="string"&&Q().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const n=typeof s=="string"?s:s?.url??K.geometryServiceUrl;let e,a,o,r,c,f,u,m,p=0;const d=[],g=[];for(const l of t)if(l!=null)if(e||(e=l.spatialReference,a=z(e),o=e.isWebMercator,f=o?102100:4326,r=X[f].maxX,c=X[f].minX,u=X[f].plus180Line,m=X[f].minus180Line),a)if(l.type==="mesh")g.push(l);else if(l.type==="point")g.push(_(l.clone(),r,c));else if(l.type==="multipoint"){const h=l.clone();h.points=h.points.map(x=>_(x,r,c)),g.push(h)}else if(l.type==="extent"){const h=l.clone()._normalize(!1,!1,a);g.push(h.rings?new O(h):h)}else if(l.extent){const h=l.extent,x=w(h.xmin,c)*(2*r);let M=x===0?l.clone():F(l.clone(),x);h.offset(x,0);let{xmin:R,xmax:y}=h;R=Number(R.toFixed(9)),y=Number(y.toFixed(9)),h.intersects(u)&&y!==r?(p=y>p?y:p,M=D(M,o),d.push(M),g.push("cut")):h.intersects(m)&&R!==c?(p=y*(2*r)>p?y*(2*r):p,M=D(M,o,360),d.push(M),g.push("cut")):g.push(M)}else g.push(l.clone());else g.push(l);else g.push(l);let b=w(p,r),I=-90;const A=b,S=new L;for(;b>0;){const l=360*b-180;S.addPath([[l,I],[l,-1*I]]),I*=-1,b--}if(d.length>0&&A>0){const l=ct(d,await nt(n,d,S,i)),h=[],x=[];for(let y=0;y<g.length;y++){const N=g[y];if(N!=="cut")x.push(N);else{const v=l.shift(),P=t[y];P!=null&&P.type==="polygon"&&P.rings&&P.rings.length>1&&v.rings.length>=P.rings.length?(h.push(v),x.push("simplify")):x.push(o?J(v):v)}}if(!h.length)return x;const M=await rt(n,h,i),R=[];for(let y=0;y<x.length;y++){const N=x[y];N!=="simplify"?R.push(N):R.push(o?J(M.shift()):M.shift())}return R}const j=[];for(let l=0;l<g.length;l++){const h=g[l];if(h!=="cut")j.push(h);else{const x=d.shift();j.push(o===!0?J(x):x)}}return j}function lt(t){if(!t)return null;const s=t.extent;if(!s)return null;const i=t.spatialReference&&z(t.spatialReference);if(!i)return s;const[n,e]=i.valid,a=2*e,{width:o}=s;let r,{xmin:c,xmax:f}=s;if([c,f]=[f,c],t.type==="extent"||o===0||o<=e||o>a||c<n||f>e)return s;switch(t.type){case"polygon":if(!(t.rings.length>1))return s;r=U(t.rings);break;case"polyline":if(!(t.paths.length>1))return s;r=U(t.paths);break;case"multipoint":r=t.points}const u=s.clone();for(let m=0;m<r.length;m++){let p=r[m][0];p<0?(p+=e,f=Math.max(p,f)):(p-=e,c=Math.min(p,c))}return u.xmin=c,u.xmax=f,u.width<o?(u.xmin-=e,u.xmax-=e,u):s}function ft(t,s,i){const n=z(i);if(n==null)return t;const[e,a]=n.valid,o=2*a;let r=0,c=0;s>a?r=Math.ceil(Math.abs(s-a)/o):s<e&&(r=-Math.ceil(Math.abs(s-e)/o)),t>a?c=Math.ceil(Math.abs(t-a)/o):t<e&&(c=-Math.ceil(Math.abs(t-e)/o));let f=t+(r-c)*o;const u=f-s;return u>a?f-=o:u<e&&(f+=o),f}function ut(t,s){const i=z(s);if(i){const[n,e]=i.valid,a=e-n;if(t<n)for(;t<n;)t+=a;if(t>e)for(;t>e;)t-=a}return t}export{ut as L,C as M,ft as P,$ as R,w as i,X as r,F as s,lt as v};
