import{fn as Ie,X as Ee,i0 as Oe,b7 as Q,_ as V,bc as $,s as Y,aW as Z,eV as ee,i1 as F,n as Pe,Z as Le,i2 as _e,i3 as Ue,i4 as Ce,bC as Ne,e_ as je,ei as te,b5 as re,a9 as z}from"./main-DnzmeE4U.js";import{a as ke}from"./devEnvironmentUtils-CxrVv3RG.js";import{i as ne,j as Fe,n as qe}from"./mat3-DOnW3DjW.js";import{t as W,e as se}from"./mat3f64-Dh9_zhFu.js";import{h as De}from"./mat4-BFStKTjU.js";import{e as Ge}from"./mat4f64-BaJwL7tQ.js";import{s as Ve}from"./vec2f64-CEUyUoff.js";import{E as oe,c as $e,i as ae,r as ze,A as We,I as He}from"./vec32-BuqRmYBM.js";import{N as ie,f as ue,n as q}from"./VerticalOffset.glsl-BtVaDxLq.js";import{c as le,x as Ke,L as Xe,i as ce,O as Je,E as Qe}from"./BufferView-BBCzkcZS.js";import{r as Ye,n as Ze,d as fe,l as me}from"./vec3-CRJiMrND.js";import{o as et,d as de}from"./vec4-DcTMp5mq.js";import{o as pe,i as tt}from"./Indices-DkAzsiH-.js";import{D as he,E as H}from"./enums-DBi1-Mm2.js";import{e as K,i as A,u as ye,n as rt}from"./renderState-DlSSrLcZ.js";import{i as nt,f as st}from"./vec2f32-CVhmN3Me.js";import{u as ot}from"./memoryEstimations-iHVpvWPf.js";import{t as at}from"./NestedMap-Ddo7BfvO.js";import{r as ge}from"./Version-BTMwSXf1.js";import{t as it}from"./requestImageUtils-rT_rMd2F.js";import{t as L}from"./orientedBoundingBox-CTsjUkMw.js";import{e as P}from"./VertexAttribute-DFC3a3eR.js";import{z as D,s as ut,t as lt,n as ct,o as ft}from"./DefaultMaterial-DGGIMylx.js";import{a as xe}from"./NormalAttribute.glsl-C9zbIKka.js";let be=class{constructor(e){this._streamDataRequester=e}async loadJSON(e,t){return this._load("json",e,t)}async loadBinary(e,t){return Ie(e)?(Ee(t),Oe(e)):this._load("binary",e,t)}async loadImage(e,t){return this._load("image",e,t)}async _load(e,t,s){if(this._streamDataRequester==null)return(await Q(t,{responseType:mt[e]})).data;const r=await V(this._streamDataRequester.request(t,e,s));if(r.ok===!0)return r.value;throw $(r.error),new Y("glt-loader-request-error",`Request for resource failed: ${r.error}`)}};const mt={image:"image",binary:"array-buffer",json:"json","image+type":void 0},B=()=>Pe.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");class dt{constructor(t,s,r){this.resource=t,this.textures=s,this.cachedMemory=r}}async function pt(e,t){const s=await ht(e,t),r=await wt(s.textureDefinitions??{},t);let a=0;for(const o in r)if(r.hasOwnProperty(o)){const i=r[o];a+=i?.image?i.image.width*i.image.height*4:0}return new dt(s,r,a+ot(s))}async function ht(e,t){const s=t?.streamDataRequester;if(s)return yt(e,s,t);const r=await V(Q(e,t));if(r.ok===!0)return r.value.data;$(r.error),we(r.error)}async function yt(e,t,s){const r=await V(t.request(e,"json",s));if(r.ok===!0)return r.value;$(r.error),we(r.error.details.url)}function we(e){throw new Y("",`Request for object resource failed: ${e}`)}function gt(e){const t=e.params,s=t.topology;let r=!0;switch(t.vertexAttributes||(B().warn("Geometry must specify vertex attributes"),r=!1),t.topology){case"PerAttributeArray":break;case"Indexed":case null:case void 0:{const o=t.faces;if(o){if(t.vertexAttributes)for(const i in t.vertexAttributes){const u=o[i];u?.values?(u.valueType!=null&&u.valueType!=="UInt32"&&(B().warn(`Unsupported indexed geometry indices type '${u.valueType}', only UInt32 is currently supported`),r=!1),u.valuesPerElement!=null&&u.valuesPerElement!==1&&(B().warn(`Unsupported indexed geometry values per element '${u.valuesPerElement}', only 1 is currently supported`),r=!1)):(B().warn(`Indexed geometry does not specify face indices for '${i}' attribute`),r=!1)}}else B().warn("Indexed geometries must specify faces"),r=!1;break}default:B().warn(`Unsupported topology '${s}'`),r=!1}e.params.material||(B().warn("Geometry requires material"),r=!1);const a=e.params.vertexAttributes;for(const o in a)a[o].values||(B().warn("Geometries with externally defined attributes are not yet supported"),r=!1);return r}function xt(e,t){const s=new Array,r=new Array,a=new Array,o=new at,i=e.resource,u=ge.parse(i.version||"1.0","wosr");vt.validate(u);const n=i.model.name,l=i.model.geometries,c=i.materialDefinitions??{},f=e.textures;let h=0;const y=new Map;for(let d=0;d<l.length;d++){const g=l[d];if(!gt(g))continue;const b=Tt(g),T=g.params.vertexAttributes,p=[],x=m=>{if(g.params.topology==="PerAttributeArray")return null;const v=g.params.faces;for(const w in v)if(w===m)return v[w].values;return null},C=T[P.POSITION],j=C.values.length/C.valuesPerElement;for(const m in T){const v=T[m],w=v.values,R=x(m)??pe(j);p.push([m,new L(w,R,v.valuesPerElement,!0)])}const S=b.texture,M=f&&f[S];if(M&&!y.has(S)){const{image:m,parameters:v}=M,w=new ie(m,v);r.push(w),y.set(S,w)}const k=y.get(S),N=k?k.id:void 0,E=b.material;let I=o.get(E,S);if(I==null){const m=c[E.slice(E.lastIndexOf("/")+1)].params;m.transparency===1&&(m.transparency=0);const v=M&&M.alphaChannelUsage,w=m.transparency>0||v==="transparency"||v==="maskAndTransparency",R=M?Te(M.alphaChannelUsage):void 0,J={ambient:Z(m.diffuse),diffuse:Z(m.diffuse),opacity:1-(m.transparency||0),transparent:w,textureAlphaMode:R,textureAlphaCutoff:.33,textureId:N,doubleSided:!0,cullFace:K.None,colorMixMode:m.externalColorMixMode||"tint",textureAlphaPremultiplied:M?.parameters.preMultiplyAlpha??!1};t?.materialParameters&&Object.assign(J,t.materialParameters),I=new D(J,t),o.set(E,S,I)}a.push(I);const O=new ue(I,p);h+=p.find(m=>m[0]===P.POSITION)?.[1]?.indices.length??0,s.push(O)}return{engineResources:[{name:n,stageResources:{textures:r,materials:a,geometries:s},pivotOffset:i.model.pivotOffset,numberOfVertices:h,lodThreshold:null}],referenceBoundingBox:bt(s)}}function bt(e){const t=ee();return e.forEach(s=>{const r=s.boundingInfo;r!=null&&(F(t,r.bbMin),F(t,r.bbMax))}),t}async function wt(e,t){const s=new Array;for(const o in e){const i=e[o],u=i.images[0].data;if(!u){B().warn("Externally referenced texture data is not yet supported");continue}const n=i.encoding+";base64,"+u,l="/textureDefinitions/"+o,c=i.channels==="rgba"?i.alphaChannelUsage||"transparency":"none",f={noUnpackFlip:!0,wrap:{s:he.REPEAT,t:he.REPEAT},preMultiplyAlpha:Te(c)!==A.Opaque},h=t?.disableTextures?Promise.resolve(null):it(n,t);s.push(h.then(y=>({refId:l,image:y,parameters:f,alphaChannelUsage:c})))}const r=await Promise.all(s),a={};for(const o of r)a[o.refId]=o;return a}function Te(e){switch(e){case"mask":return A.Mask;case"maskAndTransparency":return A.MaskBlend;case"none":return A.Opaque;default:return A.Blend}}function Tt(e){const t=e.params;return{id:1,material:t.material,texture:t.texture,region:t.texture}}const vt=new ge(1,2,"wosr");function ve(e,t){X(e.typedBuffer,t.typedBuffer,e.typedBufferStride,t.typedBufferStride)}function X(e,t,s=2,r=s){const a=t.length/2;let o=0,i=0;if(!Le(t)||_e(t)){for(let n=0;n<a;++n)e[o]=t[i],e[o+1]=t[i+1],o+=s,i+=r;return}const u=Ue(t);if(Ce(t))for(let n=0;n<a;++n)e[o]=Math.max(t[i]/u,-1),e[o+1]=Math.max(t[i+1]/u,-1),o+=s,i+=r;else for(let n=0;n<a;++n)e[o]=t[i]/u,e[o+1]=t[i+1]/u,o+=s,i+=r}function Re(e,t,s,r){const a=e.typedBuffer,o=e.typedBufferStride,i=r?.count??e.count;let u=(r?.dstIndex??0)*o;for(let n=0;n<i;++n)a[u]=t,a[u+1]=s,u+=o}Object.freeze(Object.defineProperty({__proto__:null,fill:Re,normalizeIntegerBuffer:X,normalizeIntegerBufferView:ve},Symbol.toStringTag,{value:"Module"}));let Ae=class{constructor(e){this.data=e,this.type="encoded-mesh-texture",this.encoding=ye.KTX2_ENCODING}};function G(e){return e?.type==="encoded-mesh-texture"}async function Rt(e){const t=new Blob([e]),s=await t.text();return JSON.parse(s)}async function At(e,t){if(t===ye.KTX2_ENCODING)return new Ae(e);const s=new Blob([e],{type:t});let r=URL.createObjectURL(s);switch(t){case"image/jpeg":r+="#.jpg";break;case"image/png":r+="#.png"}const a=new Image;if(Ne("esri-iPhone"))return new Promise((o,i)=>{const u=()=>{l(),o(a)},n=c=>{l(),i(c)},l=()=>{URL.revokeObjectURL(r),a.removeEventListener("load",u),a.removeEventListener("error",n)};a.addEventListener("load",u),a.addEventListener("error",n),a.src=r});try{a.src=r,await a.decode()}catch{console.warn("Failed decoding HTMLImageElement")}return URL.revokeObjectURL(r),a}function Me(e,t){switch(t){case H.TRIANGLES:return Mt(e);case H.TRIANGLE_STRIP:return Bt(e);case H.TRIANGLE_FAN:return St(e)}}function Mt(e){return typeof e=="number"?pe(e):je(e)?new Uint16Array(e):e}function Bt(e){const t=typeof e=="number"?e:e.length;if(t<3)return[];const s=t-2,r=tt(3*s);if(typeof e=="number"){let a=0;for(let o=0;o<s;o+=1)o%2==0?(r[a++]=o,r[a++]=o+1,r[a++]=o+2):(r[a++]=o+1,r[a++]=o,r[a++]=o+2)}else{let a=0;for(let o=0;o<s;o+=1)o%2==0?(r[a++]=e[o],r[a++]=e[o+1],r[a++]=e[o+2]):(r[a++]=e[o+1],r[a++]=e[o],r[a++]=e[o+2])}return r}function St(e){const t=typeof e=="number"?e:e.length;if(t<3)return new Uint16Array(0);const s=t-2,r=s<=65536?new Uint16Array(3*s):new Uint32Array(3*s);if(typeof e=="number"){let u=0;for(let n=0;n<s;++n)r[u++]=0,r[u++]=n+1,r[u++]=n+2;return r}const a=e[0];let o=e[1],i=0;for(let u=0;u<s;++u){const n=e[u+2];r[i++]=a,r[i++]=o,r[i++]=n,o=n}return r}function _(e){if(e==null)return null;const t=e.offset!=null?e.offset:nt,s=e.rotation!=null?e.rotation:0,r=e.scale!=null?e.scale:st,a=W(1,0,0,0,1,0,t[0],t[1],1),o=W(Math.cos(s),-Math.sin(s),0,Math.sin(s),Math.cos(s),0,0,0,1),i=W(r[0],0,0,0,r[1],0,0,0,1),u=se();return ne(u,o,i),ne(u,a,u),u}class It{constructor(){this.geometries=new Array,this.materials=new Array,this.textures=new Array}}class Et{constructor(t,s,r){this.name=t,this.lodThreshold=s,this.pivotOffset=r,this.stageResources=new It,this.numberOfVertices=0}}async function Be(e,t){const s=Se(ke(e));if(s.fileType==="wosr"){const f=await(t.cache?t.cache.loadWOSR(s.url,t):pt(s.url,t)),{engineResources:h,referenceBoundingBox:y}=xt(f,t);return{lods:h,referenceBoundingBox:y,isEsriSymbolResource:!1,isWosr:!0}}let r;if(t.cache)r=await t.cache.loadGLTF(s.url,t,!!t.usePBR);else{const{loadGLTF:f}=await import("./loader-hV6Mz7xG.js");r=await f(new be(t.streamDataRequester),s.url,t,t.usePBR)}const a=r.model.meta?.ESRI_proxyEllipsoid,o=r.meta.isEsriSymbolResource&&a!=null&&r.meta.ESRI_webstyle==="EsriRealisticTreesStyle";o&&!r.customMeta.esriTreeRendering&&(r.customMeta.esriTreeRendering=!0,Ut(r,a));const i=!!t.usePBR,u=r.meta.isEsriSymbolResource?{usePBR:i,isSchematic:!1,treeRendering:o,mrrFactors:ut}:{usePBR:i,isSchematic:!1,treeRendering:!1,mrrFactors:lt},n={...t.materialParameters,treeRendering:o},{engineResources:l,referenceBoundingBox:c}=Ot(r,u,n,t,s.specifiedLodIndex);return{lods:l,referenceBoundingBox:c,isEsriSymbolResource:r.meta.isEsriSymbolResource,isWosr:!1}}function Se(e){const t=e.match(/(.*\.(gltf|glb))(\?lod=([0-9]+))?$/);return t?{fileType:"gltf",url:t[1],specifiedLodIndex:t[4]!=null?Number(t[4]):null}:e.match(/(.*\.(json|json\.gz))$/)?{fileType:"wosr",url:e,specifiedLodIndex:null}:{fileType:"unknown",url:e,specifiedLodIndex:null}}function Ot(e,t,s,r,a){const o=e.model,i=new Array,u=new Map,n=new Map,l=o.lods.length,c=ee();return o.lods.forEach((f,h)=>{const y=r.skipHighLods===!0&&(l>1&&h===0||l>3&&h===1)||r.skipHighLods===!1&&a!=null&&h!==a;if(y&&h!==0)return;const d=new Et(f.name,f.lodThreshold,[0,0,0]);f.parts.forEach(g=>{const b=y?new D({},r):Pt(o,g,d,t,s,u,n,r),{geometry:T,vertexCount:p}=Lt(g,b??new D({},r)),x=T.boundingInfo;x!=null&&h===0&&(F(c,x.bbMin),F(c,x.bbMax)),b!=null&&(d.stageResources.geometries.push(T),d.numberOfVertices+=p)}),y||i.push(d)}),{engineResources:i,referenceBoundingBox:c}}function Pt(e,t,s,r,a,o,i,u){const n=e.materials.get(t.material);if(n==null)return null;const{normal:l,color:c,texCoord0:f,tangent:h}=t.attributes,y=t.material+(l?"_normal":"")+(c?"_color":"")+(f?"_texCoord0":"")+(h?"_tangent":""),d=t.attributes.texCoord0!=null,g=t.attributes.normal!=null,b=_t(n.alphaMode);if(!o.has(y)){if(d){const O=(m,v=!1)=>{if(m!=null&&!i.has(m)){const w=e.textures.get(m);if(w){const R=w.data;i.set(m,new ie(G(R)?R.data:R,{...w.parameters,preMultiplyAlpha:!G(R)&&v,encoding:G(R)?R.encoding:void 0}))}}};O(n.colorTexture,b!==A.Opaque),O(n.normalTexture),O(n.occlusionTexture),O(n.emissiveTexture),O(n.metallicRoughnessTexture)}const p=1/re,x=n.color[0]**p,C=n.color[1]**p,j=n.color[2]**p,S=n.emissiveFactor[0]**p,M=n.emissiveFactor[1]**p,k=n.emissiveFactor[2]**p,N=n.colorTexture!=null&&d?i.get(n.colorTexture):null,E=ct(n),I=n.normalTextureTransform?.scale!=null?n.normalTextureTransform?.scale:Ve;o.set(y,new D({...r,transparent:b===A.Blend,customDepthTest:rt.Lequal,textureAlphaMode:b,textureAlphaCutoff:n.alphaCutoff,diffuse:[x,C,j],ambient:[x,C,j],opacity:n.opacity,doubleSided:n.doubleSided,doubleSidedType:"winding-order",cullFace:n.doubleSided?K.None:K.Back,hasVertexColors:!!t.attributes.color,hasVertexTangents:!!t.attributes.tangent,normalType:g?xe.Attribute:xe.ScreenDerivative,castShadows:!0,receiveShadows:n.receiveShadows,receiveAmbientOcclusion:n.receiveAmbientOcclustion,textureId:N?.id,colorMixMode:n.colorMixMode,normalTextureId:n.normalTexture!=null&&d?i.get(n.normalTexture).id:void 0,textureAlphaPremultiplied:N!=null&&!!N.parameters.preMultiplyAlpha,occlusionTextureId:n.occlusionTexture!=null&&d?i.get(n.occlusionTexture).id:void 0,emissiveTextureId:n.emissiveTexture!=null&&d?i.get(n.emissiveTexture).id:void 0,metallicRoughnessTextureId:n.metallicRoughnessTexture!=null&&d?i.get(n.metallicRoughnessTexture).id:void 0,emissiveFactor:[S,M,k],mrrFactors:E?ft:[n.metallicFactor,n.roughnessFactor,r.mrrFactors[2]],isSchematic:E,colorTextureTransformMatrix:_(n.colorTextureTransform),normalTextureTransformMatrix:_(n.normalTextureTransform),scale:[I[0],I[1]],occlusionTextureTransformMatrix:_(n.occlusionTextureTransform),emissiveTextureTransformMatrix:_(n.emissiveTextureTransform),metallicRoughnessTextureTransformMatrix:_(n.metallicRoughnessTextureTransform),...a},u))}const T=o.get(y);if(s.stageResources.materials.push(T),d){const p=x=>{x!=null&&s.stageResources.textures.push(i.get(x))};p(n.colorTexture),p(n.normalTexture),p(n.occlusionTexture),p(n.emissiveTexture),p(n.metallicRoughnessTexture)}return T}function Lt(e,t){const s=e.attributes.position.count,r=Me(e.indices||s,e.primitiveType),a=q(3*s),{typedBuffer:o,typedBufferStride:i}=e.attributes.position;Ye(a,o,e.transform,3,i);const u=[[P.POSITION,new L(a,r,3,!0)]];if(e.attributes.normal!=null){const l=q(3*s),{typedBuffer:c,typedBufferStride:f}=e.attributes.normal;Fe(U,e.transform),Ze(l,c,U,3,f),te(U)&&fe(l,l),u.push([P.NORMAL,new L(l,r,3,!0)])}if(e.attributes.tangent!=null){const l=q(4*s),{typedBuffer:c,typedBufferStride:f}=e.attributes.tangent;qe(U,e.transform),et(l,c,U,4,f),te(U)&&fe(l,l,4),u.push([P.TANGENT,new L(l,r,4,!0)])}if(e.attributes.texCoord0!=null){const l=q(2*s),{typedBuffer:c,typedBufferStride:f}=e.attributes.texCoord0;X(l,c,2,f),u.push([P.UV0,new L(l,r,2,!0)])}const n=e.attributes.color;if(n!=null){const l=new Uint8Array(4*s);n.elementCount===4?n instanceof le?de(l,n,1,255):(n instanceof Ke||n instanceof Xe)&&de(l,n,1/255,255):(l.fill(255),n instanceof ce?me(l,n.typedBuffer,1,255,4,n.typedBufferStride):(e.attributes.color instanceof Je||e.attributes.color instanceof Qe)&&me(l,n.typedBuffer,1/255,255,4,e.attributes.color.typedBufferStride)),u.push([P.COLOR,new L(l,r,4,!0)])}return{geometry:new ue(t,u),vertexCount:s}}const U=se();function _t(e){switch(e){case"BLEND":return A.Blend;case"MASK":return A.Mask;case"OPAQUE":case null:case void 0:return A.Opaque}}function Ut(e,t){for(let s=0;s<e.model.lods.length;++s){const r=e.model.lods[s];for(const a of r.parts){const o=a.attributes.normal;if(o==null)return;const i=a.attributes.position,u=i.count,n=z(),l=z(),c=z(),f=new Float32Array(4*u),h=new Float32Array(3*u),y=De(Ge(),a.transform);let d=0,g=0;for(let b=0;b<u;b++){i.getVec(b,l),o.getVec(b,n),oe(l,l,a.transform),$e(c,l,t.center),ae(c,c,t.radius);const T=c[2],p=ze(c),x=Math.min(.45+.55*p*p,1)**re;ae(c,c,t.radius),y!==null&&oe(c,c,y),We(c,c),s+1!==e.model.lods.length&&e.model.lods.length>1&&He(c,c,n,T>-1?.2:Math.min(-4*T-3.8,1)),h[d]=c[0],h[d+1]=c[1],h[d+2]=c[2],d+=3,f[g]=x,f[g+1]=x,f[g+2]=x,f[g+3]=1,g+=4}a.attributes.normal=new ce(h),a.attributes.color=new le(f)}}}const Ct=Object.freeze(Object.defineProperty({__proto__:null,fetch:Be,parseUrl:Se},Symbol.toStringTag,{value:"Module"}));export{Be as Y,be as a,Me as b,ve as c,Ct as d,Re as l,G as n,At as o,Rt as r,_ as s,Ae as t};
