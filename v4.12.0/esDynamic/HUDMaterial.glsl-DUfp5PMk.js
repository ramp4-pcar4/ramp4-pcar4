import{x as n,z as u,K as Te,a3 as It,a9 as R,eQ as Se,ij as it,n as Oe,l_ as Pe,a1 as be,bp as Me,ca as Ce,aV as De,am as Ae}from"./main-DnzmeE4U.js";import{o as Re}from"./floatRGBA-YJlz5IlR.js";import{e as vt,r as gt,n as G,s as Ee,u as Fe}from"./vec4f64-CjUMzAyX.js";import{v as ze,N as je,af as Ie,aO as Le,s as Ve,J as Be,P as Ne,a9 as Ue,o as $e,U as Lt,ae as mt,c as Vt,w as He,aP as qe,i as Ge,G as U,K as We,k as Xe,g as ke,M as Ye,ak as Q,Y as Qe,Z as Ze,aQ as Je,ao as Ke,at as O,av as ti,R as ei,au as ii,aw as ri,A as X,t as si,aR as oi,aS as ai,aT as Bt,ay as ni,aU as li,aC as ci,aV as hi,aj as pi,aD as ui,aW as di,aX as fi,aY as vi,aZ as gi,a_ as Nt,a$ as Ut,b0 as mi}from"./VerticalOffset.glsl-BtVaDxLq.js";import{D as $t,E as Ht,O as _i}from"./enums-DBi1-Mm2.js";import{n as _t,c as qt,h as rt,s as wi,A as yi,C as xi,X as Ti}from"./mat4-BFStKTjU.js";import{e as $}from"./mat4f64-BaJwL7tQ.js";import{r as Gt,E as Si,o as wt,I as Oi}from"./vec2-BnynUbeJ.js";import{t as Wt,n as yt}from"./vec2f64-CEUyUoff.js";import{c as st,o as H,p as Xt,s as V,H as ot,R as kt,P as xt,Z as Yt,X as Pi,g as B,r as k,_ as Qt,A as at,K as bi,E as nt,u as Tt,N as Mi}from"./vec32-BuqRmYBM.js";import{m as Zt,L as Jt,E as St,a as lt,x as Kt,z as ct}from"./vec42-D8CJyqHG.js";import{H as Ci,N as Di,L as Ai}from"./Octree-Kk-G5P_T.js";import{b as Ri}from"./sphere-Cj20syUS.js";import{f as Ei}from"./plane-B_adY3_o.js";import{l as Fi}from"./ViewingMode-CyR_b1T8.js";import{n as I,u as te,f as Ot}from"./ShaderOutput-C_OqLoo1.js";import{o as zi}from"./VertexArrayObject-DTkLCIKs.js";import{n as ee}from"./mat3-DOnW3DjW.js";import{e as ie}from"./mat3f64-Dh9_zhFu.js";import{x as ji}from"./BufferView-BBCzkcZS.js";import{H as Ii,s as Li}from"./InterleavedLayout-DcHoXu73.js";import{b as re,u as Vi,n as Bi,d as Ni,e as Ui}from"./HUDVisibility.glsl-Bl7zdrV0.js";import{e as _}from"./VertexAttribute-DFC3a3eR.js";import{B as $i,o as Hi,p as qi,g as Gi}from"./renderState-DlSSrLcZ.js";import{n as f,t as P}from"./glsl-o28TenZV.js";import{a as Wi}from"./BindType-CKbZk6AG.js";import{i as Xi}from"./ShaderBuilder-BkQM64Qp.js";let ki=class extends ze{constructor(t,e){super(t,"vec4",Wi.Draw,(i,r,s)=>i.setUniform4fv(t,e(r,s)))}};const Pt=128,W=.5,Yi=vt(W/2,W/2,1-W/2,1-W/2);function Qi(t){return t==="cross"||t==="x"}function Zi(t,e=Pt,i=e*W,r=0){const s=Ji(t,e,i,r);return new je(s,{mipmap:!1,wrap:{s:$t.CLAMP_TO_EDGE,t:$t.CLAMP_TO_EDGE},width:e,height:e,components:4,noUnpackFlip:!0,reloadable:!0})}function Ji(t,e=Pt,i=e*W,r=0){switch(t){case"circle":default:return Ki(e,i);case"square":return tr(e,i);case"cross":return ir(e,i,r);case"x":return rr(e,i,r);case"kite":return er(e,i);case"triangle":return sr(e,i);case"arrow":return or(e,i)}}function Ki(t,e){const i=t/2-.5;return Z(t,ae(i,i,e/2))}function tr(t,e){return se(t,e,!1)}function er(t,e){return se(t,e,!0)}function ir(t,e,i=0){return oe(t,e,!1,i)}function rr(t,e,i=0){return oe(t,e,!0,i)}function sr(t,e){return Z(t,ne(t/2,e,e/2))}function or(t,e){const i=e,r=e/2,s=t/2,o=.8*i,a=ae(s,(t-e)/2-o,Math.sqrt(o*o+r*r)),l=ne(s,i,r);return Z(t,(c,h)=>Math.max(l(c,h),-a(c,h)))}function se(t,e,i){return i&&(e/=Math.SQRT2),Z(t,(r,s)=>{let o=r-.5*t+.25,a=.5*t-s-.75;if(i){const l=(o+a)/Math.SQRT2;a=(a-o)/Math.SQRT2,o=l}return Math.max(Math.abs(o),Math.abs(a))-.5*e})}function oe(t,e,i,r=0){e-=r,i&&(e*=Math.SQRT2);const s=.5*e;return Z(t,(o,a)=>{let l,c=o-.5*t,h=.5*t-a-1;if(i){const m=(c+h)/Math.SQRT2;h=(h-c)/Math.SQRT2,c=m}return c=Math.abs(c),h=Math.abs(h),l=c>h?c>s?Math.sqrt((c-s)*(c-s)+h*h):h:h>s?Math.sqrt(c*c+(h-s)*(h-s)):c,l-=r/2,l})}function ae(t,e,i){return(r,s)=>{const o=r-t,a=s-e;return Math.sqrt(o*o+a*a)-i}}function ne(t,e,i){const r=Math.sqrt(e*e+i*i);return(s,o)=>{const a=Math.abs(s-t)-i,l=o-t+e/2+.75,c=(e*a+i*l)/r,h=-l;return Math.max(c,h)}}function Z(t,e){const i=new Uint8Array(4*t*t);for(let r=0;r<t;r++)for(let s=0;s<t;s++){const o=s+t*r;let a=e(s,r);a=a/t+.5,Re(a,i,4*o)}return i}function ar(t,e,i){return 2*Math.atan(Math.sqrt(e*e+i*i)*Math.tan(.5*t)/e)}function nr(t,e,i){return 2*Math.atan(Math.sqrt(e*e+i*i)*Math.tan(.5*t)/i)}function lr(t,e,i){return 2*Math.atan(e*Math.tan(.5*t)/Math.sqrt(e*e+i*i))}function cr(t,e,i){return 2*Math.atan(i*Math.tan(.5*t)/Math.sqrt(e*e+i*i))}var le,y;(function(t){t[t.Default=0]="Default",t[t.Screenshot=1]="Screenshot",t[t.ObjectAndLayerID=2]="ObjectAndLayerID"})(le||(le={})),function(t){t[t.TOP=0]="TOP",t[t.RIGHT=1]="RIGHT",t[t.BOTTOM=2]="BOTTOM",t[t.LEFT=3]="LEFT"}(y||(y={}));var bt;let p=bt=class extends It{constructor(t){super(t),this._ray=Ri(),this._viewport=gt(0,0,1,1),this._padding=gt(0,0,0,0),this._fov=55/180*Math.PI,this._nearFar=Wt(1,1e3),this._viewDirty=!0,this._viewMatrix=$(),this._viewProjectionDirty=!0,this._viewProjectionMatrix=$(),this._viewInverseTransposeMatrixDirty=!0,this._viewInverseTransposeMatrix=$(),this._frustumDirty=!0,this._frustum=Ci(),this._fullViewport=G(),this._pixelRatio=1,this.row=0,this.column=0,this._rows=1,this._columns=1,this._center=R(),this._up=R(),this.relativeElevation=0}get pixelRatio(){return this._pixelRatio}set pixelRatio(t){this._pixelRatio=t>0?t:1}get rows(){return this._rows}set rows(t){this._rows=Math.max(1,t)}get columns(){return this._columns}set columns(t){this._columns=Math.max(1,t)}get eye(){return this._ray.origin}set eye(t){this._compareAndSetView(t,this._ray.origin)}get center(){return this._center}set center(t){this._compareAndSetView(t,this._center,"_center")}get ray(){return st(this._ray.direction,this.center,this.eye),this._ray}get up(){return this._up}set up(t){this._compareAndSetView(t,this._up,"_up")}get viewMatrix(){return this._ensureViewClean(),this._viewMatrix}set viewMatrix(t){_t(this._viewMatrix,t),this.notifyChange("_viewMatrix"),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get viewForward(){return this._ensureViewClean(),H(R(),-this._viewMatrix[2],-this._viewMatrix[6],-this._viewMatrix[10])}get viewUp(){return this._ensureViewClean(),H(R(),this._viewMatrix[1],this._viewMatrix[5],this._viewMatrix[9])}get viewRight(){return this._ensureViewClean(),H(R(),this._viewMatrix[0],this._viewMatrix[4],this._viewMatrix[8])}get nearFar(){return this._nearFar}get near(){return this._nearFar[0]}set near(t){this._nearFar[0]!==t&&(this._nearFar[0]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_nearFar"))}get far(){return this._nearFar[1]}set far(t){this._nearFar[1]!==t&&(this._nearFar[1]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_nearFar"))}get viewport(){return this._viewport}set viewport(t){this.x=t[0],this.y=t[1],this.width=t[2],this.height=t[3]}get screenViewport(){if(this.pixelRatio===1)return this._viewport;const t=Zt(G(),this._viewport,1/this.pixelRatio),e=this._get("screenViewport");return e&&Jt(t,e)?e:t}get screenPadding(){if(this.pixelRatio===1)return this._padding;const t=Zt(G(),this._padding,1/this.pixelRatio),e=this._get("screenPadding");return e&&Jt(t,e)?e:t}get x(){return this._viewport[0]}set x(t){t+=this._padding[y.LEFT],this._viewport[0]!==t&&(this._viewport[0]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get y(){return this._viewport[1]}set y(t){t+=this._padding[y.BOTTOM],this._viewport[1]!==t&&(this._viewport[1]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get width(){return this._viewport[2]}set width(t){this._viewport[2]!==t&&(this._viewport[2]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get height(){return this._viewport[3]}set height(t){this._viewport[3]!==t&&(this._viewport[3]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get fullWidth(){return this._viewport[2]+this._padding[y.RIGHT]+this._padding[y.LEFT]}set fullWidth(t){this.width=t-(this._padding[y.RIGHT]+this._padding[y.LEFT])}get fullHeight(){return this._viewport[3]+this._padding[y.TOP]+this._padding[y.BOTTOM]}set fullHeight(t){this.height=t-(this._padding[y.TOP]+this._padding[y.BOTTOM])}get fullViewport(){return this._fullViewport[0]=this._viewport[0]-this._padding[y.LEFT],this._fullViewport[1]=this._viewport[1]-this._padding[y.BOTTOM],this._fullViewport[2]=this.fullWidth,this._fullViewport[3]=this.fullHeight,this._fullViewport}get _aspect(){return this.width/this.height}get padding(){return this._padding}set padding(t){St(this._padding,t)||(this._viewport[0]+=t[y.LEFT]-this._padding[y.LEFT],this._viewport[1]+=t[y.BOTTOM]-this._padding[y.BOTTOM],this._viewport[2]-=t[y.RIGHT]+t[y.LEFT]-(this._padding[y.RIGHT]+this._padding[y.LEFT]),this._viewport[3]-=t[y.TOP]+t[y.BOTTOM]-(this._padding[y.TOP]+this._padding[y.BOTTOM]),lt(this._padding,t),this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_padding"),this.notifyChange("_viewport"))}get viewProjectionMatrix(){return this._viewProjectionDirty&&(qt(this._viewProjectionMatrix,this.projectionMatrix,this.viewMatrix),this._viewProjectionDirty=!1),this._viewProjectionMatrix}get projectionMatrix(){return this._projectionMatrixInternal}get inverseProjectionMatrix(){return rt($(),this.projectionMatrix)||this._get("inverseProjectionMatrix")||$()}get fov(){return this._fov}set fov(t){this._fov=t,this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovX(){return lr(this._fov,this.width,this.height)}set fovX(t){this._fov=ar(t,this.width,this.height),this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovY(){return cr(this._fov,this.width,this.height)}set fovY(t){this._fov=nr(t,this.width,this.height),this._viewProjectionDirty=!0,this._frustumDirty=!0}get distance(){return Xt(this.center,this.eye)}get frustum(){return this._recomputeFrustum(),this._frustum}get viewInverseTransposeMatrix(){return(this._viewInverseTransposeMatrixDirty||this._viewDirty)&&(rt(this._viewInverseTransposeMatrix,this.viewMatrix),wi(this._viewInverseTransposeMatrix,this._viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),this._viewInverseTransposeMatrix}depthNDCToWorld(t){const{near:e,far:i}=this;return 2*e*i/(i+e-t*(i-e))}get perRenderPixelRatio(){return Math.tan(this.fovX/2)/(this.width/2)}get perScreenPixelRatio(){return this.perRenderPixelRatio*this.pixelRatio}get aboveGround(){return this.relativeElevation!=null&&this.relativeElevation>=0}get _projectionMatrixInternal(){const t=this.width,e=this.height,i=this.near*Math.tan(this.fovY/2)*2,r=i*this._aspect,s=i/this.rows,o=r/this.columns,a=-r/2+this.column*o,l=a+o,c=-i/2+this.row*s,h=c+s,m=yi($(),a*(1+2*this._padding[y.LEFT]/t),l*(1+2*this._padding[y.RIGHT]/t),c*(1+2*this._padding[y.BOTTOM]/e),h*(1+2*this._padding[y.TOP]/e),this.near,this.far),v=this._get("projectionMatrix");return v&&xi(v,m)?v:m}copyFrom(t){V(this._ray.origin,t.eye),this.center=t.center,this.up=t.up,lt(this._viewport,t.viewport),this.notifyChange("_viewport"),lt(this._padding,t.padding),this.notifyChange("_padding"),Gt(this._nearFar,t.nearFar),this.notifyChange("_nearFar"),this._fov=t.fov,this.row=t.row,this.column=t.column,this.rows=t.rows,this.columns=t.columns,this.relativeElevation=t.relativeElevation;const e=t;return this._viewDirty=e._viewDirty,this._viewDirty||(_t(this._viewMatrix,t.viewMatrix),this.notifyChange("_viewMatrix")),this._viewProjectionDirty=!0,this._frustumDirty=e._frustumDirty,this._frustumDirty||(Di(this._frustum,t.frustum),this._frustumDirty=!1),e._viewInverseTransposeMatrixDirty?this._viewInverseTransposeMatrixDirty=!0:(_t(this._viewInverseTransposeMatrix,t.viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),lt(this._fullViewport,t.fullViewport),this.pixelRatio=t.pixelRatio,this}copyViewFrom(t){this.eye=t.eye,this.center=t.center,this.up=t.up,this.fov=t.fov}clone(){return new bt().copyFrom(this)}equals(t){return ot(this.eye,t.eye)&&ot(this.center,t.center)&&ot(this.up,t.up)&&St(this._viewport,t.viewport)&&St(this._padding,t.padding)&&Si(this.nearFar,t.nearFar)&&this._fov===t.fov&&this.pixelRatio===t.pixelRatio&&this.relativeElevation===t.relativeElevation&&this.row===t.row&&this.column===t.column&&this.rows===t.rows&&this.columns===t.columns}almostEquals(t){const e=Math.max(1,1/this.pixelRatio,1/t.pixelRatio);if(Math.abs(t.fov-this._fov)>=.001||Kt(t.screenPadding,this.screenPadding)>=e||Kt(this.screenViewport,t.screenViewport)>=e||this.row!==t.row||this.column!==t.column||this.rows!==t.rows||this.columns!==t.columns)return!1;kt(b,t.eye,t.center),kt(Mt,this.eye,this.center);const i=xt(b,Mt),r=Yt(b),s=Yt(Mt),o=5e-4;return i*i>=(1-1e-10)*r*s&&Pi(t.eye,this.eye)<Math.max(r,s)*o*o}computeRenderPixelSizeAt(t){return this.computeRenderPixelSizeAtDist(this._viewDirectionDistance(t))}computeRenderPixelSizeAtDist(t){return t*this.perRenderPixelRatio}computeScreenPixelSizeAt(t){return this.computeScreenPixelSizeAtDist(this._viewDirectionDistance(t))}_viewDirectionDistance(t){return Math.abs(Ei(this.viewForward,st(b,t,this.eye)))}computeScreenPixelSizeAtDist(t){return t*this.perScreenPixelRatio}computeDistanceFromRadius(t,e){return t/Math.tan(Math.min(this.fovX,this.fovY)/(2*(e||1)))}getScreenCenter(t=Se()){return t[0]=(this.padding[y.LEFT]+this.width/2)/this.pixelRatio,t[1]=(this.padding[y.TOP]+this.height/2)/this.pixelRatio,t}getRenderCenter(t,e=.5,i=.5){return t[0]=this.padding[y.LEFT]+this.width*e,t[1]=this.padding[y.BOTTOM]+this.height*i,t[2]=.5,t}setGLViewport(t){const e=this.viewport,i=this.padding;t.setViewport(e[0]-i[3],e[1]-i[2],e[2]+i[1]+i[3],e[3]+i[0]+i[2])}applyProjection(t,e){t!==g&&V(g,t),g[3]=1,ct(g,g,this.projectionMatrix);const i=Math.abs(g[3]);B(g,g,1/i);const r=this.fullViewport;e[0]=it(0,r[0]+r[2],.5+.5*g[0]),e[1]=it(0,r[1]+r[3],.5+.5*g[1]),e[2]=.5*(g[2]+1),e[3]=i}unapplyProjection(t,e){const i=this.fullViewport;g[0]=(t[0]/(i[0]+i[2])*2-1)*t[3],g[1]=(t[1]/(i[1]+i[3])*2-1)*t[3],g[2]=(2*t[2]-1)*t[3],g[3]=t[3],this.inverseProjectionMatrix!=null&&(ct(g,g,this.inverseProjectionMatrix),e[0]=g[0],e[1]=g[1],e[2]=g[2])}projectToScreen(t,e){return this.projectToRenderScreen(t,Ct),this.renderToScreen(Ct,e),e}projectToRenderScreen(t,e){if(g[0]=t[0],g[1]=t[1],g[2]=t[2],g[3]=1,ct(g,g,this.viewProjectionMatrix),g[3]===0)return null;const i=g;B(i,i,1/Math.abs(g[3]));const r=this.fullViewport,s=it(0,r[0]+r[2],.5+.5*i[0]),o=it(0,r[1]+r[3],.5+.5*i[1]);return"x"in e?(e.x=s,e.y=o):(e[0]=s,e[1]=o,e.length>2&&(e[2]=.5*(i[2]+1))),e}unprojectFromScreen(t,e){return this.unprojectFromRenderScreen(this.screenToRender(t,Ct),e)}unprojectFromRenderScreen(t,e){if(qt(ht,this.projectionMatrix,this.viewMatrix),!rt(ht,ht))return null;const i=this.fullViewport;return g[0]=2*(t[0]-i[0])/i[2]-1,g[1]=2*(t[1]-i[1])/i[3]-1,g[2]=2*t[2]-1,g[3]=1,ct(g,g,ht),g[3]===0?null:(e[0]=g[0]/g[3],e[1]=g[1]/g[3],e[2]=g[2]/g[3],e)}constrainWindowSize(t,e,i,r){const s=t*this.pixelRatio,o=e*this.pixelRatio,a=Math.max(s-i/2,0),l=Math.max(this.fullHeight-o-r/2,0),c=-Math.min(s-i/2,0),h=-Math.min(this.fullHeight-o-r/2,0),m=i-c- -Math.min(this.fullWidth-s-i/2,0),v=r-h- -Math.min(o-r/2,0);return[Math.round(a),Math.round(l),Math.round(m),Math.round(v)]}computeUp(t){t===Fi.Global?this._computeUpGlobal():this._computeUpLocal()}screenToRender(t,e){const i=t[0]*this.pixelRatio,r=this.fullHeight-t[1]*this.pixelRatio;return e[0]=i,e[1]=r,e}renderToScreen(t,e){const i=t[0]/this.pixelRatio,r=(this.fullHeight-t[1])/this.pixelRatio;e[0]=i,e[1]=r}_computeUpGlobal(){st(b,this.center,this.eye);const t=k(this.center);t<1?(H(this._up,0,0,1),this._markViewDirty(),this.notifyChange("_up")):Math.abs(xt(b,this.center))>.9999*k(b)*t||(Qt(this._up,b,this.center),Qt(this._up,this._up,b),at(this._up,this._up),this.notifyChange("_up"),this._markViewDirty())}_computeUpLocal(){bi(b,this.eye,this.center),Math.abs(b[2])<=.9999&&(B(b,b,b[2]),H(this._up,-b[0],-b[1],1-b[2]),at(this._up,this._up),this.notifyChange("_up"),this._markViewDirty())}_compareAndSetView(t,e,i=""){typeof t[0]=="number"&&isFinite(t[0])&&typeof t[1]=="number"&&isFinite(t[1])&&typeof t[2]=="number"&&isFinite(t[2])?ot(t,e)||(V(e,t),this._markViewDirty(),i.length&&this.notifyChange(i)):Oe.getLogger("esri.views.3d.webgl-engine.lib.RenderCamera").warn("RenderCamera vector contains invalid number, ignoring value")}_markViewDirty(){this._viewDirty=!0,this._frustumDirty=!0,this._viewProjectionDirty=!0}_recomputeFrustum(){this._frustumDirty&&(Ai(this.viewMatrix,this.projectionMatrix,this._frustum),this._frustumDirty=!1)}_ensureViewClean(){this._viewDirty&&(Ti(this._viewMatrix,this.eye,this.center,this.up),this.notifyChange("_viewMatrix"),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0)}};n([u()],p.prototype,"_viewport",void 0),n([u()],p.prototype,"_padding",void 0),n([u()],p.prototype,"_fov",void 0),n([u()],p.prototype,"_nearFar",void 0),n([u()],p.prototype,"_viewDirty",void 0),n([u()],p.prototype,"_viewMatrix",void 0),n([u()],p.prototype,"_pixelRatio",void 0),n([u()],p.prototype,"pixelRatio",null),n([u()],p.prototype,"row",void 0),n([u()],p.prototype,"column",void 0),n([u()],p.prototype,"_rows",void 0),n([u()],p.prototype,"rows",null),n([u()],p.prototype,"_columns",void 0),n([u()],p.prototype,"columns",null),n([u()],p.prototype,"eye",null),n([u()],p.prototype,"center",null),n([u()],p.prototype,"_center",void 0),n([u()],p.prototype,"up",null),n([u()],p.prototype,"_up",void 0),n([u()],p.prototype,"viewMatrix",null),n([u({readOnly:!0})],p.prototype,"viewForward",null),n([u({readOnly:!0})],p.prototype,"viewUp",null),n([u({readOnly:!0})],p.prototype,"viewRight",null),n([u({readOnly:!0})],p.prototype,"nearFar",null),n([u()],p.prototype,"near",null),n([u()],p.prototype,"far",null),n([u()],p.prototype,"viewport",null),n([u({readOnly:!0})],p.prototype,"screenViewport",null),n([u({readOnly:!0})],p.prototype,"screenPadding",null),n([u()],p.prototype,"x",null),n([u()],p.prototype,"y",null),n([u()],p.prototype,"width",null),n([u()],p.prototype,"height",null),n([u()],p.prototype,"fullWidth",null),n([u()],p.prototype,"fullHeight",null),n([u({readOnly:!0})],p.prototype,"_aspect",null),n([u()],p.prototype,"padding",null),n([u({readOnly:!0})],p.prototype,"projectionMatrix",null),n([u({readOnly:!0})],p.prototype,"inverseProjectionMatrix",null),n([u()],p.prototype,"fov",null),n([u()],p.prototype,"fovX",null),n([u()],p.prototype,"fovY",null),n([u()],p.prototype,"viewInverseTransposeMatrix",null),n([u({readOnly:!0})],p.prototype,"_projectionMatrixInternal",null),n([u()],p.prototype,"relativeElevation",void 0),p=bt=n([Te("esri.views.3d.webgl.RenderCamera")],p);const hr=p,g=G(),ht=$(),b=R(),Mt=R(),Ct=Pe(),pr={required:[]};I.Depth;let ce=class extends It{precompile(t){return!!this.acquireTechniques(t)}consumes(){return pr}get usedMemory(){return 0}get isDecoration(){return!1}get running(){return!1}modify(t){}get numGeometries(){return 0}get hasOccludees(){return!1}get hasEmissions(){return!1}forEachGeometry(t){}queryRenderOccludedState(t){return!1}};class ur extends ce{}class dr extends ce{}let fr=class extends zi{};function vr(t){return t instanceof Float32Array&&t.length>=16}function gr(t){return Array.isArray(t)&&t.length>=16}function mr(t){return vr(t)||gr(t)}class _r{constructor(){this.factor=new he,this.factorAlignment=new he}}class he{constructor(){this.scale=0,this.factor=0,this.minScaleFactor=0}}function wr(t,e){const{vertex:i,fragment:r}=t;t.include(Ie,e),i.include(re),i.main.add(f`vec4 posProjCenter;
if (dot(position, position) > 0.0) {
ProjectHUDAux projectAux;
vec4 posProj = projectPositionHUD(projectAux);
posProjCenter = alignToPixelCenter(posProj, viewport.zw);
forwardViewPosDepth(projectAux.posView);
vec3 vpos = projectAux.posModel;
if (rejectBySlice(vpos)) {
posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
}
} else {
posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
}
gl_Position = posProjCenter;
gl_PointSize = 1.0;`),r.main.add(f`fragColor = vec4(1);
if(discardByTerrainDepth()) {
fragColor.g = 0.5;
}`)}function pe(t){const e=new Xi,i=t.signedDistanceFieldEnabled;e.include(Vi,t),e.vertex.include(Le,t);const{occlusionPass:r,output:s,oitPass:o}=t;if(r)return e.include(wr,t),e;const{vertex:a,fragment:l}=e;e.include(Ve),e.include(Be,t),e.include(Ne,t),e.include(Bi),l.include(Ni),l.include(Ue),e.varyings.add("vcolor","vec4"),e.varyings.add("vtc","vec2"),e.varyings.add("vsize","vec2");const c=s===I.Highlight,h=c&&t.occlusionTestEnabled;h&&e.varyings.add("voccluded","float"),a.uniforms.add(new $e("viewport",d=>d.camera.fullViewport),new Lt("screenOffset",(d,S)=>wt(pt,2*d.screenOffset[0]*S.camera.pixelRatio,2*d.screenOffset[1]*S.camera.pixelRatio)),new Lt("anchorPosition",d=>J(d)),new mt("materialColor",d=>d.color),new Vt("materialRotation",d=>d.rotation)),He(a),i&&(a.uniforms.add(new mt("outlineColor",d=>d.outlineColor)),l.uniforms.add(new mt("outlineColor",d=>ue(d)?d.outlineColor:Ee),new Vt("outlineSize",d=>ue(d)?d.outlineSize:0))),t.horizonCullingEnabled&&a.uniforms.add(new ki("pointDistanceSphere",(d,S)=>{const A=S.camera.eye,F=d.origin;return gt(F[0]-A[0],F[1]-A[1],F[2]-A[2],be.radius)})),t.pixelSnappingEnabled&&a.include(re),t.hasScreenSizePerspective&&(qe(a),Ge(a)),t.debugDrawLabelBorder&&e.varyings.add("debugBorderCoords","vec4"),e.attributes.add(_.UV0,"vec2"),e.attributes.add(_.COLOR,"vec4"),e.attributes.add(_.SIZE,"vec2"),e.attributes.add(_.ROTATION,"float"),e.attributes.add(_.FEATUREATTRIBUTE,"vec4"),a.code.add(t.horizonCullingEnabled?f`bool behindHorizon(vec3 posModel) {
vec3 camToEarthCenter = pointDistanceSphere.xyz - localOrigin;
vec3 camToPos = pointDistanceSphere.xyz + posModel;
float earthRadius = pointDistanceSphere.w;
float a = dot(camToPos, camToPos);
float b = dot(camToPos, camToEarthCenter);
float c = dot(camToEarthCenter, camToEarthCenter) - earthRadius * earthRadius;
return  b > 0.0 && b < a && b * b  > a * c;
}`:f`bool behindHorizon(vec3 posModel) { return false; }`),a.main.add(f`
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);
      forwardObjectAndLayerIdColor();

      if (rejectBySlice(projectAux.posModel)) {
        // Project outside of clip plane
        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
        return;
      }

      if (behindHorizon(projectAux.posModel)) {
        // Project outside of clip plane
        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
        return;
      }

      vec2 inputSize;
      ${P(t.hasScreenSizePerspective,f`
          inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);
          vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);`,f`
          inputSize = size;
          vec2 screenOffsetScaled = screenOffset;`)}
      ${P(t.vvSize,f`inputSize *= vvScale(featureAttribute).xx;`)}

      vec2 combinedSize = inputSize * pixelRatio;
      vec4 quadOffset = vec4(0.0);

      ${P(t.occlusionTestEnabled,f`
      bool visible = testHUDVisibility(posProj);
      if (!visible) {
        vtc = vec2(0.0);
        ${P(t.debugDrawLabelBorder,"debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);")}
        return;
      }`)}
      ${P(h,f`voccluded = visible ? 0.0 : 1.0;`)}
    `);const m=f`
      vec2 uv01 = floor(uv0);
      vec2 uv = uv0 - uv01;
      quadOffset.xy = (uv01 - anchorPosition) * 2.0 * combinedSize;

      ${P(t.hasRotation,f`
          float angle = radians(materialRotation + rotation);
          float cosAngle = cos(angle);
          float sinAngle = sin(angle);
          mat2 rotate = mat2(cosAngle, -sinAngle, sinAngle,  cosAngle);

          quadOffset.xy = rotate * quadOffset.xy;
        `)}

      quadOffset.xy = (quadOffset.xy + screenOffsetScaled) / viewport.zw * posProj.w;
  `,v=t.pixelSnappingEnabled?i?f`posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;`:f`posProj += quadOffset;
if (inputSize.x == size.x) {
posProj = alignToPixelOrigin(posProj, viewport.zw);
}`:f`posProj += quadOffset;`;a.main.add(f`
    ${m}
    ${t.vvColor?"vcolor = interpolateVVColor(featureAttribute.y) * materialColor;":"vcolor = color / 255.0 * materialColor;"}

    ${P(s===I.ObjectAndLayerIdColor,f`vcolor.a = 1.0;`)}

    bool alphaDiscard = vcolor.a < ${f.float(U)};
    ${P(i,`alphaDiscard = alphaDiscard && outlineColor.a < ${f.float(U)};`)}
    if (alphaDiscard) {
      // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      return;
    } else {
      ${v}
      gl_Position = posProj;
    }

    vtc = uv;

    ${P(t.debugDrawLabelBorder,f`debugBorderCoords = vec4(uv01, 1.5 / combinedSize);`)}
    vsize = inputSize;
  `),l.uniforms.add(new We("tex",d=>d.texture)),t.occludedFragmentFade&&(l.uniforms.add(new Xe("depthMap",d=>d.mainDepth)),l.uniforms.add(new ke("occludedOpacity",d=>d.hudOccludedFragmentOpacity)));const x=t.debugDrawLabelBorder?f`(isBorder > 0.0 ? 0.0 : ${f.float(U)})`:f.float(U),w=f`
    ${P(t.debugDrawLabelBorder,f`float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));`)}

    ${P(t.sampleSignedDistanceFieldTexelCenter,f`
      float txSize = float(textureSize(tex, 0).x);
      float texelSize = 1.0 / txSize;

      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel
      vec2 scaleFactor = (vsize - txSize) * texelSize;
      vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;`,f`vec2 samplePos = vtc;`)}

    ${i?f`
      vec4 fillPixelColor = vcolor;

      // Get distance and map it into [-0.5, 0.5]
      float d = rgbaTofloat(texture(tex, samplePos)) - 0.5;

      // Distance in output units (i.e. pixels)
      float dist = d * vsize.x;

      // Create smooth transition from the icon into its outline
      float fillAlphaFactor = clamp(0.5 - dist, 0.0, 1.0);
      fillPixelColor.a *= fillAlphaFactor;

      if (outlineSize > 0.25) {
        vec4 outlinePixelColor = outlineColor;
        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);

        // Create smooth transition around outline
        float outlineAlphaFactor = clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);
        outlinePixelColor.a *= outlineAlphaFactor;

        if (
          outlineAlphaFactor + fillAlphaFactor < ${x} ||
          fillPixelColor.a + outlinePixelColor.a < ${f.float(U)}
        ) {
          discard;
        }

        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)
        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);
        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +
          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);

        ${P(!c,f`fragColor = vec4(compositeColor, compositeAlpha);`)}
      } else {
        if (fillAlphaFactor < ${x}) {
          discard;
        }

        ${P(!c,f`fragColor = premultiplyAlpha(fillPixelColor);`)}
      }

      // visualize SDF:
      // fragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);
      `:f`
          vec4 texColor = texture(tex, vtc, -0.5);
          if (texColor.a < ${x}) {
            discard;
          }
          ${P(!c,f`fragColor = texColor * premultiplyAlpha(vcolor);`)}
          `}

    ${P(t.occludedFragmentFade&&!c,f`
        float zSample = texelFetch(depthMap, ivec2(gl_FragCoord.xy), 0).x;
        if (zSample < gl_FragCoord.z) {
          fragColor *= occludedOpacity;
        }
        `)}

    ${P(!c&&t.debugDrawLabelBorder,f`fragColor = mix(fragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder * 0.5);`)}
  `;switch(s){case I.Color:case I.ColorEmission:e.outputs.add("fragColor","vec4",0),s===I.ColorEmission&&e.outputs.add("fragEmission","vec4",1),o===Q.ColorAlpha&&e.outputs.add("fragAlpha","float",s===I.ColorEmission?2:1),l.main.add(f`
        ${w}
        ${P(o===Q.FrontFace,f`fragColor.rgb /= fragColor.a;`)}
        ${P(s===I.ColorEmission,f`fragEmission = vec4(0.0);`)}
        ${P(o===Q.ColorAlpha,f`fragAlpha = fragColor.a;`)}`);break;case I.ObjectAndLayerIdColor:l.main.add(f`
        ${w}
        outputObjectAndLayerIdColor();`);break;case I.Highlight:e.include(Ye,t),l.main.add(f`
        ${w}
        outputHighlight(${P(h,f`voccluded == 1.0`,f`false`)});`)}return e}function ue(t){return t.outlineColor[3]>0&&t.outlineSize>0}function J(t){return t.textureIsSignedDistanceField?yr(t.anchorPosition,t.distanceFieldBoundingBox,pt):Gt(pt,t.anchorPosition),pt}function yr(t,e,i){wt(i,t[0]*(e[2]-e[0])+e[0],t[1]*(e[3]-e[1])+e[1])}const pt=yt(),xr=Object.freeze(Object.defineProperty({__proto__:null,build:pe,calculateAnchorPosition:J},Symbol.toStringTag,{value:"Module"}));class Tr extends Qe{constructor(e,i){super(e,i,new Ze(xr,()=>Promise.resolve().then(()=>Lr))),this.primitiveType=i.occlusionPass?Ht.POINTS:Ht.TRIANGLES}initializePipeline(e){const{oitPass:i,hasPolygonOffset:r,draped:s,output:o,depthTestEnabled:a,occlusionPass:l}=e,c=i===Q.NONE,h=i===Q.ColorAlpha,m=o===I.Highlight,v=a&&!s&&!h&&!l&&!m;return $i({blending:te(o)?c?Hi:Je(i):null,depthTest:a&&!s?{func:_i.LEQUAL}:null,depthWrite:v?qi:null,drawBuffers:Ke(i,o),colorWrite:Gi,polygonOffset:r?Sr:null})}}const Sr={factor:0,units:-4};class T extends ti{constructor(e){super(),this.spherical=e,this.screenCenterOffsetUnitsEnabled=!1,this.occlusionTestEnabled=!0,this.signedDistanceFieldEnabled=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.vvSize=!1,this.vvColor=!1,this.hasVerticalOffset=!1,this.hasScreenSizePerspective=!1,this.hasRotation=!1,this.debugDrawLabelBorder=!1,this.hasPolygonOffset=!1,this.depthTestEnabled=!0,this.pixelSnappingEnabled=!0,this.draped=!1,this.terrainDepthTest=!1,this.cullAboveTerrain=!1,this.occlusionPass=!1,this.occludedFragmentFade=!1,this.objectAndLayerIdColorInstanced=!1,this.horizonCullingEnabled=!0,this.isFocused=!0,this.textureCoordinateType=ei.None,this.emissionSource=ii.None,this.discardInvisibleFragments=!0,this.hasVvInstancing=!1}}n([O()],T.prototype,"screenCenterOffsetUnitsEnabled",void 0),n([O()],T.prototype,"occlusionTestEnabled",void 0),n([O()],T.prototype,"signedDistanceFieldEnabled",void 0),n([O()],T.prototype,"sampleSignedDistanceFieldTexelCenter",void 0),n([O()],T.prototype,"vvSize",void 0),n([O()],T.prototype,"vvColor",void 0),n([O()],T.prototype,"hasVerticalOffset",void 0),n([O()],T.prototype,"hasScreenSizePerspective",void 0),n([O()],T.prototype,"hasRotation",void 0),n([O()],T.prototype,"debugDrawLabelBorder",void 0),n([O()],T.prototype,"hasPolygonOffset",void 0),n([O()],T.prototype,"depthTestEnabled",void 0),n([O()],T.prototype,"pixelSnappingEnabled",void 0),n([O()],T.prototype,"draped",void 0),n([O()],T.prototype,"terrainDepthTest",void 0),n([O()],T.prototype,"cullAboveTerrain",void 0),n([O()],T.prototype,"occlusionPass",void 0),n([O()],T.prototype,"occludedFragmentFade",void 0),n([O()],T.prototype,"objectAndLayerIdColorInstanced",void 0),n([O()],T.prototype,"horizonCullingEnabled",void 0),n([O()],T.prototype,"isFocused",void 0);class Or extends ri{constructor(e,i){super(e,zr),this.produces=new Map([[X.HUD_MATERIAL,r=>Ot(r)&&!this.parameters.drawAsLabel],[X.LABEL_MATERIAL,r=>Ot(r)&&this.parameters.drawAsLabel],[X.OCCLUSION_PIXELS,()=>this.parameters.occlusionTest],[X.DRAPED_MATERIAL,r=>this.parameters.draped&&Ot(r)]]),this._visible=!0,this._configuration=new T(i)}getConfiguration(e,i){return this._configuration.output=e,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled=this.parameters.centerOffsetUnits==="screen",this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.draped=this.parameters.draped,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.sampleSignedDistanceFieldTexelCenter=this.parameters.sampleSignedDistanceFieldTexelCenter,this._configuration.hasRotation=this.parameters.hasRotation,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.occlusionPass=i.slot===X.OCCLUSION_PIXELS,this._configuration.occludedFragmentFade=this.parameters.occludedFragmentFade,this._configuration.horizonCullingEnabled=this.parameters.horizonCullingEnabled,this._configuration.isFocused=this.parameters.isFocused,this._configuration.depthTestEnabled=this.parameters.depthEnabled||i.slot===X.OCCLUSION_PIXELS,te(e)&&(this._configuration.debugDrawLabelBorder=!!si.LABELS_SHOW_BORDER),this._configuration.oitPass=i.oitPass,this._configuration.terrainDepthTest=i.terrainDepthTest,this._configuration.cullAboveTerrain=i.cullAboveTerrain,this._configuration}intersect(e,i,r,s,o,a){const{options:{selectionMode:l,hud:c,excludeLabels:h},point:m,camera:v}=r,{parameters:x}=this;if(!l||!c||h&&x.isLabel||!e.visible||!m)return;const{scaleX:w,scaleY:d}=this._getScreenScale(e,v.pixelRatio);ee(At,i),e.attributes.has(_.FEATUREATTRIBUTE)&&Mr(At);const S=e.attributes.get(_.POSITION),A=e.attributes.get(_.SIZE),F=e.attributes.get(_.NORMAL),D=e.attributes.get(_.ROTATION),j=e.attributes.get(_.CENTEROFFSETANDDISTANCE);Li(S.size>=3);const N=J(x),q=this.parameters.centerOffsetUnits==="screen";for(let L=0;L<S.data.length/S.size;L++){const ut=L*S.size;H(M,S.data[ut],S.data[ut+1],S.data[ut+2]),nt(M,M,i),nt(M,M,v.viewMatrix);const dt=L*j.size;if(H(z,j.data[dt],j.data[dt+1],j.data[dt+2]),!q&&(M[0]+=z[0],M[1]+=z[1],z[2]!==0)){const et=z[2];at(z,M),st(M,M,B(z,z,et))}const ft=L*F.size;if(H(K,F.data[ft],F.data[ft+1],F.data[ft+2]),de(K,At,v,Et),this._applyVerticalOffsetTransformationView(M,Et,v,Dt),v.applyProjection(M,C),C[0]>-1){q&&(z[0]||z[1])&&(C[0]+=z[0]*v.pixelRatio,z[1]!==0&&(C[1]+=oi(z[1],Dt.factorAlignment)*v.pixelRatio),v.unapplyProjection(C,M)),C[0]+=this.parameters.screenOffset[0]*v.pixelRatio,C[1]+=this.parameters.screenOffset[1]*v.pixelRatio,C[0]=Math.floor(C[0]),C[1]=Math.floor(C[1]);const et=L*A.size;E[0]=A.data[et],E[1]=A.data[et+1],ai(E,Dt.factor,E);const we=Rr*v.pixelRatio;let Ft=0;x.textureIsSignedDistanceField&&(Ft=Math.min(x.outlineSize,.5*E[0])*v.pixelRatio/2),E[0]*=w,E[1]*=d;const ye=L*D.size,xe=x.rotation+D.data[ye];if(fe(m,C[0],C[1],E,we,Ft,xe,x,N)){const zt=r.ray;if(nt(ge,M,rt(Dr,v.viewMatrix)),C[0]=m[0],C[1]=m[1],v.unprojectFromRenderScreen(C,M)){const Y=R();V(Y,zt.direction);const jt=1/k(Y);B(Y,Y,jt),a(Xt(zt.origin,M)*jt,Y,-1,!0,1,ge)}}}}}intersectDraped(e,i,r,s,o,a){const l=e.attributes.get(_.POSITION),c=e.attributes.get(_.SIZE),h=e.attributes.get(_.ROTATION),m=this.parameters,v=J(m),{scaleX:x,scaleY:w}=this._getScreenScale(e,e.screenToWorldRatio),d=Er*e.screenToWorldRatio;for(let S=0;S<l.data.length/l.size;S++){const A=S*l.size,F=l.data[A],D=l.data[A+1],j=S*c.size;E[0]=c.data[j],E[1]=c.data[j+1];let N=0;m.textureIsSignedDistanceField&&(N=Math.min(m.outlineSize,.5*E[0])*e.screenToWorldRatio/2),E[0]*=x,E[1]*=w;const q=S*h.size,L=m.rotation+h.data[q];fe(s,F,D,E,d,N,L,m,v)&&o(a.dist,a.normal,-1,!1)}}createBufferWriter(){return new Ir}_updateScaleInfo(e,i,r){const s=this.parameters;s.screenSizePerspective!=null?Bt(r,i,s.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minScaleFactor=0),s.screenSizePerspectiveAlignment!=null?Bt(r,i,s.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minScaleFactor=e.factor.minScaleFactor)}applyShaderOffsetsView(e,i,r,s,o,a,l){const c=de(i,r,o,Et);return this._applyVerticalGroundOffsetView(e,c,o,l),this._applyVerticalOffsetTransformationView(l,c,o,a),this._applyPolygonOffsetView(l,c,s[3],o,l),this._applyCenterOffsetView(l,s,l),l}applyShaderOffsetsNDC(e,i,r,s,o){return this._applyCenterOffsetNDC(e,i,r,s),o!=null&&V(o,s),this._applyPolygonOffsetNDC(s,i,r,s),s}_applyPolygonOffsetView(e,i,r,s,o){const a=s.aboveGround?1:-1;let l=Math.sign(r);l===0&&(l=a);const c=a*l;if(this.parameters.shaderPolygonOffset<=0)return V(o,e);const h=Me(Math.abs(i.cosAngle),.01,1),m=1-Math.sqrt(1-h*h)/h/s.viewport[2];return B(o,e,c>0?m:1/m),o}_applyVerticalGroundOffsetView(e,i,r,s){const o=k(e),a=r.aboveGround?1:-1,l=r.computeRenderPixelSizeAtDist(o)*Ui,c=B(M,i.normal,a*l);return Tt(s,e,c),s}_applyVerticalOffsetTransformationView(e,i,r,s){const o=this.parameters;if(!o.verticalOffset?.screenLength){if(o.screenSizePerspective||o.screenSizePerspectiveAlignment){const h=k(e);this._updateScaleInfo(s,h,i.cosAngle)}else s.factor.scale=1,s.factorAlignment.scale=1;return e}const a=k(e),l=o.screenSizePerspectiveAlignment??o.screenSizePerspective,c=ni(r,a,o.verticalOffset,i.cosAngle,l);return this._updateScaleInfo(s,a,i.cosAngle),B(i.normal,i.normal,c),Tt(e,e,i.normal)}_applyCenterOffsetView(e,i,r){const s=this.parameters.centerOffsetUnits!=="screen";return r!==e&&V(r,e),s&&(r[0]+=i[0],r[1]+=i[1],i[2]&&(at(K,r),Tt(r,r,B(K,K,i[2])))),r}_applyCenterOffsetNDC(e,i,r,s){const o=this.parameters.centerOffsetUnits!=="screen";return s!==e&&V(s,e),o||(s[0]+=i[0]/r.fullWidth*2,s[1]+=i[1]/r.fullHeight*2),s}_applyPolygonOffsetNDC(e,i,r,s){const o=this.parameters.shaderPolygonOffset;if(e!==s&&V(s,e),o){const a=r.aboveGround?1:-1,l=a*Math.sign(i[3]);s[2]-=(l||a)*o}return s}set visible(e){this._visible=e}get visible(){const{color:e,outlineSize:i,outlineColor:r}=this.parameters,s=e[3]>=U||i>=U&&r[3]>=U;return this._visible&&s}createGLMaterial(e){return new Pr(e)}calculateRelativeScreenBounds(e,i,r=Ce()){return br(this.parameters,e,i,r),r[2]=r[0]+e[0],r[3]=r[1]+e[1],r}_getScreenScale(e,i){const r=e.attributes.get(_.FEATUREATTRIBUTE);if(r==null)return{scaleX:i,scaleY:i};const s=Fe(r.data,Ar);return li(Rt,this.parameters,s),{scaleX:Rt[0]*i,scaleY:Rt[1]*i}}}class Pr extends ci{constructor(e){super({...e,...e.material.parameters})}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.getTechnique(Tr,e)}}function br(t,e,i,r){r[0]=t.anchorPosition[0]*-e[0]+t.screenOffset[0]*i,r[1]=t.anchorPosition[1]*-e[1]+t.screenOffset[1]*i}function de(t,e,i,r){return mr(e)&&(e=ee(Cr,e)),Mi(r.normal,t,e),nt(r.normal,r.normal,i.viewInverseTransposeMatrix),r.cosAngle=xt(ve,Fr),r}function Mr(t){const e=t[0],i=t[1],r=t[2],s=t[3],o=t[4],a=t[5],l=t[6],c=t[7],h=t[8],m=1/Math.sqrt(e*e+i*i+r*r),v=1/Math.sqrt(s*s+o*o+a*a),x=1/Math.sqrt(l*l+c*c+h*h);return t[0]=e*m,t[1]=i*m,t[2]=r*m,t[3]=s*v,t[4]=o*v,t[5]=a*v,t[6]=l*x,t[7]=c*x,t[8]=h*x,t}function fe(t,e,i,r,s,o,a,l,c){let h=e-s-r[0]*c[0],m=h+r[0]+2*s,v=i-s-r[1]*c[1],x=v+r[1]+2*s;const w=l.distanceFieldBoundingBox;return l.textureIsSignedDistanceField&&w!=null&&(h+=r[0]*w[0],v+=r[1]*w[1],m-=r[0]*(1-w[2]),x-=r[1]*(1-w[3]),h-=o,m+=o,v-=o,x+=o),wt(me,e,i),Oi(tt,t,me,De(a)),tt[0]>h&&tt[0]<m&&tt[1]>v&&tt[1]<x}const Dt=new _r,M=R(),K=R(),C=G(),ve=R(),ge=R(),tt=yt(),me=yt(),At=ie(),Cr=ie(),Dr=$(),z=R(),Rt=R(),Ar=G(),Et={normal:ve,cosAngle:0},Rr=1,Er=2,E=[0,0],Fr=Ae(0,0,1);class zr extends hi{constructor(){super(...arguments),this.renderOccluded=pi.Occlude,this.isDecoration=!1,this.color=vt(1,1,1,1),this.polygonOffset=!1,this.anchorPosition=Wt(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.outlineColor=vt(1,1,1,1),this.outlineSize=0,this.distanceFieldBoundingBox=G(),this.rotation=0,this.hasRotation=!1,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.occludedFragmentFade=!1,this.horizonCullingEnabled=!1,this.centerOffsetUnits="world",this.drawAsLabel=!1,this.depthEnabled=!0,this.isFocused=!0,this.focusEffect="none",this.draped=!1,this.isLabel=!1}}const _e=Ii().vec3f(_.POSITION).vec3f(_.NORMAL).vec2f(_.UV0).vec4u8(_.COLOR).vec2f(_.SIZE).f32(_.ROTATION).vec4f(_.CENTEROFFSETANDDISTANCE).vec4f(_.FEATUREATTRIBUTE),jr=_e.clone().vec4u8(_.OBJECTANDLAYERIDCOLOR);class Ir{constructor(){this.vertexBufferLayout=ui()?jr:_e}elementCount(e){return 6*e.get(_.POSITION).indices.length}write(e,i,r,s,o,a){di(r.get(_.POSITION),e,o.position,a,6),fi(r.get(_.NORMAL),i,o.normal,a,6);const l=r.get(_.UV0)?.data;let c=0,h=0,m=1,v=1;l&&l.length>=4&&(c=l[0],h=l[1],m=l[2],v=l[3]),m=Math.min(1.99999,m+1),v=Math.min(1.99999,v+1);let x=r.get(_.POSITION).indices.length,w=a;const d=o.uv0;for(let D=0;D<x;++D)d.set(w,0,c),d.set(w,1,h),w++,d.set(w,0,m),d.set(w,1,h),w++,d.set(w,0,m),d.set(w,1,v),w++,d.set(w,0,m),d.set(w,1,v),w++,d.set(w,0,c),d.set(w,1,v),w++,d.set(w,0,c),d.set(w,1,h),w++;vi(r.get(_.COLOR),4,o.color,a,6);const{data:S,indices:A}=r.get(_.SIZE);x=A.length;const F=o.size;w=a;for(let D=0;D<x;++D){const j=S[2*A[D]],N=S[2*A[D]+1];for(let q=0;q<6;++q)F.set(w,0,j),F.set(w,1,N),w++}if(gi(r.get(_.ROTATION),o.rotation,a,6),r.get(_.CENTEROFFSETANDDISTANCE)?Nt(r.get(_.CENTEROFFSETANDDISTANCE),o.centerOffsetAndDistance,a,6):Ut(o.centerOffsetAndDistance,a,6*x),r.get(_.FEATUREATTRIBUTE)?Nt(r.get(_.FEATUREATTRIBUTE),o.featureAttribute,a,6):Ut(o.featureAttribute,a,6*x),s!=null){const D=r.get(_.POSITION)?.indices;if(D){const j=D.length,N=o.getField(_.OBJECTANDLAYERIDCOLOR,ji);mi(s,N,j,a,6)}}}}const Lr=Object.freeze(Object.defineProperty({__proto__:null,build:pe,calculateAnchorPosition:J},Symbol.toStringTag,{value:"Module"}));export{Zi as a,Or as b,Yi as c,Pt as d,W as e,hr as i,dr as o,fr as r,Qi as s,ur as u};
