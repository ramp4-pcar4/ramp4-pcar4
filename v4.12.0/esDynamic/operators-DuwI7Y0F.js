import{aV as Ne,bP as k,it as Yn,$ as B,bq as Vn,dz as R,dw as lt,dx as mt,dy as K,cE as gt,cF as pt,cG as ft}from"./main-DnzmeE4U.js";import{t as ee,s as X}from"./SimpleGeometryCursor-DSF_YyIm.js";import{ac as Xn,b as d,j as Q,a as f,H as te,aZ as F,y as Bn,u as zn,c as ne,bk as Ln,a3 as De,d as U,ax as re,ah as oe,bl as ht,bm as se,bn as ie,bo as ue,bp as kn,bh as Se,bq as Fn,w as $n,ad as Un,v as Wn,e as Y,n as M,r as yt,br as z,a$ as q,bs as ae,aw as ce,bb as dt,ay as Hn,bt as _t,L as xt,bu as Zn,bv as le,B as Qn,V as Jn,f as Kn,P as L,h as Ce,bw as er,bx as tr,by as we,bz as nr,b3 as rr,ab as or,bA as sr,bB as ir,bC as ur,bD as ar,bE as cr,a2 as vt,C as lr}from"./ProjectionTransformation-BocI5WO-.js";import{getSpatialReference as _,toGeometry as E,fromGeometry as g,toPolygon as bt,fromSpatialReference as D,toPoint as me,fromExtent as Pt,fromPolyline as mr,fromPoint as Ee}from"./apiConverter-CjySd46F.js";import{u as gr,a as pr,i as fr,c as hr,s as yr}from"./operatorGeodesicBuffer-CkCgXz8c.js";import{e as J}from"./geodeticCurveType-D_etKnbP.js";import{i as dr,a as _r,u as xr,c as vr,s as br}from"./operatorGeodeticDensify-ChMTJefg.js";import{x as Pr,f as Nr,l as Dr,P as Sr}from"./operatorBuffer-DDkLDz0-.js";import{X as Cr,M as wr,v as Er,_ as Mr}from"./operatorConvexHull-kc9DYEJz.js";import{t as Ir}from"./OperatorCrosses-C8KE8VFj.js";import{s as Tr,t as Gr,o as qr,u as Ar}from"./operatorIntersection-Dg9zL0zY.js";import{t as Or}from"./OperatorIntersects-BD2Yq74a.js";import{D as jr,w as Rr,j as Yr}from"./operatorOffset-DinOS4aJ.js";import{t as Vr}from"./OperatorOverlaps-BX6mIWAt.js";import{s as Xr,t as Br,o as zr,u as Lr}from"./operatorSimplify-BpGhOiFY.js";import{t as kr}from"./OperatorTouches-b2hnC2YH.js";import{s as Fr,o as $r,t as Ur}from"./operatorUnion-CT2aPw-_.js";import{t as Wr}from"./OperatorWithin-DhNVr_3R.js";const Hr={uniform:0,conformal:1,rigid:2,"rigid-motion":3,general:4},ge=e=>e.map(t=>new d(t.x,t.y));let Nt=class{constructor(){this.transform=new Xn}calculateErrors(e,t){const n=e.length,o=t.length;if(n!==o)throw new Error(`The input length (${n}) is not the same as output length (${o})`);const r=[];return{rms:this.transform.calculateErrors(n,ge(e),ge(t),r),errorsOut:r}}flipX(e,t){return this.transform.flipX(e,t),this}flipY(e,t){return this.transform.flipY(e,t),this}initializeFromControlPoints(e,t,n,o){const r=t.length,s=n.length;if(r!==s)throw new Error(`The input length (${r}) is not the same as output length (${s})`);this.transform.initializeFromControlPoints(Hr[e],r,ge(t),ge(n),o?.transform)}isIdentity(){return this.transform.isIdentity()}rotate(e,t,n){const o=Ne(e);return t!=null&&n!=null?this.transform.rotateAngleAbout(o,new d(t,n)):this.transform.rotateAngle(o),this}scale(e,t){return this.transform.scale(e,t),this}setIdentity(){this.transform.setIdentity()}setSwapCoordinates(){return this.transform.setSwapCoordinates(),this}shear(e,t){return this.transform.shear(e,t),this}shift(e,t){return this.transform.shiftCoords(e,t),this}};const Zr=Object.freeze(Object.defineProperty({__proto__:null,default:Nt},Symbol.toStringTag,{value:"Module"}));let Qr=class{getOperatorType(){return 10303}supportsCurves(){return!0}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,n){return new Jr(e,t,n)}execute(e,t,n){const o=e.clone();return o.applyTransformation(t),o}},Jr=class extends ee{constructor(e,t,n){super(),this.m_index=-1,this.m_transformation=t.clone(),this.m_inputGeometryCursor=e}next(){let e;if(e=this.m_inputGeometryCursor.next()){Q(e),this.m_index=this.m_inputGeometryCursor.getGeometryID();const t=e.clone();return t.applyTransformation(this.m_transformation),t}return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}};const Me=new Qr;function Kr(e,t){return Me.execute(e,t,null)}function eo(e,t){const n=Me.executeMany(new X(e),t,null);return Array.from(n)}function to(){return Me.supportsCurves()}function Dt(e,t){const n=_(e);return E(Kr(g(e),t.transform),n)}function no(e,t){const n=e.map(g),o=_(e);return eo(n,t.transform).map(r=>E(r,o)).filter(k)}const ro=to(),oo=Object.freeze(Object.defineProperty({__proto__:null,execute:Dt,executeMany:no,supportsCurves:ro},Symbol.toStringTag,{value:"Module"}));function St(e,t={}){const{unit:n}=t;let o=g(e).calculateArea2D();if(o&&n){const r=_(e);if(r.isGeographic)throw new Error("Unable to convert from an angular area unit to a linear area unit.");const s=Yn(r);s!==n&&(s?o=B(o,s,n):(o=Math.sqrt(o),o*=Vn(r),o**=2,o=B(o,"square-meters",n)))}return o}const Ct=!0,so=Object.freeze(Object.defineProperty({__proto__:null,execute:St,supportsCurves:Ct},Symbol.toStringTag,{value:"Module"}));function io(e,t,n={}){const{unit:o}=n,r=_(e);return o&&(t=R(t,o,r)),bt(Nr(g(e),D(r),t),r)}function uo(e,t,n={}){let{maxDeviation:o=NaN,maxVerticesInFullCircle:r=96,union:s=!1,unit:u}=n;const i=_(e);u&&(t=t.map(c=>R(c,u,i)),o&&(o=R(o,u,i)));const a=e.map(g);return Dr(a,D(i),t,o,r,s).map(c=>bt(c,i)).filter(k)}const ao=Pr(),co=Object.freeze(Object.defineProperty({__proto__:null,execute:io,executeMany:uo,supportsCurves:ao},Symbol.toStringTag,{value:"Module"}));function lo(e,t){if(!e.isEmpty())switch(e.getGeometryType()){case f.enumPolygon:return wt(e);case f.enumPolyline:return go(e);case f.enumLine:case f.enumBezier:case f.enumEllipticArc:return po(e);case f.enumMultiPoint:return fo(e);case f.enumEnvelope:return e.getCenterXY();case f.enumPoint:return e.getXY();default:return d.construct(Number.NaN,Number.NaN)}return d.construct(Number.NaN,Number.NaN)}function mo(e,t){return wt(e,t)}function wt(e,t=-1){const n=new F(0),o=new F(0),r=e.getImpl();let s;const u=r.hasNonLinearSegments();let i;const a=r.getXY(0);if(t===-1){if(i=r.calculateArea2D(),i===0)return It(e);u&&(s=r.querySegmentIterator());for(let l=0,h=r.getPathCount();l<h;l++)Et(a,r,l,n,o),u&&Mt(a,s,n,o)}else{if(i=r.calculateRingArea2D(t),i===0)return It(e,t);u&&(s=r.querySegmentIterator(),s.resetToPath(t)),Et(a,r,t,n,o),u&&Mt(a,s,n,o)}const c=new d,p=new d;return c.setCoords(n.getResult(),o.getResult()),p.assign(c.mul(1/i).add(a)),p}function Et(e,t,n,o,r){const s=t.getPathStart(n),u=t.getPathEnd(n);if(u-s<3)return;const i=t.getAttributeStreamRef(0),a=i.readPoint2D(2*s),c=i.readPoint2D(2*(s+1));c.subThis(a);const p=new F(0),l=t.hasNonLinearSegments(),h=1/3,m=new d;for(let b=s+2;b<u;b++){i.queryPoint2D(2*b,m),m.subThis(a);const N=.5*m.crossProduct(c);l&&p.add(N);const P=h*N;o.add((c.x+m.x)*P),r.add((c.y+m.y)*P),c.setCoordsPoint2D(m)}const y=l?p.getResult():t.calculateRingArea2D(n),v=a.sub(e).mul(y);o.add(v.x),r.add(v.y)}function Mt(e,t,n,o){let r;for(t.nextPath()||te("centroid");(r=t.nextCurve())!==null;){const s=r.calculateWeightedAreaCentroid2D(e);n.add(s.x),o.add(s.y)}}function go(e){return Tt(e.getImpl())}function po(e){const t=e.calculateLength2D();return t===0?e.getStartXY():e.calculateWeightedCentroid2D().mul(1/t)}function fo(e){const t=new F(0),n=new F(0),o=e.getImpl(),r=o.getAttributeStreamRef(0),s=o.getPointCount(),u=new d;for(let a=0;a<s;a++)r.queryPoint2D(2*a,u),t.add(u.x),n.add(u.y);const i=new d;return i.setCoords(t.getResult(),n.getResult()),i.divThis(s)}function It(e,t=-1){return Tt(e.getImpl(),t)}function Tt(e,t=-1){const n=t===-1?e.calculateLength2D():e.calculatePathLength2D(t);if(n===0)return ho(e,t);const o=new F(0),r=new F(0),s=e.querySegmentIterator();for(t!==-1&&s.resetToPath(t);s.nextPath();){const i=s.getPathIndex(),a=e.getXY(e.getPathStart(i));for(;s.hasNextSegment();){const p=s.nextSegment(),l=p.calculateLength2D();if(l===0)continue;const h=p.calculateWeightedCentroid2D().sub(a.mul(l));o.add(h.x),r.add(h.y)}const c=a.mul(e.calculatePathLength2D(i));if(o.add(c.x),r.add(c.y),t!==-1)break}const u=new d;return u.setCoords(o.getResult(),r.getResult()),u.mul(1/n)}function ho(e,t=-1){if(t!==-1)return e.getXY(e.getPathStart(t));const n=new F(0),o=new F(0);for(let r=0;r<e.getPathCount();++r){const s=e.getXY(e.getPathStart(r));n.add(s.x),o.add(s.y)}return d.construct(n.getResult(),o.getResult()).mul(1/e.getPathCount())}let yo=class{getOperatorType(){return 10205}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}execute(e,t){return lo(e)}};const Gt=new yo;function qt(e){const t=Gt.execute(g(e),null);return me(t,_(e))}const At=Gt.supportsCurves(),_o=Object.freeze(Object.defineProperty({__proto__:null,execute:qt,supportsCurves:At},Symbol.toStringTag,{value:"Module"})),Ie=new Bn;function xo(e,t,n){return Ie.execute(e,t,n,null)}function vo(e,t,n){const o=Ie.executeMany(new X(e),t,n,null);return Array.from(o)}function bo(){return Ie.supportsCurves()}function Ot(e,t){const n=_(e),o=Pt(t).asEnvelope2D();return E(xo(g(e),o,D(n)),n)}function jt(e,t){const n=e.map(g),o=_(e),r=Pt(t).asEnvelope2D();return vo(n,r,D(o)).map(s=>E(s,o))}const Rt=bo(),Po=Object.freeze(Object.defineProperty({__proto__:null,execute:Ot,executeMany:jt,supportsCurves:Rt},Symbol.toStringTag,{value:"Module"})),Te=new zn;function No(e){const t=_(e);return Te.accelerateGeometry(g(e),D(t),1)}function Do(e,t){return Te.execute(g(e),g(t),D(e.spatialReference),null)}const So=Te.supportsCurves(),Co=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:No,execute:Do,supportsCurves:So},Symbol.toStringTag,{value:"Module"}));function wo(e){const t=_(e);return E(wr(g(e)),t)}function Eo(e,t={}){const{merge:n=!1}=t,o=e.map(g),r=_(e);return Er(o,n).map(s=>E(s,r))}function Mo(e){return Mr(g(e))}const Io=Cr(),To=Object.freeze(Object.defineProperty({__proto__:null,execute:wo,executeMany:Eo,isConvex:Mo,supportsCurves:Io},Symbol.toStringTag,{value:"Module"})),Ge=new Ir;function Go(e){const t=_(e);return Ge.accelerateGeometry(g(e),D(t),1)}function qo(e,t){return Ge.execute(g(e),g(t),D(e.spatialReference),null)}const Ao=Ge.supportsCurves(),Oo=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Go,execute:qo,supportsCurves:Ao},Symbol.toStringTag,{value:"Module"}));var Yt=Fn;function $(e,t){return{m_geometry:e,m_side:t}}function jo(e,t,n,o,r,s){if(t.isEmpty()){const a=$(t,0);return void r.push(a)}if(n.isEmpty()){const a=$(t,0);return void r.push(a)}const u=[],i=new oe;{const a=i.createGeometryUserIndex(),c=i.addGeometry(t),p=i.addGeometry(n),l=new ht(s);let h=0,m=null;if(i.hasCurves()){m=new Yt;const y=i.getEnvelope2D(s);h=se(o.total());const v=ie(o.total(),y);ue(i,v,o.total(),12e3,m,null,s)}i.dbgVerifyCurves(),l.setEditShapeCrackAndCluster(i,o),l.cut(e,a,c,p,u);for(const y of u){m!==null&&m.stitchCurves(i,y,h,!1);const v=$(i.getGeometry(y),kn(i.getGeometryUserIndex(y,a)));r.push(v)}m!==null&&m.clearStitcher(i)}}function Ro(e,t,n,o,r,s){if(t.isEmpty()){const a=$(t,0);return void r.push(a)}if(n.isEmpty()){const a=$(t,0);return void r.push(a)}const u=[],i=new oe;{const a=i.createGeometryUserIndex(),c=i.addGeometry(t),p=i.addGeometry(n),l=new ht(s);let h=0,m=null;if(i.hasCurves()){m=new Yt;const P=i.getEnvelope2D(s);h=se(o.total());const w=ie(o.total(),P);ue(i,w,o.total(),12e3,m,null,s)}i.dbgVerifyCurves(),l.setEditShapeCrackAndCluster(i,o),l.cut(!1,a,c,p,u),m!==null&&m.stitchCurves(i,Se,h,!0);let y=i.getGeometry(c);const v=new U,b=new U,N=[];for(let P=0;P<u.length;P++){let w=null;{const S=new oe,C=S.addGeometry(y),G=S.addGeometry(i.getGeometry(u[P]));if(S.hasCurves()){const j=S.getEnvelope2D(s);h=se(o.total());const x=ie(o.total(),j);ue(S,x,o.total(),12e3,m,null,s)}l.setEditShapeCrackAndCluster(S,o);const O=l.intersection(C,G);if(m!==null&&m.stitchCurves(S,Se,h,!0),w=S.getGeometry(O),w.isEmpty())continue;const V=i.getGeometryUserIndex(u[P],a);V===2?v.add(w,!1):V===1?b.add(w,!1):N.push(w)}{const S=new oe,C=S.addGeometry(y),G=S.addGeometry(i.getGeometry(u[P]));if(S.hasCurves()){const V=S.getEnvelope2D(s);h=se(o.total());const j=ie(o.total(),V);ue(S,j,o.total(),12e3,m,null,s)}l.setEditShapeCrackAndCluster(S,o);const O=l.difference(C,G);m!==null&&m.stitchCurves(S,Se,h,!0),y=S.getGeometry(O)}}if(!y.isEmpty()&&u.length>0&&N.push(y),v.isEmpty()&&b.isEmpty())return;if(!v.isEmpty()){const P=$(v,1);r.push(P)}if(!b.isEmpty()){const P=$(b,2);r.push(P)}for(let P=0,w=N.length;P<w;++P){const S=$(N[P],3);r.push(S)}}}let Yo=class{getOperatorType(){return 10005}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}execute(e,t,n,o,r){return new Vo(e,t,n,o,r)}},Vo=class extends ee{constructor(e,t,n,o,r){super(),this.m_cutIndex=-1,this.m_cuts=[],this.m_progressTracker=r,this.m_cuttee=t.clone(),this.m_cutter=new ne({copy:n}),this.m_bConsiderTouch=e;const s=Ln(t,n);this.m_tolerance=De(o,s,!0)}next(){return this.m_cutIndex===-1&&this.generateCuts(),++this.m_cutIndex<this.m_cuts.length?this.m_cuts[this.m_cutIndex]:null}getGeometryID(){return this.m_cutIndex}tock(){return!0}getRank(){return 1}generateCuts(){switch(this.m_cuttee.getGeometryType()){case f.enumPolyline:this.generatePolylineCuts();break;case f.enumPolygon:this.generatePolygonCuts()}}generatePolylineCuts(){const e=new ne,t=new ne,n=new ne;this.m_cuts.length=0,this.m_cuts.push(e),this.m_cuts.push(t);const o=[];jo(this.m_bConsiderTouch,this.m_cuttee,this.m_cutter,this.m_tolerance,o,this.m_progressTracker);for(let r=0;r<o.length;r++){const s=o[r];s.m_side===1?e.add(s.m_geometry,!1):s.m_side===2||s.m_side===4?t.add(s.m_geometry,!1):s.m_side===3?this.m_cuts.push(s.m_geometry):s.m_side===0?n.add(s.m_geometry,!1):te("")}n.isEmpty()||e.isEmpty()&&t.isEmpty()&&!(this.m_cuts.length>=3)||this.m_cuts.push(n),e.isEmpty()&&t.isEmpty()&&this.m_cuts.length<3&&(this.m_cuts.length=0)}generatePolygonCuts(){const e=new U,t=new U,n=new U;this.m_cuts.length=0,this.m_cuts.push(e),this.m_cuts.push(t);const o=[];Ro(this.m_bConsiderTouch,this.m_cuttee,this.m_cutter,this.m_tolerance,o,this.m_progressTracker);for(let r=0;r<o.length;r++){const s=o[r];s.m_side===1?e.add(s.m_geometry,!1):s.m_side===2?t.add(s.m_geometry,!1):s.m_side===3?this.m_cuts.push(s.m_geometry):s.m_side===0?n.add(s.m_geometry,!1):te("")}re(n.isEmpty()||o.length===1),e.isEmpty()&&t.isEmpty()&&this.m_cuts.length<3&&(this.m_cuts.length=0)}};const Vt=new Yo;function Xo(e,t,n){const o=Vt.execute(!0,e,t,n,null);return Array.from(o)}function Bo(){return Vt.supportsCurves()}function Xt(e,t){const n=_(e);return Xo(g(e),mr(t),D(n)).map(o=>E(o,n)).filter(k)}const Bt=Bo(),zo=Object.freeze(Object.defineProperty({__proto__:null,execute:Xt,supportsCurves:Bt},Symbol.toStringTag,{value:"Module"})),qe=new $n;function Lo(e,t,n,o){return qe.execute(e,t,n,o,null)}function ko(e,t,n,o){const r=qe.executeMany(new X(e),t,n,o,null);return Array.from(r)}function Fo(){return qe.supportsCurves()}function zt(e,t,n={}){let{maxAngleInDegrees:o=0,maxDeviation:r=0,unit:s}=n;const u=_(e);return s&&(t=R(t,s,u),r&&(r=R(r,s,u))),E(Lo(g(e),t,r,Ne(o)),u)}function Lt(e,t,n={}){let{maxAngleInDegrees:o=0,maxDeviation:r=0,unit:s}=n;const u=e.map(g),i=_(e);return s&&(t=R(t,s,i),r&&(r=R(r,s,i))),ko(u,t,r,Ne(o)).map(a=>E(a,i)).filter(k)}const kt=Fo(),$o=Object.freeze(Object.defineProperty({__proto__:null,execute:zt,executeMany:Lt,supportsCurves:kt},Symbol.toStringTag,{value:"Module"})),Ae=new Un;function Uo(e,t,n){return Ae.execute(e,t,n,null)}function Wo(e,t,n){const o=Ae.executeMany(new X(e),new X([t]),n,null);return Array.from(o)}function Ho(){return Ae.supportsCurves()}function Ft(e,t){const n=_(e);return E(Uo(g(e),g(t),D(n)),n)}function $t(e,t){const n=e.map(g),o=_(e);return Wo(n,g(t),D(o)).map(r=>E(r,o))}const Ut=Ho(),Zo=Object.freeze(Object.defineProperty({__proto__:null,execute:Ft,executeMany:$t,supportsCurves:Ut},Symbol.toStringTag,{value:"Module"})),Oe=new Wn;function Qo(e){const t=_(e);return Oe.accelerateGeometry(g(e),D(t),1)}function Jo(e,t){return Oe.execute(g(e),g(t),D(e.spatialReference))}const Ko=Oe.supportsCurves(),es=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Qo,execute:Jo,supportsCurves:Ko},Symbol.toStringTag,{value:"Module"}));function je(){return{outPoint:new d,index:-1,t:Number.NaN}}function pe(e,t,n){return{outPoint:e.clone(),index:t,t:n}}function I(e,t,n,o){e.outPoint.assign(t),e.index=n,e.t=o}function W(e,t){e.outPoint.assign(t.outPoint),e.index=t.index,e.t=t.t}function Wt(e,t,n,o){e.index=n,e.t=o,t.queryCoord2D(e.t,e.outPoint)}function fe(e,t){const n=je();W(n,e),W(e,t),W(t,n)}function ts(e,t,n,o,r,s){if(e.getGeometryType()===f.enumPolygon){for(;o.nextPath();)if(o.hasNextSegment()){const u=o.nextSegment();if(z(e,u.getEndXY(),0)!==0)return I(r,u.getEndXY(),-1,Number.NaN),I(s,u.getEndXY(),-1,Number.NaN),!0}o.resetToFirstPath()}if(t.getGeometryType()===f.enumPolygon){for(;n.nextPath();)if(n.hasNextSegment()){const u=n.nextSegment();if(z(t,u.getEndXY(),0)!==0)return I(r,u.getEndXY(),-1,Number.NaN),I(s,u.getEndXY(),-1,Number.NaN),!0}n.resetToFirstPath()}return!1}function ns(e){const t=e.getPathCount(),n=xt(e.getSegmentCount(),0);let o=0;for(let r=0;r<t;++r){const s=o+e.getSegmentCountPath(r);for(let u=o,i=e.getPathStart(r);u<s;++u,++i)n[u]=i;o=s}return Zn(e.getPointCount(),n),n}function Ht(e,t){return!!Number.isNaN(t)||e<=t}function he(e){const t=new U;return t.addEnvelope(e,!1),t}let rs=class{constructor(e,t){if(this.m_env2DgeometryA=null,this.m_env2DgeometryB=null,this.m_progressCounter=0,this.m_progressTracker=t,this.m_maxSqrDistance=e*e,this.m_maxDistance=e,this.m_bIsNearCalc=!1,Number.isNaN(this.m_maxDistance)?this.m_maxDistance=Number.POSITIVE_INFINITY:this.m_maxDistance=e,this.m_maxSqrDistance=this.m_maxDistance*this.m_maxDistance,Number.isFinite(this.m_maxSqrDistance)){let n=Math.sqrt(this.m_maxSqrDistance);for(;n<this.m_maxDistance;)this.m_maxSqrDistance*=1+Number.EPSILON,n=Math.sqrt(this.m_maxSqrDistance)}}calculate(e,t,n,o){if((e.getGeometryType()!==Y.type||t.getGeometryType()!==Y.type)&&(this.m_env2DgeometryA=new M,this.m_env2DgeometryB=new M,e.queryEnvelope(this.m_env2DgeometryA),t.queryEnvelope(this.m_env2DgeometryB),!Ht(this.m_env2DgeometryA.distanceFromEnvelope(this.m_env2DgeometryB),this.m_maxDistance)))return Number.POSITIVE_INFINITY;const r=pe(new d,le(),Number.NaN),s=pe(new d,le(),Number.NaN),u=this._ExecuteBruteForce(e,t,r,s);return Ht(u,this.m_maxDistance)?(n!==null&&W(n,r),o!==null&&W(o,s),u):Number.POSITIVE_INFINITY}isNear(e,t){if(this.m_bIsNearCalc=!0,e.isEmpty()||t.isEmpty())return!1;if(e===t)return!0;let n=!0;if(e.getGeometryType()!==Y.type&&e.getGeometryType()!==yt.type||t.getGeometryType()!==Y.type&&t.getGeometryType()!==yt.type||(n=!1),n){if(this.m_env2DgeometryA=new M,this.m_env2DgeometryB=new M,e.queryEnvelope(this.m_env2DgeometryA),t.queryEnvelope(this.m_env2DgeometryB),!(this.m_env2DgeometryA.sqrMaxMinDistanceEnvelope(this.m_env2DgeometryB)>this.m_maxSqrDistance))return!0;if(this.m_env2DgeometryA.sqrDistanceEnvelope(this.m_env2DgeometryB,null,null)>this.m_maxSqrDistance)return!1}const o=pe(new d,le(),Number.NaN),r=pe(new d,le(),Number.NaN);return this._ExecuteBruteForce(e,t,o,r)<=this.m_maxDistance}progress_(e=!1){}_ExecuteBruteForce(e,t,n,o){switch(e.getGeometryType()){case f.enumPoint:return this.distancePointGeometry(e,t,n,o);case f.enumMultiPoint:return this.distanceMultipointGeometry(e,t,n,o);case f.enumEnvelope:return this.distanceEnvelopeGeometry(e,t,n,o);case f.enumPolyline:case f.enumPolygon:return this.distanceMultipathGeometry(e,t,n,o);default:return Number.NaN}}distancePointGeometry(e,t,n,o){switch(t.getGeometryType()){case f.enumPoint:return this.distancePointPoint(e,t,n,o);case f.enumMultiPoint:return this.distancePointMultipoint(e,t,n,o);case f.enumPolyline:case f.enumPolygon:return this.distancePointMultipath(e,t,n,o);case f.enumEnvelope:return this.distancePointEnvelope(e,t,n,o);default:return Number.NaN}}distancePointPoint(e,t,n,o){const r=e.getXY(),s=t.getXY();return I(n,r,0,0),I(o,s,0,0),Math.sqrt(d.sqrDistance(r,s))}distancePointMultipoint(e,t,n,o){const r=e.getXY();let s=this.m_maxSqrDistance,u=s,i=!1;const a=t.getPointCount(),c=new d;for(let p=0;p<a;++p)if(t.queryXY(p,c),u=d.sqrDistance(r,c),this.m_bIsNearCalc){if(u<=s)return 0}else if(!(u>s)&&(!i&&u===s||u<s)&&(s=u,I(n,r,0,0),I(o,c,p,0),i=!0,s===0))return 0;return i?Math.sqrt(s):Number.POSITIVE_INFINITY}distancePointMultipath(e,t,n,o){const r=!this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB),s=e.getXY();if(!r&&t.getGeometryType()===f.enumPolygon&&z(t,s,0)!==0)return I(n,s,0,0),I(o,s,-1,Number.NaN),0;t.getImpl().getAccelerators();let u=this.m_maxSqrDistance,i=u,a=-1;const c=new M,p=t.querySegmentIterator();let l=!1;for(;p.nextPath();)for(;p.hasNextSegment();){const h=p.nextSegment();h.queryEnvelope(c);const m=c.sqrDistance(s);if(m>u||!this.m_bIsNearCalc&&l&&m===u)continue;a=h.getClosestCoordinate(s,!1);const y=h.getCoord2D(a);if(i=d.sqrDistance(s,y),this.m_bIsNearCalc){if(i<=u)return 0}else if(!(i>u)&&(!l||i<u)&&(u=i,I(n,s,0,0),I(o,y,p.getStartPointIndex(),a),l=!0,u===0))return 0}return l?Math.sqrt(u):Number.POSITIVE_INFINITY}distancePointEnvelope(e,t,n,o){const r=e.getXY();I(n,r,0,0),I(o,r,-1,Number.NaN);const s=t.asEnvelope2D();return s.contains(r)?0:Math.sqrt(s.sqrDistance(r,o.outPoint))}distanceMultipointGeometry(e,t,n,o){switch(t.getGeometryType()){case f.enumPoint:{this.m_env2DgeometryB=q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const r=this.distancePointMultipoint(t,e,o,n);return this.m_env2DgeometryB=q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),r}case f.enumMultiPoint:return this.distanceMultipointMultipoint(e,t,n,o,1,1);case f.enumPolyline:case f.enumPolygon:return this.distanceMultipointMultipath(e,t,n,o);case f.enumEnvelope:return this.distanceMultipointMultipath(e,he(t),n,o);default:return Number.NaN}}distanceMultipointMultipoint(e,t,n,o,r,s){const u={stack:[],error:void 0,hasError:!1};try{if(this.m_bIsNearCalc&&r===1&&s===1){const w=Math.trunc(ae(Math.sqrt(e.getPointCount())+1,1,ce())),S=Math.trunc(ae(Math.sqrt(t.getPointCount())+1,1,ce()));if((w>=4||S>=4)&&this.distanceMultipointMultipoint(e,t,n,o,w,S)<=this.m_maxSqrDistance)return 0}let i=this.m_maxSqrDistance;const a=[e],c=[t],p=this.swapGeometriesIfBGtA(a,c);p&&(this.m_env2DgeometryB=q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),s=q(r,r=s),fe(n,o)),lt(u,dt(()=>{fe(n,o),this.m_env2DgeometryB=q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB)},!p),!1);const l=a[0].getImpl(),h=c[0].getImpl(),m=l.getPointCount(),y=h.getPointCount(),v=y>1;let b=!1;const N=new d,P=new d;for(let w=0;w<m;w+=r){if(l.queryXY(w,N),v){const S=this.m_env2DgeometryB.sqrDistance(N);if(this.m_bIsNearCalc){if(S>i)continue;if(this.m_env2DgeometryB.sqrMaxMinDistance(N)<=i)return 0}else if(S>=i)continue}for(let S=0;S<y;S+=s){h.queryXY(S,P);const C=d.sqrDistance(N,P);if(this.m_bIsNearCalc){if(C<=i)return 0}else if(!(C>i||b&&C===i)&&(!b||C<i)&&(I(n,N,w,0),I(o,P,S,0),b=!0,i=C,i===0))return b?Math.sqrt(i):Number.POSITIVE_INFINITY}}return b?Math.sqrt(i):Number.POSITIVE_INFINITY}catch(i){u.error=i,u.hasError=!0}finally{mt(u)}}distanceMultipointMultipath(e,t,n,o){let r=!!this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB)&&t.getGeometryType()===f.enumPolygon;const s=t.querySegmentIterator();s.stripAttributes();const u=new M,i=new d;let a=this.m_maxSqrDistance;const c=e.getImpl(),p=c.getPointCount(),l=p>1;let h=!1;for(;s.nextPath();)for(;s.hasNextSegment();){const m=s.nextSegment();if(m.queryLooseEnvelope(u),l){const y=u.sqrDistanceEnvelope(this.m_env2DgeometryA,null,null);if(this.m_bIsNearCalc){if(y>a)continue}else if(y>a||h&&y===a)continue}for(let y=0;y<p;y++){if(c.queryXY(y,i),r&&z(t,i,0)!==0)return I(n,i,-1,Number.NaN),I(o,i,y,0),0;{const P=u.sqrDistance(i);if(this.m_bIsNearCalc){if(P>a)continue}else if(P>a)continue}const v=m.getClosestCoordinate(i,!1),b=m.getCoord2D(v);i.subThis(b);const N=i.sqrLength();if(this.m_bIsNearCalc){if(N<=a)return 0}else if(!(N>a)&&(!h||N<a)&&(a=N,I(n,c.getXY(y),y,0),I(o,b,s.getStartPointIndex(),v),h=!0,a===0))return 0}r=!1}return h?Math.sqrt(a):Number.POSITIVE_INFINITY}distanceEnvelopeGeometry(e,t,n,o){switch(t.getGeometryType()){case f.enumPoint:return this.distancePointEnvelope(t,e,o,n);case f.enumMultiPoint:{this.m_env2DgeometryB=q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const r=this.distanceMultipointMultipath(t,he(e),o,n);return this.m_env2DgeometryB=q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),r}case f.enumPolyline:case f.enumPolygon:return this.distanceMultipathMultipath(he(e),t,n,o);case f.enumEnvelope:return this.distanceEnvelopeEnvelope(e,t,n,o);default:return Number.NaN}}distanceEnvelopeEnvelope(e,t,n,o){n.t=Number.NaN,n.index=-1,o.t=Number.NaN,o.index=-1;const r=e.asEnvelope2D(),s=t.asEnvelope2D();return Math.sqrt(r.sqrDistanceEnvelope(s,n.outPoint,o.outPoint))}distanceMultipathGeometry(e,t,n,o){switch(t.getGeometryType()){case f.enumPoint:{this.m_env2DgeometryB=q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const r=this.distancePointMultipath(t,e,o,n);return this.m_env2DgeometryB=q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),r}case f.enumMultiPoint:{this.m_env2DgeometryB=q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const r=this.distanceMultipointMultipath(t,e,o,n);return this.m_env2DgeometryB=q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),r}case f.enumPolyline:case f.enumPolygon:return this.distanceMultipathMultipath(e,t,n,o);case f.enumEnvelope:return this.distanceMultipathMultipath(e,he(t),n,o);default:return Number.NaN}}distanceMultipathMultipath(e,t,n,o){const r={stack:[],error:void 0,hasError:!1};try{const s=[e],u=[t],i=this.swapGeometriesIfAGtB(s,u);i&&(this.m_env2DgeometryB=q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),fe(n,o)),lt(r,dt(()=>{fe(n,o),this.m_env2DgeometryB=q(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB)},!i),!1);const a=s[0],c=u[0],p=a.querySegmentIterator();p.stripAttributes();const l=c.querySegmentIterator();if(l.stripAttributes(),this.m_bIsNearCalc&&this.m_env2DgeometryA.sqrMaxMinDistanceEnvelope(this.m_env2DgeometryB)<=this.m_maxSqrDistance)return 0;if(this.m_bIsNearCalc){const C=Math.trunc(ae(Math.sqrt(a.getPointCount())+1,1,ce())),G=Math.trunc(ae(Math.sqrt(a.getPointCount())+1,1,ce()));if(this.distanceMultipointMultipoint(a,c,n,o,C,G)<=this.m_maxSqrDistance)return 0}if(this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB)){const C=je(),G=je();if(ts(a,c,p,l,C,G))return W(n,C),W(o,G),0}const h=ns(a),m=[],y=new Hn,v=new M,b=new M,N=new M;let P=this.m_maxSqrDistance,w=!0,S=!1;for(let C=0,G=h.length;C<G;++C){a.querySegment(h[C],y,!0);const O=y.get();if(O.queryEnvelope(v),!(v.sqrDistanceEnvelope(this.m_env2DgeometryB,null,null)>P)){if(this.m_bIsNearCalc&&v.sqrMaxDistanceEnvelope(this.m_env2DgeometryB)<=P)return 0;for(;l.nextPath();){if(this.progress_(),w)c.queryPathEnvelope(l.getPathIndex(),N),m[l.getPathIndex()]=N.clone();else if(v.sqrDistanceEnvelope(m[l.getPathIndex()],null,null)>P)continue;for(;l.hasNextSegment();){const V=l.nextSegment();if(V.queryEnvelope(b),v.sqrDistanceEnvelope(b,null,null)<=P){const j=!v.isIntersecting(b),x=[0],T=[0];let A=O.distance(V,j,x,T);if(A*=A,this.m_bIsNearCalc&&A<=this.m_maxSqrDistance)return 0;if(A<P||A===P&&h[C]<n.index){if(S=!0,Wt(n,O,h[C],x[0]),Wt(o,V,l.getStartPointIndex(),T[0]),A===0)return 0;P=A}}}}l.resetToFirstPath(),w=!1}}return S?Math.sqrt(P):Number.POSITIVE_INFINITY}catch(s){r.error=s,r.hasError=!0}finally{mt(r)}}swapGeometriesIfAGtB(e,t){return _t(e[0])>_t(t[0])&&(t[0]=q(e[0],e[0]=t[0]),!0)}swapGeometriesIfBGtA(e,t){return this.swapGeometriesIfAGtB(t,e)}},os=class{getOperatorType(){return 10100}supportsCurves(){return!0}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}execute(e,t,n){return this.executeEx(e,t,n,null,null,Number.NaN)}executeEx(e,t,n,o,r,s){if(e.isEmpty()||t.isEmpty())return Number.NaN;Q(e),Q(t);const u=e,i=t;Number.isNaN(s)&&(s=Number.POSITIVE_INFINITY);const a=new rs(s,n).calculate(u,i,o,r);return Number.isFinite(a)?a:Number.NaN}};const Zt=new os;function Qt(e,t,n={}){const{unit:o}=n;let r=Zt.execute(g(e),g(t),null);if(r&&o){const s=_(e);r=K(r,s,o)}return r}const Jt=Zt.supportsCurves(),ss=Object.freeze(Object.defineProperty({__proto__:null,execute:Qt,supportsCurves:Jt},Symbol.toStringTag,{value:"Module"}));let is=class extends Qn{getOperatorType(){return 2}execute(e,t,n,o){return Jn(e,t,n,3,o)}};const Re=new is;function Kt(e){const t=_(e);return Re.accelerateGeometry(g(e),D(t),1)}function en(e,t){return Re.execute(g(e),g(t),D(e.spatialReference),null)}const tn=Re.supportsCurves(),us=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Kt,execute:en,supportsCurves:tn},Symbol.toStringTag,{value:"Module"})),Ye=new Sr;function as(e,t,n){return Ye.execute(e,t,n,null)}function cs(e,t,n){const o=Ye.executeMany(new X(e),t,n,null);return Array.from(o)}function ls(){return Ye.supportsCurves()}function nn(e,t,n={}){const{removeDegenerateParts:o=!1,unit:r}=n,s=_(e);return r&&(t=R(t,r,s)),E(as(g(e),t,o),s)}function rn(e,t,n={}){const{removeDegenerateParts:o=!1,unit:r}=n,s=e.map(g),u=_(e);return r&&(t=R(t,r,u)),cs(s,t,o).map(i=>E(i,u)).filter(k)}const on=ls(),ms=Object.freeze(Object.defineProperty({__proto__:null,execute:nn,executeMany:rn,supportsCurves:on},Symbol.toStringTag,{value:"Module"}));let ye,Ve,Xe,Be,sn;function un(){return!!ye&&yr()}async function an(){if(!un()){const[e]=await Promise.all([import("./apiConverter-CjySd46F.js"),gr()]);ye=e.fromGeometry,Ve=e.fromSpatialReference,Xe=e.getSpatialReference,Be=e.toPolygon,sn=pr()}}function gs(e,t,n={}){let{curveType:o="geodesic",maxDeviation:r=NaN,unit:s}=n;s&&(t=B(t,s,"meters"),r&&(r=B(r,s,"meters")));const u=Xe(e);return Be(fr(ye(e),Ve(u),J[o],t,r),u)}function ps(e,t,n={}){let{curveType:o="geodesic",maxDeviation:r=NaN,union:s=!1,unit:u}=n;u&&(t=t.map(c=>B(c,u,"meters")),r&&(r=B(r,u,"meters")));const i=e.map(ye),a=Xe(e);return hr(i,Ve(a),J[o],t,r,s).map(c=>Be(c,a)).filter(k)}const fs=Object.freeze(Object.defineProperty({__proto__:null,execute:gs,executeMany:ps,isLoaded:un,load:an,get supportsCurves(){return sn}},Symbol.toStringTag,{value:"Module"}));let de;function cn(){return!!de&&ft()}async function hs(){if(!cn()){const[e,t]=await Promise.all([import("./OperatorGeodeticArea-fiTop2oa.js"),import("./ProjectionTransformation-BocI5WO-.js").then(n=>n.bF).then(n=>n.aG).then(({injectPe:n})=>n),gt()]);de=new e.OperatorGeodeticArea,t(pt)}}function ys(e,t,n){return de.execute(e,t,n,null)}function ds(){return de.supportsCurves()}let ze,ln,mn,Le;function ke(){return!!ze&&cn()}async function Fe(){if(!ke()){const[e]=await Promise.all([import("./apiConverter-CjySd46F.js"),hs()]);ze=e.fromGeometry,ln=e.fromSpatialReference,mn=e.getSpatialReference,Le=ds()}}function gn(e,t={}){const{curveType:n="geodesic",unit:o}=t,r=mn(e);let s=ys(ze(e),ln(r),J[n]);return s&&o&&(s=B(s,"square-meters",o)),s}const _s=Object.freeze(Object.defineProperty({__proto__:null,execute:gn,isLoaded:ke,load:Fe,get supportsCurves(){return Le}},Symbol.toStringTag,{value:"Module"}));let _e,$e,Ue,We,He;function Ze(){return!!_e&&br()}async function Qe(){if(!Ze()){const[e]=await Promise.all([import("./apiConverter-CjySd46F.js"),dr()]);_e=e.fromGeometry,$e=e.fromSpatialReference,Ue=e.getSpatialReference,We=e.toGeometry,He=_r()}}function pn(e,t,n={}){const{curveType:o="geodesic",unit:r}=n;r&&(t=B(t,r,"meters"));const s=Ue(e);return We(xr(_e(e),t,$e(s),J[o]),s)}function fn(e,t,n={}){const{curveType:o="geodesic",unit:r}=n;r&&(t=B(t,r,"meters"));const s=e.map(_e),u=Ue(e);return vr(s,t,$e(u),J[o]).map(i=>We(i,u))}const xs=Object.freeze(Object.defineProperty({__proto__:null,execute:pn,executeMany:fn,isLoaded:Ze,load:Qe,get supportsCurves(){return He}},Symbol.toStringTag,{value:"Module"}));let xe;function hn(){return!!xe&&ft()}async function vs(){if(!hn()){const[e,t]=await Promise.all([import("./OperatorGeodeticLength-Ki0Ymc4T.js"),import("./ProjectionTransformation-BocI5WO-.js").then(n=>n.bF).then(n=>n.aG).then(({injectPe:n})=>n),gt()]);xe=new e.OperatorGeodeticLength,t(pt)}}function bs(e,t,n){return xe.execute(e,t,n,null)}function Ps(){return xe.supportsCurves()}let Je,yn,dn,Ke;function et(){return!!Je&&hn()}async function tt(){if(!et()){const[e]=await Promise.all([import("./apiConverter-CjySd46F.js"),vs()]);Je=e.fromGeometry,yn=e.fromSpatialReference,dn=e.getSpatialReference,Ke=Ps()}}function _n(e,t={}){const{curveType:n="geodesic",unit:o}=t,r=dn(e);let s=bs(Je(e),yn(r),J[n]);return s&&o&&(s=B(s,"meters",o)),s}const Ns=Object.freeze(Object.defineProperty({__proto__:null,execute:_n,isLoaded:et,load:tt,get supportsCurves(){return Ke}},Symbol.toStringTag,{value:"Module"}));function Ds(e){const t=_(e);return Gr(g(e),D(t))}function Ss(e,t){const n=_(e);return E(qr(g(e),g(t),D(n)),n)}function Cs(e,t){const n=e.map(g),o=_(e);return Ar(n,g(t),D(o),7).map(r=>E(r,o)).filter(k)}const ws=Tr(),Es=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Ds,execute:Ss,executeMany:Cs,supportsCurves:ws},Symbol.toStringTag,{value:"Module"})),nt=new Or;function Ms(e){const t=_(e);return nt.accelerateGeometry(g(e),D(t),1)}function Is(e,t){return nt.execute(g(e),g(t),D(e.spatialReference),null)}const Ts=nt.supportsCurves(),Gs=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Ms,execute:Is,supportsCurves:Ts},Symbol.toStringTag,{value:"Module"}));function xn(){return H(new d,-1,Number.NaN)}function H(e,t,n){return{m_coordinate:e.clone(),m_vertexIndex:t,m_geometryIndex:0,m_distance:n,m_bRightSide:!1,isEmpty:qs}}function qs(){return Number.isNaN(this.m_distance)}function ve(e,t,n=-1,o=-1){if(e.isEmpty())return 3;const r=e.getGeometryType();if(Kn(r))return As(e,t,n,o);if(r===f.enumPolygon)return Os(e,t,n,o);if(r===f.enumPolyline)return js(e,t,n,o);if(r===f.enumEnvelope){const s=new M;return e.queryEnvelope(s),s.contains(t)?s.containsExclusive(t)?1:2:0}return 3}function As(e,t,n,o){if(n>=0||o>=0)return L("");if(e.isDegenerate(0))return e.getStartXY().equals(t)?2:3;if(!e.isCurve()){const a=d.orientationRobust(t,e.getStartXY(),e.getEndXY());return a<0?1:a>0?0:2}const r=e.getClosestCoordinate(t,!1),s=e.getTangent(r),u=e.getCoord2D(r),i=d.orientationRobust(t,u,u.add(s));return i<0?1:i>0?0:2}function Os(e,t,n,o){(n>=0||o>=0)&&L("");const r=new M;e.queryEnvelope(r);const s=z(e,t,0);return s===0?0:s===1?1:2}function js(e,t,n,o){(n<0&&o>=0||n>=0&&o<0)&&L("");const r=e.querySegmentIterator();if(n<0){let u=Number.MAX_VALUE,i=0;for(;r.nextPath();)for(;r.hasNextSegment();){const a=r.nextSegment(),c=a.getClosestCoordinate(t,!1),p=a.getCoord2D(c),l=d.sqrDistance(p,t);l<u?(i=1,n=r.getStartPointIndex(),o=r.getPathIndex(),u=l):l===u&&i++}if(i===0)return 3;if(i===1)return r.resetToVertex(n,o),ve(r.nextSegment(),t)}const s=Xs(t,r,n,o);if(s.i1!==-1&&s.i2===-1)return s.bRight1?1:0;if(s.i1!==-1&&s.i2!==-1){if(s.bRight1===s.bRight2)return s.bRight1?1:0;{r.resetToVertex(s.i1,-1);const u=r.nextSegment().getTangent(1);r.resetToVertex(s.i2,-1);const i=r.nextSegment().getTangent(0);return u.crossProduct(i)>=0?1:0}}return r.resetToVertex(n,o),ve(r.nextSegment(),t)}function Rs(e,t,n){for(e.resetToVertex(t,n);e.hasNextSegment();)if(!e.nextSegment().isDegenerate(0))return e.getStartPointIndex();for(e.resetToVertex(t,n);e.hasPreviousSegment();)if(!e.previousSegment().isDegenerate(0))return e.getStartPointIndex();return-1}function Ys(e,t){for(e.resetToVertex(t,-1),e.nextSegment();e.hasNextSegment();)if(!e.nextSegment().isDegenerate(0))return e.getStartPointIndex();return-1}function Vs(e,t){for(e.resetToVertex(t,-1);e.hasPreviousSegment();)if(!e.previousSegment().isDegenerate(0))return e.getStartPointIndex();return-1}function Xs(e,t,n,o){const r={i1:-1,i2:-1,bRight1:!1,bRight2:!1};if(r.i1=Rs(t,n,o),r.i1!==-1){t.resetToVertex(r.i1,-1);const s=t.nextSegment(),u=s.getClosestCoordinate(e,!1),i=s.getCoord2D(u),a=d.sqrDistance(i,e);{const c=i.clone();c.subThis(s.getStartXY());const p=e.clone();p.subThis(s.getStartXY()),r.bRight1=c.crossProduct(p)<0}if(r.i2=Ys(t,r.i1),r.i2!==-1){t.resetToVertex(r.i2,-1);const c=t.nextSegment(),p=c.getClosestCoordinate(e,!1),l=c.getCoord2D(p);if(d.sqrDistance(l,e)>a)r.i2=-1;else{const h=l.clone();h.subThis(c.getStartXY());const m=e.clone();m.subThis(c.getStartXY()),r.bRight2=h.crossProduct(m)<0}}if(r.i2===-1&&(r.i2=Vs(t,r.i1),r.i2!==-1)){t.resetToVertex(r.i2,-1);const c=t.nextSegment(),p=c.getClosestCoordinate(e,!1),l=c.getCoord2D(p);if(d.sqrDistance(l,e)>a)r.i2=-1;else{const h=l.clone();h.subThis(c.getStartXY());const m=e.clone();m.subThis(c.getStartXY()),r.bRight2=h.crossProduct(m)<0;const y=r.i1;r.i1=r.i2,r.i2=y;const v=r.bRight1;r.bRight1=r.bRight2,r.bRight2=v}}}return r}let Z=class{getOperatorType(){return 10500}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}getNearestCoordinate(e,t,n,o){if(t.isNAN()&&L("NAN xy coordinates are not allowed"),e.isEmpty())return xn();switch(e.getGeometryType()){case f.enumPoint:return this.pointGetNearestVertex(e,t);case f.enumMultiPoint:return this.multiVertexGetNearestVertex(e,t);case f.enumPolyline:case f.enumPolygon:return this.multiPathGetNearestCoordinate(e,t,n,o);default:Ce("")}}getNearestVertex(e,t){if(t.isNAN()&&L("NAN xy coordinates are not allowed"),e.isEmpty())return xn();switch(e.getGeometryType()){case f.enumPoint:return this.pointGetNearestVertex(e,t);case f.enumMultiPoint:case f.enumPolyline:case f.enumPolygon:return this.multiVertexGetNearestVertex(e,t);default:Ce("")}}getNearestVertices(e,t,n,o){if(o===0&&L(""),t.isNAN()&&L("NAN xy coordinates are not allowed"),e.isEmpty())return[];switch(e.getGeometryType()){case f.enumPoint:return this.pointGetNearestVertices(e,t,n,o);case f.enumMultiPoint:case f.enumPolyline:case f.enumPolygon:return this.multiVertexGetNearestVertices(e,t,n,o);default:Ce("")}}multiPathGetNearestCoordinate(e,t,n,o){if(e.getGeometryType()===f.enumPolygon&&n){const l=new M;e.queryEnvelope(l);const h=er(null,l,!1);let m;if(m=z(e,t,o?0:h),m!==0){const y=H(t,-1,0);return o&&(y.m_bRightSide=!0),y}}const r=e.querySegmentIterator(),s=new d;let u=-1,i=-1,a=Number.MAX_VALUE,c=0;for(;r.nextPath();)for(;r.hasNextSegment();){const l=r.nextSegment(),h=l.getClosestCoordinate(t,!1),m=l.getCoord2D(h),y=d.sqrDistance(m,t);y<a?(c=1,s.assign(m),u=r.getStartPointIndex(),i=r.getPathIndex(),a=y):y===a&&c++}u===-1&&L("");const p=H(s,u,Math.sqrt(a));if(o)if(e.getGeometryType()!==f.enumPolygon){let l=!1;if(c>1){const h=ve(e,t,u,i);l=h!==0&&h!==3}else{r.resetToVertex(u,i);const h=r.nextSegment();l=ve(h,t)!==0}p.m_bRightSide=l}else n||z(e,t,0)!==0&&(p.m_bRightSide=!0);return p}pointGetNearestVertex(e,t){const n=e.getXY(),o=d.distance(n,t);return H(n,0,o)}multiVertexGetNearestVertex(e,t){const n=e.getAttributeStreamRef(0),o=e.getPointCount();let r=-1;const s=new d;let u=Number.MAX_VALUE;const i=new d;for(let a=0;a<o;a++){n.queryPoint2D(2*a,i);const c=d.sqrDistance(i,t);c<u&&(s.assign(i),r=a,u=c)}return H(s,r,Math.sqrt(u))}pointGetNearestVertices(e,t,n,o){const r=[];if(o!==0){const s=n*n,u=e.getXY(),i=d.sqrDistance(u,t);i<=s&&r.push(H(u,0,Math.sqrt(i)))}return r}multiVertexGetNearestVertices(e,t,n,o){const r=[];if(o!==0){const s=e.getAttributeStreamRef(0),u=e.getPointCount();r.length=o+1;const i=n*n;for(let a=0;a<u;a++){const c=s.read(2*a),p=s.read(2*a+1),l=t.x-c,h=t.y-p,m=l*l+h*h;m<=i&&r.push(H(d.construct(c,p),a,Math.sqrt(m)))}r.sort((a,c)=>a.m_distance-c.m_distance)}return r.slice(0,o)}},Bs=class{getOperatorType(){return 10203}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}executeMany(e,t){return new vn(e,t)}execute(e,t){return new vn(null,t).labelPoint(e)}},vn=class extends ee{progress_(){}tock(){return!0}getRank(){return 1}constructor(e,t){super(),this.m_index=-1,this.m_progressCounter=0,this.m_progressTracker=t,this.m_inputGeoms=e}next(){const e=this.m_inputGeoms.next();return e?(Q(e),this.m_index=this.m_inputGeoms.getGeometryID(),this.labelPoint(e)):null}getGeometryID(){return this.m_index}labelPoint(e){if(e===null&&L("null pointer is not allowed"),e.getGeometryType()===f.enumPoint)return e;if(e.isEmpty())return new Y({vd:e.getDescription()});switch(e.getGeometryType()){case f.enumPolygon:return this.labelPointPolygon(e);case f.enumPolyline:return this.labelPointPolyline(e);case f.enumMultiPoint:return this.labelPointMultiPoint(e);case f.enumEnvelope:return this.labelPointEnvelope(e);default:L("geometry is not supported")}}labelPointPolygon(e){const t=new M;e.queryEnvelope(t);const n=De(null,t,!0).total();let o=null,r=e;if(e.hasNonLinearSegments()){const x=new U({copy:e}),T=tr(x,.25*n,n);re(T!==e),o=T,r=o}let s=0,u=0;for(let x=0,T=r.getPathCount();x<T;++x){const A=Math.abs(r.calculateRingArea2D(x));A>u&&(u=A,s=x)}const i=new d;if(Math.abs(u)<=2*n*n?i.setNAN():i.assign(mo(r,s)),Number.isNaN(i.x)){const x=new M;return r.queryPathEnvelope(s,x),new Y({pt:x.getCenter()})}if(r.getPointCount()<4)return new Y({x:i.x,y:i.y});const a=d.getNAN(),c=[a.clone(),a.clone(),a.clone(),a.clone()],p=[Number.NaN,Number.NaN,Number.NaN,Number.NaN],l=[Number.NaN,Number.NaN,Number.NaN,Number.NaN];let h=!1,m=new Z().getNearestCoordinate(r,i,!0,!1);if(m.m_distance===0&&(h=!0,c[0]=i,m=new Z().getNearestCoordinate(r,i,!1,!1),m.m_distance>.25*t.minDimension()*1.66666666))return new Y({x:i.x,y:i.y});p[0]=m.m_distance,l[0]=0;const y=new d;let v=!1,b=.25,N=-1;const P=new M;r.queryPathEnvelope(s,P);do{let x=Number.NaN;if(c[1]=this.calculateParacentroid_(r,we(P.xmin,P.xmax,b),n),c[1].isNAN()||(m=new Z().getNearestCoordinate(r,c[1],!1,!1),x=m.m_distance),x>n&&z(r,c[1],n)===1)v=!0,p[1]=x,l[1]=d.sqrDistance(c[1],i);else if(x>N&&(N=x,y.setCoordsPoint2D(c[1])),b-=.01,b<.1){if(!(N>=0))break;v=!0,p[1]=N,c[1]=y,l[1]=d.sqrDistance(c[1],i)}}while(!v);v=!1,b=.5,N=-1;let w=.01,S=1;do{let x=Number.NaN;if(c[2]=this.calculateParacentroid_(r,we(P.xmin,P.xmax,b),n),c[2].isNAN()||(m=new Z().getNearestCoordinate(r,c[2],!1,!1),x=m.m_distance),x>n&&z(r,c[2],n)===1)v=!0,p[2]=x,l[2]=d.sqrDistance(c[2],i);else if(x>N&&(N=x,y.setCoordsPoint2D(c[2])),b=.5+w*S,w+=.01,S*=-1,b<.3||b>.7){if(!(N>=0))break;v=!0,p[2]=N,c[2]=y,l[2]=d.sqrDistance(c[2],i)}}while(!v);v=!1,b=.75,N=-1;do{let x=Number.NaN;if(c[3]=this.calculateParacentroid_(r,we(P.xmin,P.xmax,b),n),c[3].isNAN()||(m=new Z().getNearestCoordinate(r,c[3],!1,!1),x=m.m_distance),x>n&&z(r,c[3],n)===1)v=!0,p[3]=x,l[3]=d.sqrDistance(c[3],i);else if(x>N&&(N=x,y.setCoordsPoint2D(c[3])),b+=.01,b>.9){if(!(N>=0))break;v=!0,p[3]=N,c[3]=y,l[3]=d.sqrDistance(c[3],i)}}while(!v);const C=[0,1,2,3],G=h?0:1;for(let x=G;x<4;x++)for(let T=G;T<3;T++){const A=l[T],ct=l[T+1];if(nr(A,ct)>0){const Rn=C[T];C[T]=C[T+1],C[T+1]=Rn,l[T]=ct,l[T+1]=A}}let O=G,V=0,j=0;for(let x=G;x<4;x++){switch(x){case 0:j=2*p[C[x]];break;case 1:j=1.66666666*p[C[x]];break;case 2:j=1.33333333*p[C[x]];break;case 3:j=p[C[x]]}j>V&&(V=j,O=C[x])}return re(!c[O].isNAN()),new Y({x:c[O].x,y:c[O].y})}labelPointPolyline(e){const t=new d;if(e.getPointCount()>2*e.getPathCount()){let n=-1,o=-Number.MAX_VALUE;for(let i=0,a=e.getPathCount();i<a;i++)if(e.getPathSize(i)>2){const c=e.calculatePathLength2D(i);c>o&&(o=c,n=i)}const r=e.getPathStart(n),s=e.getPathEnd(n),u=Math.trunc((r+s)/2);t.assign(e.getXY(u))}else{let n=-Number.MAX_VALUE;const o=e.querySegmentIterator();for(;o.nextPath();)if(o.hasNextSegment()){const r=o.nextSegment(),s=r.calculateLength2D();s>n&&(n=s,t.assign(r.getCoord2D(r.lengthToT(.5*s))))}}return new Y({x:t.x,y:t.y})}labelPointMultiPoint(e){const t=new M;e.queryEnvelope(t);const n=t.getCenter(),o=new Z().getNearestCoordinate(e,n,!1,!1).m_coordinate;return new Y({x:o.x,y:o.y})}labelPointEnvelope(e){const t=e.getCenterXY();return new Y({x:t.x,y:t.y})}calculateParacentroid_(e,t,n){const o=new M;e.queryEnvelope(o);const r=new d(t,0);let s=Number.MAX_VALUE,u=Number.MAX_VALUE,i=!1,a=!1;const c=new rr;c.setStartXYCoords(r.x,o.ymin-1),c.setEndXYCoords(r.x,o.ymax+1);const p=new M,l=new d,h=new d,m=or(d,2),y=e.querySegmentIterator();for(;y.nextPath();)for(;y.hasNextSegment();){const v=y.nextSegment();if(v.queryEnvelope(p),re(v.isMonotoneQuickAndDirty()),l.setCoordsPoint2D(c.getStartXY()),h.setCoordsPoint2D(c.getEndXY()),p.clipLine(l,h)===0||c.intersect(v,m,null,null,n)!==1)continue;const b=m[0].y;s>u?b<s&&(s=b,i=!0):b<u&&(u=b,a=!0)}return i&&a?r.y=(s+u)/2:r.setNAN(),r}};const rt=new Bs;function zs(e){return rt.execute(e,null)}function Ls(e){const t=rt.executeMany(new X(e),null);return Array.from(t)}function ks(){return rt.supportsCurves()}function bn(e){return me(zs(g(e)),_(e))}function Pn(e){const t=e.map(g),n=_(e);return Ls(t).map(o=>me(o,n))}const Nn=ks(),Fs=Object.freeze(Object.defineProperty({__proto__:null,execute:bn,executeMany:Pn,supportsCurves:Nn},Symbol.toStringTag,{value:"Module"}));function $s(e,t={}){const{unit:n}=t;let o=g(e).calculateLength2D();if(o&&n){const r=_(e);o=K(o,r,n)}return o}const Us=!0,Ws=Object.freeze(Object.defineProperty({__proto__:null,execute:$s,supportsCurves:Us},Symbol.toStringTag,{value:"Module"})),Dn={round:0,bevel:1,miter:2,square:3};function Hs(e,t,n={}){const{miterLimit:o=10,flattenError:r=0,joins:s="round",unit:u}=n,i=_(e);return u&&(t=R(t,u,i)),E(Rr(g(e),D(i),t,Dn[s],o,r),i)}function Zs(e,t,n={}){const{miterLimit:o=10,flattenError:r=0,joins:s="round",unit:u}=n,i=_(e);u&&(t=R(t,u,i));const a=e.map(g);return Yr(a,D(i),t,Dn[s],o,r).map(c=>E(c,i)).filter(k)}const Qs=jr(),Js=Object.freeze(Object.defineProperty({__proto__:null,execute:Hs,executeMany:Zs,supportsCurves:Qs},Symbol.toStringTag,{value:"Module"})),ot=new Vr;function Ks(e){const t=_(e);return ot.accelerateGeometry(g(e),D(t),1)}function ei(e,t){return ot.execute(g(e),g(t),D(e.spatialReference),null)}const ti=ot.supportsCurves(),ni=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Ks,execute:ei,supportsCurves:ti},Symbol.toStringTag,{value:"Module"}));function st(e,t,n=!1){const o=me(e.m_coordinate,_(t)),r=e.m_distance,s=e.isEmpty(),u=e.m_bRightSide;return{coordinate:o,distance:r,isEmpty:s,...n&&{isRightSide:u},vertexIndex:e.m_vertexIndex}}const be=new Z;function Sn(e,t,n={}){const{calculateLeftRightSide:o=!1,testPolygonInterior:r=!0,unit:s}=n,u=be.getNearestCoordinate(g(e),Ee(t).getXY(),r,o);if(s&&u.m_distance){const i=_(e);u.m_distance=K(u.m_distance,i,s)}return st(u,e,o)}function Cn(e,t,n={}){const{unit:o}=n,r=be.getNearestVertex(g(e),Ee(t).getXY());if(o&&r.m_distance){const s=_(e);r.m_distance=K(r.m_distance,s,o)}return st(r,e)}function wn(e,t,n,o,r={}){const{unit:s}=r,u=_(e);return s&&n&&(n=R(n,s,u)),be.getNearestVertices(g(e),Ee(t).getXY(),n,o).map(i=>(s&&i.m_distance&&(i.m_distance=K(i.m_distance,u,s)),st(i,e)))}const En=be.supportsCurves(),ri=Object.freeze(Object.defineProperty({__proto__:null,getNearestCoordinate:Sn,getNearestVertex:Cn,getNearestVertices:wn,supportsCurves:En},Symbol.toStringTag,{value:"Module"}));let oi=class{supportsCurves(){return!0}getOperatorType(){return 1}execute(e,t,n,o,r){return sr(e,t,n,o,r)}isValidDE9IM(e){return ir(e)===0}accelerateGeometry(e,t,n){return ur(e,t,n)}canAccelerateGeometry(e){return ar(e)}};const Pe=new oi;function Mn(e){const t=_(e);return Pe.accelerateGeometry(g(e),D(t),1)}function In(e,t,n){return Pe.execute(g(e),g(t),D(e.spatialReference),n,null)}function Tn(e){return Pe.isValidDE9IM(e)}const Gn=Pe.supportsCurves(),si=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:Mn,execute:In,isValidDE9IM:Tn,supportsCurves:Gn},Symbol.toStringTag,{value:"Module"}));function ii(e){const t=_(e);return E(Br(g(e),D(t),!1),t)}function ui(e){const t=e.map(g),n=_(e);return zr(t,D(n),!1).map(o=>E(o,n))}function ai(e){return Lr(g(e),D(_(e)),!1)}const ci=Xr(),li=Object.freeze(Object.defineProperty({__proto__:null,execute:ii,executeMany:ui,isSimple:ai,supportsCurves:ci},Symbol.toStringTag,{value:"Module"}));class mi{getOperatorType(){return 10003}supportsCurves(){return!0}accelerateGeometry(t,n,o){return!1}canAccelerateGeometry(t){return!1}executeMany(t,n,o,r){return new fi(t,n,o,r)}execute(t,n,o,r){const s=new X([t]),u=new X([n]),i=this.executeMany(s,u,o,r).next();return i||te("null output"),i}}function gi(e,t,n,o){const r=e.getDimension(),s=t.getDimension();if(r!==s)return r>s?e:t;if(e.isEmpty())return t;if(t.isEmpty())return e;const u=new M,i=new M,a=new M;e.queryEnvelope(u),t.queryEnvelope(i),a.setCoords({env2D:u}),a.mergeEnvelope2D(i);const c=De(n,a,!0),p=e.getGeometryType(),l=t.getGeometryType();return p===f.enumPoint&&l===f.enumPoint?pi(e,t,c):p===f.enumPoint&&l===f.enumMultiPoint?qn(t,e,c):p===f.enumMultiPoint&&l===f.enumPoint?qn(e,t,c):cr(e,t,n,o)}function pi(e,t,n,o){const r=vt(n),s=r*r,u=e.getXY(),i=t.getXY(),a=new lr({vd:e.getDescription()});return d.sqrDistance(u,i)>s&&(a.add(e),a.add(t)),a}function qn(e,t,n,o){const r=e.getImpl().getAttributeStreamRef(0),s=e.getPointCount(),u=t.getXY(),i=e.createInstance(),a=vt(n),c=new M;if(e.queryEnvelope(c),c.inflateCoords(a,a),c.contains(u)){const p=a*a;let l=!1;const h=xt(s,!1);for(let m=0;m<s;m++){const y=r.read(2*m),v=r.read(2*m+1),b=y-u.x,N=v-u.y;b*b+N*N<=p&&(l=!0,h[m]=!0)}if(l)for(let m=0;m<s;m++)h[m]||i.addPoints(e,m,m+1);else i.addPoints(e,0,s),i.add(t)}else i.addPoints(e,0,s),i.add(t);return i}class fi extends ee{constructor(t,n,o,r){super(),this.m_progressTracker=r,this.m_index=-1,this.m_inputGeoms=t,this.m_spatialReference=o,this.m_rightGeom=n.next(),this.m_bEmpty=!this.m_rightGeom,Q(this.m_rightGeom)}tock(){return!0}getRank(){return 1}next(){if(this.m_bEmpty)return null;const t=this.m_inputGeoms.next();return t?(Q(t),this.m_index=this.m_inputGeoms.getGeometryID(),gi(t,this.m_rightGeom,this.m_spatialReference,this.m_progressTracker)):null}getGeometryID(){return this.m_index}}const it=new mi;function hi(e,t,n){return it.execute(e,t,n,null)}function yi(e,t,n){const o=it.executeMany(new X(e),new X([t]),n,null);return Array.from(o)}function di(){return it.supportsCurves()}function An(e,t){const n=_(e);return E(hi(g(e),g(t),D(n)),n)}function On(e,t){const n=e.map(g),o=_(e);return yi(n,g(t),D(o)).map(r=>E(r,o)).filter(k)}const jn=di(),_i=Object.freeze(Object.defineProperty({__proto__:null,execute:An,executeMany:On,supportsCurves:jn},Symbol.toStringTag,{value:"Module"})),ut=new kr;function xi(e){const t=_(e);return ut.accelerateGeometry(g(e),D(t),1)}function vi(e,t){return ut.execute(g(e),g(t),D(e.spatialReference),null)}const bi=ut.supportsCurves(),Pi=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:xi,execute:vi,supportsCurves:bi},Symbol.toStringTag,{value:"Module"}));function Ni(e,t){const n=_(e);return E($r(g(e),g(t),D(n)),n)}function Di(e){const t=e.map(g),n=_(e);return E(Ur(t,D(n)),n)}const Si=Fr(),Ci=Object.freeze(Object.defineProperty({__proto__:null,execute:Ni,executeMany:Di,supportsCurves:Si},Symbol.toStringTag,{value:"Module"})),at=new Wr;function wi(e){const t=_(e);return at.accelerateGeometry(g(e),D(t),1)}function Ei(e,t){return at.execute(g(e),g(t),D(e.spatialReference),null)}const Mi=at.supportsCurves(),Ii=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:wi,execute:Ei,supportsCurves:Mi},Symbol.toStringTag,{value:"Module"}));function Ti(e,t,n,o){const r=new Nt().rotate(t,n,o);return Dt(e,r)}async function Gi(){await Promise.all([Fe(),an(),Qe(),tt()])}const qi=Object.freeze(Object.defineProperty({__proto__:null,area:so,buffer:co,centroid:_o,clip:Po,contains:Co,convexHull:To,crosses:Oo,cut:zo,densify:$o,difference:Zo,disjoint:es,distance:ss,equals:us,generalize:ms,geodesicBuffer:fs,geodeticArea:_s,geodeticDensify:xs,geodeticLength:Ns,intersection:Es,intersects:Gs,labelPoint:Fs,length:Ws,loadAll:Gi,offset:Js,overlaps:ni,proximity:ri,relate:si,rotate:Ti,simplify:li,symmetricDifference:_i,touches:Pi,union:Ci,within:Ii},Symbol.toStringTag,{value:"Module"}));export{Le as A,pn as B,fn as C,Ze as D,Qe as E,He as F,_n as G,et as H,tt as I,Ke as J,bn as K,Pn as L,Nn as M,Sn as N,Cn as O,wn as P,En as Q,Mn as R,In as S,Tn as T,Gn as U,An as V,On as W,jn as X,Zr as Y,oo as Z,qi as _,qt as a,jt as b,At as c,Xt as d,Bt as e,Lt as f,kt as g,Ft as h,$t as i,Ut as j,Qt as k,Jt as l,Rt as m,St as n,Kt as o,zt as p,en as q,tn as r,Ct as s,nn as t,Ot as u,rn as v,on as w,gn as x,ke as y,Fe as z};
