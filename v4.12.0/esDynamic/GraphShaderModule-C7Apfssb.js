import{E as Y}from"./MapView-BcnxJC0k.js";import{x as g,t as st,s as ot,n as Ve,cZ as ct}from"./main-DnzmeE4U.js";import{p as at,w as ut}from"./Texture-DXSFJsEu.js";import"./enums-DBi1-Mm2.js";import"./FramebufferObject-DQw0QX3p.js";import{r as dt}from"./ProgramTemplate-CBS0ERm4.js";import{i as ht}from"./ShaderBuilder-BkQM64Qp.js";let pt=class{constructor(){this.drawPhase=Y.MAP|Y.HITTEST|Y.HIGHLIGHT|Y.DEBUG}startup(){}shutdown(t){}};function lt(t){return t.split(" ").map((e,r)=>r>0?e.charAt(0).toUpperCase()+e.slice(1):e).join("")}function ft(t,e){const r=[];for(r.push(e);r.length;){const n=r.pop();if(typeof n=="object"&&!t.has(n.uid)){t.add(n.uid);for(const i of n.children)r.push(i)}}}let M=class Ke{constructor(){this.uid=Ke.NodeCount++,this._debugName=null,this._isMutable=!1,this.isImplicit=!1}get isMutable(){return this._isMutable}setMutable(){return this._isMutable=!0,this}setDebugName(e){return e=lt(e),this._debugName=e,this.isImplicit&&this.children[0]instanceof Ke&&this.children[0].setDebugName(e),this}get debugInfo(){return{name:this._debugName??""}}cloneInto(e){e._debugName=this._debugName,e._isMutable=this._isMutable,e.isImplicit=this.isImplicit,e.uid=this.uid}};function o(t){return typeof t=="object"?t.clone():t}M.NodeCount=0;let y=class extends M{constructor(){super(...arguments),this.shaderType="primitive-node"}},yt=class We extends M{constructor(e){super(),this.child=e,this.shaderType="scope-node"}get children(){return[this.child]}clone(){const e=new We(o(this.child));return this.cloneInto(e),e}},mt=class Xe extends M{constructor(e,r,n){super(),this.property=e,this.target=r,this.returnType=n,this.shaderType="property-access-node"}get children(){const e=[this.target];return typeof this.property!="string"&&e.push(this.property),e}clone(){const e=new Xe(this.property,o(this.target),this.returnType);return this.cloneInto(e),e}};class Ue extends M{constructor(e,r,n,i){super(),this.x=e,this.y=r,this.target=n,this.returnType=i,this.shaderType="property-access-2d-node"}get children(){return[this.target,this.x,this.y]}clone(){const e=new Ue(this.x,this.y,o(this.target),this.returnType);return this.cloneInto(e),e}}class Ae extends M{constructor(e,r,n){super(),this.condition=e,this.ifTrue=r,this.ifFalse=n,this.shaderType="condition-node"}get children(){return[this.condition,this.ifTrue,this.ifFalse]}clone(){const e=o(this.ifTrue),r=this.ifFalse?o(this.ifFalse):null,n=new Ae(this.condition,e,r);return this.cloneInto(n),n}}let gt=class Ye extends M{constructor(e,r,n,i){super(),this.captureList=e,this.returnType=r,this.generator=i,this.shaderType="block-node",n&&(this.subgraph=new yt(n))}get children(){return Object.keys(this.captureList).map(e=>this.captureList[e]).concat(this.subgraph??[])}clone(){const e={};for(const n in this.captureList)e[n]=o(this.captureList[n]);const r=new Ye(e,this.returnType,this.subgraph?o(this.subgraph.child):this.subgraph,this.generator);return this.cloneInto(r),r}},C=class et extends M{constructor(e,r,n,i,s,c=!1){super(),this.token=e,this._children=r,this.isInfix=n,this.isPropertyAccess=i,this.returnType=s,this.isTernary=c,this.shaderType="function-node"}get children(){return this._children}clone(){const e=new et(this.token,this._children.map(o),this.isInfix,this.isPropertyAccess,this.returnType,this.isTernary);return this.cloneInto(e),e}};var z,le,fe,ye,me,ge,be,we,ve,xe,_e,Ie,$e,Te;function bt(t){switch(t.type){case"bool":case"bvec2":case"bvec3":case"bvec4":return v;case"float":case"vec2":case"vec3":case"vec4":return p;case"int":case"ivec2":case"ivec3":case"ivec4":return f;case"uint":case"uvec2":case"uvec3":case"uvec4":return G;default:throw new Error("Unable to handle type")}}function wt(t){const e=[["float","vec2","vec3","vec4"],["int","ivec2","ivec3","ivec4"],["uint","uvec2","uvec3","uvec4"],["bool","bvec2","bvec3","bvec4"]];for(const r of e)if(r.includes(t))return r.map(n=>_t[n]);throw new Error("Unable to find type family")}function De(t){return new Proxy(t,{get(e,r){if(r==="constructor")return new Proxy(e.constructor,{construct:(n,i,s)=>De(new n(...i))});if(r in e)return e[r];if(typeof r=="string"){const n=wt(t.type);return _(t,r,n[r.length-1])}}})}function $(t){return new Proxy(t,{construct:(e,r,n)=>De(new e(...r))})}function vt(t){return new Proxy(t,{get(e,r){if(r in e)return e[r];if(typeof r=="string"){const n=parseInt(r,10);if(!isNaN(n))return _(t,`[${n}]`,t.elementType.constructor)}}})}function xt(t){return new Proxy(t,{construct:(e,r,n)=>vt(new e(...r))})}let Ne=class extends Error{},L=z=class extends y{constructor(t,e){super(),this.elementType=t,this.size=e,this.children=[],this.type="array"}clone(){const t=new z(this.elementType,this.size);return super.cloneInto(t),t}get(t,e){const r=new f(t),n=e!=null?new f(e):null;return n!=null?ue(this,r,n,bt(this.elementType.constructor)):_(this,r,this.elementType.constructor)}last(){return this.get(this.size-1)}first(){return this.get(0)}findIndex(t,e,r){return St(this,t,e,r)}glslFindIndex(t,e,r){return kt(this,t,e,r)}static ofType(t,e){const r={construct:(n,i)=>new z(new t,e)};return new Proxy(z,r)}};L.type="array",L=z=g([xt],L);class de extends y{constructor(e,r,n,i=!1){super(),this.elementType=e,this.xSize=r,this.ySize=n,this.isRowMajor=i,this.children=[],this.type="array-2d"}clone(){const e=new de(this.elementType,this.xSize,this.ySize,this.isRowMajor);return super.cloneInto(e),e}get size(){return this.xSize*this.ySize}get(e,r){return this.isRowMajor?this._getRowMajor(e,r):this._getColumnMajor(e,r)}_getColumnMajor(e,r){const n=new f(e);return _(this,new f(r).add(n.multiply(this.xSize)),this.elementType.constructor)}_getRowMajor(e,r){const n=new f(e),i=new f(r);return _(this,n.add(i.multiply(this.ySize)),this.elementType.constructor)}static ofType(e,r,n,i=!1){return new Proxy(L,{construct:(s,c)=>new de(new e,r,n,i)})}}de.type="array-2d";class he extends y{constructor(){super(...arguments),this.type="sampler2D",this.children=[]}clone(){const e=new he;return e.children=this.children.map(o),super.cloneInto(e),e}}he.type="sampler2D";let p=class j extends y{constructor(e){super(),this.type="float",this.children=[e]}clone(){const e=new j(o(this.children[0]));return super.cloneInto(e),e}multiply(e){return T(this,typeof e=="number"?m(e,j):e)}divide(e){return H(this,typeof e=="number"?m(e,j):e)}add(e){return U(this,typeof e=="number"?m(e,j):e)}subtract(e){return R(this,typeof e=="number"?m(e,j):e)}};p.type="float";let P=le=class extends y{constructor(t,e){super(),this.type="vec2",this.children=[t,e].filter(r=>r!=null)}clone(){const t=new le(o(this.children[0]),o(this.children[1]));return super.cloneInto(t),t}get 0(){return _(this,"[0]",p)}get 1(){return _(this,"[1]",p)}get 2(){throw new Ne}get 3(){throw new Ne}multiply(t){return T(this,typeof t=="number"?m(t,p):t)}divide(t){return H(this,typeof t=="number"?m(t,p):t)}add(t){return U(this,typeof t=="number"?m(t,p):t)}subtract(t){return R(this,typeof t=="number"?m(t,p):t)}};P.type="vec2",P=le=g([$],P);let K=fe=class extends y{constructor(t,e,r){super(),this.type="vec3",this.children=[t,e,r].filter(n=>n!=null)}get 0(){return _(this,"[0]",p)}get 1(){return _(this,"[1]",p)}get 2(){return _(this,"[2]",p)}get 3(){throw new Ne}clone(){const t=new fe(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(t),t}multiply(t){return T(this,typeof t=="number"?m(t,p):t)}divide(t){return H(this,typeof t=="number"?m(t,p):t)}add(t){return U(this,typeof t=="number"?m(t,p):t)}subtract(t){return R(this,typeof t=="number"?m(t,p):t)}};K.type="vec3",K=fe=g([$],K);let S=ye=class extends y{constructor(t,e,r,n){super(),this.type="vec4",this.children=[t,e,r,n].filter(i=>i!=null)}clone(){const t=new ye(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(t),t}get 0(){return _(this,"[0]",p)}get 1(){return _(this,"[1]",p)}get 2(){return _(this,"[2]",p)}get 3(){return _(this,"[3]",p)}multiply(t){return T(this,typeof t=="number"?m(t,p):t)}divide(t){return H(this,typeof t=="number"?m(t,p):t)}add(t){return U(this,typeof t=="number"?m(t,p):t)}subtract(t){return R(this,typeof t=="number"?m(t,p):t)}};S.type="vec4",S=ye=g([$],S);let G=me=class extends y{constructor(t){super(),this.type="uint",this.children=[t]}clone(){const t=new me(o(this.children[0]));return super.cloneInto(t),t}};G.type="uint",G=me=g([$],G);let ee=ge=class extends y{constructor(t,e){super(),this.type="uvec2",this.children=[t,e].filter(r=>r!=null)}clone(){const t=new ge(o(this.children[0]),o(this.children[1]));return super.cloneInto(t),t}};ee.type="uvec2",ee=ge=g([$],ee);let te=be=class extends y{constructor(t,e,r){super(),this.type="uvec3",this.children=[t,e,r].filter(n=>n!=null)}clone(){const t=new be(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(t),t}};te.type="uvec3",te=be=g([$],te);let re=we=class extends y{constructor(t,e,r,n){super(),this.type="uvec4",this.children=[t,e,r,n].filter(i=>i!=null)}clone(){const t=new we(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(t),t}};re.type="uvec4",re=we=g([$],re);class v extends y{constructor(e){super(),this.type="bool",this.children=[e]}and(e){return Re(this,e)}or(e){return He(this,e)}clone(){const e=new v(o(this.children[0]));return super.cloneInto(e),e}}v.type="bool";let ne=ve=class extends y{constructor(t,e){super(),this.type="bvec2",this.children=[t,e].filter(r=>r!=null)}all(){return ke(this)}any(){return Ce(this)}clone(){const t=new ve(o(this.children[0]),o(this.children[1]));return super.cloneInto(t),t}};ne.type="bvec2",ne=ve=g([$],ne);let ie=xe=class extends y{constructor(t,e,r){super(),this.type="bvec3",this.children=[t,e,r].filter(n=>n!=null)}all(){return ke(this)}any(){return Ce(this)}clone(){const t=new xe(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(t),t}};function m(t,e){return typeof t=="number"?new e(t):t}ie.type="bvec3",ie=xe=g([$],ie);let se=_e=class extends y{constructor(t,e,r,n){super(),this.type="bvec4",this.children=[t,e,r,n].filter(i=>i!=null)}all(){return ke(this)}any(){return Ce(this)}clone(){const t=new _e(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(t),t}};se.type="bvec4",se=_e=g([$],se);class f extends y{constructor(e){super(),this.type="int",this.children=[e]}multiply(e){return T(this,m(e,f))}add(e){return U(this,m(e,f))}subtract(e){return R(this,m(e,f))}divide(e){return H(this,m(e,f))}clone(){const e=new f(o(this.children[0]));return super.cloneInto(e),e}}f.type="int";let oe=Ie=class extends y{constructor(t,e){super(),this.type="ivec2",this.children=[t,e].filter(r=>r!=null)}clone(){const t=new Ie(o(this.children[0]),o(this.children[1]));return super.cloneInto(t),t}};oe.type="ivec2",oe=Ie=g([$],oe);let ce=$e=class extends y{constructor(t,e,r){super(),this.type="ivec3",this.children=[t,e,r].filter(n=>n!=null)}clone(){const t=new $e(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(t),t}};ce.type="ivec3",ce=$e=g([$],ce);let ae=Te=class extends y{constructor(t,e,r,n){super(),this.type="ivec4",this.children=[t,e,r,n].filter(i=>i!=null)}clone(){const t=new Te(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(t),t}};ae.type="ivec4",ae=Te=g([$],ae);class pe extends y{constructor(e,r,n,i){super(),this.type="mat2",this.children=[e,r,n,i]}clone(){const e=new pe(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(e),e}get(e,r){return ue(this,new f(e),new f(r),p)}multiply(e){return T(this,e)}}pe.type="mat2";class F extends y{static identity(){return new F(1,0,0,0,1,0,0,0,1)}static fromRotation(e){const r=Ze(e),n=qe(e);return new F(n,r,0,Le(r),n,0,0,0,1)}constructor(e,r,n,i,s,c,u,a,d){super(),this.type="mat3",this.children=[e,r,n,i,s,c,u,a,d]}add(e){return U(this,e)}multiply(e){return T(this,e)}get(e,r){return ue(this,new f(e),new f(r),p)}clone(){const e=new F(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]),o(this.children[4]),o(this.children[5]),o(this.children[6]),o(this.children[7]),o(this.children[8]));return super.cloneInto(e),e}}F.type="mat3";class V extends y{static identity(){return new V(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}constructor(e,r,n,i,s,c,u,a,d,h,l,x,E,k,W,X){super(),this.type="mat4",this.children=[e,r,n,i,s,c,u,a,d,h,l,x,E,k,W,X]}static fromColumns(e,r,n,i){return new V(e.x,e.y,e.z,e.w,r.x,r.y,r.z,r.w,n.x,n.y,n.z,n.w,i.x,i.y,i.z,i.w)}multiply(e){return T(this,e)}get(e,r){return ue(this,new f(e),new f(r),p)}clone(){const e=new V(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]),o(this.children[4]),o(this.children[5]),o(this.children[6]),o(this.children[7]),o(this.children[8]),o(this.children[9]),o(this.children[10]),o(this.children[11]),o(this.children[12]),o(this.children[13]),o(this.children[14]),o(this.children[15]));return super.cloneInto(e),e}}V.type="mat4";const _t={float:p,vec2:P,vec3:K,vec4:S,int:f,ivec2:oe,ivec3:ce,ivec4:ae,uint:G,uvec2:ee,uvec3:te,uvec4:re,bool:v,bvec2:ne,bvec3:ie,bvec4:se},It=(...t)=>new f(...t),ze=(...t)=>new p(...t),$t=(...t)=>new P(...t),Tt=(...t)=>new K(...t),Nt=(...t)=>new S(...t),Mt=(...t)=>new F(...t);function _(t,e,r){const n=new r(new mt(e,t,r));return n.isImplicit=!0,n}function ue(t,e,r,n){const i=new n(new Ue(e,r,t,n));return i.isImplicit=!0,i}function I(t,e,r,n=null){if(n){const s=new n,c=new n(new C(t,[e,r],!0,!1,s));return c.isImplicit=!0,c}if(e.type==="float"||e.type==="int"){const s=new r.constructor(new C(t,[e,r],!0,!1,r.constructor));return s.isImplicit=!0,s}if((e.type==="mat2"||e.type==="mat3"||e.type==="mat4")&&r.type!=="float"){const s=new r.constructor(new C(t,[e,r],!0,!1,r.constructor));return s.isImplicit=!0,s}const i=new e.constructor(new C(t,[e,r],!0,!1,e.constructor));return i.isImplicit=!0,i}function w(t,e,r=e.constructor){const n=new r(new C(t,[e],!1,!1,r));return n.isImplicit=!0,n}function N(t,e,r,n=e.constructor){const i=new n(new C(t,[e,r],!1,!1,n));return i.isImplicit=!0,i}function Me(t,e,r,n,i=e.constructor){const s=new i(new C(t,[e,r,n],!1,!1,i));return s.isImplicit=!0,s}function Le(t){return T(t,ze(-1))}function Se(t,e,r,n){return new e(new gt(t,e,r,n))}function St(t,e,r=0,n=t.size){const i=new f(r).setMutable().setDebugName("FindIndexIterator"),s=e(t.get(i)).setDebugName("FindIndexPredicate");return Se({iter:i},f,s,({out:c,iter:u,subgraph:a})=>`
${c} = -1;

for (; ${u} < ${n}; ${u}++) {

${a.body}

  if (${a.varName}) {
    ${c} = ${u};
    break;
  }

}
`).setDebugName("FindIndexBlock")}function kt(t,e,r=0,n=t.size){return Se({array:t},f,null,({out:i,array:s})=>`
${i} = -1;
for (int i = ${r}; i < ${n}; i++) {
  bool condition;
  ${e({array:s,i:"i",out:"condition"})}
  if (condition) {
    ${i} = i;
    break;
  }
}
`).setDebugName("GlslFindIndexBlock")}function Ge(t,e,r){const n=typeof e=="function"?e():e,i=typeof r=="function"?r():r,s=new n.constructor(new Ae(t,n,i));return s.isImplicit=!0,s}function Ct(...t){const e=t.map(([u,a])=>typeof a=="function"?[u,a()]:[u,a]),r=e[0][1].constructor,n=e.findIndex(u=>u[0]===!0);if(n===-1)throw new Error("A cond must have a fallthrough case with `true`/; ");const i=e.slice(0,n),s=e[n][1],c=new r(i.reduceRight((u,a)=>Ge(a[0],a[1],u),s));return c.isImplicit=!0,c}function T(t,e){return I("*",t,e)}function H(t,e){return I("/",t,e)}function U(t,e){return I("+",t,e)}function R(t,e){return I("-",t,e)}function Pt(t,e){return I("%",t,e)}function Ft(t,e){return I(">>",t,e)}function Et(t,e){return I("&",t,e)}function Kt(t,e){return I("==",t,e,v)}function Ut(t,e){return I("<",t,e,v)}function At(t,e){return I("<=",t,e,v)}function Ot(t,e){return I(">",t,e,v)}function Bt(t,e){return I(">=",t,e,v)}function He(...t){return t.length<=1?t[0]:t.slice(1).reduce((e,r)=>jt(e,r),t[0])}function jt(t,e){return I("||",t,e,v)}function Re(...t){return t.length<=1?t[0]:t.slice(1).reduce((e,r)=>Vt(e,r),t[0])}function Vt(t,e){return I("&&",t,e,v)}function Dt(t){return w("abs",t)}function ke(t){return w("all",t,v)}function Ce(t){return w("any",t,v)}function zt(t,e){return e==null?w("atan",t):N("atan",t,e,t.constructor)}function Lt(t){return w("ceil",t)}function Gt(t,e,r){return Me("clamp",t,e,r,t.constructor)}function qe(t){return w("cos",t)}function Ht(t,e){return N("distance",t,e,p)}function Rt(t,e){return N("dot",t,e,p)}function qt(t){return w("floor",t)}function Zt(t){return w("fract",t)}function Jt(t){return w("length",t,p)}function Qt(t,e){return N("max",t,e)}function Wt(t,e){return N("min",t,e)}function Xt(t,e,r){return Me("mix",t,e,r)}function Yt(t,e){return N("mod",t,e)}function er(t){return w("normalize",t)}function tr(t){return t.type==="bool"?w("!",t):w("not",t)}function rr(t,e){return N("pow",t,e)}function nr(t){return w("round",t)}function Ze(t){return w("sin",t)}function ir(t,e,r){return Me("smoothstep",t,e,r)}function sr(t){return w("sqrt",t)}function or(t,e){return N("step",t,e,e.constructor)}function cr(t,e){return N("texture",t,e,S)}const q=5;function b(t,e,r){const n=e.split(`
`);for(const i of n)if(i.trim().length){{let s="";r!=null&&(s+=`/*id:${r??"000"}*/   `),t.body+=s.padEnd(14)}t.body+=" ".repeat(t.indent)+i+`
`}}class Je{write(e){for(const r of e.rootOutputNodes())e.shouldPruneOutputNode(r)||(r.variableName=this._write(e,r.node));return e}_createVarName(e,r){let n="";return typeof r!="boolean"&&typeof r!="number"&&r.debugInfo.name&&(n=`${r.debugInfo.name}_`),`${n}v${e.varCount++}`}_write(e,r,n=!1){if(typeof r=="number"||typeof r=="boolean")return r.toString();let i=e.getEmit(r);if(i)return i;switch(r.shaderType){case"scope-node":i=this._writeScopeNode(e,r);break;case"primitive-node":i=this._writePrimitiveNode(e,r,n);break;case"function-node":i=this._writeFunctionNode(e,r);break;case"property-access-node":i=this._writePropertyAccessNode(e,r);break;case"property-access-2d-node":i=this._writePropertyAccess2DNode(e,r);break;case"text-node":i=r.text;break;case"block-node":i=this._writeBlockNode(e,r);break;case"condition-node":i=this._writeConditionNode(e,r)}return e.setEmit(r,i),i}_writeScopeNode(e,r){const n=new r.child.constructor;n.setDebugName(r.debugInfo.name);const i=this._write(e,n,!0);return b(e,`{ /*ScopeStart: ${r.uid} ${r.debugInfo.name}*/`),e.indent+=2,b(e,`${i} = ${this._write(e,r.child)};`),e.indent-=2,b(e,`} /*ScopeEnd: ${r.uid} ${r.debugInfo.name}*/`),i}_writeConditionNode(e,r){const n=new r.ifTrue.constructor,i=this._write(e,n,!0);b(e,`if (${this._write(e,r.condition)}) {`),e.indent+=2;const s=e.createSubgraphContext(),c=this._write(s,r.ifTrue);if(e.body+=s.body,c&&b(e,`${i} = ${c};`),e.indent-=2,b(e,"}"),r.ifFalse){b(e,"else {"),e.indent+=2;const u=e.createSubgraphContext(),a=this._write(u,r.ifFalse);e.body+=u.body,a&&b(e,`${i} = ${a};`),e.indent-=2,b(e,"}")}return i}_writeBlockNode(e,r){const{captureList:n,generator:i,returnType:s}=r,c={};for(const h in n){if(!n[h])continue;const l=this._write(e,n[h]);c[h]=l}const u=new s,a=this._write(e,u,!0);if(c.out=a,r.subgraph){const h=e.createSubgraphContext(),l=this._write(h,r.subgraph.child),x=h.body;c.subgraph={varName:l,body:x}}const d=i(c);return b(e,`{
`),e.indent+=2,b(e,d),e.indent-=2,b(e,`}
`),a}_writePropertyAccessNode(e,r){const n=this._write(e,r.target);return typeof r.property=="string"&&r.property.includes("[")?`${n}${r.property}`:typeof r.property!="string"?`${n}[${this._write(e,r.property)}]`:`${n}.${r.property}`}_writePropertyAccess2DNode(e,r){return`${this._write(e,r.target)}[${this._write(e,r.x)}][${this._write(e,r.y)}]`}_writeFunctionNode(e,r){const n=r.returnType.type;if(r.isInfix){const[c,u]=r.children.map(d=>this._write(e,d)),a=this._createVarName(e,r);return b(e,`${n.padEnd(q)} ${a} = ${c} ${r.token} ${u};`,r.uid),a}const i=r.children.map(c=>this._write(e,c)).join(", "),s=this._createVarName(e,r);return b(e,`${n.padEnd(q)} ${s} = ${r.token}(${i});`,r.uid),s}_writePrimitiveNode(e,r,n=!1){const i=e.getInput(r);if(i)return i.isUsed=!0,i.variableName;const s=r.children.length===1&&r.children[0]?.type===r.type;if(!r.isMutable&&(r.isImplicit||s))return this._write(e,r.children[0]);const c=this._createVarName(e,r);if(n)return b(e,`${r.type.padEnd(q)} ${c};`,r.uid),c;const u=!r.debugInfo.name&&!r.isMutable;if(u&&r.type==="float"&&typeof r.children[0]=="number")return Number.isInteger(r.children[0])?r.children[0].toFixed(1):r.children[0].toString();if(u&&r.type==="int"&&typeof r.children[0]=="number"&&Number.isInteger(r.children[0]))return r.children[0].toString();const a=r.children.map(d=>this._write(e,d)).join(", ");return r.type==="array"?(b(e,`${r.type.padEnd(q)} ${c} = [${a}];`,r.uid),c):u?`${r.type}(${a})`:(b(e,`${r.type.padEnd(q)} ${c} = ${r.type}(${a});`,r.uid),c)}}let A=class tt{constructor(e,r,n){this.variableName=e,this.variableInputType=r,this.node=n,this.type="shader-input",this.isUsed=!1}clone(){return new tt(this.variableName,this.variableInputType,o(this.node))}},O=class rt{constructor(e,r,n){this.outVariableName=e,this.outVariableType=r,this.node=n,this.type="shader-output"}clone(){const e=new rt(this.outVariableName,this.outVariableType,o(this.node));return e.variableName=this.variableName,e}};class D{static createVertex(e,r,n,i,s,c){const u=[];for(const d in e){const h=e[d],l=n.get(d);l?u.push(new A(l,"builtin",h)):u.push(new A("a_"+d,"in",h))}for(const d of i){const h=d.uniformHydrated;u.push(new A(d.uniformName,"uniform",h))}const a=[];for(const d in r){const h=r[d];d==="glPosition"?a.push(new O("gl_Position","builtin",h)):d==="glPointSize"?a.push(new O("gl_PointSize","builtin",h)):a.push(new O("v_"+d,"out",h))}return new D(u,a,s,c)}static createFragment(e,r,n,i,s,c){const u=[],a=Array.from(s.rootOutputNodes());for(const h in e){const l=e[h],x=n.get(h);if(x){u.push(new A(x,"builtin",l));continue}const E=a.find(k=>k.node===l);E&&u.push(new A(E.outVariableName,"in",l))}for(const h of i){const l=h.uniformHydrated;u.push(new A(h.uniformName,"uniform",l))}const d=[];for(const h in r){const l=r[h],x=n.get(h);h==="discard"?d.push(new O(null,"discard",l)):x?d.push(new O(x,"builtin",l)):d.push(new O(h,"out",l))}return new D(u,d,c)}constructor(e,r,n,i){this.type="shader-graph-context",this.indent=0,this.body="",this.varCount=0,this._inputShaderTypesByNodeUid=new Map,this._nodeEmitMap=new Map;for(const s of e)this._inputShaderTypesByNodeUid.set(s.node.uid,s);this._outputShaderTypes=r,this._transformFeedbackBindings=n,this._transformFeedbackNames=new Set(n.map(s=>"v_"+s.propertyKey)),this._usedInFragmentShader=i}shouldPruneOutputNode(e){return!!this._usedInFragmentShader&&e.outVariableType!=="builtin"&&!this._transformFeedbackNames.has(e.outVariableName)&&!this._usedInFragmentShader.has(e.node.uid)}setEmit(e,r){this._nodeEmitMap.set(e.uid,r)}getEmit(e){return this._nodeEmitMap.get(e.uid)}inputs(){return this._inputShaderTypesByNodeUid.values()}getInput(e){return this._inputShaderTypesByNodeUid.get(e.uid)}*rootOutputNodes(){for(const e of this._outputShaderTypes)yield e}*nodes(){const e=[];for(const r of this._outputShaderTypes.values())e.push(r.node);for(;e.length;){const r=e.pop();typeof r!="number"&&typeof r!="boolean"&&e.push(...r.children.filter(Boolean)),yield r}}*nodesOfTypeOrFunction(){for(const e of this.nodes())typeof e!="number"&&typeof e!="boolean"&&(yield e)}createSubgraphContext(){const e=this.clone();return e.body="",e.indent=this.indent+2,e._nodeEmitMap=new Map(this._nodeEmitMap),e}clone(){const e=new D([],this._outputShaderTypes,this._transformFeedbackBindings,this._usedInFragmentShader);return e._inputShaderTypesByNodeUid=this._inputShaderTypesByNodeUid,e.indent=this.indent,e.body=this.body,e.varCount=this.varCount,e._nodeEmitMap=this._nodeEmitMap,e}insertVertexShader(e){e.vertex.code.add(""),this._insertInputs(e,"vertex"),e.vertex.code.add(""),e.vertex.code.add("// OUTPUTS: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const r of this.rootOutputNodes()){const n=r.outVariableType==="builtin";this.shouldPruneOutputNode(r)||(n?e.vertex.code.add(`// ${r.outVariableType.padEnd(7)} ${r.node.type.padEnd(9)} ${r.outVariableName};`):e.vertex.code.add(`${r.outVariableType.padEnd(10)} ${r.node.type.padEnd(9)} ${r.outVariableName};`))}e.vertex.code.add(""),e.vertex.code.add("void main() {"),e.vertex.code.add("  "+this.body.split(`
`).join(`
  `));for(const r of this.rootOutputNodes())this.shouldPruneOutputNode(r)||e.vertex.code.add(`  ${r.outVariableName} = ${r.variableName};`);e.vertex.code.add("}")}insertFragmentShader(e){this._insertInputs(e,"fragment"),e.fragment.code.add(""),e.fragment.code.add("// OUTPUTS: "),e.fragment.code.add("// --------------------------------------------------------- ");let r=0;for(const n of this.rootOutputNodes())n.outVariableType==="builtin"?e.fragment.code.add(`// ${n.outVariableType.padEnd(7)} ${n.node.type.padEnd(9)} ${n.outVariableName};`):e.outputs.add(n.outVariableName,n.node.type,r++);e.fragment.code.add(""),e.fragment.code.add("void main() {"),e.fragment.code.add("  "+this.body.split(`
`).join(`
  `));for(const n of this.rootOutputNodes())n.outVariableType==="discard"?(e.fragment.code.add("  // TODO: Should ensure codegen for discard appears first in fragment shader"),e.fragment.code.add(`  if (${n.variableName}) {`),e.fragment.code.add("    discard;"),e.fragment.code.add("  }"),e.fragment.code.add("  ")):e.fragment.code.add(`  ${n.outVariableName} = ${n.variableName};`);e.fragment.code.add("}")}_insertInputs(e,r){e[r].code.add("// INPUTS: "),e[r].code.add("// --------------------------------------------------------- ");for(const n of this.inputs())n.isUsed&&n.variableInputType!=="builtin"&&(n.node.type==="array"?e[r].code.add(`${n.variableInputType.padEnd(10)} ${n.node.elementType.type.padEnd(9)} ${n.variableName}[${n.node.size}];`):n.node.type==="array-2d"?e[r].code.add(`${n.variableInputType.padEnd(10)} ${n.node.elementType.type.padEnd(9)} ${n.variableName}[${n.node.size}]; // Emulated 2D Array. Not supported by ES3.0`):e[r].code.add(`${n.variableInputType.padEnd(10)} ${n.node.type.padEnd(9)} ${n.variableName};`))}}function ar(t,e,r){const n=new at(e.width,e.height);return n.dataType=e.dataType,e.depth&&(n.depth=e.depth),e.flipped&&(n.flipped=e.flipped),e.hasMipmap&&(n.hasMipmap=e.hasMipmap),n.internalFormat=e.internalFormat,e.isImmutable&&(n.isImmutable=e.isImmutable),e.isOpaque&&(n.isOpaque=e.isOpaque),e.maxAnisotropy&&(n.maxAnisotropy=e.maxAnisotropy),n.pixelFormat=e.pixelFormat,e.preMultiplyAlpha&&(n.preMultiplyAlpha=e.preMultiplyAlpha),e.samplingMode&&(n.samplingMode=e.samplingMode),e.target&&(n.target=e.target),n.uniform=e.uniform,e.unpackAlignment&&(n.unpackAlignment=e.unpackAlignment),e.wrapMode&&(n.wrapMode=e.wrapMode),new ut(t,n,r)}const ur=()=>Ve.getLogger("esri.views.2d.engine.webgl.shaderGraph.typed.TypedShaderProgram");function Z(t,e,r){const n=e.length;if(n!==r){const i=new ot("Invalid Uniform",`Invalid length, expected ${r} but got ${n}`,{uniformName:t,values:e});ur().errorOnce(i)}}class Pe{constructor(e,r,n,i,s,c){this._program=null,this._vao=null,this._temporaryTextures=[],this.vertexShader=e,this.fragmentShader=r,this._locations=n,this._locationInfo=i,this._uniformBindings=s,this._transformFeedbackBindings=c}destroy(){this._program&&this._program.dispose(),this.cleanupTemporaryTextures()}get locations(){return this._locations}get locationInfo(){return this._locationInfo}setUniforms(e){this._uniforms=e}cleanupTemporaryTextures(){for(const e of this._temporaryTextures)e.dispose();this._temporaryTextures=[]}bind(e){const r=this._uniforms;if(!this._program){const i=new Map;for(const[c,u]of this._locations)i.set(c,u);const s=[];for(const c of this._transformFeedbackBindings??[]){const{index:u,propertyKey:a}=c;s[u]=`v_${a}`}this._program=new dt(e,this.vertexShader,this.fragmentShader,i,new Map,s)}const n=this._program;e.useProgram(n);for(const i of this._uniformBindings){const{shaderModulePath:s,uniformName:c,uniformType:u,uniformArrayLength:a}=i,d=st(s,r);if(d==null){if(u==="sampler2D")continue;throw new Error(`Failed to find uniform value for ${s}`)}switch(u==="array"||u==="array-2d"?i.uniformArrayElementType:u){case"sampler2D":{const{unit:h,texture:l}=d;if(n.setUniform1i(c,h),"type"in l)e.bindTexture(l,h);else{const x=ar(e,l.descriptor,l.data);e.bindTexture(x,h)}break}case"int":if(!a){n.setUniform1i(c,d);break}Z(i.uniformName,d,a),n.setUniform1iv(c,d);break;case"float":if(!a){n.setUniform1f(c,d);break}Z(i.uniformName,d,a),n.setUniform1fv(c,d);break;case"vec2":if(!a){n.setUniform2f(c,d[0],d[1]);break}Z(i.uniformName,d,a),n.setUniform2fv(c,d.flat());break;case"vec3":if(!a){n.setUniform3f(c,d[0],d[1],d[2]);break}Z(i.uniformName,d,a),n.setUniform3fv(c,d.flat());break;case"vec4":if(!a){n.setUniform4f(c,d[0],d[1],d[2],d[3]);break}Z(i.uniformName,d,a),n.setUniform4fv(c,d.flat());break;case"mat3":n.setUniformMatrix3fv(c,d);break;case"mat4":n.setUniformMatrix4fv(c,d);break;default:throw new Error(`Unable to set uniform for type ${u}`)}}}}function J(t){return new t}function B(t,e,r){const n=t.constructor[e]??[];t.constructor.hasOwnProperty(e)||Object.defineProperty(t.constructor,e,{value:n.slice()}),t.constructor[e].push(r)}function dr(t,e){return(r,n)=>{B(r,"locations",{typeCtor:e,propertyKey:n,parameterIndex:null,index:t})}}const hr=t=>(e,r)=>{B(e,"builtins",{builtin:t,propertyKey:r})},pr=t=>(e,r,n)=>{B(e,"inputs",{inputCtor:t,propertyKey:r,parameterIndex:n})},lr=t=>(e,r)=>{B(e,"uniforms",{typeCtor:t,propertyKey:r})},fr=t=>(e,r)=>{B(e,"options",{typeCtor:t,propertyKey:r})},yr=(t,e)=>{B(t,"defines",{propertyKey:e})},Fe=(t,e)=>(r,n)=>{r.constructor.builtins.push({builtin:t,propertyKey:n,typeCtor:e})};class Ee{}Ee.builtins=[],g([Fe("gl_VertexID",f)],Ee.prototype,"glVertexID",void 0);class mr{}class Q{}Q.builtins=[],g([Fe("gl_FragCoord",S)],Q.prototype,"glFragCoord",void 0),g([Fe("gl_PointCoord",P)],Q.prototype,"glPointCoord",void 0);class Qe{}g([hr("gl_FragDepth")],Qe.prototype,"glFragDepth",void 0);class gr{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}}let br=class{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const t=this._shaderModuleClass.inputs.findLast(e=>e.propertyKey==="vertex"&&e.parameterIndex===0);if(!t)throw new Error("Unable to find vertex input parameter");return t}get computeInput(){return this._shaderModuleClass.inputs.findLast(t=>t.propertyKey==="vertex"&&t.parameterIndex===1)}get fragmentInput(){const t=this._shaderModuleClass.inputs.findLast(e=>e.propertyKey==="fragment");if(!t)throw new Error("Unable to find fragment input parameter");return t}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){return[...this.vertexInput.inputCtor.locations,...this.computeInput?.inputCtor.locations??[]]}get locationsMap(){const t=new Map,e=new Set;for(const r of this.locations)e.has(r.index)?Ve.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${r.propertyKey} to ${r.index}. Index already in use`,{locationsMap:t}):(t.set(r.propertyKey,r.index),e.add(r.index));return t}get locationInfo(){if(!this._locationInfo){const t=this.locationsMap,e=Array.from(t.entries()).map(([i,s])=>`${i}.${s}`).join("."),r=ct(e),n=this.computeAttributes;this._locationInfo={hash:r,stringHash:e,locations:t,computeAttributeMap:n}}return this._locationInfo}get renamedLocationsMap(){const t=new Map;for(const e of this.locations)t.set("a_"+e.propertyKey,e.index);return t}get optionPropertyKeys(){if(!this._optionPropertyKeys){const t=new Set;for(const e of this._options)t.add(e.propertyKey);this._optionPropertyKeys=t}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram(t,e,r,n){try{const{vertex:i,fragment:s,uniformBindings:c}=this._generateShaders(t,e,r,n);return new Pe(i,s,this.renamedLocationsMap,this.locationInfo,c,this.transformFeedbackBindings)}catch{return new Pe("","",this.renamedLocationsMap,this.locationInfo,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo(t){const e=this._options.find(n=>n.propertyKey===t);if(e)return{type:"option",className:e.typeCtor};const r=this._uniforms.find(n=>n.propertyKey===t);if(!r)throw new Error(`Unable to find uniform class type for property: ${t}`);return{type:"required",className:r.typeCtor}}getShaderKey(t,e,r,n){const i=Object.keys(t).map(a=>`${a}.${t[a]}`).join("."),s=Object.keys(r).map(a=>`${a}.${r[a]}`).join("."),c=Object.keys(n).map(a=>`${a}.${n[a]}`).join("."),u=Object.keys(e).filter(a=>this.optionPropertyKeys.has(a)&&e[a]).join(".");return`${this.type}.${i}.${s}.${c}.${u}`}_generateShaders(t,e,r,n){const i=[];this._setDefines(r),this._setOptionalUniforms(i,e),this._setRequiredUniforms(i);const s=this._hydrateVertexInput(n),c=this._injectPackPrecisionFactor(s,t),u=this._hydrateComputeInput(),a=u&&this._injectComputePackPrecisionFactor(u,t),d=this.vertex(c,a),h=this._hydrateFragmentInput(d),l=this.fragment(h),x=new Set;for(const nt in l){const it=l[nt];ft(x,it)}const E=this._getVertexInputBuiltins(),k=D.createVertex({...s,...u},d,E,i,this.transformFeedbackBindings,x);new Je().write(k);const W=this._getFragmentInputBuiltins(l);W.set("glPointCoord","gl_PointCoord");const X=D.createFragment(h,l,W,i,k,this.transformFeedbackBindings);new Je().write(X);const Oe=this._createShaderBuilder(k,X),Be=Oe.generate("vertex"),je=Oe.generate("fragment");return this.logShader&&(console.log(Be),console.log(je)),{vertex:Be,fragment:je,uniformBindings:i}}_setDefines(t){for(const e in t)this[e]=t[e]}_setOptionalUniforms(t,e){for(const r of this._options)e[r.propertyKey]?this[r.propertyKey]=this._hydrateUniformGroup(t,r):this[r.propertyKey]=null}_setRequiredUniforms(t){for(const e of this._uniforms)this[e.propertyKey]=this._hydrateUniformGroup(t,e)}_hydrateUniformGroup(t,e){const r=new e.typeCtor;for(const n of r._uniforms??[]){const i=J(n.typeCtor),s=`u_${e.propertyKey}_${n.propertyKey}`,c=i.type,u=[e.propertyKey,n.propertyKey].join(".");if("type"in n.typeCtor&&n.typeCtor.type==="array"){const a=i;t.push({shaderModulePath:u,uniformName:s,uniformType:c,uniformArrayLength:a.size,uniformArrayElementType:a.elementType.type,uniformHydrated:i})}else if("type"in n.typeCtor&&n.typeCtor.type==="array-2d"){const a=i;t.push({shaderModulePath:u,uniformName:s,uniformType:c,uniformArrayLength:a.size,uniformArrayElementType:a.elementType.type,uniformHydrated:i})}else t.push({shaderModulePath:u,uniformName:s,uniformType:c,uniformHydrated:i});r[n.propertyKey]=i}return r}_hydrateVertexInput(t){const e=this.vertexInput.inputCtor,r=e.locations.reduce((n,i)=>t[i.propertyKey]===!1?n:{...n,[i.propertyKey]:J(i.typeCtor)},{});for(const{propertyKey:n,typeCtor:i}of e.builtins){const s=J(i);r[n]=s}return r}_hydrateComputeInput(){return this.computeInput==null?null:this.computeInput.inputCtor.locations.reduce((t,e)=>({...t,[e.propertyKey]:J(e.typeCtor)}),{})}_injectPackPrecisionFactor(t,e){const r={};for(const n in t){const i=t[n],s=e[n];if(s){if(i.type!=="float"&&i.type!=="vec2"&&i.type!=="vec3"&&i.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${i.type}`);r[n]=i.divide(new p(s))}else r[n]=i}return r}_injectComputePackPrecisionFactor(t,e){const r={},n=new Map;for(const i in this.computeAttributes)for(const s of this.computeAttributes[i]??[])n.set(s,i);for(const i in t){const s=t[i],c=n.get(i);if(!c)continue;const u=e[c];if(u){if(s.type!=="float"&&s.type!=="vec2"&&s.type!=="vec3"&&s.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${s.type}`);r[i]=s.divide(new p(u))}else r[i]=s}return r}_hydrateFragmentInput(t){const e={};for(const r in t)e[r]=t[r];for(const{propertyKey:r,typeCtor:n}of Q.builtins){const i=J(n);e[r]=i}return e}_getVertexInputBuiltins(){const t=this.vertexInput.inputCtor,e=new Map;for(const{builtin:r,propertyKey:n}of t.builtins)e.set(n,r);return e}_getFragmentInputBuiltins(t){const e=t.constructor,r=new Map;for(const n of e.builtins??[])r.set(n.propertyKey,n.builtin);return r}_createShaderBuilder(t,e){const r=new ht;return this._insertDebugInfo(r),t.insertVertexShader(r),e.insertFragmentShader(r),r}_insertDebugInfo(t){t.vertex.code.add("// DEFINES: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this._defines)this[e.propertyKey]?t.vertex.code.add(`//   ${e.propertyKey}: true`):t.vertex.code.add(`//   ${e.propertyKey}: false`);t.vertex.code.add(""),t.vertex.code.add("// OPTIONS: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this._options)this[e.propertyKey]?t.vertex.code.add(`//   ${e.propertyKey}: true`):t.vertex.code.add(`//   ${e.propertyKey}: false`)}};export{Bt as $,ir as A,ze as B,Ee as C,T as D,Zt as E,Yt as F,qt as G,Tt as H,Nt as I,$t as J,yr as K,rr as L,Jt as M,It as N,Lt as O,gr as P,fr as Q,mr as R,Pt as S,Ct as T,he as U,L as V,f as W,K as X,S as Y,nr as Z,p as _,P as a,He as a0,V as a1,v as a2,Le as a3,Se as a4,Ht as a5,Re as a6,tr as a7,er as a8,pe as a9,Mt as aa,Ft as ab,Et as ac,Pe as ad,cr as b,Xt as c,Kt as d,Gt as e,Dt as f,lr as g,dr as h,Wt as i,br as j,At as k,Ot as l,pr as m,Ut as n,zt as o,Rt as p,Qt as q,F as r,or as s,pt as t,sr as u,Q as v,Qe as w,qe as x,Ze as y,Ge as z};
