import{x as N,z as W,aY as Rt,K as Lt,G as jt,s as Et,ai as Gt,n as H,af as qt,bC as et,X as Nt,gY as Mt,bQ as Ot,ap as Wt,aV as $t}from"./main-DnzmeE4U.js";import{s as ht}from"./pixelRangeUtils-BteWOAF5.js";let ct=class{constructor(t=null,e=null,n=null){this.minValue=t,this.maxValue=e,this.noDataValue=n}};var J;let q=J=class extends jt{static createEmptyBand(t,e){return new(J.getPixelArrayConstructor(t))(e)}static combineBandMasks(t){if(t.length<2)return t[0];const e=t[0].length,n=new Uint8Array(e).fill(255);for(let o=0;o<t.length;o++){const r=t[o];for(let i=0;i<e;i++)r[i]||(n[i]=0)}return n}static getPixelArrayConstructor(t){let e;switch(t){case"u1":case"u2":case"u4":case"u8":e=Uint8Array;break;case"u16":e=Uint16Array;break;case"u32":e=Uint32Array;break;case"s8":e=Int8Array;break;case"s16":e=Int16Array;break;case"s32":e=Int32Array;break;case"f32":case"c64":case"c128":case"unknown":e=Float32Array;break;case"f64":e=Float64Array}return e}constructor(t){super(t),this.width=null,this.height=null,this.pixelType="f32",this.validPixelCount=null,this.mask=null,this.maskIsAlpha=!1,this.premultiplyAlpha=!1,this.statistics=null,this.depthCount=1}castPixelType(t){if(!t)return"f32";let e=t.toLowerCase();return["u1","u2","u4"].includes(e)?e="u8":["unknown","u8","s8","u16","s16","u32","s32","f32","f64"].includes(e)||(e="f32"),e}getPlaneCount(){return this.pixels?.length}addData(t){if(!t.pixels||t.pixels.length!==this.width*this.height)throw new Et("pixelblock:invalid-or-missing-pixels","add data requires valid pixels array that has same length defined by pixel block width * height");this.pixels||(this.pixels=[]),this.statistics||(this.statistics=[]),this.pixels.push(t.pixels),this.statistics.push(t.statistics??new ct)}getAsRGBA(){const t=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case"s8":case"s16":case"u16":case"s32":case"u32":case"f32":case"f64":this._fillFromNon8Bit(t);break;default:this._fillFrom8Bit(t)}return new Uint8ClampedArray(t)}getAsRGBAFloat(){const t=new Float32Array(this.width*this.height*4);return this._fillFrom32Bit(t),t}updateStatistics(){if(!this.pixels)return;this.statistics=this.pixels.map(n=>zt(n,this.mask));const t=this.mask;let e=0;if(t!=null)for(let n=0;n<t.length;n++)t[n]&&e++;else e=this.width*this.height;this.validPixelCount=e}clamp(t){if(!t||t==="f64"||t==="f32"||!this.pixels)return;const[e,n]=ht(t),o=this.pixels,r=this.width*this.height,i=o.length;let l,f,h;const a=[];for(let s=0;s<i;s++){h=J.createEmptyBand(t,r),l=o[s];for(let c=0;c<r;c++)f=l[c],h[c]=f>n?n:f<e?e:f;a.push(h)}this.pixels=a,this.pixelType=t}extractBands(t){const{pixels:e,statistics:n}=this;if(t==null||t.length===0||!e||e.length===0)return this;const o=e.length,r=t.some(c=>c>=e.length),i=o===t.length&&!t.some((c,p)=>c!==p);if(r||i)return this;const l=this.bandMasks?.length===o?t.map(c=>this.bandMasks[c]):void 0;let{mask:f,validPixelCount:h}=this;const{width:a,height:s}=this;return l?.length&&(f=J.combineBandMasks(l),h=f.filter(c=>!!c).length),new J({pixelType:this.pixelType,width:a,height:s,mask:f,bandMasks:l,validPixelCount:h,maskIsAlpha:this.maskIsAlpha,pixels:t.map(c=>e[c]),statistics:n&&t.map(c=>n[c])})}clone(){const t=new J({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount});let e;this.mask!=null&&(t.mask=new Uint8Array(this.mask)),this.bandMasks&&(t.bandMasks=this.bandMasks.map(o=>new Uint8Array(o)));const n=J.getPixelArrayConstructor(this.pixelType);if(this.pixels&&this.pixels.length>0){t.pixels=[];const o=!!this.pixels[0].slice;for(e=0;e<this.pixels.length;e++)t.pixels[e]=o?this.pixels[e].slice():new n(this.pixels[e])}if(this.statistics)for(t.statistics=[],e=0;e<this.statistics.length;e++)t.statistics[e]=Gt(this.statistics[e]);return t.premultiplyAlpha=this.premultiplyAlpha,t}_fillFrom8Bit(t){const{mask:e,maskIsAlpha:n,premultiplyAlpha:o,pixels:r}=this;if(!t||!r?.length)return void H.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");let i,l,f,h;i=l=f=r[0],r.length>=3?(l=r[1],f=r[2]):r.length===2&&(l=r[1]);const a=new Uint32Array(t),s=this.width*this.height;if(i.length===s)if(e!=null&&e.length===s)if(n)for(h=0;h<s;h++){const c=e[h];if(c){const p=c/255;a[h]=o?c<<24|f[h]*p<<16|l[h]*p<<8|i[h]*p:c<<24|f[h]<<16|l[h]<<8|i[h]}}else for(h=0;h<s;h++)e[h]&&(a[h]=255<<24|f[h]<<16|l[h]<<8|i[h]);else for(h=0;h<s;h++)a[h]=255<<24|f[h]<<16|l[h]<<8|i[h];else H.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.")}_fillFromNon8Bit(t){const{pixels:e,mask:n,statistics:o}=this;if(!t||!e?.length)return void H.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");const r=this.pixelType;let i=1,l=0,f=1;if(o&&o.length>0){for(const d of o)if(d.minValue!=null&&(l=Math.min(l,d.minValue)),d.maxValue!=null&&d.minValue!=null){const x=d.maxValue-d.minValue;f=Math.max(f,x)}i=255/f}else{let d=255;r==="s8"?(l=-128,d=127):r==="u16"?d=65535:r==="s16"?(l=-32768,d=32767):r==="u32"?d=4294967295:r==="s32"?(l=-2147483648,d=2147483647):r==="f32"?(l=-34e38,d=34e38):r==="f64"&&(l=-Number.MAX_VALUE,d=Number.MAX_VALUE),i=255/(d-l)}const h=new Uint32Array(t),a=this.width*this.height;let s,c,p,u,m;if(s=c=p=e[0],s.length!==a)return H.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if(e.length>=2)if(c=e[1],e.length>=3&&(p=e[2]),n!=null&&n.length===a)for(u=0;u<a;u++)n[u]&&(h[u]=255<<24|(p[u]-l)*i<<16|(c[u]-l)*i<<8|(s[u]-l)*i);else for(u=0;u<a;u++)h[u]=255<<24|(p[u]-l)*i<<16|(c[u]-l)*i<<8|(s[u]-l)*i;else if(n!=null&&n.length===a)for(u=0;u<a;u++)m=(s[u]-l)*i,n[u]&&(h[u]=255<<24|m<<16|m<<8|m);else for(u=0;u<a;u++)m=(s[u]-l)*i,h[u]=255<<24|m<<16|m<<8|m}_fillFrom32Bit(t){const{pixels:e,mask:n}=this;if(!t||!e?.length)return H.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The input pixel block is empty.");let o,r,i,l;o=r=i=e[0],e.length>=3?(r=e[1],i=e[2]):e.length===2&&(r=e[1]);const f=this.width*this.height;if(o.length!==f)return H.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let h=0;if(n!=null&&n.length===f)for(l=0;l<f;l++)t[h++]=o[l],t[h++]=r[l],t[h++]=i[l],t[h++]=1&n[l];else for(l=0;l<f;l++)t[h++]=o[l],t[h++]=r[l],t[h++]=i[l],t[h++]=1}};function zt(t,e){let n=1/0,o=-1/0;const r=t.length;let i,l=0;if(e!=null)for(i=0;i<r;i++)e[i]&&(l=t[i],n=l<n?l:n,o=l>o?l:o);else for(i=0;i<r;i++)l=t[i],n=l<n?l:n,o=l>o?l:o;return new ct(n,o)}N([W({json:{write:!0}})],q.prototype,"width",void 0),N([W({json:{write:!0}})],q.prototype,"height",void 0),N([W({json:{write:!0}})],q.prototype,"pixelType",void 0),N([Rt("pixelType")],q.prototype,"castPixelType",null),N([W({json:{write:!0}})],q.prototype,"validPixelCount",void 0),N([W({json:{write:!0}})],q.prototype,"mask",void 0),N([W({json:{write:!0}})],q.prototype,"maskIsAlpha",void 0),N([W({json:{write:!0}})],q.prototype,"pixels",void 0),N([W()],q.prototype,"premultiplyAlpha",void 0),N([W({json:{write:!0}})],q.prototype,"statistics",void 0),N([W({json:{write:!0}})],q.prototype,"depthCount",void 0),N([W({json:{write:!0}})],q.prototype,"noDataValues",void 0),N([W({json:{write:!0}})],q.prototype,"bandMasks",void 0),q=J=N([Lt("esri.layers.support.PixelBlock")],q);const D=q;var ft,ut;(function(t){t[t.matchAny=0]="matchAny",t[t.matchAll=1]="matchAll"})(ft||(ft={})),function(t){t[t.bestMatch=0]="bestMatch",t[t.fail=1]="fail"}(ut||(ut={}));const Xt=6;function R(t){return t!=null&&t.declaredClass==="esri.layers.support.PixelBlock"&&t.pixels&&t.pixels.length>0}function Kt(t){if(!t?.length||t.some(s=>!R(s)))return null;if(t.length===1)return t[0]?.clone()??null;const e=t,{width:n,height:o,pixelType:r}=e[0];if(e.some(s=>s.width!==n||s.height!==o))return null;const i=e.map(({mask:s})=>s).filter(s=>s!=null);let l=null;i.length&&(l=new Uint8Array(n*o),l.set(i[0]),i.length>1&&vt(i.slice(1),l));const f=[];e.forEach(({pixels:s})=>f.push(...s));const h=e.map(({statistics:s})=>s).filter(s=>s?.length),a=[];return h.forEach(s=>a.push(...s)),new D({pixelType:r,width:n,height:o,mask:l,pixels:f,statistics:a.length?a:null})}function Jt(t){if(!t)return;const e=t.colormap;if(!e||e.length===0)return;const n=e.sort((c,p)=>c[0]-p[0]);let o=0;n[0][0]<0&&(o=n[0][0]);const r=Math.max(256,n[n.length-1][0]-o+1),i=new Uint8Array(4*r),l=[];let f,h=0,a=0;const s=n[0].length===5;if(r>65536)return n.forEach(c=>{l[c[0]-o]=s?c.slice(1):c.slice(1).concat([255])}),{indexed2DColormap:l,offset:o,alphaSpecified:s};if(t.fillUnspecified)for(f=n[a],h=f[0]-o;h<r;h++)i[4*h]=f[1],i[4*h+1]=f[2],i[4*h+2]=f[3],i[4*h+3]=s?f[4]:255,h===f[0]-o&&(f=a===n.length-1?f:n[++a]);else for(h=0;h<n.length;h++)f=n[h],a=4*(f[0]-o),i[a]=f[1],i[a+1]=f[2],i[a+2]=f[3],i[a+3]=s?f[4]:255;return{indexedColormap:i,offset:o,alphaSpecified:s}}function Yt(t,e){if(!R(t)||!e||!e.indexedColormap&&!e.indexed2DColormap)return t;const n=t.clone(),o=n.pixels;let r=n.mask;const i=n.width*n.height;if(o.length!==1)return t;const{indexedColormap:l,indexed2DColormap:f,offset:h,alphaSpecified:a}=e;let s=0;const c=o[0],p=new Uint8Array(c.length),u=new Uint8Array(c.length),m=new Uint8Array(c.length);let d,x=0;if(l){const y=l.length-1;if(r!=null)for(s=0;s<i;s++)r[s]&&(x=4*(c[s]-h),x<h||x>y?r[s]=0:(p[s]=l[x],u[s]=l[x+1],m[s]=l[x+2],r[s]=l[x+3]));else{for(r=new Uint8Array(i),s=0;s<i;s++)x=4*(c[s]-h),x<h||x>y?r[s]=0:(p[s]=l[x],u[s]=l[x+1],m[s]=l[x+2],r[s]=l[x+3]);n.mask=r}}else if(f)if(r!=null)for(s=0;s<i;s++)r[s]&&(d=f[c[s]],p[s]=d[0],u[s]=d[1],m[s]=d[2],r[s]=d[3]);else{for(r=new Uint8Array(i),s=0;s<i;s++)d=f[c[s]],p[s]=d[0],u[s]=d[1],m[s]=d[2],r[s]=d[3];n.mask=r}return n.pixels=[p,u,m],n.statistics=null,n.pixelType="u8",n.maskIsAlpha=a,n}function Ht(t,e){if(!R(t))return null;const{pixels:n,mask:o}=t,r=n.length;let i=e.lut;const{offset:l}=e;i&&i[0].length===1&&(i=n.map(()=>i));const f=[],h=e.outputPixelType||"u8";for(let s=0;s<r;s++){const c=pt(n[s],o,i[s],l||0,h);f.push(c)}const a=new D({width:t.width,height:t.height,pixels:f,mask:o,pixelType:h});return a.updateStatistics(),a}function pt(t,e,n,o,r){const i=t.length,l=D.createEmptyBand(r,i);if(e)for(let f=0;f<i;f++)e[f]&&(l[f]=n[t[f]-o]);else for(let f=0;f<i;f++)l[f]=n[t[f]-o];return l}function Qt(t,e){if(!R(t))return null;const n=t.clone(),{pixels:o}=n,r=n.width*n.height,i=e.length,l=Math.floor(i/2),f=e[Math.floor(l)],h=o[0];let a,s,c,p,u,m,d=!1;const x=new Uint8Array(r),y=new Uint8Array(r),M=new Uint8Array(r);let k=n.mask;const w=e[0].mappedColor.length===4;for(k||(k=new Uint8Array(r),k.fill(w?255:1),n.mask=k),u=0;u<r;u++)if(k[u]){for(a=h[u],d=!1,m=l,s=f,c=0,p=i-1;p-c>1;){if(a===s.value){d=!0;break}a>s.value?c=m:p=m,m=Math.floor((c+p)/2),s=e[Math.floor(m)]}d||(a===e[c].value?(s=e[c],d=!0):a===e[p].value?(s=e[p],d=!0):a<e[c].value?(d=!1,s=null):a>e[c].value&&(a<e[p].value?(s=e[c],d=!0):p===i-1?(d=!1,s=null):(s=e[p],d=!0))),d?(x[u]=s.mappedColor[0],y[u]=s.mappedColor[1],M[u]=s.mappedColor[2],k[u]=s.mappedColor[3]):x[u]=y[u]=M[u]=k[u]=0}return n.pixels=[x,y,M],n.mask=k,n.pixelType="u8",n.maskIsAlpha=w,n}function Zt(t,e){if(!R(t))return null;const{width:n,height:o}=t,{inputRanges:r,outputValues:i,outputPixelType:l,noDataRanges:f,allowUnmatched:h,isLastInputRangeInclusive:a}=e,s=t.pixels[0],c=D.createEmptyBand(l,s.length),p=t.mask,u=new Uint8Array(n*o);p?u.set(p):u.fill(255);const m=t.pixelType.startsWith("f")?1e-6:0,d=r.map(w=>w-m);d[0]=r[0],d[d.length-1]=r[r.length-1]+(a?1e-6:0);const x=r.length/2,[y,M]=ht(l);for(let w=0;w<o;w++)for(let g=0;g<n;g++){const b=w*n+g;if(u[b]){const U=s[b];let T=!1;for(let B=x-1;B>=0;B--)if(U===d[2*B]||U>d[2*B]&&U<d[2*B+1]){c[b]=i[B],T=!0;break}T||(h?c[b]=U>M?M:U<y?y:U:u[b]=0)}}const k=f?.length;if(k)for(let w=0;w<o;w++)for(let g=0;g<n;g++){const b=w*n+g;if(!p||p[b]){const U=s[b];for(let T=0;T<k;T+=2)if(U>=f[T]&&U<=f[T+1]){c[b]=0,u[b]=0;break}}}return new D({width:n,height:o,pixelType:l,pixels:[c],mask:u})}function At(t,e,n,o){const r=n!=null&&n.length>=2?new Set(n):null,i=n?.length===1?n[0]:null,l=!!e?.length;for(let f=0;f<t.length;f++)if(o[f]){const h=t[f];if(l){let a=!1;for(let s=0;s<e.length;s+=2)if(h>=e[s]&&h<=e[s+1]){a=!0;break}a||(o[f]=0)}o[f]&&(h===i||r?.has(h))&&(o[f]=0)}}function bt(t,e){const n=t[0].length;for(let o=0;o<n;o++)if(e[o]){let r=!1;for(let i=0;i<t.length;i++)if(t[i][o]){r=!0;break}r||(e[o]=0)}}function vt(t,e){const n=t[0].length;for(let o=0;o<n;o++)if(e[o]){let r=!1;for(let i=0;i<t.length;i++)if(t[i][o]===0){r=!0;break}r&&(e[o]=0)}}function te(t,e){if(!R(t))return null;const{width:n,height:o,pixels:r}=t,i=n*o,l=new Uint8Array(i);t.mask?l.set(t.mask):l.fill(255);const f=r.length,{includedRanges:h,noDataValues:a,outputPixelType:s,matchAll:c,lookups:p}=e;if(p){const u=[];for(let m=0;m<f;m++){const d=p[m],x=pt(r[m],l,d.lut,d.offset||0,"u8");u.push(x)}u.length===1?l.set(u[0]):c?bt(u,l):vt(u,l)}else if(c){const u=[];for(let m=0;m<f;m++){const d=new Uint8Array(i);d.set(l),At(r[m],h?.slice(2*m,2*m+2),a?.[m],d),u.push(d)}u.length===1?l.set(u[0]):bt(u,l)}else for(let u=0;u<f;u++)At(r[u],h?.slice(2*u,2*u+2),a?.[u],l);return new D({width:n,height:o,pixelType:s,pixels:r,mask:l})}function ee(t){const{srcPixelType:e,inputRanges:n,outputValues:o,allowUnmatched:r,noDataRanges:i,isLastInputRangeInclusive:l,outputPixelType:f}=t;if(e!=="u8"&&e!=="s8"&&e!=="u16"&&e!=="s16")return null;const h=e.includes("16")?65536:256,a=e.includes("s")?-h/2:0,s=D.createEmptyBand(f,h),c=new Uint8Array(h);r&&c.fill(255);const[p,u]=ht(f);if(n?.length&&o?.length){const m=n.map(d=>d-1e-6);m[0]=n[0],l&&(m[m.length-1]=n[n.length-1]);for(let d=0;d<m.length;d++){const x=o[d]>u?u:o[d]<p?p:o[d],y=Math.ceil(m[2*d]-a),M=Math.floor(m[2*d+1]-a);for(let k=y;k<=M;k++)s[k]=x,c[k]=255}}if(i?.length)for(let m=0;m<i.length;m++){const d=Math.ceil(i[2*m]-a),x=Math.floor(i[2*m+1]-a);for(let y=d;y<=x;y++)c[y]=0}return{lut:s,offset:a,mask:c}}function ne(t,e,n){if(t!=="u8"&&t!=="s8"&&t!=="u16"&&t!=="s16")return null;const o=t.includes("16")?65536:256,r=t.includes("s")?-o/2:0,i=new Uint8Array(o);if(e)for(let l=0;l<e.length;l++){const f=Math.ceil(e[2*l]-r),h=Math.floor(e[2*l+1]-r);for(let a=f;a<=h;a++)i[a]=255}else i.fill(255);if(n)for(let l=0;l<n.length;l++)i[n[l]-r]=0;return{lut:i,offset:r}}function ie(t,e,n,o,r,i,l,f){return{xmin:r<=n*t?0:r<n*t+t?r-n*t:t,ymin:i<=o*e?0:i<o*e+e?i-o*e:e,xmax:r+l<=n*t?0:r+l<n*t+t?r+l-n*t:t,ymax:i+f<=o*e?0:i+f<o*e+e?i+f-o*e:e}}function le(t,e){if(!t||t.length===0)return null;const n=t.find(m=>m.pixelBlock);if(n?.pixelBlock==null)return null;const o=(n.extent.xmax-n.extent.xmin)/n.pixelBlock.width,r=(n.extent.ymax-n.extent.ymin)/n.pixelBlock.height,i=.01*Math.min(o,r),l=t.sort((m,d)=>Math.abs(m.extent.ymax-d.extent.ymax)>i?d.extent.ymax-m.extent.ymax:Math.abs(m.extent.xmin-d.extent.xmin)>i?m.extent.xmin-d.extent.xmin:0),f=Math.min.apply(null,l.map(m=>m.extent.xmin)),h=Math.min.apply(null,l.map(m=>m.extent.ymin)),a=Math.max.apply(null,l.map(m=>m.extent.xmax)),s=Math.max.apply(null,l.map(m=>m.extent.ymax)),c={x:Math.round((e.xmin-f)/o),y:Math.round((s-e.ymax)/r)},p={width:Math.round((a-f)/o),height:Math.round((s-h)/r)},u={width:Math.round((e.xmax-e.xmin)/o),height:Math.round((e.ymax-e.ymin)/r)};return Math.round(p.width/n.pixelBlock.width)*Math.round(p.height/n.pixelBlock.height)!==l.length||c.x<0||c.y<0||p.width<u.width||p.height<u.height?null:{extent:e,pixelBlock:Ut(l.map(m=>m.pixelBlock),p,{clipOffset:c,clipSize:u})}}function dt(t,e,n,o,r,i){const{width:l,height:f}=n.block,{x:h,y:a}=n.offset,{width:s,height:c}=n.mosaic,p=ie(l,f,o,r,h,a,s,c);let u=0,m=0;if(i){const d=i.hasGCSSShiftTransform?360:i.halfWorldWidth??0,x=l*i.resolutionX,y=i.startX+o*x;y<d&&y+x>d?m=i.rightPadding:y>=d&&(u=i.leftMargin-i.rightPadding,m=0)}if(p.xmax-=m,typeof e!="number")for(let d=p.ymin;d<p.ymax;d++){const x=(r*f+d-a)*s+(o*l-h)+u,y=d*l;for(let M=p.xmin;M<p.xmax;M++)t[x+M]=e[y+M]}else for(let d=p.ymin;d<p.ymax;d++){const x=(r*f+d-a)*s+(o*l-h)+u;for(let y=p.xmin;y<p.xmax;y++)t[x+y]=e}}function Ut(t,e,n={}){const{clipOffset:o,clipSize:r,alignmentInfo:i,blockWidths:l}=n;if(l)return se(t,e,{blockWidths:l});const f=t.find(v=>R(v));if(f==null)return null;const h=r?r.width:e.width,a=r?r.height:e.height,s=f.width,c=f.height,p=e.width/s,u=e.height/c,m={offset:o||{x:0,y:0},mosaic:r||e,block:{width:s,height:c}},d=f.pixelType,x=D.getPixelArrayConstructor(d),y=f.pixels.length,M=[];let k,w;for(let v=0;v<y;v++){w=new x(h*a);for(let I=0;I<u;I++)for(let A=0;A<p;A++){const P=t[I*p+A];R(P)&&(k=P.pixels[v],dt(w,k,m,A,I,i))}M.push(w)}const g=t.some(v=>v==null||v.mask!=null&&v.mask.length>0),b=t.some(v=>v?.bandMasks&&v.bandMasks.length>1),U=g?new Uint8Array(h*a):void 0,T=b?[]:void 0;if(U){for(let v=0;v<u;v++)for(let I=0;I<p;I++){const A=t[v*p+I],P=A!=null?A.mask:null;dt(U,P??(A?255:0),m,I,v,i)}if(T)for(let v=0;v<y;v++){const I=new Uint8Array(h*a);for(let A=0;A<u;A++)for(let P=0;P<p;P++){const C=t[A*p+P],S=C?.bandMasks?.[v]??C?.mask;dt(I,S??(C?255:0),m,P,A,i)}T.push(I)}}const B=new D({width:h,height:a,pixels:M,pixelType:d,bandMasks:T,mask:U});return B.updateStatistics(),B}function se(t,e,n){const o=t.find(x=>x!=null);if(o==null)return null;const r=t.some(x=>x==null||!!x.mask),{width:i,height:l}=e,f=r?new Uint8Array(i*l):null,{blockWidths:h}=n,a=[],s=o.getPlaneCount(),c=D.getPixelArrayConstructor(o.pixelType);if(r)for(let x=0,y=0;x<t.length;y+=h[x],x++){const M=t[x];if(!R(M))continue;const k=M.mask;for(let w=0;w<l;w++)for(let g=0;g<h[x];g++)f[w*i+g+y]=k==null?255:k[w*M.width+g]}const p=t.some(x=>x?.bandMasks&&x.bandMasks.length>1),u=p?[]:void 0,m=i*l;for(let x=0;x<s;x++){const y=new c(m),M=p?new Uint8Array(m):void 0;for(let k=0,w=0;k<t.length;w+=h[k],k++){const g=t[k];if(!R(g))continue;const b=g.pixels[x];if(b!=null){for(let U=0;U<l;U++)for(let T=0;T<h[k];T++)y[U*i+T+w]=b[U*g.width+T];if(M){const U=g.bandMasks?.[x]??g.mask;for(let T=0;T<l;T++)for(let B=0;B<h[k];B++)M[T*i+B+w]=U?U[T*g.width+B]:255}}}a.push(y),u&&M&&u.push(M)}const d=new D({width:i,height:l,mask:f,bandMasks:u,pixels:a,pixelType:o.pixelType});return d.updateStatistics(),d}function oe(t,e,n){if(!R(t))return null;const{width:o,height:r}=t,i=e.x,l=e.y,f=n.width+i,h=n.height+l;if(i<0||l<0||f>o||h>r||i===0&&l===0&&f===o&&h===r)return t;t.mask||(t.mask=new Uint8Array(o*r));const a=t.mask;for(let s=0;s<r;s++){const c=s*o;for(let p=0;p<o;p++)a[c+p]=s<l||s>=h||p<i||p>=f?0:1}return t.updateStatistics(),t}function re(t){if(!R(t))return null;const e=t.clone(),{width:n,height:o,pixels:r}=t,i=r[0],l=e.pixels[0],f=t.mask;for(let h=2;h<o-1;h++){const a=new Map;for(let c=h-2;c<h+2;c++)for(let p=0;p<4;p++){const u=c*n+p;lt(a,i[u],f?f[u]:1)}l[h*n]=Tt(a),l[h*n+1]=l[h*n+2]=l[h*n];let s=3;for(;s<n-1;s++){let c=(h-2)*n+s+1;lt(a,i[c],f?f[c]:1),c=(h-1)*n+s+1,lt(a,i[c],f?f[c]:1),c=h*n+s+1,lt(a,i[c],f?f[c]:1),c=(h+1)*n+s+1,lt(a,i[c],f?f[c]:1),c=(h-2)*n+s-3,ot(a,i[c],f?f[c]:1),c=(h-1)*n+s-3,ot(a,i[c],f?f[c]:1),c=h*n+s-3,ot(a,i[c],f?f[c]:1),c=(h+1)*n+s-3,ot(a,i[c],f?f[c]:1),l[h*n+s]=Tt(a)}l[h*n+s+1]=l[h*n+s]}for(let h=0;h<n;h++)l[h]=l[n+h]=l[2*n+h],l[(o-1)*n+h]=l[(o-2)*n+h];return e.updateStatistics(),e}function Tt(t){if(t.size===0)return 0;let e=0,n=-1,o=0;const r=t.keys();let i=r.next();for(;!i.done;)o=t.get(i.value),o>e&&(n=i.value,e=o),i=r.next();return n}function ot(t,e,n){if(n===0)return;const o=t.get(e);o===1?t.delete(e):t.set(e,o-1)}function lt(t,e,n){n!==0&&t.set(e,t.has(e)?t.get(e)+1:1)}function mt(t,e,n){let{x:o,y:r}=e;const{width:i,height:l}=n;if(o===0&&r===0&&l===t.height&&i===t.width)return t;const{width:f,height:h}=t,a=Math.max(0,r),s=Math.max(0,o),c=Math.min(o+i,f),p=Math.min(r+l,h);if(c<0||p<0||!R(t))return null;o=Math.max(0,-o),r=Math.max(0,-r);const{pixels:u}=t,m=i*l,d=u.length,x=[];for(let w=0;w<d;w++){const g=u[w],b=D.createEmptyBand(t.pixelType,m);for(let U=a;U<p;U++){const T=U*f;let B=(U+r-a)*i+o;for(let v=s;v<c;v++)b[B++]=g[T+v]}x.push(b)}const y=new Uint8Array(m),M=t.mask;for(let w=a;w<p;w++){const g=w*f;let b=(w+r-a)*i+o;for(let U=s;U<c;U++)y[b++]=M?M[g+U]:1}const k=new D({width:n.width,height:n.height,pixelType:t.pixelType,pixels:x,mask:y});return k.updateStatistics(),k}function Pt(t,e=!0){if(!R(t))return null;const{pixels:n,width:o,height:r,mask:i,pixelType:l}=t,f=[],h=Math.round(o/2),a=Math.round(r/2),s=r-1,c=o-1;for(let u=0;u<n.length;u++){const m=n[u],d=D.createEmptyBand(l,h*a);let x=0;for(let y=0;y<r;y+=2)for(let M=0;M<o;M+=2){const k=m[y*o+M];if(e){const w=M===c?k:m[y*o+M+1],g=y===s?k:m[y*o+M+o],b=M===c?g:y===s?w:m[y*o+M+o+1];d[x++]=(k+w+g+b)/4}else d[x++]=k}f.push(d)}let p=null;if(i!=null){p=new Uint8Array(h*a);let u=0;for(let m=0;m<r;m+=2)for(let d=0;d<o;d+=2){const x=i[m*o+d];if(e){const y=d===c?x:i[m*o+d+1],M=m===s?x:i[m*o+d+o],k=d===c?M:m===s?y:i[m*o+d+o+1];p[u++]=x*y*M*k?1:0}else p[u++]=x}}return new D({width:h,height:a,pixelType:l,pixels:f,mask:p})}function ae(t,e,n=0,o=!0){if(!R(t))return null;const{width:r,height:i}=e;let{width:l,height:f}=t;const h=new Map,a={x:0,y:0},s=1+n;let c=t;for(let p=0;p<s;p++){const u=Math.ceil(l/r),m=Math.ceil(f/i);for(let d=0;d<m;d++){a.y=d*i;for(let x=0;x<u;x++){a.x=x*r;const y=mt(c,a,e);h.set(`${p}/${d}/${x}`,y)}}p<s-1&&(c=Pt(c,o)),l=Math.round(l/2),f=Math.round(f/2)}return h}function he(t){const{pixelBlock:e,tileSize:n,level:o,row:r,col:i,useBilinear:l}=t;if(!R(e))return null;const{width:f,height:h}=n,a=2**o,s=a*f,c=a*h;let p=mt(e,{y:r*c,x:i*s},{width:s,height:c});if(!p)return null;for(let u=o;u>0;u--)p=Pt(p,l);return p}function It(t,e,n,o,r=0){const{width:i,height:l}=t,{width:f,height:h}=e,a=o.cols,s=o.rows,c=Math.ceil(f/a-.1/a),p=Math.ceil(h/s-.1/s);let u,m,d,x,y,M,k;const w=c*a,g=w*p*s,b=new Float32Array(g),U=new Float32Array(g),T=new Uint32Array(g),B=new Uint32Array(g);let v,I,A=0;for(let P=0;P<p;P++)for(let C=0;C<c;C++){u=12*(P*c+C),m=n[u],d=n[u+1],x=n[u+2],y=n[u+3],M=n[u+4],k=n[u+5];for(let S=0;S<s;S++){A=(P*s+S)*w+C*a,I=(S+.5)/s;for(let F=0;F<S;F++)v=(F+.5)/a,b[A+F]=(m*v+d*I+x)*i+r,U[A+F]=(y*v+M*I+k)*l+r,T[A+F]=Math.floor(b[A+F]),B[A+F]=Math.floor(U[A+F])}u+=6,m=n[u],d=n[u+1],x=n[u+2],y=n[u+3],M=n[u+4],k=n[u+5];for(let S=0;S<s;S++){A=(P*s+S)*w+C*a,I=(S+.5)/s;for(let F=S;F<a;F++)v=(F+.5)/a,b[A+F]=(m*v+d*I+x)*i+r,U[A+F]=(y*v+M*I+k)*l+r,T[A+F]=Math.floor(b[A+F]),B[A+F]=Math.floor(U[A+F])}}return{offsets_x:b,offsets_y:U,offsets_xi:T,offsets_yi:B,gridWidth:w}}function ce(t,e){const{coefficients:n,spacing:o}=e,{offsets_x:r,offsets_y:i,gridWidth:l}=It(t,t,n,{rows:o[0],cols:o[1]}),{width:f,height:h}=t,a=new Float32Array(f*h),s=180/Math.PI;for(let c=0;c<h;c++)for(let p=0;p<f;p++){const u=c*l+p,m=c===0?u:u-l,d=c===h-1?u:u+l,x=r[m]-r[d],y=i[d]-i[m];if(isNaN(x)||isNaN(y))a[c*f+p]=90;else{let M=Math.atan2(y,x)*s;M=(360+M)%360,a[c*f+p]=M}}return a}function fe(t,e,n,o,r="nearest"){if(!R(t))return null;r==="majority"&&(t=re(t));const{pixels:i,mask:l,bandMasks:f,pixelType:h}=t,a=t.width,s=t.height,c=D.getPixelArrayConstructor(h),p=i.length,{width:u,height:m}=e;let d=!1;for(let A=0;A<n.length;A+=3)n[A]===-1&&n[A+1]===-1&&n[A+2]===-1&&(d=!0);const{offsets_x:x,offsets_y:y,offsets_xi:M,offsets_yi:k,gridWidth:w}=It({width:a,height:s},e,n,o,r==="majority"?.5:0);let g;const b=(A,P,C,S)=>{const F=A instanceof Float32Array||A instanceof Float64Array?0:.5;for(let j=0;j<m;j++){g=j*w;for(let V=0;V<u;V++){if(x[g]<0||y[g]<0)A[j*u+V]=0;else if(S)A[j*u+V]=P[M[g]+k[g]*a];else{const G=Math.floor(x[g]),O=Math.floor(y[g]),$=Math.ceil(x[g]),K=Math.ceil(y[g]),X=x[g]-G,Y=y[g]-O;if(!C||C[G+O*a]&&C[$+O*a]&&C[G+K*a]&&C[$+K*a]){const tt=(1-X)*P[G+O*a]+X*P[$+O*a],_=(1-X)*P[G+K*a]+X*P[$+K*a];A[j*u+V]=(1-Y)*tt+Y*_+F}else A[j*u+V]=P[M[g]+k[g]*a]}g++}}},U=[];let T;const B=f?.length===p,v=[];for(let A=0;A<p;A++){if(B){const P=new Uint8Array(u*m);b(P,f[A],f[A],!0),v.push(P)}T=new c(u*m),b(T,i[A],B?f[A]:l,r==="nearest"||r==="majority"),U.push(T)}const I=new D({width:u,height:m,pixelType:h,pixels:U,bandMasks:B?v:void 0});if(l!=null)I.mask=new Uint8Array(u*m),b(I.mask,l,l,!0);else if(d){I.mask=new Uint8Array(u*m);for(let A=0;A<u*m;A++)I.mask[A]=x[A]<0||y[A]<0?0:1}return I.updateStatistics(),I}const Q=new Map;Q.set("meter-per-second",1),Q.set("kilometer-per-hour",.277778),Q.set("knots",.514444),Q.set("feet-per-second",.3048),Q.set("mile-per-hour",.44704);const gt=180/Math.PI,xt=5,st=new qt({esriMetersPerSecond:"meter-per-second",esriKilometersPerHour:"kilometer-per-hour",esriKnots:"knots",esriFeetPerSecond:"feet-per-second",esriMilesPerHour:"mile-per-hour"});function rt(t,e){return Q.get(t)/Q.get(e)||1}function Bt(t){return(450-t)%360}function wt(t,e="geographic"){const[n,o]=t,r=Math.sqrt(n*n+o*o);let i=Math.atan2(o,n)*gt;return i=(360+i)%360,e==="geographic"&&(i=Bt(i)),[r,i]}function ue(t,e="geographic"){let n=t[1];e==="geographic"&&(n=Bt(n)),n%=360;const o=t[0];return[o*Math.cos(n/gt),o*Math.sin(n/gt)]}function pe(t,e,n,o="geographic"){if(!R(t)||n==null)return t;const r=e==="vector-magdir"?t.clone():yt(t,e),i=r.pixels[1];for(let l=0;l<i.length;l++)i[l]=o==="geographic"?(i[l]+n[l]+270)%360:(i[l]+360-n[l])%360;return e==="vector-magdir"?r:yt(r,"vector-magdir")}function yt(t,e,n="geographic",o=1){if(!R(t))return t;const{pixels:r,width:i,height:l}=t,f=i*l,h=r[0],a=r[1],s=t.pixelType.startsWith("f")?t.pixelType:"f32",c=D.createEmptyBand(s,f),p=D.createEmptyBand(s,f);let u=0;for(let d=0;d<l;d++)for(let x=0;x<i;x++)e==="vector-uv"?([c[u],p[u]]=wt([h[u],a[u]],n),c[u]*=o):([c[u],p[u]]=ue([h[u],a[u]],n),c[u]*=o,p[u]*=o),u++;const m=new D({pixelType:s,width:t.width,height:t.height,mask:t.mask,validPixelCount:t.validPixelCount,maskIsAlpha:t.maskIsAlpha,pixels:[c,p]});return m.updateStatistics(),m}function de(t,e,n=1){if(n===1||!R(t))return t;const o=t.clone(),{pixels:r,width:i,height:l}=o,f=r[0];r[1];let h=0;for(let a=0;a<l;a++)for(let s=0;s<i;s++)f[h]*=n,h++;return o.updateStatistics(),o}function me(t,e,n,o,r){if(r==null||!r.spatialReference.equals(t.spatialReference))return{extent:t,width:Math.round(e/o),height:Math.round(n/o),resolution:t.width/e};const i=r.xmin,l=r.ymax,f=(t.xmax-t.xmin)/e*o,h=(t.ymax-t.ymin)/n*o,a=(f+h)/2;return t.xmin=i+Math.floor((t.xmin-i)/f)*f,t.xmax=i+Math.ceil((t.xmax-i)/f)*f,t.ymin=l+Math.floor((t.ymin-l)/h)*h,t.ymax=l+Math.ceil((t.ymax-l)/h)*h,{extent:t,width:Math.round(t.width/f),height:Math.round(t.height/h),resolution:a}}const ge=St(0,0,0);function St(t=0,e=0,n=Math.PI,o=!0){o&&(n=(2*Math.PI-n)%(2*Math.PI));const r=o?-1:1,i=13*r,l=-7*r,f=-2*r,h=-16*r,a=21.75,[s,c]=E(0,e+i,n,a),[p,u]=E(t-5.5,e+l,n,a),[m,d]=E(t+5.5,e+l,n,a),[x,y]=E(t-1.5,e+f,n,a),[M,k]=E(t+1.5,e+f,n,a),[w,g]=E(t-1.5,e+h,n,a),[b,U]=E(t+1.5,e+h,n,a);return[s,c,p,u,x,y,M,k,m,d,w,g,b,U]}function xe(t=0,e=Math.PI,n=!0){n&&(e=(2*Math.PI-e)%(2*Math.PI));const o=10,r=n?-1:1,i=5*r,l=20*r,f=25*r,h=45,a=0,s=0,c=2,p=0,u=c*r,m=n?1:-1,d=o/2*m;let[x,y]=[a+d,s-l],[M,k]=[x+c*m,y],[w,g]=[M-p*m,k+u],[b,U]=[a-d,s-f],[T,B]=[b+p*m,U-u],v=Math.ceil(t/xt),I=Math.floor(v/10);v-=8*I;const A=[],P=[];for(let X=0;X<v/2;X++,I--){I<=0&&v%2==1&&X===(v-1)/2&&(b=a,T=b+p*m,U=(U+y)/2,B=U-u);const[Y,tt]=E(b,U,e,h);if(I>0){const[_,L]=E(M,U,e,h),[nt,it]=E(x,y,e,h);A.push(_),A.push(L),A.push(Y),A.push(tt),A.push(nt),A.push(it)}else{const[_,L]=E(M,k,e,h),[nt,it]=E(w,g,e,h),[_t,Dt]=E(T,B,e,h);P.push(Y),P.push(tt),P.push(_t),P.push(Dt),P.push(nt),P.push(it),P.push(_),P.push(L)}U+=i,y+=i,k+=i,g+=i,B+=i}const[C,S]=E(a+d,s+l,e,h),F=(o/2+c)*m,[j,V]=E(a+F,s+l,e,h),[G,O]=E(a+d,s-f,e,h),[$,K]=E(a+F,s-f,e,h);return{pennants:A,barbs:P,shaft:[C,S,j,V,G,O,$,K]}}function E(t,e,n,o=1){const r=Math.sqrt(t*t+e*e)/o,i=(2*Math.PI+Math.atan2(e,t))%(2*Math.PI);return[r,(2*Math.PI+i-n)%(2*Math.PI)]}const at=[0,1,3,6,10,16,21,27,33,40,47,55,63],we=[0,.5,1,1.5,2],ye=[0,.25,.5,1,1.5,2,2.5,3,3.5,4];function Z(t,e,n,o){const r=rt(o||"knots",n);let i;for(i=1;i<e.length;i++)if(i===e.length-1){if(t<e[i]*r)break}else if(t<=e[i]*r)break;return Math.min(i-1,e.length-2)}function ke(t,e,n,o,r){let i=0;switch(e){case"beaufort_kn":i=Z(t,at,"knots",n);break;case"beaufort_km":i=Z(t,at,"kilometer-per-hour",n);break;case"beaufort_ft":i=Z(t,at,"feet-per-second",n);break;case"beaufort_m":i=Z(t,at,"meter-per-second",n);break;case"classified_arrow":i=Z(t,r??[],o,n);break;case"ocean_current_m":i=Z(t,we,"meter-per-second",n);break;case"ocean_current_kn":i=Z(t,ye,"knots",n)}return i}function Me(t,e){const{style:n,inputUnit:o,outputUnit:r,breakValues:i}=e,l=st.fromJSON(o),f=st.fromJSON(r),h=7*6,a=15;let s=0,c=0;const{width:p,height:u,mask:m}=t,d=t.pixels[0],x=t.pixels[1],y=m!=null?m.filter(g=>g>0).length:p*u,M=new Float32Array(y*h),k=new Uint32Array(a*y),w=e.invertDirection?St(0,0,0,!1):ge;for(let g=0;g<u;g++)for(let b=0;b<p;b++){const U=g*p+b;if(!m||m[g*p+b]){const T=(x[U]+360)%360/180*Math.PI,B=ke(d[U],n,l,f,i);for(let I=0;I<w.length;I+=2)M[s++]=(b+.5)/p,M[s++]=(g+.5)/u,M[s++]=w[I],M[s++]=w[I+1]+T,M[s++]=B,M[s++]=d[U];const v=7*(s/h-1);k[c++]=v,k[c++]=v+1,k[c++]=v+2,k[c++]=v+0,k[c++]=v+4,k[c++]=v+3,k[c++]=v+0,k[c++]=v+2,k[c++]=v+3,k[c++]=v+2,k[c++]=v+5,k[c++]=v+3,k[c++]=v+5,k[c++]=v+6,k[c++]=v+3}}return{vertexData:M,indexData:k}}const kt=[];function Ae(t,e){if(kt.length===0)for(let u=0;u<30;u++)kt.push(xe(5*u,0,!e.invertDirection));const n=rt(st.fromJSON(e.inputUnit),"knots"),{width:o,height:r,mask:i}=t,l=t.pixels[0],f=t.pixels[1],h=6,a=[],s=[];let c=0,p=0;for(let u=0;u<r;u++)for(let m=0;m<o;m++){const d=u*o+m,x=l[d]*n;if((!i||i[u*o+m])&&x>=xt){const y=(f[d]+360)%360/180*Math.PI,{pennants:M,barbs:k,shaft:w}=kt[Math.min(Math.floor(x/5),29)];if(M.length+k.length===0)continue;let g=a.length/h;const b=(m+.5)/o,U=(u+.5)/r;for(let T=0;T<M.length;T+=2)a[c++]=b,a[c++]=U,a[c++]=M[T],a[c++]=M[T+1]+y,a[c++]=0,a[c++]=x;for(let T=0;T<k.length;T+=2)a[c++]=b,a[c++]=U,a[c++]=k[T],a[c++]=k[T+1]+y,a[c++]=0,a[c++]=x;for(let T=0;T<w.length;T+=2)a[c++]=b,a[c++]=U,a[c++]=w[T],a[c++]=w[T+1]+y,a[c++]=0,a[c++]=x;for(let T=0;T<M.length/6;T++)s[p++]=g,s[p++]=g+1,s[p++]=g+2,g+=3;for(let T=0;T<k.length/8;T++)s[p++]=g,s[p++]=g+1,s[p++]=g+2,s[p++]=g+1,s[p++]=g+2,s[p++]=g+3,g+=4;s[p++]=g+0,s[p++]=g+1,s[p++]=g+2,s[p++]=g+1,s[p++]=g+3,s[p++]=g+2,g+=4}}return{vertexData:new Float32Array(a),indexData:new Uint32Array(s)}}function Ft(t,e){let n=0,o=0;const{width:r,height:i,mask:l}=t,f=t.pixels[0],h=[],a=[],s=rt(st.fromJSON(e.inputUnit),"knots"),c=e.style==="wind_speed"?xt:Number.MAX_VALUE;for(let p=0;p<i;p++)for(let u=0;u<r;u++){const m=f[p*r+u]*s;if((!l||l[p*r+u])&&m<c){for(let x=0;x<4;x++)h[n++]=(u+.5)/r,h[n++]=(p+.5)/i,h[n++]=x<2?-.5:.5,h[n++]=x%2==0?-.5:.5,h[n++]=0,h[n++]=m;const d=4*(n/24-1);a[o++]=d,a[o++]=d+1,a[o++]=d+2,a[o++]=d+1,a[o++]=d+2,a[o++]=d+3}}return{vertexData:new Float32Array(h),indexData:new Uint32Array(a)}}function be(t,e){return e.style==="simple_scalar"?Ft(t,e):e.style==="wind_speed"?Ae(t,e):Me(t,e)}function ve(t,e,n,o=[0,0],r=.5){const{width:i,height:l,mask:f}=t,[h,a]=t.pixels,[s,c]=o,p=Math.round((i-s)/n),u=Math.round((l-c)/n),m=p*u,d=new Float32Array(m),x=new Float32Array(m),y=new Uint8Array(m);for(let k=0;k<u;k++)for(let w=0;w<p;w++){let g=0;const b=k*p+w,U=Math.max(0,k*n+c),T=Math.max(0,w*n+s),B=Math.min(l,U+n),v=Math.min(i,T+n);for(let I=U;I<B;I++)for(let A=T;A<v;A++){const P=I*i+A;if(!f||f[P]){g++;const C=[h[P],a[P]],[S,F]=C;d[b]+=S,x[b]+=F}}if(g>=(B-U)*(v-T)*(1-r)){y[b]=1;const[I,A]=wt([d[b]/g,x[b]/g]);d[b]=I,x[b]=A}else y[b]=0,d[b]=0,x[b]=0}const M=new D({width:p,height:u,pixels:[d,x],mask:y});return M.updateStatistics(),M}const z=()=>H.getLogger("esri.views.2d.engine.flow.dataUtils"),Ue=10;async function Te(t,e,n,o){const r=performance.now(),i=Pe(e,n),l=performance.now(),f=Be(e,i,n.width,n.height),h=performance.now(),a=Fe(f),s=performance.now(),c=t==="Streamlines"?Ce(a,Ue):Ve(a),p=performance.now();return et("esri-2d-profiler")&&(z().info("I.1","_createFlowFieldFromData (ms)",Math.round(l-r)),z().info("I.2","_getStreamlines (ms)",Math.round(h-l)),z().info("I.3","createAnimatedLinesData (ms)",Math.round(s-h)),z().info("I.4","create{Streamlines|Particles}Mesh (ms)",Math.round(p-s)),z().info("I.5","createFlowMesh (ms)",Math.round(p-r)),z().info("I.6","Mesh size (bytes)",c.vertexData.buffer.byteLength+c.indexData.buffer.byteLength)),await Promise.resolve(),Nt(o),c}function Pe(t,e){const n=Se(e.data,e.width,e.height,t.smoothing);return t.interpolate?(o,r)=>{const i=Math.floor(o),l=Math.floor(r);if(i<0||i>=e.width)return[0,0];if(l<0||l>=e.height)return[0,0];const f=o-i,h=r-l,a=i,s=l,c=i<e.width-1?i+1:i,p=l<e.height-1?l+1:l,u=n[2*(s*e.width+a)],m=n[2*(s*e.width+c)],d=n[2*(p*e.width+a)],x=n[2*(p*e.width+c)],y=n[2*(s*e.width+a)+1],M=n[2*(s*e.width+c)+1];return[(u*(1-h)+d*h)*(1-f)+(m*(1-h)+x*h)*f,(y*(1-h)+n[2*(p*e.width+a)+1]*h)*(1-f)+(M*(1-h)+n[2*(p*e.width+c)+1]*h)*f]}:(o,r)=>{const i=Math.round(o),l=Math.round(r);return i<0||i>=e.width||l<0||l>=e.height?[0,0]:[n[2*(l*e.width+i)],n[2*(l*e.width+i)+1]]}}function Ie(t,e,n,o,r,i,l,f,h){const a=[];let s=n,c=o,p=0,[u,m]=e(s,c);u*=t.velocityScale,m*=t.velocityScale;const d=Math.sqrt(u*u+m*m);let x,y;a.push({x:s,y:c,t:p,speed:d});for(let M=0;M<t.verticesPerLine;M++){let[k,w]=e(s,c);k*=t.velocityScale,w*=t.velocityScale;const g=Math.sqrt(k*k+w*w);if(g<t.minSpeedThreshold)return a;const b=k/g,U=w/g;if(s+=b*t.segmentLength,c+=U*t.segmentLength,p+=t.segmentLength/g,Math.acos(b*x+U*y)>t.maxTurnAngle)return a;if(t.collisions){const T=Math.round(s*h),B=Math.round(c*h);if(T<0||T>l-1||B<0||B>f-1)return a;const v=i[B*l+T];if(v!==-1&&v!==r)return a;i[B*l+T]=r}a.push({x:s,y:c,t:p,speed:g}),x=b,y=U}return a}function Be(t,e,n,o){const r=[],i=new Mt,l=1/Math.max(t.lineCollisionWidth,1),f=Math.round(n*l),h=Math.round(o*l),a=new Int32Array(f*h);for(let c=0;c<a.length;c++)a[c]=-1;const s=[];for(let c=0;c<o;c+=t.lineSpacing)for(let p=0;p<n;p+=t.lineSpacing)s.push({x:p,y:c,sort:i.getFloat()});s.sort((c,p)=>c.sort-p.sort);for(const{x:c,y:p}of s)if(i.getFloat()<t.density){const u=Ie(t,e,c,p,r.length,a,f,h,l);if(u.length<2)continue;r.push(u)}return r}function Se(t,e,n,o){if(o===0)return t;const r=Math.round(3*o),i=new Array(2*r+1);let l=0;for(let a=-r;a<=r;a++){const s=Math.exp(-a*a/(o*o));i[a+r]=s,l+=s}for(let a=-r;a<=r;a++)i[a+r]/=l;const f=new Float32Array(t.length);for(let a=0;a<n;a++)for(let s=0;s<e;s++){let c=0,p=0;for(let u=-r;u<=r;u++){if(s+u<0||s+u>=e)continue;const m=i[u+r];c+=m*t[2*(a*e+(s+u))],p+=m*t[2*(a*e+(s+u))+1]}f[2*(a*e+s)]=c,f[2*(a*e+s)+1]=p}const h=new Float32Array(t.length);for(let a=0;a<e;a++)for(let s=0;s<n;s++){let c=0,p=0;for(let u=-r;u<=r;u++){if(s+u<0||s+u>=n)continue;const m=i[u+r];c+=m*f[2*((s+u)*e+a)],p+=m*f[2*((s+u)*e+a)+1]}h[2*(s*e+a)]=c,h[2*(s*e+a)+1]=p}return h}function Fe(t,e){const n=new Mt,o=t.reduce((h,a)=>h+a.length,0),r=new Float32Array(4*o),i=new Array(t.length);let l=0,f=0;for(const h of t){const a=l;for(const s of h)r[4*l]=s.x,r[4*l+1]=s.y,r[4*l+2]=s.t,r[4*l+3]=s.speed,l++;i[f++]={startVertex:a,numberOfVertices:h.length,totalTime:h[h.length-1].t,timeSeed:n.getFloat()}}return{lineVertices:r,lineDescriptors:i}}function Ce(t,e){const{lineVertices:n,lineDescriptors:o}=t;let r=0,i=0;for(const p of o)r+=2*p.numberOfVertices,i+=6*(p.numberOfVertices-1);const l=new Float32Array(r*9),f=new Uint32Array(i);let h=0,a=0;function s(){f[a++]=h-2,f[a++]=h,f[a++]=h-1,f[a++]=h,f[a++]=h+1,f[a++]=h-1}function c(p,u,m,d,x,y,M,k){const w=h*9;let g=0;l[w+g++]=p,l[w+g++]=u,l[w+g++]=1,l[w+g++]=m,l[w+g++]=y,l[w+g++]=M,l[w+g++]=d/2,l[w+g++]=x/2,l[w+g++]=k,h++,l[w+g++]=p,l[w+g++]=u,l[w+g++]=-1,l[w+g++]=m,l[w+g++]=y,l[w+g++]=M,l[w+g++]=-d/2,l[w+g++]=-x/2,l[w+g++]=k,h++}for(const p of o){const{totalTime:u,timeSeed:m}=p;let d=null,x=null,y=null,M=null,k=null,w=null;for(let g=0;g<p.numberOfVertices;g++){const b=n[4*(p.startVertex+g)],U=n[4*(p.startVertex+g)+1],T=n[4*(p.startVertex+g)+2],B=n[4*(p.startVertex+g)+3];let v=null,I=null,A=null,P=null;if(g>0){v=b-d,I=U-x;const C=Math.sqrt(v*v+I*I);if(v/=C,I/=C,g>1){let S=v+k,F=I+w;const j=Math.sqrt(S*S+F*F);S/=j,F/=j;const V=Math.min(1/(S*v+F*I),e);S*=V,F*=V,A=-F,P=S}else A=-I,P=v;A!==null&&P!==null&&(c(d,x,y,A,P,u,m,B),s())}d=b,x=U,y=T,k=v,w=I,M=B}c(d,x,y,-w,k,u,m,M)}return{vertexData:l,indexData:f}}function Ve(t){const{lineVertices:e,lineDescriptors:n}=t;let o=0,r=0;for(const A of n){const P=A.numberOfVertices-1;o+=4*P*2,r+=6*P*2}const i=new Float32Array(o*16),l=new Uint32Array(r);let f,h,a,s,c,p,u,m,d,x,y,M,k,w,g=0,b=0;function U(){l[b++]=g-8,l[b++]=g-7,l[b++]=g-6,l[b++]=g-7,l[b++]=g-5,l[b++]=g-6,l[b++]=g-4,l[b++]=g-3,l[b++]=g-2,l[b++]=g-3,l[b++]=g-1,l[b++]=g-2}function T(A,P,C,S,F,j,V,G,O,$,K,X,Y,tt){const _=g*16;let L=0;for(const nt of[1,2])for(const it of[1,2,3,4])i[_+L++]=A,i[_+L++]=P,i[_+L++]=C,i[_+L++]=S,i[_+L++]=V,i[_+L++]=G,i[_+L++]=O,i[_+L++]=$,i[_+L++]=nt,i[_+L++]=it,i[_+L++]=Y,i[_+L++]=tt,i[_+L++]=F/2,i[_+L++]=j/2,i[_+L++]=K/2,i[_+L++]=X/2,g++}function B(A,P){let C=d+y,S=x+M;const F=Math.sqrt(C*C+S*S);C/=F,S/=F;const j=d*C+x*S;C/=j,S/=j;let V=y+k,G=M+w;const O=Math.sqrt(V*V+G*G);V/=O,G/=O;const $=y*V+M*G;V/=$,G/=$,T(f,h,a,s,-S,C,c,p,u,m,-G,V,A,P),U()}function v(A,P,C,S,F,j){if(d=y,x=M,y=k,M=w,d==null&&x==null&&(d=y,x=M),c!=null&&p!=null){k=A-c,w=P-p;const V=Math.sqrt(k*k+w*w);k/=V,w/=V}d!=null&&x!=null&&B(F,j),f=c,h=p,a=u,s=m,c=A,p=P,u=C,m=S}function I(A,P){d=y,x=M,y=k,M=w,d==null&&x==null&&(d=y,x=M),d!=null&&x!=null&&B(A,P)}for(const A of n){f=null,h=null,a=null,s=null,c=null,p=null,u=null,m=null,d=null,x=null,y=null,M=null,k=null,w=null;const{totalTime:P,timeSeed:C}=A;for(let S=0;S<A.numberOfVertices;S++)v(e[4*(A.startVertex+S)],e[4*(A.startVertex+S)+1],e[4*(A.startVertex+S)+2],e[4*(A.startVertex+S)+3],P,C);I(P,C)}return{vertexData:i,indexData:l}}function Ct(t,e){const n=e.pixels,{width:o,height:r}=e,i=new Float32Array(o*r*2),l=e.mask||new Uint8Array(o*r*2);if(e.mask||l.fill(255),t==="vector-uv")for(let f=0;f<o*r;f++)i[2*f]=n[0][f],i[2*f+1]=-n[1][f];else if(t==="vector-magdir")for(let f=0;f<o*r;f++){const h=n[0][f],a=$t(n[1][f]),s=Math.cos(a-Math.PI/2),c=Math.sin(a-Math.PI/2);i[2*f]=s*h,i[2*f+1]=c*h}return{data:i,mask:l,width:o,height:r}}async function _e(t,e,n,o,r,i){const l=performance.now(),f=Ot(e.spatialReference);if(!f){const w=await Vt(t,e,n,o,r,i);return et("esri-2d-profiler")&&z().info("I.7","loadImagery, early exit (ms)",Math.round(performance.now()-l)),et("esri-2d-profiler")&&z().info("I.9","Number of parts",1),w}const[h,a]=f.valid,s=a-h,c=Math.ceil(e.width/s),p=e.width/c,u=Math.round(n/c);let m=e.xmin;const d=[],x=performance.now();for(let w=0;w<c;w++){const g=new Wt({xmin:m,xmax:m+p,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference});d.push(Vt(t,g,u,o,r,i)),m+=p}const y=await Promise.all(d);et("esri-2d-profiler")&&z().info("I.8","All calls to _fetchPart (ms)",Math.round(performance.now()-x)),et("esri-2d-profiler")&&z().info("I.9","Number of parts",y.length);const M={data:new Float32Array(n*o*2),mask:new Uint8Array(n*o),width:n,height:o};let k=0;for(const w of y){for(let g=0;g<w.height;g++)for(let b=0;b<w.width;b++)k+b>=n||(M.data[2*(g*n+k+b)]=w.data[2*(g*w.width+b)],M.data[2*(g*n+k+b)+1]=w.data[2*(g*w.width+b)+1],M.mask[g*n+k+b]=w.mask[g*w.width+b]);k+=w.width}return et("esri-2d-profiler")&&z().info("I.10","loadImagery, general exit (ms)",Math.round(performance.now()-l)),M}async function Vt(t,e,n,o,r,i){const l={requestProjectedLocalDirections:!0,signal:i};if(r!=null&&(l.timeExtent=r),t.type==="imagery"){await t.load({signal:i});const a=t.rasterInfo.dataType,s=await t.fetchImage(e,n,o,l);return s?.pixelData?.pixelBlock==null?{data:new Float32Array(n*o*2),mask:new Uint8Array(n*o),width:n,height:o}:Ct(a,s.pixelData.pixelBlock)}await t.load({signal:i});const f=t.serviceRasterInfo.dataType,h=await t.fetchPixels(e,n,o,l);return h?.pixelBlock==null?{data:new Float32Array(n*o*2),mask:new Uint8Array(n*o),width:n,height:o}:Ct(f,h.pixelBlock)}export{fe as D,he as E,le as M,mt as P,ce as R,ve as S,oe as T,be as U,ae as W,Ft as _,D as a,Ht as b,Jt as c,rt as d,Te as e,yt as f,_e as g,Yt as h,wt as i,ut as j,Xt as k,ct as l,me as m,ft as n,R as o,de as p,te as q,Kt as r,st as s,pt as t,Qt as u,Zt as v,ne as w,Ut as x,ee as y,pe as z};
