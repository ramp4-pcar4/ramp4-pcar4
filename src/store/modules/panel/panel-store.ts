import type { ActionContext } from 'vuex';
import { make } from 'vuex-pathify';

import { PanelState } from './panel-state';
import type { PanelConfig } from './panel-state';
import type { RootState } from '@/store/state';
import type { PanelInstance } from '@/api';
import { DefPromise } from '@/geo/api';

type PanelContext = ActionContext<PanelState, RootState>;

export enum PanelAction {
    openPanel = 'openPanel',
    closePanel = 'closePanel',
    movePanel = 'movePanel',
    removePanel = 'removePanel',
    setWidth = 'setWidth',
    setStackWidth = 'setStackWidth',
    setMobileView = 'setMobileView',
    updateVisible = 'updateVisible'
}

export enum PanelMutation {
    REGISTER_PANEL = 'REGISTER_PANEL',
    OPEN_PANEL = 'OPEN_PANEL',

    ADD_TO_PANEL_ORDER = 'ADD_TO_PANEL_ORDER',
    ADD_REG_PROMISE = 'ADD_REG_PROMISE',
    CLOSE_PANEL = 'CLOSE_PANEL',
    REMOVE_PANEL = 'REMOVE_PANEL',
    MOVE_PANEL = 'MOVE_PANEL',

    SET_ORDERED_ITEMS = 'SET_ORDERED_ITEMS',
    SET_PRIORITY = 'SET_PRIORITY',
    SET_VISIBLE = 'SET_VISIBLE',
    SET_WIDTH = 'SET_WIDTH',
    SET_REMAINING_WIDTH = 'SET_REMAINING_WIDTH'
}

const getters = {
    /**
     * Returns `visible` from the state. If the screenSize of the app is 'xs', returns only the first panel.
     *
     * @param screenSize the size of the app's screen as a string
     * @returns {PanelConfig[]}
     */
    getVisible:
        (state: PanelState) =>
        (screenSize: string): PanelConfig[] => {
            if (screenSize === 'xs' && state.visible.length > 0) {
                return [state.visible.slice().pop()!];
            }

            return state.visible;
        },

    /**
     * Returns `remainingWidth` from the state. Displays how much space is left for panels to be displayed on the map.
     *
     * @returns {number}
     */
    getRemainingWidth: (state: PanelState): number => {
        return state.remainingWidth;
    },

    /**
     * Returns registration promises from the state, for the specified panelIds.
     * Should ideally be called when all panelIds have a promise associated with them.
     * @param panelIds the panel Ids for which promises should be returned
     */
    getRegPromises:
        (state: PanelState) =>
        (panelIds: string[]): Promise<void>[] => {
            const regPromises: Promise<void>[] = [];
            panelIds.forEach((panelId: string) => {
                if (panelId in state.regPromises) {
                    regPromises.push(state.regPromises[panelId].getPromise());
                }
            });
            return regPromises;
        }
};

const actions = {
    [PanelAction.openPanel](
        context: PanelContext,
        value: { panel: PanelInstance }
    ): void {
        context.commit(PanelMutation.OPEN_PANEL, value);
        context.commit(PanelMutation.SET_PRIORITY, value);
        context.dispatch(PanelAction.updateVisible);
    },

    [PanelAction.closePanel](
        context: PanelContext,
        value: { panel: PanelConfig }
    ): void {
        if (context.state.priority === value.panel) {
            context.commit(PanelMutation.SET_PRIORITY, null);
        }

        context.commit(PanelMutation.CLOSE_PANEL, value);
        context.dispatch(PanelAction.updateVisible);
    },

    [PanelAction.movePanel](
        context: PanelContext,
        value: { panel: PanelConfig; direction: string }
    ): void {
        context.commit(PanelMutation.MOVE_PANEL, value);
        context.dispatch(PanelAction.updateVisible);
    },

    [PanelAction.removePanel](
        context: PanelContext,
        value: { panel: PanelConfig }
    ): void {
        if (context.state.priority === value.panel) {
            context.commit(PanelMutation.SET_PRIORITY, null);
        }

        context.commit(PanelMutation.REMOVE_PANEL, value);
        context.dispatch(PanelAction.updateVisible);
    },

    [PanelAction.setWidth](context: PanelContext, value: number): void {
        context.commit(PanelMutation.SET_WIDTH, value);
        context.dispatch(PanelAction.updateVisible);
    },

    /**
     * Sets the width of the panel stack and re-calculates which panels are visible given the new width.
     *
     * @param {PanelContext} context
     * @param {number} value
     */
    [PanelAction.setStackWidth](context: PanelContext, value: number): void {
        context.commit('SET_STACK_WIDTH', value); // `SET_STACK_WIDTH` mutation is auto-generated by pathify
        context.dispatch(PanelAction.updateVisible);
    },

    [PanelAction.setMobileView](context: PanelContext, value: boolean): void {
        context.commit('SET_MOBILE_VIEW', value);
    },

    [PanelAction.updateVisible](context: PanelContext): void {
        // TODO: update when panel width system is in place
        let remainingWidth = context.state.stackWidth;
        const nowVisible: PanelInstance[] = [];

        // add panels until theres no space in the stack
        for (let i = context.state.orderedItems.length - 1; i >= 0; i--) {
            let panelWidth = context.state.orderedItems[i].width || 350;

            // if not in mobile view, all panels have a 12px margin to the right
            if (!context.state.mobileView) {
                panelWidth += 12;
            } else {
                // if in mobile view, a single panel will take up the whole view
                panelWidth = remainingWidth;
            }

            // mobile mode only allows for one panel to be visible
            if (
                (remainingWidth >= panelWidth && !context.state.mobileView) ||
                nowVisible.length === 0
            ) {
                remainingWidth -= panelWidth;
                nowVisible.unshift(context.state.orderedItems[i]);
            }
        }

        // if pinned isn't visible we need to change the order of the panels (to make it visible)
        if (
            context.state.pinned &&
            !nowVisible.includes(context.state.pinned)
        ) {
            let lastElement: PanelInstance;
            // remove elements from visible until theres room for pinned
            for (
                let i = 0;
                i < nowVisible.length - 1 &&
                remainingWidth < (context.state.pinned.width || 350);
                i++
            ) {
                lastElement = nowVisible.shift()!;
                remainingWidth += lastElement.width || 350;
            }

            if (remainingWidth >= (context.state.pinned.width || 350)) {
                // if theres room insert pinned element
                nowVisible.unshift(context.state.pinned);
            } else {
                // otherwise there is only one element in `nowVisible` (loop invariant fun)
                // if there is no priority, the one element should be pinned
                // otherwise the priority element stays as the only visible
                if (!context.state.priority) {
                    lastElement = nowVisible.shift()!;
                    nowVisible.unshift(context.state.pinned);
                }
            }

            const pinnedIndex = context.state.orderedItems.indexOf(
                context.state.pinned
            );
            const lastRemovedIndex = context.state.orderedItems.indexOf(
                lastElement!
            );
            // clone the current order, splice out the pinned item, insert it back in after the last element we removed from visible
            const newPanelOrder = context.state.orderedItems.slice();
            if (lastRemovedIndex > -1) {
                newPanelOrder.splice(pinnedIndex, 1);
                newPanelOrder.splice(lastRemovedIndex, 0, context.state.pinned);
            }

            context.commit(PanelMutation.SET_ORDERED_ITEMS, newPanelOrder);
        } else {
            context.commit(PanelMutation.SET_PRIORITY, null);
        }
        context.commit(PanelMutation.SET_REMAINING_WIDTH, remainingWidth);
        context.commit(PanelMutation.SET_VISIBLE, nowVisible);
    }
};

const mutations = {
    [PanelMutation.REGISTER_PANEL](
        state: PanelState,
        { panel }: { panel: PanelInstance }
    ): void {
        state.items = { ...state.items, [panel.id]: panel };
        // since panel has successfully registered, resolve its associated registration promise
        if (!(panel.id in state.regPromises)) {
            const regPromise = new DefPromise();
            regPromise.resolveMe();
            state.regPromises = {
                ...state.regPromises,
                [panel.id]: regPromise
            };
        } else {
            state.regPromises[panel.id].resolveMe();
        }
    },

    [PanelMutation.OPEN_PANEL](
        state: PanelState,
        { panel }: { panel: PanelInstance }
    ): void {
        state.orderedItems = [...state.orderedItems, panel];
    },

    [PanelMutation.CLOSE_PANEL](
        state: PanelState,
        { panel }: { panel: PanelInstance }
    ): void {
        const index = state.orderedItems.indexOf(panel);
        if (index !== -1) {
            state.orderedItems = [
                ...state.orderedItems.slice(0, index),
                ...state.orderedItems.slice(index + 1)
            ];
        }
    },

    [PanelMutation.MOVE_PANEL](
        state: PanelState,
        { panel, direction }: { panel: PanelInstance; direction: string }
    ): void {
        const index = state.orderedItems.indexOf(panel);
        const delta = direction === 'right' ? 1 : -1;
        if (state.visible.includes(state.orderedItems[index + delta])) {
            [state.orderedItems[index], state.orderedItems[index + delta]] = [
                state.orderedItems[index + delta],
                state.orderedItems[index]
            ];
        }
    },

    [PanelMutation.REMOVE_PANEL](
        state: PanelState,
        { panel }: { panel: PanelInstance }
    ): void {
        // remove from items
        if (state.items[panel.id] !== undefined) {
            delete state.items[panel.id];
        }

        // remove registration promise
        if (state.regPromises[panel.id] !== undefined) {
            delete state.regPromises[panel.id];
        }
        // remove from visible
        const index = state.visible.indexOf(panel);
        if (index !== -1) {
            state.visible = [
                ...state.visible.slice(0, index),
                ...state.visible.slice(index + 1)
            ];
        }

        // remove from pinner
        if (state.pinned !== null && state.pinned.id == panel.id) {
            state.pinned = null;
        }
    },

    [PanelMutation.ADD_REG_PROMISE](state: PanelState, panelId: string): void {
        state.regPromises = {
            ...state.regPromises,
            [panelId]: new DefPromise()
        };
    }
};

export function panel() {
    const state = new PanelState();

    return {
        namespaced: true,
        state,
        getters: { ...getters },
        actions: { ...actions },
        mutations: { ...mutations, ...make.mutations(state) }
    };
}
