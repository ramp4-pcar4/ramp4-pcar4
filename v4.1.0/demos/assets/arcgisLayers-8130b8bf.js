import{_ as S}from"./preload-helper-388ac9d5.js";import{D as v,b as f,f as w,b5 as h,r as m,b6 as O,Y as L,b7 as p}from"./main-e6c796d9.js";import{t as d,r as P}from"./fetchService-ef4ecfd2.js";import{a as T}from"./lazyLayerLoader-ee560691.js";const g={FeatureLayer:!0,SceneLayer:!0};async function k(r){const l=r.properties?.customParameters,e=await F(r.url,l),a={...r.properties,url:r.url};if(!e.sublayerIds)return e.layerOrTableId!=null&&(a.layerId=e.layerOrTableId,a.sourceJSON=e.sourceJSON),new e.Constructor(a);const t=new(await S(()=>import("./GroupLayer-3827d466.js"),["./GroupLayer-3827d466.js","./main-e6c796d9.js","./preload-helper-388ac9d5.js","./main-dcc594cc.css","./lazyLayerLoader-ee560691.js"],import.meta.url)).default({title:e.parsedUrl.title});return C(t,e,a),t}function I(r,l){return r?r.find(e=>e.id===l):null}function C(r,l,e){function a(t,s){const o={...e,layerId:t,sublayerTitleMode:"service-name"};return m(s)&&(o.sourceJSON=s),new l.Constructor(o)}l.sublayerIds.forEach(t=>{const s=a(t,I(l.sublayerInfos,t));r.add(s)}),l.tableIds.forEach(t=>{const s=a(t,I(l.tableInfos,t));r.tables.add(s)})}async function F(r,l){let e=v(r);if(f(e)&&(e=await N(r,l)),f(e))throw new w("arcgis-layers:url-mismatch","The url '${url}' is not a valid arcgis resource",{url:r});const{serverType:a,sublayer:t}=e;let s;const o={FeatureServer:"FeatureLayer",StreamServer:"StreamLayer",VectorTileServer:"VectorTileLayer"};switch(a){case"MapServer":t!=null?s="FeatureLayer":s=await U(r,l)?"TileLayer":"MapImageLayer";break;case"ImageServer":{const n=await d(r,{customParameters:l}),{tileInfo:y,cacheType:i}=n;s=y?y?.format?.toUpperCase()!=="LERC"||i&&i.toLowerCase()!=="elevation"?"ImageryTileLayer":"ElevationLayer":"ImageryLayer";break}case"SceneServer":{const n=await d(e.url.path,{customParameters:l});if(s="SceneLayer",n){const y=n?.layers;if(n?.layerType==="Voxel")s="VoxelLayer";else if(y?.length){const i=y[0]?.layerType;i!=null&&p[i]!=null&&(s=p[i])}}break}default:s=o[a]}const u=a==="FeatureServer",c={parsedUrl:e,Constructor:null,layerOrTableId:u?t:void 0,sublayerIds:null,tableIds:null};if(g[s]&&t==null){const n=await _(r,a,l);u&&(c.sublayerInfos=n.layerInfos,c.tableInfos=n.tableInfos),n.layerIds.length+n.tableIds.length!==1?(c.sublayerIds=n.layerIds,c.tableIds=n.tableIds):u&&(c.layerOrTableId=n.layerIds[0]??n.tableIds[0],c.sourceJSON=n.layerInfos?.[0]??n.tableInfos?.[0])}return c.Constructor=await J(s),c}async function N(r,l){const e=await d(r,{customParameters:l});let a=null,t=null;const s=e.type;if(s==="Feature Layer"||s==="Table"?(a="FeatureServer",t=e.id??null):s==="indexedVector"?a="VectorTileServer":e.hasOwnProperty("mapName")?a="MapServer":e.hasOwnProperty("bandCount")&&e.hasOwnProperty("pixelSizeX")?a="ImageServer":e.hasOwnProperty("maxRecordCount")&&e.hasOwnProperty("allowGeometryUpdates")?a="FeatureServer":e.hasOwnProperty("streamUrls")?a="StreamServer":b(e)?(a="SceneServer",t=e.id):e.hasOwnProperty("layers")&&b(e.layers?.[0])&&(a="SceneServer"),!a)return null;const o=t!=null?h(r):null;return{title:m(o)&&e.name||O(r),serverType:a,sublayer:t,url:{path:m(o)?o.serviceUrl:L(r).path}}}function b(r){return r!=null&&r.hasOwnProperty("store")&&r.hasOwnProperty("id")&&typeof r.id=="number"}async function _(r,l,e){let a,t=!1;if(l==="FeatureServer"){const u=await P(r,{customParameters:e});t=!!u.layersJSON,a=u.layersJSON||u.serviceJSON}else a=await d(r,{customParameters:e});const s=a?.layers,o=a?.tables;return{layerIds:s?.map(u=>u.id).reverse()||[],tableIds:o?.map(u=>u.id).reverse()||[],layerInfos:t?s:[],tableInfos:t?o:[]}}async function J(r){return(0,T[r])()}async function U(r,l){return(await d(r,{customParameters:l})).tileInfo}export{k as fromUrl};
