import{hY as u,hZ as f,hj as g,hr as m,h_ as p,h$ as L,i0 as w,hi as A}from"./main-e6c796d9.js";import{H as h,a as n,F as l,D as H}from"./hilight-defs-1101779f.js";import"./preload-helper-388ac9d5.js";class c extends u{config={};mode=h.NONE;constructor(e,i){super(i),this.config=e,this.mode=e.mode}async add(e){this.notImplementedError("addGraphics")}async remove(e){this.notImplementedError("removeGraphics")}async reloadHilight(e){}async getHilightLayer(){const e=await this.layerFetcher();if(e){if(e.isLoaded&&e instanceof f)return e;console.warn("Hilight layer exists but is in bad form.");return}else{console.warn("Hilight layer could not be fetched.");return}}notImplementedError(e){console.warn("Hilight mode method {method} was not implemented by subclass.")}layerFetcher(){return new Promise(e=>{let i=0;const t=setInterval(()=>{const a=this.$iApi.geo.layer.getLayer(n);if(a)clearInterval(t),e(a);else if(i+=125,i>=1125){clearInterval(t),e(void 0);return}},125)})}}class d extends c{async add(e){const i=await this.getHilightLayer();i&&await i.addGraphic(e)}async remove(e){const i=await this.getHilightLayer();i&&i.removeGraphic(e)}async reloadHilight(e){await this.remove(e),await this.add(e)}}class v extends d{handlers=[];onOpacity;offOpacity;lastAdd=0;constructor(e,i){super(e,i),this.onOpacity=e.options?.onOpacity??.75,this.offOpacity=e.options?.offOpacity>.02?e.options.offOpacity:.02,this.hilightSetup(),this.handlers.push(this.$iApi.event.on(g.MAP_BASEMAPCHANGE,()=>{this.getHilightLayer().then(t=>{t&&t.graphics.length===0&&this.updateFogLayer()})}))}async hilightSetup(){const e=m(this.$vApp.$pinia).activeBasemapConfig;try{const i=this.$iApi.geo.layer.createLayer({id:l,layerType:p.TILE,cosmetic:!0,url:e.layers[0].url});await this.$iApi.geo.map.addLayer(i),i.opacity=this.offOpacity,await this.reorderFogLayer()}catch{console.error("Something went wrong while setting up the hilighter.")}}async updateFogLayer(){this.$iApi.geo.map.removeLayer(l),await this.hilightSetup()}async reorderFogLayer(){const e=this.getFogLayer(),i=await this.getHilightLayer();if(!i||!e)return;const t=this.$iApi.geo.layer.allLayers(),a=t.indexOf(e);t.indexOf(i)<a&&this.$iApi.geo.map.reorder(i,a+1,!1)}async add(e){this.lastAdd=Date.now();const i=this.getFogLayer();i&&(i.opacity=this.onOpacity,await super.add(e))}async remove(e){await super.remove(e);const i=this.getFogLayer();if(!i)return;const t=Date.now();setTimeout(()=>{this.lastAdd<t&&(i.opacity=this.offOpacity)},300)}async reloadHilight(e){await this.updateFogLayer(),await super.reloadHilight(e)}getFogLayer(){const e=this.$iApi.geo.layer.getLayer(l);if(e&&e instanceof L)return e;console.warn("Hilight fog layer could not be fetched.")}}class y extends d{handlers=[];constructor(e,i){super(e,i),this.hilightSetup(e),this.handlers.push(this.$iApi.event.on(g.MAP_CREATED,()=>{this.hilightSetup(e)}))}hilightSetup(e){this.$iApi.geo.map.viewPromise.then(()=>{this.$iApi.geo.map.esriView.highlightOptions=e.options})}async add(e){await super.add(e);const i=this.$iApi.geo.layer.getLayer(n);if(i&&i.esriLayer&&i.isLoaded&&i instanceof w){const t=e instanceof Array?e:[e];this.$iApi.geo.map.esriView?.whenLayerView(i.esriLayer)?.then(function(a){a.highlight(t.map(s=>i.getEsriGraphic(s.id)))})}}async remove(e){await super.remove(e)}}class $ extends A{hilightMode=new c({},this.$iApi);initialized(){this.initHilightLayer()}_parseConfig(e){if(e)switch(e.mode){case h.NONE:this.hilightMode=new c(e,this.$iApi);break;case h.GLOW:this.hilightMode=new y(e,this.$iApi);break;case h.LIFT:this.hilightMode=new d(e,this.$iApi);break;case h.FOG:this.hilightMode=new v(e,this.$iApi);break;default:console.error("Could not find hilight mode:",e.mode);break}else this.hilightMode=new y(H,this.$iApi)}async initHilightLayer(){const e=this.$iApi.geo.layer.createLayer({id:n,layerType:p.GRAPHIC,cosmetic:!0,url:""});await this.$iApi.geo.map.addLayer(e)}async addHilight(e){const i=e instanceof Array?e:[e];await this.hilightMode.add(i)}async removeHilight(e){const i=e?e instanceof Array?e:[e]:void 0;await this.hilightMode.remove(i)}async reloadHilight(e){const i=e instanceof Array?e:[e];await this.hilightMode.reloadHilight(i)}async getGraphicsByKey(e,i,t){const a=await this.getHilightLayer();if(!a)return[];let s=a.graphics.map(r=>({...this.deconstructGraphicKey(r.id),og:r}));return e&&(s=s.filter(r=>r.origin===e)),i&&(s=s.filter(r=>r.uid===i)),t&&(s=s.filter(r=>r.oid===t)),s.map(r=>r.og)}constructGraphicKey(e,i,t){return`${n}~${e}~${i}~${t}`}deconstructGraphicKey(e){const i=e.split("~");return i.length!==4&&console.warn("Malformed Hilight Graphic key provided:",e),{origin:i[1],uid:i[2],oid:parseInt(i[3])}}async getHilightLayer(){if(this.hilightMode)return await this.hilightMode.getHilightLayer();console.warn("API get layer request before highlight mode object exists")}}class F extends ${async added(){this._parseConfig(this.config);const e=this.$vApp.$watch(()=>this.config,i=>this._parseConfig(i));this.removed=()=>{e()}}}export{F as default};
