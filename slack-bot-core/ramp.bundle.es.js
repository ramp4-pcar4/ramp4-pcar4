import { ref, computed, markRaw, defineComponent, inject, reactive, watch, onBeforeUnmount, resolveDirective, withDirectives, openBlock, createElementBlock, withKeys, withModifiers, onMounted, normalizeClass, normalizeStyle, createVNode, Transition, withCtx, createBlock, resolveDynamicComponent, mergeProps, TransitionGroup, Fragment, renderList, unref, nextTick, renderSlot, createElementVNode, vShow, resolveComponent, createTextVNode, toDisplayString, createCommentVNode, onUpdated, Teleport, getCurrentInstance, createApp as createApp$1, toRaw, h, render, defineAsyncComponent, onBeforeMount, toRef, useTemplateRef, isRef, vModelText, provide, onErrorCaptured, vModelSelect, createStaticVNode } from 'vue';
import { createI18n, useI18n } from 'vue-i18n';
import { createPopper, detectOverflow } from '@popperjs/core';
import maxSize from 'popper-max-size-modifier';
import { TinyEmitter } from 'tiny-emitter';
import EsriBasemap from '@arcgis/core/Basemap';
import EsriColour from '@arcgis/core/Color';
import EsriConfig from '@arcgis/core/config';
import EsriExtent from '@arcgis/core/geometry/Extent';
import '@arcgis/core/geometry/Geometry';
import EsriMultipoint from '@arcgis/core/geometry/Multipoint';
import EsriPoint from '@arcgis/core/geometry/Point';
import EsriPolygon from '@arcgis/core/geometry/Polygon';
import EsriPolyline from '@arcgis/core/geometry/Polyline';
import EsriSpatialReference from '@arcgis/core/geometry/SpatialReference';
import { fromJSON as fromJSON$2 } from '@arcgis/core/geometry/support/jsonUtils';
import EsriGraphic from '@arcgis/core/Graphic';
import EsriFeatureLayer from '@arcgis/core/layers/FeatureLayer';
import EsriGraphicsLayer from '@arcgis/core/layers/GraphicsLayer';
import EsriImageryLayer from '@arcgis/core/layers/ImageryLayer';
import EsriMapImageLayer from '@arcgis/core/layers/MapImageLayer';
import EsriOpenStreetMapLayer from '@arcgis/core/layers/OpenStreetMapLayer';
import EsriTileLayer from '@arcgis/core/layers/TileLayer';
import EsriWMSLayer from '@arcgis/core/layers/WMSLayer';
import EsriField from '@arcgis/core/layers/support/Field';
import '@arcgis/core/layers/support/LOD';
import '@arcgis/core/layers/support/WMSSublayer';
import EsriMap from '@arcgis/core/Map';
import '@arcgis/core/renderers/ClassBreaksRenderer';
import '@arcgis/core/renderers/Renderer';
import EsriSimpleRenderer from '@arcgis/core/renderers/SimpleRenderer';
import '@arcgis/core/renderers/UniqueValueRenderer';
import '@arcgis/core/renderers/support/ClassBreakInfo';
import { fromJSON as fromJSON$1 } from '@arcgis/core/renderers/support/jsonUtils';
import '@arcgis/core/renderers/support/UniqueValueInfo';
import EsriRequest from '@arcgis/core/request';
import { executeForIds } from '@arcgis/core/rest/query';
import EsriQuery from '@arcgis/core/rest/support/Query';
import EsriPictureMarkerSymbol from '@arcgis/core/symbols/PictureMarkerSymbol';
import EsriSimpleFillSymbol from '@arcgis/core/symbols/SimpleFillSymbol';
import EsriSimpleLineSymbol from '@arcgis/core/symbols/SimpleLineSymbol';
import EsriSimpleMarkerSymbol from '@arcgis/core/symbols/SimpleMarkerSymbol';
import '@arcgis/core/symbols/Symbol';
import { fromJSON } from '@arcgis/core/symbols/support/jsonUtils';
import EsriFeatureFilter from '@arcgis/core/layers/support/FeatureFilter';
import EsriMapView from '@arcgis/core/views/MapView';
import EsriColorBackground from '@arcgis/core/webmap/background/ColorBackground';
import merge from 'deepmerge';
import { Tools } from 'terraformer';
import proj4 from 'proj4';
import { debounce, throttle } from 'throttle-debounce';
import { defineStore, createPinia } from 'pinia';
import screenfull from 'screenfull';
import clonedeep from 'lodash.clonedeep';
import VueTippy, { setDefaultProps, useTippy } from 'vue-tippy';
import linkifyHtml from 'linkify-html';
import ArcGIS from 'terraformer-arcgis-parser';
import { dsv, csv2geojson } from 'csv2geojson';
import shp from 'shpjs/dist/shp.min.js';
import axios from 'redaxios';
import JSZip from 'jszip';
import { geojson } from 'flatgeobuf';
import to from 'await-to-js';
import { XMLParser } from 'fast-xml-parser';
import svgjs from 'svg.js';
import { fabric } from 'fabric';
import FileSaver from 'file-saver';
import { marked } from 'marked';
import draggable from 'vuedraggable';
import VueSlider from 'vue-slider-component';
import 'vue-slider-component/theme/default.css';
import Toggle from '@vueform/toggle';
import { ColorPicker } from 'vue-accessible-color-picker';
import Treeselect from '@ramp4-pcar4/vue3-treeselect';
import '@ramp4-pcar4/vue3-treeselect/dist/vue3-treeselect.css';
import 'ag-grid-community/dist/styles/ag-grid.css';
import 'ag-grid-community/dist/styles/ag-theme-material.css';
import { AgGridVue } from 'ag-grid-vue3';
import { AG_GRID_LOCALE_EN, AG_GRID_LOCALE_FR } from '@ag-grid-community/locale';
import { GridApi, ColumnApi } from 'ag-grid-community';
import anime from 'animejs';
import 'tippy.js/animations/scale.css';

var FieldType = /* @__PURE__ */ ((FieldType2) => {
  FieldType2["BLOB"] = "blob";
  FieldType2["DATE"] = "date";
  FieldType2["DOUBLE"] = "double";
  FieldType2["GEOMETRY"] = "geometry";
  FieldType2["GLOBAL_ID"] = "global-id";
  FieldType2["GUID"] = "guid";
  FieldType2["INTEGER"] = "integer";
  FieldType2["LONG"] = "long";
  FieldType2["OID"] = "oid";
  FieldType2["RASTER"] = "raster";
  FieldType2["SINGLE"] = "single";
  FieldType2["SMALL_INTEGER"] = "small-integer";
  FieldType2["STRING"] = "string";
  FieldType2["XML"] = "xml";
  return FieldType2;
})(FieldType || {});
var PointStyleType = /* @__PURE__ */ ((PointStyleType2) => {
  PointStyleType2["CIRCLE"] = "circle";
  PointStyleType2["CROSS"] = "cross";
  PointStyleType2["DIAMOND"] = "diamond";
  PointStyleType2["ICON"] = "icon";
  PointStyleType2["PATH"] = "path";
  PointStyleType2["SQUARE"] = "square";
  PointStyleType2["TRIANGLE"] = "triangle";
  PointStyleType2["X"] = "x";
  return PointStyleType2;
})(PointStyleType || {});
var LineStyleType = /* @__PURE__ */ ((LineStyleType2) => {
  LineStyleType2["DASH"] = "dash";
  LineStyleType2["DASHDOT"] = "dash-dot";
  LineStyleType2["DASHDOTDOT"] = "short-dash-dot-dot";
  LineStyleType2["DOT"] = "dot";
  LineStyleType2["LONGDASH"] = "long-dash";
  LineStyleType2["LONGDASHDOT"] = "long-dash-dot";
  LineStyleType2["LONGDASHDOTDOT"] = "long-dash-dot-dot";
  LineStyleType2["NONE"] = "none";
  LineStyleType2["NULL"] = "none";
  LineStyleType2["SHORTDASH"] = "short-dash";
  LineStyleType2["SHORTDASHDOT"] = "short-dash-dot";
  LineStyleType2["SHORTDASHDOTDOT"] = "short-dash-dot-dot";
  LineStyleType2["SHORTDOT"] = "short-dot";
  LineStyleType2["SOLID"] = "solid";
  return LineStyleType2;
})(LineStyleType || {});
var LineJoinType = /* @__PURE__ */ ((LineJoinType2) => {
  LineJoinType2["BEVEL"] = "bevel";
  LineJoinType2["MITER"] = "miter";
  LineJoinType2["ROUND"] = "round";
  return LineJoinType2;
})(LineJoinType || {});
var LineCapType = /* @__PURE__ */ ((LineCapType2) => {
  LineCapType2["ROUND"] = "round";
  LineCapType2["BUTT"] = "butt";
  LineCapType2["SQUARE"] = "square";
  return LineCapType2;
})(LineCapType || {});
var FillStyleType = /* @__PURE__ */ ((FillStyleType2) => {
  FillStyleType2["BDIAG"] = "backward-diagonal";
  FillStyleType2["CROSS"] = "cross";
  FillStyleType2["DIAG_CROSS"] = "diagonal-cross";
  FillStyleType2["FDIAG"] = "forward-diagonal";
  FillStyleType2["HORIZONTAL"] = "horizontal";
  FillStyleType2["NONE"] = "none";
  FillStyleType2["NULL"] = "none";
  FillStyleType2["SOLID"] = "solid";
  FillStyleType2["VERTICAL"] = "vertical";
  return FillStyleType2;
})(FillStyleType || {});
var GeometryType = /* @__PURE__ */ ((GeometryType2) => {
  GeometryType2["POINT"] = "Point";
  GeometryType2["MULTIPOINT"] = "MultiPoint";
  GeometryType2["LINESTRING"] = "LineString";
  GeometryType2["MULTILINESTRING"] = "MultiLineString";
  GeometryType2["POLYGON"] = "Polygon";
  GeometryType2["MULTIPOLYGON"] = "MultiPolygon";
  GeometryType2["LINEARRING"] = "LinearRing";
  GeometryType2["EXTENT"] = "Extent";
  GeometryType2["NONE"] = "None";
  GeometryType2["UNKNOWN"] = "Unknown";
  return GeometryType2;
})(GeometryType || {});
var RendererType = /* @__PURE__ */ ((RendererType2) => {
  RendererType2["Simple"] = "simple";
  RendererType2["Unique"] = "uniqueValue";
  RendererType2["ClassBreaks"] = "classBreaks";
  RendererType2["Unknown"] = "unknown";
  return RendererType2;
})(RendererType || {});
var LayerType = /* @__PURE__ */ ((LayerType2) => {
  LayerType2["FEATURE"] = "esri-feature";
  LayerType2["MAPIMAGE"] = "esri-map-image";
  LayerType2["TILE"] = "esri-tile";
  LayerType2["IMAGERY"] = "esri-imagery";
  LayerType2["GRAPHIC"] = "esri-graphic";
  LayerType2["WMS"] = "ogc-wms";
  LayerType2["WFS"] = "ogc-wfs";
  LayerType2["GEOJSON"] = "file-geojson";
  LayerType2["GEOJSONZIPPED"] = "file-zip-geojson";
  LayerType2["CSV"] = "file-csv";
  LayerType2["SHAPEFILE"] = "file-shape";
  LayerType2["FLATGEOBUF"] = "file-fgb";
  LayerType2["FLATGEOBUFZIPPED"] = "file-zip-fgb";
  LayerType2["OSM"] = "osm-tile";
  LayerType2["DATACSV"] = "data-csv";
  LayerType2["DATAJSON"] = "data-json";
  LayerType2["DATATABLE"] = "data-esri-table";
  LayerType2["UNKNOWN"] = "unknown";
  LayerType2["SUBLAYER"] = "sublayer";
  return LayerType2;
})(LayerType || {});
var LayerFormat = /* @__PURE__ */ ((LayerFormat2) => {
  LayerFormat2["FEATURE"] = "feature";
  LayerFormat2["GRAPHIC"] = "graphic";
  LayerFormat2["IMAGERY"] = "imagery";
  LayerFormat2["MAPIMAGE"] = "map-image";
  LayerFormat2["NOLAYER"] = "no-layer";
  LayerFormat2["OSM"] = "osm-tile";
  LayerFormat2["TILE"] = "tile";
  LayerFormat2["UNKNOWN"] = "unknown";
  LayerFormat2["WMS"] = "wms";
  return LayerFormat2;
})(LayerFormat || {});
var DataFormat = /* @__PURE__ */ ((DataFormat2) => {
  DataFormat2["ESRI_FEATURE"] = "esriFeature";
  DataFormat2["ESRI_RASTER"] = "esriRaster";
  DataFormat2["ESRI_TILE"] = "esriTile";
  DataFormat2["OSM_TILE"] = "osmTile";
  DataFormat2["OGC_RASTER"] = "ogcRaster";
  DataFormat2["UNKNOWN"] = "unknown";
  return DataFormat2;
})(DataFormat || {});
var GeoJsonGeomType = /* @__PURE__ */ ((GeoJsonGeomType2) => {
  GeoJsonGeomType2["POINT"] = "Point";
  GeoJsonGeomType2["MULTIPOINT"] = "MultiPoint";
  GeoJsonGeomType2["LINESTRING"] = "LineString";
  GeoJsonGeomType2["MULTILINESTRING"] = "MultiLineString";
  GeoJsonGeomType2["POLYGON"] = "Polygon";
  GeoJsonGeomType2["MULTIPOLYGON"] = "MultiPolygon";
  return GeoJsonGeomType2;
})(GeoJsonGeomType || {});
var LayerIdentifyMode = /* @__PURE__ */ ((LayerIdentifyMode2) => {
  LayerIdentifyMode2["GEOMETRIC"] = "geometric";
  LayerIdentifyMode2["SYMBOLIC"] = "symbolic";
  LayerIdentifyMode2["HYBRID"] = "hybrid";
  LayerIdentifyMode2["NONE"] = "none";
  return LayerIdentifyMode2;
})(LayerIdentifyMode || {});
var InitiationState = /* @__PURE__ */ ((InitiationState2) => {
  InitiationState2["NEW"] = "new";
  InitiationState2["INITIATING"] = "initiating";
  InitiationState2["INITIATED"] = "initiated";
  InitiationState2["TERMINATING"] = "terminating";
  InitiationState2["TERMINATED"] = "terminated";
  return InitiationState2;
})(InitiationState || {});
var LayerState = /* @__PURE__ */ ((LayerState2) => {
  LayerState2["NEW"] = "new";
  LayerState2["LOADING"] = "loading";
  LayerState2["LOADED"] = "loaded";
  LayerState2["ERROR"] = "error";
  return LayerState2;
})(LayerState || {});
var DrawState = /* @__PURE__ */ ((DrawState2) => {
  DrawState2["NOT_LOADED"] = "not-loaded";
  DrawState2["NOT_VISUAL"] = "not-visual";
  DrawState2["REFRESH"] = "refresh";
  DrawState2["UP_TO_DATE"] = "up-to-date";
  return DrawState2;
})(DrawState || {});
var IdentifyResultFormat = /* @__PURE__ */ ((IdentifyResultFormat2) => {
  IdentifyResultFormat2["ESRI"] = "esri";
  IdentifyResultFormat2["TEXT"] = "text";
  IdentifyResultFormat2["IMAGE"] = "image";
  IdentifyResultFormat2["HTML"] = "html";
  IdentifyResultFormat2["XML"] = "xml";
  IdentifyResultFormat2["JSON"] = "json";
  IdentifyResultFormat2["UNKNOWN"] = "unknown";
  return IdentifyResultFormat2;
})(IdentifyResultFormat || {});
var CoreFilter = /* @__PURE__ */ ((CoreFilter2) => {
  CoreFilter2["SYMBOL"] = "symbol";
  CoreFilter2["GRID"] = "grid";
  CoreFilter2["EXTENT"] = "extent";
  CoreFilter2["INITIAL"] = "initial";
  CoreFilter2["API"] = "api";
  CoreFilter2["PERMANENT"] = "permanent";
  return CoreFilter2;
})(CoreFilter || {});
var LayerControl = /* @__PURE__ */ ((LayerControl2) => {
  LayerControl2["BoundaryZoom"] = "boundaryZoom";
  LayerControl2["Datatable"] = "datatable";
  LayerControl2["Identify"] = "identify";
  LayerControl2["Metadata"] = "metadata";
  LayerControl2["Opacity"] = "opacity";
  LayerControl2["Refresh"] = "refresh";
  LayerControl2["Reload"] = "reload";
  LayerControl2["Remove"] = "remove";
  LayerControl2["Settings"] = "settings";
  LayerControl2["Symbology"] = "symbology";
  LayerControl2["Visibility"] = "visibility";
  return LayerControl2;
})(LayerControl || {});

class Graphic {
  attributes;
  geometry;
  style;
  id;
  constructor(geom, id, attribs) {
    this.geometry = geom;
    if (id) {
      this.id = id;
    } else {
      this.id = geo.sharedUtils.generateUUID();
    }
    if (attribs) {
      this.attributes = attribs;
    } else {
      this.attributes = {};
    }
  }
  _hover;
  // TODO event system to be decided
  // _hoverRemoved: Subject<string> = new Subject();
  /** Returns the hovertip for the graphic, if any. */
  get hover() {
    return this._hover;
  }
  /** Adds a hovertip to the graphic. If one already exists, replace it. */
  set hover(hover) {
    if (hover && this._hover && this._hover.id !== hover.id) {
      this.removeHover();
    }
    this._hover = hover;
  }
  /** Removes the hovertip from the graphic if it exists. */
  removeHover() {
    if (this._hover) {
      this._hover = void 0;
    }
  }
}

class SpatialReference {
  /** Well known id. This generally corresponds to an EPSG code or an ESRI wkid number */
  wkid;
  /** Latest well known id. This optional property allows updated wkid values to be leveraged when standards change */
  latestWkid;
  /** Well known type. */
  wkt;
  constructor(wkidOrWkt, latestWkid) {
    if (typeof wkidOrWkt === "string") {
      this.wkt = wkidOrWkt;
    } else {
      this.wkid = wkidOrWkt;
      this.latestWkid = latestWkid;
    }
  }
  /**
   * Returns the another spatial reference is the same as this one
   *
   * @method isEqual
   * @param {SpatialReference} otherSR spatial reference to compare to
   * @returns {Boolean} result of the comparison
   */
  isEqual(otherSR) {
    if (this.isWebMercator() && otherSR.isWebMercator()) {
      return true;
    }
    if (this.wkid && otherSR.wkid && this.wkid === otherSR.wkid || this.wkt && otherSR.wkt && this.wkt === otherSR.wkt || this.latestWkid && otherSR.latestWkid && this.latestWkid === otherSR.latestWkid) {
      return true;
    }
    return false;
  }
  clone() {
    const sr = new SpatialReference("");
    sr.latestWkid = this.latestWkid;
    sr.wkid = this.wkid;
    sr.wkt = this.wkt;
    return sr;
  }
  lean() {
    const l = {};
    if (this.wkt) {
      l.wkt = this.wkt;
    } else {
      l.wkid = this.wkid;
      if (this.latestWkid) {
        l.latestWkid = this.latestWkid;
      }
    }
    return l;
  }
  isWebMercator() {
    const mercator = [900913, 3587, 54004, 41001, 102113, 102100, 3785];
    return !!(this.wkid && mercator.includes(this.wkid) || this.latestWkid && mercator.includes(this.latestWkid));
  }
  /**
   * Returns a spatial reference for Lat Long projection
   *
   * @static
   * @method latLongSR
   * @returns {SpatialReference} the initialized spatial reference
   */
  static latLongSR() {
    return new SpatialReference(4326);
  }
  /**
   * Returns a spatial ref object from a config typed object
   * @param srObject config spatial reference object
   * @returns spatial reference object with same settings as input
   */
  static fromConfig(srObject) {
    if (srObject.wkt) {
      return new SpatialReference(srObject.wkt);
    } else if (srObject.wkid) {
      return new SpatialReference(srObject.wkid, srObject.latestWkid);
    } else {
      throw new Error("Could not parse config spatial reference object");
    }
  }
  /**
   * Parse the typical RAMP formats for spatial references into an RAMP SpatialReference object
   * @param {SpatialReference | string | number} sr can be RAMP SpatialReference, WKID integer, WKT string, or ESPG:#### string
   * @returns {SpatialReference} Spatial Reference object
   */
  static parseSR(sr) {
    if (!sr) {
      return SpatialReference.latLongSR();
    } else if (sr instanceof SpatialReference) {
      return sr.clone();
    } else if (typeof sr === "string" && sr.startsWith("EPSG:")) {
      return new SpatialReference(parseInt(sr.substring(5).trim()));
    } else {
      return new SpatialReference(sr);
    }
  }
  static fromESRI(esriSR) {
    if (esriSR.wkt) {
      return new SpatialReference(esriSR.wkt);
    } else {
      const latestWkid = esriSR.toJSON().latestWkid;
      const rampSR = new SpatialReference(esriSR.wkid);
      if (latestWkid) {
        rampSR.latestWkid = latestWkid;
      }
      return rampSR;
    }
  }
  toESRI() {
    return new EsriSpatialReference(this.lean());
  }
  static fromGeoJSON(crs) {
    const p = SpatialReference.parseGeoJsonCrs(crs);
    if (p.substring(0, 5) === "EPSG:") {
      return new SpatialReference(parseInt(p.slice(5)));
    } else {
      return new SpatialReference(p);
    }
  }
  /**
   * Convert a GeoJSON styled co-ord reference to an EPSG styled string
   * @param {GeoJson.CoordinateReferenceSystem} crs GeoJSON crs object
   * @returns {string} A proj4 friendly projection, in the form EPSG:#### or a WKT
   */
  static parseGeoJsonCrs(crs) {
    if (!crs) {
      return "EPSG:4326";
    } else if (crs.type === "name") {
      const urnRegex = /urn:ogc:def:crs:EPSG::(\d+)/;
      const val = crs.properties.name;
      const matches = val.match(urnRegex);
      if (matches) {
        return "EPSG:" + matches[1];
      } else if (val.substring(0, 7) !== "urn:ogc") {
        return val;
      }
    }
    console.error(
      "Encountered unsupported GeoJSON CRS format. Defaulting to lat-long, resuling conversion is likely wrong",
      crs
    );
    return "EPSG:4326";
  }
  // TODO all geoms have optional .crs property.
  //      Since this function will likely be called on every geom in a set,
  //      we may want to have logic to leave it undefined if crs is latlong
  //      also might want to consider various magics for feature sets to remove all the crs
  //      from the geoms and just define once on the feature set.
  //      Tricky because it depends on the orchestrator knowing what the deal is.
  //      As implemented now, it is the safest option, but most bulky
  toGeoJSON() {
    const crs = {
      type: "name",
      properties: {
        name: ""
      }
    };
    if (this.wkt) {
      crs.properties.name = this.wkt;
    } else {
      crs.properties.name = "urn:ogc:def:crs:EPSG::" + (this.latestWkid || this.wkid);
    }
    return crs;
  }
}

class BaseGeometry {
  /** Spatial Reference of the geometry */
  sr;
  /** Id of the geometry */
  id;
  constructor(id, sr) {
    this.id = id ? id.toString() : "";
    this.sr = SpatialReference.parseSR(sr);
  }
  /**
   * Returns the type of the geometry object.
   * Function implementation in subclasses.
   */
  get type() {
    return GeometryType.UNKNOWN;
  }
  childIdGenerator(idx) {
    return `${this.id}-${idx}`;
  }
  toESRI() {
    throw new Error(`.toESRI not implemented on geometry type ${this.type}`);
  }
  toGeoJSON() {
    throw new Error(`.toGeoJSON not implemented on geometry type ${this.type}`);
  }
  invalid() {
    return this.type === GeometryType.NONE || this.type === GeometryType.UNKNOWN;
  }
  geoJsonFactory(type, coords) {
    const gj = {
      type,
      coordinates: coords
    };
    if (this.sr) {
      gj.crs = this.sr.toGeoJSON();
    }
    return gj;
  }
}
class NoGeometry extends BaseGeometry {
  constructor() {
    super("no_geometry");
  }
  get type() {
    return GeometryType.NONE;
  }
}

class Point extends BaseGeometry {
  // storing raw geometry in array format.
  // it will be in native format for geojson and for feeding into other
  // ramp geometry types (i.e. arrays of points like [[x1,y1],[x2,y2]])
  rawArray;
  constructor(id, geometry, sr, raw) {
    super(id, geometry.sr || sr);
    if (raw) {
      this.rawArray = geometry.slice();
    } else {
      this.rawArray = Point.parseXY(geometry);
    }
  }
  /** Returns the string 'Point'. */
  get type() {
    return GeometryType.POINT;
  }
  get x() {
    return this.rawArray[0];
  }
  set x(val) {
    this.rawArray[0] = val;
  }
  get y() {
    return this.rawArray[1];
  }
  set y(val) {
    this.rawArray[1] = val;
  }
  /**
   * Returns a 2-element array with values x and y (i.e. [x, y])
   */
  toArray() {
    return this.rawArray.slice();
  }
  static parseXY(input) {
    let buffer;
    if (Array.isArray(input) && input.length === 2) {
      buffer = input;
    } else if (input instanceof Point) {
      return input.toArray();
    } else {
      buffer = [input.x, input.y];
    }
    if (isNaN(buffer[0]) || isNaN(buffer[1])) {
      throw new Error(
        "Unsupported point format detected. Supported formats are two element array of numbers, or object with x and y properties containing numbers"
      );
    } else {
      return [parseFloat(buffer[0]), parseFloat(buffer[1])];
    }
  }
  static fromESRI(esriPoint, id) {
    return new Point(id, [esriPoint.x, esriPoint.y], SpatialReference.fromESRI(esriPoint.spatialReference), true);
  }
  toESRI() {
    return new EsriPoint({
      x: this.x,
      y: this.y,
      spatialReference: this.sr.toESRI()
    });
  }
  static fromGeoJSON(geoJsonPoint, id) {
    return new Point(id, geoJsonPoint.coordinates, SpatialReference.fromGeoJSON(geoJsonPoint.crs), true);
  }
  toGeoJSON() {
    return this.geoJsonFactory(GeoJsonGeomType.POINT, this.toArray());
  }
}

class PointSet extends BaseGeometry {
  // for now, keeping raw for efficiency (not having object padding around every vertex)
  rawArray;
  constructor(id, geometry, sr, raw) {
    super(id, geometry.sr || sr);
    if (raw) {
      this.rawArray = PointSet.arrayDeepCopy(geometry);
    } else if (geometry instanceof PointSet) {
      this.rawArray = geometry.toArray();
    } else {
      this.rawArray = PointSet.parsePointSet(geometry);
    }
  }
  /** Returns an array of the contained lines formatted as API Point objects. A new array is returned each time this is called. */
  get pointArray() {
    return this.rawArray.map((p, i) => new Point(this.childIdGenerator(i), p, this.sr, true));
  }
  /** Returns a copy of the n-th contained point. */
  getAt(n) {
    return new Point(this.childIdGenerator(n), this.rawArray[n], this.sr, true);
  }
  /** Will update the n-th contained point with the values of the point parameter. It is assumed the point is in the same spatial reference as the Multipoint */
  updateAt(point, n) {
    this.rawArray[n] = Point.parseXY(point);
  }
  /** Returns the number of contained points. */
  get length() {
    return this.rawArray.length;
  }
  // TODO make an .addPoint? .removePoint?
  /**
   * Returns an array of point arrays (e.g. [[x1, y1], [x2, y2]] )
   */
  toArray() {
    return PointSet.arrayDeepCopy(this.rawArray);
  }
  static parsePointSet(input) {
    if (Array.isArray(input)) {
      if (input.length === 0) {
        throw new Error("no verticies provided");
      }
      return input.map((v) => Point.parseXY(v));
    } else {
      throw new Error("Bad geometry input encountered");
    }
  }
  static arrayDeepCopy(a) {
    return a.map((p) => p.slice());
  }
}

class MultiPoint extends PointSet {
  constructor(id, geometry, sr, raw) {
    super(id, geometry, sr, raw);
  }
  /** Returns the string 'MultiPoint'. */
  get type() {
    return GeometryType.MULTIPOINT;
  }
  // TODO make an .addPoint? .removePoint?
  static fromESRI(esriMultiPoint, id) {
    return new MultiPoint(
      id,
      esriMultiPoint.points,
      SpatialReference.fromESRI(esriMultiPoint.spatialReference),
      true
    );
  }
  toESRI() {
    return new EsriMultipoint({
      points: this.toArray(),
      spatialReference: this.sr.toESRI()
    });
  }
  static fromGeoJSON(geoJsonMultiPoint, id) {
    return new MultiPoint(
      id,
      geoJsonMultiPoint.coordinates,
      SpatialReference.fromGeoJSON(geoJsonMultiPoint.crs),
      true
    );
  }
  toGeoJSON() {
    return this.geoJsonFactory(GeoJsonGeomType.MULTIPOINT, this.toArray());
  }
}

class LineString extends PointSet {
  constructor(id, geometry, sr, raw) {
    super(id, geometry, sr, raw);
    if (this.rawArray.length < 2) {
      throw new Error("lines require at least two verticies");
    }
  }
  /** Returns the string 'LineString'. */
  get type() {
    return GeometryType.LINESTRING;
  }
  static fromESRI(esriLine, id) {
    return new LineString(id, esriLine.paths[0], SpatialReference.fromESRI(esriLine.spatialReference), true);
  }
  toESRI() {
    return new EsriPolyline({
      paths: [this.toArray()],
      spatialReference: this.sr.toESRI()
    });
  }
  static fromGeoJSON(geoJsonLine, id) {
    return new LineString(id, geoJsonLine.coordinates, SpatialReference.fromGeoJSON(geoJsonLine.crs), true);
  }
  toGeoJSON() {
    return this.geoJsonFactory(GeoJsonGeomType.LINESTRING, this.toArray());
  }
}

class MultiLineString extends BaseGeometry {
  rawArray;
  constructor(id, geometry, sr, raw) {
    super(id, geometry.sr || sr);
    if (raw) {
      this.rawArray = MultiLineString.arrayDeepCopy(geometry);
    } else if (geometry instanceof MultiLineString) {
      this.rawArray = geometry.toArray();
    } else if (geometry instanceof PointSet) {
      this.rawArray = [geometry.toArray()];
    } else if (Array.isArray(geometry)) {
      if (geometry.length === 0) {
        throw new Error("no lines provided");
      }
      this.rawArray = geometry.map((l) => PointSet.parsePointSet(l));
    } else {
      throw new Error("invalid lines format for MulitLineString");
    }
  }
  /** Returns an array of the contained lines formatted as API LineString objects. A new array is returned each time this is called. */
  get lineArray() {
    return this.rawArray.map((line, i) => new LineString(this.childIdGenerator(i), line, this.sr, true));
  }
  /** Returns a copy of the n-th contained line. */
  getAt(n) {
    return new LineString(this.childIdGenerator(n), this.rawArray[n], this.sr, true);
  }
  /** Will update the n-th contained line with the values of the line parameter. It is assumed the line is in the same spatial reference as the Multipoint */
  updateAt(line, n) {
    this.rawArray[n] = PointSet.parsePointSet(line);
  }
  /** Returns the number of contained lines. */
  get length() {
    return this.rawArray.length;
  }
  /** Returns the string 'MultiLineString'. */
  get type() {
    return GeometryType.MULTILINESTRING;
  }
  /**
   * Returns an array of line arrays (e.g. [[[x1, y1], [x2, y2]], [[x3, y3], [x4, y4]]] )
   */
  toArray() {
    return MultiLineString.arrayDeepCopy(this.rawArray);
  }
  static arrayDeepCopy(a) {
    return a.map((l) => l.map((p) => p.slice()));
  }
  static fromESRI(esriLine, id) {
    return new MultiLineString(id, esriLine.paths, SpatialReference.fromESRI(esriLine.spatialReference), true);
  }
  toESRI() {
    return new EsriPolyline({
      paths: this.toArray(),
      spatialReference: this.sr.toESRI()
    });
  }
  static fromGeoJSON(geoJsonMultiLine, id) {
    return new MultiLineString(
      id,
      geoJsonMultiLine.coordinates,
      SpatialReference.fromGeoJSON(geoJsonMultiLine.crs),
      true
    );
  }
  toGeoJSON() {
    return this.geoJsonFactory(GeoJsonGeomType.MULTILINESTRING, this.toArray());
  }
}

class LinearRing extends PointSet {
  constructor(id, geometry, sr, raw) {
    super(id, geometry, sr, raw);
    LinearRing.closeRing(this.rawArray);
    if (this.length < 4) {
      throw new Error("Linear Ring must have at least 3 distinct vertices.");
    }
  }
  /** Returns the string 'LinearRing'. */
  get type() {
    return GeometryType.LINEARRING;
  }
  /** Will update the n-th contained point with the values of the point parameter. It is assumed the point is in the same spatial reference as the Multipoint */
  updateAt(point, n) {
    const l = this.length - 1;
    if (n === 0) {
      super.updateAt(point, l);
    } else if (n === l) {
      super.updateAt(point, 0);
    }
    super.updateAt(point, n);
  }
  /**
   * Will inspect an array of verticies. If the last vertex is different than the first vertex,
   * will add a copy of the first vertex to the end, thus closing the line.
   * The array parameter will be modified
   *
   * @param {Array} points An array of 2-element arrays of verticies.
   */
  static closeRing(points) {
    const first = points[0];
    const last = points[points.length - 1];
    if (first[0] !== last[0] || first[1] !== last[1]) {
      points.push(first.slice());
    }
  }
  static fromESRI(esriPoly, id) {
    return new LinearRing(id, esriPoly.rings[0], SpatialReference.fromESRI(esriPoly.spatialReference), true);
  }
  toESRI() {
    return new EsriPolygon({
      rings: [this.toArray()],
      spatialReference: this.sr.toESRI()
    });
  }
  static fromGeoJSON(geoJsonLine, id) {
    return new LinearRing(id, geoJsonLine.coordinates, SpatialReference.fromGeoJSON(geoJsonLine.crs), true);
  }
  toGeoJSON() {
    return this.geoJsonFactory(GeoJsonGeomType.POLYGON, [this.toArray()]);
  }
}

class Polygon extends BaseGeometry {
  rawArray;
  // from arrays of verticies (i.e. one line) that can be interpreted as a single-ring polygon
  // for now, not allowing these as it increases parsing logic quite a bit.
  // constructor(id: IdDef, polygon: Array<Point>, sr?: SpatialReference)
  // constructor(id: IdDef, polygon: Array<Array<number>>, sr?: SpatialReference)
  // constructor(id: IdDef, polygon: Array<object>, sr?: SpatialReference)
  constructor(id, geometry, sr, raw) {
    super(id, geometry.sr || sr);
    if (raw) {
      this.rawArray = Polygon.arrayDeepCopy(geometry);
    } else {
      this.rawArray = Polygon.parsePolygon(geometry);
    }
  }
  addLinearRings(linearRings) {
    linearRings.forEach((lr) => this.rawArray.push(lr.toArray()));
  }
  // TODO make a .getAt, .updateAt for rings?
  // TODO make a .removeLinearRings?
  /** Returns an array of the contained rings. A new array is returned each time this is called. */
  get ringArray() {
    return this.rawArray.map((lra, i) => new LinearRing(this.childIdGenerator(i), lra, this.sr, true));
  }
  /** Returns the string 'Polygon'. */
  get type() {
    return GeometryType.POLYGON;
  }
  /**
   * Returns an array of ring arrays (e.g. [[[x1, y1], [x2, y2], [x3, y3], [x1, y1]], [<another ring>]] )
   */
  toArray() {
    return Polygon.arrayDeepCopy(this.rawArray);
  }
  static parsePolygon(input) {
    let arrOfLines = [];
    if (input instanceof Polygon) {
      return input.toArray();
    } else if (input instanceof MultiLineString) {
      arrOfLines = input.toArray();
    } else if (input instanceof PointSet) {
      arrOfLines = [input.toArray()];
    } else if (Array.isArray(input)) {
      if (input.length === 0) {
        throw new Error("no rings provided");
      }
      arrOfLines = input.map((l) => PointSet.parsePointSet(l));
    } else {
      throw new Error("invalid input format for parsePolygon");
    }
    arrOfLines.forEach((l) => LinearRing.closeRing(l));
    return arrOfLines;
  }
  static arrayDeepCopy(a) {
    return a.map((l) => l.map((p) => p.slice()));
  }
  static fromESRI(esriPoly, id) {
    return new Polygon(id, esriPoly.rings, SpatialReference.fromESRI(esriPoly.spatialReference), true);
  }
  toESRI() {
    return new EsriPolygon({
      rings: this.toArray(),
      spatialReference: this.sr.toESRI()
    });
  }
  static fromGeoJSON(geoJsonPoly, id) {
    return new Polygon(id, geoJsonPoly.coordinates, SpatialReference.fromGeoJSON(geoJsonPoly.crs), true);
  }
  toGeoJSON() {
    return this.geoJsonFactory(GeoJsonGeomType.POLYGON, this.toArray());
  }
}

class MultiPolygon extends BaseGeometry {
  rawArray;
  constructor(id, geometry, sr, raw) {
    super(id, geometry.sr || sr);
    if (raw) {
      this.rawArray = MultiPolygon.arrayDeepCopy(geometry);
    } else {
      this.rawArray = MultiPolygon.parseMultiPolygon(geometry);
    }
  }
  addPolygon(polygon) {
    this.rawArray.push(polygon.toArray());
  }
  // TODO make a .getAt, .updateAt for polygons?
  // TODO make a .removePolygon?
  /** Returns an array of the contained polygons. A new array is returned each time this is called. */
  get polygonArray() {
    return this.rawArray.map((p, i) => new Polygon(this.childIdGenerator(i), p, this.sr, true));
  }
  /** Returns the string 'MultiPolygon'. */
  get type() {
    return GeometryType.MULTIPOLYGON;
  }
  /**
   * Returns an array of polygon arrays (e.g. [[[[x1, y1], [x2, y2], [x3, y3], [x1, y1]], [<another ring>]], [<another polygon>]] )
   */
  toArray() {
    return MultiPolygon.arrayDeepCopy(this.rawArray);
  }
  static parseMultiPolygon(input) {
    if (input instanceof MultiPolygon) {
      return input.toArray();
    } else if (input instanceof Polygon) {
      return [input.toArray()];
    } else if (input instanceof MultiLineString || input instanceof PointSet) {
      return [Polygon.parsePolygon(input)];
    } else if (Array.isArray(input)) {
      if (input.length === 0) {
        throw new Error("no polygons provided");
      }
      return input.map((p) => Polygon.parsePolygon(p));
    } else {
      throw new Error("invalid input format for parseMultiPolygon");
    }
  }
  // sing this function definition. epic chorus.
  static arrayDeepCopy(a) {
    return a.map((g) => g.map((l) => l.map((p) => p.slice())));
  }
  static fromESRI(esriPoly, id) {
    return new MultiPolygon(id, [esriPoly.rings], SpatialReference.fromESRI(esriPoly.spatialReference), true);
  }
  toESRI() {
    const ringMerger = [];
    this.toArray().forEach((poly) => {
      poly.forEach((ring) => ringMerger.push(ring));
    });
    return new EsriPolygon({
      rings: ringMerger,
      spatialReference: this.sr.toESRI()
    });
  }
  static fromGeoJSON(geoJsonMultiPoly, id) {
    return new MultiPolygon(
      id,
      geoJsonMultiPoly.coordinates,
      SpatialReference.fromGeoJSON(geoJsonMultiPoly.crs),
      true
    );
  }
  toGeoJSON() {
    return this.geoJsonFactory(GeoJsonGeomType.MULTIPOLYGON, this.toArray());
  }
}

class Extent extends BaseGeometry {
  // doing things a bit different for Extents.
  // tried array of arrays to be consistent with other geometeries, but
  // was more extra coding and overhead of unrequired array
  rawMin;
  rawMax;
  constructor(id, minGeometry, maxGeometry, sr) {
    super(id, minGeometry.sr || sr);
    this.rawMin = Point.parseXY(minGeometry);
    this.rawMax = Point.parseXY(maxGeometry);
  }
  // TODO setters for individul values? classic [x|y][min|max] set
  /** Returns the string 'Extent'. */
  get type() {
    return GeometryType.EXTENT;
  }
  get xmin() {
    return this.rawMin[0];
  }
  get ymin() {
    return this.rawMin[1];
  }
  get xmax() {
    return this.rawMax[0];
  }
  get ymax() {
    return this.rawMax[1];
  }
  center() {
    return new Point(
      this.id + "_centerPoint",
      [(this.xmax - this.xmin) / 2 + this.xmin, (this.ymax - this.ymin) / 2 + this.ymin],
      this.sr,
      true
    );
  }
  expand(factor) {
    return Extent.fromESRI(this.toESRI().expand(factor), `${this.id}-expanded`);
  }
  clone() {
    return new Extent(this.id, this.rawMin, this.rawMax, this.sr);
  }
  /**
   * Reports if a point is within the boundary of the extent.
   * For performance reasons, the point must be in the same spatial reference as the extent.
   *
   * @param {Point} testPoint
   * @returns {boolean} if point was within the extent or not
   */
  contains(testPoint) {
    if (this.sr.isEqual(testPoint.sr)) {
      return this.xmin <= testPoint.x && this.xmax >= testPoint.x && this.ymin <= testPoint.y && this.ymax >= testPoint.y;
    } else {
      console.error("Extent.contains(point) must have point in same spatial reference as the extent.");
      return false;
    }
  }
  /**
   * Returns an array of point arrays (e.g. [[x1, y1], [x2, y2]] )
   */
  toArray() {
    return [this.rawMin.slice(), this.rawMax.slice()];
  }
  toPolygonArray() {
    return [
      [
        this.rawMin.slice(),
        [this.xmin, this.ymax],
        this.rawMax.slice(),
        [this.xmax, this.ymin],
        this.rawMin.slice()
      ]
    ];
  }
  toPolygon() {
    return new Polygon(this.id, this.toPolygonArray(), this.sr, true);
  }
  static fromParams(id, xmin, ymin, xmax, ymax, sr) {
    return new Extent(id, [xmin, ymin], [xmax, ymax], sr);
  }
  static fromConfig(id, configExtent) {
    return new Extent(
      id,
      [configExtent.xmin, configExtent.ymin],
      [configExtent.xmax, configExtent.ymax],
      SpatialReference.fromConfig(configExtent.spatialReference)
    );
  }
  isEqual(e) {
    if (!e) {
      return false;
    }
    return this.xmin === e.xmin && this.ymin === e.ymin && this.xmax === e.xmax && this.ymax === e.ymax;
  }
  static fromESRI(esriExtent, id) {
    return Extent.fromParams(
      id,
      esriExtent.xmin,
      esriExtent.ymin,
      esriExtent.xmax,
      esriExtent.ymax,
      SpatialReference.fromESRI(esriExtent.spatialReference)
    );
  }
  toESRI() {
    return new EsriExtent({
      xmin: this.xmin,
      ymin: this.ymin,
      xmax: this.xmax,
      ymax: this.ymax,
      spatialReference: this.sr.toESRI()
    });
  }
  static fromArcServer(serverExtent, id) {
    return Extent.fromESRI(EsriExtent.fromJSON(serverExtent), id);
  }
  // TODO for GeoJSON, we are converting to Polygon.
  //      However the spec also supports bbox string
  //      Not sure which is best. Have a second set of to/from functions?
  static fromGeoJSON(geoJsonExtent, id) {
    if (geoJsonExtent.coordinates.length !== 5) {
      throw new Error("Extent expected a four vertex polygon from GeoJSON");
    }
    const pMin = geoJsonExtent.coordinates[0].slice();
    const pMax = pMin.slice();
    [1, 2, 3].forEach((i) => {
      [0, 1].forEach((j) => {
        const pt = geoJsonExtent.coordinates[i];
        if (pMin[j] > pt[j]) {
          pMin[j] = pt[j];
        }
        if (pMax[j] < pt[j]) {
          pMax[j] = pt[j];
        }
      });
    });
    return new Extent(id, pMin, pMax, SpatialReference.fromGeoJSON(geoJsonExtent.crs));
  }
  toGeoJSON() {
    return this.geoJsonFactory(GeoJsonGeomType.POLYGON, this.toPolygonArray());
  }
}

class Colour {
  c;
  // 4 numbers. R,G,B (0-255), A (0-1). This is ESRI and SVG standard
  constructor(colour) {
    if (!colour) {
      this.c = [0, 0, 0, 1];
      return;
    }
    if (Array.isArray(colour)) {
      const l = colour.length;
      if (l < 3 || l > 4) {
        console.error("Invalid colour value array passed to Colour class");
        this.c = [0, 0, 0, 1];
        return;
      }
      this.c = colour.map((n, i) => i === 3 ? n : parseInt(n));
      if (l === 3) {
        this.c.push(1);
      }
    } else if (typeof colour === "string") {
      const s = colour.substring(0, 1) === "#" ? colour.substring(1) : colour;
      this.c = [0, 2, 4, 6].map((i) => {
        const hex = s.substring(i, i + 2);
        return Colour.hexToInt(hex);
      });
    } else {
      this.c = [colour.r, colour.g, colour.b, colour.a ?? 1];
    }
    this.c.forEach((n, i) => {
      if (n < 0) {
        console.error("Negative value passed to colour");
        this.c[i] = 0;
      }
      if (n > 255) {
        console.error("Rotund value passed to colour");
        this.c[i] = 255;
      }
    });
    if (this.c[3] > 1) {
      this.c[3] = this.c[3] / 255;
    }
  }
  get rgba() {
    return this.c.slice();
  }
  get hex() {
    const temp = this.rgba;
    temp[3] = temp[3] * 255;
    return `#${temp.map((i) => Colour.intToHex(i)).join("")}`;
  }
  get r() {
    return this.c[0];
  }
  get g() {
    return this.c[1];
  }
  get b() {
    return this.c[2];
  }
  get a() {
    return this.c[3];
  }
  toESRI() {
    return new EsriColour(this.rgba);
  }
  toArcServer() {
    return [this.c[0], this.c[1], this.c[2], 255 * this.c[3]];
  }
  static hexToInt(twoCharHex) {
    return twoCharHex.length === 0 ? 255 : parseInt(twoCharHex, 16);
  }
  static intToHex(num) {
    const s = num.toString(16);
    return s.length === 1 ? `0${s}` : s;
  }
}

class BaseStyle {
  toOptions() {
    throw new Error(`.toOptions called on BaseStyle. Likely was not implemented on subclass.`);
  }
  toESRI() {
    throw new Error(`.toESRI called on BaseStyle. Likely was not implemented on subclass.`);
  }
  // takes any "measurement" type option and converts to points units.
  // numbers === points
  // text number === points
  // text number + 'pt' === points
  // text number + 'px' === pixels, gets converted
  // undefined === undefined
  // empty string === undefined
  static convToPoints(input) {
    if (typeof input === "undefined") {
      return void 0;
    } else if (typeof input === "string") {
      let numnum;
      const len = input.length;
      if (len === 0) {
        return void 0;
      }
      const suffix = input.substring(len - 2);
      if (suffix === "px") {
        numnum = parseFloat(input.substring(0, len - 2)) * 1.333333;
      } else if (suffix === "pt") {
        numnum = parseFloat(input.substring(0, len - 2));
      } else {
        numnum = parseFloat(input);
      }
      return numnum;
    } else {
      return input;
    }
  }
}

class PointStyle extends BaseStyle {
  _height;
  _xOffset;
  _yOffset;
  _icon;
  _width;
  _size;
  _colour;
  _style;
  _outline;
  _path;
  _angle;
  constructor(opts) {
    opts = opts || { style: PointStyleType.CIRCLE };
    super();
    this._style = opts.style || PointStyleType.CIRCLE;
    if (opts.style === PointStyleType.ICON) {
      const iopts = opts;
      this._icon = iopts.icon || "";
      this._height = BaseStyle.convToPoints(iopts.height) || 16.5;
      this._width = BaseStyle.convToPoints(iopts.width) || 16.5;
      this._size = 0;
      this._colour = new Colour();
      this._outline = new LineStyle();
      this._path = "";
    } else {
      const mopts = opts;
      this._size = BaseStyle.convToPoints(mopts.size) || 12;
      this._colour = new Colour(mopts.colour ?? "#ffffff40");
      this._outline = new LineStyle(mopts.outline);
      this._path = this._style === PointStyleType.PATH ? mopts.path || "" : "";
      this._height = 0;
      this._width = 0;
      this._icon = "";
    }
    this._xOffset = BaseStyle.convToPoints(opts.xOffset) || 0;
    this._yOffset = BaseStyle.convToPoints(opts.yOffset) || 0;
    this._angle = opts.angle || 0;
  }
  /** Returns the specified colour */
  get colour() {
    this.propGrouse(false);
    return this._colour;
  }
  /** Returns the specified style type */
  get styleType() {
    return this._style;
  }
  /** Returns the specified width */
  get width() {
    this.propGrouse(true);
    return this._width;
  }
  /** Returns the specified height */
  get height() {
    this.propGrouse(true);
    return this._height;
  }
  /** Returns the specified size, in points units (not pixels) */
  get size() {
    this.propGrouse(false);
    return this._size;
  }
  /** Returns the specified x offset */
  get xOffset() {
    return this._xOffset;
  }
  /** Returns the specified y offset */
  get yOffset() {
    return this._yOffset;
  }
  /** Returns the specified angle, in degrees */
  get angle() {
    return this._angle;
  }
  /** Returns the specified icon. Can be image url, svg image */
  get icon() {
    this.propGrouse(true);
    return this._icon;
  }
  /** Returns the outline style */
  get outline() {
    this.propGrouse(false);
    return this._outline;
  }
  /** Returns the SVG path */
  get path() {
    this.propGrouse(false);
    return this._path;
  }
  propGrouse(forIcon) {
    if (!(this._style === PointStyleType.ICON === forIcon)) {
      console.warn(`Accessed a point style property that is invalid for the style type ${this._style}`);
    }
  }
  toOptions() {
    const common = {
      style: this.styleType,
      yOffset: this.yOffset,
      xOffset: this.xOffset,
      angle: this.angle
    };
    if (this._style === PointStyleType.ICON) {
      return {
        ...common,
        icon: this.icon,
        width: this.width,
        height: this.height
      };
    } else {
      return {
        ...common,
        size: this.size,
        colour: this.colour.hex,
        path: this.path
      };
    }
  }
  toESRI() {
    let symbol;
    if (this.styleType === PointStyleType.ICON) {
      if (PointStyle.isImageUrl(this.icon)) {
        symbol = new EsriPictureMarkerSymbol();
        symbol.url = this.icon;
        symbol.width = this.width;
        symbol.height = this.height;
        symbol.xoffset = this.xOffset;
        symbol.yoffset = this.yOffset;
        symbol.angle = this.angle;
      } else {
        symbol = new EsriSimpleMarkerSymbol();
        symbol.color = new EsriColour(this.colour.rgba);
        symbol.size = this.width;
        symbol.xoffset = this.xOffset;
        symbol.yoffset = this.yOffset;
        symbol.angle = this.angle;
      }
    } else {
      symbol = new EsriSimpleMarkerSymbol();
      symbol.color = new EsriColour(this.colour.rgba);
      symbol.size = this.size;
      symbol.xoffset = this.xOffset;
      symbol.yoffset = this.yOffset;
      symbol.angle = this.angle;
      symbol.path = this.path;
      symbol.style = this.styleType;
      symbol.outline = this.outline.toESRI();
    }
    return symbol;
  }
  static fromESRI(e) {
    const opts = {
      xOffset: e.xoffset,
      yOffset: e.yoffset,
      angle: e.angle
    };
    if (e.type === "simple-marker") {
      const mopts = opts;
      mopts.style = e.style;
      mopts.colour = e.color.toRgba();
      mopts.size = e.size;
      mopts.path = e.path;
      mopts.outline = LineStyle.fromESRI(e.outline).toOptions();
    } else {
      const popts = opts;
      popts.style = PointStyleType.ICON;
      popts.width = e.width;
      popts.height = e.height;
      popts.icon = e.url;
    }
    return new PointStyle(opts);
  }
  static fromArcServer(json) {
    return PointStyle.fromESRI(fromJSON(json));
  }
  /**
   * Check to see if text provided is a valid image / data URL based on extension type or format.
   *
   * @function isImageUrl
   * @param {String} text                      string to be matched against valid image types / data url format
   * @returns {Boolean}                        true if valid image extension
   */
  static isImageUrl(text) {
    return !!text.match(/\.(jpeg|jpg|gif|png|swf|svg)$/) || !!text.match(
      /^\s*data:([a-z]+\/[a-z0-9\-\+]+(;[a-z\-]+\=[a-z0-9\-]+)?)?(;base64)?,[a-z0-9\!\$\&\'\,\(\)\*\+\,\;\=\-\.\_\~\:\@\/\?\%\s]*\s*$/i
      //eslint-disable-line
    );
  }
}

class LineStyle extends BaseStyle {
  _style;
  _width;
  _miter;
  _cap;
  _join;
  _colour;
  constructor(opts) {
    opts = opts || {};
    super();
    this._style = opts.style || LineStyleType.SOLID;
    const tempW = BaseStyle.convToPoints(opts.width);
    this._width = typeof tempW === "undefined" || tempW < 0 ? 0.75 : tempW;
    this._colour = new Colour(opts.colour);
    this._miter = opts.miter ?? 2;
    this._cap = opts.cap || LineCapType.ROUND;
    this._join = opts.join || LineJoinType.ROUND;
  }
  /** Returns the specified style type (e.g. solid, dashed, dotted) */
  get styleType() {
    return this._style;
  }
  /** Returns the specified width */
  get width() {
    return this._width;
  }
  /** Returns the specified colour */
  get colour() {
    return this._colour;
  }
  /** Returns the specified miter limit */
  get miter() {
    return this._miter;
  }
  /** Returns the specified line cap style */
  get cap() {
    return this._cap;
  }
  /** Returns the specified line join style */
  get join() {
    return this._join;
  }
  toOptions() {
    return {
      style: this.styleType,
      width: this.width,
      colour: this.colour.hex,
      miter: this.miter,
      cap: this.cap,
      join: this.join
    };
  }
  toESRI() {
    const s = new EsriSimpleLineSymbol();
    s.width = this.width;
    s.color = this.colour.toESRI();
    s.style = this.styleType;
    s.cap = this.cap;
    s.miterLimit = this.miter;
    s.join = this.join;
    return s;
  }
  static fromESRI(e) {
    const opts = {
      width: e.width,
      colour: e.color.toRgba(),
      style: e.style
    };
    return new LineStyle(opts);
  }
  static fromArcServer(json) {
    return LineStyle.fromESRI(fromJSON(json));
  }
}

class PolygonStyle extends BaseStyle {
  _outlineStyle;
  _fillColour;
  _fillStyle;
  constructor(opts) {
    super();
    opts = opts || {};
    if (!opts.fill) {
      opts.fill = {};
    }
    this._fillColour = new Colour(opts.fill.colour);
    this._fillStyle = opts.fill.style || FillStyleType.SOLID;
    this._outlineStyle = new LineStyle(opts.outline);
  }
  /** Returns the specified colour */
  get fillColour() {
    return this._fillColour;
  }
  /** Returns the fill style type (solid, transparent, hatching, etc) */
  get fillStyleType() {
    return this._fillStyle;
  }
  /** Returns the outline style */
  get outline() {
    return this._outlineStyle;
  }
  toOptions() {
    return {
      fill: {
        style: this.fillStyleType,
        colour: this.fillColour.hex
      },
      outline: this.outline.toOptions()
    };
  }
  toESRI() {
    const lineSymbol = this.outline.toESRI();
    const fillColour = new EsriColour(this.fillColour.rgba);
    const fillSymbol = new EsriSimpleFillSymbol();
    fillSymbol.style = this.fillStyleType;
    fillSymbol.color = fillColour;
    fillSymbol.outline = lineSymbol;
    return fillSymbol;
  }
  static fromESRI(e) {
    const opts = {
      fill: {
        colour: e.color.toRgba(),
        style: e.style
      },
      outline: LineStyle.fromESRI(e.outline).toOptions()
    };
    return new PolygonStyle(opts);
  }
  static fromArcServer(json) {
    return PolygonStyle.fromESRI(fromJSON(json));
  }
}

class GeometryAPI {
  // expose our common classes, so they can be grabbed from iApi.geo.geom easily
  Extent = Extent;
  Graphic = Graphic;
  // Hover = Hover;
  LineString = LineString;
  LineStyle = LineStyle;
  LinearRing = LinearRing;
  MultiLineString = MultiLineString;
  MultiPoint = MultiPoint;
  MultiPolygon = MultiPolygon;
  Point = Point;
  PointStyle = PointStyle;
  Polygon = Polygon;
  PolygonStyle = PolygonStyle;
  SpatialReference = SpatialReference;
  /**
   * Convert an ESRI map click event object to a generic RAMPish map click event object
   *
   * @param {ViewClickEvent | ViewDoubleClickEvent} esriMapClick an event param from an esri 2D map click or double-click event
   * @param {String | Number} [id] optional id for the map point geometry on the result
   * @returns {MapClick} a generic bundle of data matching a subset of the incoming esri data
   */
  esriMapClickToRamp(esriMapClick, id) {
    return {
      mapPoint: Point.fromESRI(esriMapClick.mapPoint, id),
      screenX: esriMapClick.x,
      screenY: esriMapClick.y,
      button: esriMapClick.button,
      input: esriMapClick.native.pointerType,
      clickTime: esriMapClick.timestamp
    };
  }
  /**
   * Convert an ESRI map click event object to a generic RAMPish map click event object
   *
   * @param {ViewPointerMoveEvent} esriMapMove an event param from an esri 2D map click or double-click event
   * @returns {MapMove} a generic bundle of data matching a subset of the incoming esri data
   */
  esriMapMouseToRamp(esriMapMove) {
    return {
      screenX: esriMapMove.x,
      screenY: esriMapMove.y,
      button: esriMapMove.button,
      moveTime: esriMapMove.timestamp
    };
  }
  /**
   * Converts any RAMP API geometry to a corresponding ESRI geometry
   *
   * @param {BaseGeometry} rampApiGeom a RAMP API geometry
   * @returns {Geometry} an ESRI geometry
   */
  geomRampToEsri(rampApiGeom) {
    return rampApiGeom.toESRI();
  }
  /**
   * Converts any ESRI geometry to a corresponding RAMP API geometry
   *
   * @param {Geometry} esriGeometry an ESRI geometry
   * @param {String | Number} [id] optional id for the result geometry
   * @returns {BaseGeometry} a RAMP API geometry
   */
  geomEsriToRamp(esriGeometry, id) {
    switch (esriGeometry.type) {
      case "point":
        return Point.fromESRI(esriGeometry, id);
      case "polyline": {
        const esriLine = esriGeometry;
        if (esriLine.paths.length === 1) {
          return LineString.fromESRI(esriLine, id);
        } else {
          return MultiLineString.fromESRI(esriLine, id);
        }
      }
      case "polygon":
        return Polygon.fromESRI(esriGeometry, id);
      case "extent":
        return Extent.fromESRI(esriGeometry, id);
      case "multipoint":
        return MultiPoint.fromESRI(esriGeometry, id);
      default:
        throw new Error(`Encountered unhandled geometry type ${esriGeometry.type}`);
    }
  }
  /**
   * Converts any GeoJson geometry to a corresponding RAMP API geometry
   *
   * @param {GeoJson.DirectGeometryObject} geoJsonGeometry a GeoJson geometry
   * @param {String | Number} [id] optional id for the result geometry
   * @returns {BaseGeometry} a RAMP API geometry
   */
  geomGeoJsonToRamp(geoJsonGeometry, id) {
    switch (geoJsonGeometry.type) {
      case GeoJsonGeomType.POINT:
        return Point.fromGeoJSON(geoJsonGeometry, id);
      case GeoJsonGeomType.LINESTRING:
        return LineString.fromGeoJSON(geoJsonGeometry, id);
      case GeoJsonGeomType.POLYGON:
        return Polygon.fromGeoJSON(geoJsonGeometry, id);
      case GeoJsonGeomType.MULTIPOINT:
        return MultiPoint.fromGeoJSON(geoJsonGeometry, id);
      case GeoJsonGeomType.MULTILINESTRING:
        return MultiLineString.fromGeoJSON(geoJsonGeometry, id);
      case GeoJsonGeomType.MULTIPOLYGON:
        return MultiPolygon.fromGeoJSON(geoJsonGeometry, id);
      default:
        throw new Error(`Encountered unhandled geometry type ${geoJsonGeometry.type}`);
    }
  }
  /**
   * Converts any RAMP API geometry to a corresponding GeoJson geometry
   *
   * @param {BaseGeometry} geoJsonGeometry a RAMP API geometry
   * @returns {GeoJson.DirectGeometryObject} a GeoJson geometry
   */
  geomRampToGeoJson(rampApiGeom) {
    return rampApiGeom.toGeoJSON();
  }
  /**
   * Converts any RAMP API Graphic to a GeoJson Feature. Any styles or ids will be excluded from the result.
   *
   * @param {Graphic} rampGraphic a RAMP API graphic
   * @returns {any} a GeoJson Feature
   */
  graphicRampToGeoJson(rampGraphic) {
    const typescriptIsDumb = {};
    const f = {
      type: "Feature",
      geometry: this.geomRampToGeoJson(rampGraphic.geometry),
      properties: typescriptIsDumb
    };
    Object.keys(rampGraphic.attributes).forEach((k) => f.properties[k] = rampGraphic.attributes[k]);
    return f;
  }
  /**
   * Converts any GeoJson Feature to a RAMP API Graphic
   *
   * @param {any} geoJsonFeature a GeoJson Feature
   * @param {number | string } [geomId] an id to apply to the geometry of the graphic
   * @returns {Graphic} a RAMP API Graphic
   */
  graphicGeoJsonToRamp(geoJsonFeature, geomId) {
    if (geoJsonFeature.type !== "Feature") {
      throw new Error("Expected input parameter of graphicGeoJsonToRamp to be a GeoJson feature");
    }
    const geom = this.geomGeoJsonToRamp(geoJsonFeature.geometry, geomId);
    const attrib = {};
    Object.keys(geoJsonFeature.properties.forEach((k) => attrib[k] = geoJsonFeature.properties[k]));
    const g = new Graphic(geom, "", attrib);
    return g;
  }
  /**
   * Converts any RAMP API Graphic to an ESRI Graphic
   * @param {Graphic} rampGraphic a RAMP API Graphic
   * @returns {EsriGraphic} an ESRI Graphic
   */
  graphicRampToEsri(rampGraphic) {
    const gConf = {
      attributes: {},
      id: rampGraphic.id
    };
    gConf.geometry = this.geomRampToEsri(rampGraphic.geometry);
    Object.keys(rampGraphic.attributes).forEach((k) => gConf.attributes[k] = rampGraphic.attributes[k]);
    if (rampGraphic.style) {
      gConf.symbol = this.styleRampToEsri(rampGraphic.style);
    }
    return new EsriGraphic(gConf);
  }
  styleRampToEsri(rampStyle) {
    return rampStyle.toESRI();
  }
  styleEsriToRamp(esriSymbol) {
    switch (esriSymbol.type) {
      case "picture-marker":
      case "simple-marker":
        return PointStyle.fromESRI(esriSymbol);
      case "simple-line":
        return LineStyle.fromESRI(esriSymbol);
      case "simple-fill":
        return PolygonStyle.fromESRI(esriSymbol);
      default:
        console.error(`Unsupported ESRI symbol type encountered: ${esriSymbol.type}`);
        return new PointStyle();
    }
  }
  // converts an arcgis server geometry type to ramp geometry type
  serverGeomTypeToRampGeomType(serverType) {
    if (!serverType) {
      return GeometryType.NONE;
    }
    switch (serverType) {
      case "esriGeometryPolygon":
        return GeometryType.POLYGON;
      case "esriGeometryPolyline":
        return GeometryType.LINESTRING;
      case "esriGeometryPoint":
        return GeometryType.POINT;
      case "esriGeometryMultipoint":
        return GeometryType.MULTIPOINT;
      case "esriGeometryEnvelope":
        return GeometryType.EXTENT;
      default:
        console.error(`Unrecognized server geometry type encountered: ${serverType}`);
        return GeometryType.UNKNOWN;
    }
  }
  // converts an esri client geometry type to ramp geometry type
  clientGeomTypeToRampGeomType(clientType) {
    if (!clientType) {
      return GeometryType.NONE;
    }
    switch (clientType) {
      case "polygon":
        return GeometryType.POLYGON;
      case "polyline":
        return GeometryType.LINESTRING;
      case "point":
        return GeometryType.POINT;
      case "multipoint":
        return GeometryType.MULTIPOINT;
      default:
        console.error(`Unrecognized client geometry type encountered: ${clientType}`);
        return GeometryType.UNKNOWN;
    }
  }
  // converts a geojson geometry type to an esri geometry type that can support it
  geoJsonGeomTypeToEsriGeomType(geoJsonGeomType) {
    switch (geoJsonGeomType) {
      case GeoJsonGeomType.POINT:
        return "point";
      case GeoJsonGeomType.LINESTRING:
      case GeoJsonGeomType.MULTILINESTRING:
        return "polyline";
      case GeoJsonGeomType.POLYGON:
      case GeoJsonGeomType.MULTIPOLYGON:
        return "polygon";
      case GeoJsonGeomType.MULTIPOINT:
        return "multipoint";
      default:
        throw new Error(`Encountered unhandled geometry type ${geoJsonGeomType}`);
    }
  }
  /**
   * Check to see if text provided is a valid image / data URL based on extension type or format.
   *
   * @function isImageUrl
   * @param {String} text                      string to be matched against valid image types / data url format
   * @returns {Boolean}                        true if valid image extension
   */
  isImageUrl(text) {
    return PointStyle.isImageUrl(text);
  }
}

class TreeNode {
  layerIdx;
  name;
  children;
  uid;
  isRoot;
  constructor(idx, uid, name = "", root = true) {
    this.layerIdx = idx;
    this.name = name;
    this.isRoot = root;
    this.children = [];
    this.uid = uid;
  }
  // returns a tree node in the tree that has the given uid.
  // returns undefined if nothing found
  findChildByUid(uid) {
    if (this.uid === uid) {
      return this;
    } else {
      let hit;
      this.children.some((t) => {
        return hit = t.findChildByUid(uid);
      });
      return hit;
    }
  }
  // returns a tree node in the tree that has the given layer index.
  // returns undefined if nothing found
  findChildByIdx(idx) {
    if (this.layerIdx === idx) {
      return this;
    } else {
      let hit;
      this.children.some((t) => {
        return hit = t.findChildByIdx(idx);
      });
      return hit;
    }
  }
  /**
   * Returns whether this node is bound to a logical layer.
   *
   * @method isLogicalLayer
   * @returns {boolean} true if the layer is bound to a logical layer.
   */
  get isLogicalLayer() {
    return this.layerIdx > -1 && this.children.length === 0;
  }
  /**
   * Returns whether this node is a root node.
   *
   * @method isLayerRoot
   * @returns {boolean} true if this node is a root node for this layer.
   */
  get isLayerRoot() {
    return this.isRoot;
  }
}

class ScaleSet {
  minScale;
  maxScale;
  constructor(minScale = 0, maxScale = 0) {
    this.minScale = minScale;
    this.maxScale = maxScale;
  }
  /**
   * Indicates if the feature class is not visible at the given scale,
   * and if so, if we need to zoom in to see it or zoom out
   *
   * @function isOffScale
   * @param {Integer}  mapScale the scale to test against
   * @returns {Object} has boolean properties `offScale` and `zoomIn`
   */
  isOffScale(mapScale) {
    const result = {
      offScale: false,
      zoomIn: false
    };
    if (mapScale < this.maxScale && this.maxScale !== 0) {
      result.offScale = true;
      result.zoomIn = false;
    } else if (mapScale > this.minScale && this.minScale !== 0) {
      result.offScale = true;
      result.zoomIn = true;
    }
    return result;
  }
}

class Filter {
  // Handles state and result caches for data filters on feature classes.
  // Instances of this class are private within layers, so any public facing calls or event
  // raising is done at the layer level.
  sql;
  // object mapping string to string
  cache;
  // object mapping string to promise of array of ints
  extent;
  constructor(permanentWhereClause = "", initialWhereClause = "") {
    this.sql = {
      [CoreFilter.PERMANENT]: permanentWhereClause,
      [CoreFilter.INITIAL]: initialWhereClause
    };
    this.extent = void 0;
    this.cache = {};
  }
  /**
   * Returns list of filter keys that have active filters
   *
   * @method sqlActiveFilters
   * @param {Array} [exclusions] list of any filter keys to exclude from the result. omission includes all filters
   * @returns {Array} list of filter keys with active filter sql
   */
  sqlActiveFilters(exclusions = []) {
    const s = this.sql;
    const rawActive = Object.keys(s).filter((k) => s[k]);
    if (exclusions.length === 0) {
      return rawActive;
    } else {
      return rawActive.filter((k) => exclusions.indexOf(k) === -1);
    }
  }
  /**
   * Indicates if any filters are active. A Permanent filter does not influence the result.
   *
   * @method isActive
   * @returns {Boolean} indicates if any non-permanent filters are active
   */
  isActive() {
    return this.sqlActiveFilters([CoreFilter.PERMANENT]).length > 0;
  }
  /**
   * Returns a SQL WHERE condition that is combination of active filters.
   *
   * @method getCombinedSql
   * @param {Array} [exclusions] list of any filter keys to exclude from the result. omission includes all filters
   * @returns {String} all non-excluded sql statements connected with AND operators.
   */
  getCombinedSql(exclusions = []) {
    const keys = this.sqlActiveFilters(exclusions);
    const l = keys.length;
    if (l === 0) {
      return "";
    } else if (l === 1) {
      return this.sql[keys[0]];
    } else {
      return keys.map((k) => `(${this.sql[k]})`).join(" AND ");
    }
  }
  /**
   * Updates a SQL filter clause.
   *
   * @method setSql
   * @param {String} filterKey key of the filter to update (can be a new value)
   * @param {String} whereClause clause defining the active filters on symbols. Use '' for no filter. Use '1=2' for everything filtered.
   */
  setSql(filterKey, whereClause) {
    if (filterKey === CoreFilter.PERMANENT) {
      console.error("Attempted to overwrite a permanent filter. Not allowed.");
    } else {
      this.sql[filterKey] = whereClause;
      this.clearCacheSet(filterKey);
    }
  }
  /**
   * Returns current SQL for a filter key
   *
   * @method getSql
   * @param {String} filterKey key string indicating what filter the sql belongs to
   * @returns {String} the SQL, if any, that matches the filter type
   */
  getSql(filterKey) {
    return this.sql[filterKey] || "";
  }
  /**
   * Registers a new extent for cache tracking.
   *
   * @method setExtent
   * @param {Extent} extent the extent to filter against
   */
  setExtent(extent) {
    if (!extent.isEqual(this.extent)) {
      this.extent = extent;
      this.clearCacheSet(CoreFilter.EXTENT);
    }
  }
  /**
   * Returns cache key depending on the situation we are in.
   *
   * @method getCacheKey
   * @private
   * @param {Array} sqlFilters list of filter keys influencing this cache
   * @param {Boolean} includeExtent if the cache includes extent based filters
   * @returns {String} the cache key to use
   */
  getCacheKey(sqlFilters, includeExtent) {
    const sqlKey = sqlFilters.sort().join("$");
    return `_cache$${sqlKey}${includeExtent ? "$" + CoreFilter.EXTENT : ""}$`;
  }
  /**
   * Returns cache for a specific filtering scenario.
   *
   * @method getCache
   * @param {Array} sqlFilters list of filter keys influencing this cache
   * @param {Boolean} includeExtent if the cache includes extent based filters
   * @returns {Promise} resolves in a filter result appropriate for the parameters. returns undefined if no cache exists.
   */
  getCache(sqlFilters, includeExtent) {
    const key = this.getCacheKey(sqlFilters, includeExtent);
    return this.cache[key];
  }
  /**
   * Sets a filter query in a cache, so repeated identical requests will only hit the server once
   *
   * @method setCache
   * @param {Promise} queryPromise the query we want to cache
   * @param {Array} sqlFilters list of filter keys influencing this cache
   * @param {Boolean} includeExtent if the cache includes extent based filters
   */
  setCache(queryPromise, sqlFilters, includeExtent) {
    const key = this.getCacheKey(sqlFilters, includeExtent);
    this.cache[key] = queryPromise;
  }
  /**
   * Returns list of cache keys that have caches
   *
   * @method cacheActiveKeys
   * @returns {Array} list of cache keys with active caches
   */
  cacheActiveKeys() {
    const c = this.cache;
    return Object.keys(c).filter((k) => c[k]);
  }
  /**
   * Resets all internal caches.
   *
   * @method clearAllCaches
   */
  clearAllCaches() {
    this.cache = {};
  }
  /**
   * Resets all internal caches related to a filter.
   *
   * @method clearCacheSet
   * @param {String} filterName filter that has changed and needs its caches wiped
   */
  clearCacheSet(filterName) {
    this.cacheActiveKeys().forEach((c) => {
      if (c.indexOf(`$${filterName}$`) > -1) {
        delete this.cache[c];
      }
    });
  }
  /**
   * Resets all internal filter settings to have no filter applied.
   *
   * @method clearAll
   */
  clearAll() {
    this.sql = { [CoreFilter.PERMANENT]: this.sql[CoreFilter.PERMANENT] };
    this.extent = void 0;
    this.clearAllCaches();
  }
}

class ExtentSet {
  id;
  sr;
  _defaultExtent;
  _fullExtent;
  _maximumExtent;
  constructor(id, defaultExtent, fullExtent = void 0, maximumExtent = void 0) {
    this.id = id;
    this.sr = defaultExtent.sr.clone();
    this._defaultExtent = defaultExtent.clone();
    this._fullExtent = fullExtent?.clone();
    this._maximumExtent = maximumExtent?.clone();
    if (fullExtent && !fullExtent.sr.isEqual(this.sr)) {
      console.error(`Full extent provided in extent set has a mismatching spatial reference: ${fullExtent.sr}`);
    }
    if (maximumExtent && !maximumExtent.sr.isEqual(this.sr)) {
      console.error(
        `Maximum extent provided in extent set has a mismatching spatial reference: ${maximumExtent.sr}`
      );
    }
  }
  get defaultExtent() {
    return this._defaultExtent;
  }
  set defaultExtent(extent) {
    this._defaultExtent = extent.clone();
  }
  /**
   * @return {Extent} the full extent (returns default extent if not provided)
   */
  get fullExtent() {
    if (!this._fullExtent) {
      return this.defaultExtent;
    }
    return this._fullExtent;
  }
  set fullExtent(extent) {
    this._fullExtent = extent.clone();
  }
  /**
   * @return {Extent} the maximum extent (returns full extent if not provided)
   */
  get maximumExtent() {
    if (!this._maximumExtent) {
      return this.fullExtent;
    }
    return this._maximumExtent;
  }
  set maximumExtent(extent) {
    this._maximumExtent = extent.clone();
  }
  /**
   * Parses a RAMP API Extent Set config into an ExtentSet object
   * @param {RampExtentSetConfig} extentSetConfig the extent set config
   * @returns {ExtentSet} the parsed ExtentSet object
   */
  static fromConfig(extentSetConfig) {
    return new ExtentSet(
      extentSetConfig.id,
      Extent.fromConfig(`${extentSetConfig.id}-extent-default`, extentSetConfig.default),
      extentSetConfig.full !== void 0 ? Extent.fromConfig(`${extentSetConfig.id}-extent-full`, extentSetConfig.full) : void 0,
      extentSetConfig.maximum !== void 0 ? Extent.fromConfig(`${extentSetConfig.id}-extent-maximum`, extentSetConfig.maximum) : void 0
    );
  }
  clone() {
    return new ExtentSet(this.id, this._defaultExtent, this._fullExtent, this._maximumExtent);
  }
}

class DefPromise {
  realPromise;
  resolveMe(v) {
  }
  rejectMe() {
  }
  getPromise() {
    return this.realPromise;
  }
  constructor() {
    this.realPromise = new Promise((resolve, reject) => {
      this.resolveMe = (v) => {
        resolve(v);
      };
      this.rejectMe = reject;
    });
  }
}

class SharedUtilsAPI {
  /**
   * Get a 'good enough' uuid. For backup purposes if client does not supply its own
   * unique layer id
   *
   * @method  generateUUID
   * @returns {String} a uuid
   */
  generateUUID() {
    let d = Date.now();
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = (d + Math.random() * 16) % 16 | 0;
      d = Math.floor(d / 16);
      return (c === "x" ? r : r & 3 | 8).toString(16);
    });
  }
  // TODO see who is using this. Should it be somewhere more specific?
  /**
   * Convert an image to a canvas element
   *
   * @param {String} url image url to convert (result from the esri print task)
   * @param {Object} canvas [optional = undefined] canvas to draw the image upon; if not supplied, a new canvas will be made
   * @param {Boolean} crossOrigin [optional = true] when set, tries to fetch an image with crossOrigin = anonymous
   * @return {Promise} conversion promise resolving into a canvas of the image
   */
  convertImageToCanvas(url, canvas, crossOrigin = true) {
    const c = canvas ?? window.document.createElement("canvas");
    const image = window.document.createElement("img");
    if (crossOrigin) {
      image.crossOrigin = "anonymous";
    }
    const conversionPromise = new Promise((resolve, reject) => {
      image.addEventListener("load", () => {
        c.width = image.width;
        c.height = image.height;
        c.getContext("2d")?.drawImage(image, 0, 0);
        resolve(c);
      });
      image.addEventListener("error", (error) => reject(error));
    });
    image.src = url;
    return conversionPromise;
  }
  /**
   * Loads an image (as crossing) and converts it to dataURL. If a supplied imageUri is already a dataURL, just return it.
   * If an image fails to load with the crossing attribute, return the original imageUri
   *
   * @function convertImagetoDataURL
   * @param {String} imageUri url of the image to load and convert
   * @param {String} imageType [optional = 'image/png'] format of the image representation
   * @return {Promise} promise resolving with the dataURL of the image
   */
  async convertImagetoDataURL(imageUri, imageType = "image/png") {
    if (imageUri.startsWith("data")) {
      return imageUri;
    }
    return this.convertImageToCanvas(imageUri).then((canvas) => {
      return canvas.toDataURL(imageType);
    }).catch((error) => {
      console.error("Failed to load crossorigin image", imageUri, error);
      return imageUri;
    });
  }
  /**
   * Splits an indexed map server url into an object with .rootUrl and .index
   * properties.
   *
   * @function parseUrlIndex
   * @param  {String} url    an indexed map server url
   * @returns {Object}  the url split into the server root and the index.
   */
  parseUrlIndex(url) {
    const result = {
      rootUrl: url,
      index: 0
    };
    const re = /\/(\d+)\/?$/;
    const matches = url.match(re);
    if (matches) {
      const idxStr = matches[1];
      result.index = isNaN(parseInt(idxStr)) ? void 0 : parseInt(idxStr);
      result.rootUrl = url.substr(0, url.length - matches[0].length);
    } else {
      console.warn("Cannot extract layer index from url " + url);
    }
    return result;
  }
  /**
   * Determines whether the provided control is enabled for the bound layer, based on the config provided
   * @param control the control we want to determine the availability of
   * @param config an object containing information regarding enabled/disabled controls for the bound layer
   * @returns whether the control is available
   */
  controlAvailable(control, config) {
    return config?.disabledControls?.includes(control) ? false : config?.controls ? config?.controls?.includes(control) : true;
  }
}
class UrlWrapper {
  _url;
  _base;
  _query;
  _queryMap = {};
  constructor(url) {
    this._url = url;
    [this._base, this._query] = url.split("?").concat("");
    this._queryMap = this._query.split("&").reduce((map, parameter) => {
      const [key, value] = parameter.split("=");
      map[key] = value;
      return map;
    }, {});
  }
  get query() {
    return this._query;
  }
  get base() {
    return this._base;
  }
  get queryMap() {
    return this._queryMap;
  }
  /**
   * Updates the query part of the url with passed in values.
   *
   * For example:
   *  - orginal url: http://example?flag=red&demohell=true
   *  - queryMapUpdate: {
   *     flag: undefined,
   *     demohell: false,
   *     acid: cat
   * }
   * - resulting url: http://example?demohell=false&acid=cat
   *
   *
   * @param {UrlQueryMap} queryMapUpdate an object of values to be added or replaced on the query of the url; if any values are undefined, their corresponding keys will be removed from the query.
   * @returns {string} updated url
   * @memberof UrlWrapper
   */
  updateQuery(queryMapUpdate) {
    const requestQueryMap = merge.all([{}, this.queryMap, queryMapUpdate]);
    const requestUrl = `${this.base}${Object.entries(requestQueryMap).filter(([, value]) => value !== void 0).map(([key, value], index) => `${index === 0 ? "?" : ""}${key}=${value}`).join("&")}`;
    return requestUrl;
  }
}

const latLongProj = "EPSG:4326";
class ProjectionAPI {
  espgWorker;
  constructor() {
    this.espgWorker = this.defaultEpsgLookup;
    proj4.defs(
      "EPSG:3978",
      "+proj=lcc +lat_1=49 +lat_2=77 +lat_0=49 +lon_0=-95 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
    );
    proj4.defs(
      "EPSG:3979",
      "+proj=lcc +lat_1=49 +lat_2=77 +lat_0=49 +lon_0=-95 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
    );
    proj4.defs("EPSG:54004", "+proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs");
    proj4.defs("EPSG:102100", proj4.defs("EPSG:3857"));
    proj4.defs(
      "EPSG:102187",
      "+proj=tmerc +lat_0=0 +lon_0=-114 +k=0.9999 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
    );
    proj4.defs(
      "EPSG:102190",
      "+proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
    );
    let utm = 1;
    while (utm <= 60) {
      const zone = utm < 10 ? `0${utm}` : utm;
      proj4.defs(`EPSG:326${zone}`, `+proj=utm +zone=${utm} +ellps=WGS84 +datum=WGS84 +units=m +no_defs`);
      utm++;
    }
  }
  /**
   * Add a projection definition.
   * @param {number | string} code the projection code to add.
   * @param {string} proj4formula the formula for the projection.
   */
  addProjection(code, proj4formula) {
    code = typeof code === "number" ? `EPSG:${code}` : code;
    proj4.defs(code, proj4formula);
  }
  // default for lazyness. uses official epsg website, hardcoded for extra style points.
  defaultEpsgLookup(code) {
    const urnRegex = /urn:ogc:def:crs:EPSG::(\d+)/;
    const epsgRegex = /EPSG:(\d+)/;
    const matcher = String(code).match(urnRegex) || String(code).match(epsgRegex) || [];
    if (matcher.length < 2) {
      throw new Error("Invalid code provided.");
    }
    return new Promise((resolve, reject) => {
      const epsgUrl = `https://epsg.io/${matcher[1]}.proj4`;
      const params = {
        responseType: "text"
      };
      const restReq = EsriRequest(epsgUrl, params);
      restReq.then(
        (serviceResult) => {
          if (serviceResult.data) {
            resolve(serviceResult.data);
          } else {
            reject();
          }
        },
        (e) => {
          reject(e);
        }
      );
    });
  }
  /**
   * Fetch a projection string from an EPSG service
   * @param { String | Number } code an EPSG projection code to look up
   * @returns { Promise<String> } resolves with proj4 projection string, or rejects if not found
   */
  epsgLookup(code) {
    return this.espgWorker(code);
  }
  /**
   * Provide an alternate lookup function to find proj4 projection strings based off EPSG codes. Be aware this setting
   * is page-wide, and will impact any instance of RAMP running.
   * Function signature should be `f(code: string | number): Promise<string>`.
   * The function should be able to parse codes that are
   * - just the integer part of an EPSG code (e.g. 1234)
   * - a string in EPSG format (e.g. 'EPSG:1234')
   * - a string in URN format (e.g. 'urn:ogc:def:crs:EPSG::1234')
   * @param lookupFunction
   */
  setEpsgLookup(lookupFunction) {
    this.espgWorker = lookupFunction;
  }
  /**
   * Convert a projection to an string that is compatible with proj4.  If it is an SpatialReference or an integer it will be converted.
   * @param {SpatialReference|Integer|String} proj an SpatialReference, integer or string.  Strings will be unchanged and unchecked,
   * ints and SpatialReference objects will be converted.
   * @return {String} A proj4 friendly projection, in the form EPSG:#### or a WKT
   */
  normalizeProj(proj) {
    if (typeof proj === "object") {
      if (proj.wkid) {
        return "EPSG:" + proj.wkid;
      } else if (proj.wkt) {
        return proj.wkt;
      }
    } else if (typeof proj === "number") {
      return "EPSG:" + proj;
    } else if (typeof proj === "string") {
      return proj;
    }
    throw new Error("Bad argument type, please provide a string, integer or SpatialReference object.");
  }
  /**
   * Check whether or not a spatialReference is supported by proj4 library. Attempt to load from epsg source if not.
   *
   * @param {SpatialReference | string | number} spatialReference to be checked to see if it's supported by proj4. Can be ESRI SR object, WKID integer, EPSG string or WKT.
   * @returns {Promise<boolean>} true if proj was defined or was able to download definition. false if out of luck
   */
  async checkProj(spatialReference) {
    let srcProj;
    let latestProj = "";
    try {
      srcProj = this.normalizeProj(spatialReference);
    } catch {
      return false;
    }
    if (!srcProj.startsWith("EPSG:")) {
      return true;
    }
    if (typeof spatialReference === "object" && spatialReference.latestWkid) {
      latestProj = this.normalizeProj(spatialReference.latestWkid);
    }
    const applyLatest = (latestDef, normalDef) => {
      if (latestDef !== normalDef) {
        proj4.defs(normalDef, proj4.defs(latestDef));
      }
    };
    if (proj4.defs(srcProj)) {
      return true;
    }
    if (latestProj && proj4.defs(latestProj)) {
      applyLatest(latestProj, srcProj);
      return true;
    }
    const doLookup = async (epsgStr) => {
      try {
        const def = await this.epsgLookup(epsgStr);
        if (def === null || def === "") {
          return false;
        }
        proj4.defs(epsgStr, def);
        return true;
      } catch (e) {
        return false;
      }
    };
    const latestLookup = latestProj ? doLookup(latestProj) : Promise.resolve(false);
    const latestSuccess = await latestLookup;
    if (latestSuccess) {
      applyLatest(latestProj, srcProj);
      return true;
    } else {
      return doLookup(srcProj);
    }
  }
  /**
   * Utility for checking a set of spatial references, rejects if one cannot be used
   *
   * @param {Array<SpatialReference | string | number>} spatialReferences set of Spatial references to be checked. Can be ESRI SR object, WKID integer, EPSG string or WKT.
   * @returns {Promise<void>} resolves after all references succeed the check. rejects if any test fails.
   */
  async checkProjBomber(spatialReferences) {
    if (spatialReferences.length > 0) {
      const prj = spatialReferences.pop();
      const happy = await this.checkProj(prj);
      if (happy) {
        return this.checkProjBomber(spatialReferences);
      } else {
        console.error("Unable to parse or locate projection information for this item:", prj);
        throw new Error("Could not find projection information, see console for details");
      }
    }
  }
  /**
   * Reproject a GeoJSON object in place.
   * Note the .crs of the object will not be updated or corrected.
   * Valid formats for the spatial reference parameters are: RAMP SpatialReference, WKID number,
   * WKT string, or EPSG:#### string
   *
   * @param {Object} geojson the GeoJSON to be reprojected, this will be modified in place
   * @param {SpatialReference | String | Number} inputSR spatial reference of the GeoJSON. If missing it will attempt to use any crs data in the GeoJSON, defaulting to Lat Long.
   * @param {SpatialReference | String | Number} outputSR spatial reference to project to. If missing, will use Lat Long.
   * @returns {Promise<Object>} resolves with projected geoJson
   */
  async projectGeoJson(geoJson, inputSR, outputSR) {
    let inSr;
    let outSr;
    if (inputSR) {
      inSr = this.normalizeProj(inputSR);
    } else {
      inSr = SpatialReference.parseGeoJsonCrs(geoJson.crs);
    }
    if (outputSR) {
      outSr = this.normalizeProj(outputSR);
    } else {
      outSr = latLongProj;
    }
    if (outSr === inSr) {
      return geoJson;
    }
    await this.checkProjBomber([inSr, outSr]);
    const projFunc = proj4(inSr, outSr).forward;
    return Tools.applyConverter(geoJson, projFunc);
  }
  /**
   * Project a geometry using local calculations (proj4)
   *
   * @param {SpatialReference | Integer | String} destProj the spatial reference of the result (as SpatialReference, integer WKID or an EPSG string)
   * @param {BaseGeometry} geometry a RAMP API Geometry object
   * @return {Promise} resolve in a RAMP API Geometry object with co-ordinates in the destination projection
   */
  async projectGeometry(destProj, geometry) {
    if (geometry.type === GeometryType.EXTENT) {
      return this.projectExtent(destProj, geometry);
    }
    await this.checkProjBomber([destProj, geometry.sr]);
    const preGJ = geometry.toGeoJSON();
    const postGJ = await this.projectGeoJson(preGJ, this.normalizeProj(geometry.sr), this.normalizeProj(destProj));
    const projectedRampGeom = geo.geom.geomGeoJsonToRamp(postGJ, geometry.id);
    projectedRampGeom.sr = SpatialReference.parseSR(destProj);
    return projectedRampGeom;
  }
  /**
   * Reproject an Extent object on the client.  Does not require network traffic,
   * but may not handle conversion between projection types as well.
   * Internally it tests 8 points along each edge and takes the max extent of the result.
   * To project an extent without warping, convert to a polygon and do a standard geometry projection
   * (result will not be guaranteed to retain Extent characteristics)
   *
   * @param {SpatialReference | Integer | String} destProj the spatial reference of the result (as SpatialReference, integer WKID or an EPSG string)
   * @param {Extent} extent to reproject
   * @returns {Promise} resolves with the reprojected extent
   */
  async projectExtent(destProj, extent) {
    const interpolate = (p0, p1, steps) => {
      if (steps === 0) {
        return [p0, p1];
      }
      const mid = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      if (steps === 1) {
        return [p0, mid, p1];
      }
      if (steps > 1) {
        const i0 = interpolate(p0, mid, steps - 1);
        const i1 = interpolate(mid, p1, steps - 1);
        return i0.concat(i1.slice(1));
      }
      return [[]];
    };
    const points = extent.toPolygonArray().pop() || [];
    let interpolatedPoly = [];
    [0, 1, 2, 3].map((i) => interpolate(points[i], points[i + 1], 3).slice(1)).forEach((seg) => interpolatedPoly = interpolatedPoly.concat(seg));
    const iPoly = new Polygon("warpy", [interpolatedPoly], extent.sr, true);
    const iWarped = await this.projectGeometry(destProj, iPoly);
    const rawWarp = iWarped.toArray().pop() || [];
    const xvals = rawWarp.map((p) => p[0]);
    const yvals = rawWarp.map((p_1) => p_1[1]);
    const x0 = Math.min.apply(null, xvals);
    const x1 = Math.max.apply(null, xvals);
    const y0 = Math.min.apply(null, yvals);
    const y1 = Math.max.apply(null, yvals);
    return Extent.fromParams(extent.id + "_projected", x0, y0, x1, y1, iWarped.sr);
  }
}

class GeoCommonAPI {
  // useful functions
  DEFAULT_MERCATOR = "DEFAULT_ESRI_World_AuxMerc_3857";
  DEFAULT_LAMBERT = "DEFAULT_NRCAN_Lambert_3978";
  proj;
  geom;
  sharedUtils;
  constructor() {
    this.proj = new ProjectionAPI();
    this.geom = new GeometryAPI();
    this.sharedUtils = new SharedUtilsAPI();
  }
  defaultTileSchemas() {
    return [this.DEFAULT_LAMBERT, this.DEFAULT_MERCATOR];
  }
  defaultLODs(keycode) {
    const lodGrinder = (a) => {
      return a.map((lod) => {
        return {
          level: lod[0],
          resolution: lod[1],
          scale: lod[2]
        };
      });
    };
    if (keycode === this.DEFAULT_LAMBERT) {
      const lambertLods = [
        [0, 38364.660062653464, 145e6],
        [1, 22489.62831258996, 85e6],
        [2, 13229.193125052918, 5e7],
        [3, 7937.5158750317505, 3e7],
        [4, 4630.2175937685215, 175e5],
        [5, 2645.8386250105837, 1e7],
        [6, 1587.5031750063501, 6e6],
        [7, 926.0435187537042, 35e5],
        [8, 529.1677250021168, 2e6],
        [9, 317.50063500127004, 12e5],
        [10, 185.20870375074085, 7e5],
        [11, 111.12522225044451, 42e4],
        [12, 66.1459656252646, 25e4],
        [13, 38.36466006265346, 145e3],
        [14, 22.48962831258996, 85e3],
        [15, 13.229193125052918, 5e4],
        [16, 7.9375158750317505, 3e4],
        [17, 4.6302175937685215, 17500]
      ];
      return lodGrinder(lambertLods);
    } else if (keycode === this.DEFAULT_MERCATOR) {
      const mercatorLods = [
        [0, 19567.87924099992, 73957190948944e-6],
        [1, 9783.93962049996, 36978595474472e-6],
        [2, 4891.96981024998, 18489297737236e-6],
        [3, 2445.98490512499, 9244648868618e-6],
        [4, 1222.992452562495, 4622324434309e-6],
        [5, 611.4962262813797, 2311162217155e-6],
        [6, 305.74811314055756, 1155581108577e-6],
        [7, 152.87405657041106, 577790.554289],
        [8, 76.43702828507324, 288895.277144],
        [9, 38.21851414253662, 144447.638572],
        [10, 19.10925707126831, 72223.819286],
        [11, 9.554628535634155, 36111.909643],
        [12, 4.77731426794937, 18055.954822],
        [13, 2.388657133974685, 9027.977411],
        [14, 1.1943285668550503, 4513.988705],
        [15, 0.5971642835598172, 2256.994353],
        [16, 0.29858214164761665, 1128.497176],
        [17, 0.14929107082380833, 564.248588],
        [18, 0.07464553541190416, 282.124294],
        [19, 0.03732276770595208, 141.062147],
        [20, 0.01866138385297604, 70.5310735]
      ];
      return lodGrinder(mercatorLods);
    } else {
      throw new Error(`Unknown tile schema key passed to LOD defaulter ${keycode}`);
    }
  }
}

class APIScope {
  /**
   * The instance of RampMap API scoped to a single Vue R4MP application.
   *
   * @type {InstanceAPI}
   * @memberof APIScope
   */
  $iApi;
  /**
   * The instance of Vue R4MP application controlled by this InstanceAPI.
   * This is just a shorthand for `this.$iApi.$vApp`.
   *
   * @readonly
   * @type {Vue}
   * @memberof APIScope
   */
  get $vApp() {
    return this.$iApi.$vApp;
  }
  get $element() {
    return this.$iApi.$element;
  }
  /**
   * Creates an instance of APIScope.
   *
   * @param {InstanceAPI} iApi
   * @memberof APIScope
   */
  constructor(iApi) {
    this.$iApi = iApi;
  }
}
function isVueConstructor(value) {
  return typeof value === "function" && value.render && typeof value.render === "function";
}
function isComponentOptions(value) {
  const names = [
    "data",
    "props",
    "propsData",
    "computed",
    "methods",
    "watch",
    "template",
    "render",
    "components",
    "model"
  ];
  return typeof value === "object" && !value.functional && names.some((name) => value[name] !== void 0);
}
function isHTMLScreen(value) {
  return typeof value === "object" && Object.keys(value).every((k) => typeof k === "string") && Object.values(value).every((v) => v instanceof HTMLElement);
}
function isTypeofImportVue(value) {
  return typeof value === "object" && value.default !== void 0;
}

class AppbarItemInstance {
  id;
  /**
   * Optional object containing any options to be passed to the appbar component.
   *
   * @type {object}
   * @memberof AppbarItemInstance
   */
  options;
  /**
   * An actual id of the appbar Vue component to use when rendering in the template.
   *
   * @type {string}
   * @memberof AppbarItemInstance
   */
  componentId;
  constructor(value) {
    const params = {
      options: {},
      ...value
    };
    ({ id: this.id, options: this.options, componentId: this.componentId } = params);
  }
}

const useAppbarStore = defineStore("appbar", () => {
  const items = ref({});
  const order = ref([]);
  const temporary = ref([]);
  const visible = computed(
    () => order.value.map(
      (subArray) => subArray.map((id) => items.value[id]).filter((item) => {
        if (typeof item === "string" || item.componentId) {
          return true;
        }
      })
    ).filter((subArray) => subArray.length > 0)
  );
  function addTempButton(value) {
    if (!temporary.value.includes(value)) {
      temporary.value.push(value);
    }
  }
  function removeButton(value) {
    const idx = temporary.value.indexOf(value);
    if (idx !== -1) {
      temporary.value.splice(idx, 1);
    }
    if (value in items.value) {
      delete items.value[value];
    }
    order.value.forEach((subItems) => {
      const idx2 = subItems.indexOf(value);
      if (idx2 !== -1) {
        subItems.splice(idx2, 1);
      }
    });
  }
  return { items, order, temporary, visible, addTempButton, removeButton };
});

const useGridStore = defineStore("grid", () => {
  const grids = ref({});
  const panel = ref();
  const currentId = ref();
  function addGrid(value) {
    grids.value = { ...grids.value, [value.id]: value };
  }
  function removeGrid(id) {
    if (grids.value[id] !== void 0) {
      delete grids.value[id];
    }
  }
  function getGridId(id) {
    return Object.keys(grids.value).find((gid) => grids.value[gid].layerIds.includes(id));
  }
  function removeLayer(gridId, layerId) {
    grids.value[gridId].layerIds = grids.value[gridId].layerIds.filter((id) => id !== layerId);
  }
  return {
    grids,
    panel,
    currentId,
    addGrid,
    removeGrid,
    getGridId,
    removeLayer
  };
});

const useMapCaptionStore = defineStore("map-caption", () => {
  const attribution = ref({ text: {}, logo: {} });
  const scale = ref({});
  const coords = ref({});
  const langtoggle = ref({});
  function toggleScale(value) {
    if (value !== void 0) {
      scale.value.isImperialScale = value;
    } else {
      scale.value.isImperialScale = !scale.value.isImperialScale;
    }
  }
  function setAttribution(newAttribution) {
    attribution.value.text.value = newAttribution.text.value;
    attribution.value.text.disabled = newAttribution.text.disabled;
    attribution.value.logo.altText = newAttribution.logo.altText;
    attribution.value.logo.link = newAttribution.logo.link;
    attribution.value.logo.value = newAttribution.logo.value;
    attribution.value.logo.disabled = newAttribution.logo.disabled;
  }
  return {
    attribution,
    scale,
    coords,
    langtoggle,
    toggleScale,
    setAttribution
  };
});

const bfs = (layers, predicate) => {
  const queue = [...layers];
  while (queue.length > 0) {
    const layer = queue.shift();
    if (predicate(layer)) {
      return layer;
    }
    if (layer) {
      queue.push(...layer.sublayers);
    }
  }
};
const useLayerStore = defineStore("layer", () => {
  const layers = ref([]);
  const layerConfigs = ref([]);
  const mapOrder = ref([]);
  function getLayerByUid(uid) {
    return bfs(layers.value, (layer) => layer?.uid === uid);
  }
  function getLayerById(id) {
    return bfs(layers.value, (layer) => layer?.id === id);
  }
  function getLayerByAny(idOrUid) {
    return bfs(
      layers.value,
      (layer) => layer !== void 0 && (layer.id === idOrUid || layer.uid === idOrUid)
    );
  }
  function addLayerConfig(value) {
    layerConfigs.value = [...layerConfigs.value, value];
  }
  function addLayer(value, index = void 0) {
    layers.value = [...layers.value, value];
    if (value.mapLayer) {
      if (index === void 0 || index < 0) {
        console.error("Map layer added to store with invalid index!");
        index = mapOrder.value.length;
      }
      mapOrder.value.splice(index, 0, value.id);
      mapOrder.value = [...mapOrder.value];
    }
  }
  function reorderLayer(layer, index) {
    if (!layer.mapLayer) {
      console.error("Data layer passed to layer store reorder");
      return;
    }
    if (index < 0) {
      console.error("Negative index passed to layer store reorder");
      return;
    }
    if (index >= mapOrder.value.length) {
      index = mapOrder.value.length - 1;
    }
    const layerOrderIdx = mapOrder.value.findIndex((layerId) => layerId === layer.id);
    if (layerOrderIdx !== -1 && layerOrderIdx !== index) {
      mapOrder.value.splice(layerOrderIdx, 1);
      mapOrder.value.splice(index, 0, layer.id);
      mapOrder.value = [...mapOrder.value];
    }
  }
  function removeLayer(value) {
    const filteredLayers = layers.value.filter((layer) => {
      return layer.id !== value.id || layer.uid !== value.uid;
    });
    layers.value = filteredLayers;
    if (value.mapLayer) {
      const filteredOrder = mapOrder.value.filter((layerId) => layerId !== value.id);
      mapOrder.value = filteredOrder;
    }
  }
  function removeLayerConfig(layerId) {
    const filteredLayerConfigs = layerConfigs.value.filter((layerConfig) => {
      return layerConfig.id !== layerId;
    });
    layerConfigs.value = filteredLayerConfigs;
  }
  return {
    /**
     * All layers registered with the instance (aka the "map")
     */
    layers,
    /**
     * Layer ids of map layers (regardless of layer state), in order of map stack.
     */
    mapOrder,
    layerConfigs,
    getLayerByUid,
    getLayerById,
    getLayerByAny,
    addLayerConfig,
    addLayer,
    reorderLayer,
    removeLayer,
    removeLayerConfig
  };
});

const useConfigStore = defineStore("config", () => {
  const config = ref({
    map: {
      lodSets: [],
      extentSets: [],
      tileSchemas: [],
      basemaps: [],
      initialBasemapId: ""
    },
    fixtures: {},
    layers: []
  });
  const startingFixtures = ref([]);
  const activeBasemapConfig = ref();
  const registeredConfigs = ref({});
  const registeredLangs = ref({});
  function getActiveConfig(lang) {
    if (registeredConfigs.value[registeredLangs.value[lang]] === void 0) {
      throw new Error("Unsupported language or no registered config exists for requested language");
    }
    return registeredConfigs.value[registeredLangs.value[lang]];
  }
  function newConfig(newConfig2) {
    const updatedConfig = { ...config.value, ...newConfig2 };
    config.value = updatedConfig;
    if (Array.isArray(config.value.layers)) {
      const layerStore = useLayerStore();
      layerStore.layerConfigs = [...layerStore.layerConfigs, config.value.layers];
    }
  }
  function registerConfig(configInfo) {
    const configLangs = configInfo.configLangs;
    const config2 = configInfo.config;
    const allLangs = configInfo.allLangs;
    if (configLangs !== void 0 && configLangs.length > 0) {
      configLangs.forEach((lang) => {
        registeredConfigs.value[lang] = config2;
        registeredLangs.value[lang] = lang;
      });
    }
    if (allLangs !== void 0 && allLangs.length > 0) {
      allLangs.forEach((lang) => {
        registeredLangs.value[lang] = Object.keys(registeredConfigs.value)[0];
      });
    }
  }
  return {
    config,
    startingFixtures,
    activeBasemapConfig,
    registeredConfigs,
    registeredLangs,
    getActiveConfig,
    newConfig,
    registerConfig
  };
});

class DetailsItemInstance {
  id;
  name;
  template;
  fields;
  componentId;
  constructor(value) {
    const params = {
      ...typeof value === "string" ? { id: value, template: "", name: "" } : value
    };
    ({ template: this.template, id: this.id, name: this.name, fields: this.fields } = params);
  }
}

const useDetailsStore = defineStore("details", () => {
  const payload = ref([]);
  const properties = ref({});
  const defaultTemplates = ref({});
  const currentFeatureId = ref();
  const slowLoadingFlag = ref(false);
  const activeGreedy = ref(0);
  const lastHilight = ref(0);
  const hilightToggle = ref(true);
  const origin = ref();
  function removeLayer(layer) {
    const idx = payload.value.findIndex((res) => res.uid === layer.uid);
    if (idx !== -1) {
      payload.value.splice(idx, 1);
    }
  }
  function addConfigProperty(item) {
    properties.value = { ...properties.value, [item.id]: item };
  }
  return {
    payload,
    properties,
    defaultTemplates,
    currentFeatureId,
    slowLoadingFlag,
    activeGreedy,
    lastHilight,
    hilightToggle,
    origin,
    removeLayer,
    addConfigProperty
  };
});

const useFixtureStore = defineStore("fixture", () => {
  const items = ref({});
  const loadPromises = ref({});
  function getLoadPromises(fixtureIds) {
    return fixtureIds.map((id) => loadPromises.value[id].getPromise());
  }
  function addFixture(value) {
    items.value = { ...items.value, [value.id]: markRaw(value) };
    if (!(value.id in loadPromises.value)) {
      const loadPromise = new DefPromise();
      loadPromise.resolveMe(markRaw(value));
      loadPromises.value = {
        ...loadPromises.value,
        [value.id]: loadPromise
      };
    } else {
      loadPromises.value[value.id].resolveMe(markRaw(value));
    }
    if (typeof value.added === "function") {
      value.added();
    }
  }
  function removeFixture(value) {
    delete items.value[value.id];
    items.value = { ...items.value };
    delete loadPromises.value[value.id];
    loadPromises.value = { ...loadPromises.value };
    if (typeof value.removed === "function") {
      value.removed();
    }
  }
  function addLoadPromise(fixtureId) {
    loadPromises.value = {
      ...loadPromises.value,
      [fixtureId]: new DefPromise()
    };
  }
  return {
    items,
    loadPromises,
    getLoadPromises,
    addFixture,
    removeFixture,
    addLoadPromise
  };
});

var GlobalEvents = /* @__PURE__ */ ((GlobalEvents2) => {
  GlobalEvents2["APPBAR_BUTTON_CLICK"] = "appbar/click";
  GlobalEvents2["COMPONENT"] = "ramp/component";
  GlobalEvents2["CONFIG_CHANGE"] = "config/configchanged";
  GlobalEvents2["DETAILS_TOGGLE"] = "details/toggle";
  GlobalEvents2["FILTER_CHANGE"] = "filter/change";
  GlobalEvents2["FIXTURE_ADDED"] = "fixture/added";
  GlobalEvents2["FIXTURE_REMOVED"] = "fixture/removed";
  GlobalEvents2["GRID_TOGGLE"] = "grid/toggle";
  GlobalEvents2["HELP_TOGGLE"] = "help/toggle";
  GlobalEvents2["LANG_CHANGE"] = "lang/change";
  GlobalEvents2["LAYER_DRAWSTATECHANGE"] = "layer/drawstatechange";
  GlobalEvents2["LAYER_INITIATIONSTATECHANGE"] = "layer/initiationStatechange";
  GlobalEvents2["LAYER_LAYERSTATECHANGE"] = "layer/layerstatechange";
  GlobalEvents2["LAYER_OPACITYCHANGE"] = "layer/opacitychange";
  GlobalEvents2["LAYER_REGISTERED"] = "layer/registered";
  GlobalEvents2["LAYER_RELOAD_END"] = "layer/reloadend";
  GlobalEvents2["LAYER_RELOAD_START"] = "layer/reloadstart";
  GlobalEvents2["LAYER_REMOVE"] = "layer/remove";
  GlobalEvents2["LAYER_VISIBILITYCHANGE"] = "layer/visibilitychange";
  GlobalEvents2["MAP_BASEMAPCHANGE"] = "map/basemapchanged";
  GlobalEvents2["MAP_BLUR"] = "map/blur";
  GlobalEvents2["MAP_CLICK"] = "map/click";
  GlobalEvents2["MAP_CREATED"] = "map/created";
  GlobalEvents2["MAP_DESTROYED"] = "map/destroyed";
  GlobalEvents2["MAP_DOUBLECLICK"] = "map/doubleclick";
  GlobalEvents2["MAP_EXTENTCHANGE"] = "map/extentchanged";
  GlobalEvents2["MAP_FOCUS"] = "map/focus";
  GlobalEvents2["MAP_GRAPHICHIT"] = "map/graphichit";
  GlobalEvents2["MAP_IDENTIFY"] = "map/identify";
  GlobalEvents2["MAP_KEYDOWN"] = "map/keydown";
  GlobalEvents2["MAP_KEYUP"] = "map/keyup";
  GlobalEvents2["MAP_MOUSEDOWN"] = "map/mousedown";
  GlobalEvents2["MAP_MOUSELEAVE"] = "map/mouseleave";
  GlobalEvents2["MAP_MOUSEMOVE"] = "map/mousemove";
  GlobalEvents2["MAP_MOUSEMOVE_END"] = "map/mousemoveend";
  GlobalEvents2["MAP_MOUSEMOVE_START"] = "map/mousemovestart";
  GlobalEvents2["MAP_REFRESH_END"] = "map/refreshend";
  GlobalEvents2["MAP_REFRESH_START"] = "map/refreshstart";
  GlobalEvents2["MAP_REORDER"] = "map/reorder";
  GlobalEvents2["MAP_RESIZED"] = "map/resized";
  GlobalEvents2["MAP_SCALECHANGE"] = "map/scalechanged";
  GlobalEvents2["MAP_START"] = "map/start";
  GlobalEvents2["METADATA_TOGGLE"] = "metadata/toggle";
  GlobalEvents2["PANEL_CLOSED"] = "panel/closed";
  GlobalEvents2["PANEL_MINIMIZED"] = "panel/minimized";
  GlobalEvents2["PANEL_OPENED"] = "panel/opened";
  GlobalEvents2["RAMP_MOBILEVIEW_CHANGE"] = "ramp/mobileviewchange";
  GlobalEvents2["REORDER_TOGGLE"] = "reorder/toggle";
  GlobalEvents2["SETTINGS_TOGGLE"] = "settings/toggle";
  GlobalEvents2["USER_LAYER_ADDED"] = "user/layeradded";
  GlobalEvents2["WIZARD_TOGGLE"] = "wizard/toggle";
  return GlobalEvents2;
})(GlobalEvents || {});
var DefEH = /* @__PURE__ */ ((DefEH2) => {
  DefEH2["CONFIG_CHANGE_UPDATES_MAP_ATTRIBS"] = "ramp_config_change_updates_map_attribs";
  DefEH2["LAYER_ERROR_UPDATES_LEGEND"] = "ramp_layer_error_updates_legend";
  DefEH2["LAYER_REGISTER_BINDS_LEGEND"] = "ramp_layer_register_binds_legend";
  DefEH2["LAYER_RELOAD_END_BINDS_LEGEND"] = "ramp_layer_reload_end_binds_legend";
  DefEH2["LAYER_RELOAD_START_UPDATES_LEGEND"] = "ramp_layer_reload_start_updates_legend";
  DefEH2["LAYER_REMOVE_UPDATES_DETAILS"] = "ramp_layer_remove_updates_details";
  DefEH2["LAYER_REMOVE_CHECKS_GRID"] = "ramp_layer_remove_checks_grid";
  DefEH2["LAYER_REMOVE_UPDATES_LEGEND"] = "ramp_layer_remove_updates_legend";
  DefEH2["LAYER_USERADD_UPDATES_LEGEND"] = "ramp_layer_useradd_updates_legend";
  DefEH2["MAP_BASEMAP_CHECKS_TILE_PROJ"] = "ramp_map_basemap_checks_tile_proj";
  DefEH2["MAP_BASEMAP_UPDATES_MAP_ATTRIBS"] = "ramp_map_basemap_updates_map_attribs";
  DefEH2["MAP_BLUR_UPDATES_KEY_HANDLER"] = "ramp_map_blur_updates_key_handler";
  DefEH2["MAP_CLICK_RUNS_IDENTIFY"] = "ramp_map_click_runs_identify";
  DefEH2["MAP_CREATED_INITIALIZES_FIXTURES"] = "ramp_map_created_initializes_fixtures";
  DefEH2["MAP_CREATED_UPDATES_MAP_ATTRIBS"] = "ramp_map_created_updates_map_attribs";
  DefEH2["MAP_EXTENT_UPDATES_MAPTIP"] = "ramp_map_extent_updates_maptip";
  DefEH2["MAP_GRAPHICHIT_CREATES_MAPTIP"] = "ramp_map_graphichit_creates_maptip";
  DefEH2["MAP_IDENTIFY_OPENS_IDENTIFY_RESULTS"] = "ramp_map_identify_opens_identify_results";
  DefEH2["MAP_KEYDOWN_UPDATES_COORDS"] = "ramp_map_keydown_updates_coords";
  DefEH2["MAP_KEYDOWN_UPDATES_KEY_HANDLER"] = "ramp_map_keydown_updates_key_handler";
  DefEH2["MAP_KEYUP_UPDATES_KEY_HANDLER"] = "ramp_map_keyup_updates_key_handler";
  DefEH2["MAP_MOUSE_UPDATES_COORDS"] = "ramp_map_mouse_updates_coords";
  DefEH2["MAP_MOUSE_UPDATES_MAPTIP"] = "ramp_map_mouse_updates_maptip";
  DefEH2["MAP_MOUSELEAVE_REMOVES_MAPTIP"] = "ramp_map_mouseleave_removes_maptip";
  DefEH2["MAP_RESIZE_UPDATES_SCALEBAR"] = "ramp_map_resize_updates_scalebar";
  DefEH2["MAP_SCALE_UPDATES_SCALEBAR"] = "ramp_map_scale_updates_scalebar";
  DefEH2["PANEL_CLOSE_UPDATES_APPBAR"] = "ramp_panel_close_updates_appbar";
  DefEH2["PANEL_OPEN_UPDATES_APPBAR"] = "ramp_panel_open_updates_appbar";
  DefEH2["TOGGLE_DETAILS"] = "ramp_toggle_details";
  DefEH2["TOGGLE_GRID"] = "ramp_toggle_grid";
  DefEH2["TOGGLE_HELP"] = "ramp_toggle_help";
  DefEH2["TOGGLE_METADATA"] = "ramp_toggle_metadata";
  DefEH2["TOGGLE_REORDER"] = "ramp_toggle_reorder";
  DefEH2["TOGGLE_SETTINGS"] = "ramp_toggle_settings";
  DefEH2["TOGGLE_WIZARD"] = "ramp_toggle_wizard";
  return DefEH2;
})(DefEH || {});
class EventHandler {
  eventName;
  handlerName;
  handlerFunc;
  constructor(eName, hName, handler) {
    this.eventName = eName;
    this.handlerName = hName;
    this.handlerFunc = handler;
  }
}
class EventAPI extends APIScope {
  /**
   * A vue instance that provides an event bus for all events.
   *
   * @private
   * @type {Vue}
   * @memberof EventAPI
   */
  _eventBus;
  // tracks active event handlers: event name, handler name, and the actual handler function
  _eventRegister;
  // a helpful register of event names that have been declared by the app and fixtures.
  _nameRegister;
  // for autonamer
  _funCounter;
  constructor(iApi) {
    super(iApi);
    this._eventBus = new TinyEmitter();
    this._eventRegister = [];
    this._funCounter = 1;
    this._nameRegister = Object.values(GlobalEvents).filter((e) => typeof e === "string" && e.indexOf("/") > -1);
  }
  /**
   * Locates a registered handler by name, or undefined if not found
   *
   * @param {string} handlerName the name of the event handler
   * @returns {EventHandler | undefined} handler information or undefined
   * @memberof EventAPI
   * @private
   */
  findHandler(handlerName) {
    return this._eventRegister.find((eh) => eh.handlerName === handlerName);
  }
  /**
   * Generates an event handler name. Used when caller doesnt provide one.
   *
   * @param {string} eventName the name of the event the handler is handling
   * @returns {String} a handler name
   * @memberof EventAPI
   * @private
   */
  handlerNamer(eventName) {
    this._funCounter++;
    return eventName.replace(/\//g, "_") + this._funCounter.toString();
  }
  /**
   * Adds event names to the names registry of the event bus.
   *
   * @param {string | Array} names event names or names to register
   * @memberof EventAPI
   */
  registerEventName(names) {
    const arrr = Array.isArray(names) ? names : [names];
    arrr.forEach((n) => {
      if (this._nameRegister.indexOf(n) === -1) {
        this._nameRegister.push(n);
      }
    });
  }
  /**
   * A list of event names that have been registered with the bus.
   *
   * @returns {Array} list of event names
   * @memberof EventAPI
   */
  eventNames() {
    return this._nameRegister.slice();
  }
  // TODO provide a method to unregister an event name? would that ever really need to happen?
  /**
   * Adds an event handler to an event.
   *
   * @param {string} event name of the event to react to
   * @param {Function} callback function to execute when event triggers
   * @param {string} [handlerName] name of the handler (for reference). a name will be generated if not provided.
   * @returns {string} the handler name
   * @memberof EventAPI
   */
  on(event, callback, handlerName = "") {
    if (this.findHandler(handlerName)) {
      throw new Error("Duplicate handler name registration: " + handlerName);
    }
    if (!handlerName) {
      handlerName = this.handlerNamer(event);
    }
    const eh = new EventHandler(event, handlerName, callback);
    this._eventRegister.push(eh);
    this._eventBus.on(event, callback);
    return handlerName;
  }
  /**
   * Removes an event handler from an event.
   *
   * @param {string} handlerName name of the handler to remove
   * @memberof EventAPI
   */
  off(handlerName) {
    const eh = this.findHandler(handlerName);
    if (eh) {
      this._eventRegister.splice(this._eventRegister.indexOf(eh), 1);
      this._eventBus.off(eh.eventName, eh.handlerFunc);
    }
  }
  /**
   * Removes all event handlers, filtered to an event name if desired.
   * @param {string} [event] name of the event. Omission will remove all handlers for all events
   */
  offAll(event = "") {
    const active = this.activeHandlers(event);
    active.forEach((h) => this.off(h));
  }
  /**
   * Removes all default event handlers.
   */
  removeDefaultEvents() {
    Object.values(DefEH).forEach((handlerName) => {
      this.off(handlerName);
    });
  }
  /**
   * Triggers an event.
   *
   * @param {string} event the name of the event
   * @param {...any[]} args any arguements the event is expecting
   * @memberof EventAPI
   */
  emit(event, ...args) {
    this._eventBus.emit(event, ...args);
  }
  /**
   * Adds an event handler to an event that will be respected once. After the handler
   * reacts to the event, it will be removed.
   *
   * @param {string} event name of the event to react to once
   * @param {Function} callback function to execute when event triggers
   * @param {string} [handlerName] name of the handler (for reference). a name will be generated if not provided.
   * @returns {string} the handler name
   * @memberof EventAPI
   */
  once(event, callback, handlerName = "") {
    if (!handlerName) {
      handlerName = this.handlerNamer(event);
    }
    const secretCallback = (...args) => {
      callback(...args);
      this.off(handlerName);
    };
    return this.on(event, secretCallback, handlerName);
  }
  /**
   * Returns any active event handlers, filtered to an event name if desired.
   *
   * @param {string} [event] name of the event. Omission will return all active handlers
   * @returns {Array} list of handler names
   * @memberof EventAPI
   */
  activeHandlers(event = "") {
    if (event === "") {
      return this._eventRegister.map((eh) => eh.handlerName);
    }
    return this._eventRegister.filter((eh) => eh.eventName === event).map((eh) => eh.handlerName);
  }
  /**
   * Loads the set of standard, built-in event handlers to the R4MP Vue instance.
   * This will quickly set up the vanilla version of RAMP.
   * Note this function is automatically run by the instance startup unless the loadDefaultEvents option is
   * set to false. The function is exposed to allow custom pages the ability to call it at a different point
   * in the startup. Also, a subset of standard event handlers can be provided on the optional parameter if one
   * wishes to omit some of the standard handlers.
   *
   * @param {Array<string>} [eventHandlerNames] list of built-in event handler names to add. omission means all built-in event handlers will be added
   * @returns {Array<string>} resolves with array of event handler names
   * @memberof EventAPI
   */
  addDefaultEvents(eventHandlerNames) {
    if (!Array.isArray(eventHandlerNames) || eventHandlerNames.length === 0) {
      eventHandlerNames = Object.values(DefEH);
    }
    return eventHandlerNames.map((hn) => this.defaultHandlerFactory(hn));
  }
  /**
   * Will apply the implementation of default events handlers
   *
   * @param {string} handlerName the name of the default event handler to create
   * @returns {String} name of the event handler
   * @memberof EventAPI
   * @private
   */
  defaultHandlerFactory(handlerName) {
    let zeHandler;
    switch (handlerName) {
      case "ramp_config_change_updates_map_attribs" /* CONFIG_CHANGE_UPDATES_MAP_ATTRIBS */:
        zeHandler = (payload) => {
          const currentBasemapConfig = payload.map.basemaps.find(
            (bms) => bms.id === this.$iApi.geo.map.getCurrentBasemapId()
          );
          this.$iApi.geo.map.caption.updateAttribution(currentBasemapConfig?.attribution);
        };
        this.$iApi.event.on("config/configchanged" /* CONFIG_CHANGE */, zeHandler, handlerName);
        break;
      case "ramp_layer_error_updates_legend" /* LAYER_ERROR_UPDATES_LEGEND */:
        zeHandler = (payload) => {
          if (payload.layer.layerState === LayerState.ERROR) {
            const legendFixture = this.$iApi.fixture.get("legend");
            if (legendFixture) {
              legendFixture.updateLegend(payload.layer);
            }
          }
        };
        this.$iApi.event.on("layer/layerstatechange" /* LAYER_LAYERSTATECHANGE */, zeHandler, handlerName);
        break;
      case "ramp_layer_register_binds_legend" /* LAYER_REGISTER_BINDS_LEGEND */:
        zeHandler = (layer) => {
          const legendFixture = this.$iApi.fixture.get("legend");
          if (legendFixture) {
            legendFixture.updateLegend(layer);
          }
        };
        this.$iApi.event.on("layer/registered" /* LAYER_REGISTERED */, zeHandler, handlerName);
        break;
      case "ramp_layer_reload_end_binds_legend" /* LAYER_RELOAD_END_BINDS_LEGEND */:
        zeHandler = (layer) => {
          const legendFixture = this.$iApi.fixture.get("legend");
          if (legendFixture) {
            legendFixture.updateLegend(layer);
          }
        };
        this.$iApi.event.on("layer/reloadend" /* LAYER_RELOAD_END */, zeHandler, handlerName);
        break;
      case "ramp_layer_reload_start_updates_legend" /* LAYER_RELOAD_START_UPDATES_LEGEND */:
        zeHandler = (layer) => {
          if (!layer.isSublayer) {
            const legendApi = this.$iApi.fixture.get("legend");
            if (legendApi) {
              legendApi.reloadLayerItem(layer.uid);
            }
          }
        };
        this.$iApi.event.on("layer/reloadstart" /* LAYER_RELOAD_START */, zeHandler, handlerName);
        break;
      case "ramp_layer_remove_checks_grid" /* LAYER_REMOVE_CHECKS_GRID */:
        zeHandler = (layer) => {
          if (this.$iApi.fixture.get("grid")) {
            const gridStore = useGridStore(this.$vApp.$pinia);
            const gridId = gridStore.getGridId(layer.id);
            if (gridId === void 0) return;
            gridStore.removeLayer(gridId, layer.id);
            if (gridStore.grids[gridId].layerIds.length === 0) {
              gridStore.removeGrid(gridId);
              const currentId = gridStore.currentId;
              if (gridId === currentId) {
                const panel = this.$iApi.panel.get("grid");
                this.$iApi.panel.close(panel);
                gridStore.currentId = void 0;
              }
            }
          }
        };
        this.$iApi.event.on("layer/remove" /* LAYER_REMOVE */, zeHandler, handlerName);
        break;
      case "ramp_layer_remove_updates_details" /* LAYER_REMOVE_UPDATES_DETAILS */:
        zeHandler = (layer) => {
          const detailsStore = useDetailsStore(this.$vApp.$pinia);
          if (this.$iApi.fixture.get("details")) {
            detailsStore.removeLayer(layer);
          }
        };
        this.$iApi.event.on("layer/remove" /* LAYER_REMOVE */, zeHandler, handlerName);
        break;
      case "ramp_layer_remove_updates_legend" /* LAYER_REMOVE_UPDATES_LEGEND */:
        zeHandler = (layer) => {
          const legendApi = this.$iApi.fixture.get("legend");
          if (legendApi) {
            legendApi.removeLayerItem(layer);
            this.$iApi.updateAlert(
              this.$iApi.$i18n.t("legend.alert.layerRemoved", {
                name: layer.name
              })
            );
          }
        };
        this.$iApi.event.on("layer/remove" /* LAYER_REMOVE */, zeHandler, handlerName);
        break;
      case "ramp_layer_useradd_updates_legend" /* LAYER_USERADD_UPDATES_LEGEND */:
        zeHandler = (layer) => {
          const legendFixture = this.$iApi.fixture.get("legend");
          if (legendFixture) {
            legendFixture.addLayerItem(layer);
          }
        };
        this.$iApi.event.on("user/layeradded" /* USER_LAYER_ADDED */, zeHandler, handlerName);
        break;
      case "ramp_map_basemap_checks_tile_proj" /* MAP_BASEMAP_CHECKS_TILE_PROJ */:
        zeHandler = (payload) => {
          if (payload.schemaChanged) {
            this.$iApi.geo.layer.allLayers().filter((l) => l.layerType === LayerType.TILE).forEach((tl) => {
              tl.checkProj();
            });
          }
        };
        this.$iApi.event.on("map/basemapchanged" /* MAP_BASEMAPCHANGE */, zeHandler, handlerName);
        break;
      case "ramp_map_basemap_updates_map_attribs" /* MAP_BASEMAP_UPDATES_MAP_ATTRIBS */:
        zeHandler = () => {
          this.$iApi.geo.map.caption.updateAttribution(
            useConfigStore(this.$vApp.$pinia).activeBasemapConfig?.attribution
          );
        };
        this.$iApi.event.on("map/basemapchanged" /* MAP_BASEMAPCHANGE */, zeHandler, handlerName);
        break;
      case "ramp_map_blur_updates_key_handler" /* MAP_BLUR_UPDATES_KEY_HANDLER */:
        zeHandler = () => {
          this.$iApi.geo.map.stopKeyPan();
        };
        this.$iApi.event.on("map/blur" /* MAP_BLUR */, zeHandler, handlerName);
        break;
      case "ramp_map_click_runs_identify" /* MAP_CLICK_RUNS_IDENTIFY */:
        zeHandler = (clickParam) => {
          if (clickParam.button === 0) {
            this.$iApi.geo.map.runIdentify(clickParam);
          }
        };
        this.on("map/click" /* MAP_CLICK */, zeHandler, handlerName);
        break;
      case "ramp_map_created_initializes_fixtures" /* MAP_CREATED_INITIALIZES_FIXTURES */:
        zeHandler = () => {
          const fixtures = useFixtureStore(this.$vApp.$pinia).items;
          Object.keys(fixtures).forEach((fId) => {
            fixtures[fId].initialized?.();
          });
        };
        if (this.$iApi.geo.map.created) zeHandler();
        this.$iApi.event.on("map/created" /* MAP_CREATED */, zeHandler, handlerName);
        break;
      case "ramp_map_created_updates_map_attribs" /* MAP_CREATED_UPDATES_MAP_ATTRIBS */:
        zeHandler = () => {
          this.$iApi.geo.map.caption.updateAttribution(
            useConfigStore(this.$vApp.$pinia).activeBasemapConfig?.attribution
          );
        };
        if (this.$iApi.geo.map.created) zeHandler();
        this.$iApi.event.on("map/created" /* MAP_CREATED */, zeHandler, handlerName);
        break;
      case "ramp_map_extent_updates_maptip" /* MAP_EXTENT_UPDATES_MAPTIP */:
        zeHandler = () => {
          if (this.$iApi.geo.map.keysActive) {
            const screenCenter = this.$iApi.geo.map.mapPointToScreenPoint(
              this.$iApi.geo.map.getExtent().center()
            );
            this.$iApi.geo.map.maptip.checkAtCoord(screenCenter);
          } else {
            this.$iApi.geo.map.maptip.clear();
          }
        };
        this.$iApi.event.on(
          "map/extentchanged" /* MAP_EXTENTCHANGE */,
          throttle(50, true, () => zeHandler()),
          // Smaller throttle because extent change is intervalled
          handlerName
        );
        break;
      case "ramp_map_graphichit_creates_maptip" /* MAP_GRAPHICHIT_CREATES_MAPTIP */:
        zeHandler = (tooltipInfo) => {
          this.$iApi.geo.map.maptip.generateDefaultMaptip(tooltipInfo);
        };
        this.$iApi.event.on("map/graphichit" /* MAP_GRAPHICHIT */, zeHandler, handlerName);
        break;
      case "ramp_map_identify_opens_identify_results" /* MAP_IDENTIFY_OPENS_IDENTIFY_RESULTS */:
        zeHandler = (identifyParam) => {
          const detailFix = this.$iApi.fixture.get("details");
          if (detailFix) {
            detailFix.openDetails(identifyParam.results);
          }
        };
        this.on("map/identify" /* MAP_IDENTIFY */, zeHandler, handlerName);
        break;
      case "ramp_map_keydown_updates_coords" /* MAP_KEYDOWN_UPDATES_COORDS */:
        this.$iApi.event.on(
          "map/keydown" /* MAP_KEYDOWN */,
          throttle(50, () => {
            const mapCaptionStore = useMapCaptionStore(this.$vApp.$pinia);
            const currentCrosshairsCoords = mapCaptionStore.coords;
            if (currentCrosshairsCoords?.disabled || !this.$iApi.geo.map.keysActive) {
              return;
            }
            this.$iApi.geo.map.caption.formatPoint(this.$iApi.geo.map.getExtent().center()).then((fs) => {
              mapCaptionStore.coords = {
                formattedString: fs
              };
            });
          }),
          handlerName
        );
        break;
      case "ramp_map_keydown_updates_key_handler" /* MAP_KEYDOWN_UPDATES_KEY_HANDLER */:
        zeHandler = (payload) => {
          this.$iApi.geo.map.mapKeyDown(payload);
        };
        this.$iApi.event.on("map/keydown" /* MAP_KEYDOWN */, zeHandler, handlerName);
        break;
      case "ramp_map_keyup_updates_key_handler" /* MAP_KEYUP_UPDATES_KEY_HANDLER */:
        zeHandler = (payload) => {
          this.$iApi.geo.map.mapKeyUp(payload);
        };
        this.$iApi.event.on("map/keyup" /* MAP_KEYUP */, zeHandler, handlerName);
        break;
      case "ramp_map_mouse_updates_coords" /* MAP_MOUSE_UPDATES_COORDS */:
        this.$iApi.event.on(
          "map/mousemove" /* MAP_MOUSEMOVE */,
          throttle(50, (mapMove) => {
            const mapCaptionStore = useMapCaptionStore(this.$vApp.$pinia);
            const currentCursorCoords = mapCaptionStore.coords;
            if (currentCursorCoords?.disabled) {
              return;
            }
            this.$iApi.geo.map.caption.formatPoint(this.$iApi.geo.map.screenPointToMapPoint(mapMove)).then((fs) => {
              mapCaptionStore.coords = {
                formattedString: fs
              };
            });
          }),
          handlerName
        );
        break;
      case "ramp_map_mouse_updates_maptip" /* MAP_MOUSE_UPDATES_MAPTIP */:
        zeHandler = (mapMove) => {
          this.$iApi.geo.map.maptip.checkAtCoord({
            screenX: mapMove.screenX,
            screenY: mapMove.screenY
          });
        };
        this.$iApi.event.on(
          "map/mousemove" /* MAP_MOUSEMOVE */,
          throttle(50, (mapMove) => zeHandler(mapMove)),
          handlerName
        );
        break;
      case "ramp_map_mouseleave_removes_maptip" /* MAP_MOUSELEAVE_REMOVES_MAPTIP */:
        zeHandler = () => {
          this.$iApi.geo.map.maptip.clear();
        };
        this.$iApi.event.on("map/mouseleave" /* MAP_MOUSELEAVE */, zeHandler);
        break;
      case "ramp_map_resize_updates_scalebar" /* MAP_RESIZE_UPDATES_SCALEBAR */:
        this.$iApi.event.on(
          "map/resized" /* MAP_RESIZED */,
          debounce(100, () => this.$iApi.geo.map.caption.updateScale()),
          handlerName
        );
        break;
      case "ramp_map_scale_updates_scalebar" /* MAP_SCALE_UPDATES_SCALEBAR */:
        this.$iApi.event.on(
          "map/scalechanged" /* MAP_SCALECHANGE */,
          debounce(300, () => this.$iApi.geo.map.caption.updateScale()),
          handlerName
        );
        break;
      case "ramp_panel_close_updates_appbar" /* PANEL_CLOSE_UPDATES_APPBAR */:
        zeHandler = (panel) => {
          const appbarStore = useAppbarStore(this.$vApp.$pinia);
          if (this.$iApi.fixture.get("appbar") && !appbarStore.order.flat().find((item) => item === panel.id)) {
            appbarStore.removeButton(panel.id);
          }
        };
        this.on("panel/closed" /* PANEL_CLOSED */, zeHandler, handlerName);
        break;
      case "ramp_panel_open_updates_appbar" /* PANEL_OPEN_UPDATES_APPBAR */:
        zeHandler = (panel) => {
          const appbarStore = useAppbarStore(this.$vApp.$pinia);
          if (this.$iApi.fixture.get("appbar") && (!panel.teleport || panel.teleport?.showAppbarButton) && !appbarStore.order.flat().find((item) => item === panel.id)) {
            appbarStore.addTempButton(panel.id);
          }
        };
        this.on("panel/opened" /* PANEL_OPENED */, zeHandler, handlerName);
        break;
      case "ramp_toggle_details" /* TOGGLE_DETAILS */:
        zeHandler = (payload, open) => {
          const detailsFixture = this.$iApi.fixture.get("details");
          if (detailsFixture) {
            detailsFixture.toggleFeature(payload, open);
          }
        };
        this.$iApi.event.on("details/toggle" /* DETAILS_TOGGLE */, zeHandler, handlerName);
        break;
      case "ramp_toggle_grid" /* TOGGLE_GRID */:
        zeHandler = (layer, open) => {
          const gridFixture = this.$iApi.fixture.get("grid");
          if (gridFixture) {
            gridFixture.toggleGrid(layer.id, open);
          }
        };
        this.$iApi.event.on("grid/toggle" /* GRID_TOGGLE */, zeHandler, handlerName);
        break;
      case "ramp_toggle_help" /* TOGGLE_HELP */:
        zeHandler = (payload) => {
          const helpFixture = this.$iApi.fixture.get("help");
          if (helpFixture) {
            helpFixture.toggleHelp(payload);
          }
        };
        this.$iApi.event.on("help/toggle" /* HELP_TOGGLE */, zeHandler, handlerName);
        break;
      case "ramp_toggle_metadata" /* TOGGLE_METADATA */:
        zeHandler = (payload, open) => {
          const metadataFixture = this.$iApi.fixture.get("metadata");
          if (metadataFixture) {
            metadataFixture.toggleMetadata(payload, open);
          }
        };
        this.$iApi.event.on("metadata/toggle" /* METADATA_TOGGLE */, zeHandler, handlerName);
        break;
      case "ramp_toggle_reorder" /* TOGGLE_REORDER */:
        zeHandler = (payload) => {
          const reorderFixture = this.$iApi.fixture.get("layer-reorder");
          if (reorderFixture) {
            reorderFixture.toggleLayerReorder(payload);
          }
        };
        this.$iApi.event.on("reorder/toggle" /* REORDER_TOGGLE */, zeHandler, handlerName);
        break;
      case "ramp_toggle_settings" /* TOGGLE_SETTINGS */:
        zeHandler = (layer, payload) => {
          const settingsFixture = this.$iApi.fixture.get("settings");
          if (settingsFixture) {
            settingsFixture.toggleSettings(layer, payload);
          }
        };
        this.$iApi.event.on("settings/toggle" /* SETTINGS_TOGGLE */, zeHandler, handlerName);
        break;
      case "ramp_toggle_wizard" /* TOGGLE_WIZARD */:
        zeHandler = (payload) => {
          const wizardFixture = this.$iApi.fixture.get("wizard");
          if (wizardFixture) {
            wizardFixture.toggleWizard(payload);
          }
        };
        this.$iApi.event.on("wizard/toggle" /* WIZARD_TOGGLE */, zeHandler, handlerName);
        break;
      default:
        console.error(`Unrecognized default event handler name encountered: ${handlerName}`);
        return `ERROR_NOT_REGISTERED__${handlerName}`;
    }
    return handlerName;
  }
}

const messages$i = {"en":{"lang-code":"en","lang-dir":"ltr","lang-en":"English","lang-fr":"anglais","lang-native":"English","ramp.about.open":"Open About RAMP","ramp.about":"About RAMP","keyboardInstructions.title":"Keyboard Instructions","keyboardInstructions.open":"Open keyboard instructions","keyboardInstructions.app":"Use 'Tab' to navigate between sections of the application.","keyboardInstructions.lists":"Use the arrow keys to move between items in lists. With a list item selected you can press 'Space' or 'Enter' to click the item. You can also navigate within the list item using 'Tab'.","keyboardInstructions.map":"When the map is selected, use the arrow keys to move around and 'Enter' to select a point.","keyboardInstructions.OK":"OK","map.toggleScaleToMetric":"Switch to metric map scale","map.toggleScaleToImperial":"Switch to imperial map scale","map.coordinates.east":"E","map.coordinates.west":"W","map.coordinates.north":"N","map.coordinates.south":"S","map.changeLanguage":"Change Language","map.language.short":"EN-CA","map.language.en":"English","map.language.fr":"Français","map.language.curr":"current","map.export":"export map","notifications.open":"Open Notifications Panel","notifications.title":"Notifications","notifications.empty":"No new notifications.","notifications.controls.dismiss":"Dismiss","notifications.controls.expand":"Expand","notifications.controls.collapse":"Collapse","notifications.controls.clearAll":"Clear All","panels.access":"Press enter or space to access the panel","panels.controls.close":"Close","panels.controls.pin":"Pin","panels.controls.unpin":"Unpin","panels.controls.back":"Back","panels.controls.optionsMenu":"More","panels.controls.minimize":"Minimize","panels.controls.expand":"Expand","panels.controls.collapse":"Collapse","panels.controls.moveRight":"Move Right","panels.controls.moveLeft":"Move Left","panels.controls.items":"Use the arrow keys to navigate the items","panels.alert.open":"{name} panel opened","panels.alert.close":"{name} panel closed","panels.alert.minimize":"{name} panel minimized","layer.error":"{id} failed to load","layer.longload":"{id} is taking longer than expected to load","layer.longdraw":"{id} is taking longer than expected to draw","layer.mismatch":"{name} cannot be displayed in the current projection","layer.filtersdisabled":"Filters have been disabled for {name}","layer.filterwarning":"You are attempting to use a grid that contains unmodifiable layers. Filtering will be partially disabled.","layer.noexportmap":"{name} was attempted to be added as a Map Image Layer but Map Export is not enabled for the service","caption.attributionDefaultText":"Powered by ESRI","caption.attributionLogoAltText":"ESRI logo","caption.attributionLink":"https://www.esri.com/"},"fr":{"lang-code":"fr","lang-dir":"ltr","lang-en":"French","lang-fr":"français","lang-native":"Français","ramp.about.open":"Ouvrir À propos de PCAR","ramp.about":"À propos de PCAR","keyboardInstructions.title":"Instructions clavier","keyboardInstructions.open":"Instructions clavier ouvert","keyboardInstructions.app":"Utilisez la touche Tab pour vous déplacer entre les sections de l'application.","keyboardInstructions.lists":"Lorsqu'un élément de la liste est sélectionné, vous pouvez appuyer sur « Espace » ou « Entrée » pour cliquer sur l'élément. Vous pouvez également vous déplacer au sein de l'élément de la liste au moyen de la touche « Tab ».","keyboardInstructions.map":"Lorsque la carte est sélectionnée, utilisez le pavé curseur pour vous déplacer et appuyez sur « Entrée »  pour sélectionner un point.","keyboardInstructions.OK":"OK","map.toggleScaleToMetric":"Passer à l'échelle métrique","map.toggleScaleToImperial":"Passer à l'échelle impériale","map.coordinates.east":"E","map.coordinates.west":"O","map.coordinates.north":"N","map.coordinates.south":"S","map.changeLanguage":"Changer de langue","map.language.short":"FR-CA","map.language.en":"English","map.language.fr":"Français","map.language.curr":"actuel","map.export":"exporter la carte","notifications.open":"Ouvrir la fenêtre des notifications","notifications.title":"Notifications","notifications.empty":"Aucune nouvelle notification.","notifications.controls.dismiss":"Rejeter","notifications.controls.expand":"Développer","notifications.controls.collapse":"Réduire","notifications.controls.clearAll":"Effacer tout","panels.access":"Appuyez sur Entrée ou sur la barre d'espacement pour accéder au panneau","panels.controls.close":"Fermer","panels.controls.pin":"Épingler","panels.controls.unpin":"Désépingler","panels.controls.back":"Retour","panels.controls.optionsMenu":"Plus","panels.controls.minimize":"Réduire","panels.controls.expand":"Développer","panels.controls.collapse":"Réduire","panels.controls.moveRight":"Aller à droite","panels.controls.moveLeft":"Aller à gauche","panels.controls.items":"Utilisez les touches fléchées pour naviguer entre les éléments","panels.alert.open":"Fenêtre {name} ouverte","panels.alert.close":"Fenêtre {name} fermée","panels.alert.minimize":"Fenêtre {name} réduite","layer.error":"Échec du chargement de {id}","layer.longload":"Le chargement de {id} met plus de temps que prévu","layer.longdraw":"{id} prend plus de temps que prévu à extraire","layer.mismatch":"{id} ne peut pas s'afficher dans la projection actuelle","layer.filtersdisabled":"Les filtres ont été désactivés pour {name}","layer.filterwarning":"Vous essayez d'utiliser une grille qui contient des couches non modifiables. Le filtrage sera partiellement désactivé.","layer.noexportmap":"La tentative d’ajouter {name} comme couche d’imagerie cartographique a échouée car elle n’a pu être activé pour ce service","caption.attributionDefaultText":"Propulsé par ESRI","caption.attributionLogoAltText":"Logo ESRI","caption.attributionLink":"https://www.esri.com/fr-fr/home"}};

const lang = "en";
const numberFormats = {
  en: {
    number: {
      style: "decimal",
      useGrouping: false,
      maximumFractionDigits: 20
    }
  },
  fr: {
    number: {
      style: "decimal",
      useGrouping: false,
      maximumFractionDigits: 20
    }
  }
};
function i18n() {
  return createI18n({
    legacy: false,
    // get the language of the page from the root `html` node
    locale: document.documentElement.getAttribute("lang") || lang,
    fallbackLocale: lang,
    globalInjection: true,
    //@ts-ignore
    messages: messages$i,
    numberFormats
  });
}

const useMaptipStore = defineStore("maptip", () => {
  const maptipInstance = ref(void 0);
  const maptipPoint = ref(void 0);
  const content = ref("");
  function setMaptipInstance(value) {
    maptipInstance.value = value;
  }
  function setMaptipPoint(value) {
    maptipPoint.value = value;
  }
  function setMaptipContent(value) {
    content.value = value;
  }
  return {
    maptipInstance,
    maptipPoint,
    content,
    setMaptipInstance,
    setMaptipPoint,
    setMaptipContent
  };
});

const _sfc_main$1H = /* @__PURE__ */ defineComponent({
  __name: "esri-map",
  setup(__props) {
    const maptipStore = useMaptipStore();
    const iApi = inject("iApi");
    const maptipPoint = computed(() => maptipStore.maptipPoint);
    const maptipInstance = computed(() => maptipStore.maptipInstance);
    const maptipContent = computed(() => maptipStore.content);
    const watchers = reactive([]);
    watchers.push(
      watch(maptipPoint, () => {
        if (maptipPoint.value) {
          let offsetX, offsetY;
          const originX = iApi.geo.map.getPixelWidth() / 2;
          const originY = 0;
          const screenPointFromMapPoint = iApi.geo.map.mapPointToScreenPoint(maptipPoint.value);
          offsetX = screenPointFromMapPoint.screenX - originX;
          offsetY = originY - screenPointFromMapPoint.screenY;
          maptipInstance.value.setProps({
            offset: [offsetX, offsetY]
          });
          if (maptipContent.value && maptipContent.value !== "") {
            maptipInstance.value.show();
          }
        } else {
          maptipInstance.value.hide();
        }
      })
    );
    watchers.push(
      watch(maptipContent, (maptipContent2) => {
        if (maptipContent2 && maptipContent2 !== "" && maptipPoint) {
          maptipInstance.value.setContent(maptipContent2);
          maptipInstance.value.show();
        } else {
          maptipInstance.value.hide();
        }
      })
    );
    onBeforeUnmount(() => {
      watchers.forEach((unwatch) => unwatch());
    });
    const mouseFocus = () => {
      iApi.geo.map.setMouseFocus();
    };
    return (_ctx, _cache) => {
      const _directive_tippy = resolveDirective("tippy");
      return withDirectives((openBlock(), createElementBlock("div", {
        name: "esriMap",
        id: "esriMap",
        class: "h-full overflow-hidden",
        onMousedown: mouseFocus,
        onKeydown: _cache[0] || (_cache[0] = withKeys(withModifiers(() => {
        }, ["prevent"]), ["up", "down", "left", "right"]))
      }, null, 544)), [
        [_directive_tippy, {
          allowHTML: true,
          zIndex: 150,
          theme: "ramp4",
          trigger: "manual",
          appendTo: "parent",
          arrow: false,
          delay: 200,
          duration: [200, 200]
        }]
      ]);
    };
  }
});

class CustomResizeObserver {
  resizeObserver;
  constructor(breakpoints) {
    this.resizeObserver = "ResizeObserver" in self ? new ResizeObserver(function(entries) {
      const defaultBreakpoints = {
        xs: 200,
        sm: 576,
        md: 768,
        lg: 960
      };
      entries.forEach(function(entry) {
        const bp = entry.target.dataset.breakpoints ? JSON.parse(entry.target.dataset.breakpoints) : breakpoints ?? defaultBreakpoints;
        Object.keys(bp).forEach(function(breakpoint) {
          const minWidth = bp[breakpoint];
          if (entry.contentRect.width >= minWidth) {
            entry.target.classList.add(breakpoint);
          } else {
            entry.target.classList.remove(breakpoint);
          }
        });
      });
    }) : void 0;
  }
  observe(target) {
    this.resizeObserver?.observe(target);
  }
}

const _hoisted_1$1q = ["data-cy"];
const _sfc_main$1G = /* @__PURE__ */ defineComponent({
  __name: "panel-container",
  props: {
    panel: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const componentEl = ref(null);
    const props = __props;
    const skipTransition = ref(false);
    onMounted(() => {
      if (props.panel.teleport) {
        const ro = new CustomResizeObserver(
          // only need default breakpoints for mobile vs non mobile
          // TODO: Iron out defaulting. Should this be a complete override instead?
          { xs: 0, sm: 461, ...props.panel.teleport.breakpoints }
        );
        ro.observe(componentEl.value);
      }
    });
    const animateTransition = (el, done, value) => {
      if (skipTransition.value) {
        return done();
      }
      anime({
        targets: el,
        opacity: {
          value,
          duration: 400,
          easing: "cubicBezier(.5, .05, .1, .3)"
        },
        complete: done
      });
    };
    const enter = (el, done) => {
      animateTransition(el, done, [0, 1]);
    };
    const beforeLeave = (el) => {
      if (el.classList.contains("screen-spinner")) {
        return;
      }
      skipTransition.value = props.panel.isScreenLoaded(props.panel.route.screen);
      componentEl.value.querySelectorAll("[focus-item").forEach((element) => element.classList.remove("default-focus-style"));
    };
    const leave = (el, done) => {
      animateTransition(el, done, [0, 1]);
    };
    return (_ctx, _cache) => {
      const _directive_focus_container = resolveDirective("focus-container");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["shadow-tm bg-white h-full xs:mr-0 sm:mr-12 last:mr-0 pointer-events-auto min-w-0 shrink-0", __props.panel.expanded ? "flex-grow max-w-full" : ""]),
        style: normalizeStyle(__props.panel.style),
        "data-cy": __props.panel.id,
        ref_key: "componentEl",
        ref: componentEl
      }, [
        createVNode(Transition, {
          onBeforeLeave: beforeLeave,
          onLeave: leave,
          onEnter: enter
        }, {
          default: withCtx(() => [
            withDirectives((openBlock(), createBlock(resolveDynamicComponent(__props.panel.route.screen), mergeProps({ class: "h-full" }, __props.panel.route.props, { panel: __props.panel }), null, 16, ["panel"])), [
              [_directive_focus_container]
            ])
          ]),
          _: 1
        })
      ], 14, _hoisted_1$1q);
    };
  }
});

const usePanelStore = defineStore("panel", () => {
  const pinned = ref(void 0);
  const priority = ref(void 0);
  const stackWidth = ref(0);
  const remWidth = ref(0);
  const mobileView = ref(false);
  const reorderable = ref(true);
  const items = ref({});
  const regPromises = ref({});
  const orderedItems = ref([]);
  const teleported = ref([]);
  const visible = ref([]);
  const getRemainingWidth = computed(() => {
    return remWidth.value;
  });
  function getVisible(screenSize) {
    if (screenSize === "xs" && visible.value.length > 0) {
      return [visible.value.slice().pop()];
    }
    return visible.value;
  }
  function getRegPromises(panelIds) {
    const reguPromises = [];
    panelIds.forEach((panelId) => {
      if (panelId in regPromises.value) {
        reguPromises.push(regPromises.value[panelId].getPromise());
      }
    });
    return reguPromises;
  }
  function openPanel(panel) {
    open(panel);
    updateVisible();
    priority.value = void 0;
  }
  function closePanel(panel) {
    close(panel);
    updateVisible();
  }
  function movePanel(panel, direction) {
    move(panel, direction);
    updateVisible();
  }
  function removePanel(panel) {
    remove(panel);
    updateVisible();
  }
  function setStackWidth(value) {
    stackWidth.value = value;
    updateVisible();
  }
  function setMobileView(value) {
    mobileView.value = value;
  }
  function updateVisible() {
    let remainingWidth = stackWidth.value;
    const nowVisible = [];
    const defaultWidth = 350;
    const panelMargin = 12;
    const gridMinWidth = 600;
    for (let i = orderedItems.value.length - 1; i >= 0; i--) {
      const panel = orderedItems.value[i];
      let panelWidth = panel.width || defaultWidth;
      if (!mobileView.value) {
        panelWidth += panelMargin;
      } else {
        panelWidth = remainingWidth;
      }
      if (panel.id === "grid") {
        panelWidth = Math.max(Math.min(panelWidth, remainingWidth), gridMinWidth);
      }
      if (remainingWidth >= panelWidth && !mobileView.value || nowVisible.length === 0) {
        remainingWidth -= panelWidth;
        nowVisible.unshift(panel);
      }
      if (panel.id === "grid" && remainingWidth < gridMinWidth) {
        break;
      }
    }
    if (pinned.value && //@ts-ignore
    !nowVisible.includes(pinned.value) && !mobileView.value) {
      let lastElement;
      for (let i = 0; i < nowVisible.length - 1 && remainingWidth < (pinned.value.width || defaultWidth) + panelMargin; i++) {
        lastElement = nowVisible.shift();
        remainingWidth += lastElement.width || defaultWidth;
      }
      if (remainingWidth >= (pinned.value.width || defaultWidth)) {
        nowVisible.unshift(pinned.value);
      } else {
        if (!priority.value) {
          lastElement = nowVisible.shift();
          nowVisible.unshift(pinned.value);
        }
      }
      const pinnedIndex = orderedItems.value.indexOf(pinned.value);
      const lastRemovedIndex = orderedItems.value.indexOf(lastElement);
      const newPanelOrder = orderedItems.value.slice();
      if (lastRemovedIndex > -1) {
        newPanelOrder.splice(pinnedIndex, 1);
        newPanelOrder.splice(lastRemovedIndex, 0, pinned.value);
      }
      orderedItems.value = newPanelOrder;
    }
    remWidth.value = remainingWidth;
    visible.value = nowVisible;
  }
  function registerPanel(panel) {
    items.value = { ...items.value, [panel.id]: panel };
    if (!(panel.id in regPromises.value)) {
      const regPromise = new DefPromise();
      regPromise.resolveMe(panel);
      regPromises.value = {
        ...regPromises.value,
        [panel.id]: regPromise
      };
    } else {
      regPromises.value[panel.id].resolveMe(panel);
    }
  }
  function open(panel) {
    if (panel.teleport) {
      teleported.value = [...teleported.value, panel];
    } else {
      orderedItems.value = [...orderedItems.value, panel];
      priority.value = panel;
    }
  }
  function close(panel) {
    if (panel.teleport) {
      const index = teleported.value.indexOf(panel);
      if (index !== -1) {
        teleported.value = [...teleported.value.slice(0, index), ...teleported.value.slice(index + 1)];
      }
    } else {
      const index = orderedItems.value.indexOf(panel);
      if (index !== -1) {
        orderedItems.value = [...orderedItems.value.slice(0, index), ...orderedItems.value.slice(index + 1)];
      }
    }
  }
  function move(panel, direction) {
    const index = orderedItems.value.indexOf(panel);
    const delta = direction === "right" ? 1 : -1;
    if (visible.value.includes(orderedItems.value[index + delta])) {
      [orderedItems.value[index], orderedItems.value[index + delta]] = [
        orderedItems.value[index + delta],
        orderedItems.value[index]
      ];
    }
  }
  function remove(panel) {
    if (items.value[panel.id] !== void 0) {
      delete items.value[panel.id];
    }
    if (regPromises.value[panel.id] !== void 0) {
      delete regPromises.value[panel.id];
    }
    const index = visible.value.indexOf(panel);
    if (index !== -1) {
      visible.value = [...visible.value.slice(0, index), ...visible.value.slice(index + 1)];
    }
    if (pinned.value && pinned.value.id == panel.id) {
      pinned.value = void 0;
    }
  }
  function addRegPromise(panelId) {
    regPromises.value = {
      ...regPromises.value,
      [panelId]: new DefPromise()
    };
  }
  return {
    items,
    regPromises,
    orderedItems,
    pinned,
    priority,
    visible,
    stackWidth,
    remWidth,
    mobileView,
    reorderable,
    teleported,
    getRemainingWidth,
    getVisible,
    getRegPromises,
    openPanel,
    closePanel,
    movePanel,
    removePanel,
    setStackWidth,
    setMobileView,
    updateVisible,
    registerPanel,
    addRegPromise
  };
});

const _sfc_main$1F = /* @__PURE__ */ defineComponent({
  __name: "panel-stack",
  setup(__props) {
    const panelStore = usePanelStore();
    const iApi = inject("iApi");
    const el = ref();
    const mobileMode = computed(() => panelStore.mobileView);
    onMounted(() => {
      const resizeObserver = new ResizeObserver((entries) => {
        const newMode = !(iApi?.$vApp.$root?.$refs["app-size"]).classList.contains("sm");
        const oldMode = mobileMode.value;
        if (oldMode !== newMode) {
          panelStore.mobileView = newMode;
          iApi?.event.emit(GlobalEvents.RAMP_MOBILEVIEW_CHANGE, newMode);
        }
        panelStore.setStackWidth(entries[0].contentRect.width);
      });
      resizeObserver.observe(el.value?.$el);
    });
    const visible = (screenSize) => (
      //@ts-ignore
      panelStore.getVisible(screenSize)
    );
    const enter = (el2, done) => {
      animateTransition(el2, done, [
        [6, 0],
        [0, 1]
      ]);
    };
    const leave = (el2, done) => {
      const [bbox, pbbox] = [el2.children[0].getBoundingClientRect(), el2.parentElement.getBoundingClientRect()];
      el2.style.width = `${bbox.width}px`;
      el2.style.height = `${bbox.height}px`;
      el2.style.left = `${bbox.left - pbbox.left}px`;
      el2.style.position = "absolute";
      animateTransition(el2, done, [
        [0, -6],
        [1, 0]
      ]);
    };
    const animateTransition = (el2, done, values) => {
      anime({
        targets: el2,
        duration: 300,
        translateY: {
          value: values[0],
          easing: "cubicBezier(.5, .05, .1, .3)"
        },
        opacity: {
          value: values[1],
          duration: 250,
          easing: "cubicBezier(.5, .05, .1, .3)"
        },
        complete: done
      });
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(TransitionGroup, {
        onEnter: enter,
        onLeave: leave,
        name: "panel-container",
        tag: "div",
        ref_key: "el",
        ref: el
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(visible(unref(iApi).screenSize), (panel) => {
            return openBlock(), createBlock(_sfc_main$1G, {
              key: `${panel.id}`,
              panel
            }, null, 8, ["panel"]);
          }), 128))
        ]),
        _: 1
      }, 512);
    };
  }
});

const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

const PanelStack = /* @__PURE__ */ _export_sfc(_sfc_main$1F, [["__scopeId", "data-v-11f38702"]]);

const _hoisted_1$1p = ["content", "aria-label"];
const _sfc_main$1E = /* @__PURE__ */ defineComponent({
  __name: "dropdown-menu",
  props: {
    position: {
      type: String,
      default: "bottom"
    },
    popperOptions: {
      type: Object,
      default() {
        return {};
      }
    },
    tooltip: { type: String },
    tooltipPlacement: { type: String, default: "bottom" },
    tooltipPlacementAlt: { type: String, default: "top" },
    tooltipTheme: { type: String, default: "ramp4" },
    tooltipAnimation: { type: String, default: "scale" },
    centered: { type: Boolean, default: true },
    ariaLabel: { type: String }
  },
  setup(__props) {
    const open = ref(false);
    const popper = ref(null);
    const watchers = reactive([]);
    const el = ref();
    const dropdown = ref();
    const dropdownTrigger = ref();
    const props = __props;
    watchers.push(
      watch(open, () => {
        popper.value.update();
      })
    );
    const toggleDropdown = () => {
      open.value = !open.value;
      dropdownTrigger.value._tippy.hide();
    };
    const focusDropdownTrigger = () => {
      dropdownTrigger.value._tippy.setProps({
        placement: open.value ? props.tooltipPlacementAlt : props.tooltipPlacement
      });
      dropdownTrigger.value._tippy.show();
    };
    const blurDropdownTrigger = () => {
      dropdownTrigger.value._tippy.hide();
    };
    onMounted(() => {
      window.addEventListener(
        "click",
        (event) => {
          if (!el.value || !el.value.contains(event.target)) {
            open.value = false;
          }
        },
        { capture: true }
      );
      window.addEventListener("blur", () => {
        open.value = false;
      });
      window.addEventListener("focusin", (event) => {
        if (!el.value || !el.value.contains(event.target)) {
          open.value = false;
        }
      });
      dropdownTrigger.value.addEventListener("focus", focusDropdownTrigger);
      dropdownTrigger.value.addEventListener("blur", blurDropdownTrigger);
      dropdownTrigger.value.addEventListener("mouseover", focusDropdownTrigger);
      dropdownTrigger.value.addEventListener("mouseleave", blurDropdownTrigger);
      nextTick(() => {
        const overflowScrollModifier = {
          name: "overflowScroll",
          enabled: true,
          phase: "main",
          fn({ state }) {
            const { bottom } = detectOverflow(state);
            if (bottom > 0) {
              state.styles.popper.overflowY = bottom > 100 ? "auto" : void 0;
              state.styles.popper.overflowX = "hidden";
              state.styles.popper.height = `${state.rects.popper.height - bottom - 8}px`;
            } else {
              state.styles.popper.height = "auto";
            }
          }
        };
        if (dropdownTrigger.value && dropdown.value) {
          popper.value = createPopper(dropdownTrigger.value, dropdown.value, {
            placement: props.position || "bottom",
            modifiers: [
              overflowScrollModifier,
              {
                name: "offset",
                options: {
                  offset: [0, 5]
                }
              }
            ],
            ...props.popperOptions
          });
        }
      });
    });
    onBeforeUnmount(() => {
      watchers.forEach((unwatch) => unwatch());
      window.removeEventListener(
        "click",
        (event) => {
          if (!el.value || !el.value.contains(event.target)) {
            open.value = false;
          }
        },
        { capture: true }
      );
      window.removeEventListener("blur", () => {
        open.value = false;
      });
      window.removeEventListener("focusin", (event) => {
        if (!el.value || !el.value.contains(event.target)) {
          open.value = false;
        }
      });
      dropdownTrigger.value.removeEventListener("focus", focusDropdownTrigger);
      dropdownTrigger.value.removeEventListener("blur", blurDropdownTrigger);
      dropdownTrigger.value.removeEventListener("mouseover", focusDropdownTrigger);
      dropdownTrigger.value.removeEventListener("mouseleave", blurDropdownTrigger);
      open.value = false;
    });
    return (_ctx, _cache) => {
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", {
        ref_key: "el",
        ref: el
      }, [
        withDirectives((openBlock(), createElementBlock("button", {
          type: "button",
          class: "text-gray-500 hover:text-black dropdown-button",
          onClick: toggleDropdown,
          content: __props.tooltip,
          "aria-label": __props.ariaLabel ? String(__props.ariaLabel) : String(__props.tooltip),
          ref_key: "dropdownTrigger",
          ref: dropdownTrigger
        }, [
          renderSlot(_ctx.$slots, "header")
        ], 8, _hoisted_1$1p)), [
          [_directive_tippy, {
            placement: __props.tooltipPlacement,
            theme: __props.tooltipTheme,
            animation: __props.tooltipAnimation,
            appendTo: "parent",
            trigger: "manual"
          }]
        ]),
        withDirectives(createElementVNode("div", {
          onClick: _cache[0] || (_cache[0] = ($event) => popper.value.update()),
          class: normalizeClass(["rv-dropdown shadow-md border border-gray:200 py-8 bg-white rounded z-10", { "text-center": __props.centered }]),
          ref_key: "dropdown",
          ref: dropdown
        }, [
          renderSlot(_ctx.$slots, "default", {
            close: () => open.value = !open.value
          })
        ], 2), [
          [vShow, open.value]
        ])
      ], 512);
    };
  }
});

const useNotificationStore = defineStore("notification", () => {
  const notificationStack = ref([]);
  const groups = ref({});
  const notificationNumber = computed(() => {
    return notificationStack.value.length >= 99 ? 99 : notificationStack.value.length;
  });
  function showNotification(notification) {
    notificationStack.value = [notification, ...notificationStack.value];
  }
  function removeNotification(notification) {
    if (notificationStack.value.includes(notification)) {
      const index = notificationStack.value.indexOf(notification);
      if (notification instanceof NotificationGroup) {
        removeGroup(notification);
      }
      if (index > -1) {
        notificationStack.value.splice(index, 1);
      }
    }
  }
  function registerGroup(group) {
    groups.value[group.id] = group;
  }
  function addToGroup(id, message) {
    if (groups.value[id]) {
      groups.value[id].messageList.push(message);
      if (!notificationStack.value.includes(groups.value[id])) {
        notificationStack.value = [groups.value[id], ...notificationStack.value];
      }
    }
  }
  function clearAll() {
    Object.values(groups.value).forEach((group) => removeGroup(group));
    notificationStack.value = [];
  }
  function removeGroup(group) {
    const index = notificationStack.value.indexOf(group);
    if (index > -1) {
      notificationStack.value.splice(index, 1);
    }
    group.messageList = [];
  }
  return {
    notificationStack,
    groups,
    notificationNumber,
    showNotification,
    removeNotification,
    registerGroup,
    addToGroup,
    clearAll
  };
});

const _hoisted_1$1o = { class: "h-full flex flex-col" };
const _hoisted_2$16 = { class: "w-full flex mb-6" };
const _hoisted_3$M = ["content", "aria-label"];
const _sfc_main$1D = /* @__PURE__ */ defineComponent({
  __name: "screen",
  props: {
    panel: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const notificationStore = useNotificationStore();
    const { t } = useI18n();
    const number = computed(() => notificationStore.notificationNumber);
    const clearAll = () => notificationStore.clearAll();
    return (_ctx, _cache) => {
      const _component_panel_screen = resolveComponent("panel-screen");
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createBlock(_component_panel_screen, { panel: __props.panel }, {
        header: withCtx(() => [
          createTextVNode(toDisplayString(unref(t)("notifications.title")), 1)
        ]),
        content: withCtx(() => [
          createElementVNode("div", _hoisted_1$1o, [
            createElementVNode("div", _hoisted_2$16, [
              withDirectives((openBlock(), createElementBlock("button", {
                type: "button",
                onClick: clearAll,
                class: normalizeClass(["p-4 ml-auto", [
                  !number.value ? "text-gray-300 cursor-default pointer-events-none" : "text-gray-500 hover:text-black"
                ]]),
                content: unref(t)("notifications.controls.clearAll"),
                "aria-label": unref(t)("notifications.controls.clearAll")
              }, _cache[0] || (_cache[0] = [
                createElementVNode("svg", {
                  xmlns: "http://www.w3.org/2000/svg",
                  viewBox: "0 0 24 24",
                  class: "fill-current h-24 w-24"
                }, [
                  createElementVNode("path", {
                    d: "M0 0h24v24H0z",
                    fill: "none"
                  }),
                  createElementVNode("path", { d: "M5 13h14v-2H5v2zm-2 4h14v-2H3v2zM7 7v2h14V7H7z" })
                ], -1)
              ]), 10, _hoisted_3$M)), [
                [_directive_tippy, {
                  placement: "bottom",
                  theme: "ramp4",
                  animation: "scale"
                }]
              ])
            ]),
            createVNode(_sfc_main$1B, { class: "overflow-y-auto" })
          ])
        ]),
        _: 1
      }, 8, ["panel"]);
    };
  }
});

var NotificationType = /* @__PURE__ */ ((NotificationType2) => {
  NotificationType2["ERROR"] = "error";
  NotificationType2["INFO"] = "info";
  NotificationType2["WARNING"] = "warning";
  return NotificationType2;
})(NotificationType || {});
class NotificationAPI extends APIScope {
  notificationStore;
  /**
   * Creates an instance of Notification API
   *
   * @param iApi The instance API for the RAMP that this should be associated with.
   */
  constructor(iApi) {
    super(iApi);
    this.$iApi.panel.register({
      id: "notifications",
      config: {
        screens: {
          "notifications-screen": markRaw(_sfc_main$1D)
        },
        alertName: "notifications.title"
      }
    });
    this.notificationStore = useNotificationStore(this.$vApp.$pinia);
  }
  /**
   * Shows a notification with the type and message provided
   *
   * @param {NotificationType} type The type of notification to display
   * @param {string} message The message to display in the notification
   * @memberof NotificationAPI
   */
  show(type, message) {
    this.notificationStore.showNotification({ type, message });
  }
  /**
   * Adds a notification group, which can be used to hold multiple messages.
   *
   * @param {string} id The id for the group
   * @param {NotificationType} type The type of notification the group will hold, 'error' 'warning' or 'info'
   * @param {string} message The "main" message for the notification, describing the grouped messages
   * @memberof NotificationAPI
   */
  addGroup(id, type, message) {
    if (this.getGroup(id)) {
      throw new Error("Duplicate notification group id registration: " + id);
    }
    const group = new NotificationGroup(this.$iApi, id, type, message);
    this.notificationStore.registerGroup(group);
    return group;
  }
  /**
   * Returns the group with the id provided, returns `undefined` if there is no such group
   *
   * @param {string} id The id of the group wanted
   * @returns {NotificationGroup | undefined}
   * @memberof NotificationAPI
   */
  getGroup(id) {
    const group = this.notificationStore.groups[id];
    return group;
  }
}
class NotificationGroup extends APIScope {
  notificationStore = useNotificationStore(this.$vApp.$pinia);
  id;
  message;
  type;
  messageList = [];
  /**
   * Creates an instance of Notification Group
   *
   * @param $iApi
   * @param id The id for the group
   * @param type The type of notification the group will show
   * @param message The main message for the group
   */
  constructor($iApi, id, type, message) {
    super($iApi);
    this.id = id;
    this.type = type;
    this.message = message;
  }
  /**
   * Shows a message under the group
   *
   * @param {string} message The message to show
   * @memberof NotificationGroup
   */
  show(message) {
    this.notificationStore.addToGroup(this.id, message);
  }
}

const _hoisted_1$1n = ["content"];
const _hoisted_2$15 = { class: "flex items-center text-left" };
const _hoisted_3$L = { class: "select-text cursor-text" };
const _hoisted_4$v = ["content"];
const _hoisted_5$n = {
  key: 0,
  class: "text-left"
};
const _sfc_main$1C = /* @__PURE__ */ defineComponent({
  __name: "notification-item",
  props: {
    notification: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const notificationStore = useNotificationStore();
    const { t } = useI18n();
    const props = __props;
    const open = ref(false);
    const icons = reactive({
      [NotificationType.WARNING]: "⚠",
      [NotificationType.INFO]: "ℹ️",
      [NotificationType.ERROR]: "❌"
    });
    const removeNotification = (notif) => {
      notificationStore.removeNotification(notif);
    };
    const tooltipShow = () => {
      if (!props.notification.messageList) {
        return false;
      }
    };
    return (_ctx, _cache) => {
      const _directive_tippy = resolveDirective("tippy");
      return withDirectives((openBlock(), createElementBlock("li", {
        class: normalizeClass(["flex-col default-focus-style p-4", __props.notification.messageList ? "cursor-pointer" : ""]),
        content: unref(t)(open.value ? "notifications.controls.collapse" : "notifications.controls.expand"),
        onClick: _cache[1] || (_cache[1] = ($event) => open.value = !open.value)
      }, [
        createElementVNode("div", _hoisted_2$15, [
          createElementVNode("span", null, [
            createTextVNode(toDisplayString(icons[__props.notification.type]) + " ", 1),
            createElementVNode("span", _hoisted_3$L, toDisplayString(__props.notification.message), 1)
          ]),
          _cache[4] || (_cache[4] = createElementVNode("span", { class: "flex-grow" }, null, -1)),
          __props.notification.messageList ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(["dropdown-icon p-4 pointer-events-none", { "transform -rotate-180": open.value }])
          }, _cache[2] || (_cache[2] = [
            createElementVNode("svg", {
              xmlns: "http://www.w3.org/2000/svg",
              height: "24",
              viewBox: "0 0 24 24",
              width: "24"
            }, [
              createElementVNode("path", { d: "M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" })
            ], -1)
          ]), 2)) : createCommentVNode("", true),
          withDirectives((openBlock(), createElementBlock("button", {
            type: "button",
            onClick: _cache[0] || (_cache[0] = withModifiers(($event) => removeNotification(__props.notification), ["stop"])),
            class: "mx-4 p-4",
            content: unref(t)("notifications.controls.dismiss")
          }, _cache[3] || (_cache[3] = [
            createElementVNode("svg", {
              class: "fill-current w-16 h-16",
              xmlns: "http://www.w3.org/2000/svg",
              viewBox: "0 0 352 512"
            }, [
              createElementVNode("path", { d: "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z" })
            ], -1)
          ]), 8, _hoisted_4$v)), [
            [_directive_tippy, { theme: "ramp4", animation: "scale" }]
          ])
        ]),
        __props.notification.messageList && open.value ? (openBlock(), createElementBlock("div", _hoisted_5$n, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.notification.messageList, (message, index) => {
            return openBlock(), createElementBlock("p", {
              key: __props.notification.id + message + index
            }, toDisplayString(message), 1);
          }), 128))
        ])) : createCommentVNode("", true)
      ], 10, _hoisted_1$1n)), [
        [_directive_tippy, { onShow: tooltipShow, theme: "ramp4", animation: "scale" }]
      ]);
    };
  }
});

const _hoisted_1$1m = ["content"];
const _hoisted_2$14 = {
  key: 0,
  class: "w-full border-b border-black"
};
const _hoisted_3$K = {
  key: 1,
  class: "flex flex-col items-center h-full"
};
const _sfc_main$1B = /* @__PURE__ */ defineComponent({
  __name: "notification-list",
  setup(__props) {
    const notificationStore = useNotificationStore();
    const { t } = useI18n();
    const el = ref();
    const blurEvent = () => {
      el.value._tippy.hide();
    };
    const keyupEvent = (e) => {
      const evt = e;
      if (evt.key === "Tab" && el.value?.matches(":focus")) {
        el.value._tippy.show();
      }
    };
    onMounted(() => {
      el.value?.addEventListener("blur", blurEvent);
      el.value?.addEventListener("keyup", keyupEvent);
    });
    onBeforeUnmount(() => {
      el.value?.removeEventListener("blur", blurEvent);
      el.value?.removeEventListener("keyup", keyupEvent);
    });
    const notificationStack = computed(() => notificationStore.notificationStack);
    return (_ctx, _cache) => {
      const _directive_focus_item = resolveDirective("focus-item");
      const _directive_focus_list = resolveDirective("focus-list");
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", null, [
        notificationStack.value.length > 0 ? withDirectives((openBlock(), createElementBlock("ul", {
          key: 0,
          content: unref(t)("panels.controls.items"),
          ref_key: "el",
          ref: el
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(notificationStack.value, (notification, index) => {
            return openBlock(), createElementBlock(Fragment, {
              key: notification.message + index
            }, [
              index > 0 ? (openBlock(), createElementBlock("div", _hoisted_2$14)) : createCommentVNode("", true),
              withDirectives(createVNode(_sfc_main$1C, {
                class: normalizeClass([notification.type]),
                notification
              }, null, 8, ["class", "notification"]), [
                [_directive_focus_item]
              ])
            ], 64);
          }), 128))
        ], 8, _hoisted_1$1m)), [
          [_directive_focus_list],
          [_directive_tippy, { trigger: "manual", placement: "top-start" }]
        ]) : (openBlock(), createElementBlock("div", _hoisted_3$K, [
          _cache[0] || (_cache[0] = createElementVNode("span", { class: "flex-grow" }, null, -1)),
          _cache[1] || (_cache[1] = createElementVNode("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24",
            class: "h-48 w-48 fill-current"
          }, [
            createElementVNode("path", {
              d: "M0 0h24v24H0z",
              fill: "none"
            }),
            createElementVNode("path", { d: "M18 7l-1.41-1.41-6.34 6.34 1.41 1.41L18 7zm4.24-1.41L11.66 16.17 7.48 12l-1.41 1.41L11.66 19l12-12-1.42-1.41zM.41 13.41L6 19l1.41-1.41L1.83 12 .41 13.41z" })
          ], -1)),
          createElementVNode("span", null, toDisplayString(unref(t)("notifications.empty")), 1),
          _cache[2] || (_cache[2] = createElementVNode("span", { style: { "flex-grow": "6" } }, null, -1))
        ]))
      ]);
    };
  }
});

const _hoisted_1$1l = { class: "flex items-center hover:text-white" };
const _hoisted_2$13 = ["aria-label"];
const _hoisted_3$J = {
  key: 0,
  class: "number rounded-full w-18 text-white"
};
const _hoisted_4$u = { class: "notification-dropdown pointer-events-auto bg-white rounded text-center text-black w-500 h-256 flex flex-col p-0" };
const _hoisted_5$m = { class: "pb-8 border-b border-gray-600" };
const _hoisted_6$l = { class: "absolute flex right-3 top-3" };
const _hoisted_7$l = ["content", "aria-label"];
const _sfc_main$1A = /* @__PURE__ */ defineComponent({
  __name: "caption-button",
  setup(__props) {
    const notificationStore = useNotificationStore();
    const { t } = useI18n();
    const number = computed(() => notificationStore.notificationNumber);
    const clearAll = () => notificationStore.clearAll();
    return (_ctx, _cache) => {
      const _component_close = resolveComponent("close");
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createBlock(_sfc_main$1E, {
        position: "top-start",
        tooltip: unref(t)("notifications.title"),
        tooltipPlacement: "top",
        class: "pointer-events-auto sm:flex ml-4 mr-8"
      }, {
        header: withCtx(() => [
          createElementVNode("div", _hoisted_1$1l, [
            (openBlock(), createElementBlock("svg", {
              class: "fill-current w-24 h-24",
              xmlns: "http://www.w3.org/2000/svg",
              viewBox: "0 0 24 24",
              "aria-label": unref(t)("notifications.open")
            }, _cache[0] || (_cache[0] = [
              createElementVNode("path", { d: "M12 22c1.1 0 2-.9 2-2h-4c0 1.1.89 2 2 2zm6-6v-5c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2z" }, null, -1)
            ]), 8, _hoisted_2$13)),
            number.value && number.value > 0 ? (openBlock(), createElementBlock("span", _hoisted_3$J, toDisplayString(number.value), 1)) : createCommentVNode("", true)
          ])
        ]),
        default: withCtx((scope) => [
          createElementVNode("div", _hoisted_4$u, [
            createElementVNode("div", null, [
              createElementVNode("h4", _hoisted_5$m, toDisplayString(unref(t)("notifications.title")), 1),
              createElementVNode("div", _hoisted_6$l, [
                withDirectives((openBlock(), createElementBlock("button", {
                  type: "button",
                  onClick: clearAll,
                  class: normalizeClass(["p-4 mr-6", [
                    !number.value ? "text-gray-300 cursor-default pointer-events-none" : "text-gray-500 hover:text-black"
                  ]]),
                  content: unref(t)("notifications.controls.clearAll"),
                  "aria-label": unref(t)("notifications.controls.clearAll")
                }, _cache[1] || (_cache[1] = [
                  createElementVNode("svg", {
                    xmlns: "http://www.w3.org/2000/svg",
                    viewBox: "0 0 24 24",
                    class: "fill-current h-24 w-24"
                  }, [
                    createElementVNode("path", {
                      d: "M0 0h24v24H0z",
                      fill: "none"
                    }),
                    createElementVNode("path", { d: "M5 13h14v-2H5v2zm-2 4h14v-2H3v2zM7 7v2h14V7H7z" })
                  ], -1)
                ]), 10, _hoisted_7$l)), [
                  [_directive_tippy, {
                    placement: "bottom",
                    theme: "ramp4",
                    animation: "scale",
                    appendTo: "parent"
                  }]
                ]),
                createVNode(_component_close, {
                  onClick: scope.close
                }, null, 8, ["onClick"])
              ])
            ]),
            createVNode(_sfc_main$1B, { class: "overflow-y-auto h-230" })
          ])
        ]),
        _: 1
      }, 8, ["tooltip"]);
    };
  }
});

const NotificationsCaptionButton = /* @__PURE__ */ _export_sfc(_sfc_main$1A, [["__scopeId", "data-v-3f132e2e"]]);

const _hoisted_1$1k = { class: "flex hover:text-white" };
const _hoisted_2$12 = ["aria-label"];
const _hoisted_3$I = { class: "about-ramp-dropdown pointer-events-auto bg-white rounded w-256 h-50" };
const _hoisted_4$t = { class: "pb-8 border-b border-gray-600 mb-10" };
const _hoisted_5$l = { class: "absolute right-5 top-5" };
const _hoisted_6$k = { class: "select-text" };
const _hoisted_7$k = { class: "font-bold cursor-text" };
const _hoisted_8$g = { class: "text-sm cursor-text" };
const _hoisted_9$b = { class: "text-sm cursor-text" };
const _sfc_main$1z = /* @__PURE__ */ defineComponent({
  __name: "about-ramp-dropdown",
  props: {
    position: {
      type: String,
      default: "top-start"
    }
  },
  setup(__props) {
    const { t } = useI18n();
    const versionString = computed(() => {
      return `${version.major}.${version.minor}.${version.patch}`;
    });
    const versionHash = computed(() => {
      return version.hash.slice(0, 9);
    });
    const buildDate = computed(() => {
      let timestamp = new Date(version.timestamp);
      if (isNaN(timestamp)) {
        return "dev mode, no date";
      } else {
        const padZero = (num) => {
          if (num < 10) {
            return "0" + num.toString();
          } else {
            return num.toString();
          }
        };
        return `${timestamp.getFullYear()}-${timestamp.getMonth() + 1}-${timestamp.getDate()} ${timestamp.getHours()}:${padZero(
          timestamp.getMinutes()
        )}:${padZero(timestamp.getSeconds())}`;
      }
    });
    return (_ctx, _cache) => {
      const _component_close = resolveComponent("close");
      const _component_dropdown_menu = resolveComponent("dropdown-menu");
      const _directive_focus_item = resolveDirective("focus-item");
      return withDirectives((openBlock(), createBlock(_component_dropdown_menu, {
        class: "pointer-events-auto sm:flex",
        position: __props.position,
        tooltip: unref(t)("ramp.about"),
        tooltipPlacement: __props.position
      }, {
        header: withCtx(() => [
          createElementVNode("div", _hoisted_1$1k, [
            (openBlock(), createElementBlock("svg", {
              xmlns: "http://www.w3.org/2000/svg",
              viewBox: "0 0 24 24",
              class: "fill-current w-20 h-20",
              "aria-label": unref(t)("ramp.about.open")
            }, _cache[0] || (_cache[0] = [
              createElementVNode("path", { d: "M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z" }, null, -1)
            ]), 8, _hoisted_2$12))
          ])
        ]),
        default: withCtx((scope) => [
          createElementVNode("div", _hoisted_3$I, [
            createElementVNode("div", null, [
              createElementVNode("h4", _hoisted_4$t, toDisplayString(unref(t)("ramp.about")), 1),
              createElementVNode("div", _hoisted_5$l, [
                createVNode(_component_close, {
                  onClick: scope.close
                }, null, 8, ["onClick"])
              ]),
              createElementVNode("div", _hoisted_6$k, [
                createElementVNode("div", null, [
                  createElementVNode("span", _hoisted_7$k, toDisplayString(versionString.value), 1),
                  createElementVNode("span", _hoisted_8$g, " [" + toDisplayString(versionHash.value) + "] ", 1)
                ]),
                createElementVNode("div", null, [
                  createElementVNode("span", _hoisted_9$b, toDisplayString(buildDate.value), 1)
                ]),
                _cache[1] || (_cache[1] = createElementVNode("div", { class: "mt-5" }, [
                  createElementVNode("a", {
                    class: "text-sm underline text-blue-600",
                    href: "https://github.com/ramp4-pcar4/ramp4-pcar4",
                    target: "_blank"
                  }, [
                    createElementVNode("svg", {
                      xmlns: "http://www.w3.org/2000/svg",
                      viewBox: "0 0 24 24",
                      class: "inline-block fill-black w-16 h-16"
                    }, [
                      createElementVNode("path", { d: "M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z" })
                    ]),
                    createTextVNode(" ramp4-pcar4 ")
                  ])
                ], -1))
              ])
            ])
          ])
        ]),
        _: 1
      }, 8, ["position", "tooltip", "tooltipPlacement"])), [
        [_directive_focus_item]
      ]);
    };
  }
});

const AboutRampDropdown = /* @__PURE__ */ _export_sfc(_sfc_main$1z, [["__scopeId", "data-v-dd0345a4"]]);

const _hoisted_1$1j = { class: "map-caption absolute bottom-0 h-29 sm:h-38 flex justify-end pointer-events-auto cursor-default select-none text-gray-200 bg-black-75 left-0 right-0 py-2 sm:py-6" };
const _hoisted_2$11 = {
  key: 0,
  class: "relative top-2 sm:top-1 ml-4 sm:ml-0 shrink-0"
};
const _hoisted_3$H = ["href", "aria-label"];
const _hoisted_4$s = ["src", "alt"];
const _hoisted_5$k = {
  key: 1,
  class: "relative ml-10 top-2 text-sm sm:text-base"
};
const _hoisted_6$j = { class: "flex min-w-fit justify-end" };
const _hoisted_7$j = {
  key: 0,
  class: "pl-8 px-14 sm:block display-none relative top-2"
};
const _hoisted_8$f = ["aria-pressed", "aria-label", "content"];
const _hoisted_9$a = { class: "relative top-1 text-sm sm:text-base" };
const _hoisted_10$9 = { class: "text-gray-200 hover:text-white text-sm sm:text-base pb-5" };
const _hoisted_11$8 = ["onClick"];
const _hoisted_12$7 = {
  key: 0,
  class: "sr-only"
};
const _sfc_main$1y = /* @__PURE__ */ defineComponent({
  __name: "map-caption",
  setup(__props) {
    const mapCaptionStore = useMapCaptionStore();
    const configStore = useConfigStore();
    const { t } = useI18n();
    const iApi = inject("iApi");
    const scale = computed(() => mapCaptionStore.scale);
    const attribution = computed(() => mapCaptionStore.attribution);
    const coords = computed(() => mapCaptionStore.coords);
    const langtoggle = computed(() => mapCaptionStore.langtoggle);
    const mapConfig = computed(() => configStore.config.map);
    const lang = ref([]);
    const watchers = reactive([]);
    watchers.push(
      watch(mapConfig, (newConfig) => {
        if (!newConfig) {
          return;
        }
        iApi.geo.map.caption.createCaption(mapConfig.value?.caption);
      })
    );
    onBeforeUnmount(() => {
      watchers.forEach((unwatch) => unwatch());
    });
    onUpdated(() => {
      nextTick(() => {
        if (iApi.$i18n.locale.value && lang.value.length == 0) {
          lang.value = iApi.$i18n.availableLocales;
        }
      });
    });
    const changeLang = (lang2) => {
      if (iApi.$i18n.locale.value != lang2) {
        iApi.setLanguage(lang2);
      }
    };
    const onScaleClick = () => {
      mapCaptionStore.toggleScale();
      iApi.geo.map.caption.updateScale();
    };
    const changeScaleMessage = (isImperialScale = false) => {
      return isImperialScale ? t("map.toggleScaleToMetric") : t("map.toggleScaleToImperial");
    };
    return (_ctx, _cache) => {
      const _component_dropdown_menu = resolveComponent("dropdown-menu");
      const _directive_truncate = resolveDirective("truncate");
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", _hoisted_1$1j, [
        createVNode(AboutRampDropdown, {
          class: "sm:block display-none ml-8 mr-4",
          position: "top-end"
        }),
        createVNode(NotificationsCaptionButton, { class: "sm:block display-none" }),
        !attribution.value?.logo.disabled ? (openBlock(), createElementBlock("span", _hoisted_2$11, [
          createElementVNode("a", {
            class: "pointer-events-auto cursor-pointer",
            href: attribution.value?.logo.link,
            target: "_blank",
            "aria-label": attribution.value?.logo.altText
          }, [
            createElementVNode("img", {
              class: "object-contain h-18 sm:h-26",
              src: attribution.value?.logo.value,
              alt: attribution.value?.logo.altText
            }, null, 8, _hoisted_4$s)
          ], 8, _hoisted_3$H)
        ])) : createCommentVNode("", true),
        !attribution.value?.text.disabled ? withDirectives((openBlock(), createElementBlock("span", _hoisted_5$k, [
          createTextVNode(toDisplayString(attribution.value?.text.value), 1)
        ])), [
          [_directive_truncate, {
            options: {
              placement: "top",
              hideOnClick: false,
              theme: "ramp4",
              animation: "scale"
            }
          }]
        ]) : createCommentVNode("", true),
        _cache[0] || (_cache[0] = createElementVNode("span", { class: "flex-grow w-15" }, null, -1)),
        createElementVNode("div", _hoisted_6$j, [
          !coords.value?.disabled ? withDirectives((openBlock(), createElementBlock("div", _hoisted_7$j, [
            createTextVNode(toDisplayString(coords.value?.formattedString), 1)
          ])), [
            [_directive_truncate, {
              options: {
                hideOnClick: false,
                theme: "ramp4",
                animation: "scale"
              }
            }]
          ]) : createCommentVNode("", true),
          !scale.value?.disabled ? withDirectives((openBlock(), createElementBlock("button", {
            key: 1,
            type: "button",
            class: "flex-shrink-0 mx-2 sm:mx-10 px-4 pointer-events-auto cursor-pointer border-none",
            onClick: onScaleClick,
            "aria-pressed": scale.value?.isImperialScale,
            "aria-label": `
                    ${scale.value?.label} - ${changeScaleMessage(scale.value?.isImperialScale)}
                `,
            content: changeScaleMessage(scale.value?.isImperialScale)
          }, [
            createElementVNode("span", {
              class: "border-solid border-2 border-white border-t-0 h-5 mr-4 inline-block",
              style: normalizeStyle({ width: scale.value?.width })
            }, null, 4),
            createElementVNode("span", _hoisted_9$a, toDisplayString(scale.value?.label), 1)
          ], 8, _hoisted_8$f)), [
            [_directive_tippy, {
              delay: [300, 0],
              placement: "top",
              hideOnClick: false,
              theme: "ramp4",
              animation: "scale",
              touch: ["hold", 200]
            }]
          ]) : createCommentVNode("", true),
          !langtoggle.value?.disabled ? (openBlock(), createBlock(_component_dropdown_menu, {
            key: 2,
            class: "flex-shrink-0 pointer-events-auto focus:outline-none px-4 mr-4 relative top-2 overflow-hidden",
            position: "top-end",
            tooltip: unref(t)("map.changeLanguage"),
            ariaLabel: `${unref(t)("map.language.short")} - ${unref(t)("map.changeLanguage")}`,
            tooltipPlacement: "top-start",
            tooltipPlacementAlt: "left-end"
          }, {
            header: withCtx(() => [
              createElementVNode("span", _hoisted_10$9, toDisplayString(unref(t)("map.language.short")), 1)
            ]),
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(lang.value, (item, index) => {
                return openBlock(), createElementBlock("a", {
                  key: `${item}-${index}`,
                  class: normalizeClass(["flex-auto items-center text-sm sm:text-base cursor-pointer", { "font-bold": item === unref(iApi).$i18n.locale.value }]),
                  href: "javascript:;",
                  onClick: ($event) => changeLang(item)
                }, [
                  createTextVNode(toDisplayString(unref(t)("map.language." + item)) + " ", 1),
                  item === unref(iApi).$i18n.locale.value ? (openBlock(), createElementBlock("span", _hoisted_12$7, toDisplayString(unref(t)("map.language.curr")), 1)) : createCommentVNode("", true)
                ], 10, _hoisted_11$8);
              }), 128))
            ]),
            _: 1
          }, 8, ["tooltip", "ariaLabel"])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const _hoisted_1$1i = ["content"];
const _hoisted_2$10 = {
  key: 0,
  class: "number absolute -top-2 -right-2 text-white w-18 rounded-full"
};
const _sfc_main$1x = /* @__PURE__ */ defineComponent({
  __name: "floating-button",
  setup(__props) {
    const notificationStore = useNotificationStore();
    const iApi = inject("iApi");
    const { t } = useI18n();
    const number = computed(() => notificationStore.notificationNumber);
    return (_ctx, _cache) => {
      const _directive_tippy = resolveDirective("tippy");
      return withDirectives((openBlock(), createElementBlock("button", {
        type: "button",
        onClick: _cache[0] || (_cache[0] = ($event) => unref(iApi).panel.get("notifications").open()),
        class: "pointer-events-auto items-center absolute left-8 bottom-36 p-6 block sm:display-none bg-black-75 rounded-full text-gray-400 hover:text-white",
        content: unref(t)("notifications.title")
      }, [
        _cache[1] || (_cache[1] = createElementVNode("svg", {
          class: "fill-current w-24 h-24",
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 24 24"
        }, [
          createElementVNode("path", { d: "M12 22c1.1 0 2-.9 2-2h-4c0 1.1.89 2 2 2zm6-6v-5c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2z" })
        ], -1)),
        number.value && number.value > 0 ? (openBlock(), createElementBlock("span", _hoisted_2$10, toDisplayString(number.value), 1)) : createCommentVNode("", true)
      ], 8, _hoisted_1$1i)), [
        [_directive_tippy]
      ]);
    };
  }
});

const NotificationFloatingButton = /* @__PURE__ */ _export_sfc(_sfc_main$1x, [["__scopeId", "data-v-b03e7e33"]]);

const _hoisted_1$1h = { class: "flex items-center mb-20" };
const _hoisted_2$$ = { class: "text-xl" };
const _sfc_main$1w = /* @__PURE__ */ defineComponent({
  __name: "keyboard-instructions",
  setup(__props) {
    const iApi = inject("iApi");
    const { t } = useI18n();
    const open = ref(false);
    const instructionSections = ref(["app", "lists", "map"]);
    const handlers = ref([]);
    const firstEl = ref(null);
    const lastEl = ref(null);
    onMounted(() => {
      handlers.value.push(
        iApi.event.on("openKeyboardInstructions", () => {
          open.value = true;
          nextTick(() => {
            firstEl.value.focus();
          });
        })
      );
    });
    onBeforeUnmount(() => {
      handlers.value.forEach((handler) => iApi?.event.off(handler));
    });
    const onKeydown = (event) => {
      if (event.key === "Tab") {
        if (event.shiftKey && event.target === firstEl.value) {
          event.preventDefault();
          lastEl.value.focus();
        } else if (!event.shiftKey && event.target === lastEl.value) {
          event.preventDefault();
          firstEl.value.focus();
        }
      } else if (event.key === "Escape") {
        event.preventDefault();
        open.value = false;
      }
    };
    return (_ctx, _cache) => {
      const _component_close = resolveComponent("close");
      return open.value ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "absolute inset-0 flex justify-center items-center bg-opacity-30 bg-black z-50 pointer-events-auto",
        onClick: _cache[3] || (_cache[3] = ($event) => open.value = false),
        onKeydown
      }, [
        createElementVNode("div", {
          class: "bg-white w-500 pointer-events-auto shadow-2xl p-20 flex flex-col",
          onClick: _cache[2] || (_cache[2] = withModifiers(() => {
          }, ["stop", "prevent"])),
          tabindex: "0",
          ref_key: "firstEl",
          ref: firstEl
        }, [
          createElementVNode("div", _hoisted_1$1h, [
            createElementVNode("h2", _hoisted_2$$, toDisplayString(unref(t)("keyboardInstructions.title")), 1),
            createVNode(_component_close, {
              class: "ml-auto",
              onClick: _cache[0] || (_cache[0] = ($event) => open.value = false)
            })
          ]),
          (openBlock(true), createElementBlock(Fragment, null, renderList(instructionSections.value, (section) => {
            return openBlock(), createElementBlock("p", {
              class: "whitespace-pre-line pb-10",
              key: section
            }, toDisplayString(unref(t)(`keyboardInstructions.${section}`)), 1);
          }), 128)),
          createElementVNode("button", {
            type: "button",
            class: "mt-auto self-end mr-10 mb-10 px-20 py-10",
            onClick: _cache[1] || (_cache[1] = ($event) => open.value = false),
            ref_key: "lastEl",
            ref: lastEl
          }, toDisplayString(unref(t)("keyboardInstructions.OK")), 513)
        ], 512)
      ], 32)) : createCommentVNode("", true);
    };
  }
});

const useInstanceStore = defineStore("instance", () => {
  const started = ref(false);
  return { started };
});

const _hoisted_1$1g = { class: "h-full relative" };
const _hoisted_2$_ = { class: "inner-shell absolute top-0 left-0 h-full w-full pointer-events-none" };
const _hoisted_3$G = { class: "absolute top-8 w-full flex justify-center" };
const _hoisted_4$r = {
  key: 1,
  class: "w-full h-full"
};
const _sfc_main$1v = /* @__PURE__ */ defineComponent({
  __name: "shell",
  setup(__props) {
    const iApi = inject("iApi");
    const instanceStore = useInstanceStore();
    const fixtureStore = useFixtureStore();
    const panelStore = usePanelStore();
    const { t } = useI18n();
    const appbarFixture = computed(() => fixtureStore.items["appbar"]);
    const openKeyboardInstructions = () => {
      iApi?.event.emit("openKeyboardInstructions");
    };
    const teleported = () => (
      // @ts-ignore
      panelStore.teleported
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1g, [
        createElementVNode("div", _hoisted_2$_, [
          _cache[0] || (_cache[0] = createElementVNode("div", { class: "sr-only screen-reader-alert" }, null, -1)),
          createElementVNode("div", _hoisted_3$G, [
            createElementVNode("button", {
              type: "button",
              class: "bg-white hidden-until-focus z-50 shadow-md px-10",
              onClick: openKeyboardInstructions
            }, toDisplayString(unref(t)("keyboardInstructions.open")), 1)
          ]),
          createVNode(_sfc_main$1w),
          createVNode(PanelStack, { class: "panel-stack sm:flex absolute inset-0 overflow-hidden sm:p-12 z-10 sm:pl-80 xs:pl-40 sm:pb-48 xs:pb-28 xs:pr-0 sm:pr-40" }),
          !appbarFixture.value ? (openBlock(), createBlock(NotificationFloatingButton, { key: 0 })) : createCommentVNode("", true),
          createVNode(_sfc_main$1y, { class: "z-30" })
        ]),
        unref(instanceStore).started ? (openBlock(), createBlock(_sfc_main$1H, { key: 0 })) : (openBlock(), createElementBlock("div", _hoisted_4$r, _cache[1] || (_cache[1] = [
          createElementVNode("div", { class: "spinner relative inset-x-1/2 inset-y-9/20" }, null, -1)
        ]))),
        (openBlock(true), createElementBlock(Fragment, null, renderList(teleported(), (panel) => {
          return openBlock(), createBlock(Teleport, {
            to: panel.teleport?.target,
            key: panel.id
          }, [
            (openBlock(), createBlock(_sfc_main$1G, {
              key: `${panel.id}`,
              panel
            }, null, 8, ["panel"]))
          ], 8, ["to"]);
        }), 128))
      ]);
    };
  }
});

const Shell = /* @__PURE__ */ _export_sfc(_sfc_main$1v, [["__scopeId", "data-v-6c131943"]]);

const _sfc_main$1u = defineComponent({
  name: "App",
  components: { Shell },
  setup() {
    const instance = getCurrentInstance();
    onMounted(() => {
      const ro = new CustomResizeObserver();
      ro.observe(instance?.proxy?.$refs["app-size"]);
      setDefaultProps({
        aria: {
          content: "labelledby"
        },
        theme: "ramp4",
        animation: "scale",
        inertia: true,
        trigger: "mouseenter manual focus",
        touch: ["hold", 200],
        delay: [300, 0],
        appendTo: () => document.fullscreenElement || document.body
      });
    });
  }
});

const _hoisted_1$1f = ["lang"];
const _hoisted_2$Z = {
  class: "h-full",
  ref: "app-size"
};
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_shell = resolveComponent("shell");
  return openBlock(), createElementBlock("div", {
    class: "ramp-app ramp-styles animation-enabled",
    lang: _ctx.$i18n.locale
  }, [
    createElementVNode("div", _hoisted_2$Z, [
      createVNode(_component_shell)
    ], 512)
  ], 8, _hoisted_1$1f);
}
const App = /* @__PURE__ */ _export_sfc(_sfc_main$1u, [["render", _sfc_render$4]]);

const LIST_ATTR$1 = "focus-list";
const ITEM_ATTR$1 = "focus-item";
const ICON_ATTR$1 = "focus-icon";
const CONTAINER_ATTR$1 = "focus-container";
const FOCUS_ATTRS$1 = `[${LIST_ATTR$1}],[${CONTAINER_ATTR$1}]`;
const TRUNCATE_ATTR$1 = "truncate-text";
const SHOW_TRUNCATE = "show-truncate";
const FOCUSED_CLASS = "focused";
const TABBABLE_TAGS$1 = `button,input,select,a,textarea,[contenteditable],[${LIST_ATTR$1}],[${ICON_ATTR$1}],[tabIndex]`;
const FocusList = {
  mounted(el, binding) {
    if (+el.getAttribute("tabindex") <= 0) {
      el.setAttribute("tabindex", "0");
    }
    el.toggleAttribute(LIST_ATTR$1, true);
    new FocusListManager(el, binding.value);
  },
  updated(el) {
    syncTabIndex(el);
  }
};
function syncTabIndex(element) {
  const tabbable = element.querySelectorAll(TABBABLE_TAGS$1);
  tabbable.forEach((el) => {
    if (el.closest(FOCUS_ATTRS$1) === element || el.closest(FOCUS_ATTRS$1) === el && el.parentElement.closest(FOCUS_ATTRS$1) === element) {
      if (!el.closest(`[${LIST_ATTR$1}],.${FOCUSED_CLASS}`).classList.contains(FOCUSED_CLASS)) {
        el.setAttribute("tabindex", "-1");
        return;
      } else {
        el.setAttribute("tabindex", "0");
      }
    }
  });
}
class FocusListManager {
  element;
  highlightedItem;
  isHorizontal;
  isClicked;
  isTapped;
  /**
   * Creates an instance of FocusListManager
   *
   * @param {HTMLElement} element The focus list's element
   * @param {string} attributeValue The value of the `v-focus-list` attribute which tells the focus list manager the orientation of the list. 'horizontal' means the list should be traversed horizontally, and other value will make the list vertical (including no value).
   */
  constructor(element, attributeValue) {
    this.element = element;
    this.highlightedItem = this.element;
    this.isHorizontal = attributeValue === "horizontal";
    this.isClicked = false;
    this.isTapped = false;
    this.setTabIndex(-1);
    this.element.setAttribute("role", "group");
    const focusManager = this;
    element.addEventListener("keydown", function(event) {
      focusManager.onKeydown(event);
    });
    element.addEventListener("focus", function() {
      focusManager.onFocus();
    });
    element.addEventListener("blur", function() {
      focusManager.onBlur();
    });
    element.addEventListener("mousedown", function() {
      focusManager.onMousedown();
    });
    element.addEventListener("touchstart", function() {
      focusManager.onTouchstart();
    });
    document.addEventListener("click", function(event) {
      if (element.contains(event.target)) {
        focusManager.onClick(event);
      } else {
        focusManager.defocusItem(focusManager.highlightedItem);
      }
    });
  }
  /**
   * Sets `tabindex` to `value` for every tabbable thing under `focusItem` (or the list if not specified)
   *
   * @param {Number} value the value to give `tabindex` on each tabbable item
   * @param {Element} focusItem the element containing the tabbable items, defaults to the focus list
   */
  setTabIndex(value, focusItem = this.element) {
    const tabbable = focusItem.querySelectorAll(TABBABLE_TAGS$1);
    tabbable.forEach((el) => {
      if (value === -1 || el.closest(FOCUS_ATTRS$1) === this.element || el.closest(FOCUS_ATTRS$1) === el && el.parentElement.closest(FOCUS_ATTRS$1) === this.element || el.closest(`[${LIST_ATTR$1}],.${FOCUSED_CLASS}`).classList.contains(FOCUSED_CLASS)) {
        el.setAttribute("tabindex", value.toString());
      }
    });
  }
  /**
   * Removes 'focused' to the class list of `item` then updates the tabIndex on subitems (setting them to -1).
   *
   * @param {Element} item The element to defocus
   */
  defocusItem(item) {
    item.classList.remove(FOCUSED_CLASS);
    this.setTabIndex(-1, item);
    if (item._tippy) {
      item._tippy.hide();
    }
    if (item.getAttribute(ITEM_ATTR$1) === SHOW_TRUNCATE) {
      item.querySelector(`[${TRUNCATE_ATTR$1}]`)?._tippy?.hide();
    }
  }
  /**
   * Adds 'focused' to the class list of `item` then updates the tabIndex on subitems (setting them to 0).
   *
   * @param {Element} item The element to focus
   */
  focusItem(item) {
    item.classList.add(FOCUSED_CLASS);
    this.setAriaActiveDescendant(item);
    this.setTabIndex(0, item);
    item.scrollIntoView({ block: "nearest" });
    if (item._tippy && !this.isTapped) {
      item._tippy.show();
    }
    if (item.getAttribute(ITEM_ATTR$1) === SHOW_TRUNCATE) {
      item.querySelector(`[${TRUNCATE_ATTR$1}]`)?._tippy?.show();
    }
    this.isTapped = false;
  }
  /**
   * Updates the list's `aria-activedescendant` to be `item`
   *
   * @param item The element that should be the active descendant
   */
  setAriaActiveDescendant(item) {
    this.element.setAttribute("aria-activedescendant", item.getAttribute("id"));
  }
  /**
   * Moves the highlight through the `listOfItems` forward (or backward) 1 spot
   *
   * @param {HTMLElement[]}listOfItems The list of items being moved through
   * @param {boolean} reverse true iff the highlight should move back one spot
   */
  shiftHighlight(listOfItems, reverse = false) {
    this.defocusItem(this.highlightedItem);
    if (reverse) {
      if (this.highlightedItem === this.element) {
        this.highlightedItem = listOfItems[listOfItems.length - 1];
      } else {
        const index = Array.prototype.indexOf.call(listOfItems, this.highlightedItem);
        this.highlightedItem = listOfItems[index - 1] || listOfItems[listOfItems.length - 1];
      }
    } else {
      if (this.highlightedItem === this.element) {
        this.highlightedItem = listOfItems[0];
      } else {
        const index = Array.prototype.indexOf.call(listOfItems, this.highlightedItem);
        this.highlightedItem = listOfItems[index + 1] || listOfItems[0];
      }
    }
    this.element.focus();
    this.focusItem(this.highlightedItem);
  }
  /**
   * Callback for the keydown event listener on the focus list element
   *
   * @param {KeyboardEvent} event keydown event
   */
  onKeydown(event) {
    const tempFocusManager = this;
    const listOfItems = Array.prototype.filter.call(
      this.element.querySelectorAll(`[${ITEM_ATTR$1}]`),
      (el) => {
        return el.closest(`[${LIST_ATTR$1}]`) === tempFocusManager.element && !!el.offsetParent;
      }
    );
    if (listOfItems.length === 0) {
      return;
    }
    switch (event.key) {
      case "Up" /* ArrowUpIE */:
      case "ArrowUp" /* ArrowUp */:
        if (this.isHorizontal) {
          break;
        }
        event.preventDefault();
        event.stopPropagation();
        this.shiftHighlight(listOfItems, true);
        break;
      case "Down" /* ArrowDownIE */:
      case "ArrowDown" /* ArrowDown */:
        if (this.isHorizontal) {
          break;
        }
        event.preventDefault();
        event.stopPropagation();
        this.shiftHighlight(listOfItems);
        break;
      case "Left" /* ArrowLeftIE */:
      case "ArrowLeft" /* ArrowLeft */:
        if (!this.isHorizontal) {
          break;
        }
        event.preventDefault();
        event.stopPropagation();
        this.shiftHighlight(listOfItems, true);
        break;
      case "Right" /* ArrowRightIE */:
      case "ArrowRight" /* ArrowRight */:
        if (!this.isHorizontal) {
          break;
        }
        event.preventDefault();
        event.stopPropagation();
        this.shiftHighlight(listOfItems);
        break;
      case "Esc" /* EscapeIE */:
      case "Escape" /* Escape */:
        if (this.highlightedItem !== this.element) {
          event.preventDefault();
          event.stopPropagation();
          this.defocusItem(this.highlightedItem);
          this.highlightedItem = this.element;
          this.element.removeAttribute("aria-activedescendant");
          this.element.focus();
        }
        break;
      case "Enter" /* Enter */:
      case " " /* Space */:
        if (event.target === this.element && this.highlightedItem !== this.element) {
          event.preventDefault();
          event.stopPropagation();
          this.highlightedItem.click();
        }
        break;
      case "Tab" /* Tab */:
        if (this.highlightedItem !== this.element) {
          if (this.highlightedItem.querySelectorAll(TABBABLE_TAGS$1).length === 0) {
            this.defocusItem(this.highlightedItem);
          }
          if (event.shiftKey) {
            event.preventDefault();
            event.stopPropagation();
            this.defocusItem(this.highlightedItem);
            this.highlightedItem = this.element;
            this.element.removeAttribute("aria-activedescendant");
            this.element.focus();
          }
        }
    }
  }
  /**
   * Callback for the click event listener on the focus list element
   *
   * @param {MouseEvent} event click event
   */
  onClick(event) {
    this.defocusItem(this.highlightedItem);
    let targetElement = event.target;
    if (!targetElement.hasAttribute(LIST_ATTR$1)) {
      while (targetElement.parentElement.closest(`[${LIST_ATTR$1}]`) !== this.element) {
        targetElement = targetElement.parentElement.closest(`[${LIST_ATTR$1}]`);
      }
    }
    this.highlightedItem = targetElement.closest(`[${ITEM_ATTR$1}]`) || targetElement.closest(`[${LIST_ATTR$1}]`) || this.highlightedItem;
    if (targetElement.hasAttribute(`${ITEM_ATTR$1}`)) {
      this.element.focus();
    }
    if (this.highlightedItem !== this.element) {
      this.focusItem(this.highlightedItem);
    } else {
      this.element.removeAttribute("aria-activedescendant");
    }
  }
  /**
   * Callback for the focus event listener on the focus list element.
   * NOTE: this is only called when the LIST ELEMENT is focused, not any descendant
   *
   * This is used to pull back the `focusedItem` id and the aria-activedescendant attribute when a list is focused
   */
  onFocus() {
    if (this.highlightedItem && !this.isClicked) {
      if (this.highlightedItem._tippy) {
        this.highlightedItem._tippy.show();
      }
      if (this.highlightedItem.getAttribute(ITEM_ATTR$1) === SHOW_TRUNCATE) {
        this.highlightedItem.querySelector(`[${TRUNCATE_ATTR$1}]`)?._tippy?.show();
      }
    }
    this.isClicked = false;
    if (!(this.element.hasAttribute("aria-activedescendant") || this.highlightedItem === this.element)) {
      this.setAriaActiveDescendant(this.highlightedItem);
    } else if (this.highlightedItem !== this.element) {
      this.focusItem(this.highlightedItem);
    }
    syncTabIndex(this.element);
    if (this.highlightedItem && this.highlightedItem !== this.element) {
      this.highlightedItem.setAttribute("tabindex", "-1");
    }
  }
  /**
   * Callback for the BLUR event listener on the focus list element.
   * NOTE: this is only called when the list element stops being focused, not a descendant
   */
  onBlur() {
    if (this.highlightedItem) {
      if (this.highlightedItem._tippy) {
        this.highlightedItem._tippy.hide();
      }
      if (this.highlightedItem.getAttribute(ITEM_ATTR$1) === SHOW_TRUNCATE) {
        this.highlightedItem.querySelector(`[${TRUNCATE_ATTR$1}]`)?._tippy?.hide();
      }
    }
  }
  /**
   * Callback for the MOUSEDOWN event listener on the focus list element.
   */
  onMousedown() {
    this.isClicked = true;
  }
  /**
   * Callback for the TOUCHSTART event listener on the focus list element.
   */
  onTouchstart() {
    this.isTapped = true;
  }
}

const ITEM_ATTR = "focus-item";
const FocusItem = {
  beforeMount(el, binding) {
    if (!el.hasAttribute("id")) {
      el.setAttribute("id", generateID());
    }
    if (binding.value) {
      el.setAttribute(ITEM_ATTR, binding.value);
    } else {
      el.toggleAttribute(ITEM_ATTR, true);
    }
  }
};
function generateID() {
  let newID;
  do {
    newID = "focus-item-" + Math.random().toString(36).substring(2, 9);
  } while (document.getElementById(newID) !== null);
  return newID;
}

const CONTAINER_ATTR = "focus-container";
const LIST_ATTR = "focus-list";
const ICON_ATTR = "focus-icon";
const FOCUS_ATTRS = `[${LIST_ATTR}],[${CONTAINER_ATTR}]`;
const TABBABLE_TAGS = `button,input,select,a,textarea,[contenteditable],.ag-tab-guard,[${LIST_ATTR}],[${CONTAINER_ATTR}],[${ICON_ATTR}],[tabIndex]`;
let managers = [];
const FocusContainer = {
  mounted(el) {
    const rampShells = [...document.querySelectorAll(".inner-shell")];
    if (rampShells.some((shell) => shell.contains(el))) {
      managers.push(new FocusContainerManager(el));
    }
  },
  beforeUnmount(el) {
    managers = managers.filter((manager) => {
      if (manager.element === el) {
        manager.removeEventListeners();
        return false;
      }
      return true;
    });
  }
};
class FocusContainerManager {
  element;
  /**
   * Creates an instance of FocusContainerManager
   *
   * @param element The HTMLElement the directive was placed on
   * @param options The options provided to the directive
   */
  constructor(element) {
    this.element = element;
    this.element.toggleAttribute(CONTAINER_ATTR, true);
    this.element.tabIndex = 0;
    this.disableTabbing();
    const focusManager = this;
    this.element.addEventListener("keypress", function(event) {
      focusManager.onKeypress(event);
    });
    this.element.addEventListener("click", function() {
      focusManager.onClick();
    });
    this.element.addEventListener("focusout", function(event) {
      focusManager.onFocusOut(event);
    });
    this.element.addEventListener("focus", function() {
      focusManager.onFocus();
    });
  }
  /**
   * Removes all of the event listeners on the container element.
   */
  removeEventListeners() {
    const focusManager = this;
    this.element.removeEventListener("keypress", function(event) {
      focusManager.onKeypress(event);
    });
    this.element.removeEventListener("click", function() {
      focusManager.onClick();
    });
    this.element.removeEventListener("focusout", function(event) {
      focusManager.onFocusOut(event);
    });
    this.element.removeEventListener("focus", function() {
      focusManager.onFocus();
    });
  }
  /**
   * Callback for the `keypress` event on the container element
   *
   * @param event The keyboard event
   */
  onKeypress(event) {
    if (event.target !== this.element) {
      return;
    }
    if (event.key === "Enter" /* Enter */ || event.key === " " /* Space */) {
      this.enableTabbing().focus();
    }
  }
  /**
   * Callback for the `click` event on the container element
   */
  onClick() {
    this.enableTabbing();
  }
  /**
   * Callback for the `focusout` event on the container element
   *
   * @param event The focus event
   */
  onFocusOut(event) {
    if (!this.element.contains(event.relatedTarget)) {
      this.disableTabbing();
    }
  }
  /**
   * Callback for the `focus` event on the container element
   */
  onFocus() {
    this.disableTabbing();
  }
  /**
   * Sets tabindex to -1 for EVERY element under the container element
   */
  disableTabbing() {
    const tab_list = Array.prototype.filter.call(this.element.querySelectorAll(TABBABLE_TAGS), () => {
      return true;
    });
    tab_list.forEach((el) => {
      el.tabIndex = -1;
    });
  }
  /**
   * Sets tabindex to 0 for every VISIBLE element not under a different focus container or list.
   * @return {HTMLElement} the first valid element
   */
  enableTabbing() {
    let first_tabbable_item = void 0;
    Array.prototype.map.call(this.element.querySelectorAll(TABBABLE_TAGS), (el) => {
      if ((el.closest(FOCUS_ATTRS) === this.element || el.closest(FOCUS_ATTRS) === el && el.parentElement.closest(FOCUS_ATTRS) === this.element) && !!el.offsetParent) {
        el.tabIndex = 0;
        if (first_tabbable_item === void 0) {
          first_tabbable_item = el;
        }
      }
    });
    return first_tabbable_item;
  }
}

const TRUNCATE_ATTR = "truncate-text";
const TRIGGER_ATTR = "truncate-trigger";
const Truncate = {
  beforeMount(el, binding) {
    if (!el.classList.contains("truncate") && !binding.value?.noTruncateClass) {
      el.classList.add("truncate");
    }
    el.toggleAttribute(TRUNCATE_ATTR, true);
  },
  mounted(el, binding) {
    let triggerElement;
    if (binding.value && binding.value.externalTrigger) {
      triggerElement = el.closest(`[${TRIGGER_ATTR}]`);
    }
    useTippy(el, {
      content: linkifyContent(el.textContent),
      onShow,
      allowHTML: true,
      placement: "bottom-start",
      maxWidth: 320,
      //flip: false, // can't find a replacement for Vue3
      //boundary: 'window',
      triggerTarget: triggerElement,
      ...binding.value?.options || {}
    });
  },
  updated(el, binding) {
    if (el._tippy) {
      el._tippy.setContent(linkifyContent(el.textContent));
      if (binding.value && binding.value.options) {
        el._tippy.setProps(binding.value.options);
      }
    }
  },
  unmounted(el) {
    if (el._tippy) {
      el._tippy.destroy();
    }
  }
};
function onShow(instance) {
  const isTruncated = instance.reference.clientWidth < instance.reference.scrollWidth || instance.reference.clientHeight < instance.reference.scrollHeight;
  if (!isTruncated) {
    return false;
  }
}
function linkifyContent(content) {
  if (content === null) {
    return "";
  }
  let res = linkifyHtml(content, {
    target: "_blank",
    validate: {
      url: (value) => /^https?:\/\//.test(value)
      // only links that begin with a protocol will be hyperlinked
    }
  });
  res = `<div style='word-break: break-word;'>${res}</div>`;
  return res;
}

const _hoisted_1$1e = ["content"];
const _hoisted_2$Y = {
  key: 0,
  class: "flex flex-shrink-0 items-center border-b border-solid border-gray-600 px-8 h-48 overflow-hidden"
};
const _hoisted_3$F = {
  class: "flex-grow text-lg py-16 pl-8 min-w-0",
  tabIndex: "0"
};
const _hoisted_4$q = { key: 1 };
const _hoisted_5$j = {
  key: 0,
  class: "flex"
};
const _hoisted_6$i = {
  key: 1,
  class: "p-8 flex-grow overflow-y-auto"
};
const _hoisted_7$i = ["innerHTML"];
const _hoisted_8$e = {
  key: 2,
  class: "px-8 py-16 border-t border-gray-400 default-focus-style"
};
const _sfc_main$1t = /* @__PURE__ */ defineComponent({
  __name: "panel-screen",
  props: {
    // prop indicating if the `header` slot should be rendered
    header: {
      type: Boolean,
      default: true
    },
    // prop indicating if the `content` slot should be rendered
    content: {
      type: Boolean,
      default: true
    },
    // prop indicating if the `footer` slot should be rendered
    footer: {
      type: Boolean,
      default: false
    },
    panel: {
      type: Object,
      required: true
    },
    screenId: {
      type: String,
      required: false
    }
  },
  setup(__props) {
    const { t } = useI18n();
    const panelStore = usePanelStore();
    const appbarStore = useAppbarStore();
    const iApi = inject("iApi");
    const el = ref();
    const props = __props;
    const temporary = computed(() => iApi?.fixture.get("appbar") ? appbarStore.temporary : []);
    const mobileView = computed(() => panelStore.mobileView);
    const reorderable = computed(() => panelStore.reorderable);
    const checkMode = () => !mobileView.value && !props.panel.teleport;
    const move = (direction) => {
      props.panel.move(direction);
      if (direction === "left") {
        nextTick(() => {
          (el.value?.querySelector(".move-left")).focus();
        });
      }
    };
    const screenContent = computed(() => {
      return props.screenId ? props.panel.screens[props.screenId][iApi?.$i18n.locale.value ?? "en"] : null;
    });
    onMounted(() => {
      el.value?.addEventListener("blur", () => {
        el.value._tippy.hide();
      });
      el.value?.addEventListener("keyup", (e) => {
        if (e.key === "Tab" && el.value?.matches(":focus")) {
          el.value._tippy.show();
        }
      });
    });
    onBeforeUnmount(() => {
      el.value?.removeEventListener("blur", () => {
        el.value._tippy.hide();
      });
      el.value?.removeEventListener("keyup", (e) => {
        if (e.key === "Tab" && el.value?.matches(":focus")) {
          el.value._tippy.show();
        }
      });
    });
    return (_ctx, _cache) => {
      const _component_back = resolveComponent("back");
      const _component_panel_options_menu = resolveComponent("panel-options-menu");
      const _component_left = resolveComponent("left");
      const _component_right = resolveComponent("right");
      const _component_pin = resolveComponent("pin");
      const _component_expand = resolveComponent("expand");
      const _component_minimize = resolveComponent("minimize");
      const _component_close = resolveComponent("close");
      const _directive_truncate = resolveDirective("truncate");
      const _directive_focus_item = resolveDirective("focus-item");
      const _directive_tippy = resolveDirective("tippy");
      return withDirectives((openBlock(), createElementBlock("div", {
        class: "h-full flex flex-col items-stretch",
        content: `<div style='word-break: break-word;'>${unref(t)(__props.panel.alertName) + ". " + unref(t)("panels.access")}</div>`,
        ref_key: "el",
        ref: el
      }, [
        __props.header ? (openBlock(), createElementBlock("header", _hoisted_2$Y, [
          createVNode(_component_back, {
            class: normalizeClass(!!__props.panel.teleport ? "display-none" : "block sm:display-none"),
            onClick: _cache[0] || (_cache[0] = ($event) => __props.panel.close())
          }, null, 8, ["class"]),
          withDirectives((openBlock(), createElementBlock("h2", _hoisted_3$F, [
            _ctx.$slots.header ? renderSlot(_ctx.$slots, "header", { key: 0 }) : (openBlock(), createElementBlock("div", _hoisted_4$q, toDisplayString(unref(t)(__props.panel.alertName)), 1))
          ])), [
            [_directive_truncate]
          ]),
          !!_ctx.$slots.controls ? (openBlock(), createBlock(_component_panel_options_menu, { key: 0 }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "controls")
            ]),
            _: 3
          })) : createCommentVNode("", true),
          createElementVNode("div", {
            class: normalizeClass(!!__props.panel.teleport ? "flex" : "display-none sm:flex")
          }, [
            !__props.panel.teleport ? (openBlock(), createElementBlock("div", _hoisted_5$j, [
              reorderable.value ? (openBlock(), createBlock(_component_left, {
                key: 0,
                onClick: _cache[1] || (_cache[1] = ($event) => move("left")),
                active: !__props.panel.isLeftMostPanel
              }, null, 8, ["active"])) : createCommentVNode("", true),
              reorderable.value ? (openBlock(), createBlock(_component_right, {
                key: 1,
                onClick: _cache[2] || (_cache[2] = ($event) => move("right")),
                active: !__props.panel.isRightMostPanel
              }, null, 8, ["active"])) : createCommentVNode("", true),
              createVNode(_component_pin, {
                onClick: _cache[3] || (_cache[3] = ($event) => __props.panel.pin()),
                active: __props.panel.isPinned
              }, null, 8, ["active"]),
              __props.panel.controls && __props.panel.controls.expand ? (openBlock(), createBlock(_component_expand, {
                key: 2,
                onClick: _cache[4] || (_cache[4] = ($event) => __props.panel.expand()),
                active: __props.panel.expanded
              }, null, 8, ["active"])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true),
            __props.panel.button && temporary.value?.includes(__props.panel.id) ? (openBlock(), createBlock(_component_minimize, {
              key: 1,
              onClick: _cache[5] || (_cache[5] = ($event) => __props.panel.minimize())
            })) : createCommentVNode("", true),
            createVNode(_component_close, {
              onClick: _cache[6] || (_cache[6] = ($event) => __props.panel.close())
            })
          ], 2)
        ])) : createCommentVNode("", true),
        __props.content ? (openBlock(), createElementBlock("div", _hoisted_6$i, [
          _ctx.$slots.content ? renderSlot(_ctx.$slots, "content", { key: 0 }) : screenContent.value ? (openBlock(), createElementBlock("div", {
            key: 1,
            innerHTML: screenContent.value.innerHTML
          }, null, 8, _hoisted_7$i)) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        __props.footer ? withDirectives((openBlock(), createElementBlock("div", _hoisted_8$e, [
          renderSlot(_ctx.$slots, "footer")
        ])), [
          [_directive_focus_item]
        ]) : createCommentVNode("", true)
      ], 8, _hoisted_1$1e)), [
        [_directive_tippy, {
          trigger: "manual",
          onShow: checkMode,
          allowHTML: true,
          maxWidth: __props.panel.style["flex-basis"] ?? 350,
          popperOptions: {
            placement: "top",
            modifiers: [
              { name: "preventOverflow", options: { altAxis: true } },
              { name: "flip", options: { fallbackPlacements: ["top"] } }
            ]
          }
        }]
      ]);
    };
  }
});

const _hoisted_1$1d = { class: "relative" };
const _hoisted_2$X = ["content", "aria-label"];
const _hoisted_3$E = ["transform"];
const _sfc_main$1s = /* @__PURE__ */ defineComponent({
  __name: "pin",
  props: {
    active: Boolean
  },
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", _hoisted_1$1d, [
        withDirectives((openBlock(), createElementBlock("button", {
          type: "button",
          class: normalizeClass(["text-gray-500 hover:text-black focus:text-black p-8", { "text-gray-700": __props.active }]),
          content: unref(t)(__props.active ? "panels.controls.unpin" : "panels.controls.pin"),
          "aria-label": unref(t)(__props.active ? "panels.controls.unpin" : "panels.controls.pin")
        }, [
          (openBlock(), createElementBlock("svg", {
            class: "fill-current w-16 h-16",
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 384 512",
            transform: `rotate(${__props.active ? 30 : 0})`
          }, _cache[0] || (_cache[0] = [
            createElementVNode("path", { d: "M298.028 214.267L285.793 96H328c13.255 0 24-10.745 24-24V24c0-13.255-10.745-24-24-24H56C42.745 0 32 10.745 32 24v48c0 13.255 10.745 24 24 24h42.207L85.972 214.267C37.465 236.82 0 277.261 0 328c0 13.255 10.745 24 24 24h136v104.007c0 1.242.289 2.467.845 3.578l24 48c2.941 5.882 11.364 5.893 14.311 0l24-48a8.008 8.008 0 0 0 .845-3.578V352h136c13.255 0 24-10.745 24-24-.001-51.183-37.983-91.42-85.973-113.733z" }, null, -1)
          ]), 8, _hoisted_3$E))
        ], 10, _hoisted_2$X)), [
          [_directive_tippy, { placement: "bottom", hideOnClick: false }]
        ])
      ]);
    };
  }
});

const _hoisted_1$1c = { class: "relative" };
const _hoisted_2$W = ["content", "aria-label"];
const _sfc_main$1r = /* @__PURE__ */ defineComponent({
  __name: "close",
  props: {
    active: Boolean
  },
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", _hoisted_1$1c, [
        withDirectives((openBlock(), createElementBlock("button", {
          type: "button",
          class: normalizeClass(["text-gray-500 hover:text-black focus:text-black p-8", { "text-gray-700": __props.active }]),
          content: unref(t)("panels.controls.close"),
          "aria-label": unref(t)("panels.controls.close")
        }, _cache[0] || (_cache[0] = [
          createElementVNode("svg", {
            class: "fill-current w-16 h-16",
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 352 512"
          }, [
            createElementVNode("path", { d: "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z" })
          ], -1)
        ]), 10, _hoisted_2$W)), [
          [_directive_tippy, {
            placement: "bottom",
            theme: "ramp4",
            animation: "scale"
          }]
        ])
      ]);
    };
  }
});

const _hoisted_1$1b = { class: "relative" };
const _hoisted_2$V = ["content", "aria-label"];
const _sfc_main$1q = /* @__PURE__ */ defineComponent({
  __name: "back",
  props: {
    active: Boolean
  },
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", _hoisted_1$1b, [
        withDirectives((openBlock(), createElementBlock("button", {
          type: "button",
          class: normalizeClass(["text-gray-500 hover:text-black focus:text-black p-8", { "text-gray-700": __props.active }]),
          content: unref(t)("panels.controls.back"),
          "aria-label": unref(t)("panels.controls.back")
        }, _cache[0] || (_cache[0] = [
          createElementVNode("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            class: "fill-current w-16 h-16",
            viewBox: "0 0 16 16"
          }, [
            createElementVNode("path", {
              d: "M20.485784919653916,7.578491965389372h-14.170000000000005l3.5800000000000054,-3.589999999999997l-1.409999999999993,-1.4099999999999984l-6.000000000000008,6.0000000000000275l6.000000000000008,6l1.409999999999993,-1.4100000000000001l-3.58,-3.59h14.170000000000007Z",
              transform: "matrix(0.865803 0 0 0.865803 -1.99071 0.638058)"
            })
          ], -1)
        ]), 10, _hoisted_2$V)), [
          [_directive_tippy, {
            placement: "bottom",
            theme: "ramp4",
            animation: "scale"
          }]
        ])
      ]);
    };
  }
});

const _hoisted_1$1a = { class: "w-32 h-32" };
const _hoisted_2$U = ["content"];
const _hoisted_3$D = {
  key: 0,
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  class: "h-24 w-24 fill-current transform rotate-90"
};
const _hoisted_4$p = {
  key: 1,
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  class: "h-24 w-24 fill-current transform rotate-90"
};
const _sfc_main$1p = /* @__PURE__ */ defineComponent({
  __name: "expand",
  props: {
    active: Boolean
  },
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", _hoisted_1$1a, [
        withDirectives((openBlock(), createElementBlock("button", {
          type: "button",
          class: "text-gray-500 hover:text-black focus:text-black w-full h-full flex justify-center items-center",
          content: unref(t)(`panels.controls.${__props.active ? "collapse" : "expand"}`)
        }, [
          !__props.active ? (openBlock(), createElementBlock("svg", _hoisted_3$D, _cache[0] || (_cache[0] = [
            createElementVNode("path", {
              d: "M0 0h24v24H0z",
              fill: "none"
            }, null, -1),
            createElementVNode("path", {
              d: "M0 0h24v24H0V0z",
              fill: "none"
            }, null, -1),
            createElementVNode("path", { d: "M4 20h16v2H4zM4 2h16v2H4zm9 7h3l-4-4-4 4h3v6H8l4 4 4-4h-3z" }, null, -1)
          ]))) : (openBlock(), createElementBlock("svg", _hoisted_4$p, _cache[1] || (_cache[1] = [
            createElementVNode("path", {
              d: "M0 0h24v24H0z",
              fill: "none"
            }, null, -1),
            createElementVNode("path", {
              d: "M0 0h24v24H0V0z",
              fill: "none"
            }, null, -1),
            createElementVNode("path", { d: "M8 19h3v3h2v-3h3l-4-4-4 4zm8-15h-3V1h-2v3H8l4 4 4-4zM4 9v2h16V9H4z" }, null, -1),
            createElementVNode("path", { d: "M4 12h16v2H4z" }, null, -1)
          ])))
        ], 8, _hoisted_2$U)), [
          [_directive_tippy, {
            placement: "bottom",
            theme: "ramp4",
            animation: "scale",
            hideOnClick: false
          }]
        ])
      ]);
    };
  }
});

const _hoisted_1$19 = { class: "relative" };
const _hoisted_2$T = ["content", "aria-label"];
const _sfc_main$1o = /* @__PURE__ */ defineComponent({
  __name: "minimize",
  props: {
    active: Boolean
  },
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", _hoisted_1$19, [
        withDirectives((openBlock(), createElementBlock("button", {
          type: "button",
          class: normalizeClass(["text-gray-500 hover:text-black focus:text-black p-6", { "text-gray-700": __props.active }]),
          content: unref(t)("panels.controls.minimize"),
          "aria-label": unref(t)("panels.controls.minimize")
        }, _cache[0] || (_cache[0] = [
          createElementVNode("svg", {
            class: "fill-current w-20 h-20",
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24"
          }, [
            createElementVNode("path", {
              d: "M0 0h24v24H0V0z",
              fill: "none"
            }),
            createElementVNode("path", { d: "M6 19h12v2H6z" })
          ], -1)
        ]), 10, _hoisted_2$T)), [
          [_directive_tippy, {
            placement: "bottom",
            theme: "ramp4",
            animation: "scale"
          }]
        ])
      ]);
    };
  }
});

const _hoisted_1$18 = { class: "relative" };
const _hoisted_2$S = ["content", "aria-label"];
const _sfc_main$1n = /* @__PURE__ */ defineComponent({
  __name: "right",
  props: {
    active: Boolean
  },
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", _hoisted_1$18, [
        withDirectives((openBlock(), createElementBlock("button", {
          type: "button",
          class: normalizeClass(["p-8", {
            "text-gray-500 hover:text-black focus:text-black": __props.active,
            "text-gray-300": !__props.active
          }]),
          content: unref(t)("panels.controls.moveRight"),
          "aria-label": unref(t)("panels.controls.moveRight")
        }, _cache[0] || (_cache[0] = [
          createElementVNode("svg", {
            class: "fill-current w-16 h-16",
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "4 4 16 16"
          }, [
            createElementVNode("path", { d: "M 8.59 16.34 L 13.17 11.75 L 8.59 7.16 L 10 5.75 L 16 11.75 L 10 17.75 Z" })
          ], -1)
        ]), 10, _hoisted_2$S)), [
          [_directive_tippy, {
            placement: "bottom",
            theme: "ramp4",
            animation: "scale"
          }]
        ])
      ]);
    };
  }
});

const _hoisted_1$17 = { class: "relative" };
const _hoisted_2$R = ["content", "aria-label"];
const _sfc_main$1m = /* @__PURE__ */ defineComponent({
  __name: "left",
  props: {
    active: Boolean
  },
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", _hoisted_1$17, [
        withDirectives((openBlock(), createElementBlock("button", {
          type: "button",
          class: normalizeClass(["p-8 move-left", {
            "text-gray-500 hover:text-black focus:text-black": __props.active,
            "text-gray-300": !__props.active
          }]),
          content: unref(t)("panels.controls.moveLeft"),
          "aria-label": unref(t)("panels.controls.moveLeft")
        }, _cache[0] || (_cache[0] = [
          createElementVNode("svg", {
            class: "fill-current w-16 h-16",
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "4 4 16 16"
          }, [
            createElementVNode("path", { d: "M 15.41 16.09 L 10.83 11.5 L 15.41 6.91 L 14 5.5 L 8 11.5 L 14 17.5 Z" })
          ], -1)
        ]), 10, _hoisted_2$R)), [
          [_directive_tippy, {
            placement: "bottom",
            theme: "ramp4",
            animation: "scale"
          }]
        ])
      ]);
    };
  }
});

const _sfc_main$1l = /* @__PURE__ */ defineComponent({
  __name: "panel-options-menu",
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$1E, {
        class: "flex",
        tooltip: unref(t)("panels.controls.optionsMenu"),
        popperOptions: { strategy: "fixed" },
        position: "bottom-end"
      }, {
        header: withCtx(() => _cache[0] || (_cache[0] = [
          createElementVNode("div", { class: "p-6" }, [
            createElementVNode("svg", {
              xmlns: "http://www.w3.org/2000/svg",
              viewBox: "0 0 24 24",
              class: "fill-current w-20 h-20"
            }, [
              createElementVNode("path", { d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" })
            ])
          ], -1)
        ])),
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ]),
        _: 3
      }, 8, ["tooltip"]);
    };
  }
});

const PanelOptionsMenuV = /* @__PURE__ */ _export_sfc(_sfc_main$1l, [["__scopeId", "data-v-51e22a4a"]]);

const _hoisted_1$16 = {
  key: 0,
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  class: "fill-current w-32 h-20"
};
const _hoisted_2$Q = {
  key: 1,
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  class: "fill-current w-32 h-20"
};
const _sfc_main$1k = /* @__PURE__ */ defineComponent({
  __name: "fullscreen-nav",
  setup(__props) {
    const { t } = useI18n();
    const iApi = inject("iApi");
    const onClick = () => {
      iApi.toggleFullscreen();
    };
    return (_ctx, _cache) => {
      const _component_mapnav_button = resolveComponent("mapnav-button");
      return openBlock(), createBlock(_component_mapnav_button, {
        onClickFunction: onClick,
        tooltip: unref(t)("mapnav.fullscreen")
      }, {
        default: withCtx(() => [
          unref(iApi).isFullscreen ? (openBlock(), createElementBlock("svg", _hoisted_1$16, _cache[0] || (_cache[0] = [
            createElementVNode("path", {
              d: "M0 0h24v24H0z",
              fill: "none"
            }, null, -1),
            createElementVNode("path", { d: "M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z" }, null, -1)
          ]))) : (openBlock(), createElementBlock("svg", _hoisted_2$Q, _cache[1] || (_cache[1] = [
            createElementVNode("path", {
              d: "M0 0h24v24H0z",
              fill: "none"
            }, null, -1),
            createElementVNode("path", { d: "M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z" }, null, -1)
          ])))
        ]),
        _: 1
      }, 8, ["tooltip"]);
    };
  }
});

const _sfc_main$1j = /* @__PURE__ */ defineComponent({
  __name: "geolocator-nav",
  setup(__props) {
    const { t } = useI18n();
    const iApi = inject("iApi");
    let geolocation = reactive([]);
    const geolocate = async () => {
      if (!geolocation.length) {
        const position = await browserLocate({
          maximumAge: Infinity,
          timeout: 5e3
        }).catch((error) => {
          if (error.code === GeolocationPositionError.PERMISSION_DENIED) {
            iApi.notify.show(NotificationType.ERROR, t("mapnav.geolocator.error.permission"));
          } else {
            iApi.notify.show(NotificationType.ERROR, t("mapnav.geolocator.error.internal"));
          }
        });
        if (position) {
          geolocation = [position.coords.longitude, position.coords.latitude];
          zoomIn(geolocation);
        }
      } else {
        zoomIn(geolocation);
      }
    };
    const zoomIn = (coords) => {
      let zoomTarget = new Point("geolocation", coords, SpatialReference.latLongSR(), true);
      iApi.geo.map.zoomMapTo(zoomTarget);
    };
    const browserLocate = (options) => {
      return new Promise((resolve, reject) => navigator.geolocation.getCurrentPosition(resolve, reject, options));
    };
    return (_ctx, _cache) => {
      const _component_mapnav_button = resolveComponent("mapnav-button");
      return openBlock(), createBlock(_component_mapnav_button, {
        onClickFunction: geolocate,
        tooltip: unref(t)("mapnav.geolocator")
      }, {
        default: withCtx(() => _cache[0] || (_cache[0] = [
          createElementVNode("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24",
            class: "fill-current w-32 h-20"
          }, [
            createElementVNode("path", { d: "M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm8.94 3c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z" })
          ], -1)
        ])),
        _: 1
      }, 8, ["tooltip"]);
    };
  }
});

const _sfc_main$1i = /* @__PURE__ */ defineComponent({
  __name: "home-nav",
  setup(__props) {
    const { t } = useI18n();
    const iApi = inject("iApi");
    const goToHome = () => {
      const extentSet = iApi.geo.map.getExtentSet();
      iApi.geo.map.zoomMapTo(extentSet.fullExtent);
    };
    return (_ctx, _cache) => {
      const _component_mapnav_button = resolveComponent("mapnav-button");
      return openBlock(), createBlock(_component_mapnav_button, {
        onClickFunction: goToHome,
        tooltip: unref(t)("mapnav.home")
      }, {
        default: withCtx(() => _cache[0] || (_cache[0] = [
          createElementVNode("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24",
            class: "fill-current w-32 h-20"
          }, [
            createElementVNode("path", { d: "M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" }),
            createElementVNode("path", {
              d: "M0 0h24v24H0z",
              fill: "none"
            })
          ], -1)
        ])),
        _: 1
      }, 8, ["tooltip"]);
    };
  }
});

const _hoisted_1$15 = {
  class: "relative w-32 h-32 text-gray-600 hover:text-black",
  tabindex: "-1"
};
const _hoisted_2$P = ["content", "aria-label"];
const _sfc_main$1h = /* @__PURE__ */ defineComponent({
  __name: "button",
  props: {
    onClickFunction: {
      type: Function,
      required: true
    },
    tooltip: {
      type: [String, Boolean],
      default: false
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      const _directive_focus_item = resolveDirective("focus-item");
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", _hoisted_1$15, [
        withDirectives((openBlock(), createElementBlock("button", {
          type: "button",
          class: "w-full h-full default-focus-style focus:outline-none",
          onClick: _cache[0] || (_cache[0] = ($event) => __props.onClickFunction()),
          content: __props.tooltip,
          "aria-label": typeof __props.tooltip === "string" ? __props.tooltip : ""
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 8, _hoisted_2$P)), [
          [_directive_focus_item],
          [_directive_tippy, { placement: "left" }]
        ])
      ]);
    };
  }
});

const _hoisted_1$14 = {
  class: "relative",
  tabindex: "-1"
};
const _hoisted_2$O = ["aria-label", "content"];
const _sfc_main$1g = /* @__PURE__ */ defineComponent({
  __name: "button",
  props: {
    onClickFunction: {
      type: Function,
      required: true
    },
    id: {
      type: String,
      required: true
    },
    tooltip: {
      type: [String, Boolean],
      default: false
    }
  },
  setup(__props) {
    const iApi = inject("iApi");
    const props = __props;
    const onClick = () => iApi?.event.emit(GlobalEvents.APPBAR_BUTTON_CLICK, props.id);
    return (_ctx, _cache) => {
      const _directive_focus_item = resolveDirective("focus-item");
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", _hoisted_1$14, [
        withDirectives((openBlock(), createElementBlock("button", {
          type: "button",
          class: "py-6 w-full h-full",
          onClick: _cache[0] || (_cache[0] = () => {
            __props.onClickFunction();
            onClick();
          }),
          "aria-label": String(__props.tooltip),
          content: `<div style='word-break: break-word;'>${__props.tooltip}</div>`
        }, [
          renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ], 8, _hoisted_2$O)), [
          [_directive_focus_item],
          [_directive_tippy, {
            allowHTML: true,
            placement: "right"
          }]
        ])
      ]);
    };
  }
});

const AppbarButtonV = /* @__PURE__ */ _export_sfc(_sfc_main$1g, [["__scopeId", "data-v-457cd2d4"]]);

const useAreasOfInterestStore = defineStore("areas-of-interest", () => {
  const areas = ref([]);
  return { areas };
});

const useExportStore = defineStore("export", () => {
  const componentSelectedState = ref({
    title: true,
    map: true,
    mapElements: true,
    legend: true,
    footnote: true,
    timestamp: true
  });
  const fileName = ref("");
  function toggleSelected(value) {
    if (componentSelectedState.value[value.name] !== void 0) {
      const currValue = componentSelectedState.value[value.name];
      componentSelectedState.value[value.name] = value.selected !== void 0 ? value.selected : !currValue;
    }
  }
  return { componentSelectedState, fileName, toggleSelected };
});

const useExtentguardStore = defineStore("extentguard", () => {
  const active = ref(false);
  function setActive(value) {
    active.value = value;
  }
  const enforcing = ref(false);
  function setEnforcing(value) {
    enforcing.value = value;
  }
  const alwaysOn = ref(false);
  function setAlwaysOn(value) {
    alwaysOn.value = value;
  }
  const extentSetIds = ref([]);
  function setExtentSetIds(value) {
    extentSetIds.value = value;
  }
  return {
    active,
    setActive,
    enforcing,
    setEnforcing,
    alwaysOn,
    setAlwaysOn,
    extentSetIds,
    setExtentSetIds
  };
});

const fsaToProv = {
  A: 10,
  B: 12,
  C: 11,
  E: 13,
  G: 24,
  H: 24,
  J: 24,
  K: 35,
  L: 35,
  M: 35,
  N: 35,
  P: 35,
  R: 46,
  S: 47,
  T: 48,
  V: 59,
  X: [62, 61],
  Y: 60
};
const provs = {
  en: {},
  fr: {}
};
class Provinces {
  list = {};
  listFetched = false;
  constructor(language, url) {
    axios.get(url).then((res) => {
      res.data.definitions.forEach((type) => provs[language][type.code] = type.description);
      Object.keys(provs[language]).forEach((provKey) => {
        this.list[provKey] = provs[language][provKey];
      });
      this.listFetched = true;
    });
  }
  // return list of province codes based on FSA search input query
  fsaToProvinces(fsa) {
    const genericObj = {};
    let provCodes = fsaToProv[fsa.substring(0, 1).toUpperCase()];
    if (typeof provCodes === "number") {
      provCodes = [provCodes];
    }
    provCodes.forEach((n) => {
      genericObj[n] = this.list[n];
    });
    return genericObj;
  }
}
function Provinces$1(language, url) {
  return new Provinces(language, url);
}

const types = {
  en: {
    ADDRESS: "Street Address",
    FSA: "Forward Sortation Area",
    NTS: "National Topographic System",
    COORD: "Latitude/Longitude",
    SCALE: "Scale"
  },
  fr: {
    ADDRESS: "Adresse Municipale",
    FSA: "Région De Tri D'Acheminement",
    NTS: "Système National De Référence Cartographique",
    COORD: "Latitude/Longitude",
    SCALE: "Échelle"
  }
};
class Types {
  allTypes = {};
  validTypes = {};
  filterComplete = false;
  typesFetched = false;
  constructor(language, url) {
    axios.get(url).then((res) => {
      res.data.definitions.forEach((type) => {
        types[language][type.code] = type.term.split(`${type.code}-`)[1];
      });
      Object.keys(types[language]).forEach((typeKey) => {
        this.allTypes[typeKey] = types[language][typeKey];
        this.validTypes[typeKey] = types[language][typeKey];
      });
      this.typesFetched = true;
    });
  }
  // remove any excluded types indicated by config
  filterValidTypes(exclude) {
    if (this.filterComplete) {
      return this.validTypes;
    }
    exclude = typeof exclude === "string" ? [exclude] : exclude;
    if (exclude && exclude.length > 0) {
      for (const key of exclude) {
        delete this.validTypes[key];
      }
    }
    this.filterComplete = true;
    return this.validTypes;
  }
}
function Types$1(language, url) {
  return new Types(language, url);
}

function make(config, query) {
  const latLngRegDD = /^[-+]?([1-8]?\d(\.\d+)?|90(\.0+)?)(\s*[,|;\s]\s*)[-+]?(180(\.0+)?|((1[0-7]\d)|([1-9]?\d))(\.\d+)?)[*]$/;
  const ntsReg = /^\d{2,3}[A-P]/;
  const fsaReg = /^[ABCEGHJKLMNPRSTVXY]\d[A-Z]/;
  if (latLngRegDD.test(query) && !config.disabledSearchTypes.includes("LAT/LNG")) {
    const queryStr = query.slice(0, -1);
    return new LatLongQuery(config, queryStr);
  } else if (fsaReg.test(query) && !config.disabledSearchTypes.includes("FSA")) {
    return new FSAQuery(config, query);
  } else if (ntsReg.test(query) && !config.disabledSearchTypes.includes("NTS")) {
    return new NTSQuery(config, query.substring(0, 6).toUpperCase());
  } else {
    return new AddressQuery(config, query);
  }
}
class Query {
  config;
  query;
  failedServs = [];
  results = [];
  onComplete;
  latLongResult;
  featureResults = [];
  resultType = "geoname";
  constructor(config, query) {
    this.query = query;
    this.config = config;
  }
  search() {
    return this.jsonRequest(this.getUrl()).then((r) => this.normalizeNameItems(r.items)).catch(() => {
      console.error("Geoname service failed");
      this.failedServs.push("geoname");
      return this.normalizeNameItems([]);
    });
  }
  getUrl(useLocate, restrict, lat, lon) {
    let url = "";
    if (useLocate) {
      url = this.config.geoLocateUrl + "?q=" + this.query;
    } else {
      if (lat && lon) {
        url = `${this.config.geoNameUrl}?lat=${lat}&lon=${lon}&num=${this.config.maxResults}`;
      } else {
        url = `${this.config.geoNameUrl}?q=${this.query}&num=${this.config.maxResults}`;
      }
      if (this.config.categories.length > 0) {
        url += `&concise=${this.config.categories.join(",")}`;
      }
      if (this.config.officialOnly) {
        url += "&category=O";
      }
    }
    return url;
  }
  normalizeNameItems(items) {
    return items.filter((i) => this.config.types.validTypes[i.concise.code]).map((i) => {
      return {
        name: i.name,
        location: i.location,
        province: this.config.provinces.list[i.province.code],
        type: this.config.types.allTypes[i.concise.code],
        LatLon: { lat: i.latitude, lon: i.longitude },
        bbox: i.bbox,
        order: this.config.sortOrder.indexOf(i.concise.code) >= 0 ? this.config.sortOrder.indexOf(i.concise.code) : this.config.sortOrder.length
      };
    });
  }
  jsonRequest(url) {
    return new Promise((resolve, reject) => {
      const xobj = new XMLHttpRequest();
      xobj.open("GET", url, true);
      xobj.responseType = "json";
      xobj.onload = () => {
        if (xobj.status === 200) {
          const rawResponse = typeof xobj.response === "string" ? JSON.parse(xobj.response) : xobj.response;
          resolve(rawResponse);
        } else {
          reject("Could not load results from remote service.");
        }
      };
      xobj.send();
    });
  }
  locateByQuery() {
    return this.jsonRequest(this.getUrl(true, void 0));
  }
  nameByLatLon(lat, lon, restrict) {
    return this.jsonRequest(this.getUrl(false, restrict, lat, lon)).then((r) => {
      return this.normalizeNameItems(r.items);
    }).catch(() => {
      console.error("LatLon service failed");
      this.failedServs.push("geoname");
      return this.normalizeNameItems([]);
    });
  }
}
class LatLongQuery extends Query {
  constructor(config, query) {
    super(config, query);
    this.resultType = "latlong";
    const filteredQuery = query.split(/[\s|,|;|]/).filter((n) => !isNaN(n) && n !== "").map((n) => parseFloat(n));
    const coords = filteredQuery;
    const buff = 0.015;
    const boundingBox = [coords[1] - buff, coords[0] - buff, coords[1] + buff, coords[0] + buff];
    this.latLongResult = {
      name: `${coords[0]},${coords[1]}`,
      location: {
        latitude: coords[0],
        longitude: coords[1]
      },
      type: "Latitude/Longitude",
      position: [coords[1], coords[0]],
      bbox: boundingBox
    };
    this.onComplete = new Promise((resolve, reject) => {
      this.nameByLatLon(coords[0], coords[1]).then((r) => {
        if (r) {
          this.results = r;
          resolve(this);
        } else {
          reject("Given lat lon coordinates cannot be found");
        }
      });
    });
  }
}
class FSAQuery extends Query {
  constructor(config, query) {
    query = query.substring(0, 3).toUpperCase();
    super(config, query);
    this.resultType = "fsa";
    this.onComplete = new Promise((resolve) => {
      this.formatLocationResult().then((fLR) => {
        if (fLR) {
          this.featureResults.push(fLR);
          this.nameByLatLon(
            fLR.LatLon.lat,
            fLR.LatLon.lon,
            Object.keys(fLR._provinces).map((x) => parseInt(x))
          ).then((r) => {
            this.results = r;
            resolve(this);
          });
        } else {
          console.log("FSA code given cannot be found.");
          resolve(this);
        }
      });
    });
  }
  formatLocationResult() {
    return this.locateByQuery().then((locateResponseList) => {
      if (locateResponseList.length === 1 && this.query) {
        const provList = this.config.provinces.fsaToProvinces(this.query);
        return {
          fsa: this.query,
          code: "FSA",
          desc: this.config.types.allTypes.FSA,
          province: Object.keys(provList).map((i) => provList[i]).join(","),
          _provinces: provList,
          LatLon: {
            lat: locateResponseList[0].geometry.coordinates[1],
            lon: locateResponseList[0].geometry.coordinates[0]
          }
        };
      }
    }).catch(() => {
      console.error("FSA service failed");
      this.failedServs.push("geolocation");
      return void 0;
    });
  }
}
class NTSQuery extends Query {
  unitName;
  unit;
  mapSheets = [];
  constructor(config, query) {
    super(config, query);
    this.resultType = "nts";
    query = isNaN(parseInt(query[2])) ? "0" + query : query;
    this.unitName = query;
    this.onComplete = new Promise((resolve) => {
      this.locateByQuery().then((lr) => {
        if (lr.length > 0 && this.query) {
          const allSheets = this.locateToResult(lr);
          this.unit = allSheets[0];
          this.mapSheets = allSheets;
          this.featureResults.push(this.unit);
          this.nameByLatLon(this.unit.LatLon.lat, this.unit.LatLon.lon).then((r) => {
            this.results = r;
            resolve(this);
          });
        } else {
          console.log("Given NTS code not found");
          resolve(this);
        }
      }).catch(() => {
        console.error("NTS service failed");
        this.failedServs.push("geolocation");
        resolve(this);
      });
    });
  }
  locateToResult(lrl) {
    const results = lrl.map((ls) => {
      const title = ls.title.split(" ");
      return {
        nts: title.shift() || "",
        // 064D or 064D06
        location: title.join(" "),
        // "NUMABIN BAY"
        code: "NTS",
        // "NTS"
        desc: this.config.types.allTypes.NTS,
        // "National Topographic System"
        LatLon: {
          lat: ls.geometry.coordinates[1],
          lon: ls.geometry.coordinates[0]
        },
        bbox: ls.bbox
      };
    });
    return results;
  }
  equals(otherQ) {
    return this.unitName === otherQ.unitName;
  }
}
class AddressQuery extends Query {
  constructor(config, query) {
    query = encodeURIComponent(query.trim());
    super(config, query);
    this.resultType = "address";
    this.onComplete = new Promise((resolve) => {
      this.locateByQuery().then((lr) => {
        this.featureResults = this.locateToResult(lr);
        this.search().then((r) => {
          this.results = r;
          resolve(this);
        });
      }).catch(() => {
        this.failedServs.push("geolocation");
        console.error("Address service failed");
        this.search().then((r) => {
          this.results = r;
          resolve(this);
        });
      });
    });
  }
  locateToResult(lrl) {
    if (this.config.categories.length > 0 && !this.config.categories.includes("ADDR")) {
      return [];
    }
    const results = lrl.filter((lr) => lr.type?.includes("Street")).map((ls) => {
      const [name, city, province] = ls.title.split(", ");
      return {
        name,
        city: city.split(" Of ").pop(),
        // prevents redundant label i.e. 'City Of Kingston'
        province,
        desc: this.config.types.allTypes.ADDRESS,
        LatLon: {
          lat: ls.geometry.coordinates[1],
          lon: ls.geometry.coordinates[0]
        }
      };
    });
    return results;
  }
}

const GEO_LOCATE_URL = "https://geogratis.gc.ca/services/geolocation/@{language}/locate";
const GEO_NAMES_URL = "https://geogratis.gc.ca/services/geoname/@{language}/geonames.json";
const GEO_PROVINCES_URL = "https://geogratis.gc.ca/services/geoname/@{language}/codes/province.json";
const GEO_TYPES_URL = "https://geogratis.gc.ca/services/geoname/@{language}/codes/concise.json";
const CODE_TO_ABBR = {
  10: "NL",
  11: "PE",
  12: "NS",
  13: "NB",
  24: "QC",
  35: "ON",
  46: "MB",
  47: "SK",
  48: "AB",
  59: "BC",
  60: "YU",
  61: "NT",
  62: "NU",
  72: "UF",
  73: "IW"
};
class GeoSearchUI {
  config;
  constructor(language, uConfig) {
    let geoLocateUrl;
    let geoNameUrl;
    let geoProvinceUrl;
    let geoTypesUrl;
    const services = uConfig?.serviceUrls;
    if (services) {
      geoLocateUrl = services.geoLocation ? services.geoLocation : GEO_LOCATE_URL;
      geoNameUrl = services.geoNames ? services.geoNames : GEO_NAMES_URL;
      geoProvinceUrl = services.geoProvince ? services.geoProvince : GEO_PROVINCES_URL;
      geoTypesUrl = services.geoTypes ? services.geoTypes : GEO_TYPES_URL;
    } else {
      geoLocateUrl = GEO_LOCATE_URL;
      geoNameUrl = GEO_NAMES_URL;
      geoProvinceUrl = GEO_PROVINCES_URL;
      geoTypesUrl = GEO_TYPES_URL;
    }
    geoLocateUrl = geoLocateUrl.replace("@{language}", language);
    geoNameUrl = geoNameUrl.replace("@{language}", language);
    geoProvinceUrl = geoProvinceUrl.replace("@{language}", language);
    geoTypesUrl = geoTypesUrl.replace("@{language}", language);
    const settings = uConfig?.settings;
    let categories;
    let sortOrder;
    let disabledSearchTypes;
    let maxResults;
    let officialOnly;
    if (settings) {
      categories = settings.categories ? settings.categories : [];
      sortOrder = settings.sortOrder ? settings.sortOrder : [];
      disabledSearchTypes = settings.disabledSearchTypes ? settings.disabledSearchTypes : [];
      maxResults = settings.maxResults > 0 ? settings.maxResults : 100;
      officialOnly = !!settings.officialOnly;
    } else {
      categories = [];
      sortOrder = [];
      disabledSearchTypes = [];
      maxResults = 100;
      officialOnly = false;
    }
    this.config = {
      language,
      geoNameUrl,
      geoLocateUrl,
      types: Types$1(language, geoTypesUrl),
      // list of type filters
      provinces: Provinces$1(language, geoProvinceUrl),
      // list of province filters
      categories,
      sortOrder,
      disabledSearchTypes,
      maxResults,
      officialOnly
    };
    this.config.types.filterValidTypes(uConfig?.excludeTypes);
    this._provinceList = [];
    this._typeList = [];
    this._excludedTypes = uConfig?.excludeTypes || [];
  }
  get provinceList() {
    return this._provinceList;
  }
  get typeList() {
    return this._typeList;
  }
  set provinceList(val) {
    this._provinceList = val;
  }
  set typeList(val) {
    this._typeList = val;
  }
  levenshteinDistance(q, result) {
    result = result.toLowerCase().trim();
    const query = decodeURI(q.query.toLowerCase().replace("*", ""));
    const levDistance = [];
    for (let i = 0; i <= result.length; i++) {
      levDistance[i] = [i];
      for (let j = 1; j <= query.length; j++) {
        levDistance[i][j] = i === 0 ? j : Math.min(
          levDistance[i][j - 1] + 1,
          // delete
          levDistance[i - 1][j] + 0.2,
          // insert
          levDistance[i - 1][j - 1] + (query[j - 1] === result[i - 1] ? 0 : 1)
          // substitute
        );
      }
    }
    return levDistance[result.length][query.length];
  }
  /**
   * Find and return the province object in the province list
   *
   * @param {string} province the target province
   * @return {Object}         associated province object
   */
  findProvinceObj(province) {
    return this.provinceList.find((p) => {
      return p.name === province;
    });
  }
  /**
   * Given some string query, returns a promise that resolves as a formatted location object
   *
   * @param {string} q the search string this query is based on
   * @return {Promise}
   */
  query(q) {
    return make(this.config, q.toUpperCase()).onComplete.then((q2) => {
      let featureResult = [];
      if (q2.featureResults.length > 0) {
        if (q2.resultType === "fsa") {
          featureResult = q2.featureResults.map((fsa) => ({
            name: fsa.fsa,
            bbox: [
              fsa.LatLon.lon + 0.02,
              fsa.LatLon.lat - 0.02,
              fsa.LatLon.lon - 0.02,
              fsa.LatLon.lat + 0.02
            ],
            type: fsa.desc,
            position: [fsa.LatLon.lon, fsa.LatLon.lat],
            location: {
              latitude: fsa.LatLon.lat,
              longitude: fsa.LatLon.lon,
              province: this.findProvinceObj(fsa.province)
            },
            order: -1
          }));
        } else if (q2.resultType === "nts") {
          featureResult = q2.featureResults.map((nts) => ({
            name: nts.nts,
            bbox: nts.bbox ?? [
              nts.LatLon.lon + 0.02,
              nts.LatLon.lat - 0.02,
              nts.LatLon.lon - 0.02,
              nts.LatLon.lat + 0.02
            ],
            type: nts.desc,
            position: [nts.LatLon.lon, nts.LatLon.lat],
            location: {
              city: nts.location,
              latitude: nts.LatLon.lat,
              longitude: nts.LatLon.lon
            },
            order: -1
          }));
        } else if (q2.resultType === "address") {
          featureResult = q2.featureResults.map((address) => ({
            name: address.name,
            bbox: [
              address.LatLon.lon + 2e-3,
              address.LatLon.lat - 2e-3,
              address.LatLon.lon - 2e-3,
              address.LatLon.lat + 2e-3
            ],
            type: address.desc,
            position: [address.LatLon.lon, address.LatLon.lat],
            location: {
              city: address.city,
              latitude: address.LatLon.lat,
              longitude: address.LatLon.lon,
              province: this.findProvinceObj(address.province)
            },
            order: this.config.sortOrder.indexOf("ADDR") >= 0 ? this.config.sortOrder.indexOf("ADDR") : this.config.sortOrder.length
          }));
          if (this.config.sortOrder.length > 0) {
            featureResult = featureResult.sort((a, b) => {
              return this.levenshteinDistance(q2, a.name) > this.levenshteinDistance(q2, b.name) ? 1 : -1;
            });
          }
        }
      } else if (q2.resultType === "latlong") {
        featureResult = [q2.latLongResult];
        featureResult[0].order = -1;
      }
      const queryResult = q2.results.map((item) => ({
        name: item.name,
        bbox: item.bbox,
        type: item.type,
        position: [item.LatLon.lon, item.LatLon.lat],
        location: {
          city: item.location,
          latitude: item.LatLon.lat,
          longitude: item.LatLon.lon,
          province: this.findProvinceObj(item.province)
        },
        order: item.order
      }));
      return {
        results: featureResult.concat(queryResult).slice(0, this.config.maxResults).sort((a, b) => {
          if (this.config.sortOrder.length > 0) {
            return a.order > b.order ? 1 : -1;
          } else {
            return this.levenshteinDistance(q2, a.name) > this.levenshteinDistance(q2, b.name) ? 1 : -1;
          }
        }),
        failedServs: q2.failedServs
      };
    });
  }
  /**
   * Return a promise that resolves to a list of formatted province objects
   *
   * @return {Promise<Array>} a promise that resolves to a list of formatted province objects
   */
  fetchProvinces() {
    return new Promise((resolve) => {
      const provsWatcher = setInterval(() => {
        if (this.config.provinces.listFetched) {
          clearInterval(provsWatcher);
          const provinceList = [];
          const reset = {
            code: -1,
            abbr: "...",
            name: "..."
          };
          provinceList.push(reset);
          const rawProvinces = this.config.provinces.list;
          for (const code in rawProvinces) {
            provinceList.push({
              code,
              abbr: CODE_TO_ABBR[code],
              name: rawProvinces[code]
            });
          }
          this.provinceList = provinceList;
          resolve(this.provinceList);
        }
      });
    });
  }
  /**
   * Return a promise that resolves to a list of formatted type objects
   *
   * @return {Promise<Array>} a promise that resolves to a list of formatted type objects
   */
  fetchTypes() {
    return new Promise((resolve) => {
      const typesWatcher = setInterval(() => {
        if (this.config.types.typesFetched) {
          clearInterval(typesWatcher);
          const typeList = [];
          const reset = {
            code: -1,
            name: "..."
          };
          typeList.push(reset);
          const rawTypes = this.config.types.allTypes;
          for (const type in rawTypes) {
            if (!this._excludedTypes.includes(type)) {
              typeList.push({
                code: type,
                name: rawTypes[type]
              });
            }
          }
          this.typeList = typeList;
          resolve(this.typeList);
        }
      }, 250);
    });
  }
}

function filter(visibleOnly, queryParams, data) {
  if (visibleOnly && queryParams.extent) {
    data = data.filter(
      (r) => r.bbox[0] <= queryParams.extent.xmax && r.bbox[1] <= queryParams.extent.ymax && r.bbox[2] >= queryParams.extent.xmin && r.bbox[3] >= queryParams.extent.ymin
    );
  }
  if (queryParams.province && queryParams.province !== "...") {
    data = data.filter((r) => r.location.province?.name && r.location.province.name === queryParams.province);
  }
  if (queryParams.type && queryParams.type !== "...") {
    data = data.filter((r) => r.type === queryParams.type);
  }
  return data;
}
const useGeosearchStore = defineStore("geosearch", () => {
  const GSservice = ref(new GeoSearchUI("en", void 0));
  const queryParams = ref({
    type: "",
    province: "",
    extent: void 0
  });
  const resultsVisible = ref(false);
  const searchVal = ref("");
  const searchRegex = ref("");
  const lastSearchVal = ref("");
  const searchResults = ref([]);
  const savedResults = ref([]);
  const loadingResults = ref(false);
  const failedServices = ref([]);
  const getProvinces = computed(
    () => new Promise((resolve) => {
      GSservice.value.fetchProvinces().then((provs) => {
        provs.sort((provA, provB) => provA.name > provB.name ? 1 : -1);
        resolve(provs);
      });
    })
  );
  const getTypes = computed(
    () => new Promise((resolve) => {
      GSservice.value.fetchTypes().then((types) => {
        types.sort((typeA, typeB) => typeA.name > typeB.name ? 1 : -1);
        resolve(types);
      });
    })
  );
  function initService(lang, config) {
    GSservice.value = new GeoSearchUI(lang, config);
  }
  function runQuery(forceReRun) {
    loadingResults.value = true;
    const cleanedSearchVal = searchVal.value.replace(/["!*$+?^{}()|[\]\\]/g, "").trim();
    if (!cleanedSearchVal) {
      searchResults.value = [];
      savedResults.value = [];
      loadingResults.value = false;
    } else {
      if (cleanedSearchVal && cleanedSearchVal !== lastSearchVal.value || forceReRun) {
        const watcher = setInterval(() => {
          if (GSservice.value.config.provinces.listFetched && GSservice.value.config.types.typesFetched) {
            clearInterval(watcher);
            GSservice.value.query(`${cleanedSearchVal}*`).then((data) => {
              failedServices.value = data.failedServs;
              lastSearchVal.value = cleanedSearchVal;
              savedResults.value = data.results;
              const filteredData = filter(
                resultsVisible.value,
                //@ts-ignore
                queryParams.value,
                savedResults.value
              );
              searchResults.value = filteredData || [];
              loadingResults.value = false;
            });
          }
        }, 250);
      } else {
        const filteredData = filter(
          resultsVisible.value,
          //@ts-ignore
          queryParams.value,
          savedResults.value
        );
        searchResults.value = filteredData || [];
        loadingResults.value = false;
      }
    }
  }
  function setProvince(payload) {
    queryParams.value.province = typeof payload.province === "undefined" ? "" : payload.province;
    runQuery(payload.forceReRun);
  }
  function setType(payload) {
    queryParams.value.type = typeof payload.type === "undefined" ? "" : payload.type;
    runQuery(payload.forceReRun);
  }
  function setSearchTerm(searchTerm) {
    lastSearchVal.value = searchVal.value.replace(/["!*$+?^{}()|[\]\\]/g, "").trim();
    searchVal.value = searchTerm;
    runQuery();
  }
  function setSearchRegex(searchTerm) {
    const accentedChars = {
      a: "àáâãäåāăąǎȁȃȧạảấầẩẫậắằẳẵặ",
      b: "ḃɓḅḇ",
      c: "çćĉċč",
      d: "ďḋḍḏḑḓ",
      e: "èéêëēĕėęěȅȇẹẻẽếềểễệ",
      f: "ƒḟ",
      g: "ĝğġģǧǵḡ",
      h: "ĥȟḣḥḧḩḫẖ",
      i: "ìíîïĩīĭįıȉȋịỉĩ",
      j: "ĵǰɉ",
      k: "ķĸƙḳḵ",
      l: "ĺļľŀłḷḹḻḽ",
      m: "ḿṁṃ",
      n: "ñńņňŉŋǹṅṇṉṋ",
      o: "òóôõöōŏőơǒǫǭȍȏȯọỏốồổỗộớờởỡợ",
      p: "ṕṗ",
      r: "ŕŗřȑȓṛṝṟ",
      s: "śŝşšșṡṣṥṧṩ",
      t: "ţťŧțṫṭṯṱẗ",
      u: "ùúûüũūŭůűųưǔǖǘǚǜȕȗụủứừửữự",
      v: "ṽṿ",
      w: "ẁẃŵẅẇẉẋ",
      x: "ẋẍ",
      y: "ỳýŷÿỹȳẏẙỵỷỹ",
      z: "źżžẑẓẕ"
    };
    searchTerm = searchTerm.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
    searchRegex.value = Array.from(searchTerm).map((c) => {
      if (Object.keys(accentedChars).includes(c)) {
        return "[" + c + accentedChars[c] + "]";
      }
      return c.replace(/["$!*+?^{}()|[\]\\]/g, "").replace(/[.\\]/g, "\\$&").trim();
    }).join("");
  }
  function setMapExtent(mapExtent) {
    if (mapExtent.visible !== void 0) {
      resultsVisible.value = mapExtent.visible;
    }
    if (mapExtent.extent.sr.wkid !== 4326) {
      throw new Error("an extent that was not projected to wkid 4326 was passed to the geosearch store");
    }
    queryParams.value.extent = mapExtent.extent;
    runQuery();
  }
  return {
    GSservice,
    queryParams,
    resultsVisible,
    searchVal,
    searchRegex,
    lastSearchVal,
    searchResults,
    savedResults,
    loadingResults,
    failedServices,
    getProvinces,
    getTypes,
    initService,
    runQuery,
    setProvince,
    setType,
    setSearchTerm,
    setSearchRegex,
    setMapExtent
  };
});

const useHelpStore = defineStore("help", () => {
  const location = ref("./help/");
  return { location };
});

var LegendControl = /* @__PURE__ */ ((LegendControl2) => {
  LegendControl2["Visibility"] = "visibilityButton";
  LegendControl2["Expand"] = "expandButton";
  return LegendControl2;
})(LegendControl || {});
var LegendType = /* @__PURE__ */ ((LegendType2) => {
  LegendType2["Item"] = "item";
  LegendType2["Placeholder"] = "placeholder";
  LegendType2["Error"] = "error";
  return LegendType2;
})(LegendType || {});
class LegendItem extends APIScope {
  _uid;
  _name;
  _type;
  _children = [];
  // list of child legend items
  _parent = void 0;
  // parent of legend item
  _loadPromise;
  // deferred promise that resolves when legend item is loaded
  _hidden;
  // indicates if item (and its children) should be hidden from the legend
  _expanded;
  // expanded state of item
  _visibility;
  // visibility state of item
  _exclusive;
  // indicates if children should follow 'exclusive set' behavior (à la radio buttons)
  _controls;
  // will use layer controls if undefined
  _disabledControls;
  // will use layer's disabled controls if undefined
  _lastVisible;
  // keeps track of last visible legend item, used for exclusive sets
  _visibleChildren;
  // keeps track of last visible child items
  /**
   * Create a new legend item with defaulting for all properties given config snippet, id is required.
   * @param {InstanceAPI} iApi instance API for the RAMP that this is associated with
   * @param {any} config the config for the given legend item
   * @param {LegendItem} parent a legend item that this item is a child of
   */
  constructor(iApi, config, parent) {
    super(iApi);
    this._uid = geo.sharedUtils.generateUUID();
    this._name = config.name;
    this._type = config.type ?? "placeholder" /* Placeholder */;
    this._parent = parent;
    this._children = [];
    this._loadPromise = new DefPromise();
    this._hidden = config.hidden ?? false;
    this._expanded = config.expanded ?? true;
    this._visibility = true;
    this._exclusive = config.exclusive ?? false;
    this._controls = config.controls?.slice() ?? ["visibilityButton" /* Visibility */, "expandButton" /* Expand */];
    this._disabledControls = config.disabledControls?.slice();
    this._lastVisible;
    this._visibleChildren = [];
  }
  /** Returns the item's uid */
  get uid() {
    return this._uid;
  }
  /** Returns the item's name */
  get name() {
    return this._name;
  }
  /** Sets the item's name
   * @param {string} name new item name
   */
  set name(name) {
    this._name = name;
  }
  /** Returns the item's type */
  get type() {
    return this._type;
  }
  /** Returns children of the legend item */
  get children() {
    return this._children;
  }
  /** Sets new children for the legend item
   * @param {Array<LegendItem>} children new child legend items
   */
  set children(children) {
    this._children = children;
  }
  /** Returns item's parent - not yet initialized */
  get parent() {
    return this._parent;
  }
  /**Sets new parent for the legend item */
  set parent(parent) {
    this._parent = parent;
  }
  /** Returns the load promise for this legend item */
  get loadPromise() {
    return this._loadPromise.getPromise();
  }
  /** Returns if item is hidden */
  get hidden() {
    return this._hidden;
  }
  /** Returns if item is expanded */
  get expanded() {
    return this._expanded;
  }
  /** Returns if item has visibility */
  get visibility() {
    return this._visibility;
  }
  /** Returns if item follows "exclusive set" behaviour */
  get exclusive() {
    return this._exclusive;
  }
  /**
   * Check if a control is available for the legend item.
   * Returns:
   *  - true if the control is included in legend item's available controls
   *  - false if control is not included, or if control is disabled
   *  - undefined if controls are not defined
   * @param {LegendControl} control name of the control
   * @return {boolean | undefined}
   */
  controlAvailable(control) {
    return this._disabledControls?.includes(control) ? false : this._controls?.includes(control);
  }
  /**
   * Enable a disabled control, or disable an enabled control.
   * @param {LegendControl} control name of the control
   * @param {boolean} enable true for enabling, false for disabling
   */
  setControl(control, enable) {
    if (enable && this._disabledControls?.includes(control)) {
      this._disabledControls = this._disabledControls.filter((item) => item !== control);
      this._controls?.push(control);
    } else if (!enable && this._controls?.includes(control)) {
      this._controls = this._controls.filter((item) => item !== control);
      this._disabledControls?.push(control);
    }
  }
  /**
   * Toggle hidden state of a legend item.
   * @param {boolean} hidden set legend item to hidden/not hidden if given, otherwise toggle
   */
  toggleHidden(hidden) {
    this._hidden = hidden ?? !this.hidden;
  }
  /**
   * Toggle expand state of a legend item.
   * @param {boolean} expanded set legend item to expanded/not expanded if given, otherwise toggle
   */
  toggleExpanded(expanded) {
    this._expanded = expanded ?? !this.expanded;
  }
  /**
   * Toggle visibility state of a legend item. Needs to verify parent visibility is updated.
   * @param {boolean} visibility set legend item to visible/not visible if given, otherwise toggle
   * @param {boolean} updateParent whether or not toggleVisibiliity should 'bubble-up' the legend tree
   */
  toggleVisibility(visible, updateParent = true) {
    if (this.visibility === visible) return;
    this._visibility = visible ?? !this.visibility;
    if (!this.exclusive) {
      if (this.visibility) {
        this._visibleChildren.length > 0 ? this._visibleChildren.forEach((item) => item.toggleVisibility(true, false)) : this.children.forEach((item) => item.toggleVisibility(true, false));
      } else {
        this.children.forEach((item) => item.toggleVisibility(false, false));
      }
    } else {
      if (this.visibility) {
        if (this._lastVisible && (!(this._lastVisible instanceof LayerItem) || this._lastVisible.layerControlAvailable(LayerControl.Visibility))) {
          this._lastVisible.toggleVisibility(true);
        } else {
          const itemToTurnOn = this.children.find(
            (child) => !(child instanceof LayerItem) || child.layerControlAvailable(LayerControl.Visibility)
          );
          if (itemToTurnOn) {
            itemToTurnOn.toggleVisibility(true);
          }
        }
      } else {
        this._lastVisible = this.children.find((item) => item.visibility);
        this._lastVisible?.toggleVisibility(false);
      }
    }
    if (this.parent && updateParent) {
      this.parent.checkVisibility(this);
    }
  }
  /**
   * Ensures visibility rules are followed if legend item is nested in another item on initialization.
   */
  checkVisibilityRules() {
    if (this.parent && !this.parent.visibility) {
      this.toggleVisibility(false, false);
    } else if (this.parent?.exclusive) {
      const siblingVisible = this.parent.children.some(
        (item) => item.visibility && item !== this && item.type === "item" /* Item */
      );
      if (siblingVisible) {
        this.toggleVisibility(false, false);
      }
    }
  }
  /**
   * Updates parent visibility after a child item's visibility toggles.
   * @param {LegendItem} toggledChild given child legend item
   */
  checkVisibility(toggledChild) {
    if (this instanceof LayerItem && !this.layerControlAvailable(LayerControl.Visibility)) {
      return;
    }
    if (!this.exclusive) {
      if (this.children.some((item) => item.visibility)) {
        this._visibility = true;
        this._visibleChildren = this.children.filter((item) => item.visibility);
        if (this instanceof LayerItem && this.layer && this.layer.layerExists) {
          this.layer.visibility = true;
        }
      } else {
        this._visibility = false;
        this._visibleChildren = [];
        if (this instanceof LayerItem && this.layer && this.layer.layerExists) {
          this.layer.visibility = false;
        }
      }
    } else if (toggledChild.visibility) {
      this.children.forEach((item) => {
        if (item.uid !== toggledChild.uid) {
          item.toggleVisibility(false, false);
        }
      });
      this._lastVisible = toggledChild;
      this._visibility = true;
      if (this instanceof LayerItem && this.layer && this.layer.layerExists) {
        this.layer.visibility = true;
      }
    } else {
      this._visibility = false;
      if (this instanceof LayerItem && this.layer && this.layer.layerExists) {
        this.layer.visibility = false;
      }
      this._lastVisible = toggledChild;
    }
    if (this.parent) {
      this.parent.checkVisibility(this);
    }
  }
  /**
   * Returns a legend config representation of this item.
   */
  getConfig() {
    const config = {
      name: this._name,
      hidden: this._hidden,
      expanded: this._expanded,
      exclusive: this._exclusive,
      controls: this._controls,
      disabledControls: this._disabledControls
    };
    const childConfigs = [];
    this.children.forEach((item) => {
      childConfigs.push(item.getConfig());
    });
    if (this.exclusive) {
      config.exclusiveVisibility = childConfigs;
    } else {
      config.children = childConfigs;
    }
    return config;
  }
  /**
   * Runs right after legend item is added
   */
  onAdded() {
  }
  /**
   * Runs right before legend item is removed
   */
  onRemoved() {
    this.toggleVisibility(false);
  }
  /**
   * Sets legend item to a loaded state.
   */
  load() {
    this._type = "item" /* Item */;
    this._loadPromise.resolveMe();
    this.checkVisibilityRules();
  }
  /**
   * Sets legend item back to a loading/placeholder state
   */
  reload() {
    this._type = "placeholder" /* Placeholder */;
    this._loadPromise = new DefPromise();
  }
  /**
   * Sets legend item to an error state
   */
  error() {
    if (this._type !== "error" /* Error */) {
      this._type = "error" /* Error */;
      this._loadPromise.getPromise().catch(() => {
      });
      this._loadPromise.rejectMe();
      this.checkVisibilityRules();
    }
  }
}

class LayerItem extends LegendItem {
  _layerId;
  _layerIdx;
  _layerUid = "";
  _isSublayer = false;
  _layer;
  _layerInitVis;
  _layerRedrawing = false;
  _layerOffscale = false;
  _treeGrown = false;
  _customSymbology = false;
  _coverIcon;
  _description;
  _symbologyExpanded;
  _origLayerControls;
  _origLayerDisabledControls;
  _layerControls;
  _layerDisabledControls;
  _maxLines;
  // number of lines this item can take up
  _symbologyRenderStyle;
  _symbologyStack;
  handlers = [];
  /**
   * Creates a new single layer item.
   */
  constructor(iApi, config, parent) {
    super(iApi, config, parent);
    this._type = LegendType.Placeholder;
    this._layerId = config.layerId;
    this._layerIdx = config.sublayerIndex;
    this._isSublayer = config.sublayerIndex !== void 0;
    this._layerControls = config.layerControls ?? [];
    this._origLayerControls = config.layerControls;
    this._layerDisabledControls = config.disabledLayerControls ?? [];
    this._origLayerDisabledControls = config.disabledLayerControls;
    this._layerRedrawing = false;
    this._symbologyExpanded = config.symbologyExpanded || false;
    if (config.coverIcon) this._coverIcon = config.coverIcon;
    if (config.description) this._description = config.description;
    this._symbologyRenderStyle = config.symbologyRenderStyle ?? "icons";
    this._customSymbology = !!config.symbologyStack;
    this._symbologyStack = config.symbologyStack?.map((symbol) => {
      return {
        uid: this.$iApi.geo.shared.generateUUID(),
        label: symbol.text,
        definitionClause: symbol.sqlQuery,
        imgUrl: symbol.image ?? "",
        drawPromise: Promise.resolve(),
        visibility: true,
        // just a placeholder
        lastVisibility: true
      };
    });
    this._maxLines = config.maxLines && [1, 2, 3, 4, 5, 6].includes(config.maxLines) ? config.maxLines : void 0;
  }
  /** Returns the id of the parent layer if this item is a sublayer. Otherwise undefined */
  get parentLayerId() {
    return this._isSublayer ? this._layerId.slice(0, this._layerId.length - `-${this._layerIdx}`.length) : void 0;
  }
  /** Returns the id of the layer */
  get layerId() {
    return this._layerId;
  }
  /** Returns layer index only if the layer item is a sublayer. Otherwise returns undefined */
  get layerIdx() {
    return this._layerIdx;
  }
  /** Returns if the layer is a sublayer */
  get isSublayer() {
    return this._isSublayer;
  }
  /** Returns UID of the layer */
  get layerUid() {
    return this._layerUid;
  }
  /** Returns Ramp Layer associated with legend item. */
  get layer() {
    return this._layer;
  }
  set layer(layer) {
    this._layer = layer;
    this._layerId = layer.id;
    this._layerIdx = layer.isSublayer ? layer.layerIdx : void 0;
    this._layerUid = layer.uid;
    this._name = this._name || layer.name;
    this._symbologyStack = this._customSymbology ? this._symbologyStack : layer.legend;
    this.updateLayerControls();
  }
  get layerOffscale() {
    return this._layerOffscale;
  }
  set layerOffscale(offscale) {
    this._layerOffscale = offscale;
  }
  get layerRedrawing() {
    return this._layerRedrawing;
  }
  set layerRedrawing(redrawing) {
    this._layerRedrawing = redrawing;
  }
  get coverIcon() {
    return this._coverIcon;
  }
  set coverIcon(icon) {
    this._coverIcon = icon;
  }
  get description() {
    return this._description;
  }
  set description(description) {
    this._description = description;
  }
  /** Returns true if symbology stack is expanded. */
  get symbologyExpanded() {
    return this._symbologyExpanded;
  }
  get treeGrown() {
    return this._treeGrown;
  }
  set treeGrown(value) {
    this._treeGrown = value;
  }
  get origLayerControls() {
    return this._origLayerControls;
  }
  get origDisabledLayerControls() {
    return this._origLayerDisabledControls;
  }
  set symbologyRenderStyle(symbologyRenderStyle) {
    this._symbologyRenderStyle = symbologyRenderStyle;
  }
  get symbologyRenderStyle() {
    return this._symbologyRenderStyle;
  }
  set symbologyStack(symbologyStack) {
    this._symbologyStack = symbologyStack;
  }
  get symbologyStack() {
    return this._symbologyStack;
  }
  get maxLines() {
    return this._maxLines;
  }
  /**
   * Returns a legend config representation of this item.
   */
  getConfig() {
    const config = {
      layerId: this._layerId,
      sublayerIndex: this._layerIdx,
      layerControls: this._layerControls,
      disabledLayerControls: this._layerDisabledControls,
      symbologyExpanded: this._symbologyExpanded,
      coverIcon: this._coverIcon,
      description: this._description,
      maxLines: this._maxLines
    };
    return { ...super.getConfig(), ...config };
  }
  /**
   * Toggle visibility state of a layer item. Needs to verify parent visibility is updated.
   * @param {boolean} visibility set legend item to visible/not visible if given, otherwise toggle
   * @param {boolean} updateParent whether or not toggleVisibility should 'bubble-up' the legend tree
   * @param {boolean} forceUpdate ignore control check, used when visibility is changed outside of legend fixture
   */
  toggleVisibility(visible, updateParent = true, forceUpdate = false) {
    if (!this.layerControlAvailable(LayerControl.Visibility) && !forceUpdate) {
      return;
    }
    super.toggleVisibility(visible, updateParent);
    if (this.layer && this.layer.layerExists) {
      this.layer.visibility = this.visibility;
      const someVisible = this._symbologyStack.some((item) => item.lastVisbility);
      this._symbologyStack.forEach((item) => {
        if (!someVisible) {
          item.lastVisbility = true;
        }
        item.visibility = this.visibility ? item.lastVisbility : false;
      });
    }
  }
  /**
   * Toggles the symbology expand and returns the new value
   *
   * @param {boolean} expanded optional parameter to toggle expanded to a certain value
   */
  toggleSymbology(expanded) {
    this._symbologyExpanded = expanded ?? !this._symbologyExpanded;
    return this._symbologyExpanded;
  }
  /**
   * Sets the visibility of the symbology with the given uid
   * If the provided UID is undefined, set the visibility of all symbols
   *
   * @param {uid | undefined} uid the uid of the legend symbology
   * @param visible The new visibility value
   */
  setSymbologyVisibility(uid, visible) {
    this._symbologyStack.some((item) => {
      if (uid === void 0 || item.uid === uid) {
        item.visibility = visible;
        item.lastVisbility = visible;
      }
      return uid !== void 0 && item.uid === uid;
    });
  }
  /**
   * Have the item adapt and update to the given layer as it loads.
   * Is either called in the constructor, or through the legend api
   *
   * @param {LayerInstance | undefined} layer the layer to load. If undefined, layer will be fetched via instance API using id/uid.
   */
  // TS complaining as usual. Can maybe remove the parameter and expect caller to set the layer first?
  // @ts-ignore
  load(layer) {
    const layerInst = layer instanceof LayerInstance ? layer : this.$iApi.geo.layer.getLayer(this._layerId ?? this._layerUid);
    if (!layerInst) {
      return;
    }
    this.layer = layerInst;
    this._layerRedrawing = layerInst.mapLayer && layerInst.drawState !== DrawState.UP_TO_DATE;
    layerInst.loadPromise().then(() => {
      this._layerInitVis = typeof this._layerInitVis !== "undefined" ? this._visibility : layerInst.visibility;
      super.load();
      this.toggleVisibility(this._layerInitVis, true, true);
      if (!layerInst.visibility) {
        this.setSymbologyVisibility(void 0, false);
      }
      this.handlers.push(
        this.$iApi.event.on(
          GlobalEvents.LAYER_VISIBILITYCHANGE,
          (payload) => {
            if (payload.layer.uid === this.layer.uid && this._type === LegendType.Item) {
              this.toggleVisibility(payload.visibility, true, true);
            }
          }
        )
      );
      this.handlers.push(
        this.$iApi.event.on(
          GlobalEvents.LAYER_DRAWSTATECHANGE,
          (payload) => {
            if (this.layer.uid === payload.layer.uid) {
              if (payload.layer.drawState === DrawState.REFRESH) {
                this.layerRedrawing = true;
              } else {
                setTimeout(() => {
                  this.layerRedrawing = payload.layer.drawState === DrawState.REFRESH;
                }, 500);
              }
            }
          }
        )
      );
      this._layerOffscale = this.$iApi.geo.map.created ? layerInst.isOffscale() : false;
      this.handlers.push(
        this.$iApi.event.on(GlobalEvents.MAP_SCALECHANGE, () => {
          if (this.$iApi.geo.map.created) {
            this._layerOffscale = this.layer?.isOffscale();
          }
        })
      );
    }).catch(() => {
      this.error();
    });
  }
  error() {
    this.updateLayerControls();
    super.error();
  }
  /**
   * Check if a control is available for the layer item.
   *
   * @param {LayerControl} control name of the control
   * @return {boolean} Indicates if control is enabled on this legend item or layer
   */
  layerControlAvailable(control) {
    return this._layerDisabledControls?.includes(control) ? false : !!this._layerControls?.includes(control);
  }
  // Update layer controls and disabled controls for this layer item.
  updateLayerControls() {
    const cont = this.$iApi.geo.layer.getLayerControls(this.layerId) ?? this.$iApi.geo.layer.getLayerControls(this.parentLayerId ?? "");
    if (!this._origLayerControls) {
      this._layerControls = cont?.controls ?? [];
    }
    if (!this._origLayerDisabledControls) {
      this._layerDisabledControls = cont?.disabledControls ?? [];
    }
  }
}

var InfoType = /* @__PURE__ */ ((InfoType2) => {
  InfoType2["Title"] = "title";
  InfoType2["Text"] = "text";
  InfoType2["Image"] = "image";
  InfoType2["Markdown"] = "markdown";
  InfoType2["Template"] = "template";
  return InfoType2;
})(InfoType || {});
class SectionItem extends LegendItem {
  _infoType;
  // the type of info displayed on this SectionItem
  _content;
  // the content to be displayed for this SectionItem
  /**
   * Create a new SectionItem.
   * @param {InstanceAPI} iApi instance API for the RAMP that this is associated with
   * @param {any} config the config for the given SectionItem
   * @param {LegendItem} parent a legend item that this item is a child of
   */
  constructor(iApi, config, parent) {
    super(iApi, config, parent);
    this._infoType = config.infoType ?? "title" /* Title */;
    this._content = config.content ?? "";
    if (config.infoType === "template" /* Template */) {
      this.$element.component(`${this._uid}-info-section`, {
        template: this._content
      });
    }
    if (config.infoType || config.content) {
      this._controls = config.controls?.slice() ?? [LegendControl.Expand];
    }
    super.load();
  }
  /** Returns the info type of this SectionItem */
  get infoType() {
    return this._infoType;
  }
  /** Returns the content of this SectionItem */
  get content() {
    return this._content;
  }
  /** Sets new content for this SectionItem
   * @param {string} content new content
   */
  set content(content) {
    this._content = content;
  }
  /**
   * Returns a legend config representation of this item.
   */
  getConfig() {
    const config = {
      infoType: this._infoType,
      content: this._content
    };
    return { ...super.getConfig(), ...config };
  }
}

const useLegendStore = defineStore("legend", () => {
  const legendConfig = ref();
  const children = ref([]);
  const headerControls = ref([]);
  const multilineItems = ref(true);
  const maxLines = ref(3);
  function addItem(value) {
    if (value.parent === void 0) {
      children.value.push(value.item);
    } else {
      if (!(value.item instanceof SectionItem) && !(value.item instanceof LayerItem)) {
        console.error("attempted to add an unsupported legend item type");
        return;
      }
      value.parent.children.push(value.item);
    }
  }
  function removeItem(item) {
    const removeItem2 = (children2) => {
      children2 = children2.filter((child) => {
        if (child === item && !child.children.length) {
          child.onRemoved();
        }
        return child !== item;
      });
      children2.forEach((child) => {
        child.children = removeItem2(child.children);
      });
      children2 = children2.filter(
        (item2) => !(item2 instanceof SectionItem && !item2.children.length && item2.content === "")
      );
      return children2;
    };
    children.value = removeItem2(children.value);
  }
  function replaceItem(value) {
    if (value.oldItem.parent === void 0) {
      const currChildren = children.value;
      const index = currChildren.indexOf(value.oldItem);
      if (index > -1) {
        children.value[index] = value.newItem;
      }
      children.value = currChildren;
    } else {
      const children2 = value.oldItem.parent.children;
      const index = children2.indexOf(value.oldItem);
      if (index > -1) {
        children2[index] = value.newItem;
      }
      value.oldItem.parent.children = children2;
    }
  }
  return {
    legendConfig,
    multilineItems,
    maxLines,
    children,
    headerControls,
    addItem,
    removeItem,
    replaceItem
  };
});

const useMapnavStore = defineStore("mapnav", () => {
  const items = ref({});
  const order = ref([]);
  function removeItem(value) {
    if (value in items.value) {
      delete items.value[value];
    }
    const index = order.value.indexOf(value);
    if (index !== -1) {
      order.value.splice(index, 1);
    }
  }
  return { items, order, removeItem };
});

const useMetadataStore = defineStore("metadata", () => {
  const status = ref("");
  const response = ref({ type: "LineString", coordinates: [] });
  return { status, response };
});

const useNortharrowStore = defineStore("northarrow", () => {
  const arrowIcon = ref("");
  const poleIcon = ref("");
  return { arrowIcon, poleIcon };
});

const useOverviewmapStore = defineStore("overviewmap", () => {
  const mapConfig = ref({
    lodSets: [],
    extentSets: [],
    basemaps: [],
    tileSchemas: [],
    initialBasemapId: ""
  });
  const basemaps = ref({});
  const startMinimized = ref(true);
  const expandFactor = ref(1.5);
  const borderColour = ref("#FF0000");
  const borderWidth = ref(1);
  const areaColour = ref("#000000");
  const areaOpacity = ref(0.25);
  function updateInitialBasemap(basemapId) {
    mapConfig.value.initialBasemapId = basemapId;
  }
  return {
    mapConfig,
    basemaps,
    startMinimized,
    expandFactor,
    borderColour,
    borderWidth,
    areaColour,
    areaOpacity,
    updateInitialBasemap
  };
});

const useScrollguardStore = defineStore("scrollguard", () => {
  const enabled = ref(false);
  function setEnabled(value) {
    enabled.value = value;
  }
  return { enabled, setEnabled };
});

var WizardStep = /* @__PURE__ */ ((WizardStep2) => {
  WizardStep2[WizardStep2["UPLOAD"] = 0] = "UPLOAD";
  WizardStep2[WizardStep2["FORMAT"] = 1] = "FORMAT";
  WizardStep2[WizardStep2["CONFIGURE"] = 2] = "CONFIGURE";
  return WizardStep2;
})(WizardStep || {});

const useWizardStore = defineStore("wizard", () => {
  const placeholderConfig = {
    id: "Placeholder",
    layerType: LayerType.UNKNOWN,
    url: ""
  };
  const layerSource = ref();
  const url = ref("");
  const typeSelection = ref("");
  const nested = ref(true);
  const fileData = ref(null);
  const layerInfo = ref({
    config: placeholderConfig,
    configOptions: []
  });
  const currStep = ref(WizardStep.UPLOAD);
  function goToStep(step) {
    switch (currStep.value) {
      case WizardStep.UPLOAD:
        if (step === WizardStep.UPLOAD) {
          url.value = "";
        } else if (step === WizardStep.FORMAT) {
          currStep.value = WizardStep.FORMAT;
        }
        break;
      case WizardStep.FORMAT:
        if (step === WizardStep.UPLOAD) {
          if (fileData.value) {
            url.value = "";
            fileData.value = null;
          }
          typeSelection.value = "";
          currStep.value = WizardStep.UPLOAD;
        } else if (step === WizardStep.CONFIGURE) {
          currStep.value = WizardStep.CONFIGURE;
        }
        break;
      case WizardStep.CONFIGURE:
        if (step === WizardStep.UPLOAD) {
          url.value = "";
          typeSelection.value = "";
          fileData.value = null;
          nested.value = true;
          layerInfo.value = {
            config: placeholderConfig,
            configOptions: []
          };
          currStep.value = WizardStep.UPLOAD;
        } else if (step === WizardStep.FORMAT) {
          layerInfo.value = {
            config: placeholderConfig,
            configOptions: []
          };
          nested.value = true;
          currStep.value = WizardStep.FORMAT;
        }
        break;
    }
  }
  return {
    layerSource,
    url,
    typeSelection,
    nested,
    fileData,
    layerInfo,
    currStep,
    goToStep
  };
});

class InstanceAPI {
  fixture;
  panel;
  event;
  geo;
  notify;
  ui;
  startRequired = false;
  _eventsOn = false;
  // internal tracker that indicates whether default event handlers are on.
  /**
   * The instance of Vue R4MP application controlled by this InstanceAPI.
   *
   * @type {VueInstance}
   * @memberof InstanceAPI
   */
  $vApp;
  $element;
  $i18n;
  _isFullscreen;
  constructor(element, configs, options) {
    this.event = new EventAPI(this);
    const appInstance = createApp(element, this);
    this.$vApp = appInstance.app;
    this.$element = appInstance.element;
    this.$i18n = appInstance.i18n;
    this.fixture = new FixtureAPI(this);
    this.panel = new PanelAPI(this);
    this.geo = new GeoAPI(this);
    this.ui = {
      maptip: this.geo.map.maptip,
      exposeOids: false,
      exposeMeasurements: true,
      getZoomIcon: () => "",
      formatNumber: () => "",
      scrollToInstance: false,
      suppressNumberLocalization: false,
      escapeHtml: () => "",
      isPlainText: () => true
    };
    this.notify = new NotificationAPI(this);
    this._isFullscreen = screenfull.isEnabled && !!this.$vApp.$root && screenfull.isFullscreen && screenfull.element === this.$vApp.$root.$el;
    if (screenfull.isEnabled) {
      screenfull.onchange(() => {
        this._isFullscreen = screenfull.isEnabled && !!this.$vApp.$root && screenfull.isFullscreen && screenfull.element === this.$vApp.$root.$el;
      });
    }
    this.initialize(true, configs, options);
  }
  /**
   * Initializes a Vue R4MP instance with the given config and options
   *
   * @private
   * @param {boolean} first whether this is the first time initialize is being called for this R4MP instance
   * @param {RampConfigs | undefined} configs language-keyed R4MP config
   * @param {RampOptions | undefined} options startup options for this R4MP instance
   */
  initialize(first, configs, options) {
    const configStore = useConfigStore(this.$vApp.$pinia);
    const panelStore = usePanelStore(this.$vApp.$pinia);
    const maptipStore = useMaptipStore(this.$vApp.$pinia);
    if (configs?.configs !== void 0) {
      const langConfigs = configs.configs;
      const langConfig = langConfigs[this.$i18n.locale.value] ?? langConfigs[Object.keys(langConfigs)[0]];
      configStore.newConfig(langConfig);
      configStore.registerConfig({
        config: langConfig,
        configLangs: Object.keys(langConfigs),
        // @ts-ignore
        allLangs: Object.keys(this.$i18n.messages.value)
      });
      for (const lang in langConfigs) {
        configStore.registerConfig({
          config: langConfigs[lang],
          configLangs: [lang]
        });
      }
      configStore.activeBasemapConfig = langConfig.map.basemaps.find(
        (bm) => bm.id === langConfig.map.initialBasemapId
      );
      const mapDivWatcher = setInterval(() => {
        const mapViewElement = this.$vApp.$el.querySelector("#esriMap");
        if (mapViewElement) {
          clearInterval(mapDivWatcher);
          this.geo.map.createMap(langConfig.map, mapViewElement);
          mapViewElement._tippy.hide(0);
          maptipStore.setMaptipInstance(mapViewElement._tippy);
          if (langConfig.layers && langConfig.layers.length > 0) {
            let mapOrderPos = 0;
            langConfig.layers.forEach((layerConfig) => {
              const layer = this.geo.layer.createLayer(layerConfig);
              this.geo.map.addLayer(layer, mapOrderPos).catch(() => {
              });
              if (layer.mapLayer) {
                mapOrderPos++;
              }
            });
          }
        }
      }, 100);
      if (langConfig.panels) {
        if (langConfig.panels.open && langConfig.panels.open.length > 0) {
          const panelIds = langConfig.panels.open.map((p) => p.id);
          this.panel.isRegistered(panelIds).then(() => {
            langConfig.panels?.open?.forEach((panel) => {
              this.panel.open({
                id: panel.id,
                screen: panel.screen
              });
              if (panel.pin) {
                this.panel.pin(panel.id);
              }
            });
          });
        }
        panelStore.reorderable = langConfig.panels.reorderable ?? true;
      }
      if (!langConfig.system?.animate && this.$element._container && this.$element._container.children[0]) {
        this.$element._container.children[0].classList.remove("animation-enabled");
      }
      if (langConfig.system?.proxyUrl) {
        this.geo.proxy = langConfig.system.proxyUrl;
      }
      if (langConfig.system?.exposeOid) {
        this.ui.exposeOids = langConfig.system.exposeOid;
      }
      if (langConfig.system?.exposeMeasurements != void 0) {
        this.ui.exposeMeasurements = langConfig.system.exposeMeasurements;
      }
      if (langConfig.system?.scrollToInstance) {
        this.ui.scrollToInstance = langConfig.system?.scrollToInstance;
      }
      if (langConfig.system?.suppressNumberLocalization) {
        this.ui.suppressNumberLocalization = langConfig.system?.suppressNumberLocalization;
      }
      const zoomSvgs = {
        magnify: `<svg class="m-auto" xmlns="http://www.w3.org/2000/svg" height="16" viewBox="0 0 24 24" width="16"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" /><path d="M0 0h24v24H0V0z" fill="none" /><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z" /></svg>`,
        globe: `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="16" height="16" viewBox="0 0 16 16" xml:space="preserve"><g transform="matrix(0.67 0 0 0.67 8 8)"><path style=" stroke: none; stroke-width: 1; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: #979797; fill-rule: nonzero; opacity: 1;" transform=" translate(-12, -12)" d="M 12 2 C 6.48 2 2 6.48 2 12 C 2 17.52 6.48 22 12 22 C 17.52 22 22 17.52 22 12 C 22 6.48 17.52 2 12 2 z M 11 19.93 C 7.05 19.44 4 16.08 4 12 C 4 11.38 4.08 10.79 4.21 10.21 L 9 15 L 9 16 C 9 17.1 9.9 18 11 18 L 11 19.93 z M 17.9 17.39 C 17.639999999999997 16.580000000000002 16.9 16 15.999999999999998 16 L 14.999999999999998 16 L 14.999999999999998 13 C 14.999999999999998 12.45 14.549999999999999 12 13.999999999999998 12 L 8 12 L 8 10 L 10 10 C 10.55 10 11 9.55 11 9 L 11 7 L 13 7 C 14.1 7 15 6.1 15 5 L 15 4.59 C 17.93 5.779999999999999 20 8.649999999999999 20 12 C 20 14.08 19.2 15.97 17.9 17.39 z" stroke-linecap="round" /></g></svg>`
      };
      const zoomKey = langConfig.system?.zoomIcon || "globe";
      const zoomIcon = zoomSvgs[zoomKey] || zoomKey;
      this.ui.getZoomIcon = () => {
        return zoomIcon;
      };
      this.ui.formatNumber = (num) => {
        return this.ui.suppressNumberLocalization ? num.toString() : this.$i18n.n(num, "number");
      };
      this.ui.escapeHtml = (content) => {
        const specialChars = {
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#039;"
        };
        return content.replace(/[<>"']/g, (m) => specialChars[m]);
      };
      this.ui.isPlainText = (content) => {
        return typeof content === "string" ? !this.containsValidHtml(content) && !this.representsObject(content) : false;
      };
    }
    if (!options) {
      options = {};
    }
    const instanceStore = useInstanceStore(this.$vApp.$pinia);
    if (options?.startRequired) {
      this.startRequired = true;
      instanceStore.started = false;
    } else {
      this.startRequired = false;
      instanceStore.started = true;
      this.event.emit(GlobalEvents.MAP_START);
    }
    if (first && (options.loadDefaultFixtures !== false || configs?.startingFixtures !== void 0)) {
      this.fixture.addDefaultFixtures(configs?.startingFixtures);
    } else if (!first) {
      this.fixture.restore();
    }
    if (options.loadDefaultEvents !== false && !this._eventsOn) {
      this.event.addDefaultEvents();
      this._eventsOn = true;
    }
  }
  /**
   * Reloads Vue R4MP instance with a new config
   *
   * @param {RampConfigs} configs language-keyed R4MP config
   * @param {RampOptions} options startup options for this R4MP instance
   */
  reload(configs, options) {
    const instanceStore = useInstanceStore(this.$vApp.$pinia);
    const notificationStore = useNotificationStore(this.$vApp.$pinia);
    const configStore = useConfigStore(this.$vApp.$pinia);
    const fixtureStore = useFixtureStore(this.$vApp.$pinia);
    const layerStore = useLayerStore(this.$vApp.$pinia);
    const gridStore = useGridStore(this.$vApp.$pinia);
    const first = !!configs;
    if (first) {
      const addedFixtures = Object.keys(fixtureStore.items);
      addedFixtures.forEach((id) => {
        if (this.fixture.exists(id)) {
          this.fixture.remove(id);
        }
      });
    } else {
      this.fixture.flush();
    }
    const addedGrids = Object.keys(gridStore.grids);
    addedGrids.forEach((id) => {
      gridStore.removeGrid(id);
    });
    instanceStore.started = false;
    this.geo.map.destroyMap();
    layerStore.$reset();
    if (options?.loadDefaultEvents === false) {
      this.event.removeDefaultEvents();
      this._eventsOn = false;
    }
    if (configs === void 0) {
      configs = JSON.parse(
        JSON.stringify({
          startingFixtures: configStore.startingFixtures,
          configs: configStore.registeredConfigs
        })
      );
    }
    notificationStore.clearAll();
    this.geo.map.maptip.clear();
    this.initialize(first, configs, options);
  }
  component(id, definition) {
    if (definition) {
      const vc = this.$element.component(id, definition);
      this.event.emit(GlobalEvents.COMPONENT, id);
      return vc;
    }
    return this.$element.component(id);
  }
  /**
   * The 'screen' size for the app. Returns the largest screen class on the element; 'lg', 'md', 'sm' or 'xs'.
   *
   * @readonly
   * @type string | null
   * @memberof InstanceAPI
   */
  get screenSize() {
    if (!this.$vApp?.$root || !this.$vApp.$root.$refs["app-size"]) {
      return null;
    }
    const classList = this.$vApp.$root.$refs["app-size"].classList;
    if (classList.contains("lg")) {
      return "lg";
    } else if (classList.contains("md")) {
      return "md";
    } else if (classList.contains("sm")) {
      return "sm";
    } else {
      return "xs";
    }
  }
  /**
   * Gets the [cloned] config linked to the current language of the app.
   *
   * @memberof InstanceAPI
   */
  getConfig() {
    const configStore = useConfigStore(this.$vApp.$pinia);
    return JSON.parse(JSON.stringify(configStore.getActiveConfig(this.language)));
  }
  /**
   * Returns the pinia store of the specified id, if it exists, else returns undefined.
   *
   * @param id the id of the store to return
   * @memberof InstanceAPI
   */
  useStore(id) {
    const fixtureIds = [
      "appbar",
      "areas-of-interest",
      "details",
      "export",
      "extentguard",
      "geosearch",
      "grid",
      "help",
      "legend",
      "mapnav",
      "metadata",
      "northarrow",
      "overviewmap",
      "scrollguard",
      "wizard"
    ];
    if (fixtureIds.includes(id) && !this.fixture.exists(id)) {
      return void 0;
    }
    switch (id) {
      case "appbar":
        return useAppbarStore(this.$vApp.$pinia);
      case "areas-of-interest":
        return useAreasOfInterestStore(this.$vApp.$pinia);
      case "details":
        return useDetailsStore(this.$vApp.$pinia);
      case "export":
        return useExportStore(this.$vApp.$pinia);
      case "extentguard":
        return useExtentguardStore(this.$vApp.$pinia);
      case "geosearch":
        return useGeosearchStore(this.$vApp.$pinia);
      case "grid":
        return useGridStore(this.$vApp.$pinia);
      case "help":
        return useHelpStore(this.$vApp.$pinia);
      case "legend":
        return useLegendStore(this.$vApp.$pinia);
      case "mapnav":
        return useMapnavStore(this.$vApp.$pinia);
      case "metadata":
        return useMetadataStore(this.$vApp.$pinia);
      case "northarrow":
        return useNortharrowStore(this.$vApp.$pinia);
      case "overviewmap":
        return useOverviewmapStore(this.$vApp.$pinia);
      case "scrollguard":
        return useScrollguardStore(this.$vApp.$pinia);
      case "wizard":
        return useWizardStore(this.$vApp.$pinia);
      case "config":
        return useConfigStore(this.$vApp.$pinia);
      case "fixture":
        return useFixtureStore(this.$vApp.$pinia);
      case "instance":
        return useInstanceStore(this.$vApp.$pinia);
      case "layer":
        return useLayerStore(this.$vApp.$pinia);
      case "map-caption":
        return useMapCaptionStore(this.$vApp.$pinia);
      case "maptip":
        return useMaptipStore(this.$vApp.$pinia);
      case "notification":
        return useNotificationStore(this.$vApp.$pinia);
      case "panel":
        return usePanelStore(this.$vApp.$pinia);
      default:
        console.error(`The store ${id} does not exist.`);
        return void 0;
    }
  }
  /**
   * Sets the language of the app to the specified string (e.g. 'en' or 'fr').
   *
   * @param {string} language The locale string to switch to
   * @memberof InstanceAPI
   */
  setLanguage(language) {
    if (this.$i18n.locale.value === language) {
      return;
    }
    const configStore = useConfigStore(this.$vApp.$pinia);
    const langs = configStore.registeredLangs;
    const old = this.$i18n.locale.value;
    this.$i18n.locale.value = language;
    const activeConfig = this.getConfig();
    if (langs[old] !== langs[language]) {
      this.event.emit(GlobalEvents.CONFIG_CHANGE, activeConfig);
      this.reload();
    }
    this.event.emit(GlobalEvents.LANG_CHANGE, {
      oldLang: old,
      newLang: language
    });
  }
  /**
   * The current locale string for the app.
   *
   * @readonly
   * @type string
   * @memberof InstanceAPI
   */
  get language() {
    return this.$vApp.$i18n.locale;
  }
  /**
   * The current animation status.
   *
   * @readonly
   * @type boolean
   * @memberof InstanceAPI
   */
  get animate() {
    return !!(this.$element._container && this.$element._container.children[0] && this.$element._container.children[0].classList.contains("animation-enabled"));
  }
  /**
   * Toggles fullscreen for the app.
   *
   * @memberof InstanceAPI
   */
  toggleFullscreen() {
    if (screenfull.isEnabled) {
      screenfull.toggle(this.$element._container || void 0);
    }
  }
  /**
   * Whether the app is fullscreen.
   *
   * @readonly
   * @type boolean
   * @memberof InstanceAPI
   */
  get isFullscreen() {
    return this._isFullscreen;
  }
  /**
   * Whether the app has been started.
   *
   * @readonly
   * @type boolean
   * @memberof InstanceAPI
   */
  get started() {
    return useInstanceStore(this.$vApp.$pinia).started;
  }
  /**
   * Updates the screen reader alert. Use this to inform screen reader users of visual changes in the app (pieces of ui appearing/leaving).
   *
   * @param alert the alert to make available to screen readers
   * @memberof InstanceAPI
   */
  updateAlert(alert) {
    const alertContainer = this.$vApp.$el.querySelector(".screen-reader-alert");
    if (alertContainer.childNodes.length > 0) {
      alertContainer.innerHTML = "";
    }
    const alertSpan = document.createElement("span");
    alertSpan.setAttribute("role", "alert");
    const alertText = document.createTextNode(alert);
    alertSpan.appendChild(alertText);
    alertContainer.insertBefore(alertSpan, null);
  }
  /**
   * If `scrollToInstance` is set to true in the configuration file, scrolls the browser to this RAMP component.
   *
   * @memberof InstanceAPI
   */
  scrollToInstance() {
    if (this.ui.scrollToInstance) {
      this.$element._container?.scrollIntoView({
        behavior: "smooth"
      });
    }
  }
  start() {
    const instanceStore = useInstanceStore(this.$vApp.$pinia);
    if (!instanceStore.started && this.startRequired) {
      this.event.emit(GlobalEvents.MAP_START);
      instanceStore.started = true;
    } else if (instanceStore.started) {
      console.warn("start has already been called");
    }
  }
  /**
   * Return whether the string contains valid html content (i.e. a html element with opening and closing tags)
   */
  containsValidHtml(content) {
    const tagPattern = /<(\w+)([^>]*)>(.*?)<\/\1>/;
    return tagPattern.test(content);
  }
  /**
   * Return whether the string represents an object or array
   */
  representsObject(content) {
    const tagPattern = /^(?:\[\s*(?:[\s\S]*?)\s*\]|\{\s*(?:[\s\S]*?)\s*\})$/;
    return tagPattern.test(content);
  }
}
function createApp(element, iApi) {
  const pinia = createPinia();
  pinia.use(({ store }) => {
    const initialState = clonedeep(store.$state);
    store.$reset = () => store.$patch(clonedeep(initialState));
  });
  const thisi18n = i18n();
  const vueElement = createApp$1(App).use(thisi18n).use(VueTippy, {
    directive: "tippy",
    // => v-tippy
    component: "tippy"
    // => <tippy/>
  }).use(pinia);
  vueElement.directive("focus-container", FocusContainer);
  vueElement.directive("focus-list", FocusList);
  vueElement.directive("focus-item", FocusItem);
  vueElement.directive("truncate", Truncate);
  vueElement.component("panel-screen", _sfc_main$1t);
  vueElement.component("pin", _sfc_main$1s);
  vueElement.component("close", _sfc_main$1r);
  vueElement.component("back", _sfc_main$1q);
  vueElement.component("expand", _sfc_main$1p);
  vueElement.component("panel-options-menu", PanelOptionsMenuV);
  vueElement.component("dropdown-menu", _sfc_main$1E);
  vueElement.component("minimize", _sfc_main$1o);
  vueElement.component("right", _sfc_main$1n);
  vueElement.component("left", _sfc_main$1m);
  vueElement.component("fullscreen-nav-button", _sfc_main$1k);
  vueElement.component("geolocator-nav-button", _sfc_main$1j);
  vueElement.component("home-nav-button", _sfc_main$1i);
  vueElement.component("mapnav-button", _sfc_main$1h);
  vueElement.component("appbar-button", AppbarButtonV);
  vueElement.component("transition", Transition);
  vueElement.component("transition-group", TransitionGroup);
  vueElement.config.globalProperties.$iApi = iApi;
  vueElement.config.globalProperties.$pinia = pinia;
  vueElement.provide("iApi", iApi);
  const app = vueElement.mount(element);
  return { element: vueElement, app, i18n: thisi18n.global };
}

class Basemap {
  esriBasemap;
  config;
  constructor(rampConfig) {
    this.config = rampConfig;
    this.esriBasemap = new EsriBasemap({
      // TODO split by type if we have to populate referenceLayers
      // TODO we can technically support most layer types. Might want to expand a bit.
      //      Feature would be easy.
      //      File based trickier but useful. Would throw asynch wrench into this.
      //      ESRI Image Server would make sense.
      baseLayers: rampConfig.layers.map((layerConfig) => {
        if (layerConfig.layerType === LayerType.TILE) {
          return new EsriTileLayer({
            url: layerConfig.url,
            opacity: layerConfig.opacity
          });
        } else if (layerConfig.layerType === LayerType.MAPIMAGE) {
          return new EsriMapImageLayer({
            url: layerConfig.url,
            opacity: layerConfig.opacity
          });
        } else if (layerConfig.layerType === LayerType.OSM) {
          return new EsriOpenStreetMapLayer({
            opacity: layerConfig.opacity
          });
        } else {
          throw new Error(`Unsupported layer type provided to basemap config: ${layerConfig.layerType}`);
        }
      }),
      title: rampConfig.name || "",
      id: rampConfig.id
    });
  }
  /**
   * Returns the tile schema id from the config
   */
  get tileSchemaId() {
    return this.config.tileSchemaId;
  }
  /**
   * Returns the basemap id from the config
   */
  get id() {
    return this.config.id;
  }
  /**
   * Get this basemap's name from the config
   */
  get name() {
    return this.config.name;
  }
  /**
   * Set this basemap's name
   */
  set name(value) {
    this.config.name = value || "";
  }
  /**
   * Get this basemap's description from the config
   */
  get description() {
    return this.config.description;
  }
  /**
   * Set this basemap's description
   */
  set description(value) {
    this.config.description = value || "";
  }
  /**
   * Get this basemap's alt text from the config
   */
  get altText() {
    return this.config.altText;
  }
  /**
   * Set this basemap's alt text
   */
  set altText(value) {
    this.config.altText = value || "";
  }
  /**
   * Get this basemap's attribution config
   */
  get attribution() {
    return this.config.attribution;
  }
  /**
   * Set this basemap's attribution
   */
  set attribution(value) {
    this.config.attribution = value;
  }
  /**
   * Get this basemap's background colour
   */
  get backgroundColour() {
    return this.config.backgroundColour ?? "#FFFFFF";
  }
}

class CommonMapAPI extends APIScope {
  /**
   * The internal esri map. Avoid referencing outside of geoapi.
   * @private
   */
  esriMap;
  /**
   * Local storage of Basemap objects
   * @private
   */
  _basemapStore;
  /**
   * Indicates if the map has been created
   * @public
   */
  created = false;
  /**
   * Tracks if we are watching for the first basemap to load.
   * @private
   */
  trackFirstBasemap = false;
  /**
   * The internal esri map view. Changes from outside of RAMP may break the instance. Use caution.
   */
  esriView;
  /**
   * Internal deferred managing the view promise
   * @private
   */
  _viewPromise;
  /**
   * A promise that resolves when the map view has been created
   */
  get viewPromise() {
    return this._viewPromise.getPromise();
  }
  /**
   * The map spatial reference in RAMP API Spatial Reference format.
   * Saves us from converting from ESRI format every time it is needed
   * @private
   */
  _rampSR;
  /**
   * The active extent set in RAMP API Extent Set format.
   * Allows a quick reference to the available extents if needed.
   * @private
   */
  _rampExtentSet;
  /**
   * The viewDiv for the ESRI MapView
   * The map will be rendered using this div object
   * @private
   */
  _targetDiv;
  /**
   * List of ESRI watch handlers
   * @private
   */
  handlers;
  /**
   * The default zoom level when zooming to a point feature
   * @private
   */
  pointZoomScale;
  constructor(iApi) {
    super(iApi);
    this.esriMap = void 0;
    this._basemapStore = [];
    this._viewPromise = new DefPromise();
    this.handlers = [];
    this.pointZoomScale = 5e4;
  }
  noMapErr() {
    console.error("Attempted to manipulate the map before calling createMap()");
  }
  abstractError() {
    throw new Error(`Attempted to call an abstract method in the parent CommonMapAPI`);
  }
  /**
   * Any map labels defaulting
   */
  labelsDefault = {
    visible: void 0
  };
  /**
   * Will generate the actual Map control objects and construct it on the page
   * @param {RampMapConfig} config the config for the map
   * @param {string | HTMLDivElement} targetDiv the div to be used for the map view
   */
  createMap(config, targetDiv) {
    this._basemapStore = config.basemaps.map((bmConfig) => {
      const bm = new Basemap(bmConfig);
      bm.esriBasemap.baseLayers.forEach((baselayer) => {
        baselayer.watch("loadStatus", () => {
          if (baselayer.loadStatus === "loaded") {
            this.trackFirstBasemap = false;
          } else if (baselayer.loadStatus === "failed") {
            this.$iApi.notify.show(
              NotificationType.ERROR,
              this.$iApi.$i18n.t("layer.error", {
                id: bm.name
              })
            );
            if (this.trackFirstBasemap) {
              this.recoverBasemap(bm.tileSchemaId);
            }
          }
        });
      });
      return bm;
    });
    if (config.labelsDefault) {
      this.labelsDefault.visible = config.labelsDefault.visible;
    }
    const esriConfig = {};
    this.esriMap = markRaw(new EsriMap(esriConfig));
    this.pointZoomScale = config.pointZoomScale && config.pointZoomScale > 0 ? config.pointZoomScale : 5e4;
    this._targetDiv = targetDiv;
    this.createMapView(config.initialBasemapId);
  }
  /**
   * Destroys the ESRI map
   *
   * @protected
   */
  destroyMap() {
    if (!this.esriMap || !this.esriView) {
      this.noMapErr();
      return;
    }
    this.destroyMapView();
    this.esriMap.destroy();
    delete this.esriMap;
    this._basemapStore.forEach((bm) => bm.esriBasemap.destroy());
    this._basemapStore = [];
  }
  /**
   * Reloads the map with the given map config and target div
   *
   * @param {RampMapConfig} config the config for the map
   * @param {string | HTMLDivElement | undefined} targetDiv the div to be used for the map view
   */
  reloadMap(config, targetDiv) {
    if (!this.esriMap || !this.esriView) {
      this.noMapErr();
      return;
    }
    this.destroyMap();
    this.createMap(config, targetDiv);
  }
  /**
   * Will generate a ESRI map view and add it to the page
   * Can optionally provide the basemap or basemap id to be used when creating the map view
   *
   * This method should be overidden by child map classes
   *
   * @param {string | Basemap | undefined} basemap the id of the basemap that should be used when creating the map view
   * @protected
   */
  createMapView(basemap) {
    this.abstractError();
  }
  /**
   * Destroys the ESRI map view
   *
   * @protected
   */
  destroyMapView() {
    if (!this.esriView) {
      this.noMapErr();
      return;
    }
    this._viewPromise = new DefPromise();
    this.created = false;
    this.handlers.forEach((h) => h.handler.remove());
    this.handlers = [];
    this.esriView.map = null;
    this.esriView.container = null;
    this.esriView.spatialReference = null;
    this.esriView.extent = null;
    this.esriView.navigation = null;
    this.esriView.destroy();
    delete this.esriView;
  }
  /**
   * Searches the local basemap list for a basemap with the given id
   * Throws error if basemap could not be found
   *
   * @param {string} id basemap id
   * @returns {Basemap} the found basemap
   * @protected
   */
  findBasemap(id) {
    const bm = this._basemapStore.find((bms) => bms.id === id);
    if (bm) {
      return bm;
    } else {
      throw new Error(`Invalid basemap id requested: ${id}`);
    }
  }
  /**
   * Applies the given basemap (or basemap with given id) to the esri map
   * Throws error if basemap could not be found with the given id
   *
   * @param {string | basemap} basemap the basemap id or object
   * @protected
   */
  applyBasemap(basemap) {
    if (!this.esriMap) {
      this.noMapErr();
      return;
    }
    const bm = typeof basemap === "string" ? this.findBasemap(basemap) : basemap;
    this.esriMap.basemap = toRaw(bm.esriBasemap);
  }
  /**
   * Set the map's basemap to the basemap with the given id.
   * If the new basemap's tile schema differs from the current one, the map view will be refreshed
   *
   * The returned boolean indicates if the schema has changed.
   *
   * This method should be overidden by child map classes
   *
   * @param {string} basemapId the basemap id
   * @returns {boolean} indicates if the schema has changed
   * @abstract
   */
  setBasemap(basemapId) {
    this.abstractError();
    return false;
  }
  /**
   * Will attempt to change to another basemap if the very first basemap failed.
   * If nothing is defined, will do nothing but manage our watching state.
   *
   * This method is overidden as needed
   *
   * @param {string} basemapSchemaId the basemap schema id (where the fallback is defined)
   */
  recoverBasemap(basemapSchemaId) {
  }
  /**
   * Get the id of the currently used basemap
   * Returns undefined if there is no map
   * @returns {string | undefined} current basemap id
   */
  getCurrentBasemapId() {
    if (this.esriMap) {
      return this.esriMap.basemap.id;
    } else {
      this.noMapErr();
    }
  }
  /**
   * Projects a geometry to the map's spatial reference
   *
   * @private
   * @param {BaseGeometry} geom the RAMP API geometry to project
   * @returns {Promise<BaseGeometry>} the geometry projected to the map's projection, in RAMP API Geometry format
   */
  geomToMapSR(geom) {
    if (!this._rampSR) {
      throw new Error("call to map.geomToMapSR before the map spatial ref was created");
    }
    if (this._rampSR.isEqual(geom.sr)) {
      return Promise.resolve(geom);
    } else {
      return this.$iApi.geo.proj.projectGeometry(this._rampSR, geom);
    }
  }
  /**
   * Zooms the map to a given geometry.
   *
   * @param {BaseGeometry} geom A RAMP API geometry to zoom the map to
   * @param {number} [scale] An optional scale value of the map. Is ignored for non-Point geometries
   * @param {boolean} [animate] Option to turn off the zoom animation. On by default
   * @param {number} [duration] Option to change animation duration (in milliseconds). Default of 200. Ignored if animate is off.
   * @param {ZoomEasing} [easing] Option to change animation easing function. Default of 'ease'. Ignored if animate is off.
   * @returns {Promise<void>} A promise that resolves when the map has finished zooming
   */
  async zoomMapTo(geom, scale, animate = true, duration = 200, easing = "ease") {
    if (this.esriView) {
      if (geom.invalid()) {
        throw new Error("attempt to zoom to invalid geometry");
      }
      const g = await this.geomToMapSR(geom);
      const zoomP = {
        target: this.$iApi.geo.geom.geomRampToEsri(g)
      };
      if (g.type === GeometryType.POINT) {
        zoomP.scale = scale || this.pointZoomScale;
      }
      const opts = { animate, duration, easing };
      return this.viewPromise.then(() => {
        return this.esriView.goTo(zoomP, opts);
      });
    } else {
      this.noMapErr();
    }
  }
  /**
   * Provides the zoom level of the map
   *
   * @returns {number} the map zoom level
   */
  getZoomLevel() {
    if (this.esriView) {
      return this.esriView.zoom;
    } else {
      this.noMapErr();
      return 1;
    }
  }
  /**
   * Provides the scale of the map (the scale denominator as integer)
   *
   * @returns {number} the map scale
   */
  getScale() {
    if (this.esriView) {
      return this.esriView.scale;
    } else {
      this.noMapErr();
      return 1;
    }
  }
  /**
   * Provides the resolution of the map. This means the number of map units that is covered by one pixel.
   *
   * @returns {number} the map resolution
   */
  getResolution() {
    if (this.esriView) {
      return this.esriView.resolution;
    } else {
      this.noMapErr();
      return 1;
    }
  }
  /**
   * Provides the extent of the map
   *
   * @returns {Extent} the map extent in RAMP API Extent format
   */
  getExtent() {
    if (this.esriView) {
      return Extent.fromESRI(this.esriView.extent);
    } else {
      this.noMapErr();
      return Extent.fromParams("i_am_error", 0, 1, 0, 1);
    }
  }
  /**
   * Provides the active extent set of the map
   *
   * @returns {ExtentSet} the active extent set of the map
   */
  getExtentSet() {
    if (this._rampExtentSet) {
      return this._rampExtentSet;
    } else {
      this.noMapErr();
      return ExtentSet.fromConfig({
        id: "i_am_error_extent_set",
        default: {
          xmin: 0,
          xmax: 1,
          ymin: 0,
          ymax: 1,
          spatialReference: {
            wkid: 4326
          }
        }
      });
    }
  }
  /**
   * Provides the spatial reference of the map
   *
   * @returns {SpatialReference} the map spatial reference in RAMP API format
   */
  getSR() {
    if (this._rampSR) {
      return this._rampSR.clone();
    } else {
      this.noMapErr();
      return SpatialReference.latLongSR();
    }
  }
  /**
   * Get the height of the map on the screen in pixels
   *
   * @returns {Number} pixel height
   */
  getPixelHeight() {
    if (this.esriView) {
      return this.esriView.height;
    } else {
      this.noMapErr();
      return 1;
    }
  }
  /**
   * Get the width of the map on the screen in pixels
   *
   * @returns {Number} pixel width
   */
  getPixelWidth() {
    if (this.esriView) {
      return this.esriView.width;
    } else {
      this.noMapErr();
      return 1;
    }
  }
  /**
   * Set's the map's pointZoomScale value to newScale.
   * If newScale is not a positive number, a console error is thrown.
   *
   * The returned boolean indicates if the value has been successfully set.
   *
   * @param {number} newScale the new pointZoomScale value, which must be a positive number
   * @returns {boolean} indicates if the value was set successfully
   */
  setPointZoomScale(newScale) {
    if (newScale > 0) {
      this.pointZoomScale = newScale;
      return true;
    }
    console.error(`Cannot set pointZoomScale to non-positive number: ${newScale}.`);
    return false;
  }
}

class MaptipAPI extends APIScope {
  maptipStore;
  /**
   * @constructor
   * @param {InstanceAPI} iApi the RAMP instance
   */
  constructor(iApi) {
    super(iApi);
    this.maptipStore = useMaptipStore(this.$vApp.$pinia);
  }
  // # makes variables private outside of typescript and lets us hide things on the API
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields
  #lastHit = void 0;
  #currentCheck = void 0;
  /**
   * Checks for a graphic at the given screen coordinates.
   * On a graphic hit the point is put in the maptip store and the `map/graphichit` event is fired.
   *
   * @param {ScreenPoint} screenPoint The screen coordinates for the hitTest
   * @returns {Promise<void>} resolves after the event is fired or no new graphic is hit.
   */
  async checkAtCoord(screenPoint) {
    this.#currentCheck = screenPoint;
    const graphicHit = await this.$iApi.geo.map.getGraphicAtCoord(screenPoint);
    if (this.#currentCheck !== screenPoint) {
      return;
    }
    if (!graphicHit) {
      this.clear();
      return;
    }
    const layerInstance = this.$iApi.geo.layer.getLayer(graphicHit.layerId);
    if (layerInstance?.geomType != GeometryType.POLYGON) {
      if (this.#lastHit && this.#lastHit.layerId === graphicHit.layerId && this.#lastHit.oid === graphicHit.oid && this.#lastHit.layerIdx === graphicHit.layerIdx) {
        return;
      }
    }
    this.clear();
    this.#lastHit = graphicHit;
    if (!layerInstance) {
      console.error(`graphic hit test returned non-existent layer id: ${graphicHit.layerId}`);
      return;
    }
    if (!layerInstance.hovertips) {
      return;
    }
    const icon = await layerInstance.getIcon(graphicHit.oid);
    const graphic = await layerInstance.getGraphic(graphicHit.oid, {
      getAttribs: true
    });
    this.setPoint(this.$iApi.geo.map.screenPointToMapPoint(screenPoint));
    this.$iApi.event.emit(GlobalEvents.MAP_GRAPHICHIT, {
      layer: layerInstance,
      graphicHit,
      attributes: graphic.attributes,
      icon,
      screenPoint
    });
  }
  /**
   * Generates and sets the "default" maptip.
   *
   * @param info the tooltip info payload
   */
  generateDefaultMaptip(info) {
    this.setContent(
      `<div class="flex items-center space-x-5"><span>${info.icon}</span><span class="line-clamp-3">${info.attributes[info.layer.config.tooltipField || info.layer.nameField]}</span></div>`
    );
  }
  /**
   * Clears the maptip from the map
   */
  clear() {
    this.#lastHit = void 0;
    this.maptipStore.setMaptipPoint(void 0);
    this.maptipStore.setMaptipContent("");
  }
  /**
   * Get the `tippy` maptip instance
   * Documentation: https://kabbouchi.github.io/tippyjs-v4-docs/tippy-instance/
   *
   * @returns {any} the `tippy` tooltip instance
   */
  getInstance() {
    return this.maptipStore.maptipInstance;
  }
  /**
   * Get the current point for the maptip
   *
   * @returns {Point} the current maptip map point
   */
  getPoint() {
    return this.maptipStore.maptipPoint;
  }
  /**
   * Set the current maptip point. Undefined = maptip wont be shown.
   *
   * @param {Point | undefined} maptipPoint
   */
  setPoint(maptipPoint) {
    this.maptipStore.setMaptipPoint(maptipPoint);
  }
  /**
   * Set the html string for the maptip
   * If empty string is provided, the maptip will use the default content
   *
   * @param {string} content the new maptip html content
   */
  setContent(content) {
    this.maptipStore.setMaptipContent(content);
  }
}

class OverviewMapAPI extends CommonMapAPI {
  overviewGraphicLayer;
  overviewmapStore;
  /**
   * @constructor
   * @param {InstanceAPI} iApi the RAMP instance
   */
  constructor(iApi) {
    super(iApi);
    this.overviewGraphicLayer = this.$iApi.geo.layer.createLayer({
      id: "RampOverviewGraphic",
      layerType: LayerType.GRAPHIC,
      url: "",
      cosmetic: true
    });
    this.overviewmapStore = useOverviewmapStore(this.$vApp.$pinia);
  }
  /**
   * Will generate a ESRI map view and add it to the page
   * Must provide the basemap or basemap id to be used when creating the map view
   *
   * @param {string | Basemap} basemap the id of the basemap that should be used when creating the map view
   * @protected
   */
  createMapView(basemap) {
    if (!basemap) {
      throw new Error("Attempted to create overview map view without a basemap");
    }
    const bm = typeof basemap === "string" ? this.findBasemap(basemap) : basemap;
    this.applyBasemap(bm);
    this._rampExtentSet = this.$iApi.geo.map.getExtentSet().clone();
    this._rampSR = this._rampExtentSet.sr.clone();
    const expandFactor = this.overviewmapStore.expandFactor;
    this.esriView = markRaw(
      new EsriMapView({
        map: this.esriMap,
        container: this._targetDiv,
        constraints: {
          rotationEnabled: false
        },
        spatialReference: this._rampSR.toESRI(),
        extent: this.$iApi.geo.map.getExtent().toESRI().expand(expandFactor)
        // use the expanded main map extent
      })
    );
    this.esriView.ui.components = [];
    this.handlers.push({
      type: "mouse-wheel",
      handler: this.esriView.on("mouse-wheel", (esriMouseWheel) => {
        esriMouseWheel.stopPropagation();
      })
    });
    this.handlers.push({
      type: "double-click",
      handler: this.esriView.on("double-click", (esriDoubleClick) => {
        esriDoubleClick.stopPropagation();
      })
    });
    this.handlers.push({
      type: "key-down",
      handler: this.esriView.on("key-down", (esriKeyDown) => {
        esriKeyDown.stopPropagation();
      })
    });
    this.handlers.push({
      type: "key-up",
      handler: this.esriView.on("key-up", (esriKeyUp) => {
        esriKeyUp.stopPropagation();
      })
    });
    this.handlers.push({
      type: "drag",
      handler: this.esriView.on("drag", (esriDrag) => {
        esriDrag.stopPropagation();
        this.mapDrag(esriDrag);
      })
    });
    this.esriView.container.addEventListener("touchmove", (e) => {
      e.preventDefault();
    });
    this.esriView.watch("fatalError", () => {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            this.esriView?.tryFatalErrorRecovery();
            observer.disconnect();
          }
        });
      });
      observer.observe(this.esriView.container);
    });
    this.esriView.when(() => {
      this._viewPromise.resolveMe();
      this.created = true;
    });
  }
  async addMapGraphicLayer() {
    if (!this.esriMap) {
      this.noMapErr();
      return;
    }
    const overviewGraphic = new Graphic(this.$iApi.geo.map.getExtent(), "overview-graphic");
    const borderColour = this.overviewmapStore.borderColour ?? "#FF0000";
    const borderWidth = this.overviewmapStore.borderWidth ?? 1;
    const areaColour = this.overviewmapStore.areaColour ?? "#000000";
    const areaOpacity = this.overviewmapStore.areaOpacity ?? 0.25;
    const areaFill = `${areaColour}${Math.round(areaOpacity * 255).toString(16)}`;
    overviewGraphic.style = new PolygonStyle({
      fill: { colour: areaFill },
      outline: {
        colour: borderColour,
        width: borderWidth
      }
    });
    await this.overviewGraphicLayer.initiate();
    await this.overviewGraphicLayer.addGraphic(overviewGraphic);
    this.esriMap?.add(this.overviewGraphicLayer.esriLayer);
  }
  async removeMapGraphicLayer() {
    if (!this.esriMap) {
      this.noMapErr();
      return;
    }
    if (!this.overviewGraphicLayer.esriLayer) {
      throw new Error(
        "Attempted to remove layer from the map without an esri layer. Likely layer.initiate() was not called or had not finished."
      );
    }
    this.overviewGraphicLayer.removeGraphic();
    this.esriMap.remove(this.overviewGraphicLayer.esriLayer);
    await this.overviewGraphicLayer.terminate();
  }
  /**
   * Destroys the ESRI map view
   *
   * @protected
   */
  destroyMapView() {
    this.esriView?.container.removeEventListener("touchmove", (e) => {
      e.preventDefault();
    });
    super.destroyMapView();
  }
  /**
   * Searches the local basemap list and main map basemaps for a basemap with the given id
   * Throws error if basemap could not be found
   *
   * @param {string} id basemap id
   * @returns {Basemap} the found basemap
   * @protected
   */
  findBasemap(id) {
    const bm = this._basemapStore.find((bms) => bms.id === id);
    if (bm) {
      return bm;
    } else {
      const configStore = useConfigStore(this.$vApp.$pinia);
      const mainMapConfig = configStore.config.map;
      if (mainMapConfig) {
        const bmConfig = mainMapConfig.basemaps.find((bm2) => bm2.id === id);
        if (bmConfig) {
          return new Basemap(bmConfig);
        }
      }
    }
    throw new Error(`Invalid basemap id requested: ${id}`);
  }
  /**
   * Sets the overview map's basemap to the basemap with the given id.
   * Will refresh the map view if set basemap uses different tile schema.
   *
   * Should only be called by the overview map component
   *
   * @param {string} basemapId the basemap id
   * @returns {boolean} indicates if the schema has changed
   */
  setBasemap(basemapId) {
    if (!this.esriView || !this.esriMap) {
      this.noMapErr();
      return false;
    }
    const bm = this.findBasemap(basemapId);
    const currBm = this.getCurrentBasemapId() ? this.findBasemap(this.getCurrentBasemapId()) : void 0;
    const differentSchema = currBm?.tileSchemaId !== bm.tileSchemaId;
    if (differentSchema) {
      this.destroyMapView();
      this.createMapView(bm);
    } else {
      this.applyBasemap(bm);
    }
    return differentSchema;
  }
  /**
   * Initial esri extent of graphic during drag
   *
   * @private
   */
  startExtent = null;
  /**
   * Moves graphic and zooms main map if extent graphic is dragged
   *
   * @param {__esri.ViewDragEvent} esriDrag
   * @private
   */
  async mapDrag(esriDrag) {
    if (esriDrag.native.pointerType === "mouse") {
      if (esriDrag.action === "start") {
        if (await this.cursorHitTest(esriDrag)) {
          this.startExtent = markRaw(
            this.overviewGraphicLayer.getEsriGraphic("overview-graphic").geometry
          );
        }
      } else if (this.startExtent) {
        const origin = this.esriView.toMap(esriDrag.origin);
        const pos = this.esriView.toMap({
          x: esriDrag.x,
          y: esriDrag.y
        });
        const newExtent = this.startExtent.clone().offset(pos.x - origin.x, pos.y - origin.y, 0);
        this.overviewGraphicLayer.getEsriGraphic("overview-graphic").geometry = newExtent;
        if (esriDrag.action === "end") {
          this.$iApi.geo.map.zoomMapTo(this.$iApi.geo.geom.geomEsriToRamp(newExtent), void 0, false);
          this.startExtent = null;
        }
      }
    }
  }
  /**
   * Updates overviewmap extent and graphic based on main map extent
   *
   * @param {Extent} newExtent new main map extent
   * @returns {Promise<void>} A promise that resolves when the overviewmap has finished updating
   */
  updateOverview(newExtent) {
    const expandFactor = this.overviewmapStore.expandFactor;
    const zoomPromise = this.zoomMapTo(newExtent.expand(expandFactor), void 0, false);
    const graphic = this.overviewGraphicLayer.getLocalGraphic("overview-graphic");
    this.overviewGraphicLayer.removeGraphic(graphic);
    graphic.geometry = newExtent;
    this.overviewGraphicLayer.addGraphic(graphic);
    return zoomPromise;
  }
  /**
   * Checks if mouse event intersects with extent graphic
   *
   * @param {MouseEvent} e
   * @returns {Promise<boolean>}
   */
  async cursorHitTest(e) {
    const hitTestResult = await this.esriView.hitTest(e);
    return hitTestResult.results.length > 0;
  }
}

class MapCaptionAPI extends APIScope {
  // Default point formatters
  DEFAULT_POINT_FORMATTERS = {
    LAT_LONG_DMS: this.formatLatLongDMS,
    LAT_LONG_DD: this.formatLatLongDD,
    LAT_LONG_DDM: this.formatLatLongDDM,
    WEB_MERCATOR: this.formatMercator,
    CANADA_ATLAS_LAMBERT: this.formatLambert,
    UTM: this.formatUTM,
    BASEMAP: this.formatBasemap
  };
  // The currently selected point-formatting function
  pointFormatter;
  /**
   * @constructor
   * @param {InstanceAPI} iApi the RAMP instance
   */
  constructor(iApi) {
    super(iApi);
    this.pointFormatter = this.DEFAULT_POINT_FORMATTERS.LAT_LONG_DMS;
  }
  /**
   * Configure the map caption using the given config
   *
   * @param captionConfig The map caption config
   */
  createCaption(captionConfig) {
    if (!captionConfig) {
      return;
    }
    const mapCaptionStore = useMapCaptionStore(this.$vApp.$pinia);
    mapCaptionStore.coords.disabled = false;
    mapCaptionStore.scale.disabled = false;
    mapCaptionStore.scale.isImperialScale = false;
    if (captionConfig.mapCoords) {
      if (captionConfig.mapCoords.disabled) {
        mapCaptionStore.coords.disabled = true;
      } else {
        const defaultFormatter = captionConfig.mapCoords.formatter;
        if (defaultFormatter !== void 0) {
          this.setPointFormatter(defaultFormatter);
        }
      }
    }
    if (captionConfig.scaleBar) {
      if (captionConfig.scaleBar.disabled) {
        mapCaptionStore.scale.disabled = true;
      } else {
        const useImperialUnits = captionConfig.scaleBar.imperialScale;
        if (useImperialUnits !== void 0) {
          mapCaptionStore.toggleScale(useImperialUnits);
          this.$iApi.geo.map.viewPromise.then(() => {
            this.updateScale();
          });
        }
      }
    }
    mapCaptionStore.langtoggle = {
      disabled: captionConfig?.langToggle?.disabled ?? false
    };
  }
  /**
   * Updates the attribution on the map-caption bar
   * Applies default ESRI attribution if incoming attribution is disabled or has undefined elements
   *
   * Updates map-caption store to notify map-caption component observer
   *
   * @function updateAttribution
   * @param {Attribution} newAttribution incoming new attribution
   */
  updateAttribution(newAttribution) {
    const esriText = {
      disabled: false,
      value: this.$iApi.$i18n.t(`caption.attributionDefaultText`)
    };
    const esriLogo = {
      disabled: false,
      altText: this.$iApi.$i18n.t(`caption.attributionLogoAltText`),
      link: this.$iApi.$i18n.t(`caption.attributionLink`),
      value: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEEAAAAkCAYAAADWzlesAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAADO9JREFUeNq0Wgl0jlca/pfvzyo6qNBSmhLLKE1kKEUtB9NTat+OYnBacwwJY19DZRC7sR41th60lWaizFSqRTOEw0lsrQSJGFIESSxJ/uRfv3nef+7Vt9f3p2E695z3fMt97/3ufe+7PO+9n9n0UzELsjKyiHdUdMZnVHTl2VyFe9nO7Kc/Io+4epUxmpWxeVkbr3hvUebgFf15GL9XUwZHndtAAYI09jGvIghOuoEwLOLeYiBoXrwGfZjYYOWAvWyMGlsk2YebXeV3NUEW1qcT5BBX4jUbCYEmHwwKEfdW1gEXgoWtiIlNRFeezcrkrQaTNSuraRYDdImrR1ylAALZBPnkXIJ0wRskeG2Cj3jsoFI2HhcfDDFWA9UBNdZZyc/PP4Z3HZYsWTLGbrffond0Xb9+/Qy6P3jw4F+HDx8+mu7XrVs3c+7cuX+i+3nz5o3n/Rw4cGAdf/7hhx9SZ8yYEcffHT9+/G/8uaSkJGvDhg3D8P3moNdXrlw5UtYVFxfnXL9+/V8PHz68grr2N2/eTC4tLb2E+9+Cotq1a/dOenr6njt37nxPdOrUqd0dO3bsjromoHBQKBPkEyFUB71MH6SPbNy4cRqfkMvlenzixImtqO/x3XffbXc6nSW5ubnpOTk5J1NTU/cQH91//fXXu3/88ccLy5cvj6d34B8gaBA9JyQk/OWjjz5aIu8Fz2DiWbZs2QLx/A4m0Qf9f/n48eNsPEeDfrdly5Y/U31UVNT7dJ04ceIsGseNGzfS6DkuLq4v8YE6Y/G+93g8XKZ6QUHBRVHfAPQC0xJfCRAv65EkeUP6gFx11JEkfw/qTc8ff/zxKofDUXrv3r08rOIBeU9CWbx48SLej5y4LGlpaf9YuHDhUv5OtqH+6Vty0riPAbWjheH8n3322VYpuG+//Xa5mGB7CGM8hKN7vV5dLfHx8WNI20E1aN4WP97YZyc7d+6MM5vNHRs2bDg3NjY23e12l5w8eZJWzIUJ9IdmlI4bNy4tICAgtHbt2hGdOnXaSe3oftu2bWmBgYFOn3MwmwcQLViwIJOeYVYJGGAZVuW2zWZzCZ6hoIGapnmknUMTQnr16vUeTOKydHqyHrx9t27dunro0KEfzJw5M4Pe3bp166Z0pHXr1g0Fj2EYCw8PD+N+SjNwUuSAKnxexOkswOWxZN63b9/MAQMGzIUwx5WXl99eunTpFLx+hJU/K9o/yM7OPhgZGdk5KSkpp0WLFv+Vrq7/na5nz57dR1dM6t7hw4e3DRkyJG7WrFlxgudzukIw58TzV3SF3Z+ByUzFbTk5O9j8fVH/JV3PnTv3uRijSdSR5/empKRkT5kypQxCC+UTxMKVQXuyWBT5WbiS4VFjIZLHWQsLN1ZFgFbm0U1KSNWUUMlDp9kAh0iNdCkRwiva2FjUsjJeJ5sYRYQwCGIYNGk8tC1UCuDQoUOb+vbtuxuPRUJ4FVwIFhZ7pUD45OXEbUpo9DIz8hgAFk0BORblWypm8BiQzkKnpoRnM+PxsEWhiYfFxMTUHTx4cDOYhg7tzM7IyLhNCiYEUEbCMxsAGYuCGjl4ClKE4GY+xCnIw95zBKqxvmyCOJqT7dws5ntZzLcoaJEjQiPUahMaESzudWEqhBEeiSuZvUvzA1+lxIMEhbD7QGYKUl0rBAgxC9vlq6IzNZZ9BYt+rMw8pBDLmSZZFBPQmBC8imaofo1roa5oKH82aQaaIH0CDTZM0sCBAxvBKbZ+7bXXGr3yyisN4ZjMDx48uAeAkofQdHbt2rUXhIpJKevMJwSLfqq3bt365enTp3eFh365SZMmBGpMFRUVZcAV1wFmzs2ZMyddtCkXk9ESExOjq1Wr9iLCbwAilA9xwrnlwimS4G2ffvppj1atWrWoWbNmbWCKAtj9V5MnT84cMWJEvTfeeKM+wqSFzCEoKMgJ3HEVgO6SkTlKMwgUgImwArn2DpMmTYrDALP0XyjEA9sbjTZtQZGij7qghqBWoK4AWPswkbLK+qHIsWPHjoXgfwvUhsZAAEflg+dfg0kuBlosUuvoO2jXl65qXWZm5g7UNRPIOIQLQqpcmECMJIAuRp1UVmiCACmTxAReFx+LhnPqV1hY+O9n6evIkSObSXCEHI0WASDtMMJ0uVHb7du3E6p9HxpxQK0DjN4r0Gc9kSZYeZiSNkuaUOv06dPTO3fuPNj0DAWgKWTFihVL+vfvT0J8kfohAsobV6tWrYbP0hf460pnLE2AF2jB21DvIKO2gO6FNB+ERJtaB+xjY37NN3+LogmkHi9s2rTp3bZt277LG8NuK5AopXbv3n0O7Gtsjx49ZmNye6GOD1RBwD9MFUKoSQSc30UdzJUrV26uWrVqP7D/lt27d+9/9OhRMas7gjYbhROzkv9R2wcHBwdWshjkYL1G7SBQTXGwTwQQLLIqWsGeGFAhVyFSO6C7Naj7ADRUJENDQGMjIiLmQl0LVLUbNWrUItSPhBNcodYhFyFklwAiYf0RNKZZs2YfFhUVXYcAvhFm0FFc++fl5eX4Mxto7JnRo0cvID4yHWSz70dHRw+khAxZ6yGVH8ndftS9DWokciWNx15fTN2zZ0+f6tWr1+LS279/fwYgcz4LPzJvdyGVLUFidFiVOIRAqx8KlQysZCdKboJUXL58uRAmMLFp06aLRbh1cGhrVEiD3nzzzTXIcU5R6gC6vXfv3kuIGgSIyq1Wq6cqpmdhiNAXFtu0adNeZVq9enUWA0xywyVECC4AicwttQ2SrvpkYnfv3i1X6xo0aPAiJv2H+fPnt27UqFEN4YsCDBCk33Lt2rW8kSNHJuP2LqUc4kq+4KFAgg6LxeKtSl+a4hMC6tSp85QD27VrVy9I1U2SJaKYS/ZG8Rf5uhVXq91ud4aEhATINo0bN46glUQMv4aQV46MMpj3iRVvsGjRohFEENQtygCRmZ5B6DsqNNPFANJT5cyZM5RoPRBE/qREaJYEYm4aZ1WFwDG9ppoClebNm9czPV/xYXOo6J4xY8Z84I8Jgq9HBCDVfsKECR+mpqZ+gSQnRVQHGTm4CxcuXBP9l4qrneUNPtheVSFYKtkF/jUKqWbx2LFjUxBJViA82asSZvv06TPq+PHjE/D4GzI70jiVT+xDyBzDo8DhZyoWNXsD4Cn/FYVQLKgIofCfMIkhgKyr4bhO8pBoVGgvsEuXLq+SEIw0Qayyl5H+vIPUmJf2ZYOwz5twXE05U/369TfBZu+wvMBpkH7L3dwyYZ+l4uoRPL50FzCcQuAJstvIyMjacG5Rw4YN64b7V9XBxcbGdgJq/cZIE4TT0/2ceTyzJsiMj0JSxfnz50+rTECBUUq2aGd2WC7Izib+WFwdLJs0sczT1w+Q3d34+PhTSKQ2w4GeVL9LTtefY1Q2YEz/qxC8LIe3f/LJJ2kqU79+/WIGDRpUj+0L8N0lG7B6N+QGiS1btgxR9ha8gi949uzZ0UiENgBSR4iQyFNiL0zkrh+V/78XfjJDq1aWnJx85dixY8kqRE1KSopNSUkZ0K1btwjhsGpMmzatbVZW1nTy/JQbQHUXA26HMRul/gOQHkcBUK1BBGiJFHgtcMV7YqeXeEM7dOhQB4lXh6dCS1kZaZbDSBjinV6ZhsBkdAMz0o00SO4hhIrUl7K/7vfv37+hP0eBw8tBftFRpNNNExMThyMqlKp8SEXsADy5t1GM+qF6CHwe+hifm5t7Ta1PSEiYj7rWIhsMZaCPEkDyL+2PHj36hdqO3lGd4KkuYbN0jC5h22TPRT179pwCZ5j9rKqF0FWtd+/eL0kBA9Y2kRudvBB4og2al1CM+iFsgQFfJTCkaZrboL2DhUfd4NjAadROvHPyvUsLayxNghxaMWw0D1EhFiguqSrxXWZ/EN7IyZMnX5QHn127dk0Gxo+nnd6q9EHf2rx58zJgC1oxSrQKgR1cKl9YWJhdOFg329TlC1oBM3YYZJ8OubcozVZTJPjkzEEwOBGr1yIr+xz23xX23i48PPxVjiqRQV6GRuetXLkSbiPpCsPuTulzEAYPAh+cnzp1ao+YmJi31D5gevkwo3sZGRmn0M+RzMzMAhFtaGG0ixcvfpmfn39WbpNBC1zILK8KHqdykCsXszQ7O/sE8WMBNKGlbrxLF1HsSeQyV5JQBSrJUghLdDQmKB46ywTJFTKzfqqxftScwM1OjGXY/Vl0UU7IHcq3XMrutkz0QsX3bOwEWo5TfsNj9hMxjP5VCFR2fPl/AS4xMH7u71X6CWR92JQjer5t72AHLrpyKGRRhKbCZrNybhJg8HvBU+385Qv8DMKi/BjBEaKuHJK42YDU/x789cFhu1s5cFH/hTAp3/UqhzMm5cTM6G8br/qnyi8lTWYDoZiUP1TUEyc1Ble1D5OSA+gG7U0GR3b+fhUy+kVIN0Kb/xFgANrk0XIqRaL0AAAAAElFTkSuQmCC"
    };
    const attribution = {
      text: {
        value: "",
        disabled: false
      },
      logo: {
        disabled: false,
        altText: "",
        link: "",
        value: ""
      }
    };
    if (newAttribution) {
      if (!newAttribution.logo) {
        attribution.logo.altText = esriLogo.altText;
        attribution.logo.link = esriLogo.link;
        attribution.logo.value = esriLogo.value;
      } else if (!newAttribution.logo.disabled) {
        attribution.logo.altText = newAttribution.logo.altText || esriLogo.altText;
        attribution.logo.link = newAttribution.logo.link || esriLogo.link;
        attribution.logo.value = newAttribution.logo.value || esriLogo.value;
      } else {
        attribution.logo.disabled = true;
      }
      if (!newAttribution.text) {
        attribution.text.value = esriText.value;
      } else if (!newAttribution.text.disabled) {
        attribution.text.value = newAttribution.text.value || esriText.value;
      } else {
        attribution.text.disabled = true;
      }
      const mapCaptionStore = useMapCaptionStore(this.$vApp.$pinia);
      mapCaptionStore.setAttribution(attribution);
    } else {
      attribution.logo.altText = esriLogo.altText;
      attribution.logo.link = esriLogo.link;
      attribution.logo.value = esriLogo.value;
      attribution.text.value = esriText.value;
    }
    if (!newAttribution || newAttribution.text?.disabled || !newAttribution.text) {
      if (!this.$iApi.geo.map.esriMap) {
        console.warn("Attempted to fetch map attribution with undefined map");
        return;
      }
      let copyrightText = "";
      const loadTimeout = 5e3;
      const intervalTimeout = 20;
      const baseLayerLoadPromises = this.$iApi.geo.map.esriMap.basemap.baseLayers.map((bl) => {
        return new Promise((resolve) => {
          let elapsedIntervals = 0;
          const maxIntervals = loadTimeout / intervalTimeout;
          const wait = setInterval(function() {
            if (bl.loaded && !bl.loadError) {
              clearInterval(wait);
              resolve(bl);
            } else if (elapsedIntervals > maxIntervals) {
              clearInterval(wait);
              resolve(null);
            }
            elapsedIntervals++;
          }, intervalTimeout);
        });
      }).toArray();
      Promise.all(baseLayerLoadPromises).then((baseLayers) => {
        copyrightText = baseLayers.filter((bl) => bl?.copyright).map((bl) => bl.copyright).join(" | ");
        attribution.text.value = copyrightText || attribution.text.value || esriText.value;
        const mapCaptionStore = useMapCaptionStore(this.$vApp.$pinia);
        mapCaptionStore.setAttribution(attribution);
      });
    }
  }
  /**
   * Calculates a scale bar for the current resolution
   * Updates map-caption store to notify map-caption component observer
   *
   * @function updateScale
   */
  updateScale() {
    const mapCaptionStore = useMapCaptionStore(this.$vApp.$pinia);
    const currentScaleBar = mapCaptionStore.scale;
    if (currentScaleBar?.disabled) {
      return;
    }
    const isImperialScale = currentScaleBar?.isImperialScale || false;
    const scaleInfo = this.scaleHelper().find((h) => h.isImperialScale === isImperialScale) ?? {
      isImperialScale: false,
      units: "error",
      pixels: 1,
      distance: 1
    };
    mapCaptionStore.scale = {
      width: `${scaleInfo.pixels}px`,
      label: `${this.$iApi.$i18n.n(scaleInfo.distance, "number")}${scaleInfo.units}`,
      isImperialScale
    };
  }
  /**
   * Formats the map point using the selected formatting function
   * Returns empty string if point is undefined
   *
   * @param { Point | undefined } p the cursor map point
   * @returns { Promise<string> } the formatted string of the map point
   */
  async formatPoint(p) {
    if (!p) {
      return "";
    }
    return await this.pointFormatter(p);
  }
  /**
   * Sets the current point formatter
   * Will accept the string id of a default formatter, or a new formatter with the correct formatter signature
   *
   * If given string id is not valid, then the point formatter is not changed
   *
   * @function setPointFormatter
   * @param {string | ((p: Point) => Promise<string>)} value
   */
  setPointFormatter(value) {
    if (typeof value === "string") {
      if (!(value in this.DEFAULT_POINT_FORMATTERS)) {
        console.warn(`Could not find point formatter with id: ${value}`);
        return;
      }
      this.pointFormatter = this.DEFAULT_POINT_FORMATTERS[value];
    } else {
      this.pointFormatter = value;
    }
  }
  /**
   * Generates helpful information to be used when constructing scale bars.
   * @returns { Array<ScaleHelper> } two objects with information for metric and imperial
   */
  scaleHelper() {
    const factor = window.innerWidth > 600 ? 70 : 35;
    const mapResolution = this.$iApi.geo.map.getResolution();
    const result = [];
    const meters = mapResolution * factor;
    const metersInAMile = 1609.34;
    const metersInAFoot = 3.28084;
    const measureUnits = meters > 1e3 ? ["km", "mi"] : ["m", "ft"];
    for (let i = 0; i < 2; i++) {
      const isImperialScale = i === 1;
      result.push({
        isImperialScale,
        units: measureUnits[i],
        pixels: 0,
        distance: 0
      });
      if (meters > 1e3) {
        const units = mapResolution * factor / (isImperialScale ? metersInAMile : 1e3);
        const len = Math.round(units).toString().length;
        const div = Math.pow(10, len - 1);
        result[i].distance = Math.ceil(units / div) * div;
        result[i].pixels = result[i].distance * (isImperialScale ? metersInAMile : 1e3) / mapResolution;
      } else {
        result[i].distance = Math.ceil(isImperialScale ? meters * metersInAFoot : meters);
        result[i].pixels = meters / mapResolution;
      }
    }
    return result;
  }
  /**
   * Wraps value between the minimum and maximum value
   * If value is between bounds, it will be returned as it is
   *
   * @function wrapValue
   * @private
   * @param {Number} val value to be wrapped
   * @param {Number} min minimum value
   * @param {Number} max maximum value
   * @return {Number} the wrapped value
   */
  wrapValue(val, min, max) {
    return ((val - min) % (max - min) + (max - min)) % (max - min) + min;
  }
  /**
   * Formats a lat/long DMS string using mouse map point coordinates
   *
   * @function formatLatLongDMSString
   * @param {Point | undefined} p the cursor map point
   * @returns {Promise<string>} the formatted string using given cursor map coordinates
   */
  async formatLatLongDMS(p) {
    const latLongPoint = await this.$iApi.geo.proj.projectGeometry(4326, p);
    const lat = this.wrapValue(latLongPoint.y, -90, 90);
    const lon = this.wrapValue(latLongPoint.x, -180, 180);
    const degreeSymbol = String.fromCharCode(176);
    const dy = Math.floor(Math.abs(lat)) * (lat < 0 ? -1 : 1);
    const my = Math.floor(Math.abs((lat - dy) * 60));
    const sy = Math.floor((Math.abs(lat) - Math.abs(dy) - my / 60) * 3600);
    const dx = Math.floor(Math.abs(lon)) * (lon < 0 ? -1 : 1);
    const mx = Math.floor(Math.abs((lon - dx) * 60));
    const sx = Math.floor((Math.abs(lon) - Math.abs(dx) - mx / 60) * 3600);
    return `${this.$iApi.$i18n.n(Math.abs(dy), "number")}${degreeSymbol} ${this.$iApi.$i18n.n(my, "number", {
      minimumIntegerDigits: 2
    })}' ${this.$iApi.$i18n.n(sy, "number", {
      minimumIntegerDigits: 2
    })}" ${this.$iApi.$i18n.t("map.coordinates." + (lat > 0 ? "north" : "south"))} | ${this.$iApi.$i18n.n(
      Math.abs(dx),
      "number"
    )}${degreeSymbol} ${this.$iApi.$i18n.n(mx, "number", {
      minimumIntegerDigits: 2
    })}' ${this.$iApi.$i18n.n(sx, "number", {
      minimumIntegerDigits: 2
    })}" ${this.$iApi.$i18n.t("map.coordinates." + (0 > lon ? "west" : "east"))}`;
  }
  /**
   * Formats a lat/long DDM string using mouse map point coordinates
   *
   * @function formatLatLongDDM
   * @param {Point | undefined} p the cursor map point
   * @returns {Promise<string>} the formatted string using given cursor map coordinates
   */
  async formatLatLongDDM(p) {
    const latLongPoint = await this.$iApi.geo.proj.projectGeometry(4326, p);
    const lat = this.wrapValue(latLongPoint.y, -90, 90);
    const lon = this.wrapValue(latLongPoint.x, -180, 180);
    const degreeSymbol = String.fromCharCode(176);
    const dy = Math.floor(Math.abs(lat)) * (lat < 0 ? -1 : 1);
    const my = Math.abs((lat - dy) * 60);
    const dx = Math.floor(Math.abs(lon)) * (lon < 0 ? -1 : 1);
    const mx = Math.abs((lon - dx) * 60);
    return `${this.$iApi.$i18n.n(Math.abs(dy), "number")}${degreeSymbol} ${this.$iApi.$i18n.n(my, "number", {
      minimumIntegerDigits: 2,
      minimumFractionDigits: 5,
      maximumFractionDigits: 5
    })} ${this.$iApi.$i18n.t("map.coordinates." + (lat > 0 ? "north" : "south"))} | ${this.$iApi.$i18n.n(
      Math.abs(dx),
      "number"
    )}${degreeSymbol} ${this.$iApi.$i18n.n(mx, "number", {
      minimumIntegerDigits: 2,
      minimumFractionDigits: 5,
      maximumFractionDigits: 5
    })} ${this.$iApi.$i18n.t("map.coordinates." + (0 > lon ? "west" : "east"))}`;
  }
  /**
   * Formats a lat/long DD string using mouse map point coordinates
   *
   * @function formatLatLongDD
   * @param {Point | undefined} p the cursor map point
   * @returns {Promise<string>} the formatted string using given cursor map coordinates
   */
  async formatLatLongDD(p) {
    const latLongPoint = await this.$iApi.geo.proj.projectGeometry(4326, p);
    const lat = this.wrapValue(latLongPoint.y, -90, 90);
    const lon = this.wrapValue(latLongPoint.x, -180, 180);
    const degreeSymbol = String.fromCharCode(176);
    const dy = Math.abs(lat);
    const dx = Math.abs(lon);
    return `${this.$iApi.$i18n.n(dy, "number", {
      minimumIntegerDigits: 2,
      minimumFractionDigits: 5,
      maximumFractionDigits: 5
    })}${degreeSymbol} ${this.$iApi.$i18n.t(
      "map.coordinates." + (lat > 0 ? "north" : "south")
    )} | ${this.$iApi.$i18n.n(dx, "number", {
      minimumIntegerDigits: 2,
      minimumFractionDigits: 5,
      maximumFractionDigits: 5
    })}${degreeSymbol} ${this.$iApi.$i18n.t("map.coordinates." + (0 > lon ? "west" : "east"))}`;
  }
  /**
   * Formats a mercator point string using mouse map point coordinates
   *
   * @function formatMercator
   * @param {Point | undefined} p the cursor map point
   * @returns {Promise<string>} the formatted string using given cursor map coordinates
   */
  async formatMercator(p) {
    const projectedPoint = await this.$iApi.geo.proj.projectGeometry(102100, p);
    return `${this.$iApi.$i18n.n(
      Math.floor(projectedPoint.x),
      "number"
    )} m | ${this.$iApi.$i18n.n(Math.floor(projectedPoint.y), "number")} m`;
  }
  /**
   * Formats a lambert point string using mouse map point coordinates
   *
   * @function formatLambert
   * @param {Point | undefined} p the cursor map point
   * @returns {Promise<string>} the formatted string using given cursor map coordinates
   */
  async formatLambert(p) {
    const projectedPoint = await this.$iApi.geo.proj.projectGeometry(3978, p);
    return `${this.$iApi.$i18n.n(Math.abs(Math.floor(projectedPoint.x)), "number")} m ${this.$iApi.$i18n.t(
      "map.coordinates." + (0 > projectedPoint.x ? "west" : "east")
    )} | ${this.$iApi.$i18n.n(Math.abs(Math.floor(projectedPoint.y)), "number")} m ${this.$iApi.$i18n.t(
      "map.coordinates." + (projectedPoint.y > 0 ? "north" : "south")
    )}`;
  }
  /**
   * Formats a UTM string using mouse map point coordinates
   *
   * @function formatUTM
   * @param {Point | undefined} p the cursor map point
   * @returns {Promise<string>} the formatted string using given cursor map coordinates
   */
  async formatUTM(p) {
    const latLongPoint = await this.$iApi.geo.proj.projectGeometry(4326, p);
    const lat = this.wrapValue(latLongPoint.y, -90, 90);
    const lon = this.wrapValue(latLongPoint.x, -180, 180);
    const zone = Math.ceil((lon + 180) / 6);
    const projectedPoint = await this.$iApi.geo.proj.projectGeometry(parseInt("326" + zone), p);
    return `${this.$iApi.$i18n.n(zone, "number", {
      minimumIntegerDigits: 2
    })} ${this.$iApi.$i18n.t("map.coordinates." + (lat > 0 ? "north" : "south"))} ${this.$iApi.$i18n.n(
      Math.floor(projectedPoint.x),
      "number"
    )} m${this.$iApi.$i18n.t("map.coordinates.east")} | ${this.$iApi.$i18n.n(
      Math.abs(Math.floor(projectedPoint.y)),
      "number"
    )} m${this.$iApi.$i18n.t("map.coordinates.north")}`;
  }
  /**
   * Formats a string based on the current basemap projection using mouse map point coordinates
   *
   * @function formatBasemap
   * @param {Point | undefined} p the cursor map point
   * @returns {Promise<string>} the formatted string using given cursor map coordinates
   */
  async formatBasemap(p) {
    const projectedPoint = await this.$iApi.geo.proj.projectGeometry(this.$iApi.geo.map.getSR(), p);
    return `${this.$iApi.$i18n.n(projectedPoint.x, "number")} | ${this.$iApi.$i18n.n(projectedPoint.y, "number")}`;
  }
}

class MapAPI extends CommonMapAPI {
  // API for managing the maptip
  maptip;
  // API for managing map caption
  caption;
  /**
   * The throttle level for map mouse move events
   * @private
   */
  mapMouseThrottle;
  /**
   * Map wide defaults for layer times. Layers can override.
   */
  layerDefaultTimes = {
    // DEV NOTE these values get updated in createMap(). Using 0 here to avoid having defaults in two spots.
    draw: 0,
    load: 0,
    fail: 0
  };
  /**
   * @constructor
   * @param {InstanceAPI} iApi the RAMP instance
   */
  constructor(iApi) {
    super(iApi);
    this.maptip = new MaptipAPI(iApi);
    this.caption = new MapCaptionAPI(iApi);
    this.mapMouseThrottle = 0;
  }
  /**
   * Will generate the actual Map control objects and construct it on the page
   * @param {RampMapConfig} config the config for the map
   * @param {string | HTMLDivElement} targetDiv the div to be used for the map view
   */
  createMap(config, targetDiv) {
    this.setMapMouseThrottle(config.mapMouseThrottle ?? 0);
    this.trackFirstBasemap = true;
    super.createMap(config, targetDiv);
    this.layerDefaultTimes.draw = config.layerTimeDefault?.expectedDrawTime ?? 1e4;
    this.layerDefaultTimes.load = config.layerTimeDefault?.expectedLoadTime ?? 1e4;
    this.layerDefaultTimes.fail = config.layerTimeDefault?.maxLoadTime || 9e4;
    this.viewPromise.then(() => {
      this.$iApi.event.emit(GlobalEvents.MAP_CREATED);
    });
  }
  /**
   * Destroys the ESRI map. Typically called by internal system, use at your own risk.
   */
  destroyMap() {
    if (!this.esriMap || !this.esriView) {
      this.noMapErr();
      return;
    }
    this.$iApi.geo.layer.allLayersOnMap(false).map((l) => l.uid).forEach((l) => this.removeLayer(l));
    super.destroyMap();
    this.$iApi.event.emit(GlobalEvents.MAP_DESTROYED);
  }
  /**
   * Will generate a ESRI map view and add it to the page
   * Can optionally provide the basemap or basemap id to be used when creating the map view
   *
   * @protected
   * @param {string | Basemap | undefined} basemap the id of the basemap that should be used when creating the map view
   */
  createMapView(basemap) {
    const configStore = useConfigStore(this.$vApp.$pinia);
    const config = configStore.config.map;
    if (!config) {
      throw new Error("Attempted to create map view without a map config");
    }
    const bm = (typeof basemap === "string" ? this.findBasemap(basemap) : basemap) || this.findBasemap(config.initialBasemapId);
    const tileSchemaConfig = config.tileSchemas.find(
      (ts) => ts.id === bm.tileSchemaId
    );
    if (!tileSchemaConfig) {
      throw new Error(`Could not find tile schema for the given basemap id: ${bm.id}`);
    }
    const extentSetConfig = config.extentSets.find(
      (es) => es.id === tileSchemaConfig.extentSetId
    );
    if (!extentSetConfig) {
      throw new Error(`Could not find extent set with the given id: ${tileSchemaConfig.extentSetId}`);
    }
    this._rampExtentSet = ExtentSet.fromConfig(extentSetConfig);
    this._rampSR = this._rampExtentSet.sr.clone();
    const lodSetConfig = config.lodSets.find(
      (ls) => ls.id === tileSchemaConfig.lodSetId
    );
    if (!lodSetConfig) {
      throw new Error(`Could not find lod set with the given id: ${tileSchemaConfig.lodSetId}`);
    }
    this.esriView = markRaw(
      new EsriMapView({
        map: this.esriMap,
        container: this._targetDiv,
        constraints: {
          lods: lodSetConfig.lods,
          rotationEnabled: false
        },
        spatialReference: this._rampSR.toESRI(),
        extent: this._rampExtentSet.defaultExtent.toESRI(),
        navigation: {
          browserTouchPanEnabled: false
        },
        background: { color: bm.backgroundColour }
      })
    );
    this.esriView.ui.components = [];
    this.handlers.push({
      type: "extent",
      handler: this.esriView.watch("extent", (newval) => {
        if (newval) {
          const newExtent = this.$iApi.geo.geom.geomEsriToRamp(newval, "map_extent_event");
          this.$iApi.event.emit(GlobalEvents.MAP_EXTENTCHANGE, newExtent);
          this.$iApi.event.emit(GlobalEvents.FILTER_CHANGE, {
            extent: newExtent,
            filterKey: CoreFilter.EXTENT
          });
        }
      })
    });
    this.handlers.push({
      type: "scale",
      handler: this.esriView.watch("scale", (newval) => {
        this.$iApi.event.emit(GlobalEvents.MAP_SCALECHANGE, newval);
      })
    });
    this.handlers.push({
      type: "resize",
      handler: this.esriView.on("resize", (esriResize) => {
        this.$iApi.event.emit(GlobalEvents.MAP_RESIZED, {
          height: esriResize.height,
          width: esriResize.width
        });
      })
    });
    this.handlers.push({
      type: "click",
      handler: this.esriView.on("click", (esriClick) => {
        this.$iApi.event.emit(
          GlobalEvents.MAP_CLICK,
          this.$iApi.geo.geom.esriMapClickToRamp(esriClick, "map_click_point")
        );
      })
    });
    this.handlers.push({
      type: "double-click",
      handler: this.esriView.on("double-click", (esriClick) => {
        this.$iApi.event.emit(
          GlobalEvents.MAP_DOUBLECLICK,
          this.$iApi.geo.geom.esriMapClickToRamp(esriClick, "map_doubleclick_point")
        );
      })
    });
    this.handlers.push({
      type: "pointer-move",
      handler: this.esriView.on("pointer-move", this.createMouseMoveHandler())
    });
    this.handlers.push({
      type: "pointer-move-start",
      // emulate mouse move start event using debounce
      handler: this.esriView.on(
        "pointer-move",
        debounce(100, true, (esriMouseMove) => {
          this.$iApi.event.emit(
            GlobalEvents.MAP_MOUSEMOVE_START,
            this.$iApi.geo.geom.esriMapMouseToRamp(esriMouseMove)
          );
        })
      )
    });
    this.handlers.push({
      type: "pointer-move-end",
      // emulate mouse move end event using debounce
      handler: this.esriView.on(
        "pointer-move",
        debounce(100, (esriMouseMove) => {
          this.$iApi.event.emit(
            GlobalEvents.MAP_MOUSEMOVE_END,
            this.$iApi.geo.geom.esriMapMouseToRamp(esriMouseMove)
          );
        })
      )
    });
    this.handlers.push({
      type: "pointer-leave",
      handler: this.esriView.on("pointer-leave", (esriMouseLeave) => {
        setTimeout(
          () => {
            this.$iApi.event.emit(GlobalEvents.MAP_MOUSELEAVE, esriMouseLeave.native);
          },
          Math.max(this.mapMouseThrottle, 100) + 1
        );
      })
    });
    this.handlers.push({
      type: "pointer-down",
      handler: this.esriView.on("pointer-down", (esriMouseDown) => {
        this.$iApi.event.emit(GlobalEvents.MAP_MOUSEDOWN, esriMouseDown.native);
      })
    });
    this.handlers.push({
      type: "key-down",
      handler: this.esriView.on("key-down", (esriKeyDown) => {
        this.$iApi.event.emit(GlobalEvents.MAP_KEYDOWN, esriKeyDown.native);
        esriKeyDown.stopPropagation();
      })
    });
    this.handlers.push({
      type: "key-up",
      handler: this.esriView.on("key-up", (esriKeyUp) => {
        this.$iApi.event.emit(GlobalEvents.MAP_KEYUP, esriKeyUp.native);
        esriKeyUp.stopPropagation();
      })
    });
    this.handlers.push({
      type: "focus",
      handler: this.esriView.on("focus", (esriFocus) => {
        this.$iApi.event.emit(GlobalEvents.MAP_FOCUS, esriFocus.native);
      })
    });
    this.handlers.push({
      type: "blur",
      handler: this.esriView.on("blur", (esriBlur) => {
        this.$iApi.event.emit(GlobalEvents.MAP_BLUR, esriBlur.native);
      })
    });
    this.esriView.container.addEventListener("touchmove", (e) => {
      e.preventDefault();
    });
    this.esriView.watch("fatalError", () => {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            this.esriView?.tryFatalErrorRecovery();
            observer.disconnect();
          }
        });
      });
      observer.observe(this.esriView.container);
    });
    this.esriView.when(() => {
      this._viewPromise.resolveMe();
      this.created = true;
      this.applyBasemap(bm);
      if (tileSchemaConfig.recoveryBasemap?.basemapId) {
        const waitTime = tileSchemaConfig.recoveryBasemap.timeout ?? 8e3;
        if (waitTime > 0) {
          setTimeout(() => {
            if (this.trackFirstBasemap) {
              this.recoverBasemap(tileSchemaConfig.id);
            }
          }, waitTime);
        }
      }
    });
  }
  /**
   * Destroys the ESRI map view
   *
   * @protected
   */
  destroyMapView() {
    this.esriView?.container.removeEventListener("touchmove", (e) => {
      e.preventDefault();
    });
    super.destroyMapView();
  }
  /**
   * Sets the basemap to the basemap with the given id or the basemap object
   * Throws error if basemap could not be found
   *
   * @param {string | basemap} basemap the basemap id or object
   * @protected
   */
  applyBasemap(basemap) {
    if (!this.esriMap) {
      this.noMapErr();
      return;
    }
    const bm = typeof basemap === "string" ? this.findBasemap(basemap) : basemap;
    this.esriMap.basemap = toRaw(bm.esriBasemap);
    const configStore = useConfigStore(this.$vApp.$pinia);
    configStore.activeBasemapConfig = bm.config;
  }
  /**
   * Set the map's basemap to the basemap with the given id.
   * If the new basemap's tile schema differs from the current one, the map view will be refreshed
   *
   * The returned boolean indicates if the schema has changed.
   *
   * @param {string} basemapId the basemap id
   * @returns {boolean} indicates if the schema has changed
   */
  setBasemap(basemapId) {
    if (!this.esriView || !this.esriMap) {
      this.noMapErr();
      return false;
    }
    const configStore = useConfigStore(this.$vApp.$pinia);
    const bm = this.findBasemap(basemapId);
    const currentBasemp = configStore.activeBasemapConfig;
    const schemaChanged = currentBasemp.tileSchemaId !== bm.tileSchemaId;
    if (schemaChanged) {
      const center = this.getExtent().center();
      const scale = this.getScale();
      this._viewPromise = new DefPromise();
      this.created = false;
      this.$iApi.event.emit(GlobalEvents.MAP_REFRESH_START);
      this.destroyMapView();
      this.createMapView(bm);
      this.viewPromise.then(() => {
        this.$iApi.event.emit(GlobalEvents.MAP_REFRESH_END);
        this.$iApi.event.emit(GlobalEvents.MAP_BASEMAPCHANGE, {
          basemapId,
          schemaChanged
        });
        const newScale = this.findClosestScale(scale);
        this.$iApi.geo.proj.projectGeometry(this._rampSR, center).then((projPoint) => this.zoomMapTo(projPoint, newScale, false));
      });
    } else {
      this.applyBasemap(bm);
      this.esriView.background = new EsriColorBackground({
        color: new Colour(bm.backgroundColour).toESRI()
      });
      this.$iApi.event.emit(GlobalEvents.MAP_BASEMAPCHANGE, {
        basemapId,
        schemaChanged
      });
    }
    return schemaChanged;
  }
  /**
   * Will attempt to change to another basemap if the very first basemap failed.
   * If nothing is defined, will do nothing but manage our watching state.
   *
   * @param {string} basemapSchemaId the basemap schema id (where the fallback is defined)
   */
  recoverBasemap(basemapSchemaId) {
    if (!this.esriMap) {
      this.noMapErr();
    }
    this.trackFirstBasemap = false;
    const configStore = useConfigStore(this.$vApp.$pinia);
    const config = configStore.config.map;
    if (config) {
      const tileSchemaConfig = config.tileSchemas.find((ts) => ts.id === basemapSchemaId);
      if (tileSchemaConfig?.recoveryBasemap?.basemapId) {
        const fallbackBM = this.findBasemap(tileSchemaConfig.recoveryBasemap.basemapId);
        this.applyBasemap(fallbackBM);
      }
    }
  }
  /**
   * Registers a layer with the instance and attempts to add it to the the map.
   * The return value provides an async indicator if the map add was successful,
   * but the layer is registered regardless.
   * Optionally can specify the layer order index for map layers.
   *
   * @param {LayerInstance} layer the Ramp layer to add
   * @param {number | undefined} index optional order index to add the layer to
   * @returns {Promise<void>} a promise that resolves when the layer has been added to the map
   */
  addLayer(layer, index = void 0) {
    return new Promise((resolve, reject) => {
      if (!this.esriMap) {
        this.noMapErr();
        reject();
      }
      if (layer.initiationState !== InitiationState.INITIATING && layer.initiationState !== InitiationState.INITIATED && layer.layerState !== LayerState.ERROR) {
        layer.initiate();
      }
      if (layer.mapLayer && index === void 0) {
        const currentMapOrder = this.$iApi.geo.layer.layerOrderIds();
        if (layer.isCosmetic) {
          index = currentMapOrder.length;
        } else {
          const layerParty = this.$iApi.geo.layer.allLayers();
          let searching = true;
          for (let i = currentMapOrder.length - 1; i >= 0 && searching; i--) {
            const lTest = layerParty.find((l) => l.id === currentMapOrder[i]);
            if (lTest && !lTest.isCosmetic) {
              index = i + 1;
              searching = false;
            }
          }
          if (searching) {
            index = 0;
          }
        }
      }
      const layerStore = useLayerStore(this.$vApp.$pinia);
      layerStore.addLayer(layer, index);
      this.$iApi.event.emit(GlobalEvents.LAYER_REGISTERED, layer);
      const startTime = Date.now();
      let timeElapsed = 0;
      const layerWatcher = setInterval(() => {
        timeElapsed += 250;
        if (timeElapsed >= layer.expectedTime.fail || layer.layerState === LayerState.ERROR) {
          clearInterval(layerWatcher);
          if (layer.lastCancel < startTime) {
            console.error(`Failed to add layer: ${layer.id}.`);
          }
          reject();
        } else if (layer.initiationState === InitiationState.INITIATED && (layer.esriLayer || !layer.mapLayer)) {
          clearInterval(layerWatcher);
          if (layer.mapLayer) {
            this.insertToEsriMap(layer);
          } else {
            layer.onLoad();
          }
          resolve();
        }
      }, 250);
    });
  }
  /**
   * Utility method to insert a Map Layer into the ESRI map. The position in ESRI map
   * is derived from global order and what layers are currently in the map.
   *
   * @param {LayerInstance} layer the RAMP layer to insert. Must be a Map layer
   */
  insertToEsriMap(layer) {
    let esriNewIndex = 0;
    const globalInsertIndex = this.$iApi.geo.layer.getLayerPosition(layer.id) ?? -1;
    if (globalInsertIndex > 0) {
      const globalPositions = this.$iApi.geo.layer.layerOrderIds();
      const allLayers = this.$iApi.geo.layer.allLayers();
      for (let i = globalInsertIndex - 1; i > -1; i--) {
        const testLayerId = globalPositions[i];
        const matchLayer = allLayers.find((fl) => fl.id === testLayerId);
        if (matchLayer && matchLayer.esriLayer) {
          const testEsriIndex = this.esriMap.layers.indexOf(matchLayer.esriLayer);
          if (testEsriIndex > -1) {
            esriNewIndex = testEsriIndex + 1;
            break;
          }
        } else if (!matchLayer) {
          console.error("ESRI Layer insert encountered bad state. Layer likely inserted at bottom of map.");
        }
      }
    }
    if (globalInsertIndex > -1) {
      this.esriMap?.add(layer.esriLayer, esriNewIndex);
    }
  }
  /**
   * Reorders a layer on the map. The position is based on the instance layer order state
   * maintained by the LayerAPI.
   * If ignoreCosmetic is set, the index changes to a different basis. Essentially the
   * as if cosmetic layers did not exists in the layer order state.
   *
   * @param {LayerInstance} layer the RAMP layer to be moved. If a sublayer is passed, the parent will be reordered.
   * @param {number} index the RAMP layer index where the layer will be moved to
   * @param {boolean} ignoreCosmetic indicates if the index should ignore cosmetic layers
   */
  reorder(layer, index, ignoreCosmetic = false) {
    if (index < 0) {
      console.error("Negative index passed to map reorder");
      return;
    }
    if (!this.esriMap) {
      this.noMapErr();
      return;
    }
    if (layer.isSublayer) {
      layer = layer.parentLayer;
    }
    if (!layer.mapLayer) {
      console.error("Attempted to reorder a data layer");
      return;
    }
    const allLayers = this.$iApi.geo.layer.allLayers();
    let globalPositions = this.$iApi.geo.layer.layerOrderIds();
    if (ignoreCosmetic) {
      if (layer.isCosmetic) {
        return;
      } else if (index > 0) {
        const squashedLayers = globalPositions.filter((testId) => {
          const matchLayer = allLayers.find((fl) => fl.id === testId);
          if (matchLayer) {
            return !matchLayer.isCosmetic;
          } else {
            console.error("Layer reorder had critical error");
            return false;
          }
        });
        if (index >= squashedLayers.length) {
          console.error("non-cosmetic reorder index was too high");
          index = squashedLayers.length - 1;
        }
        index = globalPositions.indexOf(squashedLayers[index]);
      }
    } else if (index >= globalPositions.length) {
      console.error("reorder index was too high");
      index = globalPositions.length - 1;
    }
    const oldIndex = globalPositions.indexOf(layer.id);
    if (oldIndex === index) {
      return;
    }
    const layerStore = useLayerStore(this.$vApp.$pinia);
    layerStore.reorderLayer(layer, index);
    if (layer.esriLayer && this.esriMap.layers.indexOf(layer.esriLayer) > -1) {
      let esriNewIndex = 0;
      if (index > 0) {
        globalPositions = this.$iApi.geo.layer.layerOrderIds();
        for (let i = index - 1; i > -1; i--) {
          const testId = globalPositions[i];
          const matchLayer = allLayers.find((fl) => fl.id === testId);
          if (matchLayer && matchLayer.esriLayer) {
            const testEsriIndex = this.esriMap.layers.indexOf(matchLayer.esriLayer);
            if (testEsriIndex > -1) {
              const upDownOffset = index < oldIndex ? 1 : 0;
              esriNewIndex = testEsriIndex + upDownOffset;
              break;
            }
          } else if (!matchLayer) {
            console.error("Layer reorder had critical error");
          }
        }
      }
      this.esriMap.reorder(layer.esriLayer, esriNewIndex);
    }
    this.$iApi.event.emit(GlobalEvents.MAP_REORDER, {
      layer,
      newIndex: index
    });
  }
  /**
   * Removes a sublayer from the map
   *
   * @param {LayerInstance | string} layer the Ramp sublayer or sublayer id/uid to remove
   * @returns {Promise<void>} a promise that resolves when the layer has been removed from the map
   */
  removeSublayer(sublayer) {
    let uid;
    let layer;
    if (typeof sublayer === "string") {
      uid = sublayer;
      layer = this.$iApi.geo.layer.getLayer(uid);
    } else {
      if (!sublayer.isSublayer) {
        throw new Error(`Attempted to call removeSublayer on a non-sublayer object: ${sublayer}`);
      }
      uid = sublayer.uid;
      layer = sublayer;
    }
    if (!layer) {
      throw new Error("Sublayer could not be found for removal.");
    }
    layer.visibility = false;
    layer.isRemoved = true;
    this.$iApi.event.emit(GlobalEvents.LAYER_REMOVE, sublayer);
    if (layer.parentLayer?.sublayers.every((sub) => sub.isRemoved)) {
      this.removeLayer(layer.parentLayer);
    }
  }
  /**
   * Removes a layer from the map and fires the layer remove event.
   * This will also unregister the layer from the Ramp instance.
   *
   * @param {LayerInstance | string} layer the Ramp layer or layer id/uid to remove
   * @returns {Promise<void>} a promise that resolves when the layer has been removed from the map
   */
  removeLayer(layer) {
    if (!this.esriMap) {
      this.noMapErr();
      return;
    }
    let layerInstance = void 0;
    if (layer instanceof LayerInstance) {
      layerInstance = layer;
    } else {
      layerInstance = this.$iApi.geo.layer.getLayer(layer);
    }
    if (!layerInstance) {
      throw new Error("Layer could not be found for removal.");
    }
    if (layerInstance.isSublayer) {
      this.removeSublayer(layerInstance);
      return;
    }
    if (layerInstance.supportsSublayers) {
      layerInstance.sublayers.forEach((sl) => {
        if (!sl.isRemoved) {
          this.removeSublayer(sl);
        }
      });
    }
    const layerStore = useLayerStore(this.$vApp.$pinia);
    layerStore.removeLayer(layerInstance);
    layerStore.removeLayerConfig(layerInstance.id);
    layerInstance.removeEsriLayer();
    if (layerInstance.initiationState === InitiationState.INITIATED) {
      layerInstance.terminate();
    }
    layerInstance.isRemoved = true;
    this.$iApi.event.emit(GlobalEvents.LAYER_REMOVE, layerInstance);
  }
  /**
   * Set's the map's mapMouseThrottle value to newThrottle.
   * If newThrottle is not a positive number, a console error is thrown.
   *
   * The returned boolean indicates if the value has been successfully set.
   *
   * @param {number} newThrottle the new mapMouseThrottle value, which must be a positive number
   * @returns {boolean} indicates if the value was set successfully
   */
  setMapMouseThrottle(newThrottle) {
    if (newThrottle < 0) {
      console.error("Cannot set map mouse throttle to value that is less than 0.");
      return false;
    }
    this.mapMouseThrottle = newThrottle;
    const currIdx = this.handlers.findIndex((h) => h.type === "pointer-move");
    if (currIdx !== -1) {
      const currHandler = this.handlers[currIdx];
      this.handlers.splice(currIdx, 1);
      currHandler.handler.remove();
    }
    if (currIdx !== -1 && this.esriView) {
      this.handlers.push({
        type: "pointer-move",
        handler: this.esriView.on("pointer-move", this.createMouseMoveHandler())
      });
    }
    return true;
  }
  /**
   * Creates a throttled map mouse move handler.
   * Uses mapMouseThrottle for the throttle delay
   *
   * @returns the throttled handler function
   */
  createMouseMoveHandler() {
    if (!this.esriView) {
      this.noMapErr();
      return;
    }
    return throttle(this.mapMouseThrottle, (esriMouseMove) => {
      this.$iApi.event.emit(GlobalEvents.MAP_MOUSEMOVE, this.$iApi.geo.geom.esriMapMouseToRamp(esriMouseMove));
    });
  }
  /**
   * Zooms the map to a given zoom level. The center point will not change.
   * In the rare case where there is no basemap, this will likely do nothing
   *
   * @param {number} zoomLevel An integer matching the level of detail / zoom level the map should adjust to
   * @returns {Promise<void>} A promise that resolves when the map has finished zooming
   */
  async zoomToLevel(zoomLevel) {
    if (this.esriView) {
      return this.esriView.goTo({ zoom: zoomLevel });
    } else {
      this.noMapErr();
    }
  }
  /**
   * Zooms the map to the next zoom level in towards the earth. The center point will not change.
   * In the rare case where there is no basemap, this will likely do nothing
   *
   * @returns {Promise<void>} A promise that resolves when the map has finished zooming
   */
  async zoomIn() {
    if (this.esriView) {
      return this.zoomToLevel(this.esriView.zoom + 1);
    } else {
      this.noMapErr();
    }
  }
  /**
   * Zooms the map to the next zoom level out away from the earth. The center point will not change.
   * In the rare case where there is no basemap, this will likely do nothing
   *
   * @returns {Promise<void>} A promise that resolves when the map has finished zooming
   */
  async zoomOut() {
    if (this.esriView) {
      return this.zoomToLevel(this.esriView.zoom - 1);
    } else {
      this.noMapErr();
    }
  }
  /**
   * Zooms the map to the closest zoom level that will be visible for a given scale set.
   * Does nothing if scale set is already visible for the map.
   *
   * @returns {Promise<void>} A promise that resolves when the map has finished zooming
   */
  async zoomToVisibleScale(scaleSet) {
    if (!this.esriView) {
      this.noMapErr();
      return;
    }
    const offStatus = scaleSet.isOffScale(this.getScale());
    if (!offStatus.offScale) {
      return;
    }
    const lods = this.esriView.constraints.lods;
    if (!lods) {
      return this.zoomMapTo(this.getExtent().center(), offStatus.zoomIn ? scaleSet.minScale : scaleSet.minScale);
    }
    const modLods = offStatus.zoomIn ? lods : [...lods].reverse();
    const scaleLod = modLods.find(
      (currentLod) => offStatus.zoomIn ? currentLod.scale < scaleSet.minScale : currentLod.scale > scaleSet.maxScale
    ) || modLods[modLods.length - 1];
    return this.zoomToLevel(scaleLod.level);
  }
  /**
   * Finds the tile scale (level of detail) closest to the provided scale.
   * If using a map with no scale levels, will return the given scale.
   *
   * @function findClosestScale
   * @param  {Number} scale   scale value to search for in the levels of detail
   * @return {Number}         the level of detail scale closest to the input
   */
  findClosestScale(scale) {
    const lods = this.esriView?.constraints.lods;
    if (!lods) {
      return scale;
    }
    const diffs = lods.map((lod) => Math.abs(lod.scale - scale));
    const lodIdx = diffs.indexOf(Math.min(...diffs));
    return lods[lodIdx].scale;
  }
  /**
   * Create a screenshot of the current view.
   *
   * Possible ESRI takeScreenshot() options:
   * https://developers.arcgis.com/javascript/latest/api-reference/esri-views-MapView.html#takeScreenshot
   * Will default to quality = 1 and format = 'png'.
   *
   * @param {__esri.MapViewTakeScreenshotOptions} options ESRI takeScreenshot() options
   * @returns {Promise<Screenshot>} a promise that resolves with a Screenshot
   */
  async takeScreenshot(options) {
    if (this.esriView) {
      if (!options.quality) {
        options.quality = 1;
      }
      if (!options.format) {
        options.format = "png";
      }
      return this.esriView.takeScreenshot(options);
    } else {
      throw new Error("Export attempted without a map view available");
    }
  }
  /**
   * Get a point in map co-ordinates corresponding to a pixel in screen co-ordinates.
   *
   * @param {ScreenPoint} screenPoint pixel screen co-ord of the point on the map
   * @returns {Point} the map point analagous to the screen point
   */
  screenPointToMapPoint(screenPoint) {
    if (this.esriView) {
      return Point.fromESRI(
        this.esriView.toMap({
          x: screenPoint.screenX,
          y: screenPoint.screenY
        }),
        "mappoint"
      );
    } else {
      this.noMapErr();
      return new Point("i_am_error", [0, 0], void 0, true);
    }
  }
  /**
   * Get a pixel in screen co-ordinates corresponding to a point in map co-ordinates.
   *
   * @param {Point} mapPoint point on the map
   * @returns {ScreenPoint} the screen point analagous to the map point
   */
  mapPointToScreenPoint(mapPoint) {
    if (this.esriView) {
      const esriPoint = this.esriView.toScreen(mapPoint.toESRI());
      return { screenX: esriPoint.x, screenY: esriPoint.y };
    } else {
      this.noMapErr();
      return { screenX: 1, screenY: 1 };
    }
  }
  // pending https://github.com/ramp4-pcar4/ramp4-pcar4/issues/130
  // commenting out to avoid any undecided constants being exposed
  /*
  _identifyMode: IdentifyMode[] = [
      IdentifyMode.Query,
      IdentifyMode.Marker,
      IdentifyMode.Highlight,
      IdentifyMode.Haze,
      IdentifyMode.Details
  ];
  */
  // a note about modes and events.
  // depending if we choose to implement the old modes are come up with a new scheme,
  // there are two event handlers that are running stuff (see events.ts).
  // there is a map click event that then triggers the identify routine below
  // and there is the identify event, raised by the routine below, that then opens the details panel.
  // so the solution may need to either do some on/off'ing of the event handlers,
  // or we introduce some global flag variables that get referenced
  // (e.g. dont run identify could be a first line in the function below: if api.noIdentify then return )
  // global flags MIGHT be safer, as it doesn't have to assume the default handlers are in play.
  // i.e. if someone did some event modding for custom results, and we have core code then swapping
  //      default event handlers, would be a mess.
  /**
   * Performs an identify request on all layers that support identify, and combines the results.
   *
   * @param {MapClick | Point} targetPoint the place on the map to execute the identify
   * @memberof MapAPI
   * @returns {MapIdentifyResult} results of the identify
   */
  runIdentify(targetPoint) {
    const layers = this.$iApi.geo.layer.allLayersOnMap(false).filter((l) => l.canIdentify());
    let mapClick;
    if (targetPoint instanceof Point) {
      const screenPoint = this.mapPointToScreenPoint(targetPoint);
      mapClick = {
        mapPoint: targetPoint,
        screenX: screenPoint.screenX,
        screenY: screenPoint.screenY,
        button: 0,
        input: "mouse",
        clickTime: Date.now()
      };
    } else {
      mapClick = targetPoint;
    }
    if (layers === void 0) {
      return { click: mapClick, results: [] };
    }
    let hitTestProm = Promise.resolve([]);
    if (layers.some((l) => {
      return l.identifyMode === LayerIdentifyMode.HYBRID || l.identifyMode === LayerIdentifyMode.SYMBOLIC;
    })) {
      hitTestProm = this.esriView.hitTest({
        x: mapClick.screenX,
        y: mapClick.screenY
      }).then((hitResults) => {
        return hitResults.results.map((hr) => {
          return {
            layerId: hr.layer.id,
            layerIdx: 0,
            // not required for this process, default rather than expensive lookup
            oid: hr.graphic.getObjectId()
          };
        });
      });
    }
    const p = {
      geometry: mapClick.mapPoint,
      hitTest: hitTestProm
    };
    const identifyResults = layers.filter((layer) => layer.supportsIdentify).map((layer) => {
      p.tolerance = mapClick.input == "touch" ? layer.touchTolerance : layer.mouseTolerance;
      return layer.runIdentify(p);
    }).flat();
    const timestamp = Date.now();
    identifyResults.forEach((item) => {
      item.requestTime = timestamp;
    });
    const fullResult = {
      results: identifyResults,
      click: mapClick
    };
    this.$iApi.event.emit(GlobalEvents.MAP_IDENTIFY, fullResult);
    return fullResult;
  }
  /**
   * Get the top-most graphic at the given screen point
   * Returns undefined if there is no graphic
   *
   * @param {ScreenPoint} screenPoint The screen coordinates to inspect
   * @returns {Promise<GraphicHitResult | undefined>} resolves with topmost graphic or undefined
   */
  async getGraphicAtCoord(screenPoint) {
    if (!this.esriView) {
      this.noMapErr();
      return;
    }
    const layers = this.$iApi.geo.layer.allLayersOnMap(false).filter((l) => l.supportsFeatures || l.layerType === LayerType.GRAPHIC);
    if (layers.length === 0) {
      return;
    }
    const hitTest = await this.esriView.hitTest({
      x: screenPoint.screenX,
      y: screenPoint.screenY
    });
    if (hitTest.results.length === 0) {
      return;
    }
    const hitResults = hitTest.results;
    let hitLayer;
    let topGraphic;
    const dupeSet = /* @__PURE__ */ new Set();
    hitResults.some((gHit) => {
      if (dupeSet.has(gHit.layer.id)) {
        return false;
      }
      const layerHunt = layers.find((l) => l.id === gHit.layer.id);
      if (layerHunt) {
        if (!layerHunt.isCosmetic && layerHunt.layerType !== LayerType.GRAPHIC) {
          hitLayer = layerHunt;
          topGraphic = gHit.graphic;
        }
        return true;
      } else {
        dupeSet.add(gHit.layer.id);
        return false;
      }
    });
    if (hitLayer && topGraphic) {
      return {
        oid: topGraphic.getObjectId(),
        layerId: hitLayer.id,
        layerIdx: hitLayer.layerIdx
      };
    }
  }
  // -------
  // Key Handler Fun
  // -------
  // list of keys that are currently pressed
  _activeKeys = [];
  // ID of pan interval
  _panInterval;
  // true if map is focused using mouse click
  _mouseFocus = false;
  /**
   * Processes keydown event on map and initiates panning/zooming
   *
   * @param {KeyboardEvent} payload
   * @memberof MapAPI
   */
  mapKeyDown(payload) {
    const zoomKeys = ["=", "-"];
    const panKeys = ["Shift", "Control", "ArrowDown", "ArrowLeft", "ArrowRight", "ArrowUp"];
    if (panKeys.includes(payload.key) && !this._activeKeys.includes(payload.key)) {
      this._activeKeys.push(payload.key);
      if (!this._activeKeys.some((k) => zoomKeys.includes(k))) {
        this.keyPan();
      }
    } else if (zoomKeys.includes(payload.key) && !this._activeKeys.includes(payload.key)) {
      this._activeKeys.push(payload.key);
      this.keyZoom(payload);
    } else if (payload.key === "Enter") {
      this.runIdentify(this.getExtent().center());
    } else if (payload.key === "Tab") {
      this._activeKeys.push(payload.key);
    }
  }
  /**
   * Processes keyup event on map and deactivates key
   *
   * @param {KeyboardEvent} payload
   * @memberof MapAPI
   */
  mapKeyUp(payload) {
    const zoomKeys = ["=", "-"];
    if (this._activeKeys.includes(payload.key) && !zoomKeys.includes(payload.key)) {
      this._activeKeys.splice(this._activeKeys.indexOf(payload.key), 1);
      if (!this._activeKeys.some((k) => zoomKeys.includes(k))) {
        this.keyPan();
      }
    }
  }
  /**
   * Sets the map focus source from the mouse
   *
   * @memberof MapAPI
   */
  setMouseFocus() {
    this._mouseFocus = true;
  }
  /**
   * Stops panning and deactivates all keys
   *
   * @memberof MapAPI
   */
  stopKeyPan() {
    if (this._activeKeys.includes("Tab")) {
      this._mouseFocus = false;
    }
    this._activeKeys = [];
    clearInterval(this._panInterval);
  }
  /**
   * Returns if keys are active on map
   *
   * @memberof MapAPI
   * @returns {boolean} - true if any pan/zoom keys are active
   */
  get keysActive() {
    return this._activeKeys.filter((k) => !["Control", "Shift"].includes(k)).length !== 0;
  }
  /**
   * Returns if map focus is caused by mouse click
   *
   * @memberof MapAPI
   * @returns {boolean}
   */
  get mouseFocus() {
    return this._mouseFocus;
  }
  /**
   * Pauses pan interval to process zoom from keyboard
   *
   * @param {KeyboardEvent} payload
   * @memberof MapAPI
   * @private
   */
  async keyZoom(payload) {
    clearInterval(this._panInterval);
    if (payload.key === "=") {
      await this.zoomIn();
    } else if (payload.key === "-") {
      await this.zoomOut();
    }
    this._activeKeys.splice(this._activeKeys.indexOf(payload.key), 1);
    this.keyPan();
  }
  /**
   * Starts/restarts panning with active keys
   *
   * @memberof MapAPI
   * @private
   */
  keyPan() {
    clearInterval(this._panInterval);
    if (!this.keysActive) {
      return;
    }
    const center = this.getExtent().center();
    const screenCenter = this.mapPointToScreenPoint(center);
    const p = this.screenPointToMapPoint({
      screenX: screenCenter.screenX + 5,
      screenY: screenCenter.screenY + 5
    });
    const xDiff = Math.abs(p.x - center.x);
    const yDiff = Math.abs(p.y - center.y);
    let dx = 0;
    let dy = 0;
    let multiplier = 1;
    for (let i = 0; i < this._activeKeys.length; ++i) {
      switch (this._activeKeys[i]) {
        case "ArrowLeft":
          dx -= xDiff;
          break;
        case "ArrowRight":
          dx += xDiff;
          break;
        case "ArrowUp":
          dy += yDiff;
          break;
        case "ArrowDown":
          dy -= yDiff;
          break;
        case "Shift":
          multiplier = 2;
          break;
        case "Control":
          multiplier = 0.25;
          break;
      }
    }
    const scale = this.getScale();
    this._panInterval = setInterval(() => {
      center.x += multiplier * dx;
      center.y += multiplier * dy;
      this.zoomMapTo(center, scale, false);
    }, 25);
  }
}

const circlePoint = {
	geometryType: "point",
	renderer: {
		type: "simple",
		symbol: {
			type: "esriSMS",
			style: "esriSMSCircle",
			color: [
				67,
				100,
				255,
				200
			],
			size: 7,
			outline: {
				color: [
					0,
					0,
					0,
					255
				],
				width: 1
			}
		}
	}
};
const solidLine = {
	geometryType: "polyline",
	renderer: {
		type: "simple",
		symbol: {
			type: "esriSLS",
			style: "esriSLSSolid",
			color: [
				90,
				90,
				90,
				200
			],
			width: 2
		}
	}
};
const outlinedPoly = {
	geometryType: "polygon",
	renderer: {
		type: "simple",
		symbol: {
			type: "esriSFS",
			style: "esriSFSSolid",
			color: [
				76,
				76,
				125,
				200
			],
			outline: {
				type: "esriSLS",
				style: "esriSLSSolid",
				color: [
					110,
					110,
					110,
					255
				],
				width: 1
			}
		}
	}
};
const boundingBoxPoly = {
	geometryType: "polygon",
	renderer: {
		type: "simple",
		symbol: {
			type: "esriSFS",
			style: "esriSFSSolid",
			color: [
				255,
				0,
				0,
				64
			],
			outline: {
				type: "esriSLS",
				style: "esriSLSSolid",
				color: [
					240,
					128,
					128,
					255
				],
				width: 1
			}
		}
	}
};
const defaultRenderers = {
	circlePoint: circlePoint,
	solidLine: solidLine,
	outlinedPoly: outlinedPoly,
	boundingBoxPoly: boundingBoxPoly
};

const featureTypeToRenderer = {
  Point: "circlePoint",
  MultiPoint: "circlePoint",
  LineString: "solidLine",
  MultiLineString: "solidLine",
  Polygon: "outlinedPoly",
  MultiPolygon: "outlinedPoly"
};
function assignIds(geoJson) {
  if (geoJson.type !== "FeatureCollection") {
    throw new Error("GeoJSON is not in FeatureCollection format");
  }
  let emptyID = true;
  let emptyObjID = true;
  for (let i = 0; i < geoJson.features.length; i++) {
    const val = geoJson.features[i];
    Object.assign(val.properties, { ID_FILE: "", OBJECTID_FILE: "" });
    if ("id" in val && typeof val.id !== "undefined") {
      val.properties.ID_FILE = val.id;
      emptyID = false;
    }
    if ("OBJECTID" in val.properties) {
      val.properties.OBJECTID_FILE = val.properties.OBJECTID;
      delete val.properties.OBJECTID;
      emptyObjID = false;
    }
    val.id = i + 1;
  }
  if (emptyID) {
    for (let i = 0; i < geoJson.features.length; i++) {
      delete geoJson.features[i].properties.ID_FILE;
    }
  }
  if (emptyObjID) {
    for (let i = 0; i < geoJson.features.length; i++) {
      delete geoJson.features[i].properties.OBJECTID_FILE;
    }
  }
}
function cleanUpFields(geoJson, configPackage) {
  const badField = (name) => {
    return name.indexOf(" ") > -1;
  };
  configPackage.fields?.forEach((f) => {
    if (f.name && badField(f.name)) {
      const oldField = f.name;
      let newField;
      let underscore = "_";
      let badNewName;
      do {
        newField = oldField.replace(/ /g, underscore);
        badNewName = configPackage.fields?.find((f2) => f2.name === newField);
        if (badNewName) {
          underscore += "_";
        }
      } while (badNewName);
      f.alias = oldField;
      f.name = newField;
      for (let i = 0; i < geoJson.features.length; i++) {
        const gf = geoJson.features[i];
        gf.properties[newField] = gf.properties[oldField];
        delete gf.properties[oldField];
      }
    }
  });
}
function cleanUpGeomCollection(geoJson, idx) {
  const geoms = geoJson.features[idx].geometry.geometries;
  if (geoms.length === 1) {
    geoJson.features[idx].geometry = {
      type: geoms[0].type,
      coordinates: geoms[0].coordinates
    };
  } else {
    const merged = geoms.map((g) => g.coordinates);
    geoJson.features[idx].geometry = {
      type: `Multi${geoms[0].type}`,
      coordinates: merged
    };
  }
}
function validGeomType(realGeomType) {
  if (realGeomType === "MultiLineString") {
    return "LineString";
  } else if (realGeomType === "MultiPolygon") {
    return "Polygon";
  } else {
    return realGeomType;
  }
}
class FileUtils extends APIScope {
  /**
   * Fetch file data from remote URL.
   * @param url the URL to get the data from
   * @param fileType the type of the file layer (csv, shape, or geoJson)
   */
  async fetchFileData(url, fileType) {
    const response = await axios.get(url, {
      responseType: "arrayBuffer"
    });
    switch (fileType) {
      case LayerType.GEOJSON:
      case LayerType.DATAJSON:
        return JSON.parse(this.arbToStr(response.data));
      case LayerType.SHAPEFILE:
      case LayerType.GEOJSONZIPPED:
      case LayerType.FLATGEOBUF:
      case LayerType.FLATGEOBUFZIPPED:
        return response.data;
      case LayerType.CSV:
      case LayerType.DATACSV:
        return this.arbToStr(response.data);
      default:
        console.error(`Unsupported file type passed to fetchFileData- '${fileType}'`);
    }
  }
  /**
   * Extracts fields from the first feature in the feature collection
   */
  extractGeoJsonFields(geoJson) {
    if (geoJson.features.length < 1) {
      throw new Error("GeoJSON field extraction requires at least one feature");
    }
    let overallGeomType = "";
    for (let i = 0; i < geoJson.features.length; i++) {
      const feature = geoJson.features[i];
      const featType = feature.geometry.type;
      if (featType === "GeometryCollection") {
        const geoms = feature.geometry.geometries;
        if (geoms === void 0 || geoms.length === 0) {
          throw new Error("GeoJSON file has geometry collection with missing/incomplete geometries");
        }
        const geomType = geoms[0].type;
        for (let j = 0; j < geoms.length; j++) {
          if (geoms[j].type !== geomType) {
            throw new Error("GeoJSON file has geometry collection containing multiple geometry types");
          }
        }
        cleanUpGeomCollection(geoJson, i);
      }
      const vGeomType = validGeomType(feature.geometry.type);
      if (overallGeomType === "") {
        overallGeomType = vGeomType;
      } else if (overallGeomType !== vGeomType) {
        throw new Error("GeoJSON file contains multiple geometry types");
      }
    }
    const fields = Object.keys(geoJson.features[0].properties).map((field) => {
      return { name: field, type: "string" };
    });
    let featureIdx = 0;
    const fieldsToBeMapped = Object.keys(geoJson.features[0].properties);
    while (featureIdx < geoJson.features.length) {
      const feature = geoJson.features[featureIdx];
      if (feature.properties) {
        Object.keys(feature.properties).filter((field) => fieldsToBeMapped.includes(field)).forEach((field) => {
          const value = feature.properties[field];
          if (value != null) {
            const fieldIdx = fields.findIndex((fieldInfo) => fieldInfo.name === field);
            fields[fieldIdx] = {
              name: field,
              type: this.inferType(value)
            };
            fieldsToBeMapped.splice(fieldsToBeMapped.indexOf(field), 1);
          }
        });
      }
      if (fieldsToBeMapped.length === 0) {
        break;
      }
      featureIdx++;
    }
    return fields;
  }
  /**
   * Extracts fields from csv file does no guesswork on property types and calls everything a string.
   */
  extractCsvFields(csvData, delimiter = ",") {
    const fields = dsv.dsvFormat(delimiter).parseRows(csvData)[0];
    return fields.map((field) => {
      return { name: field, type: FieldType.STRING };
    });
  }
  /**
   * Returns all the fields from csv file that can be possible lat/long fields
   * @param csvData the csv file data
   * @param delimiter the delimiter in the data
   */
  filterCsvLatLonFields(csvData, delimiter = ",") {
    const data = dsv.dsvFormat(delimiter).parseRows(csvData);
    const fields = data[0];
    const result = {
      lat: JSON.parse(JSON.stringify(fields)),
      lon: JSON.parse(JSON.stringify(fields))
    };
    for (let i = 0; i < fields.length; i++) {
      for (let j = 1; j < data.length; j++) {
        const n = Number(data[j][i]);
        const latIdx = result.lat.indexOf(fields[i]);
        const lonIdx = result.lon.indexOf(fields[i]);
        if ((isNaN(n) || n < -90 || n > 90) && latIdx !== -1) {
          result.lat.splice(latIdx, 1);
        }
        if ((isNaN(n) || n < -180 || n > 180) && lonIdx !== -1) {
          result.lon.splice(lonIdx, 1);
        }
        if (latIdx === -1 && lonIdx === -1) {
          break;
        }
      }
    }
    return result;
  }
  /**
   * Convert GeoJSON to Esri json, a format that can be read by a feature layer constructor
   *
   * @param geoJson {Object} a GeoJSON object
   * @param options {GeoJsonOptions} any options for the transformation
   * @returns {Object} feature layer constructor object
   */
  async geoJsonToEsriJson(geoJson, options) {
    let targetSR;
    let srcProj = "";
    let layerId;
    const configPackage = {
      objectIdField: "OBJECTID",
      fields: [
        {
          name: "OBJECTID",
          type: FieldType.OID
        }
      ]
    };
    assignIds(geoJson);
    const geoJsonGeomType = geoJson.features[0].geometry.type;
    const value = featureTypeToRenderer[geoJsonGeomType];
    const defRender = JSON.parse(
      // @ts-ignore
      JSON.stringify(defaultRenderers[value])
    );
    if (options) {
      if (options.sourceProjection) {
        srcProj = this.$iApi.geo.proj.normalizeProj(options.sourceProjection);
      }
      if (options.targetSR) {
        targetSR = options.targetSR;
      } else {
        throw new Error("geoJsonToEsriJson - missing opts.targetSR arguement");
      }
      if (options.layerId) {
        layerId = options.layerId;
      } else {
        layerId = this.$iApi.geo.shared.generateUUID();
      }
      if (options.colour) {
        defRender.renderer.symbol.color = new Colour(options.colour).toArcServer();
      }
    } else {
      throw new Error("geoJsonToEsriJson - missing opts arguement");
    }
    if (!srcProj) {
      srcProj = SpatialReference.parseGeoJsonCrs(geoJson.crs);
    }
    configPackage.renderer = EsriSimpleRenderer.fromJSON(defRender.renderer);
    configPackage.fields = (configPackage.fields || []).concat(
      options.fieldMetadata?.exclusiveFields ? this.extractGeoJsonFields(geoJson).filter(
        (field) => options.fieldMetadata?.fieldInfo?.find((f) => f.name === field.name)
      ) : this.extractGeoJsonFields(geoJson)
    );
    if (options.fieldMetadata?.enforceOrder && options.fieldMetadata?.fieldInfo && options.fieldMetadata?.fieldInfo.length > 0) {
      configPackage.fields = this.$iApi.geo.attributes.orderFields(
        configPackage.fields,
        options.fieldMetadata?.fieldInfo
      );
    }
    cleanUpFields(geoJson, configPackage);
    const destProj = this.$iApi.geo.proj.normalizeProj(targetSR);
    if (options) {
      if (options.latField) {
        const latField = configPackage.fields.find(
          (field) => field.name === options.latField || field.alias === options.latField
        );
        if (latField) {
          latField.type = FieldType.DOUBLE;
        }
      }
      if (options.lonField) {
        const longField = configPackage.fields.find(
          (field) => field.name === options.lonField || field.alias === options.lonField
        );
        if (longField) {
          longField.type = FieldType.DOUBLE;
        }
      }
    }
    await this.$iApi.geo.proj.checkProjBomber([srcProj, targetSR]);
    const fancySR = SpatialReference.parseSR(targetSR).toESRI();
    await this.$iApi.geo.proj.projectGeoJson(geoJson, srcProj, destProj);
    const esriJson = ArcGIS.convert(geoJson, { sr: 8888 });
    configPackage.geometryType = this.$iApi.geo.geom.geoJsonGeomTypeToEsriGeomType(geoJsonGeomType);
    const validFields = configPackage.fields.map((esriField) => esriField.name);
    for (let i = 0; i < esriJson.length; i++) {
      const gr = esriJson[i];
      gr.geometry.spatialReference = fancySR;
      gr.geometry.type = configPackage.geometryType;
      Object.keys(gr.attributes).forEach((attName) => {
        if (validFields.includes(attName)) {
          if ((Array.isArray(gr.attributes[attName]) || typeof gr.attributes[attName] === "object") && gr.attributes[attName] != null) {
            gr.attributes[attName] = JSON.stringify(gr.attributes[attName]);
          }
        } else {
          delete gr.attributes[attName];
        }
      });
    }
    const trimFields = options.fieldMetadata?.fieldInfo && options.fieldMetadata?.fieldInfo.length > 0 ? options.fieldMetadata.fieldInfo.filter((fi) => fi.trim && validFields.includes(fi.name)).map((fi) => fi.name) : [];
    trimFields.forEach((trimName) => {
      for (let i = 0; i < esriJson.length; i++) {
        const attr = esriJson[i].attributes;
        if (typeof attr[trimName] === "string") {
          attr[trimName] = attr[trimName].trim();
        }
      }
    });
    configPackage.source = esriJson;
    configPackage.spatialReference = fancySR;
    configPackage.id = layerId;
    return configPackage;
  }
  // converts csv file in string format to geojson object
  // options
  //     - latfield: a string identifying the field containing latitude values ('Lat' by default)
  //     - lonfield: a string identifying the field containing longitude values ('Long' by default)
  //     - delimiter: a string defining the delimiter character of the file (',' by default)
  async csvToGeoJson(csvData, opts) {
    const csvOpts = {
      // default values
      latfield: "Lat",
      lonfield: "Long",
      delimiter: ","
    };
    if (opts) {
      if (opts.latfield) {
        csvOpts.latfield = opts.latfield;
      }
      if (opts.lonfield) {
        csvOpts.lonfield = opts.lonfield;
      }
      if (opts.delimiter) {
        csvOpts.delimiter = opts.delimiter;
      }
    }
    return new Promise((resolve, reject) => {
      csv2geojson(csvData, csvOpts, (err, data) => {
        if (err) {
          console.error("csv conversion error");
          console.error(err);
          reject(err);
        } else {
          data.features.map((feature) => {
            feature.properties[csvOpts.lonfield] = feature.geometry.coordinates[0];
            feature.properties[csvOpts.latfield] = feature.geometry.coordinates[1];
          });
          resolve(data);
        }
      });
    });
  }
  /**
   * Converts Shapefile data to geojson.
   *
   * @param {ArrayBuffer} shapeData an ArrayBuffer of the Shapefile in zip format
   * @returns {Promise} a promise resolving with geojson
   */
  async shapefileToGeoJson(shapeData) {
    return shp(shapeData);
  }
  /**
   * Converts FlatGeobuf data to geojson.
   *
   * @param {ArrayBuffer} fgbData an ArrayBuffer of a FlatGeobuf file
   * @param {number} maxLoadTime how long we are will permit this to run, in milliseconds
   * @returns {Promise} a promise resolving with geojson
   */
  fgbToGeoJson(fgbData, maxLoadTime) {
    const pollingSpeed = 60;
    return new Promise((resolve) => {
      let headerDone = false;
      let projection = null;
      const geoJson = geojson.deserialize(new Uint8Array(fgbData), void 0, (headerMeta) => {
        projection = headerMeta.crs;
        headerDone = true;
      });
      let kickTimer = 0;
      const waitingFun = setInterval(() => {
        if (geoJson && headerDone) {
          clearInterval(waitingFun);
          let customProj;
          if (projection) {
            if (projection.code && projection.code !== 4326 && projection.org === "EPSG") {
              customProj = new SpatialReference(projection.code);
            } else if (projection.wkt) {
              customProj = new SpatialReference(projection.wkt);
            } else {
              console.error("Encountered FlatGeobuf with non-EPSG org: ", projection);
            }
          }
          if (customProj) {
            geoJson.crs = customProj.toGeoJSON();
          }
          resolve(geoJson);
        } else {
          kickTimer += pollingSpeed;
          if (kickTimer > maxLoadTime) {
            clearInterval(waitingFun);
            resolve({});
          }
        }
      }, pollingSpeed);
    });
  }
  /**
   * Attempt to infers the type of a given value
   * Will check if the value's type is one of int, double
   * Defaults to string type if not
   */
  inferType(value) {
    if (typeof value === "number") {
      return FieldType.DOUBLE;
    }
    return FieldType.STRING;
  }
  /**
   * Will property convert json-based raw data (on a layer config) to a json object
   * while respecting caching considerations.
   *
   * @param {String | Object} rawData json-compatible payload from config
   * @param {Boolean} [caching=false] if layer is concerned about caching the payload
   * @returns {Object} data as a Json object
   */
  rawDataJsonParser(rawData, caching = false) {
    let realJson;
    if (typeof rawData === "string") {
      realJson = JSON.parse(rawData);
    } else if (caching) {
      realJson = structuredClone(rawData);
    } else {
      realJson = rawData;
    }
    return realJson;
  }
  /**
   * Unzip a single zipped file.
   *
   * @param {ArrayBuffer} zippedData zipped file as ArrayBuffer
   * @returns {Promise<ArrayBuffer>} contents of the unzipped file as ArrayBuffer
   */
  async unzipSingleFile(zippedData) {
    const zipper = new JSZip();
    const unzippedData = await zipper.loadAsync(zippedData);
    const fileName = Object.keys(unzippedData.files)[0];
    if (fileName && unzippedData.file(fileName)) {
      return await unzippedData.file(fileName).async("arraybuffer");
    } else {
      throw new Error("Could not find file in zipfile data.");
    }
  }
  /**
   * Helper method for extracting binary-encoded file source from a layer config.
   *
   * @param {RampLayerConfig} layerConfig a ramp layer config. Should be layer type that is a binary format.
   */
  async binaryInitHelper(layerConfig) {
    if (layerConfig.rawData && layerConfig.rawData instanceof ArrayBuffer) {
      return layerConfig.rawData;
    } else if (layerConfig.url) {
      return this.$iApi.geo.layer.files.fetchFileData(layerConfig.url, layerConfig.layerType);
    } else {
      throw new Error(`${layerConfig.layerType} config contains no url or invalid/missing raw data`);
    }
  }
  /**
   * Convert an ArrayBuffer to a UTF-8 string
   *
   * @param {ArrayBuffer} input binary input
   * @returns {string} input in string form
   */
  arbToStr(input) {
    return new TextDecoder("utf-8").decode(new Uint8Array(input));
  }
}

const yxList = [
	4326,
	4269,
	4258,
	31467,
	31468,
	31469,
	2166,
	2167,
	2168,
	2036,
	2044,
	2045,
	2065,
	2081,
	2082,
	2083,
	2085,
	2086,
	2091,
	2092,
	2093,
	2096,
	2097,
	2098,
	2105,
	2106,
	2107,
	2108,
	2109,
	2110,
	2111,
	2112,
	2113,
	2114,
	2115,
	2116,
	2117,
	2118,
	2119,
	2120,
	2121,
	2122,
	2123,
	2124,
	2125,
	2126,
	2127,
	2128,
	2129,
	2130,
	2131,
	2132,
	2169,
	2170,
	2171,
	2172,
	2173,
	2174,
	2175,
	2176,
	2177,
	2178,
	2179,
	2180,
	2193,
	2199,
	2200,
	2206,
	2207,
	2208,
	2209,
	2210,
	2211,
	2212,
	2319,
	2320,
	2321,
	2322,
	2323,
	2324,
	2325,
	2326,
	2327,
	2328,
	2329,
	2330,
	2331,
	2332,
	2333,
	2334,
	2335,
	2336,
	2337,
	2338,
	2339,
	2340,
	2341,
	2342,
	2343,
	2344,
	2345,
	2346,
	2347,
	2348,
	2349,
	2350,
	2351,
	2352,
	2353,
	2354,
	2355,
	2356,
	2357,
	2358,
	2359,
	2360,
	2361,
	2362,
	2363,
	2364,
	2365,
	2366,
	2367,
	2368,
	2369,
	2370,
	2371,
	2372,
	2373,
	2374,
	2375,
	2376,
	2377,
	2378,
	2379,
	2380,
	2381,
	2382,
	2383,
	2384,
	2385,
	2386,
	2387,
	2388,
	2389,
	2390,
	2391,
	2392,
	2393,
	2394,
	2395,
	2396,
	2397,
	2398,
	2399,
	2400,
	2401,
	2402,
	2403,
	2404,
	2405,
	2406,
	2407,
	2408,
	2409,
	2410,
	2411,
	2412,
	2413,
	2414,
	2415,
	2416,
	2417,
	2418,
	2419,
	2420,
	2421,
	2422,
	2423,
	2424,
	2425,
	2426,
	2427,
	2428,
	2429,
	2430,
	2431,
	2432,
	2433,
	2434,
	2435,
	2436,
	2437,
	2438,
	2439,
	2440,
	2441,
	2442,
	2443,
	2444,
	2445,
	2446,
	2447,
	2448,
	2449,
	2450,
	2451,
	2452,
	2453,
	2454,
	2455,
	2456,
	2457,
	2458,
	2459,
	2460,
	2461,
	2462,
	2463,
	2464,
	2465,
	2466,
	2467,
	2468,
	2469,
	2470,
	2471,
	2472,
	2473,
	2474,
	2475,
	2476,
	2477,
	2478,
	2479,
	2480,
	2481,
	2482,
	2483,
	2484,
	2485,
	2486,
	2487,
	2488,
	2489,
	2490,
	2491,
	2492,
	2493,
	2494,
	2495,
	2496,
	2497,
	2498,
	2499,
	2500,
	2501,
	2502,
	2503,
	2504,
	2505,
	2506,
	2507,
	2508,
	2509,
	2510,
	2511,
	2512,
	2513,
	2514,
	2515,
	2516,
	2517,
	2518,
	2519,
	2520,
	2521,
	2522,
	2523,
	2524,
	2525,
	2526,
	2527,
	2528,
	2529,
	2530,
	2531,
	2532,
	2533,
	2534,
	2535,
	2536,
	2537,
	2538,
	2539,
	2540,
	2541,
	2542,
	2543,
	2544,
	2545,
	2546,
	2547,
	2548,
	2549,
	2551,
	2552,
	2553,
	2554,
	2555,
	2556,
	2557,
	2558,
	2559,
	2560,
	2561,
	2562,
	2563,
	2564,
	2565,
	2566,
	2567,
	2568,
	2569,
	2570,
	2571,
	2572,
	2573,
	2574,
	2575,
	2576,
	2577,
	2578,
	2579,
	2580,
	2581,
	2582,
	2583,
	2584,
	2585,
	2586,
	2587,
	2588,
	2589,
	2590,
	2591,
	2592,
	2593,
	2594,
	2595,
	2596,
	2597,
	2598,
	2599,
	2600,
	2601,
	2602,
	2603,
	2604,
	2605,
	2606,
	2607,
	2608,
	2609,
	2610,
	2611,
	2612,
	2613,
	2614,
	2615,
	2616,
	2617,
	2618,
	2619,
	2620,
	2621,
	2622,
	2623,
	2624,
	2625,
	2626,
	2627,
	2628,
	2629,
	2630,
	2631,
	2632,
	2633,
	2634,
	2635,
	2636,
	2637,
	2638,
	2639,
	2640,
	2641,
	2642,
	2643,
	2644,
	2645,
	2646,
	2647,
	2648,
	2649,
	2650,
	2651,
	2652,
	2653,
	2654,
	2655,
	2656,
	2657,
	2658,
	2659,
	2660,
	2661,
	2662,
	2663,
	2664,
	2665,
	2666,
	2667,
	2668,
	2669,
	2670,
	2671,
	2672,
	2673,
	2674,
	2675,
	2676,
	2677,
	2678,
	2679,
	2680,
	2681,
	2682,
	2683,
	2684,
	2685,
	2686,
	2687,
	2688,
	2689,
	2690,
	2691,
	2692,
	2693,
	2694,
	2695,
	2696,
	2697,
	2698,
	2699,
	2700,
	2701,
	2702,
	2703,
	2704,
	2705,
	2706,
	2707,
	2708,
	2709,
	2710,
	2711,
	2712,
	2713,
	2714,
	2715,
	2716,
	2717,
	2718,
	2719,
	2720,
	2721,
	2722,
	2723,
	2724,
	2725,
	2726,
	2727,
	2728,
	2729,
	2730,
	2731,
	2732,
	2733,
	2734,
	2735,
	2738,
	2739,
	2740,
	2741,
	2742,
	2743,
	2744,
	2745,
	2746,
	2747,
	2748,
	2749,
	2750,
	2751,
	2752,
	2753,
	2754,
	2755,
	2756,
	2757,
	2758,
	2935,
	2936,
	2937,
	2938,
	2939,
	2940,
	2941,
	2953,
	2963,
	3006,
	3007,
	3008,
	3009,
	3010,
	3011,
	3012,
	3013,
	3014,
	3015,
	3016,
	3017,
	3018,
	3019,
	3020,
	3021,
	3022,
	3023,
	3024,
	3025,
	3026,
	3027,
	3028,
	3029,
	3030,
	3034,
	3035,
	3038,
	3039,
	3040,
	3041,
	3042,
	3043,
	3044,
	3045,
	3046,
	3047,
	3048,
	3049,
	3050,
	3051,
	3058,
	3059,
	3068,
	3114,
	3115,
	3116,
	3117,
	3118,
	3120,
	3126,
	3127,
	3128,
	3129,
	3130,
	3131,
	3132,
	3133,
	3134,
	3135,
	3136,
	3137,
	3138,
	3139,
	3140,
	3146,
	3147,
	3150,
	3151,
	3152,
	3300,
	3301,
	3328,
	3329,
	3330,
	3331,
	3332,
	3333,
	3334,
	3335,
	3346,
	3350,
	3351,
	3352,
	3366,
	3386,
	3387,
	3388,
	3389,
	3390,
	3396,
	3397,
	3398,
	3399,
	3407,
	3414,
	3416,
	3764,
	3788,
	3789,
	3790,
	3791,
	3793,
	3795,
	3796,
	3819,
	3821,
	3823,
	3824,
	3833,
	3834,
	3835,
	3836,
	3837,
	3838,
	3839,
	3840,
	3841,
	3842,
	3843,
	3844,
	3845,
	3846,
	3847,
	3848,
	3849,
	3850,
	3851,
	3852,
	3854,
	3873,
	3874,
	3875,
	3876,
	3877,
	3878,
	3879,
	3880,
	3881,
	3882,
	3883,
	3884,
	3885,
	3888,
	3889,
	3906,
	3907,
	3908,
	3909,
	3910,
	3911,
	4001,
	4002,
	4003,
	4004,
	4005,
	4006,
	4007,
	4008,
	4009,
	4010,
	4011,
	4012,
	4013,
	4014,
	4015,
	4016,
	4017,
	4018,
	4019,
	4020,
	4021,
	4022,
	4023,
	4024,
	4025,
	4026,
	4027,
	4028,
	4029,
	4030,
	4031,
	4032,
	4033,
	4034,
	4035,
	4036,
	4037,
	4038,
	4040,
	4041,
	4042,
	4043,
	4044,
	4045,
	4046,
	4047,
	4052,
	4053,
	4054,
	4055,
	4074,
	4075,
	4080,
	4081,
	4120,
	4121,
	4122,
	4123,
	4124,
	4125,
	4126,
	4127,
	4128,
	4129,
	4130,
	4131,
	4132,
	4133,
	4134,
	4135,
	4136,
	4137,
	4138,
	4139,
	4140,
	4141,
	4142,
	4143,
	4144,
	4145,
	4146,
	4147,
	4148,
	4149,
	4150,
	4151,
	4152,
	4153,
	4154,
	4155,
	4156,
	4157,
	4158,
	4159,
	4160,
	4161,
	4162,
	4163,
	4164,
	4165,
	4166,
	4167,
	4168,
	4169,
	4170,
	4171,
	4172,
	4173,
	4174,
	4175,
	4176,
	4178,
	4179,
	4180,
	4181,
	4182,
	4183,
	4184,
	4185,
	4188,
	4189,
	4190,
	4191,
	4192,
	4193,
	4194,
	4195,
	4196,
	4197,
	4198,
	4199,
	4200,
	4201,
	4202,
	4203,
	4204,
	4205,
	4206,
	4207,
	4208,
	4209,
	4210,
	4211,
	4212,
	4213,
	4214,
	4215,
	4216,
	4218,
	4219,
	4220,
	4221,
	4222,
	4223,
	4224,
	4225,
	4226,
	4227,
	4228,
	4229,
	4230,
	4231,
	4232,
	4233,
	4234,
	4235,
	4236,
	4237,
	4238,
	4239,
	4240,
	4241,
	4242,
	4243,
	4244,
	4245,
	4246,
	4247,
	4248,
	4249,
	4250,
	4251,
	4252,
	4253,
	4254,
	4255,
	4256,
	4257,
	4259,
	4260,
	4261,
	4262,
	4263,
	4264,
	4265,
	4266,
	4267,
	4268,
	4270,
	4271,
	4272,
	4273,
	4274,
	4275,
	4276,
	4277,
	4278,
	4279,
	4280,
	4281,
	4282,
	4283,
	4284,
	4285,
	4286,
	4287,
	4288,
	4289,
	4291,
	4292,
	4293,
	4294,
	4295,
	4296,
	4297,
	4298,
	4299,
	4300,
	4301,
	4302,
	4303,
	4304,
	4306,
	4307,
	4308,
	4309,
	4310,
	4311,
	4312,
	4313,
	4314,
	4315,
	4316,
	4317,
	4318,
	4319,
	4322,
	4324,
	4327,
	4329,
	4339,
	4341,
	4343,
	4345,
	4347,
	4349,
	4351,
	4353,
	4355,
	4357,
	4359,
	4361,
	4363,
	4365,
	4367,
	4369,
	4371,
	4373,
	4375,
	4377,
	4379,
	4381,
	4383,
	4386,
	4388,
	4417,
	4434,
	4463,
	4466,
	4469,
	4470,
	4472,
	4475,
	4480,
	4482,
	4483,
	4490,
	4491,
	4492,
	4493,
	4494,
	4495,
	4496,
	4497,
	4498,
	4499,
	4500,
	4501,
	4502,
	4503,
	4504,
	4505,
	4506,
	4507,
	4508,
	4509,
	4510,
	4511,
	4512,
	4513,
	4514,
	4515,
	4516,
	4517,
	4518,
	4519,
	4520,
	4521,
	4522,
	4523,
	4524,
	4525,
	4526,
	4527,
	4528,
	4529,
	4530,
	4531,
	4532,
	4533,
	4534,
	4535,
	4536,
	4537,
	4538,
	4539,
	4540,
	4541,
	4542,
	4543,
	4544,
	4545,
	4546,
	4547,
	4548,
	4549,
	4550,
	4551,
	4552,
	4553,
	4554,
	4555,
	4557,
	4558,
	4568,
	4569,
	4570,
	4571,
	4572,
	4573,
	4574,
	4575,
	4576,
	4577,
	4578,
	4579,
	4580,
	4581,
	4582,
	4583,
	4584,
	4585,
	4586,
	4587,
	4588,
	4589,
	4600,
	4601,
	4602,
	4603,
	4604,
	4605,
	4606,
	4607,
	4608,
	4609,
	4610,
	4611,
	4612,
	4613,
	4614,
	4615,
	4616,
	4617,
	4618,
	4619,
	4620,
	4621,
	4622,
	4623,
	4624,
	4625,
	4626,
	4627,
	4628,
	4629,
	4630,
	4631,
	4632,
	4633,
	4634,
	4635,
	4636,
	4637,
	4638,
	4639,
	4640,
	4641,
	4642,
	4643,
	4644,
	4645,
	4646,
	4652,
	4653,
	4654,
	4655,
	4656,
	4657,
	4658,
	4659,
	4660,
	4661,
	4662,
	4663,
	4664,
	4665,
	4666,
	4667,
	4668,
	4669,
	4670,
	4671,
	4672,
	4673,
	4674,
	4675,
	4676,
	4677,
	4678,
	4679,
	4680,
	4681,
	4682,
	4683,
	4684,
	4685,
	4686,
	4687,
	4688,
	4689,
	4690,
	4691,
	4692,
	4693,
	4694,
	4695,
	4696,
	4697,
	4698,
	4699,
	4700,
	4701,
	4702,
	4703,
	4704,
	4705,
	4706,
	4707,
	4708,
	4709,
	4710,
	4711,
	4712,
	4713,
	4714,
	4715,
	4716,
	4717,
	4718,
	4719,
	4720,
	4721,
	4722,
	4723,
	4724,
	4725,
	4726,
	4727,
	4728,
	4729,
	4730,
	4731,
	4732,
	4733,
	4734,
	4735,
	4736,
	4737,
	4738,
	4739,
	4740,
	4741,
	4742,
	4743,
	4744,
	4745,
	4746,
	4747,
	4748,
	4749,
	4750,
	4751,
	4752,
	4753,
	4754,
	4755,
	4756,
	4757,
	4758,
	4759,
	4760,
	4761,
	4762,
	4763,
	4764,
	4765,
	4766,
	4767,
	4768,
	4769,
	4770,
	4771,
	4772,
	4773,
	4774,
	4775,
	4776,
	4777,
	4778,
	4779,
	4780,
	4781,
	4782,
	4783,
	4784,
	4785,
	4786,
	4787,
	4788,
	4789,
	4790,
	4791,
	4792,
	4793,
	4794,
	4795,
	4796,
	4797,
	4798,
	4799,
	4800,
	4801,
	4802,
	4803,
	4804,
	4805,
	4806,
	4807,
	4808,
	4809,
	4810,
	4811,
	4812,
	4813,
	4814,
	4815,
	4816,
	4817,
	4818,
	4819,
	4820,
	4821,
	4822,
	4823,
	4824,
	4839,
	4855,
	4856,
	4857,
	4858,
	4859,
	4860,
	4861,
	4862,
	4863,
	4864,
	4865,
	4866,
	4867,
	4868,
	4869,
	4870,
	4871,
	4872,
	4873,
	4874,
	4875,
	4876,
	4877,
	4878,
	4879,
	4880,
	4883,
	4885,
	4887,
	4889,
	4891,
	4893,
	4895,
	4898,
	4900,
	4901,
	4902,
	4903,
	4904,
	4907,
	4909,
	4921,
	4923,
	4925,
	4927,
	4929,
	4931,
	4933,
	4935,
	4937,
	4939,
	4941,
	4943,
	4945,
	4947,
	4949,
	4951,
	4953,
	4955,
	4957,
	4959,
	4961,
	4963,
	4965,
	4967,
	4969,
	4971,
	4973,
	4975,
	4977,
	4979,
	4981,
	4983,
	4985,
	4987,
	4989,
	4991,
	4993,
	4995,
	4997,
	4999,
	5012,
	5013,
	5017,
	5048,
	5105,
	5106,
	5107,
	5108,
	5109,
	5110,
	5111,
	5112,
	5113,
	5114,
	5115,
	5116,
	5117,
	5118,
	5119,
	5120,
	5121,
	5122,
	5123,
	5124,
	5125,
	5126,
	5127,
	5128,
	5129,
	5130,
	5132,
	5167,
	5168,
	5169,
	5170,
	5171,
	5172,
	5173,
	5174,
	5175,
	5176,
	5177,
	5178,
	5179,
	5180,
	5181,
	5182,
	5183,
	5184,
	5185,
	5186,
	5187,
	5188,
	5224,
	5228,
	5229,
	5233,
	5245,
	5246,
	5251,
	5252,
	5253,
	5254,
	5255,
	5256,
	5257,
	5258,
	5259,
	5263,
	5264,
	5269,
	5270,
	5271,
	5272,
	5273,
	5274,
	5275,
	5801,
	5802,
	5803,
	5804,
	5808,
	5809,
	5810,
	5811,
	5812,
	5813,
	5814,
	5815,
	5816,
	20004,
	20005,
	20006,
	20007,
	20008,
	20009,
	20010,
	20011,
	20012,
	20013,
	20014,
	20015,
	20016,
	20017,
	20018,
	20019,
	20020,
	20021,
	20022,
	20023,
	20024,
	20025,
	20026,
	20027,
	20028,
	20029,
	20030,
	20031,
	20032,
	20064,
	20065,
	20066,
	20067,
	20068,
	20069,
	20070,
	20071,
	20072,
	20073,
	20074,
	20075,
	20076,
	20077,
	20078,
	20079,
	20080,
	20081,
	20082,
	20083,
	20084,
	20085,
	20086,
	20087,
	20088,
	20089,
	20090,
	20091,
	20092,
	21413,
	21414,
	21415,
	21416,
	21417,
	21418,
	21419,
	21420,
	21421,
	21422,
	21423,
	21453,
	21454,
	21455,
	21456,
	21457,
	21458,
	21459,
	21460,
	21461,
	21462,
	21463,
	21473,
	21474,
	21475,
	21476,
	21477,
	21478,
	21479,
	21480,
	21481,
	21482,
	21483,
	21896,
	21897,
	21898,
	21899,
	22171,
	22172,
	22173,
	22174,
	22175,
	22176,
	22177,
	22181,
	22182,
	22183,
	22184,
	22185,
	22186,
	22187,
	22191,
	22192,
	22193,
	22194,
	22195,
	22196,
	22197,
	25884,
	27205,
	27206,
	27207,
	27208,
	27209,
	27210,
	27211,
	27212,
	27213,
	27214,
	27215,
	27216,
	27217,
	27218,
	27219,
	27220,
	27221,
	27222,
	27223,
	27224,
	27225,
	27226,
	27227,
	27228,
	27229,
	27230,
	27231,
	27232,
	27391,
	27392,
	27393,
	27394,
	27395,
	27396,
	27397,
	27398,
	27492,
	28402,
	28403,
	28404,
	28405,
	28406,
	28407,
	28408,
	28409,
	28410,
	28411,
	28412,
	28413,
	28414,
	28415,
	28416,
	28417,
	28418,
	28419,
	28420,
	28421,
	28422,
	28423,
	28424,
	28425,
	28426,
	28427,
	28428,
	28429,
	28430,
	28431,
	28432,
	28462,
	28463,
	28464,
	28465,
	28466,
	28467,
	28468,
	28469,
	28470,
	28471,
	28472,
	28473,
	28474,
	28475,
	28476,
	28477,
	28478,
	28479,
	28480,
	28481,
	28482,
	28483,
	28484,
	28485,
	28486,
	28487,
	28488,
	28489,
	28490,
	28491,
	28492,
	29701,
	29702,
	30161,
	30162,
	30163,
	30164,
	30165,
	30166,
	30167,
	30168,
	30169,
	30170,
	30171,
	30172,
	30173,
	30174,
	30175,
	30176,
	30177,
	30178,
	30179,
	30800,
	31251,
	31252,
	31253,
	31254,
	31255,
	31256,
	31257,
	31258,
	31259,
	31275,
	31276,
	31277,
	31278,
	31279,
	31281,
	31282,
	31283,
	31284,
	31285,
	31286,
	31287,
	31288,
	31289,
	31290,
	31466,
	31700
];

class OgcUtils extends APIScope {
  /**
   * Will load a WFS 3 feature set and return as GeoJSON object.
   * Data will be downloaded in batches (based on limit parameter) to
   * avoid massive requests that may timeout.
   *
   * @param {string} url the current url to the wfs service. Should be a /collections/id/items/ endpoint with optional params after the question operator
   * @param {number} [totalCount=-1] the total number of features available on that service. If not provided, the service will be interrogated for the count.
   * @param {number} [offset=0] the feature index to start the querying from. default 0
   * @param {number} [limit=1000] the limit of how many results we want returned per server request. default 1000
   * @param {WFSData} [wfsData={
   *                 type: 'FeatureCollection',
   *                 features: []
   *             }] the resulting GeoJSON being populated as we receive layer information. Undefined for initial request.
   * @param {boolean} [xyInAttribs=false] true if point co-ords should be copied to attribute values
   * @returns {Promise<any>} a promise resolving with the layer GeoJSON
   * @memberof WFSServiceSource
   */
  async loadWfsData(url, totalCount = -1, offset = 0, limit = 1e3, wfsData = {
    type: "FeatureCollection",
    features: []
  }, xyInAttribs = false) {
    let newQueryMap = {
      offset: offset.toString(),
      limit: limit.toString()
    };
    if (totalCount === -1) {
      newQueryMap = {
        resulttype: "hits"
      };
    }
    const wrapper = new UrlWrapper(url);
    const requestUrl = wrapper.updateQuery(newQueryMap);
    const [error, response] = await to(axios.get(requestUrl));
    if (!response) {
      console.error(`WFS data failed to load for ${url}`, error);
      return Promise.reject(error);
    }
    const data = response.data;
    if (totalCount === -1) {
      totalCount = response.data.numberMatched;
      return this.loadWfsData(url, totalCount, offset, limit, wfsData, xyInAttribs);
    }
    wfsData.features = wfsData.features.concat(data.features);
    if (data.features.length < totalCount - offset) {
      const newLimit = Math.min(limit, totalCount - offset - data.features.length);
      return this.loadWfsData(
        requestUrl,
        totalCount,
        data.features.length + offset,
        newLimit,
        wfsData,
        xyInAttribs
      );
    } else {
      if (xyInAttribs && wfsData.features.length > 0 && wfsData.features[0].geometry.type === GeoJsonGeomType.POINT) {
        wfsData.features.forEach((f) => {
          const p = f.geometry.coordinates;
          f.properties.rvInternalCoordX = p[0];
          f.properties.rvInternalCoordY = p[1];
        });
      }
      return wfsData;
    }
  }
  /**
   * Provides list of spatial references that are encoded in [y,x] format.
   *
   * @returns array of wkids that have reversed axis
   */
  reversedAxisWKIDs() {
    return yxList;
  }
  // NOTE this function is currently used by the wizard only in RAMP2
  /**
   * Fetch layer data from a WMS endpoint.  This method will execute a WMS GetCapabilities
   * request against the specified URL, it requests WMS 1.3 and it is capable of parsing
   * 1.3 or 1.1.1 responses.  It returns a promise which will resolve with basic layer
   * metadata and querying information.
   *
   * metadata response format:
   *   { queryTypes: [mimeType(str)],
   *     layers: [
   *       {name(str), desc(str), queryable(bool), layers:[recursive] }
   *     ] }
   *
   * @param {string} wmsEndpoint a URL pointing to a WMS server (it must not include a query string)
   * @return {Promise} a promise resolving with a metadata object (as specified above)
   */
  parseCapabilities(wmsEndpoint) {
    const getCapabilities = () => {
      let url = wmsEndpoint;
      if (wmsEndpoint.indexOf("?") === -1) {
        url += "?service=WMS&request=GetCapabilities";
      } else {
        const wrapper = new UrlWrapper(wmsEndpoint.toUpperCase());
        if (!("SERVICE" in wrapper.queryMap)) {
          url += "&service=WMS";
        }
        if (!("REQUEST" in wrapper.queryMap)) {
          url += "&request=GetCapabilities";
        }
      }
      return EsriRequest(url, {
        responseType: "xml"
      }).then((result) => result.data);
    };
    const gcPromise = new Promise((resolve) => {
      getCapabilities().then((data) => resolve(data)).catch(() => {
        console.error("Get capabilities failed; trying the second time;");
        resolve(getCapabilities());
      });
    });
    const getLayers = (xmlNode) => {
      let layers = xmlNode.Layer;
      if (!layers) {
        return [];
      }
      if (!Array.isArray(layers)) {
        layers = [layers];
      }
      return layers.map((layer) => {
        const nameNode = layer.Name;
        const titleNode = layer.Title;
        let styles = layer.Style;
        const allStyles = [];
        const styleToURL = {};
        if (styles) {
          if (!Array.isArray(styles)) {
            styles = [styles];
          }
          styles.forEach((style) => {
            const styleName = style.Name;
            allStyles.push(styleName);
            if (style.LegendURL) {
              const resource = style.LegendURL.OnlineResource;
              const styleURL = resource["@_xlink:href"];
              styleToURL[styleName] = styleURL.replaceAll("&amp;", "&");
            }
          });
        }
        return {
          // typecast to string as number IDs need to be stringified in the wms sublayer config
          // TODO: What if this ends up being null? Does layer explode?
          // If yes, consider adding a warning or notification of some sort.
          name: nameNode?.toString() ?? null,
          title: titleNode,
          queryable: layer["@_queryable"] === "1",
          layers: getLayers(layer),
          allStyles,
          styleToURL,
          currentStyle: allStyles[0]
        };
      });
    };
    const getQueryTypes = (xmlNode) => {
      let formats = xmlNode.Format;
      if (!Array.isArray(formats)) {
        formats = [formats];
      }
      return formats;
    };
    return gcPromise.then((xmlNode) => {
      if (!xmlNode) {
        return [];
      }
      const xmlData = new XMLSerializer().serializeToString(xmlNode);
      const options = {
        ignoreAttributes: false
        // check for tag attributes
      };
      const jsonObj = new XMLParser(options).parse(xmlData);
      if ("ServiceExceptionReport" in jsonObj) {
        console.error(jsonObj.ServiceExceptionReport.ServiceException);
        return [];
      }
      const capability = jsonObj.WMS_Capabilities.Capability;
      return {
        layers: getLayers(capability),
        queryTypes: getQueryTypes(capability.Request.GetFeatureInfo)
      };
    });
  }
}

class ReactiveIdentifyFactory {
  /**
   * Generates a reactive Identify Item that sources its content via pre-existing content.
   * Contains the information for a specific result and appropriate methods.
   *
   * @param {IdentifyResultFormat} format the result format of the item
   * @param {any} payload the data for the item
   * @returns {IdentifyItem} a loaded identify item
   */
  static makeRawItem(format, payload) {
    const doneThanksPromise = Promise.resolve();
    const vanillaItem = {
      format,
      data: payload,
      started: true,
      loaded: true,
      loading: doneThanksPromise,
      load() {
        return doneThanksPromise;
      }
    };
    return reactive(vanillaItem);
  }
  /**
   * Generates a reactive Identify Item that sources its content via an object id.
   * Contains the information for a specific result and mechanisms to assist in loading the data.
   *
   * @param {number} oid objectId for the item
   * @param {LayerInstance} layer the logical layer hosting the item
   * @returns {IdentifyItem} an unloaded identify item
   */
  static makeOidItem(oid, layer) {
    const sneakyDeferred = new DefPromise();
    const vanillaItem = {
      format: IdentifyResultFormat.ESRI,
      data: void 0,
      started: false,
      loaded: false,
      loading: sneakyDeferred.getPromise(),
      async load() {
        if (!this.started) {
          this.started = true;
          const g = await layer.getGraphic(oid, {
            getAttribs: true
          });
          this.data = g.attributes;
          this.loaded = true;
          sneakyDeferred.resolveMe();
        }
        return sneakyDeferred.getPromise();
      }
    };
    return reactive(vanillaItem);
  }
}

class LayerAPI extends APIScope {
  files;
  ogc;
  constructor(iApi) {
    super(iApi);
    this.files = new FileUtils(iApi);
    this.ogc = new OgcUtils(iApi);
  }
  /**
   * Will generate a RAMP Layer based on the supplied config object.
   *
   * @param {Object} config a valid layer configuration object
   * @returns {LayerInstance} Layer in uninitialized load state
   */
  createLayer(config) {
    let closs;
    switch (config.layerType) {
      case LayerType.FEATURE:
        closs = FeatureLayer;
        break;
      case LayerType.MAPIMAGE:
        closs = MapImageLayer;
        break;
      case LayerType.GRAPHIC:
        closs = GraphicLayer;
        break;
      case LayerType.TILE:
        closs = TileLayer;
        break;
      case LayerType.WFS:
        closs = WfsLayer;
        break;
      case LayerType.DATATABLE:
        closs = TableLayer;
        break;
      case LayerType.WMS:
        closs = WmsLayer;
        break;
      case LayerType.GEOJSON:
        closs = GeoJsonLayer;
        break;
      case LayerType.GEOJSONZIPPED:
        closs = GeoJsonZipLayer;
        break;
      case LayerType.FLATGEOBUFZIPPED:
        closs = FlatGeobufZipLayer;
        break;
      case LayerType.CSV:
        closs = CsvLayer;
        break;
      case LayerType.DATAJSON:
        closs = JsonDataLayer;
        break;
      case LayerType.IMAGERY:
        closs = ImageryLayer;
        break;
      case LayerType.SHAPEFILE:
        closs = ShapefileLayer;
        break;
      case LayerType.FLATGEOBUF:
        closs = FlatGeobufLayer;
        break;
      case LayerType.OSM:
        closs = OsmTileLayer;
        break;
      default:
        throw new Error("Unsupported Layer Type " + config.layerType);
    }
    return new closs(config, this.$iApi);
  }
  /**
   * Access a registered layer object.
   *
   * @param {string} layerId layer id or uid of the layer
   * @returns {LayerInstance | undefined} The layer instance with the given id. Returns undefined if layer is not found.
   */
  getLayer(layerId) {
    return useLayerStore(this.$vApp.$pinia).getLayerByAny(layerId);
  }
  /**
   * Access a registered sublayer object.
   *
   * @param {string} layerId layer id of the layer
   * @param {number} index index of the sublayer
   * @returns {LayerInstance | undefined} The sublayer instance matching the parameters. Returns undefined if sublayer is not found.
   */
  getSublayer(layerId, index) {
    const parentLayer = useLayerStore(this.$vApp.$pinia).getLayerById(layerId);
    if (parentLayer && parentLayer.supportsSublayers && index < parentLayer.sublayers.length) {
      return parentLayer.sublayers[index];
    } else {
      return void 0;
    }
  }
  /**
   * Get the current map stack position of a given map layer
   *
   * @param {string} layerId layer id or uid of the layer
   * @returns {number | undefined} The layer position in the map stack. Undefined if a data layer or layer not found
   */
  getLayerPosition(layerId) {
    const layer = this.getLayer(layerId);
    if (layer && layer.mapLayer) {
      const searchId = layer.isSublayer ? layer.parentLayer.id : layer.id;
      const idx = this.layerOrderIds().findIndex((orderId) => orderId === searchId);
      return idx === -1 ? void 0 : idx;
    } else {
      return void 0;
    }
  }
  /**
   * Return the Layer IDs of all registered map layers in the order they occupy,
   * or will occupy, the map stack.
   * @returns {Array<string>} layer ids, from bottom to top
   */
  layerOrderIds() {
    return useLayerStore(this.$vApp.$pinia).mapOrder.slice(0) || [];
  }
  /**
   * Return all registered layers.
   * @returns {Array<LayerInstance>} all registered layers
   */
  allLayers() {
    return useLayerStore(this.$vApp.$pinia).layers || [];
  }
  /**
   * Returns all layers that have initiated successfully and that have not errored.
   * @returns {Array<LayerInstance>} all layers that have initiated and not errored
   */
  allActiveLayers() {
    return this.allLayers().filter(
      (l) => l.layerState !== LayerState.ERROR && l.initiationState === InitiationState.INITIATED
    );
  }
  /**
   * Returns all map-based layers currently on the map.
   * Result can be ordered in map stack order. Unordered is more performant.
   *
   * @param {boolean} [inMapOrder=true] if result array should be sorted by map order.
   * @returns {Array<LayerInstance>} all layers on the map
   */
  allLayersOnMap(inMapOrder = true) {
    let mapLayers = this.allLayers().filter((l) => l.mapLayer && l.initiationState === InitiationState.INITIATED);
    if (inMapOrder) {
      const lOrder = this.layerOrderIds();
      const cash = new Map(lOrder.map((layerId, i) => [layerId, i]));
      mapLayers.sort((lay1, lay2) => {
        return cash.get(lay1.id) - cash.get(lay2.id);
      });
    }
    return mapLayers;
  }
  /**
   * Returns all initialized data-based layers currently registered with the map.
   * @returns {Array<LayerInstance>} all loaded data layers
   */
  allDataLayers() {
    return this.allLayers().filter((l) => !l.mapLayer && l.initiationState === InitiationState.INITIATED);
  }
  /**
   * Return all layers in an error state.
   * @returns {Array<LayerInstance>} all errored layers
   */
  allErrorLayers() {
    return this.allLayers().filter((l) => l.layerState === LayerState.ERROR);
  }
  /**
   * Returns all layers currently undergoing initiation process.
   * @returns {Array<LayerInstance>} all initiating layers
   */
  allInitiatingLayers() {
    return this.allLayers().filter((l) => l.initiationState === InitiationState.INITIATING);
  }
  /**
   * Get controls and disabled controls configuration of the layer with the given id.
   *
   * @param {string} layerId layer id or uid of the layer
   * @returns {Object | undefined} The layer's controls and disabled controls configuration. Returns undefined if layer is not found.
   */
  getLayerControls(layerId) {
    const layer = this.getLayer(layerId);
    if (!layer) {
      return;
    }
    const controls = layer.config.controls?.slice() ?? [
      LayerControl.BoundaryZoom,
      LayerControl.Datatable,
      LayerControl.Identify,
      LayerControl.Metadata,
      LayerControl.Opacity,
      LayerControl.Refresh,
      LayerControl.Reload,
      LayerControl.Remove,
      LayerControl.Settings,
      LayerControl.Symbology,
      LayerControl.Visibility
    ];
    const controlsToRemove = [];
    if (!layer.supportsFeatures) {
      controlsToRemove.push(LayerControl.Datatable);
    }
    if (layer.extent === void 0) {
      controlsToRemove.push(LayerControl.BoundaryZoom);
    }
    const metaConfig = layer.config?.metadata || (layer.isSublayer ? layer.parentLayer?.config?.metadata : {}) || {};
    if (!metaConfig.url) {
      controlsToRemove.push(LayerControl.Metadata);
    }
    if (!layer.mapLayer && !layer.config.controls?.includes(LayerControl.Settings)) {
      controlsToRemove.push(LayerControl.Settings);
    }
    controlsToRemove.forEach((control) => {
      const idx = controls?.indexOf(control) ?? -1;
      if (idx !== -1) {
        controls?.splice(idx, 1);
      }
    });
    return {
      controls,
      disabledControls: layer.config.disabledControls ?? []
    };
  }
  /**
   * Will fetch metadata about a layer service endpoint on an ArcGIS server
   *
   * @param url the server url of the layer
   * @returns {Promise} resolves with relevant information about the layer service
   */
  async loadLayerMetadata(url) {
    if (!url.trim()) {
      throw new Error("url missing on layer server metadata request.");
    }
    const [err, serviceResult] = await to(EsriRequest(url, { query: { f: "json" } }));
    if (!serviceResult) {
      console.error(`Service metadata load error: ${url}`, err);
      throw new Error(`Service metadata load error: ${url}`);
    }
    if (!serviceResult.data) {
      console.error(`Service metadata load error: ${url}`);
      throw new Error(`Service metadata load error: ${url}`);
    }
    const sData = serviceResult.data;
    const md = {
      geometryType: GeometryType.NONE,
      minScale: 0,
      maxScale: 0,
      canModifyLayer: true,
      extent: void 0,
      defaultVisibility: true,
      fields: [],
      displayField: "",
      objectIdField: "",
      renderer: void 0,
      currentVersion: 0,
      name: "",
      dataFormat: DataFormat.UNKNOWN,
      mapLayer: true
    };
    md.name = sData.name || "";
    md.currentVersion = sData.currentVersion || -1;
    md.minScale = sData.effectiveMinScale || sData.minScale || 0;
    md.maxScale = sData.effectiveMaxScale || sData.maxScale || 0;
    md.extent = sData.extent ? Extent.fromArcServer(sData.extent, "layer_extent") : void 0;
    md.defaultVisibility = sData.defaultVisibility ?? true;
    md.canModifyLayer = sData.canModifyLayer ?? true;
    if (sData.type === "Feature Layer" || sData.type === "Table") {
      md.dataFormat = DataFormat.ESRI_FEATURE;
      md.displayField = sData.displayField || "";
      if (Array.isArray(sData.fields)) {
        const esriFields = sData.fields.map((f) => EsriField.fromJSON(f));
        md.fields = esriFields.map((f) => {
          return {
            name: f.name,
            alias: f.alias,
            type: f.type,
            length: f.length
          };
        });
        const noFieldDefOid = esriFields.every((elem) => {
          if (elem.type === "oid") {
            md.objectIdField = elem.name;
            return false;
          }
          return true;
        });
        if (noFieldDefOid) {
          md.objectIdField = sData.objectIdField || (() => {
            console.error(`Encountered service with no OID defined: ${url}`);
            return "";
          })();
        }
        if (sData.type === "Feature Layer") {
          md.geometryType = this.$iApi.geo.geom.serverGeomTypeToRampGeomType(sData.geometryType);
          if (sData.drawingInfo?.renderer) {
            md.renderer = fromJSON$1(sData.drawingInfo.renderer);
          }
          if (sData.sourceSpatialReference) {
            md.sourceSR = SpatialReference.fromConfig(sData.sourceSpatialReference);
          }
        } else {
          md.mapLayer = false;
        }
      }
    } else {
      md.dataFormat = DataFormat.ESRI_RASTER;
    }
    return md;
  }
  /**
   * Will fetch the feature count for an ArcGIS Server layer
   *
   * @param serviceUrl url of the layer to count
   * @param permanentFilter optional filter to apply to the count
   * @returns {Promise} that resolves with the feature count, -1 if error
   */
  async loadFeatureCount(serviceUrl, permanentFilter = "") {
    if (!serviceUrl) {
      console.error("A layer without a url attempted to run the server based feature count routine.");
      return 0;
    }
    const restParam = {
      query: {
        f: "json",
        where: permanentFilter || "1=1",
        // apparently the 1=1 is required to make the count call work on entire dataset
        returnCountOnly: true,
        returnGeometry: false
      }
    };
    const [err, serviceResult] = await to(EsriRequest(`${serviceUrl}/query`, restParam));
    if (!serviceResult) {
      console.error(`Feature count request unsuccessful: ${serviceUrl}`, err);
      return 0;
    }
    if (!serviceResult.data) {
      console.error(`Unable to load feature count: ${serviceUrl}`);
      return 0;
    }
    if (Number.isInteger(serviceResult.data.count)) return serviceResult.data.count;
    else {
      console.error(`Funny result (${serviceResult.data.count}) during feature count: ${serviceUrl}`);
      return 0;
    }
  }
}

class LayerInstance extends APIScope {
  config = {};
  /**
   * ID of this layer. Also known as the layerId.
   *
   * @type {string}
   * @memberof LayerInstance
   */
  id;
  /**
   * Unique identifier for this layer. Randomly generated at runtime.
   */
  uid;
  /**
   * The name of the layer.
   */
  name;
  /**
   * State of the actual layer on the map, such as loading, loaded, error'd.
   */
  layerState;
  /**
   * State of the initiation / termination process of the layer
   */
  initiationState;
  /**
   * State of drawing / refreshing data for a layer
   */
  drawState;
  /**
   * Index of the layer. Aligns to index of arcgis server source, or defaults to 0 on other layers.
   * Map Image Layers and layers that do not support attributes have a value of -1
   */
  layerIdx;
  /**
   * Type of layer this is (describes the overall layer)
   */
  layerType;
  /**
   * How the layer is instantiated in the map stack
   */
  layerFormat;
  /**
   * The type of spatial data used to generate layer content
   */
  dataFormat;
  /**
   * If the layer type can support an identify request
   */
  supportsIdentify;
  /**
   * If the layer type can support Feature type requests and operations
   */
  supportsFeatures;
  /**
   * If the layer type can exist on the map
   */
  mapLayer;
  /**
   * Feature count
   */
  featureCount;
  /**
   * Array of field definitions about the given layer's fields. Non-feature layers will have empty arrays.
   */
  fields;
  /**
   * Comma delimited string of field names (or '*' for all). Useful for numerous ESRI api calls. Non-feature layers will return empty string;
   */
  fieldList;
  /**
   * Field name that contains value considered the name of a feature. Not applicable for non-feature layers.
   */
  nameField;
  /**
   * Field name that contains the object ID of a feature. Not applicable for non-feature layers.
   */
  oidField;
  /**
   * Object that contains values for the expected draw/response time.
   */
  expectedTime;
  /**
   * Timecode value for the start of most recent cancel request.
   * Used to avoid races between async things returning after layers cancel or reload.
   */
  lastCancel;
  /**
   * If the layer has Sublayers
   */
  supportsSublayers;
  /**
   * If the layer is a Sublayer
   */
  isSublayer;
  /**
   * Tracks if layer is removed from map. Is false during the period "before" the layer gets added to map.
   */
  isRemoved;
  /**
   * If the layer was sourced from a file or a WFS source (which disconnects after load).
   */
  isFile;
  /**
   * If the layer is non-interactive and only displays content on the map
   */
  isCosmetic;
  /**
   * If the layer was added by user interaction during the session
   */
  userAdded;
  /**
   * If the layer is set to participate in identify requests
   */
  identify;
  /**
   * The type of logic used to identify items on the layer
   */
  identifyMode;
  /**
   * If the layer should show hovertips on the map
   */
  hovertips;
  /**
   * The geometry type of the layer.
   */
  geomType;
  /**
   * Legend symbols of the layer
   */
  legend;
  /**
   *  The internal ESRI API layer
   */
  esriLayer;
  /**
   *  The internal ESRI API sublayer. Valid only by sublayers
   */
  esriSubLayer;
  /**
   * The internal ESRI API layer view
   */
  esriView;
  /**
   * The extent of the layer on the map
   */
  extent;
  // layer extent
  /**
   * The spatial reference of the source of geometry (e.g. map server). Undefined for non-ArcServer and non-spatial layers.
   */
  sourceSR;
  /**
   * Indicates if the layer can be modified with filters.
   */
  canModifyLayer;
  /**
   * Indicates if the layer can be reloaded.
   */
  canReload;
  /**
   * url of the service
   */
  url;
  _parentLayer;
  _sublayers;
  /**
   * Creates an instance of LayerInstance.
   *
   * @param {string} id
   * @param {InstanceAPI} iApi
   * @memberof FixtureInstance
   */
  constructor(config, iApi) {
    super(iApi);
    this.config = config;
    this.id = "";
    this.uid = "";
    this.name = "error";
    this.layerState = LayerState.NEW;
    this.drawState = DrawState.NOT_LOADED;
    this.initiationState = InitiationState.NEW;
    this.layerIdx = -1;
    this.layerFormat = LayerFormat.UNKNOWN;
    this.layerType = LayerType.UNKNOWN;
    this.dataFormat = DataFormat.UNKNOWN;
    this.supportsIdentify = false;
    this.identifyMode = LayerIdentifyMode.NONE;
    this.supportsFeatures = false;
    this.mapLayer = true;
    this.featureCount = 0;
    this.fields = [];
    this.fieldList = "";
    this.nameField = "";
    this.oidField = "";
    this.supportsSublayers = false;
    this.isSublayer = false;
    this.isRemoved = false;
    this.isFile = false;
    this.isCosmetic = false;
    this.userAdded = false;
    this.identify = false;
    this.hovertips = false;
    this.geomType = GeometryType.UNKNOWN;
    this.legend = [];
    this._sublayers = [];
    this.expectedTime = { draw: 0, load: 0, fail: 0 };
    this.lastCancel = 0;
    this.canModifyLayer = true;
    this.canReload = true;
    this.url = "";
  }
  /**
   * Sets up the internal layer object (ESRI) and initiates the loading process.
   * The promise returned resolves when the object exists (i.e. .esriLayer is populated).
   * This means the layer can be added to the map.
   */
  async initiate() {
    return Promise.resolve();
  }
  /**
   * Resets the layer class to the state it was in "pre-initialize". Implementers can decide if they want
   * to retain any state (e.g. UIDs/layerTree would be a good idea).
   * Also an appropriate function to remove any event listeners/triggers.
   * This would be called in situations like a layer getting deleted, or in a layer reload (initialize would be called again afterwards).
   * Note this does not remove any layers from the map stack, that must be done by the caller.
   */
  async terminate() {
    return Promise.resolve();
  }
  /**
   * Attempts to reload the internal layer object (ESRI).
   * Effectively doing a terminate then initiate, and removing/re-adding layer to the map.
   */
  async reload() {
    return Promise.resolve();
  }
  /**
   * Cancels an in-progress initialize or load of the layer and places it in an Error state.
   * Has no effect on a layer that is loaded, has been terminated, or never initiazed.
   */
  cancelLoad() {
  }
  /**
   * If layer is map bound, and has an esri layer in the esri map, remove it from esri map.
   * Typically should only be called by RAMP internals.
   */
  removeEsriLayer() {
  }
  /**
   * Provides a promise that resolves when the layer has finished loading. If accessing layer properties that
   * depend on the layer being loaded, wait on this promise before accessing them.
   *
   * @method loadPromise
   * @returns {Promise} resolves when the layer has finished loading
   */
  loadPromise() {
    return Promise.resolve();
  }
  /**
   * Indicates if the layer is in a state that is makes sense to interact with.
   * I.e. False if layer has not done it's initial load, or is in error state.
   * Acts as a handy shortcut to inspecting the layerState.
   *
   * @method isLoaded
   * @returns {Boolean} true if layer is loaded
   */
  get isLoaded() {
    return false;
  }
  /**
   * Indicates if the Esri map layer or data layer equivalent exists.
   */
  get layerExists() {
    return false;
  }
  /**
   * Gets the fields whose string values should be trimmed.
   * @returns {Array<string>} the field names.
   */
  getFieldsToTrim() {
    return [];
  }
  /**
   * Provides a tree structure describing the layer and any sublayers,
   * including uid values. Should only be called after loadPromise resolves.
   *
   * @method getLayerTree
   * @returns {TreeNode} the root of the layer tree
   */
  getLayerTree() {
    return new TreeNode(0, "Fake tree", "getLayerTree() was not implemented in layer");
  }
  /**
   * Provides the spatial reference of the layer
   *
   * @returns {SpatialReference} the layer spatial reference in RAMP API format
   */
  getSR() {
    return SpatialReference.latLongSR();
  }
  /**
   * Returns the visibility of the layer.
   *
   * @returns {Boolean} visibility of the layer
   */
  get visibility() {
    return false;
  }
  /**
   * Applies visibility to layer.
   *
   * @param {Boolean} value the new visibility setting
   */
  set visibility(value) {
  }
  /**
   * Returns the opacity of the layer.
   *
   * @returns {Boolean} opacity of the layer
   */
  get opacity() {
    return 0;
  }
  /**
   * Applies opacity to layer.
   *
   * @param {Boolean} value the new opacity setting
   */
  set opacity(value) {
  }
  /**
   * Returns the scale set (min and max visible scale) of the layer.
   *
   * @returns {ScaleSet} scale set of the layer
   */
  get scaleSet() {
    return new ScaleSet();
  }
  /**
   * Set the scale set (min and max visible scale) of the layer.
   *
   * @param {ScaleSet} scaleSet the new scale set of the layer
   */
  set scaleSet(scaleSet) {
  }
  /**
   * Indicates if the layer is not in a visible scale range.
   *
   * @function isOffscale
   * @param {Integer} [testScale] optional scale to test against. if not provided, current map scale is used.
   * @returns {Boolean} true if the layer is outside of a visible scale range
   */
  isOffscale(testScale = void 0) {
    return false;
  }
  /**
   * Cause the map to zoom to a scale level where the layer is visible.
   *
   * @returns {Promise} resolves when map has finished zooming
   */
  zoomToVisibleScale() {
    return Promise.resolve();
  }
  /**
   * Cause the map to zoom to this layer's boundary extent
   *
   * @returns {Promise} resolves when map has finished zooming
   */
  zoomToLayerBoundary() {
    return Promise.resolve();
  }
  /**
   * Get the click tolerance in pixels for this layer
   *
   * @returns {number} the mouse tolerance of this layer
   */
  get mouseTolerance() {
    return 0;
  }
  /**
   * Set the mouse tolerance for this layer in pixels
   *
   * @param {Integer} tolerance the new mouse tolerance
   */
  set mouseTolerance(tolerance) {
  }
  /**
   * Get the touch tolerance in pixels for this layer
   *
   * @returns {number} the touch tolerance of this layer
   */
  get touchTolerance() {
    return 0;
  }
  /**
   * Set the touch tolerance in pixels for this layer
   *
   * @param {Integer} tolerance the new touch tolerance
   */
  set touchTolerance(tolerance) {
  }
  /**
   * Return the draw order for the layer, if applicable
   */
  get drawOrder() {
    return [];
  }
  /**
   * Indicates if layer should participate in an identify request.
   */
  canIdentify() {
    return false;
  }
  /**
   * Baseline identify function for layers that do not support identify.
   * Will return an empty result. Layers that support identify should override this method.
   * Note: implementations that return real data must make that data reactive()
   *
   * @param options not used, present for nice signature of overrided function
   * @returns {Array} an empty result set
   */
  runIdentify(options) {
    return [];
  }
  /**
   * Invokes the process to get the full set of attribute values for the layer.
   * Repeat calls will re-use the downloaded values unless the values have been explicitly cleared.
   *
   * @returns {Promise} resolves with set of attribute values
   */
  getAttributes() {
    return Promise.resolve({
      features: [],
      oidIndex: {}
    });
  }
  /**
   * Requests that an attribute load request be aborted. Useful when encountering a massive dataset or a runaway process.
   */
  abortAttributeLoad() {
  }
  /**
   * Requests that any downloaded attribute sets or cached geometry be removed from memory. The next requests will pull from the server again.
   */
  clearFeatureCache() {
  }
  /**
   * The number of attributes currently downloaded (will update as download progresses)
   * @returns current download count
   */
  downloadedAttributes() {
    return 0;
  }
  /**
   * Indicates if the attribute load has been aborted.
   * @returns boolean if the process has been stopped
   */
  attribLoadAborted() {
    return false;
  }
  // formerly known as getFormattedAttributes
  /**
   * Invokes the process to get the full set of attribute values for the layer,
   * formatted in a tabular format. Additional data properties are also included.
   * Repeat calls will re-use the downloaded values unless the values have been explicitly cleared.
   *
   * @returns {Promise} resolves with set of tabular attribute values
   */
  getTabularAttributes() {
    return Promise.resolve({
      columns: [],
      rows: [],
      fields: [],
      oidField: "error"
    });
  }
  /**
   * Gets information on a graphic in the most efficient way possible. Options object properties:
   * - getGeom ; a boolean to indicate if the result should include graphic geometry
   * - getAttribs ; a boolean to indicate if the result should include graphic attributes
   * - getStyle ; a boolean to indicate if the result should graphical styling information
   *
   * All option properties are optional and default to false
   *
   * @param {Integer} objectId the object id of the graphic to find
   * @param {Object} options options object for the request, see above
   * @returns {Promise} resolves with a Graphic containing the requested information
   */
  getGraphic(objectId, options) {
    return Promise.resolve(new Graphic(new NoGeometry()));
  }
  /**
   * Gets the icon for a specific feature, as an SVG string.
   *
   * @param {Integer} objectId the object id of the feature to find
   * @returns {Promise} resolves with an svg string encoding of the icon
   */
  getIcon(objectId) {
    return Promise.resolve("");
  }
  /**
   * Returns the value of a named SQL filter for the layer.
   *
   * @param {String} filterKey the filter key / named filter to view
   * @returns {String} the value of the where clause for the filter. Empty string if not defined.
   */
  getSqlFilter(filterKey) {
    return "";
  }
  /**
   * Applies an SQL filter to the layer. Will overwrite any existing filter for the given key.
   * Use `1=2` for a "hide all" where clause.
   *
   * @param {String} filterKey the filter key / named filter to apply the SQL to
   * @param {String} whereClause the WHERE clause of the filter
   */
  setSqlFilter(filterKey, whereClause) {
  }
  /**
   * Applies the current filter settings to the physical map layer.
   *
   * @function applySqlFilter
   * @param {Array} [exclusions] list of any filters to exclude from the result. omission includes all keys
   */
  applySqlFilter(exclusions = []) {
  }
  /**
   * Gets array of object ids that currently pass any filters for the layer
   *
   * @param {Array} [exclusions] list of any filters keys to exclude from the result. omission includes all filters
   * @param {Extent} [extent] if provided, the result list will only include features intersecting the extent
   * @returns {Promise} resolves with array of object ids that pass the filter. if no filters are active, resolves with undefined.
   */
  getFilterOIDs(exclusions = [], extent = void 0) {
    return Promise.resolve(void 0);
  }
  /**
   * Gets the extent where the provided object id is on the map.
   * Can only be used on feature layers. Not applicable to point geometry.
   *
   * @param objectId the object id to query
   * @returns {Promise} resolves with the extent where the object id is present
   */
  getGraphicExtent(objectId) {
    return Promise.resolve(Extent.fromParams("fake", 0, 0, 0, 0));
  }
  /**
   * Get the parent layer for this layer
   * Only supported for sublayers
   *
   * @returns {LayerInstance | undefined} the parent layer of this layer
   */
  get parentLayer() {
    if (!this.isSublayer) {
      throw new Error("Attempted to get parent layer of a non-sublayer object");
    } else {
      return this._parentLayer;
    }
  }
  /**
   * Set the parent layer for this layer
   * Only supported for sublayers
   *
   * @param {LayerInstance | undefined} layer the new parent layer for this layer
   */
  set parentLayer(layer) {
    if (!this.isSublayer && layer) {
      throw new Error("Attempted to set parent layer for a non-sublayer object");
    } else {
      this._parentLayer = layer;
    }
  }
  /**
   * Get the sublayers for this layer
   *
   * @returns {Array<LayerInstance>} the sublayers of this layer
   */
  get sublayers() {
    return this._sublayers;
  }
  /**
   * Initiates actions after layer load.
   * Should generally only be called internally by the RAMP core.
   */
  onLoad() {
  }
  /**
   * Initiates actions after layer load error.
   * Should generally only be called internally by the RAMP core.
   * @param {boolean} [genuineError=true] Flag to detect error setting due to manual cancellation. Only genuine errors will raise notifications.
   */
  onError(genuineError = true) {
  }
  /**
   * Updates layer load state and raises events.
   * Should generally only be called internally by the RAMP core.
   * @param {LayerState} newState load state the layer is entering
   * @param {Boolean} [userCancel=false] optional flag to indicate if an error state was intentional due to a user cancel request
   */
  updateLayerState(newState, userCancel = false) {
  }
  /**
   * Updates layer draw state and raises events.
   * Should generally only be called internally by the RAMP core.
   */
  updateDrawState(newState) {
  }
  /**
   * Updates layer layer state and raises events.
   * Should generally only be called internally by the RAMP core.
   */
  updateInitiationState(newState) {
  }
  /**
   * Finds an sublayer index corresponding to the given uid.
   * -1 indicates the uid targets the root layer
   *
   * @private
   * @param {string} uid the uid we want the index for
   * @returns {number} the integer index of the uid
   */
  uidToIdx(uid) {
    if (uid === this.uid) {
      return -1;
    } else {
      const sublayerIdx = this._sublayers.findIndex((sublayer) => sublayer?.uid === uid);
      if (sublayerIdx === -1) {
        throw new Error(`Attempt to access non-existing unique id [layerid ${this.id}, uid ${uid}]`);
      } else {
        return sublayerIdx;
      }
    }
  }
  /**
   * Attempts to get an sublayer based on the index or uid provided.
   *
   * @private
   * @param {number | string} layerIdx the uid or numeric index of the item we are interested in
   * @returns {LayerInstance | undefined} the matching feature class object, or undefined if the root was requested
   */
  getSublayer(layerIdx) {
    if (!this.supportsSublayers) {
      console.warn(`Attempted to call getSublayer on a layer (layer id: ${this.id}) that does not support FCs`);
      return void 0;
    }
    let workingIdx;
    if (typeof layerIdx === "string") {
      workingIdx = this.uidToIdx(layerIdx);
    } else {
      workingIdx = layerIdx;
    }
    if (this._sublayers[workingIdx] === void 0) {
      throw new Error(
        `Attempt to access non-existing layer index [layerid ${this.id}, lookup value ${layerIdx}]`
      );
    }
    return this._sublayers[workingIdx];
  }
  /**
   * Check if layer controls is available on this layer.
   *
   * @param {LayerControl} control the layer control to check
   * @returns {boolean} Indicates if the given control is enabled on this layer
   */
  controlAvailable(control) {
    const controls = this.$iApi.geo.layer.getLayerControls(this.id);
    return this.$iApi.geo.shared.controlAvailable(control, controls);
  }
}

class CommonLayer extends LayerInstance {
  // common layer properties
  /**
   * Tracks load and draw elapsed time
   */
  timers;
  origRampConfig;
  loadDefProm;
  // a deferred promise that resolves when layer is fully ready and safe to use. for convenience of caller
  /**
   * A boolean to track whether the promise is pending (false) or fulfilled/rejected (true)
   */
  loadPromDone;
  layerTree;
  // ----------- LAYER CONSTRUCTION AND INITIALIZAION -----------
  constructor(rampConfig, $iApi) {
    super(rampConfig, $iApi);
    this.name = rampConfig.name || "";
    this.geomType = GeometryType.NONE;
    this.dataFormat = DataFormat.UNKNOWN;
    this.layerType = LayerType.UNKNOWN;
    this.layerFormat = LayerFormat.UNKNOWN;
    const defaultTimes = $iApi.geo.map.layerDefaultTimes;
    this.expectedTime.draw = rampConfig.expectedDrawTime ?? defaultTimes.draw;
    this.expectedTime.load = rampConfig.expectedLoadTime ?? defaultTimes.load;
    this.expectedTime.fail = rampConfig.maxLoadTime || defaultTimes.fail;
    this.lastCancel = 0;
    this.timers = {
      draw: void 0,
      load: void 0
    };
    this.origRampConfig = rampConfig;
    this.id = rampConfig.id || "";
    this.uid = this.$iApi.geo.shared.generateUUID();
    this.isCosmetic = false;
    this.isRemoved = false;
    this.isSublayer = false;
    this.supportsIdentify = false;
    this.mapLayer = true;
    this.identifyMode = LayerIdentifyMode.NONE;
    this.supportsFeatures = false;
    this.hovertips = false;
    this.supportsSublayers = false;
    this.isFile = false;
    this.layerState = LayerState.NEW;
    this.initiationState = InitiationState.NEW;
    this.drawState = DrawState.NOT_LOADED;
    this.loadDefProm = new DefPromise();
    this.url = this.origRampConfig.url;
    this.canReload = !!(this.url || this.origRampConfig.caching);
    this.loadPromDone = false;
    this.layerTree = new TreeNode(0, this.uid, this.name, true);
  }
  updateInitiationState(newState) {
    this.initiationState = newState;
    this.$iApi.event.emit(GlobalEvents.LAYER_INITIATIONSTATECHANGE, {
      state: newState,
      layer: this
    });
  }
  updateLayerState(newState, userCancel = false) {
    this.layerState = newState;
    this.$iApi.event.emit(GlobalEvents.LAYER_LAYERSTATECHANGE, {
      state: newState,
      layer: this,
      userCancel
    });
  }
  updateDrawState(newState) {
    this.drawState = newState;
    if (newState === DrawState.REFRESH) {
      this.startTimer("draw" /* DRAW */);
    } else if (newState === DrawState.UP_TO_DATE) {
      this.stopTimer("draw" /* DRAW */);
    }
    this.$iApi.event.emit(GlobalEvents.LAYER_DRAWSTATECHANGE, {
      state: newState,
      layer: this
    });
  }
  // need this so initiate encapsulates the entire initiation process regardless of which inherited layer type is being initiated
  async initiate() {
    this.updateInitiationState(InitiationState.INITIATING);
    this.startTimer("load" /* LOAD */);
    const failStepsHelper = (consoleMessage) => {
      if (this.layerState !== LayerState.ERROR) {
        console.error(consoleMessage);
        this.onError();
      }
    };
    const startTime = Date.now();
    const initTimeout = setTimeout(() => {
      if (startTime > this.lastCancel) {
        this.lastCancel = Date.now();
        failStepsHelper("Layer timed out during initialize. Id: " + this.id);
      }
    }, this.expectedTime.fail);
    const [initiateErr] = await to(this.onInitiate());
    clearTimeout(initTimeout);
    if (startTime > this.lastCancel) {
      if (this.drawState !== DrawState.UP_TO_DATE) {
        this.startTimer("draw" /* DRAW */);
      }
      if (initiateErr) {
        failStepsHelper(`Init error on layer id: ${this.id} . ${initiateErr.message}`);
      } else {
        this.updateInitiationState(InitiationState.INITIATED);
      }
    }
  }
  async onInitiate() {
    if (this.isSublayer) {
      console.warn("Attempted to initiate a sublayer as a CommonLayer");
      return Promise.resolve();
    }
    if (this.initiationState === InitiationState.INITIATED) {
      console.error(`Encountered layer initialize while already initiated, layer id ${this.id}`);
    }
  }
  async terminate() {
    this.updateInitiationState(InitiationState.TERMINATING);
    await Promise.all(this.sublayers.map((s) => s.terminate()));
    this.loadDefProm = new DefPromise();
    this.loadPromDone = false;
    this.updateLayerState(LayerState.NEW);
    this.updateDrawState(DrawState.NOT_LOADED);
    this.updateInitiationState(InitiationState.TERMINATED);
  }
  // ----------- LAYER LOAD -----------
  // When esri layer or data layer loads, this will perform any additional layer setup.
  // The layer status will be set to loaded once everything has finished.
  onLoad() {
    const startTime = Date.now();
    let timedOut = false;
    const loadTimeout = setTimeout(() => {
      timedOut = true;
      this.onError();
    }, this.expectedTime.fail);
    try {
      const loadPromises = this.onLoadActions();
      Promise.all(loadPromises).then(() => {
        clearTimeout(loadTimeout);
        if (!timedOut) {
          this.stopTimer("load" /* LOAD */);
          if (startTime > this.lastCancel) {
            if (this.loadPromDone) {
              this.loadDefProm = new DefPromise();
            }
            this.loadDefProm.resolveMe();
            this.loadPromDone = true;
            this.sublayers.forEach((sublayer) => sublayer.onLoad());
            this.updateLayerState(LayerState.LOADED);
          }
        } else {
          this.visibility = false;
        }
      }).catch(() => {
        clearTimeout(loadTimeout);
        this.onError();
      });
    } catch (err) {
      console.error("Encountered error on layer load: ", err);
      clearTimeout(loadTimeout);
      this.onError();
    }
  }
  onError(genuineError = true) {
    if (this.layerState === LayerState.ERROR) {
      return;
    }
    if (this.initiationState === InitiationState.INITIATING) {
      this.updateInitiationState(InitiationState.NEW);
    }
    if (this.loadPromDone) {
      this.loadDefProm = new DefPromise();
    }
    this.loadDefProm.rejectMe();
    this.loadPromDone = true;
    this.sublayers.forEach((sublayer) => sublayer.onError(genuineError));
    if (genuineError) {
      this.$iApi.notify.show(
        NotificationType.ERROR,
        this.$iApi.$i18n.t("layer.error", {
          id: this.id
        })
      );
    }
    this.stopTimer("draw" /* DRAW */);
    this.stopTimer("load" /* LOAD */);
    this.updateLayerState(LayerState.ERROR, !genuineError);
  }
  /**
   * Performs setup on the layer that needs to occur after initialization and
   * the esri layer (if a map layer) loads, but before we mark the layer as loaded.
   * Any async tasks must include their promise in the return array.
   *
   * @private
   * @returns {Array<Promise<void>>} List of things to wait on.
   */
  onLoadActions() {
    return [];
  }
  cancelLoad() {
    if (this.isLoaded || this.initiationState === InitiationState.NEW || this.initiationState === InitiationState.TERMINATING || this.initiationState === InitiationState.TERMINATED) {
      return;
    }
    this.lastCancel = Date.now();
    if (this.esriLayer && this.esriLayer.loadStatus === "loading") {
      this.esriLayer.cancelLoad();
    }
    this.removeEsriLayer();
    this.onError(false);
  }
  loadPromise() {
    return this.loadDefProm.getPromise();
  }
  get isLoaded() {
    return this.layerState === LayerState.LOADED;
  }
  // ----------- LAYER MANAGEMENT -----------
  /**
   * Indicates if layer should participate in an identify request.
   */
  canIdentify() {
    return this.supportsIdentify && this.isLoaded && this.visibility && this.identify && !this.scaleSet.isOffScale(this.$iApi.geo.map.getScale()).offScale;
  }
  /**
   * Provides a tree structure describing the layer and any sublayers,
   * including uid values. Should only be called after loadPromise resolves.
   *
   * @method getLayerTree
   * @returns {TreeNode} the root of the layer tree
   */
  getLayerTree() {
    return this.layerTree;
  }
  // ----------- STUB METHODS -----------
  // these are here to provide a consistant method interface when calling methods are
  // dealing with vars typed as BaseLayer. Layer classes that actually use these
  // methods will override the stubs.
  stubError() {
    throw new Error(`Attempted to use a method not valid for ${this.layerType}`);
  }
  /**
   * Invokes the process to get the full set of attribute values for the layer.
   * Repeat calls will re-use the downloaded values unless the values have been explicitly cleared.
   *
   * @returns {Promise} resolves with set of attribute values
   */
  getAttributes() {
    this.stubError();
    return Promise.resolve({
      features: [],
      oidIndex: {}
    });
  }
  abortAttributeLoad() {
    this.stubError();
  }
  clearFeatureCache() {
    this.stubError();
  }
  getTabularAttributes() {
    this.stubError();
    return Promise.resolve({
      columns: [],
      rows: [],
      fields: [],
      oidField: "error"
    });
  }
  /**
   * Gets information on a graphic in the most efficient way possible. Options object properties:
   * - getGeom ; a boolean to indicate if the result should include graphic geometry
   * - getAttribs ; a boolean to indicate if the result should include graphic attributes
   * - getStyle ; a boolean to indicate if the result should include symbol styling information
   *
   * @param {Integer} objectId the object id of the graphic to find
   * @param {Object} options options object for the request, see above
   * @returns {Promise} resolves with a Graphic containing the requested information
   */
  getGraphic(objectId, options) {
    this.stubError();
    return Promise.resolve(new Graphic(new NoGeometry()));
  }
  getIcon(objectId) {
    this.stubError();
    return Promise.resolve("");
  }
  getSqlFilter(filterKey) {
    this.stubError();
    return "";
  }
  setSqlFilter(filterKey, whereClause) {
    this.stubError();
  }
  getFilterOIDs(exclusions = [], extent = void 0) {
    this.stubError();
    return Promise.resolve(void 0);
  }
  /**
   * Gets the extent where the provided object id is on the map.
   * Can only be used on feature layers with multipoint, polyline, polygon geometry.
   *
   * @param objectId the object id to query
   * @returns {Promise} resolves with the extent where the object id is present
   */
  getGraphicExtent(objectId) {
    this.stubError();
    return Promise.resolve(Extent.fromParams("fake", 0, 0, 0, 0));
  }
  applySqlFilter(exclusions = []) {
    this.stubError();
  }
  /**
   * Add a WMS layer parameter, maybe even refresh the layer
   *
   * @function setCustomParameter
   * @param {String} key name of the key to be created or updated
   * @param {String} value value of the key
   * @param {Boolean} forceRefresh show the new fancy version of the layer or not
   */
  setCustomParameter(key, value, forceRefresh = true) {
    this.stubError();
  }
  /**
   * Start the draw/load timer for the layer, after which is a slow to load/draw notification is shown.
   * @param type the type of timer to start (load or draw)
   */
  startTimer(type) {
    this.stopTimer(type);
    if (this.expectedTime[type] > 0) {
      this.timers[type] = window.setTimeout(
        () => this.$iApi.notify.show(
          NotificationType.WARNING,
          // layer.longload or layer.longdraw
          this.$iApi.$i18n.t(`layer.long${type}`, {
            id: this.name || this.id
          })
        ),
        this.expectedTime[type]
      );
    }
  }
  /**
   * Stop the draw/load timer for the layer, if it was started.
   * @param type the type of timer to stop (load or draw)
   */
  stopTimer(type) {
    if (this.timers[type]) {
      clearTimeout(this.timers[type]);
      this.timers[type] = void 0;
    }
  }
}

class MapLayer extends CommonLayer {
  // common layer properties
  _serverVisibility;
  _scaleSet;
  _mouseTolerance;
  _touchTolerance;
  _drawOrder;
  // used to manage debouncing when applying filter updates against a layer. Private! but needs to be seen by FCs.
  _lastFilterUpdate = "";
  viewDefProm;
  // a deferred promise that resolves when a layer view has been created on the map. helps bridge the view handler with the layer load handler
  esriWatches;
  // ----------- LAYER CONSTRUCTION AND INITIALIZAION -----------
  constructor(rampConfig, $iApi) {
    super(rampConfig, $iApi);
    this._scaleSet = new ScaleSet();
    this._mouseTolerance = rampConfig.mouseTolerance != void 0 ? rampConfig.mouseTolerance : 5;
    this._touchTolerance = rampConfig.touchTolerance != void 0 ? rampConfig.touchTolerance : 15;
    this._drawOrder = [];
    this._serverVisibility = void 0;
    this.isCosmetic = rampConfig.cosmetic || false;
    this.extent = rampConfig.extent ? Extent.fromConfig(`${this.id}_extent`, rampConfig.extent) : void 0;
    this.viewDefProm = new DefPromise();
    this.esriWatches = [];
  }
  noLayerErr() {
    console.error(
      "Attempted to manipulate the layer but no layer found. Likely .initiate() was not finished or failed. Layer id " + this.id
    );
    console.trace();
  }
  notLoadedErr() {
    console.error("Attempted to manipulate the layer before it was loaded. Layer id " + this.id);
    console.trace();
  }
  async onInitiate() {
    await super.onInitiate();
    if (!this.esriLayer) {
      this.noLayerErr();
      return;
    }
    this.esriWatches.push(
      this.esriLayer.watch("visible", (newval) => {
        this.$iApi.event.emit(GlobalEvents.LAYER_VISIBILITYCHANGE, {
          visibility: newval,
          layer: this
        });
      })
    );
    this.esriWatches.push(
      this.esriLayer.watch("opacity", (newval) => {
        this.$iApi.event.emit(GlobalEvents.LAYER_OPACITYCHANGE, {
          opacity: newval,
          layer: this
        });
      })
    );
    this.esriWatches.push(
      this.esriLayer.watch("loadStatus", (newval) => {
        const statemap = {
          "not-loaded": LayerState.LOADING,
          loading: LayerState.LOADING,
          loaded: LayerState.LOADED,
          failed: LayerState.ERROR
        };
        if (newval === "loaded") {
          this.onLoad();
        } else if (newval === "failed") {
          this.onError();
        } else {
          this.updateLayerState(statemap[newval]);
        }
      })
    );
    this.esriLayer.on("layerview-create", (e) => {
      this.esriView = e.layerView;
      this.esriWatches.push(
        e.layerView.watch("updating", (newval) => {
          this.updateDrawState(newval ? DrawState.REFRESH : DrawState.UP_TO_DATE);
        })
      );
      this.viewDefProm.resolveMe();
    });
    this.sublayers.forEach((s) => s.initiate());
  }
  async terminate() {
    this.esriLayer = void 0;
    await super.terminate();
    this.viewDefProm = new DefPromise();
    this.esriWatches.forEach((w) => w.remove());
    this.esriWatches = [];
  }
  async reload() {
    if (!this.$iApi.geo.map.esriMap) {
      console.error("Attempted layer reload when no map exists");
      return;
    }
    this.removeEsriLayer();
    const startTime = Date.now();
    this.$iApi.event.emit(GlobalEvents.LAYER_RELOAD_START, this);
    this.sublayers.forEach((sublayer) => this.$iApi.event.emit(GlobalEvents.LAYER_RELOAD_START, sublayer));
    await this.terminate();
    await this.initiate();
    if (this.lastCancel > startTime) {
      return;
    }
    if (!this.esriLayer) {
      console.error("ESRI layer failed to re-create during reload.");
      return;
    }
    this.$iApi.geo.map.insertToEsriMap(this);
    this.$iApi.event.emit(GlobalEvents.LAYER_RELOAD_END, this);
    this.sublayers.forEach((sublayer) => this.$iApi.event.emit(GlobalEvents.LAYER_RELOAD_END, sublayer));
  }
  /**
   * Take a layer config from the RAMP application and derives a configuration for an ESRI layer
   *
   * @param rampLayerConfig snippet from RAMP for this layer
   * @returns configuration object for the ESRI layer representing this layer
   */
  makeEsriLayerConfig(rampLayerConfig) {
    const esriConfig = {
      id: rampLayerConfig.id,
      url: rampLayerConfig.url,
      opacity: rampLayerConfig?.state?.opacity ?? 1,
      visible: rampLayerConfig?.state?.visibility ?? true
    };
    return esriConfig;
  }
  removeEsriLayer() {
    if (this.esriLayer && this.$iApi.geo.map.esriMap) {
      const tempPosition = this.$iApi.geo.map.esriMap.layers.findIndex((l) => l.id === this.id);
      if (tempPosition > -1) {
        this.$iApi.geo.map.esriMap.layers.remove(this.esriLayer);
      }
    }
  }
  // ----------- LAYER LOAD -----------
  onLoadActions() {
    const proms = super.onLoadActions();
    if (!this.name) {
      this.name = this.esriLayer?.title || this.id;
    }
    if (!this.isCosmetic) {
      this.identify = this.config.state?.identify ?? this.supportsIdentify;
    }
    const lookupPromise = this.$iApi.geo.proj.checkProj(this.getSR()).then((goodSR) => {
      if (goodSR) {
        return Promise.resolve();
      } else {
        return Promise.reject();
      }
    });
    proms.push(lookupPromise);
    return proms;
  }
  // ----------- LAYER MANAGEMENT -----------
  /**
   * Wraps an error test for when someone calls a map dependent function too early
   * @private
   */
  mapCheck() {
    if (this.$iApi.geo.map.created) {
      return true;
    } else {
      console.error("Attempting to use map-dependent logic before the layer has been added to the map");
      console.trace();
      return false;
    }
  }
  /**
   * Returns the scale set (min and max visible scale) of the layer.
   *
   * @returns {ScaleSet} scale set of the layer
   */
  get scaleSet() {
    return this._scaleSet;
  }
  /**
   * Set the scale set (min and max visible scale) of the layer.
   *
   * @param {ScaleSet} scaleSet the new scale set of the layer
   */
  set scaleSet(scaleSet) {
    this._scaleSet = scaleSet;
  }
  /**
   * Indicates if the layer is not in a visible scale range.
   *
   * @function isOffscale
   * @param {Integer} [testScale] optional scale to test against. if not provided, current map scale is used.
   * @returns {Boolean} true if the layer is outside of a visible scale range
   */
  isOffscale(testScale = void 0) {
    let mahScale;
    if (typeof testScale === "undefined") {
      if (this.mapCheck()) {
        mahScale = this.$iApi.geo.map.getScale();
      } else {
        return false;
      }
    } else {
      mahScale = testScale;
    }
    return this.scaleSet.isOffScale(mahScale).offScale;
  }
  /**
   * Cause the map to zoom to a scale level where the layer is visible.
   *
   * @returns {Promise} resolves when map has finished zooming
   */
  zoomToVisibleScale() {
    if (this.mapCheck()) {
      return this.$iApi.geo.map.zoomToVisibleScale(this.scaleSet);
    } else {
      return Promise.resolve();
    }
  }
  /**
   * Cause the map to zoom to this layer's boundary extent
   *
   * @returns {Promise} resolves when map has finished zooming
   */
  zoomToLayerBoundary() {
    if (!this.extent) {
      console.error(`Attempted to zoom to boundary of a layer with no extent (Layer Id: ${this.id})`);
      return Promise.resolve();
    }
    if (this.mapCheck()) {
      return this.$iApi.geo.map.zoomMapTo(this.extent);
    } else {
      return Promise.resolve();
    }
  }
  /**
   * Get the mouse tolerance in pixels for this layer
   *
   * @returns {number} the mouse tolerance of this layer
   */
  get mouseTolerance() {
    return this._mouseTolerance;
  }
  /**
   * Set the mouse tolerance for this layer in pixels
   *
   * @param {number} tolerance the new mouse tolerance
   */
  set mouseTolerance(tolerance) {
    if (!this.supportsIdentify) {
      console.warn("Attempted to set click tolerance on a layer that doesn't support identify");
      return;
    }
    if (tolerance < 0) {
      console.error("Attempted to set a negative click tolerance");
      return;
    }
    this._mouseTolerance = tolerance;
  }
  /**
   * Get the touch tolerance in pixels for this layer
   *
   * @returns {number} the touch tolerance of this layer
   */
  get touchTolerance() {
    return this._touchTolerance;
  }
  /**
   * Set the touch tolerance in pixels for this layer
   *
   * @param {number} tolerance the new touch tolerance
   */
  set touchTolerance(tolerance) {
    if (!this.supportsIdentify) {
      console.warn("Attempted to set touch tolerance on a layer that doesn't support identify");
      return;
    }
    if (tolerance < 0) {
      console.error("Attempted to set a negative touch tolerance");
      return;
    }
    this._touchTolerance = tolerance;
  }
  /**
   * Indicates if the Esri map layer exists
   */
  get layerExists() {
    return this.initiationState === InitiationState.INITIATED && !!this.esriLayer;
  }
  /**
   * Returns an array describing the draw order of features, if applicable.
   */
  get drawOrder() {
    return this._drawOrder;
  }
  /**
   * Returns the visibility of the layer.
   *
   * @returns {Boolean} visibility of the layer
   */
  get visibility() {
    if (this.layerExists) {
      return this.esriLayer.visible;
    } else {
      return false;
    }
  }
  /**
   * Applies visibility to layer.
   *
   * @param {Boolean} value the new visibility setting
   */
  set visibility(value) {
    if (this.layerExists) {
      this.esriLayer.visible = value;
    } else {
      this.noLayerErr();
    }
  }
  /**
   * Checks the visibility of the sublayers
   * If all sublayers are invisible, then this layer is also set to invisible
   *
   * @function checkVisibility
   */
  checkVisibility() {
    if (this.supportsSublayers && this.layerExists) {
      this.visibility = this.sublayers.some((sublayer) => sublayer.visibility);
    }
  }
  /**
   * Returns the opacity of the layer.
   *
   * @returns {number} opacity of the layer (range between 0 and 1)
   */
  get opacity() {
    if (this.layerExists) {
      return this.esriLayer.opacity;
    } else {
      return 0;
    }
  }
  /**
   * Applies opacity to layer.
   *
   * @param {number} value the new opacity setting (range between 0 and 1)
   */
  set opacity(value) {
    if (this.layerExists) {
      this.esriLayer.opacity = value;
    } else {
      this.noLayerErr();
    }
  }
  /**
   * Provides the spatial reference of how the underlying ESRI layer is encoding geometry on the client.
   *
   * @returns {SpatialReference} the layer spatial reference in RAMP API format
   */
  getSR() {
    if (this.esriLayer) {
      return SpatialReference.fromESRI(this.esriLayer.spatialReference);
    } else {
      this.noLayerErr();
      return SpatialReference.latLongSR();
    }
  }
}

class AttribLayer extends MapLayer {
  attribs;
  renderer;
  serviceUrl;
  canModifyLayer;
  filter;
  constructor(rampConfig, $iApi) {
    super(rampConfig, $iApi);
    this.supportsIdentify = true;
    this.geomType = GeometryType.UNKNOWN;
    this.serviceUrl = "";
    this.fieldList = "";
    this.canModifyLayer = true;
    this.filter = new Filter(rampConfig.permanentFilteredQuery || "", rampConfig.initialFilteredQuery || "");
    this.hovertips = rampConfig.state?.hovertips ?? true;
    this.attribs = new AttribSource();
  }
  /**
   * Take a layer config from the RAMP application and derives a configuration for an ESRI layer
   *
   * @param rampLayerConfig snippet from RAMP for this layer
   * @returns configuration object for the ESRI layer representing this layer
   */
  makeEsriLayerConfig(rampLayerConfig) {
    const esriConfig = super.makeEsriLayerConfig(rampLayerConfig);
    return esriConfig;
  }
  // NOTE this logic is for ArcGIS Server sourced things.
  //      other sourced attribute layers should override this function.
  /**
   * Will load and apply metadata from the ArcGIS Server endpoint to this layer.
   *
   * @param options loading options. Currently only supports custom renderer override
   */
  async loadLayerMetadata(options = {}) {
    if (!this.serviceUrl) {
      return;
    }
    const startTime = Date.now();
    const sData = await this.$iApi.geo.layer.loadLayerMetadata(this.serviceUrl);
    if (startTime < this.lastCancel) {
      return;
    }
    this.geomType = sData.geometryType;
    this.attribs.quickCache = new QuickCache(this.geomType);
    this.scaleSet.minScale = sData.minScale;
    this.scaleSet.maxScale = sData.maxScale;
    this.dataFormat = sData.dataFormat;
    this.extent = this.extent ?? sData.extent;
    this._serverVisibility = sData.defaultVisibility;
    if (this.dataFormat === DataFormat.ESRI_FEATURE) {
      this.supportsFeatures = true;
      this.canModifyLayer = this.layerType === LayerType.SUBLAYER ? sData.canModifyLayer : true;
      this.fields = sData.fields;
      this.nameField = sData.displayField;
      this.oidField = sData.objectIdField;
      this.sourceSR = sData.sourceSR;
      this.drawOrder.forEach((d) => {
        if (d.field && this.fields.findIndex((ef) => ef.name === d.field) === -1) {
          console.error(`Draw order for layer ${this.id} references invalid field ${d.field}`);
        }
      });
      const esriRenderer = options && options.customRenderer && options.customRenderer.type ? options.customRenderer : sData.renderer;
      this.renderer = this.$iApi.geo.symbology.makeRenderer(esriRenderer, this.fields);
      this.legend = this.$iApi.geo.symbology.rendererToLegend(this.renderer);
      const loadData = {
        // version number is only provided on 10.0 SP1 servers and up.
        // servers 10.1 and higher support the query limit flag
        supportsLimit: (sData.currentVersion || 1) >= 10.1,
        serviceUrl: this.serviceUrl,
        oidField: this.oidField,
        batchSize: -1,
        attribs: "*",
        // NOTE we set to * here for generic case. Some subclasses will later call updateFieldList() after parsing config field settings
        permanentFilter: this.getSqlFilter(CoreFilter.PERMANENT)
      };
      this.attribs.attLoader = new ArcServerAttributeLoader(this.$iApi, loadData);
      if (!this.origRampConfig.name) {
        this.name = sData.name ?? this.id;
      }
    } else {
      this.supportsFeatures = false;
      this.supportsIdentify = false;
    }
  }
  /**
   * Invokes the process to get the full set of attribute values for the layer.
   * Repeat calls will re-use the downloaded values unless the values have been explicitly cleared.
   *
   * @returns {Promise} resolves with set of attribute values
   */
  getAttributes() {
    return this.attribs.attLoader.getAttribs();
  }
  abortAttributeLoad() {
    this.attribs.attLoader.abortAttribLoad();
  }
  clearFeatureCache() {
    this.attribs.clearAll();
  }
  downloadedAttributes() {
    if (this.isLoaded) {
      return this.attribs.attLoader.loadCount();
    } else {
      return 0;
    }
  }
  attribLoadAborted() {
    if (this.isLoaded) {
      return this.attribs.attLoader.isLoadAborted();
    } else {
      return false;
    }
  }
  getFieldsToTrim() {
    return this.fields.filter((field) => {
      return field.trim;
    }).map((field) => field.name);
  }
  /**
   * Invokes the process to get the full set of attribute values for the layer,
   * formatted in a tabular format. Additional data properties are also included.
   * Repeat calls will re-use the downloaded values unless the values have been explicitly cleared.
   *
   * @returns {Promise} resolves with set of tabular attribute values
   */
  getTabularAttributes() {
    return this.$iApi.geo.attributes.generateTabularAttributes(this, this.attribs);
  }
  async getGraphic(objectId, options) {
    let resultAttribs = {};
    let resultGeom = new NoGeometry();
    const map = this.$iApi.geo.map;
    let needWebAttr = false;
    let needWebGeom = false;
    let scale = 0;
    if (options.getAttribs || options.getStyle) {
      const aCache = this.attribs.quickCache.getAttribs(objectId);
      if (aCache) {
        resultAttribs = aCache;
      } else if (this.attribs.attLoader.isLoaded() || this.isFile) {
        const atSet = await this.attribs.attLoader.getAttribs();
        resultAttribs = atSet.features[atSet.oidIndex[objectId]];
      } else {
        needWebAttr = true;
      }
    }
    if (options.getGeom) {
      scale = map.getScale();
      const gCache = this.attribs.quickCache.getGeom(objectId, scale);
      if (gCache) {
        resultGeom = gCache;
      } else {
        needWebGeom = true;
      }
    }
    if (needWebAttr || needWebGeom) {
      const serviceParams = {
        oid: objectId,
        serviceUrl: this.serviceUrl,
        includeGeometry: needWebGeom,
        attribs: this.fieldList,
        fieldsToTrim: this.getFieldsToTrim()
      };
      if (needWebGeom) {
        serviceParams.mapSR = map.getSR().wkid?.toString();
        if (!this.attribs.quickCache.isPoint) {
          serviceParams.maxOffset = map.esriView?.resolution;
        }
      }
      const webFeat = await this.$iApi.geo.attributes.loadSingleFeature(serviceParams);
      if (needWebGeom) {
        this.attribs.quickCache.setGeom(objectId, webFeat.geometry, scale);
        resultGeom = webFeat.geometry;
      }
      if (needWebAttr || typeof this.attribs.quickCache.getAttribs(objectId) === "undefined") {
        this.attribs.quickCache.setAttribs(objectId, webFeat.attributes);
        if (needWebAttr) {
          resultAttribs = webFeat.attributes;
        }
      }
    }
    const resGraphic = new Graphic(resultGeom, "", options.getAttribs ? resultAttribs : void 0);
    if (options.getStyle) {
      const esriSymb = toRaw(this.renderer.getGraphicSymbol(resultAttribs));
      resGraphic.style = this.$iApi.geo.geom.styleEsriToRamp(esriSymb);
    }
    return resGraphic;
  }
  async getIcon(objectId) {
    if (!this.renderer) {
      throw new Error("getIcon called before renderer is defined");
    }
    const g = await this.getGraphic(objectId, { getAttribs: true });
    return this.$iApi.geo.symbology.getGraphicIcon(g.attributes || {}, this.renderer);
  }
  setSqlFilter(filterKey, whereClause) {
    const currentFilter = this.filter.getSql(filterKey);
    if (whereClause === currentFilter) {
      return;
    }
    this.filter.setSql(filterKey, whereClause);
    this.$iApi.event.emit(GlobalEvents.FILTER_CHANGE, {
      uid: this.uid,
      filterKey
    });
    const debounceKey = `${this.uid}-${filterKey}-${whereClause}`;
    this._lastFilterUpdate = debounceKey;
    const refreshCheck = () => {
      if (this._lastFilterUpdate === debounceKey) {
        this.applySqlFilter();
      }
    };
    setTimeout(refreshCheck, 100);
  }
  applySqlFilter(exclusions = []) {
    throw new Error(
      `attempted to apply sql filter ${exclusions} to a layer not equipped for it. likely a new subclass of AttribLayer did not override applySqlFilter`
    );
  }
  getSqlFilter(filterKey) {
    return this.filter.getSql(filterKey);
  }
  /**
   * Returns a SQL WHERE condition that is combination of active filters.
   *
   * @method getCombinedSqlFilter
   * @param {Array} [exclusions] list of any filter keys to exclude from the result. omission includes all filters
   * @returns {String} all non-excluded sql statements connected with AND operators.
   */
  getCombinedSqlFilter(exclusions) {
    return this.filter.getCombinedSql(exclusions);
  }
  async getFilterOIDs(exclusions = [], extent = void 0) {
    const sql = this.filter.getCombinedSql(exclusions);
    const bExt = !!extent;
    if (!(sql || bExt)) {
      return void 0;
    }
    if (extent) {
      this.filter.setExtent(extent);
    }
    const impactedFilters = this.filter.sqlActiveFilters(exclusions);
    let cache = this.filter.getCache(impactedFilters, bExt);
    if (!cache) {
      const qOpts = {
        filterGeometry: extent,
        filterSql: sql,
        includeGeometry: false,
        sourceSR: this.sourceSR
      };
      cache = this.queryOIDs(qOpts);
      this.filter.setCache(cache, impactedFilters, bExt);
    }
    return cache;
  }
  /**
   * Will return an array of object ids for features in the layer that satisfy the conditions of the query options parameter.
   * @param options {Object} options to provide filters and helpful information.
   * @returns {Promise} resolves with an array of numbers (object ids)
   */
  queryOIDs(options) {
    if (this.isFile) {
      console.error(`a file layer called a server based query function`);
      console.trace();
    }
    const agsOpt = {
      url: this.serviceUrl,
      ...options
    };
    return this.$iApi.geo.query.arcGisServerQueryIds(agsOpt);
  }
  /**
   * Requests a set of features for this layer that match the criteria of the options
   * - filterGeometry : a RAMP API geometry to restrict results to
   * - filterSql : a where clause to apply against feature attributes
   * - includeGeometry : a boolean to indicate if result features should include the geometry
   * - sourceSR : a spatial reference indicating what the source layer is encoded in. providing can assist in result geometry being of a proper resolution
   *
   * Each result item is loaded independently. This will capitalize on caching, but will be expensive
   * when expecting a large result set and nothing currently cached.
   *
   * @param options {Object} options to provide filters and helpful information.
   * @returns {Promise} resolves in an array of object ids and promises resolving in each feature
   */
  async queryFeaturesDiscrete(options) {
    const oids = await this.queryOIDs(options);
    const p = {
      getGeom: !!options.includeGeometry,
      getAttribs: true
    };
    return oids.map((oid) => ({
      oid,
      graphic: this.getGraphic(oid, p)
    }));
  }
  /**
   * Requests a set of features for this layer that match the criteria of the options
   * - filterGeometry : a RAMP API geometry to restrict results to
   * - filterSql : a where clause to apply against feature attributes
   * - includeGeometry : a boolean to indicate if result features should include the geometry
   * - outFields : a string of comma separated field names. will restrict fields included in the output
   * - sourceSR : a spatial reference indicating what the source layer is encoded in. providing can assist in result geometry being of a proper resolution
   *
   * @param options {Object} options to provide filters and helpful information.
   * @returns {Promise} resolves with an array of features that satisfy the criteria
   */
  async queryFeatures(options) {
    const discreteResult = await this.queryFeaturesDiscrete(options);
    return Promise.all(discreteResult.map((dr) => dr.graphic));
  }
  /**
   * Processes any layer order configuration and modifies the passed ESRI layer config
   * with ESRI-friendly definitions
   *
   * @param rampConfig {RampLayerConfig} Ramp layer configuration object.
   * @param rampConfig {Object} ESRI Feature Layer configuration object
   */
  configDrawOrder(rampConfig, esriConfig) {
    if (Array.isArray(rampConfig.drawOrder) && rampConfig.drawOrder.length > 0) {
      esriConfig.orderBy = rampConfig.drawOrder.map((dr) => {
        const order = dr.ascending ?? true ? "ascending" : "descending";
        if (dr.field) {
          return {
            field: dr.field,
            order
          };
        } else {
          return {
            valueExpression: dr.arcade,
            order
          };
        }
      });
      this._drawOrder = rampConfig.drawOrder.slice();
    }
  }
}

class CommonGraphicLayer extends MapLayer {
  constructor(rampConfig, $iApi) {
    super(rampConfig, $iApi);
    this.dataFormat = DataFormat.ESRI_FEATURE;
    this.layerFormat = LayerFormat.GRAPHIC;
    this.hovertips = false;
  }
  _graphics = [];
  /**
   * Take a layer config from the RAMP application and derives a configuration for an ESRI layer
   *
   * @param rampLayerConfig snippet from RAMP for this layer
   * @returns configuration object for the ESRI layer representing this layer
   */
  makeEsriLayerConfig(rampLayerConfig) {
    const esriConfig = super.makeEsriLayerConfig(rampLayerConfig);
    return esriConfig;
  }
  /**
   * Get the number of graphics in the layer.
   *
   * @returns {Integer} number of graphics in the layer
   */
  getGraphicCount() {
    return this._graphics.length;
  }
  /**
   * Gets a graphic from the layer, if it exists.
   *
   * @param {string} graphicId id of the graphic to find
   * @returns {Graphic} the graphic, undefined if no matching id is found.
   */
  getLocalGraphic(graphicId) {
    return this._graphics.find((g) => g.id === graphicId);
  }
  /**
   * Gets the ESRI graphic from the layer, if it exists, that is rendering the Graphic with the
   * provided id.
   *
   * @param {string} graphicId id of the graphic to find
   * @returns {ESRIGraphic} the graphic, undefined if no matching id is found.
   */
  getEsriGraphic(graphicId) {
    return this.esriLayer?.graphics.find((g) => g.id === graphicId);
  }
  /** Returns a copy of the graphics in the layer. */
  get graphics() {
    return this._graphics.slice();
  }
  /**
   * Adds graphics to the layer. Once added, the Graphic is not tightly bound to the layer.
   * Updating the Graphic object will not automatically update what is on the layer.
   *
   * @param {Graphic | Array<Graphic>} graphics one or more RAMP Graphics to add to the layer
   * @returns {Promise} resolves when graphics have been added
   */
  async addGraphic(graphics) {
    if (!this.layerExists) {
      this.noLayerErr();
      return;
    }
    let gs;
    if (graphics instanceof Array) {
      gs = graphics;
    } else {
      gs = [graphics];
    }
    const validGraphics = gs.filter((g) => {
      const index = this._graphics.findIndex((gg) => gg.id === g.id);
      if (index === -1) {
        this._graphics.push(g);
        return true;
      } else {
        console.error(`Attempting to add graphic with id '${g.id}' that has already been added.`);
        return false;
      }
    });
    const mapSR = this.$iApi.geo.map.getSR();
    const projGeomsProms = validGraphics.map((g) => this.$iApi.geo.proj.projectGeometry(mapSR, g.geometry));
    const projGeoms = await Promise.all(projGeomsProms);
    const esriGraphics = validGraphics.map((g, i) => {
      const projGraphic = new Graphic(projGeoms[i], g.id, g.attributes);
      projGraphic.style = g.style;
      return this.$iApi.geo.geom.graphicRampToEsri(projGraphic);
    });
    this.esriLayer.addMany(esriGraphics);
  }
  /**
   * If Graphics are specified, removes those graphics from the layer. Passing no parameter removes all Graphics.
   *
   * @param {Graphic | string | Array<Graphic | string>} graphics Valid formats: A Graphic object, a graphic ID in string form, or an array of Graphic objects and/or graphic ID strings
   */
  removeGraphic(graphics) {
    if (!this.layerExists) {
      this.noLayerErr();
      return;
    }
    if (typeof graphics === "undefined") {
      this.esriLayer.removeAll();
      this._graphics = [];
      return;
    }
    let inArr;
    if (Array.isArray(graphics)) {
      inArr = graphics;
    } else {
      inArr = [graphics];
    }
    const ids = inArr.map((x) => {
      if (typeof x === "string") {
        return x;
      } else {
        return x.id;
      }
    });
    ids.forEach((id) => {
      const esriIdx = this.esriLayer.graphics.findIndex((g) => g.id === id);
      if (esriIdx > -1) {
        this.esriLayer.graphics.removeAt(esriIdx);
      }
      const rampIdx = this._graphics.findIndex((g) => g.id === id);
      if (rampIdx > -1) {
        this._graphics.splice(rampIdx, 1);
      }
    });
  }
}

class GraphicLayer extends CommonGraphicLayer {
  constructor(rampConfig, $iApi) {
    super(rampConfig, $iApi);
    this.layerType = LayerType.GRAPHIC;
  }
  async onInitiate() {
    this.esriLayer = markRaw(new EsriGraphicsLayer(this.makeEsriLayerConfig(this.origRampConfig)));
    await super.onInitiate();
  }
  /**
   * Take a layer config from the RAMP application and derives a configuration for an ESRI layer
   *
   * @param rampLayerConfig snippet from RAMP for this layer
   * @returns configuration object for the ESRI layer representing this layer
   */
  makeEsriLayerConfig(rampLayerConfig) {
    const esriConfig = super.makeEsriLayerConfig(rampLayerConfig);
    return esriConfig;
  }
  onLoadActions() {
    const loadPromises = super.onLoadActions();
    this.layerTree.name = this.name;
    this.updateDrawState(DrawState.UP_TO_DATE);
    return loadPromises;
  }
  // ----------- LAYER ACTIONS -----------
}

class FileLayer extends AttribLayer {
  esriJson;
  // used as temp var to get around typescript parameter grousing. will be undefined after initLayer()
  // temporarily stores GeoJSON. acts as a nice way for subclasses to parse their random sources to GeoJSON, drop it here,
  // and have the generic initiation code in this file just grab it.
  sourceGeoJson;
  tooltipField;
  // if we end up having more things that are shared with FeatureLayer, consider making a FeatureBaseLayer class for both to inherit from
  constructor(rampConfig, $iApi) {
    super(rampConfig, $iApi);
    this.supportsIdentify = true;
    this.isFile = true;
    this.dataFormat = DataFormat.ESRI_FEATURE;
    this.layerFormat = LayerFormat.FEATURE;
    this.tooltipField = "";
    this.layerIdx = 0;
    if (rampConfig.identifyMode && rampConfig.identifyMode !== LayerIdentifyMode.NONE) {
      this.identifyMode = rampConfig.identifyMode;
    } else {
      this.identifyMode = LayerIdentifyMode.HYBRID;
    }
  }
  async reload() {
    if (this.origRampConfig.caching !== true && !this.origRampConfig.url) {
      console.error("Attempted to reload file layer from non server source without caching enabled.");
      return;
    }
    await super.reload();
  }
  async onInitiate() {
    if (!this.sourceGeoJson) {
      throw new Error("File Layer is missing source data.");
    }
    const opts = {
      layerId: this.origRampConfig.id || "",
      targetSR: this.$iApi.geo.map.getSR(),
      colour: this.origRampConfig.colour,
      fieldMetadata: this.origRampConfig.fieldMetadata,
      latField: this.origRampConfig.latField || "",
      lonField: this.origRampConfig.longField || ""
    };
    this.esriJson = await this.$iApi.geo.layer.files.geoJsonToEsriJson(this.sourceGeoJson, opts);
    this.esriLayer = markRaw(new EsriFeatureLayer(this.makeEsriLayerConfig(this.origRampConfig)));
    this.esriJson = void 0;
    if (!this.origRampConfig.caching) {
      delete this.origRampConfig.rawData;
    }
    delete this.sourceGeoJson;
    await super.onInitiate();
  }
  /**
   * Take a layer config from the RAMP application and derives a configuration for an ESRI layer
   *
   * @param rampLayerConfig snippet from RAMP for this layer
   * @returns configuration object for the ESRI layer representing this layer
   */
  makeEsriLayerConfig(rampLayerConfig) {
    const esriConfig = super.makeEsriLayerConfig(rampLayerConfig);
    const oidField = "OBJECTID";
    const copyProp = [
      "source",
      "objectIdField",
      "id",
      "fields",
      "renderer",
      "spatialReference",
      "geometryType"
    ];
    copyProp.forEach((p) => {
      esriConfig[p] = this.esriJson[p];
    });
    if (this.origRampConfig.nameField) {
      esriConfig.displayField = this.$iApi.geo.attributes.fieldValidator(
        esriConfig.fields,
        this.origRampConfig.nameField
      ) || oidField;
    } else {
      esriConfig.displayField = oidField;
    }
    esriConfig.outFields = ["*"];
    delete esriConfig.url;
    this.configDrawOrder(rampLayerConfig, esriConfig);
    return esriConfig;
  }
  onLoadActions() {
    const loadPromises = super.onLoadActions();
    if (this.esriLayer && this.origRampConfig.customRenderer?.type) {
      this.esriLayer.renderer = fromJSON$1(this.config.customRenderer);
    }
    this.layerTree.name = this.name;
    this.extractLayerMetadata();
    if (this.origRampConfig.tooltipField) {
      this.tooltipField = this.$iApi.geo.attributes.fieldValidator(this.fields, this.origRampConfig.tooltipField) || this.nameField;
    } else {
      this.tooltipField = this.nameField;
    }
    this.$iApi.geo.attributes.applyFieldMetadata(this, this.origRampConfig.fieldMetadata);
    this.attribs.attLoader.updateFieldList(this.fieldList);
    this.featureCount = this.esriLayer?.source.length || 0;
    loadPromises.push(this.viewDefProm.getPromise());
    if (this.filter.getCombinedSql()) {
      Promise.all(loadPromises).then(() => {
        this.applySqlFilter();
      });
    }
    return loadPromises;
  }
  // ----------- LAYER ACTIONS -----------
  runIdentify(options) {
    if (!this.canIdentify()) {
      return [];
    }
    const dProm = new DefPromise();
    const result = reactive({
      items: [],
      loading: dProm.getPromise(),
      loaded: false,
      errored: false,
      uid: this.uid,
      layerId: this.id,
      requestTime: Date.now()
    });
    let symbolBlocker = Promise.resolve();
    let geomBlocker = Promise.resolve();
    let geomHitBucket = [];
    let symbolHitBucket = [];
    if (this.identifyMode === LayerIdentifyMode.HYBRID || this.identifyMode === LayerIdentifyMode.GEOMETRIC) {
      const qOpts = {
        includeGeometry: false
      };
      if (this.geomType !== GeometryType.POLYGON && options.geometry.type === GeometryType.POINT) {
        qOpts.filterGeometry = this.$iApi.geo.query.makeClickBuffer(options.geometry, options.tolerance);
      } else {
        qOpts.filterGeometry = options.geometry;
      }
      qOpts.filterSql = this.getCombinedSqlFilter();
      geomBlocker = this.queryFeatures(qOpts).then((results) => {
        geomHitBucket = results;
      });
    }
    if (options.hitTest && (this.identifyMode === LayerIdentifyMode.HYBRID || this.identifyMode === LayerIdentifyMode.SYMBOLIC)) {
      symbolBlocker = geomBlocker.then(async () => {
        const hitArray = await options.hitTest;
        symbolHitBucket = await Promise.all(
          hitArray.filter(
            (hr) => hr.layerId === this.id && geomHitBucket.findIndex((g) => hr.oid === g.attributes[this.oidField]) === -1
          ).map((hr) => hr.oid)
        );
      });
    }
    Promise.all([symbolBlocker, geomBlocker]).then(() => {
      geomHitBucket.forEach((gr) => {
        result.items.push(ReactiveIdentifyFactory.makeRawItem(IdentifyResultFormat.ESRI, gr.attributes));
      });
      symbolHitBucket.forEach((oid) => {
        result.items.push(ReactiveIdentifyFactory.makeOidItem(oid, this));
      });
      result.loaded = true;
      dProm.resolveMe();
    }).catch(() => {
      result.errored = true;
      dProm.resolveMe();
    });
    return [result];
  }
  extractLayerMetadata() {
    const l = this.esriLayer;
    if (!l) {
      throw new Error("file layer attempted to extract data from esri layer, esri layer did not exist");
    }
    this.supportsFeatures = true;
    this.geomType = this.$iApi.geo.geom.clientGeomTypeToRampGeomType(l.geometryType);
    this.scaleSet.minScale = l.minScale || 0;
    this.scaleSet.maxScale = l.maxScale || 0;
    this.extent = this.extent ?? Extent.fromESRI(l.fullExtent, this.id + "_extent");
    const esriFields = markRaw(l.fields.slice());
    this.fields = esriFields.map((f) => {
      return {
        name: f.name,
        alias: f.alias,
        type: f.type,
        length: f.length
      };
    });
    this.nameField = l.displayField;
    this.oidField = l.objectIdField;
    this.renderer = this.$iApi.geo.symbology.makeRenderer(l.renderer, this.fields);
    this.legend = this.$iApi.geo.symbology.rendererToLegend(this.renderer);
    const loadData = {
      sourceGraphics: l.source,
      oidField: this.oidField,
      attribs: "*",
      // * as default. layer loader may update after processing config overrides
      batchSize: -1,
      fieldsToTrim: []
      // fields already trimmed at layer initiation
    };
    this.attribs.attLoader = new FileLayerAttributeLoader(this.$iApi, loadData);
  }
  async getGraphic(objectId, opts) {
    let resGraphic;
    if (!opts.getGeom && this.attribs.attLoader.isLoaded()) {
      const atSet = await this.attribs.attLoader.getAttribs();
      resGraphic = new Graphic(new NoGeometry(), "", atSet.features[atSet.oidIndex[objectId]]);
    } else {
      const gjOpt = {
        filterOIDs: [objectId],
        includeGeometry: !!opts.getGeom
      };
      const resultArr = await this.queryFeatures(gjOpt);
      if (resultArr.length === 0) {
        throw new Error(`Could not find object id ${objectId}`);
      } else if (resultArr.length !== 1) {
        console.warn("did not get a single result on a query for a specific object id");
      }
      resGraphic = resultArr[0];
    }
    if (opts.getStyle) {
      const esriSymb = toRaw(this.renderer.getGraphicSymbol(resGraphic.attributes));
      resGraphic.style = this.$iApi.geo.geom.styleEsriToRamp(esriSymb);
    }
    return resGraphic;
  }
  /**
   * Requests a set of features for this layer that match the criteria of the options
   * - filterGeometry : a RAMP API geometry to restrict results to
   * - filterSql : a where clause to apply against feature attributes
   * - filterOIDs : an array of Object IDs to filter against (more performant than SQL)
   * - includeGeometry : a boolean to indicate if result features should include the geometry
   * - outFields : a string of comma separated field names. will restrict fields included in the output
   * - sourceSR : a spatial reference indicating what the source layer is encoded in. providing can assist in result geometry being of a proper resolution
   *
   * @param options {Object} options to provide filters and helpful information.
   * @returns {Promise} resolves with an array of features that satisfy the criteria
   */
  async queryFeatures(options) {
    const gjOpt = {
      layer: this,
      ...options
    };
    return this.$iApi.geo.query.geoJsonQuery(gjOpt);
  }
  /**
   * Will return an array of object ids for features in the layer that satisfy the conditions of the query options parameter.
   * @param options
   * @returns {Promise} resolving with an array of numbers (object ids)
   */
  async queryOIDs(options) {
    const gjOpt = {
      layer: this,
      ...options
    };
    const gjFeats = await this.$iApi.geo.query.geoJsonQuery(gjOpt);
    return gjFeats.map((feat) => feat.attributes ? feat.attributes[this.oidField] : -1);
  }
  applySqlFilter(exclusions = []) {
    if (!this.esriView) {
      this.noLayerErr();
      return;
    }
    const sql = this.filter.getCombinedSql(exclusions);
    toRaw(this.esriView).filter = new EsriFeatureFilter({
      where: sql
    });
  }
}

class GeoJsonLayer extends FileLayer {
  constructor(rampConfig, $iApi) {
    super(rampConfig, $iApi);
    this.layerType = LayerType.GEOJSON;
  }
  async onInitiate() {
    let gj;
    const startTime = Date.now();
    if (this.origRampConfig.rawData) {
      gj = this.$iApi.geo.layer.files.rawDataJsonParser(this.origRampConfig.rawData, this.origRampConfig.caching);
    } else if (this.origRampConfig.url) {
      gj = await this.$iApi.geo.layer.files.fetchFileData(this.origRampConfig.url, this.layerType);
    } else {
      throw new Error("GeoJson layer config contains no raw data or url");
    }
    if (startTime > this.lastCancel) {
      this.sourceGeoJson = gj;
      await super.onInitiate();
    }
  }
}

class ShapefileLayer extends FileLayer {
  constructor(rampConfig, $iApi) {
    super(rampConfig, $iApi);
    this.layerType = LayerType.SHAPEFILE;
  }
  async onInitiate() {
    const startTime = Date.now();
    const shapefileData = await this.$iApi.geo.layer.files.binaryInitHelper(this.origRampConfig);
    if (startTime > this.lastCancel) {
      const gj = await this.$iApi.geo.layer.files.shapefileToGeoJson(shapefileData);
      if (startTime > this.lastCancel) {
        this.sourceGeoJson = gj;
        await super.onInitiate();
      }
    }
  }
}

class CsvLayer extends FileLayer {
  constructor(rampConfig, $iApi) {
    super(rampConfig, $iApi);
    this.layerType = LayerType.CSV;
  }
  async onInitiate() {
    if (!this.origRampConfig.latField || !this.origRampConfig.longField) {
      throw new Error("csv file config missing lat or long field names");
    }
    let csvData;
    const startTime = Date.now();
    if (this.origRampConfig.rawData && typeof this.origRampConfig.rawData === "string") {
      csvData = this.origRampConfig.rawData;
    } else if (this.origRampConfig.url) {
      csvData = await this.$iApi.geo.layer.files.fetchFileData(this.origRampConfig.url, this.layerType);
    } else {
      throw new Error("Csv file config contains no raw data or url");
    }
    if (startTime > this.lastCancel) {
      const gj = await this.$iApi.geo.layer.files.csvToGeoJson(csvData, {
        latfield: this.origRampConfig.latField,
        lonfield: this.origRampConfig.longField
      });
      if (startTime > this.lastCancel) {
        this.sourceGeoJson = gj;
        await super.onInitiate();
      }
    }
  }
}

class GeoJsonZipLayer extends FileLayer {
  constructor(rampConfig, $iApi) {
    super(rampConfig, $iApi);
    this.layerType = LayerType.GEOJSONZIPPED;
  }
  async onInitiate() {
    const startTime = Date.now();
    const zippedData = await this.$iApi.geo.layer.files.binaryInitHelper(this.origRampConfig);
    if (startTime > this.lastCancel) {
      const gjBinary = await this.$iApi.geo.layer.files.unzipSingleFile(zippedData);
      if (startTime > this.lastCancel) {
        this.sourceGeoJson = JSON.parse(this.$iApi.geo.layer.files.arbToStr(gjBinary));
        await super.onInitiate();
      }
    }
  }
}

class FlatGeobufLayer extends FileLayer {
  constructor(rampConfig, $iApi) {
    super(rampConfig, $iApi);
    this.layerType = LayerType.FLATGEOBUF;
  }
  async onInitiate() {
    const startTime = Date.now();
    const fgbData = await this.$iApi.geo.layer.files.binaryInitHelper(this.origRampConfig);
    if (startTime > this.lastCancel) {
      const gj = await this.$iApi.geo.layer.files.fgbToGeoJson(fgbData, this.expectedTime.fail + 1e3);
      if (startTime > this.lastCancel) {
        this.sourceGeoJson = gj;
        await super.onInitiate();
      }
    }
  }
}

class FlatGeobufZipLayer extends FileLayer {
  constructor(rampConfig, $iApi) {
    super(rampConfig, $iApi);
    this.layerType = LayerType.FLATGEOBUFZIPPED;
  }
  async onInitiate() {
    const startTime = Date.now();
    const zippedData = await this.$iApi.geo.layer.files.binaryInitHelper(this.origRampConfig);
    if (startTime > this.lastCancel) {
      const fgbData = await this.$iApi.geo.layer.files.unzipSingleFile(zippedData);
      if (startTime > this.lastCancel) {
        const gj = await this.$iApi.geo.layer.files.fgbToGeoJson(fgbData, this.expectedTime.fail + 1e3);
        if (startTime > this.lastCancel) {
          this.sourceGeoJson = gj;
          await super.onInitiate();
        }
      }
    }
  }
}

class FeatureLayer extends AttribLayer {
  tooltipField;
  constructor(rampConfig, $iApi) {
    super(rampConfig, $iApi);
    this.dataFormat = DataFormat.ESRI_FEATURE;
    this.tooltipField = "";
    this.supportsIdentify = true;
    this.layerType = LayerType.FEATURE;
    this.layerFormat = LayerFormat.FEATURE;
    if (rampConfig.identifyMode && rampConfig.identifyMode !== LayerIdentifyMode.NONE) {
      this.identifyMode = rampConfig.identifyMode;
    } else {
      this.identifyMode = LayerIdentifyMode.HYBRID;
    }
  }
  async onInitiate() {
    markRaw(this.esriLayer = new EsriFeatureLayer(this.makeEsriLayerConfig(this.origRampConfig)));
    await super.onInitiate();
  }
  /**
   * Take a layer config from the RAMP application and derives a configuration for an ESRI layer
   *
   * @param rampLayerConfig snippet from RAMP for this layer
   * @returns configuration object for the ESRI layer representing this layer
   */
  makeEsriLayerConfig(rampLayerConfig) {
    const esriConfig = super.makeEsriLayerConfig(rampLayerConfig);
    if (rampLayerConfig.initialFilteredQuery || rampLayerConfig.permanentFilteredQuery) {
      esriConfig.definitionExpression = this.filter.getCombinedSql();
    }
    this.configDrawOrder(rampLayerConfig, esriConfig);
    return esriConfig;
  }
  onLoadActions() {
    const startTime = Date.now();
    const loadPromises = super.onLoadActions();
    const hasCustRed = this.esriLayer && this.origRampConfig.customRenderer?.type;
    if (hasCustRed) {
      this.esriLayer.renderer = fromJSON$1(this.origRampConfig.customRenderer);
    }
    const layerUrl = this.esriLayer.parsedUrl.path;
    const urlData = this.$iApi.geo.shared.parseUrlIndex(layerUrl);
    const featIdx = urlData.index || 0;
    this.layerIdx = featIdx;
    this.serviceUrl = layerUrl;
    const pLD = this.loadLayerMetadata(
      hasCustRed ? { customRenderer: this.esriLayer?.renderer } : {}
    ).then(() => {
      if (startTime > this.lastCancel) {
        this.visibility = this.origRampConfig?.state?.visibility ?? this._serverVisibility ?? true;
        this.nameField = this.origRampConfig.nameField || this.nameField || "";
        this.tooltipField = this.origRampConfig.tooltipField || this.nameField;
        this.$iApi.geo.attributes.applyFieldMetadata(this, this.origRampConfig.fieldMetadata);
        this.attribs.attLoader.updateFieldList(this.fieldList);
        this.attribs.attLoader.updateFieldsToTrim(this.getFieldsToTrim());
      }
    });
    const pFC = this.$iApi.geo.layer.loadFeatureCount(this.serviceUrl, this.getSqlFilter(CoreFilter.PERMANENT)).then((count) => {
      if (startTime > this.lastCancel) {
        this.featureCount = count;
      }
    });
    this.layerTree.name = this.name;
    this.layerTree.layerIdx = featIdx;
    loadPromises.push(pLD, pFC);
    return loadPromises;
  }
  // ----------- LAYER ACTIONS -----------
  runIdentify(options) {
    if (!this.canIdentify()) {
      return [];
    }
    const dProm = new DefPromise();
    const result = reactive({
      items: [],
      loading: dProm.getPromise(),
      loaded: false,
      errored: false,
      uid: this.uid,
      layerId: this.id,
      requestTime: Date.now()
    });
    let clientBlocker = Promise.resolve();
    let serverBlocker = Promise.resolve();
    let hitBucket = [];
    if (this.identifyMode === LayerIdentifyMode.HYBRID || this.identifyMode === LayerIdentifyMode.GEOMETRIC) {
      const qOpts = {
        includeGeometry: false,
        sourceSR: this.sourceSR
      };
      if (this.geomType !== GeometryType.POLYGON && options.geometry.type === GeometryType.POINT) {
        qOpts.filterGeometry = this.$iApi.geo.query.makeClickBuffer(options.geometry, options.tolerance);
      } else {
        qOpts.filterGeometry = options.geometry;
      }
      qOpts.filterSql = this.getCombinedSqlFilter();
      serverBlocker = this.queryOIDs(qOpts).then((results) => {
        hitBucket = results;
      });
    }
    if (options.hitTest && (this.identifyMode === LayerIdentifyMode.HYBRID || this.identifyMode === LayerIdentifyMode.SYMBOLIC)) {
      clientBlocker = serverBlocker.then(async () => {
        const hitArray = await options.hitTest;
        hitArray.filter(
          (hr) => hr.layerId === this.id && hitBucket.findIndex((alreadyHitOid) => hr.oid === alreadyHitOid) === -1
        ).forEach((hr) => {
          hitBucket.push(hr.oid);
        });
      });
    }
    Promise.all([clientBlocker, serverBlocker]).then(() => {
      hitBucket.forEach((hitOid) => {
        result.items.push(ReactiveIdentifyFactory.makeOidItem(hitOid, this));
      });
      result.loaded = true;
      dProm.resolveMe();
    }).catch(() => {
      result.errored = true;
      dProm.resolveMe();
    });
    return [result];
  }
  applySqlFilter(exclusions = []) {
    if (this.layerExists) {
      const sql = this.filter.getCombinedSql(exclusions);
      this.esriLayer.definitionExpression = sql;
    } else {
      this.noLayerErr();
    }
  }
  /**
   * Gets the extent where the provided object id is on the map.
   * Can only be used on feature layers. Not applicable to point geometry.
   *
   * @param objectId the object id to query
   * @returns {Promise} resolves with the extent where the object id is present, rejects if geometry type is invalid or esri layer does not exist
   */
  getGraphicExtent(objectId) {
    return new Promise((resolve, reject) => {
      if (!this.layerExists) {
        this.noLayerErr();
        reject();
      } else if (!["multipoint", "polyline", "polygon"].includes(this.esriLayer.geometryType)) {
        console.error(`Attempted to query extent for invalid geometry type ${this.esriLayer.geometryType}.`);
        reject();
      } else {
        const eCache = this.attribs.quickCache.getExtent(objectId);
        if (eCache) {
          resolve(eCache);
        } else {
          this.esriLayer.queryExtent({
            objectIds: [objectId],
            outSpatialReference: this.$iApi.geo.map.getSR().toESRI()
          }).then((result) => {
            const rampExtent = Extent.fromESRI(result.extent);
            this.attribs.quickCache.setExtent(objectId, rampExtent);
            resolve(rampExtent);
          }).catch(() => {
            console.error(`Extent querying failed for ${objectId}.`);
            reject();
          });
        }
      }
    });
  }
}

class MapImageLayer extends MapLayer {
  // indicates if sublayers can have opacity adjusted
  isDynamic;
  // used to remember state after load
  origState;
  constructor(rampConfig, $iApi) {
    super(rampConfig, $iApi);
    this.supportsIdentify = true;
    this.supportsSublayers = true;
    this.layerType = LayerType.MAPIMAGE;
    this.layerFormat = LayerFormat.MAPIMAGE;
    this.isDynamic = false;
    this.hovertips = false;
    this.layerTree.layerIdx = -1;
    this.identifyMode = LayerIdentifyMode.GEOMETRIC;
  }
  async onInitiate() {
    this.esriLayer = markRaw(new EsriMapImageLayer(this.makeEsriLayerConfig(this.origRampConfig)));
    await super.onInitiate();
  }
  /**
   * Take a layer config from the RAMP application and derives a configuration for an ESRI layer
   *
   * @param rampLayerConfig snippet from RAMP for this layer
   * @returns configuration object for the ESRI layer representing this layer
   */
  makeEsriLayerConfig(rampLayerConfig) {
    const esriConfig = super.makeEsriLayerConfig(rampLayerConfig);
    this.origState = {
      visibility: esriConfig.visible,
      opacity: esriConfig.opacity
    };
    esriConfig.visible = false;
    if (rampLayerConfig.imageFormat) {
      esriConfig.imageFormat = rampLayerConfig.imageFormat;
    }
    return esriConfig;
  }
  onLoadActions() {
    const loadPromises = super.onLoadActions();
    if (!this.layerExists) {
      this.noLayerErr();
      return loadPromises;
    }
    const startTime = Date.now();
    this.layerTree.name = this.name;
    if (!this.esriLayer.capabilities.exportMap) {
      this.$iApi.notify.show(
        NotificationType.WARNING,
        this.$iApi.$i18n.t("layer.noexportmap", {
          name: this.name || this.id
        })
      );
      throw new Error("Service does not support Map Image Layer, Map Export is not enabled");
    }
    this.isDynamic = this.esriLayer.capabilities.exportMap.supportsDynamicLayers;
    this.extent = this.extent ?? Extent.fromESRI(this.esriLayer.fullExtent, this.id + "_extent");
    const findSublayer = (targetIndex) => {
      const finder = this.esriLayer?.allSublayers.find((s) => {
        return s.id === targetIndex;
      });
      if (!finder) {
        throw new Error("attempt to find map image sublayer failed");
      }
      return finder;
    };
    const subConfigs = {};
    this.origRampConfig.sublayers.forEach(
      (sublayer) => {
        subConfigs[sublayer.index || 0] = sublayer;
      }
    );
    const leafsToInit = [];
    const processSublayer = (subLayer, parentTreeNode) => {
      const sid = subLayer.id;
      const subC = subConfigs[sid];
      if (subLayer.sublayers && subLayer.sublayers.length > 0) {
        const gName = (subC ? subC.name : "") || subLayer.title || "";
        const treeGroup = new TreeNode(sid, "", gName, false);
        if (!parentTreeNode.findChildByIdx(sid)) {
          parentTreeNode.children.push(treeGroup);
        }
        subLayer.sublayers.reverse().forEach((subSubLayer) => {
          processSublayer(subSubLayer, treeGroup);
        });
      } else {
        if (!this._sublayers[sid]) {
          this._sublayers[sid] = new MapImageSublayer(
            {
              id: `${this.id}-${sid}`,
              index: sid,
              // TODO: Revisit once issue #961 is implemented.
              // See https://github.com/ramp4-pcar4/ramp4-pcar4/pull/1045#pullrequestreview-977116071
              // ^ update: issue 961 seems to have nothing to do with this. The PR link implies this
              //   comment is related to the parent state default line below. Best guess is that
              //   issue #1394 was the impacted issue. It appears that the code in the leaf initializer
              //   below is handling things, but leaving this here for now incase someone wants to
              //   dig deeper (or a problem arises)
              layerType: LayerType.SUBLAYER,
              name: subC?.name,
              // If the state isn't defined, use the same state as the parent.
              state: subC?.state ?? {
                opacity: this.opacity,
                visibility: this.visibility,
                hovertips: this.hovertips,
                identify: this.identify
              },
              extent: subC?.extent,
              controls: subC?.controls,
              disabledControls: subC?.disabledControls,
              initialFilteredQuery: subC?.initialFilteredQuery,
              permanentFilteredQuery: subC?.permanentFilteredQuery,
              labels: subC?.labels
            },
            this.$iApi,
            this
          );
        }
        const _sublayer = this._sublayers[sid];
        if (_sublayer.isRemoved) {
          return;
        }
        _sublayer.name = subC?.name || subLayer.title || "";
        leafsToInit.push(_sublayer);
        if (!parentTreeNode.children.map((node) => node.layerIdx).includes(sid)) {
          const treeLeaf = new TreeNode(sid, _sublayer.uid, _sublayer.name, false);
          parentTreeNode.children.push(treeLeaf);
        }
        _sublayer.esriWatches.push(
          subLayer.watch("visible", () => {
            this.$iApi.event.emit(GlobalEvents.LAYER_VISIBILITYCHANGE, {
              visibility: _sublayer.visibility,
              layer: _sublayer
            });
            _sublayer.parentLayer?.checkVisibility();
          }),
          subLayer.watch("opacity", (newval) => {
            this.$iApi.event.emit(GlobalEvents.LAYER_OPACITYCHANGE, {
              opacity: newval,
              layer: _sublayer
            });
          })
        );
      }
    };
    this.origRampConfig.sublayers.forEach((sublayer) => {
      if (!sublayer.cosmetic) {
        const rootSub = findSublayer(sublayer.index || 0);
        processSublayer(rootSub, this.layerTree);
      }
    });
    const leafLoadProms = leafsToInit.map(async (miSL) => {
      const sublayer = findSublayer(miSL.layerIdx);
      const config = subConfigs[miSL.layerIdx];
      miSL.serviceUrl = sublayer.url;
      miSL.fetchEsriSublayer(this);
      await miSL.initiate();
      if (startTime < this.lastCancel) {
        return;
      }
      const hasCustRed = miSL.esriSubLayer && config?.customRenderer?.type;
      if (hasCustRed) {
        miSL.esriSubLayer.renderer = fromJSON$1(config.customRenderer);
      }
      await miSL.loadLayerMetadata(hasCustRed ? { customRenderer: miSL.esriSubLayer?.renderer } : {});
      if (startTime < this.lastCancel) {
        return;
      }
      const subC = subConfigs[miSL.layerIdx];
      if (subC) {
        miSL.visibility = miSL.isRemoved ? false : subC.state?.visibility ?? (this.origState.visibility ? miSL._serverVisibility ?? this.origState.visibility : this.origState.visibility ?? miSL._serverVisibility) ?? true;
        miSL.opacity = subC.state?.opacity ?? this.origState.opacity ?? 1;
        miSL.nameField = subC.nameField || miSL.nameField || "";
        this.$iApi.geo.attributes.applyFieldMetadata(miSL, subC.fieldMetadata);
        if (!miSL.canModifyLayer) {
          this.$iApi.notify.show(
            NotificationType.WARNING,
            this.$iApi.$i18n.t(`layer.filtersdisabled`, {
              name: miSL.name || miSL.id
            })
          );
        }
      } else {
        this.$iApi.geo.attributes.applyFieldMetadata(miSL);
      }
      if (miSL.supportsFeatures) {
        miSL.updateFieldList();
        miSL.updateFieldsToTrim();
        const count = await this.$iApi.geo.layer.loadFeatureCount(
          miSL.serviceUrl,
          miSL.getSqlFilter(CoreFilter.PERMANENT)
        );
        if (startTime > this.lastCancel) {
          miSL.featureCount = count;
        }
      }
    });
    loadPromises.push(...leafLoadProms);
    this.esriLayer.allSublayers.forEach((s) => {
      if (!s.sublayers && !leafsToInit.find((sublayer) => sublayer.layerIdx === s.id)) {
        s.visible = false;
        s.opacity = 0;
      } else if (s.sublayers) {
        s.visible = true;
      }
    });
    this.visibility = this.origState.visibility ?? true;
    return loadPromises;
  }
  updateLayerState(newState, userCancel = false) {
    super.updateLayerState(newState, userCancel);
    this.sublayers.forEach((sublayer) => sublayer.updateLayerState(newState, userCancel));
  }
  updateDrawState(newState) {
    super.updateDrawState(newState);
    this.sublayers.forEach((sublayer) => sublayer.updateDrawState(newState));
  }
  // ----------- LAYER ACTIONS -----------
  runIdentify(options) {
    if (!this.canIdentify()) {
      return [];
    }
    if (options.sublayerIds) {
      options.sublayerIds = options.sublayerIds.map((id) => {
        if (typeof id === "number") {
          return this.layerTree?.findChildByIdx(id)?.uid;
        }
        return id;
      });
    }
    const activeSublayers = options.sublayerIds ? this._sublayers.filter((sublayer) => {
      return options.sublayerIds?.includes(sublayer.uid);
    }) : this._sublayers.filter((sublayer) => {
      return sublayer.canIdentify();
    });
    if (activeSublayers.length === 0) {
      return [];
    }
    let pointBuffer;
    if (options.geometry.type === GeometryType.POINT) {
      pointBuffer = this.$iApi.geo.query.makeClickBuffer(options.geometry, options.tolerance);
    }
    return activeSublayers.map((sublayer) => {
      const dProm = new DefPromise();
      const qOpts = {};
      const result = reactive({
        items: [],
        loading: dProm.getPromise(),
        loaded: false,
        errored: false,
        uid: sublayer.uid,
        layerId: sublayer.id,
        requestTime: Date.now()
      });
      if (sublayer.geomType !== GeometryType.POLYGON && pointBuffer) {
        qOpts.filterGeometry = pointBuffer;
      } else {
        qOpts.filterGeometry = options.geometry;
      }
      qOpts.filterSql = sublayer.getCombinedSqlFilter();
      qOpts.sourceSR = sublayer.sourceSR;
      sublayer.queryOIDs(qOpts).then((results) => {
        results.forEach((hitOid) => {
          result.items.push(ReactiveIdentifyFactory.makeOidItem(hitOid, sublayer));
        });
        result.loaded = true;
        dProm.resolveMe();
      }).catch(() => {
        result.errored = true;
        dProm.resolveMe();
      });
      return result;
    });
  }
}

class MapImageSublayer extends AttribLayer {
  tooltipField;
  constructor(config, $iApi, parent) {
    super(config, $iApi);
    this.layerType = LayerType.SUBLAYER;
    this.layerFormat = LayerFormat.MAPIMAGE;
    this.isSublayer = true;
    this.layerIdx = config.index;
    this.parentLayer = parent;
    this.dataFormat = DataFormat.ESRI_FEATURE;
    this.supportsFeatures = true;
    this.tooltipField = "";
    this.hovertips = false;
    this.url = this.parentLayer?.url;
    this.canReload = !!(this.url || this.origRampConfig.caching);
    if (!parent.esriLayer) {
      throw new Error("Map Image Layer with no internal esri layer encountered in sublayer creation");
    }
    this.fetchEsriSublayer(parent);
    if (config.initialFilteredQuery || config.permanentFilteredQuery) {
      this.applySqlFilter();
    }
  }
  /**
   * Set the ESRI sublayer using the parent's sublayer list
   *
   * @param {MapImageLayer} parent: Parent MapImageLayer object
   */
  fetchEsriSublayer(parent) {
    if (!parent.esriLayer) {
      console.error("Attempted to fetch the ESRI sublayer when parent has no ESRI layer");
      return;
    }
    this.esriSubLayer = markRaw(
      parent.esriLayer.allSublayers.find((s) => {
        return s.id === this.layerIdx;
      })
    );
  }
  /**
   * Load actions for a MapImage sublayer
   */
  onLoadActions() {
    this.layerTree = this.parentLayer.getLayerTree().findChildByUid(this.uid);
    this.layerTree.name = this.name;
    this.layerTree.layerIdx = this.layerIdx;
    this.identify = !(this.config.state.identify == void 0) ? this.config.state.identify : this.supportsIdentify;
    return [];
  }
  /**
   * Initiate this sublayer
   *
   * This is called after the parent layer is initiated
   */
  async onInitiate() {
    this.initiationState = InitiationState.INITIATED;
    const vizOverr = this.labelVizOverride();
    if (vizOverr !== void 0) {
      this.labelVisibility = vizOverr;
    }
  }
  async reload() {
    if (!this.$iApi.geo.map.esriMap) {
      console.error("Attempted layer reload when no map exists");
      return;
    }
    this.parentLayer?.reload();
  }
  cancelLoad() {
    this.parentLayer?.cancelLoad();
  }
  /**
   * Indicates if the Esri map sublayer and the parent's Esri map layer exist.
   */
  get layerExists() {
    return !!(this.parentLayer?.layerExists && this.esriSubLayer && this.initiationState === InitiationState.INITIATED);
  }
  /**
   * Returns the visibility of the sublayer.
   *
   * @function getVisibility
   * @returns {Boolean} visibility of the sublayer
   */
  get visibility() {
    if (this.layerExists) {
      return this.esriSubLayer.visible;
    } else {
      return false;
    }
  }
  /**
   * Applies visibility to sublayer.
   *
   * @function setVisibility
   * @param {Boolean} value the new visibility setting
   */
  set visibility(value) {
    if (this.layerExists) {
      this.esriSubLayer.visible = value;
    } else {
      this.noLayerErr();
    }
  }
  /**
   * Returns the opacity of the sublayer.
   *
   * @function getOpacity
   * @returns {Boolean} opacity of the sublayer
   */
  get opacity() {
    if (this.layerExists) {
      return this.esriSubLayer.opacity;
    } else {
      return 0;
    }
  }
  /**
   * Applies opacity to sublayer.
   *
   * @function setOpacity
   * @param {Boolean} value the new opacity setting
   */
  set opacity(value) {
    if (!this.layerExists) {
      this.noLayerErr();
      return;
    }
    if (!this.parentLayer.isDynamic) {
      console.warn(
        `Opacity of a Map Image Sublayer was set. The service does not support sublayer opacity. LayerId ${this.id}`
      );
    }
    this.esriSubLayer.opacity = value;
  }
  /**
   * Get the mouse tolerance in pixels for this sublayer's parent layer
   *
   * @returns {number} the mouse tolerance of the parent layer
   */
  get mouseTolerance() {
    if (this.layerExists) {
      return this.parentLayer.mouseTolerance;
    } else {
      return 0;
    }
  }
  /**
   * Set the mouse tolerance for this sublayer's parent layer in pixels
   *
   * @param {number} tolerance the new mouse tolerance
   */
  set mouseTolerance(tolerance) {
    if (this.layerExists) {
      this.parentLayer.mouseTolerance = tolerance;
    } else {
      this.noLayerErr();
    }
  }
  /**
   * Get the touch tolerance in pixels for this sublayer's parent layer
   *
   * @returns {number} the touch tolerance of the parent layer
   */
  get touchTolerance() {
    if (this.layerExists) {
      return this.parentLayer.touchTolerance;
    } else {
      return 0;
    }
  }
  /**
   * Set the touch tolerance in pixels for this sublayer's parent layer
   *
   * @param {number} tolerance the new touch tolerance of the parent layer
   */
  set touchTolerance(tolerance) {
    if (this.layerExists) {
      this.parentLayer.touchTolerance = tolerance;
    } else {
      this.noLayerErr();
    }
  }
  applySqlFilter(exclusions = []) {
    if (this.parentLayer?.layerExists && this.esriSubLayer) {
      if (this.supportsFeatures) {
        const sql = this.filter.getCombinedSql(exclusions);
        this.esriSubLayer.definitionExpression = sql;
      } else {
        console.error(
          "Attempted to apply an SQL filter to a sublayer that does not support it (likely Raster datatype)"
        );
      }
    } else {
      this.noLayerErr();
    }
  }
  /**
   * Provides the spatial reference of the parent MIL.
   *
   * @returns {SpatialReference} the layer spatial reference in RAMP API format
   */
  getSR() {
    if (this.parentLayer?.esriLayer) {
      return SpatialReference.fromESRI(this._parentLayer?.esriLayer?.spatialReference);
    } else {
      this.noLayerErr();
      return SpatialReference.latLongSR();
    }
  }
  /**
   * A utility method to allow a parent layer to request this layer to
   * update its internal attribute loader after field data has been
   * properly processed.
   * Generally should only be called internally.
   */
  updateFieldList() {
    this.attribs.attLoader.updateFieldList(this.fieldList);
  }
  /**
   * A utility method to allow a parent layer to request this layer to
   * update its fields to be trimmed after field data is processed.
   * Generally should only be called internally.
   */
  updateFieldsToTrim() {
    this.attribs.attLoader.updateFieldsToTrim(this.getFieldsToTrim());
  }
  /**
   * Visibility of labels on this layer
   */
  get labelVisibility() {
    if (this.layerExists) {
      return this.esriSubLayer.labelsVisible;
    } else {
      return false;
    }
  }
  set labelVisibility(val) {
    if (this.layerExists) {
      this.esriSubLayer.labelsVisible = val;
    } else {
      this.noLayerErr();
    }
  }
  /**
   * Does any config override calculating for label visibility.
   *
   * @private
   * @returns {boolean | undefined} undefined if no overrides, otherwise the override value
   */
  labelVizOverride() {
    let val = this.origRampConfig.labels?.visible;
    if (val !== void 0) {
      return val;
    }
    val = this.$iApi.geo.map.labelsDefault?.visible;
    if (val !== void 0) {
      return val;
    }
    return void 0;
  }
}

class OsmTileLayer extends MapLayer {
  constructor(rampConfig, $iApi) {
    super(rampConfig, $iApi);
    this.supportsIdentify = false;
    this.layerType = LayerType.OSM;
    this.layerFormat = LayerFormat.OSM;
    this.dataFormat = DataFormat.OSM_TILE;
    this.supportsFeatures = false;
  }
  async onInitiate() {
    this.esriLayer = markRaw(new EsriOpenStreetMapLayer(this.makeEsriLayerConfig(this.origRampConfig)));
    await super.onInitiate();
  }
  /**
   * Take a layer config from the RAMP application and derives a configuration for an ESRI layer
   *
   * @param rampLayerConfig snippet from RAMP for this layer
   * @returns configuration object for the ESRI layer representing this layer
   */
  makeEsriLayerConfig(rampLayerConfig) {
    const esriConfig = super.makeEsriLayerConfig(rampLayerConfig);
    return esriConfig;
  }
  onLoadActions() {
    const loadPromises = super.onLoadActions();
    this.layerTree.name = this.name;
    const legGuts = this.$iApi.geo.symbology.generatePlaceholderSymbology("O", "#03fc4e");
    const symbologyItem = {
      uid: this.$iApi.geo.shared.generateUUID(),
      label: "OpenStreetMap",
      // product name, same in Fr
      svgcode: legGuts.svgcode,
      esriStandard: true,
      drawPromise: Promise.resolve()
    };
    this.legend.push(symbologyItem);
    return loadPromises;
  }
}

class ImageryLayer extends MapLayer {
  constructor(rampConfig, $iApi) {
    super(rampConfig, $iApi);
    this.supportsIdentify = false;
    this.layerType = LayerType.IMAGERY;
    this.layerFormat = LayerFormat.IMAGERY;
    this.dataFormat = DataFormat.ESRI_RASTER;
  }
  async onInitiate() {
    this.esriLayer = markRaw(new EsriImageryLayer(this.makeEsriLayerConfig(this.origRampConfig)));
    await super.onInitiate();
  }
  /**
   * Take a layer config from the RAMP application and derives a configuration for an ESRI layer
   *
   * @param rampLayerConfig snippet from RAMP for this layer
   * @returns configuration object for the ESRI layer representing this layer
   */
  makeEsriLayerConfig(rampLayerConfig) {
    const esriConfig = super.makeEsriLayerConfig(rampLayerConfig);
    return esriConfig;
  }
  onLoadActions() {
    const loadPromises = super.onLoadActions();
    this.layerTree.name = this.name;
    const startTime = Date.now();
    const legendPromise = this.$iApi.geo.symbology.mapServerToLocalLegend(this.origRampConfig.url).then((legArray) => {
      if (startTime > this.lastCancel) {
        this.legend = legArray;
      }
    });
    loadPromises.push(legendPromise);
    return loadPromises;
  }
}

class TileLayer extends MapLayer {
  constructor(rampConfig, $iApi) {
    super(rampConfig, $iApi);
    this.supportsIdentify = false;
    this.layerType = LayerType.TILE;
    this.layerFormat = LayerFormat.TILE;
    this.dataFormat = DataFormat.ESRI_TILE;
  }
  async onInitiate() {
    this.esriLayer = markRaw(new EsriTileLayer(this.makeEsriLayerConfig(this.origRampConfig)));
    await super.onInitiate();
  }
  /**
   * Take a layer config from the RAMP application and derives a configuration for an ESRI layer
   *
   * @param rampLayerConfig snippet from RAMP for this layer
   * @returns configuration object for the ESRI layer representing this layer
   */
  makeEsriLayerConfig(rampLayerConfig) {
    const esriConfig = super.makeEsriLayerConfig(rampLayerConfig);
    return esriConfig;
  }
  onLoadActions() {
    const loadPromises = super.onLoadActions();
    const startTime = Date.now();
    this.layerTree.name = this.name;
    const legendPromise = this.$iApi.geo.symbology.mapServerToLocalLegend(this.origRampConfig.url).then((legArray) => {
      if (startTime > this.lastCancel) {
        this.legend = legArray;
      }
    });
    loadPromises.push(legendPromise);
    loadPromises.push(this.checkProj());
    return loadPromises;
  }
  /**
   * Check if the layer's projection matches the current basemap's.
   * If they do not match the layer will enter the error state and the user will receive a warning notification
   * If the layers do match and the layer was previously in the error state, it will reload.
   */
  checkProj() {
    const layerSR = this.getSR();
    const mapSR = this.$iApi.geo.map.getSR();
    const isEqual = mapSR.isEqual(layerSR);
    if (this.layerState === LayerState.LOADED && !isEqual) {
      this.$iApi.notify.show(
        NotificationType.WARNING,
        this.$iApi.$i18n.t("layer.mismatch", {
          name: this.name || this.id
        })
      );
      this.onError();
    } else if (this.layerState === LayerState.ERROR && isEqual) {
      this.reload();
    } else if (this.layerState !== LayerState.ERROR && !isEqual) {
      this.$iApi.notify.show(
        NotificationType.WARNING,
        this.$iApi.$i18n.t("layer.mismatch", {
          name: this.name || this.id
        })
      );
      return Promise.reject();
    }
    return Promise.resolve();
  }
}

class WmsLayer extends MapLayer {
  sublayerNames;
  mimeType;
  constructor(rampConfig, $iApi) {
    super(rampConfig, $iApi);
    this.supportsIdentify = true;
    this.layerType = LayerType.WMS;
    this.layerFormat = LayerFormat.WMS;
    this.mimeType = rampConfig.featureInfoMimeType || "";
    this.sublayerNames = [];
    this.dataFormat = DataFormat.OGC_RASTER;
    this.identifyMode = LayerIdentifyMode.GEOMETRIC;
  }
  async onInitiate() {
    this.esriLayer = markRaw(new EsriWMSLayer(this.makeEsriLayerConfig(this.origRampConfig)));
    await super.onInitiate();
  }
  /**
   * Take a layer config from the RAMP application and derives a configuration for an ESRI layer
   *
   * @param rampLayerConfig snippet from RAMP for this layer
   * @returns configuration object for the ESRI layer representing this layer
   */
  makeEsriLayerConfig(rampLayerConfig) {
    const esriConfig = super.makeEsriLayerConfig(rampLayerConfig);
    const lEntries = rampLayerConfig.sublayers;
    this.sublayerNames = lEntries.map((sublayer) => sublayer.id || "error_no_wms_id");
    const styles = lEntries.map((e) => e.currentStyle).join();
    esriConfig.customParameters = {
      styles
    };
    if (rampLayerConfig.url.indexOf("/geomet") !== -1) {
      esriConfig.customParameters.layers = lEntries[0].id;
    }
    return esriConfig;
  }
  onLoadActions() {
    const loadPromises = super.onLoadActions();
    this.layerTree.name = this.name;
    const crawlSublayers = (sublayers) => {
      let anySlVis = false;
      sublayers.forEach((sl) => {
        const visible = this.sublayerNames.indexOf(sl.name) > -1;
        if (visible) {
          anySlVis = true;
        } else {
          if (sl.sublayers && sl.sublayers.length > 0) {
            const slVisibile = crawlSublayers(sl.sublayers);
            if (slVisibile) {
              anySlVis = true;
            } else {
              sl.visible = false;
            }
          } else {
            sl.visible = false;
          }
        }
      });
      return anySlVis;
    };
    if (this.layerExists) {
      crawlSublayers(this.esriLayer.sublayers);
    } else {
      this.noLayerErr();
    }
    this.loadSymbology();
    return loadPromises;
  }
  // ----------- LAYER ACTIONS -----------
  canIdentify() {
    return super.canIdentify();
  }
  /**
   * Run a getFeatureInfo on a WMS layer, return the result as a promise.
   * Options: specs to be added once finalized
   *
   * @param {Object} options     additional arguemets, see above.
   * @returns {Object} an object with identify results array and identify promise resolving when identify is complete; if an empty object is returned, it will be skipped
   */
  runIdentify(options) {
    if (options.geometry.type !== GeometryType.POINT) {
      throw new Error("a point must be used for WMS Identify");
    }
    if (!this.canIdentify()) {
      return [];
    }
    const dProm = new DefPromise();
    const result = reactive({
      items: [],
      loading: dProm.getPromise(),
      loaded: false,
      errored: false,
      uid: this.uid,
      layerId: this.id,
      requestTime: Date.now()
    });
    this.getFeatureInfo(this.sublayerNames, options.geometry, this.mimeType).then((response) => {
      if (response) {
        let validReturn = true;
        let format;
        if (typeof response !== "string") {
          format = IdentifyResultFormat.JSON;
        } else if (response.indexOf("Search returned no results") === -1 && response !== "") {
          format = IdentifyResultFormat.TEXT;
        } else {
          validReturn = false;
          format = IdentifyResultFormat.UNKNOWN;
        }
        if (validReturn) {
          result.items.push(ReactiveIdentifyFactory.makeRawItem(format, response));
        }
      }
      result.loaded = true;
      dProm.resolveMe();
    }).catch(() => {
      result.errored = true;
      dProm.resolveMe();
    });
    return [result];
  }
  /**
   * Add a WMS layer parameter, maybe even refresh the layer
   *
   * @function setCustomParameter
   * @param {String} key name of the key to be created or updated
   * @param {String} value value of the key
   * @param {Boolean} forceRefresh show the new fancy version of the layer or not
   */
  setCustomParameter(key, value, forceRefresh = true) {
    if (this.layerExists) {
      if (!this.esriLayer.customLayerParameters) {
        this.esriLayer.customLayerParameters = {};
      }
      this.esriLayer.customLayerParameters[key] = value;
      if (forceRefresh) {
        this.esriLayer.refresh();
      }
    } else {
      this.noLayerErr();
    }
  }
  /**
   * Handles click events for WMS layers (makes a WMS GetFeatureInfo call behind the scenes).
   *
   * @param {Array} layerList a list of strings identifying the WMS sublayers to be queried
   * @param {Point} point a RAMP Point indicating where the user clicked
   * @param {String} mimeType the format to be requested for the response
   * @returns {Promise} a promise which resolves with the GetFeatureInfo response
   */
  getFeatureInfo(layerList, point, mimeType) {
    const map = this.$iApi.geo.map;
    const esriLayer = this.esriLayer;
    if (!map.esriView) {
      throw new Error("WMS get feature, no map view exists. Cannot derive click coords");
    }
    if (!esriLayer) {
      this.noLayerErr();
      throw new Error("wms get feature failed, no layer");
    }
    let wkid;
    let req;
    const ext = map.getExtent();
    const srList = esriLayer.spatialReferences;
    const layers = layerList.join(",");
    const screenPoint = map.esriView.toScreen(point.toESRI());
    const intX = Math.floor(screenPoint.x);
    const intY = Math.floor(screenPoint.y);
    const customReturnType = {
      "application/json": "json",
      "text/html": "text",
      "text/plain": "text"
    };
    const returnType = customReturnType[mimeType] || "text";
    const mapSR = map.getSR();
    if (mapSR.wkid) {
      wkid = mapSR.wkid;
    } else {
      wkid = 4326;
      console.error("Map is likely in a WKT projection. WMS Identify request will likely fail.");
    }
    if (srList && srList.length > 1) {
      if (srList.indexOf(wkid) === -1) {
        if (mapSR.latestWkid && srList.indexOf(mapSR.latestWkid) > -1) {
          wkid = mapSR.latestWkid;
        } else {
          console.error(
            "WMS service does not support the maps projection. Identify request will likely fail."
          );
        }
      }
    } else {
      console.error("No supported wkid/epsg code found for WMS service. Identify request will likely fail.");
    }
    if (esriLayer.version === "1.3" || esriLayer.version === "1.3.0") {
      req = {
        CRS: "EPSG:" + wkid,
        I: intX,
        J: intY,
        STYLES: "",
        FORMAT: esriLayer.imageFormat
      };
      if (this.$iApi.geo.layer.ogc.reversedAxisWKIDs().indexOf(wkid) > -1) {
        req.BBOX = `${ext.ymin},${ext.xmin},${ext.ymax},${ext.xmax}`;
      }
    } else {
      req = { SRS: "EPSG:" + wkid, X: intX, Y: intY };
    }
    if (!Object.prototype.hasOwnProperty.call(req, "BBOX")) {
      req.BBOX = `${ext.xmin},${ext.ymin},${ext.xmax},${ext.ymax}`;
    }
    const settings = {
      SERVICE: "WMS",
      REQUEST: "GetFeatureInfo",
      VERSION: esriLayer.version,
      WIDTH: map.getPixelWidth(),
      HEIGHT: map.getPixelHeight(),
      QUERY_LAYERS: layers,
      LAYERS: layers,
      INFO_FORMAT: mimeType
    };
    const clp = esriLayer.customLayerParameters;
    if (clp) {
      Object.keys(clp).forEach((key) => {
        if (key.toLowerCase() !== "styles") {
          settings[key] = clp[key];
        }
      });
    }
    Object.keys(settings).forEach((key) => req[key] = settings[key]);
    return EsriRequest(esriLayer.url.split("?")[0], {
      query: req,
      responseType: returnType
    });
  }
  /**
   * Finds the appropriate legend URLs for WMS layers.
   *
   * @param {Array} layerList a list of objects identifying the WMS layers to be queried
   * @returns {Array} a list of strings containing URLs for specified layers (order is preserved)
   */
  getLegendUrls(layerList) {
    if (!this.layerExists) {
      this.noLayerErr();
      return [];
    }
    const slMap = /* @__PURE__ */ new Map();
    this.esriLayer.allSublayers.forEach((sl) => {
      if (sl.visible) {
        if (sl.legendUrl) {
          this.origRampConfig.sublayers?.forEach((sublayer) => {
            if (sublayer.id && sublayer.currentStyle && sublayer.id === sl.name) {
              const wrapper = new UrlWrapper(sl.legendUrl);
              if ("STYLE" in wrapper.queryMap) {
                if (wrapper.queryMap.STYLE !== sublayer.currentStyle) {
                  sl.legendUrl = wrapper.updateQuery({
                    STYLE: sublayer.currentStyle
                  });
                }
              }
            }
          });
        }
        slMap.set(sl.name, sl.legendUrl);
      }
    });
    const legendURLs = layerList.map(
      (l) => l.styleLegends && l.currentStyle ? l.styleLegends.find((style) => {
        return style.name === l.currentStyle;
      }).url : void 0
    );
    legendURLs.forEach((entry, index) => {
      if (!entry) {
        legendURLs[index] = slMap.get(layerList[index].id);
      }
    });
    return legendURLs;
  }
  /**
   * Searches for a layer title defined by a wms.
   * @function getWMSLayerTitle
   * @private
   * @param  {String} wmsLayerId   layer id as defined in the wms (i.e. not wmsLayer.id)
   * @return {String}              layer title as defined on the service, '' if no title defined
   */
  getWMSLayerTitle(wmsLayerId) {
    if (!this.esriLayer) {
      return "";
    }
    let targetEntry;
    this.esriLayer.allSublayers.some((sl) => {
      if (sl.name === wmsLayerId) {
        targetEntry = sl.title;
        return true;
      }
    });
    return targetEntry || "";
  }
  /**
   * Download or refresh the internal symbology for the sublayer.
   *
   * @function loadSymbology
   */
  loadSymbology() {
    const startTime = Date.now();
    const configSublayers = this.config.sublayers;
    const legendArray = this.getLegendUrls(
      configSublayers.map((sublayer) => {
        return {
          id: sublayer.id,
          styleLegends: sublayer.styleLegends,
          currentStyle: sublayer.currentStyle
        };
      })
    ).map((imageUri, idx) => {
      const name = configSublayers[idx].name || this.getWMSLayerTitle(configSublayers[idx].id) || configSublayers[idx].id;
      const symbologyItem = {
        uid: this.$iApi.geo.shared.generateUUID(),
        label: name,
        svgcode: "",
        esriStandard: false,
        // is an image
        drawPromise: this.$iApi.geo.symbology.generateWMSSymbology(imageUri).then((data) => {
          if (startTime > this.lastCancel) {
            symbologyItem.svgcode = data.svgcode;
            symbologyItem.imgHeight = data.imgHeight;
            symbologyItem.imgWidth = data.imgWidth;
          }
        })
      };
      return symbologyItem;
    });
    this.legend = legendArray;
  }
}

class WfsLayer extends FileLayer {
  constructor(rampConfig, $iApi) {
    super(rampConfig, $iApi);
    this.layerType = LayerType.WFS;
  }
  async onInitiate() {
    const startTime = Date.now();
    const wrapper = new UrlWrapper(this.config.url);
    const { offset, limit } = wrapper.queryMap;
    const gj = await this.$iApi.geo.layer.ogc.loadWfsData(
      this.config.url,
      -1,
      parseInt(offset) || 0,
      parseInt(limit) || 1e3,
      void 0,
      this.config.xyInAttribs
    );
    if (startTime > this.lastCancel) {
      this.sourceGeoJson = gj;
      await super.onInitiate();
    }
  }
}

class DataLayer extends CommonLayer {
  /**
   * This represents a file content transformed to our common consumption format.
   * The implementation classes will handle that transformation, and common routines in this class can process
   * it onInitiate.
   */
  sourceJson;
  attribs;
  // since this is a mapless layer, only applies to visibility of layer in the grid
  _visibility;
  // ----------- LAYER CONSTRUCTION AND INITIALIZAION -----------
  constructor(rampConfig, $iApi) {
    super(rampConfig, $iApi);
    this.dataFormat = DataFormat.ESRI_FEATURE;
    this.layerFormat = LayerFormat.NOLAYER;
    this.drawState = DrawState.NOT_VISUAL;
    this.attribs = new AttribSource();
    this.supportsFeatures = true;
    this.mapLayer = false;
    this.isFile = false;
    this._visibility = rampConfig.state?.visibility ?? true;
    this.expectedTime.draw = 0;
  }
  async onInitiate() {
    if (this.sourceJson) {
      const realJson = this.sourceJson;
      if (realJson.data.length === 0 || realJson.fields.length === 0) {
        throw new Error("Data layer with no columns or now rows.");
      }
      const origCols = realJson.fields.slice();
      const row1 = realJson.data[0].slice();
      const allSpacesRegex = / /gi;
      this.fields = origCols.map((fName, i) => {
        let alias = "";
        let finalName = fName;
        if (fName.indexOf(" ") > -1) {
          alias = fName;
          finalName = fName.trim().replace(allSpacesRegex, "-");
          realJson.fields[i] = finalName;
        }
        const dataType = this.$iApi.geo.layer.files.inferType(row1[i]);
        return {
          name: finalName,
          alias,
          type: dataType,
          length: dataType === FieldType.STRING ? 256 : void 0
        };
      });
      this.oidField = "rampOID";
      this.fields.push({ name: this.oidField, type: FieldType.OID });
      realJson.fields.push(this.oidField);
      realJson.data.forEach((row, i) => row.push(i + 1));
      this.$iApi.geo.attributes.applyFieldMetadata(this, this.origRampConfig.fieldMetadata);
      this.fieldList = "*";
      const loadData = {
        batchSize: -1,
        // mandatory to avoid easy bugs in server process; not used here
        sourceDataJson: realJson,
        oidField: this.oidField,
        attribs: "*",
        // even required?
        fieldsToTrim: this.getFieldsToTrim()
      };
      this.attribs.attLoader = new DataLayerAttributeLoader(this.$iApi, loadData);
      await this.attribs.attLoader.getAttribs();
      this.featureCount = realJson.data.length;
      if (this.origRampConfig.nameField) {
        this.nameField = this.$iApi.geo.attributes.fieldValidator(this.fields, this.origRampConfig.nameField) || this.oidField;
      } else {
        this.nameField = this.oidField;
      }
      this.sourceJson = void 0;
      if (!this.origRampConfig.caching) {
        delete this.origRampConfig.rawData;
      }
    } else {
      throw new Error("Attempted to initiate file based data layer, sourceJson is missing");
    }
  }
  async terminate() {
    await super.terminate();
  }
  async reload() {
    this.$iApi.event.emit(GlobalEvents.LAYER_RELOAD_START, this);
    await this.terminate();
    await this.initiate();
    if (this.layerState !== LayerState.ERROR) {
      this.onLoad();
    }
    setTimeout(() => {
      this.$iApi.event.emit(GlobalEvents.LAYER_RELOAD_END, this);
    }, 300);
  }
  onLoadActions() {
    const proms = super.onLoadActions();
    this.legend = [
      {
        uid: this.$iApi.geo.shared.generateUUID(),
        label: "",
        svgcode: "",
        esriStandard: true,
        visibility: true,
        lastVisbility: true,
        drawPromise: this.getIcon(0).then((svg) => {
          this.legend[0].svgcode = svg;
        })
      }
    ];
    return proms;
  }
  // ----------- Attribute Methods -----------
  /**
   * Invokes the process to get the full set of attribute values for the layer.
   * Repeat calls will re-use the downloaded values unless the values have been explicitly cleared.
   *
   * @returns {Promise} resolves with set of attribute values
   */
  getAttributes() {
    return this.attribs.attLoader.getAttribs();
  }
  getTabularAttributes() {
    return this.$iApi.geo.attributes.generateTabularAttributes(this, this.attribs);
  }
  async getGraphic(objectId, options) {
    let resultAttribs = {};
    if (this.attribs.attLoader.isLoaded()) {
      const atSet = await this.attribs.attLoader.getAttribs();
      resultAttribs = atSet.features[atSet.oidIndex[objectId]];
    } else {
      throw new Error("Non ESRI data layer did not have attributes populated.");
    }
    return new Graphic(new NoGeometry(), "", resultAttribs);
  }
  async getIcon(objectId) {
    return '<svg id="SvgjsSvg1012" width="32" height="32" xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs" viewBox="0 0 32 32">                      <defs id="SvgjsDefs1013"></defs>                      <rect id="SvgjsRect1014" width="28"  height="28" x="2" y="2" fill="#2e8b57"></rect>                      <text id="SvgjsText1015" font-family="Roboto" font-size="23" fill="#ffffff" font-weight="bold" x="7.6875" y="-6.40000057220459" svgjs:data="{&quot;leading&quot;:&quot;1.3&quot;}">                          <tspan id="SvgjsTspan1016" class="grid-icons" dy="29.900000000000002" x="7.6875" svgjs:data="{&quot;newLined&quot;:true}">D</tspan>                      </text>                </svg>';
  }
  async getFilterOIDs(exclusions = [], extent = void 0) {
    return void 0;
  }
  // Since data layers (except table layers) do not have asynch attribute loading, there is nothing to do in the following methods.
  // However, we have it there just so that calling this method for a giant list is peaceful, and filtering
  // by layer type is not required.
  abortAttributeLoad() {
  }
  attribLoadAborted() {
    return false;
  }
  clearFeatureCache() {
  }
  downloadedAttributes() {
    return this.featureCount;
  }
  get layerExists() {
    return this.isLoaded;
  }
  /**
   * Returns the visibility of the layer data
   *
   * @returns {Boolean} visibility of the layer data
   */
  get visibility() {
    return this._visibility;
  }
  /**
   * Applies visibility to layer data.
   *
   * @param {Boolean} value the new visibility setting
   */
  set visibility(value) {
    if (this._visibility !== value) {
      this._visibility = value;
      this.$iApi.event.emit(GlobalEvents.LAYER_VISIBILITYCHANGE, {
        visibility: value,
        layer: this
      });
    }
  }
}

class JsonDataLayer extends DataLayer {
  constructor(rampConfig, $iApi) {
    super(rampConfig, $iApi);
    this.layerType = LayerType.DATAJSON;
  }
  async onInitiate() {
    const startTime = Date.now();
    let gj;
    if (this.origRampConfig.rawData) {
      gj = this.$iApi.geo.layer.files.rawDataJsonParser(this.origRampConfig.rawData, this.origRampConfig.caching);
    } else if (this.origRampConfig.url) {
      gj = await this.$iApi.geo.layer.files.fetchFileData(this.origRampConfig.url, this.layerType);
    } else {
      throw new Error("Json Data layer config contains no raw data or url");
    }
    if (startTime > this.lastCancel) {
      this.sourceJson = gj;
      await super.onInitiate();
    }
  }
}

class TableLayer extends DataLayer {
  // TODO if we add AQL filtering to the file based data layers, this prop and the appropriate initializers/methods should migrate to DataLayer
  filter;
  serviceUrl;
  constructor(rampConfig, $iApi) {
    super(rampConfig, $iApi);
    this.layerType = LayerType.DATATABLE;
    this.serviceUrl = rampConfig.url;
    this.filter = new Filter(rampConfig.permanentFilteredQuery || "", rampConfig.initialFilteredQuery || "");
  }
  async onInitiate() {
  }
  onLoadActions() {
    const loadPromises = super.onLoadActions();
    const startTime = Date.now();
    const urlData = this.$iApi.geo.shared.parseUrlIndex(this.serviceUrl);
    const featIdx = urlData.index || 0;
    const pLD = this.$iApi.geo.layer.loadLayerMetadata(this.serviceUrl).then((sData) => {
      if (startTime < this.lastCancel) {
        return;
      }
      if (!this.name) {
        this.name = sData.name;
      }
      this.layerTree.name = this.name;
      this.oidField = sData.objectIdField;
      this.nameField = this.origRampConfig.nameField || sData.displayField || this.oidField;
      this.fields = sData.fields;
      this.$iApi.geo.attributes.applyFieldMetadata(this, this.origRampConfig.fieldMetadata);
      const loadData = {
        // version number is only provided on 10.0 SP1 servers and up.
        // servers 10.1 and higher support the query limit flag
        supportsLimit: (sData.currentVersion || 1) >= 10.1,
        serviceUrl: this.serviceUrl,
        oidField: this.oidField,
        batchSize: -1,
        attribs: this.fieldList,
        permanentFilter: this.getSqlFilter(CoreFilter.PERMANENT),
        fieldsToTrim: this.getFieldsToTrim()
      };
      this.attribs.attLoader = new ArcServerAttributeLoader(this.$iApi, loadData);
      this.attribs.quickCache = new QuickCache(this.geomType);
    });
    const pFC = this.$iApi.geo.layer.loadFeatureCount(this.serviceUrl, this.getSqlFilter(CoreFilter.PERMANENT)).then((count) => {
      if (startTime > this.lastCancel) {
        this.featureCount = count;
      }
    });
    this.layerTree.layerIdx = featIdx;
    loadPromises.push(pLD, pFC);
    return loadPromises;
  }
  async getGraphic(objectId, opts) {
    let resultAttribs = {};
    const aCache = this.attribs.quickCache.getAttribs(objectId);
    if (aCache) {
      resultAttribs = aCache;
    } else if (this.attribs.attLoader.isLoaded()) {
      const atSet = await this.attribs.attLoader.getAttribs();
      resultAttribs = atSet.features[atSet.oidIndex[objectId]];
    } else {
      const serviceParams = {
        oid: objectId,
        serviceUrl: this.serviceUrl,
        includeGeometry: false,
        attribs: this.fieldList
      };
      const webFeat = await this.$iApi.geo.attributes.loadSingleFeature(serviceParams);
      this.attribs.quickCache.setAttribs(objectId, webFeat.attributes);
      resultAttribs = webFeat.attributes;
    }
    const resGraphic = new Graphic(new NoGeometry(), "", resultAttribs);
    return resGraphic;
  }
  abortAttributeLoad() {
    this.attribs.attLoader.abortAttribLoad();
  }
  clearFeatureCache() {
    this.attribs.clearAll();
  }
  downloadedAttributes() {
    if (this.isLoaded) {
      return this.attribs.attLoader.loadCount();
    } else {
      return 0;
    }
  }
  attribLoadAborted() {
    if (this.isLoaded) {
      return this.attribs.attLoader.isLoadAborted();
    } else {
      return false;
    }
  }
  // -- filter stuff --
  // A lot of overlap & duplication with AttribLayer. Currently don't have a good sharing mechansim.
  // Most of these methods are small so abstracting to geo.attribs seems equally pointless.
  // Making a common class between data and attribute layers adds in other duplications for the non-attribute-layer stuff.
  // This set of methods is more streamlined since there are no layer/extent stuff to deal with.
  setSqlFilter(filterKey, whereClause) {
    const currentFilter = this.filter.getSql(filterKey);
    if (whereClause === currentFilter) {
      return;
    }
    this.filter.setSql(filterKey, whereClause);
    this.$iApi.event.emit(GlobalEvents.FILTER_CHANGE, {
      uid: this.uid,
      filterKey
    });
  }
  getSqlFilter(filterKey) {
    return this.filter.getSql(filterKey);
  }
  /**
   * Returns a SQL WHERE condition that is combination of active filters.
   *
   * @method getCombinedSqlFilter
   * @param {Array} [exclusions] list of any filter keys to exclude from the result. omission includes all filters
   * @returns {String} all non-excluded sql statements connected with AND operators.
   */
  getCombinedSqlFilter(exclusions) {
    return this.filter.getCombinedSql(exclusions);
  }
  async getFilterOIDs(exclusions = [], extent = void 0) {
    const sql = this.filter.getCombinedSql(exclusions);
    if (!sql) {
      return void 0;
    }
    const impactedFilters = this.filter.sqlActiveFilters(exclusions);
    let cache = this.filter.getCache(impactedFilters, false);
    if (!cache) {
      const qOpts = {
        filterSql: sql,
        includeGeometry: false
      };
      cache = this.queryOIDs(qOpts);
      this.filter.setCache(cache, impactedFilters, false);
    }
    return cache;
  }
  /**
   * Will return an array of object ids for features in the layer that satisfy the conditions of the query options parameter.
   * @param options {Object} options to provide filters and helpful information.
   * @returns {Promise} resolves with an array of numbers (object ids)
   */
  queryOIDs(options) {
    const agsOpt = {
      url: this.serviceUrl,
      ...options
    };
    return this.$iApi.geo.query.arcGisServerQueryIds(agsOpt);
  }
  /**
   * Requests a set of features for this layer that match the criteria of the options
   * - filterGeometry : a RAMP API geometry to restrict results to
   * - filterSql : a where clause to apply against feature attributes
   * - includeGeometry : a boolean to indicate if result features should include the geometry
   * - sourceSR : a spatial reference indicating what the source layer is encoded in. providing can assist in result geometry being of a proper resolution
   *
   * @param options {Object} options to provide filters and helpful information.
   * @returns {Promise} resolves in an array of object ids and promises resolving in each feature
   */
  async queryFeaturesDiscrete(options) {
    const oids = await this.queryOIDs(options);
    const p = {
      getAttribs: true
    };
    return oids.map((oid) => ({
      oid,
      graphic: this.getGraphic(oid, p)
    }));
  }
  /**
   * Requests a set of features for this layer that match the criteria of the options
   * - filterSql : a where clause to apply against feature attributes
   * - outFields : a string of comma separated field names. will restrict fields included in the output
   *
   * @param options {Object} options to provide filters and helpful information.
   * @returns {Promise} resolves with an array of features that satisfy the criteria
   */
  async queryFeatures(options) {
    const discreteResult = await this.queryFeaturesDiscrete(options);
    return Promise.all(discreteResult.map((dr) => dr.graphic));
  }
}

class AttributeAPI extends APIScope {
  /**
   * Will populate the object id index for an attribute set.
   *
   * @param attSet attribute set that has features populated
   * @param oidField name of the object id field in the attribute set
   */
  oidIndexer(attSet, oidField) {
    attSet.features.forEach((feat, idx) => {
      attSet.oidIndex[feat[oidField]] = idx;
    });
  }
  /**
   * Will load an attribute set from an ArcGIS Server, recursively batching to work around maximum result limits.
   *
   * @param details defines the parameters for what to load
   * @param controller the controller which provides asyncronous hooks into the load, including loaded count and ability to abort
   */
  async arcGisBatchLoad(details, controller) {
    if (controller.loadAbortFlag) {
      return [];
    }
    const permFilter = details.permanentFilter ? ` AND ${details.permanentFilter}` : "";
    const params = {
      query: {
        where: `${details.oidField}>${details.maxId}${permFilter}`,
        outFields: details.attribs,
        orderByFields: details.oidField,
        returnGeometry: "false",
        f: "json"
      }
    };
    const [err, serviceResult] = await to(
      EsriRequest(details.serviceUrl + "/query", params)
    );
    if (!serviceResult) {
      console.error(`ArcGIS batch load error: ${details.serviceUrl}`, err);
      return Promise.reject(new Error(`ArcGIS batch load error: ${details.serviceUrl}`));
    }
    if (!serviceResult.data || !serviceResult.data.features) {
      console.error(`ArcGIS batch load gave no data/features: ${details.serviceUrl}`);
      return Promise.reject(new Error(`ArcGIS batch load gave no data/features: ${details.serviceUrl}`));
    }
    let feats = serviceResult.data.features;
    const len = feats.length;
    if (len > 0) {
      controller.loadedCount += len;
      let moreDataToLoad;
      if (details.supportsLimit) {
        moreDataToLoad = serviceResult.data.exceededTransferLimit;
      } else {
        if (details.batchSize === -1) {
          details.batchSize = len;
        }
        moreDataToLoad = len >= details.batchSize;
      }
      feats = this.trimFeatureSetAttributes(feats, details.fieldsToTrim ?? []);
      if (moreDataToLoad) {
        details.maxId = feats[len - 1].attributes[details.oidField];
        const futureFeats = await this.arcGisBatchLoad(details, controller);
        return controller.loadAbortFlag ? [] : feats.concat(futureFeats);
      } else {
        return controller.loadAbortFlag ? [] : feats;
      }
    } else {
      return [];
    }
  }
  /**
   * Will load an attribute set from an ArcGIS Server layer source.
   *
   * @param details defines the parameters for what to load
   * @param controller the controller which provides asyncronous hooks into the load, including loaded count and ability to abort
   */
  async loadArcGisServerAttributes(details, controller) {
    details.maxId = -1;
    details.batchSize = -1;
    const serverResult = await this.arcGisBatchLoad(details, controller);
    const attSet = {
      features: serverResult.map((aa) => aa.attributes),
      oidIndex: {}
    };
    this.oidIndexer(attSet, details.oidField);
    controller.loadIsDone = true;
    return attSet;
  }
  /**
   * Will generate an attribute set from a feature layer with local data (i.e. a file layer).
   *
   * @param details defines the parameters for what to load
   * @param controller the controller which provides asyncronous hooks into the load, including loaded count and ability to abort
   */
  async loadGraphicsAttributes(details, controller) {
    if (!details.sourceGraphics) {
      throw new Error("No .sourceGraphics provided to file layer attribute loader");
    }
    const pluckedAttributes = details.sourceGraphics.map((g) => toRaw(g).attributes);
    const attSet = {
      features: pluckedAttributes.toArray(),
      oidIndex: {}
    };
    this.oidIndexer(attSet, details.oidField);
    controller.loadIsDone = true;
    controller.loadedCount = attSet.features.length;
    return attSet;
  }
  /**
   * Will generate an attribute set from a compact json object. This is our base format for
   * DataLayer sources that are not hosted on ArcGIS server. Provided sourceDataJson on the details
   * parameter has already been cleaned and has object ids inserted.
   *
   * @param details defines the parameters for what to load
   * @param controller the controller which provides asyncronous hooks into the load, including loaded count and ability to abort
   */
  async loadCompactJsonAttributes(details, controller) {
    if (!details.sourceDataJson) {
      throw new Error("No .sourceDataJson provided to file data-layer attribute loader");
    }
    const fields = details.sourceDataJson.fields;
    const fieldsToTrim = details.fieldsToTrim ?? [];
    const rampAttributes = details.sourceDataJson.data.map((attRow) => {
      const attNugget = {};
      attRow.forEach((val, i) => {
        attNugget[fields[i]] = typeof val === "string" && fieldsToTrim.includes(fields[i]) ? val.trim() : val;
      });
      return attNugget;
    });
    const attSet = {
      features: rampAttributes,
      oidIndex: {}
    };
    this.oidIndexer(attSet, details.oidField);
    controller.loadIsDone = true;
    controller.loadedCount = attSet.features.length;
    details.sourceDataJson = void 0;
    return attSet;
  }
  async loadSingleFeature(details) {
    const params = {
      query: {
        f: "json",
        objectIds: details.oid,
        returnGeometry: details.includeGeometry,
        outFields: details.attribs
      }
    };
    if (typeof details.maxOffset !== "undefined") {
      params.query.maxAllowableOffset = details.maxOffset;
    }
    if (typeof details.mapSR !== "undefined") {
      params.query.outSR = details.mapSR;
    }
    if (typeof details.geometryPrecision !== "undefined" && details.geometryPrecision >= 0) {
      params.query.geometryPrecision = details.geometryPrecision;
    }
    const [err, serviceResult] = await to(
      EsriRequest(details.serviceUrl + "/query", params)
    );
    if (!serviceResult) {
      console.error(`ArcGIS single feature load error: ${details.serviceUrl}`, err);
      return Promise.reject(new Error(`ArcGIS single feature load error: ${details.serviceUrl}`));
    }
    if (!serviceResult.data || !serviceResult.data.features) {
      console.error(`Could not locate feature ${details.oid} for layer ${details.serviceUrl}`);
      return Promise.reject(new Error(`Could not locate feature ${details.oid} for layer ${details.serviceUrl}`));
    }
    const feats = serviceResult.data.features;
    if (feats.length > 0) {
      let geom;
      let feat = this.trimFeatureSetAttributes([feats[0]], details.fieldsToTrim ?? [])[0];
      if (details.includeGeometry) {
        feat.geometry.spatialReference = serviceResult.data.spatialReference;
        const localEsriGeom = fromJSON$2(feat.geometry);
        geom = this.$iApi.geo.geom.geomEsriToRamp(localEsriGeom);
      } else {
        geom = new NoGeometry();
      }
      return new Graphic(geom, "", feat.attributes);
    }
    return Promise.reject(new Error(`Could not locate feature ${details.oid} for layer ${details.serviceUrl}`));
  }
  /**
   * Trims the desired attribute values for a feature set's attribute groups.
   * @param features The featureset to be trimmed.
   * @param fieldsToTrim Array of string names of the attributes to be trimmed.
   * @returns The featureset, trimmed.
   */
  trimFeatureSetAttributes(features, fieldsToTrim) {
    fieldsToTrim.forEach((attrToTrim) => {
      features.forEach((feat) => {
        if (typeof feat.attributes[attrToTrim] === "string") {
          feat.attributes[attrToTrim] = feat.attributes[attrToTrim].trim();
        }
      });
    });
    return features;
  }
  /**
   * Will order the fields of a layer based on its fieldInfo.
   *
   * @param currentFields the current order of the fields
   * @param orderInfo the fieldInfo config that contains the order the fields should be displayed in
   */
  orderFields(currentFields, orderInfo) {
    const magicFinder = (sauce, targetName) => {
      return sauce.findIndex((protoField) => protoField.name === targetName);
    };
    const magicSorter = (field1, field2) => {
      const ordF1 = magicFinder(orderInfo, field1.name);
      const ordF2 = magicFinder(orderInfo, field2.name);
      if (ordF1 === -1 && ordF2 === -1) {
        return magicFinder(currentFields, field1.name) - magicFinder(currentFields, field2.name);
      } else if (ordF1 === -1) {
        return 1;
      } else if (ordF2 === -1) {
        return -1;
      } else {
        return ordF1 - ordF2;
      }
    };
    return currentFields.slice().sort(magicSorter);
  }
  /**
   * Will apply any field config metadata to a layer.
   * Should be used after loading process has populated .fields property of the layer
   *
   * @param layer the layer to apply the additional configuration to. Will be modified.
   * @param fieldMetadata field settings from the config object. can be undefined
   */
  applyFieldMetadata(layer, fieldMetadata = void 0) {
    if (!fieldMetadata || !fieldMetadata.fieldInfo) {
      layer.fieldList = "*";
      return;
    }
    let fieldsToTrim = fieldMetadata.fieldInfo.filter((elem) => elem.trim).map((elem) => elem.name);
    layer.fields.forEach((field) => {
      if (fieldsToTrim.includes(field.name)) {
        field.trim = true;
      }
    });
    if (fieldMetadata?.enforceOrder && fieldMetadata?.fieldInfo && fieldMetadata?.fieldInfo.length > 0) {
      layer.fields = this.orderFields(layer.fields, fieldMetadata.fieldInfo);
      layer.fieldList = fieldMetadata.fieldInfo.map((f) => f.name).join(",");
    }
    if (fieldMetadata.exclusiveFields) {
      if (!fieldMetadata.fieldInfo.find((f) => f.name === layer.oidField)) {
        fieldMetadata.fieldInfo.push({ name: layer.oidField });
      }
      layer.fieldList = fieldMetadata.fieldInfo.map((f) => f.name).join(",");
      const tempFI = fieldMetadata.fieldInfo;
      layer.fields = layer.fields.filter((origField) => {
        return tempFI.find((fInfo) => fInfo.name === origField.name);
      });
    } else {
      layer.fieldList = "*";
    }
    fieldMetadata.fieldInfo.forEach((cf) => {
      if (cf.alias) {
        const ff = layer.fields.find((fff) => fff.name === cf.name);
        if (ff) {
          ff.alias = cf.alias;
        }
      }
    });
  }
  /**
   * Util function to manage trickery. Non-Arcgis layer sources can have field names that are bad keys.
   * Our loader will have corrected them, but the ramp layer config may still be referencing the original names
   * (e.g. nameField, tooltipField).
   * This function will attempt to return the valid field name for a given original field name.
   *
   * @param fields array of valid fields for the layer
   * @param originalName field name as defined in the source
   * @returns a valid field name to use. Empty string if none found
   */
  fieldValidator(fields, originalName) {
    if (fields.findIndex((f) => f.name === originalName) === -1) {
      const validField = fields.find((f) => f.alias === originalName);
      if (validField) {
        return validField.name;
      } else {
        console.warn(`Cannot find name field in layer field list: ${originalName}`);
        return "";
      }
    } else {
      return originalName;
    }
  }
  /**
   * Will generate the tabular transformation of an attribute set for a layer.
   * The result will also be cached in the attribute source.
   * If the result is already cached, it will be returned.
   * The layer must be the owner of the attribute source.
   * This method is generally called from an internal call within a layer.
   * It exists as a public API to allow re-use across diverging layer types.
   *
   * @param layer the layer owning the attributes and the attribute source
   * @param attSource the attribute source for the attributes to transform
   */
  async generateTabularAttributes(layer, attSource) {
    if (!attSource.attLoader.tabularAttributesCache) {
      attSource.attLoader.tabularAttributesCache = this.$iApi.geo.attributes.generateTabularAttributesWorker(
        layer,
        attSource
      );
    }
    return attSource.attLoader.tabularAttributesCache;
  }
  /**
   * Worker method for the above generateTabularAttributes call.
   * Separating allows us to use async syntax for the heavy lifting,
   * but provides a promise via method that can easily be assigned to the
   * cache. Difficult to save your own async promise within your own method.
   *
   * @param layer the layer owning the attributes and the attribute source
   * @param attSource the attribute source for the attributes to transform
   */
  async generateTabularAttributesWorker(layer, attSource) {
    if (layer.dataFormat === DataFormat.ESRI_RASTER) {
      throw new Error("Attempting to get attributes on a raster layer.");
    }
    const attSet = await attSource.attLoader.getAttribs();
    if (!attSet.features || attSet.features.length === 0) {
      return {
        columns: [],
        rows: [],
        fields: [],
        oidField: ""
      };
    }
    const columns = layer.fields.filter(
      (field) => (
        // assuming there is at least one attribute - empty attribute bundle promises should be rejected, so it never even gets this far
        // filter out fields where there is no corresponding attribute data
        Object.prototype.hasOwnProperty.call(attSet.features[0], toRaw(field).name)
      )
    ).map((field) => ({
      data: toRaw(field).name,
      // TODO calling this data is really unintuitive. consider global rename to fieldName, name, attribName, etc.
      title: toRaw(field).alias || toRaw(field).name
    }));
    const rows = attSet.features.map((feature) => {
      const att = merge({}, feature);
      att.rvInteractive = "";
      att.rvSymbol = layer.getIcon(feature[layer.oidField]);
      att.rvUid = layer.uid;
      return att;
    });
    columns.forEach((c) => {
      if (c.data.slice(-2) === "()") {
        const secretFunc = function() {
          return this[c.data];
        };
        const stub = c.data.slice(0, -2);
        rows.forEach((r) => {
          r[stub] = secretFunc;
        });
      }
    });
    return {
      columns,
      rows,
      fields: layer.fields,
      // keep fields for reference ...
      oidField: layer.oidField
      // ... keep a reference to id field ...
    };
  }
}
class AttribSource {
  /**
   * Actual attribute loader, if exists
   */
  _attribLoader;
  /**
   * Actual quick cache, if exists
   */
  _quickCache;
  /**
   * Used to access the attribute loader in layer classes
   */
  get attLoader() {
    if (this._attribLoader) {
      return this._attribLoader;
    } else {
      console.trace();
      throw new Error("Attempted to load attributes prior to layer being loaded.");
    }
  }
  set attLoader(v) {
    this._attribLoader = v;
  }
  /**
   * Used to access the quick cache in layer classes
   */
  get quickCache() {
    if (this._quickCache) {
      return this._quickCache;
    } else {
      console.trace();
      throw new Error("Attempted to access attribute cache prior to layer being loaded.");
    }
  }
  set quickCache(v) {
    this._quickCache = v;
  }
  /**
   * Erase all local data in this object
   */
  clearAll() {
    if (this._attribLoader) {
      this._attribLoader.destroyAttribs();
    }
    if (this._quickCache) {
      this._quickCache.clearAll();
    }
  }
}
class AsynchAttribController {
  loadedCount;
  loadAbortFlag;
  loadIsDone;
  constructor() {
    this.loadedCount = 0;
    this.loadAbortFlag = false;
    this.loadIsDone = false;
  }
}
class AttributeLoaderBase extends APIScope {
  aac;
  loadPromise;
  details;
  tabularAttributesCache;
  constructor(iApi, details) {
    super(iApi);
    this.aac = new AsynchAttribController();
    this.details = details;
  }
  /**
   * Allows the list of field names to download to be updated. Allows support for divergant loading
   * flows between different layers.
   *
   * @param {string} newList
   */
  updateFieldList(newList) {
    this.details.attribs = newList;
  }
  updateFieldsToTrim(newFieldsToTrim) {
    this.details.fieldsToTrim = newFieldsToTrim;
  }
  getAttribs() {
    if (!this.loadPromise) {
      this.aac = new AsynchAttribController();
      this.loadPromise = this.loadPromiseGenerator();
    }
    return this.loadPromise;
  }
  abortAttribLoad() {
    this.aac.loadAbortFlag = true;
  }
  destroyAttribs() {
    this.loadPromise = void 0;
    this.tabularAttributesCache = void 0;
    this.aac.loadIsDone = false;
    this.aac.loadedCount = 0;
  }
  loadCount() {
    return this.aac.loadedCount;
  }
  isLoaded() {
    return this.aac.loadIsDone;
  }
  isLoadAborted() {
    return this.aac.loadAbortFlag;
  }
  // this will be overrideable.
  // so one function for arcgis server. another for baked featurelayer. another for json file source
  loadPromiseGenerator() {
    return Promise.reject(new Error("Subclass of AttributeLoaderBase did not implement loadPromiseGenerator"));
  }
}
class ArcServerAttributeLoader extends AttributeLoaderBase {
  constructor(iApi, details) {
    super(iApi, details);
  }
  loadPromiseGenerator() {
    return this.$iApi.geo.attributes.loadArcGisServerAttributes(this.details, this.aac);
  }
}
class FileLayerAttributeLoader extends AttributeLoaderBase {
  constructor(iApi, details) {
    super(iApi, details);
  }
  loadPromiseGenerator() {
    return this.$iApi.geo.attributes.loadGraphicsAttributes(this.details, this.aac);
  }
}
class DataLayerAttributeLoader extends AttributeLoaderBase {
  constructor(iApi, details) {
    super(iApi, details);
  }
  loadPromiseGenerator() {
    return this.$iApi.geo.attributes.loadCompactJsonAttributes(this.details, this.aac);
  }
}
class QuickCache {
  attribs;
  // the "any" type here is funny. for points, its BaseGeometry, for line/poly based, it's an object indexed by scale,
  // which then containts an object indexed by key (likely oid) and returns BaseGeometry.
  // will keep as any since it's private and the interfaces are casting to BaseGeometry. otherwise would need type shenannigans.
  geoms;
  // extents for feature layer graphics that do not have a point geometry
  extents;
  /**
   * Used to determine if we need to cache geometry at different scales.
   */
  isPoint;
  constructor(geomType) {
    this.attribs = {};
    this.geoms = {};
    this.extents = {};
    this.isPoint = geomType === GeometryType.POINT || geomType === GeometryType.MULTIPOINT;
  }
  getScaleStore(scale) {
    if (!this.geoms[scale]) {
      this.geoms[scale] = {};
    }
    return this.geoms[scale];
  }
  getGeomStore(scale = void 0) {
    if (this.isPoint) {
      return this.geoms;
    } else {
      if (typeof scale === "undefined") {
        throw new Error("Attempted to access geometry store for non-point layer without providing a map scale");
      }
      return this.getScaleStore(scale);
    }
  }
  getAttribs(key) {
    return this.attribs[key];
  }
  setAttribs(key, atts) {
    this.attribs[key] = atts;
  }
  getGeom(key, scale = void 0) {
    return this.getGeomStore(scale)[key];
  }
  setGeom(key, geom, scale = void 0) {
    const store = this.getGeomStore(scale);
    store[key] = geom;
  }
  getExtent(key) {
    return this.extents[key];
  }
  setExtent(key, extent) {
    this.extents[key] = extent;
  }
  clearAll() {
    this.attribs = {};
    this.geoms = {};
    this.extents = {};
  }
}

class BaseRenderer {
  innerRenderer;
  symbolUnits;
  defaultUnit;
  type;
  falseRenderer;
  // falseRenderer is set to true when we are creating a fake renderer to facilitate generating a legend from
  // a non-feature service, like a tile layer or imagery layer.
  constructor(esriRenderer, layerFields, falseRenderer = false) {
    this.innerRenderer = esriRenderer;
    this.symbolUnits = [];
    this.falseRenderer = falseRenderer;
    this.type = RendererType.Unknown;
  }
  // this function takes a set of attributes and extracts a value that can be used to match the owner of the attributes
  // to a part of a renderer. Use `any` result as the type can vary between renderers.
  makeSearchParams(attributes) {
    return attributes;
  }
  searchRenderer(attributes) {
    const sParams = this.makeSearchParams(attributes);
    const targetSU = this.symbolUnits.find((su) => su.match(sParams));
    if (targetSU) {
      return targetSU;
    } else if (this.defaultUnit) {
      return this.defaultUnit;
    }
    console.error(`renderer search could not find match for ${sParams}`);
    const defaultSymbol = new BaseSymbolUnit(this);
    defaultSymbol.svgCode = "";
    return defaultSymbol;
  }
  getGraphicIcon(attributes) {
    return this.searchRenderer(attributes).svgCode;
  }
  getGraphicSymbol(attributes) {
    return this.searchRenderer(attributes).symbol;
  }
  // worker function. determines if a field value should be wrapped in
  // any character and returns the character. E.g. string would return ', numbers return empty string.
  getFieldDelimiter(fieldName, fields) {
    let delim = `'`;
    if (!fields || fields.length === 0) {
      return delim;
    }
    const f = fields.find((ff) => ff.name === fieldName);
    if (f && f.type && f.type !== "string") {
      delim = "";
    }
    return delim;
  }
  // worker function
  // corrects for any character-case discrepancy for field names in the renderer vs on the layer
  cleanFieldName(fieldName, fields) {
    if (!fieldName) {
      return fieldName;
    }
    let myField = fields.find((f) => f.name === fieldName);
    if (myField) {
      return fieldName;
    } else {
      const lowName = fieldName.toLowerCase();
      myField = fields.find((f) => f.name.toLowerCase() === lowName);
      if (myField) {
        return myField.name;
      } else {
        return fieldName;
      }
    }
  }
  makeElseClause() {
    if (this.falseRenderer) {
      return "";
    }
    const elseClauseGuts = this.symbolUnits.map((pl) => pl.definitionClause).join(" OR ");
    return `(NOT (${elseClauseGuts}))`;
  }
}
class BaseSymbolUnit {
  isDefault = false;
  svgCode = "";
  symbol;
  definitionClause = "";
  label = "";
  parent;
  constructor(parent) {
    this.parent = parent;
    this.symbol = new EsriSimpleMarkerSymbol();
  }
  match(searchParams) {
    return !!searchParams;
  }
}
class SimpleRenderer extends BaseRenderer {
  constructor(esriRenderer, layerFields) {
    super(esriRenderer, layerFields);
    this.type = RendererType.Simple;
    const su = new BaseSymbolUnit(this);
    su.label = esriRenderer.label || "";
    su.symbol = esriRenderer.symbol;
    su.definitionClause = "";
    this.symbolUnits.push(su);
  }
}
class UniqueValueRenderer extends BaseRenderer {
  delim;
  keyFields;
  constructor(esriRenderer, layerFields, falseRenderer = false) {
    super(esriRenderer, layerFields, falseRenderer);
    this.type = RendererType.Unique;
    this.delim = esriRenderer.fieldDelimiter || ", ";
    const quoter = (inStr) => {
      return inStr.replace(/'/g, `''`);
    };
    this.keyFields = [esriRenderer.field, esriRenderer.field2, esriRenderer.field3].filter((fn) => fn).map((fn) => this.cleanFieldName(fn, layerFields));
    const fieldDelims = this.keyFields.map((fn) => this.getFieldDelimiter(fn, layerFields));
    esriRenderer.uniqueValueInfos.forEach((uvi) => {
      const su = new UniqueValueSymbolUnit(this, uvi.value);
      su.label = uvi.label || "";
      su.symbol = uvi.symbol;
      if (!this.falseRenderer) {
        const defClauseKeyValues = su.matchValue.split(this.delim);
        const defClause = this.keyFields.map(
          (kf, i) => defClauseKeyValues[i] === "<Null>" ? `${kf} IS NULL` : `${kf} = ${fieldDelims[i]}${quoter(defClauseKeyValues[i])}${fieldDelims[i]}`
        ).join(" AND ");
        su.definitionClause = `(${defClause})`;
        su.matchValue = su.matchValue.replace(/<Null>/g, "");
      }
      this.symbolUnits.push(su);
    });
    if (esriRenderer.defaultSymbol) {
      const su = new UniqueValueSymbolUnit(this, "");
      su.isDefault = true;
      su.label = esriRenderer.defaultLabel || "";
      su.symbol = esriRenderer.defaultSymbol;
      su.definitionClause = this.makeElseClause();
      this.defaultUnit = su;
    }
  }
  makeSearchParams(attributes) {
    return this.keyFields.map((fn) => {
      let graphicKey = attributes[fn] === null ? "" : attributes[fn];
      if (typeof graphicKey !== "string") {
        graphicKey = graphicKey.toString();
      }
      return graphicKey;
    }).join(this.delim);
  }
}
class UniqueValueSymbolUnit extends BaseSymbolUnit {
  matchValue;
  constructor(parent, value) {
    super(parent);
    if (typeof value === "number") {
      this.matchValue = value.toString();
    } else {
      this.matchValue = value;
    }
  }
  match(searchParams) {
    return this.matchValue === searchParams;
  }
}
class ClassBreaksRenderer extends BaseRenderer {
  valField;
  constructor(esriRenderer, layerFields, falseRenderer = false) {
    super(esriRenderer, layerFields, falseRenderer);
    this.valField = this.cleanFieldName(esriRenderer.field, layerFields);
    esriRenderer.classBreakInfos.forEach((cbi, i) => {
      const first = i === 0;
      const su = new ClassBreaksSymbolUnit(this, cbi.minValue, cbi.maxValue, first);
      su.label = cbi.label || "";
      su.symbol = cbi.symbol;
      if (!this.falseRenderer) {
        su.definitionClause = `(${this.valField} >${first ? "=" : ""}  ${cbi.minValue} AND ${this.valField} <= ${cbi.maxValue})`;
      }
      this.symbolUnits.push(su);
    });
    if (esriRenderer.defaultSymbol) {
      const su = new ClassBreaksSymbolUnit(this, 0, 0, false);
      su.isDefault = true;
      su.label = esriRenderer.defaultLabel || "";
      su.symbol = esriRenderer.defaultSymbol;
      su.definitionClause = this.makeElseClause();
      this.defaultUnit = su;
    }
  }
  makeSearchParams(attributes) {
    return parseFloat(attributes[this.valField]);
  }
}
class ClassBreaksSymbolUnit extends BaseSymbolUnit {
  /** min is exclusive, unless first class break */
  minValue;
  /** max is inclusive */
  maxValue;
  firstBreak;
  constructor(parent, minValue, maxValue, firstBreak) {
    super(parent);
    this.minValue = minValue;
    this.maxValue = maxValue;
    this.firstBreak = firstBreak;
  }
  match(searchParams) {
    if (this.minValue === this.maxValue) {
      return this.maxValue === searchParams;
    }
    return this.firstBreak ? this.minValue <= searchParams && this.maxValue >= searchParams : this.minValue < searchParams && this.maxValue >= searchParams;
  }
}

class SymbologyAPI extends APIScope {
  constructor(iApi) {
    super(iApi);
  }
  // layer renderer types
  SIMPLE = "simple";
  UNIQUE_VALUE = "unique-value";
  CLASS_BREAKS = "class-breaks";
  NONE = "none";
  CONTAINER_SIZE = 32;
  // size of the symbology item container
  CONTENT_SIZE = 24;
  // size of the symbology graphic
  CONTENT_IMAGE_SIZE = 28;
  // size of the symbology graphic if it's an image (images tend to already have a white boarder around them)
  CONTAINER_CENTER = this.CONTAINER_SIZE / 2;
  CONTENT_PADDING = (this.CONTAINER_SIZE - this.CONTENT_SIZE) / 2;
  /**
   * Given feature attributes, return the image URL for that feature/graphic object.
   *
   * @method getGraphicIcon
   * @param {Object} attributes object of feature attribute key value pairs
   * @param {Object} renderer an enhanced renderer (see function enhanceRenderer)
   * @return {String} svgcode Url to the features symbology image
   */
  getGraphicIcon(attributes, renderer) {
    return renderer.getGraphicIcon(attributes);
  }
  /**
   * Given feature attributes, return the symbol for that feature/graphic object.
   *
   * @method getGraphicSymbol
   * @param {Object} attributes object of feature attribute key value pairs
   * @param {Object} renderer an enhanced renderer (see function enhanceRenderer)
   * @return {Object} an ESRI Symbol object in server format
   */
  getGraphicSymbol(attributes, renderer) {
    return renderer.getGraphicSymbol(attributes);
  }
  makeRenderer(esriRenderer, fields, falseRenderer = false) {
    switch (esriRenderer.type) {
      case this.SIMPLE:
        return new SimpleRenderer(esriRenderer, fields);
      case this.CLASS_BREAKS:
        return new ClassBreaksRenderer(esriRenderer, fields, falseRenderer);
      case this.UNIQUE_VALUE:
        return new UniqueValueRenderer(esriRenderer, fields, falseRenderer);
      default:
        throw new Error(`Unknown renderer type encountered - ${esriRenderer.type}`);
    }
  }
  /**
   * Generates svg symbology for WMS layers.
   * @function generateWMSSymbology
   * @param {String} name label for the symbology item (it's not used right now, but is required to be consistent with other symbology generating functions)
   * @param {String} imageUri url or dataUrl of the legend image
   * @return {Promise} a promise resolving with symbology svg code and its label
   */
  async generateWMSSymbology(imageUri) {
    const draw = svgjs(window.document.createElement("div")).size(this.CONTAINER_SIZE, this.CONTAINER_SIZE).viewbox(0, 0, 0, 0);
    const symbologyItem = {
      svgcode: "",
      imgHeight: "",
      imgWidth: ""
    };
    if (imageUri) {
      const svgcode = await this.renderSymbologyImage(imageUri);
      if (svgcode) {
        symbologyItem.svgcode = svgcode;
        const svg = document.createElement("span");
        svg.innerHTML = svgcode;
        const img = svg.firstElementChild?.lastElementChild;
        symbologyItem.imgHeight = img?.getAttribute("height") || "";
        symbologyItem.imgWidth = img?.getAttribute("width") || "";
      } else {
        symbologyItem.svgcode = draw.svg();
      }
    } else {
      symbologyItem.svgcode = draw.svg();
    }
    return symbologyItem;
  }
  /**
   * Converts a config-supplied list of symbology to the format used by layer records.
   *
   * @private
   * @function _listToSymbology
   * @param {Function} conversionFunction a conversion function to wrap the supplied image into an image or an icon style symbology container
   * @param {Array} list a list of config-supplied symbology items in the form of [ { text: <String>, image: <String> }, ... ] wher `image` can be dataURL or an actual url
   * @return {Array} an array of converted symbology symbols in the form of [ { name: <String>, image: <String>, svgcode: <String> }, ... ]; items will be populated async as conversions are done
   */
  listToSymbology(conversionFunction, list) {
    const results = list.map(({ text, image }) => {
      const result = {
        name: text,
        image,
        // url
        svgcode: ""
      };
      conversionFunction(image).then((svgcode) => {
        result.svgcode = svgcode;
      });
      return result;
    });
    return results;
  }
  // these two functions called by legend ui to make symbol stacks.
  // may need to adjust stuff with new UI
  listToIconSymbology(list) {
    return this.listToSymbology(this.renderSymbologyIcon, list);
  }
  listToImageSymbology(list) {
    return this.listToSymbology(this.renderSymbologyImage, list);
  }
  /**
   * Renders a supplied image as an image-style symbology item (preserving the true image dimensions).
   *
   * @function renderSymbologyImage
   * @param {String} imageUri a image dataUrl or a regular url
   * @param {Object} draw [optional=null] an svg container to draw the image on; if not supplied, a new one is created
   */
  async renderSymbologyImage(imageUri, draw = null) {
    if (draw === null) {
      draw = svgjs(window.document.createElement("div")).size(this.CONTAINER_SIZE, this.CONTAINER_SIZE).viewbox(0, 0, 0, 0);
    }
    const dataUri = await this.$iApi.geo.shared.convertImagetoDataURL(imageUri);
    if (dataUri === imageUri) {
      return "";
    }
    const { loader } = await this.svgDrawImage(draw, dataUri);
    draw.viewbox(0, 0, loader.width, loader.height);
    return draw.svg();
  }
  /**
   * Renders a supplied image as an icon-style symbology item (fitting an image inside an icon container, usually 32x32 pixels).
   *
   * @function renderSymbologyIcon
   * @param {String} imageUri a image dataUrl or a regular url
   * @param {Object} draw [optional=null] an svg container to draw the image on; if not supplied, a new one is created
   */
  async renderSymbologyIcon(imageUri, draw = null) {
    if (draw === null) {
      const container = window.document.createElement("div");
      container.setAttribute("style", "opacity:0;position:fixed;left:100%;top:100%;overflow:hidden");
      window.document.body.appendChild(container);
      draw = svgjs(container).size(this.CONTAINER_SIZE, this.CONTAINER_SIZE).viewbox(0, 0, this.CONTAINER_SIZE, this.CONTAINER_SIZE);
    }
    const convertedUrl = await this.$iApi.geo.shared.convertImagetoDataURL(imageUri);
    const { image } = await this.svgDrawImage(draw, convertedUrl);
    image.center(this.CONTAINER_CENTER, this.CONTAINER_CENTER);
    this.fitInto(image, this.CONTENT_IMAGE_SIZE);
    return draw.svg();
  }
  /**
   * Generates a placeholder symbology graphic.
   * @function generatePlaceholderSymbology
   * @private
   * @param  {String} name label symbology label
   * @param  {String} colour colour to use in the graphic
   * @return {Object} symbology svg code and its label
   */
  generatePlaceholderSymbology(name, colour = "#000") {
    const draw = svgjs(window.document.createElement("div")).size(this.CONTAINER_SIZE, this.CONTAINER_SIZE).viewbox(0, 0, this.CONTAINER_SIZE, this.CONTAINER_SIZE);
    draw.rect(this.CONTENT_IMAGE_SIZE, this.CONTENT_IMAGE_SIZE).center(this.CONTAINER_CENTER, this.CONTAINER_CENTER).fill(colour);
    const textElement = draw.text(name[0].toUpperCase()).size(23).fill("#fff").attr({
      "font-weight": "bold",
      "font-family": "Roboto"
    }).center(this.CONTAINER_CENTER, this.CONTAINER_CENTER);
    textElement.tspan(name[0].toUpperCase()).addClass("grid-icons").attr({
      dy: "29.900000000000002",
      x: "7.6875"
    });
    return {
      name,
      svgcode: draw.svg()
    };
  }
  async generateBlankSymbology() {
    return svgjs(window.document.createElement("div")).size(this.CONTAINER_SIZE, this.CONTAINER_SIZE).svg();
  }
  /**
   * Generate an SVG string for an ESRI symbol.
   * @private
   * @param  {Object} symbol an ESRI symbol object in JS API format
   * @return {Promise} resolves to an SVG string representing the symbol
   */
  async symbolToSvg(symbol) {
    const _this = this;
    const pts2Pxl = 1.33333;
    const container = window.document.createElement("div");
    container.setAttribute("style", "opacity:0;position:fixed;left:100%;top:100%;overflow:hidden");
    window.document.body.appendChild(container);
    const draw = svgjs(container).size(this.CONTAINER_SIZE, this.CONTAINER_SIZE).viewbox(0, 0, this.CONTAINER_SIZE, this.CONTAINER_SIZE);
    const esriSimpleMarkerSimbol = {
      // @ts-ignore
      path({ size, path }) {
        return draw.path(path).size(size * pts2Pxl);
      },
      // @ts-ignore
      circle({ size }) {
        return draw.circle(size * pts2Pxl);
      },
      // @ts-ignore
      cross({ size }) {
        return draw.path("M 0,10 L 20,10 M 10,0 L 10,20").size(size * pts2Pxl);
      },
      // @ts-ignore
      x({ size }) {
        return draw.path("M 0,0 L 20,20 M 20,0 L 0,20").size(size * pts2Pxl);
      },
      // @ts-ignore
      triangle({ size }) {
        return draw.path("M 20,20 L 10,0 0,20 Z").size(size * pts2Pxl);
      },
      // @ts-ignore
      diamond({ size }) {
        return draw.path("M 20,10 L 10,0 0,10 10,20 Z").size(size * pts2Pxl);
      },
      // @ts-ignore
      square({ size }) {
        return draw.path("M 0,0 20,0 20,20 0,20 Z").size(size * pts2Pxl);
      }
    };
    const ESRI_DASH_MAPS = {
      [LineStyleType.SOLID]: "none",
      // esriSLSSolid
      [LineStyleType.NONE]: "none",
      // esriSLSNull
      [LineStyleType.DASH]: "5.333,4",
      // esriSLSDash
      [LineStyleType.DOT]: "1.333,4",
      // esriSLSDot
      [LineStyleType.DASHDOT]: "5.333,4,1.333,4",
      // esriSLSDashDot
      [LineStyleType.LONGDASH]: "10.666,4",
      // esriSLSLongDash
      [LineStyleType.LONGDASHDOT]: "10.666,4,1.333,4",
      // esriSLSLongDashDot
      [LineStyleType.LONGDASHDOTDOT]: "10.666,4,1.333,4,1.333,4",
      // esriSLSLongDashDotDot
      [LineStyleType.SHORTDOT]: "1.333,1.333",
      // esriSLSShortDot
      [LineStyleType.SHORTDASH]: "5.333,1.333",
      // esriSLSShortDash
      [LineStyleType.SHORTDASHDOT]: "5.333,1.333,1.333,1.333",
      // esriSLSShortDashDot
      [LineStyleType.SHORTDASHDOTDOT]: "5.333,1.333,1.333,1.333,1.333,1.333"
      // esriSLSShortDashDotDot
    };
    const DEFAULT_STROKE = {
      color: "#000",
      opacity: 1,
      width: 1,
      linecap: "square",
      linejoin: "miter",
      miterlimit: 4
    };
    const DEFAULT_OUTLINE = {
      color: [0, 0, 0, 0],
      width: 0,
      style: ESRI_DASH_MAPS.none
    };
    const esriSFSFills = {
      solid: (symbolColour) => {
        return {
          color: symbolColour.colour,
          opacity: symbolColour.opacity
        };
      },
      none: () => "transparent",
      // esriSFSNull
      horizontal: (_symbolColour, symbolStroke) => {
        const cellSize = 5;
        return draw.pattern(cellSize, cellSize, (add) => add.line(0, cellSize / 2, cellSize, cellSize / 2)).stroke(symbolStroke);
      },
      vertical: (_symbolColour, symbolStroke) => {
        const cellSize = 5;
        return draw.pattern(cellSize, cellSize, (add) => add.line(cellSize / 2, 0, cellSize / 2, cellSize)).stroke(symbolStroke);
      },
      "forward-diagonal": (_symbolColour, symbolStroke) => {
        const cellSize = 5;
        return draw.pattern(cellSize, cellSize, (add) => {
          add.line(0, 0, cellSize, cellSize).stroke(symbolStroke);
          add.line(0, 0, cellSize, cellSize).move(0, cellSize).stroke(symbolStroke);
          add.line(0, 0, cellSize, cellSize).move(cellSize, 0).stroke(symbolStroke);
        });
      },
      "backward-diagonal": (_symbolColour, symbolStroke) => {
        const cellSize = 5;
        return draw.pattern(cellSize, cellSize, (add) => {
          add.line(cellSize, 0, 0, cellSize).stroke(symbolStroke);
          add.line(cellSize, 0, 0, cellSize).move(cellSize / 2, cellSize / 2).stroke(symbolStroke);
          add.line(cellSize, 0, 0, cellSize).move(-cellSize / 2, -cellSize / 2).stroke(symbolStroke);
        });
      },
      cross: (_symbolColour, symbolStroke) => {
        const cellSize = 5;
        return draw.pattern(cellSize, cellSize, (add) => {
          add.line(cellSize / 2, 0, cellSize / 2, cellSize).stroke(symbolStroke);
          add.line(0, cellSize / 2, cellSize, cellSize / 2).stroke(symbolStroke);
        });
      },
      "diagonal-cross": (_symbolColour, symbolStroke) => {
        const cellSize = 7;
        return draw.pattern(cellSize, cellSize, (add) => {
          add.line(0, 0, cellSize, cellSize).stroke(symbolStroke);
          add.line(cellSize, 0, 0, cellSize).stroke(symbolStroke);
        });
      }
    };
    const symbolTypes = {
      "simple-marker"() {
        const symbolColour = parseEsriColour(symbol.color);
        symbol.outline = symbol.outline || DEFAULT_OUTLINE;
        const outlineColour = parseEsriColour(symbol.outline.color);
        const outlineStroke = makeStroke({
          color: outlineColour.colour,
          opacity: outlineColour.opacity,
          width: symbol.outline.width,
          // @ts-ignore
          dasharray: ESRI_DASH_MAPS[symbol.outline.style]
        });
        const marker = esriSimpleMarkerSimbol[symbol.style](symbol).fill({
          color: symbolColour.colour,
          opacity: symbolColour.opacity
        }).stroke(outlineStroke).center(_this.CONTAINER_CENTER, _this.CONTAINER_CENTER).rotate(symbol.angle || 0);
        _this.fitInto(marker, _this.CONTENT_SIZE);
      },
      "simple-line"() {
        const lineColour = parseEsriColour(symbol.color);
        const lineStroke = makeStroke({
          color: lineColour.colour,
          opacity: lineColour.opacity,
          width: symbol.width,
          linecap: "butt",
          // @ts-ignore
          dasharray: ESRI_DASH_MAPS[symbol.style]
        });
        const min = _this.CONTENT_PADDING;
        const max = _this.CONTAINER_SIZE - _this.CONTENT_PADDING;
        draw.line(min, min, max, max).stroke(lineStroke);
      },
      // cartographic line style. internet is hinting that it is not supported on JS API
      esriCLS() {
        this["simple-line"]();
      },
      "simple-fill"() {
        const symbolColour = parseEsriColour(symbol.color);
        const symbolStroke = makeStroke({
          color: symbolColour.colour,
          opacity: symbolColour.opacity
        });
        const symbolFill = esriSFSFills[symbol.style](symbolColour, symbolStroke);
        symbol.outline = symbol.outline || DEFAULT_OUTLINE;
        const outlineColour = parseEsriColour(symbol.outline.color);
        const outlineStroke = makeStroke({
          color: outlineColour.colour,
          opacity: outlineColour.opacity,
          width: symbol.outline.width,
          linecap: "butt",
          // @ts-ignore
          dasharray: ESRI_DASH_MAPS[symbol.outline.style]
        });
        draw.rect(_this.CONTENT_SIZE, _this.CONTENT_SIZE).center(_this.CONTAINER_CENTER, _this.CONTAINER_CENTER).fill(symbolFill).stroke(outlineStroke);
      },
      text() {
        console.error("no support for feature service legend of text symbols");
      },
      "picture-fill"() {
        const imageUri = symbol.imageData ? `data:${symbol.contentType};base64,${symbol.imageData}` : symbol.url;
        const imageWidth = symbol.width * symbol.xscale;
        const imageHeight = symbol.height * symbol.yscale;
        symbol.outline = symbol.outline || DEFAULT_OUTLINE;
        const outlineColour = parseEsriColour(symbol.outline.color);
        const outlineStroke = makeStroke({
          color: outlineColour.colour,
          opacity: outlineColour.opacity,
          width: symbol.outline.width,
          // @ts-ignore
          dasharray: ESRI_DASH_MAPS[symbol.outline.style]
        });
        const picturePromise = _this.$iApi.geo.shared.convertImagetoDataURL(imageUri).then((imageUri2) => {
          const symbolFill = draw.pattern(
            imageWidth,
            imageHeight,
            (add) => (
              // there was a 4th argument 'true' here before, but maximum 3 are accepted. may need to look into this
              add.image(imageUri2, imageWidth, imageHeight)
            )
          );
          draw.rect(_this.CONTENT_SIZE, _this.CONTENT_SIZE).center(_this.CONTAINER_CENTER, _this.CONTAINER_CENTER).fill(symbolFill).stroke(outlineStroke);
        });
        return picturePromise;
      },
      "picture-marker"() {
        const sSrc = symbol.source;
        const imageUri = sSrc && sSrc.imageData ? `data:${sSrc.contentType};base64,${sSrc.imageData}` : symbol.url;
        const picturePromise = _this.$iApi.geo.shared.convertImagetoDataURL(imageUri).then((imageUri2) => _this.svgDrawImage(draw, imageUri2)).then(({ image }) => {
          image.center(_this.CONTAINER_CENTER, _this.CONTAINER_CENTER).rotate(symbol.angle || 0);
          _this.fitInto(image, _this.CONTENT_IMAGE_SIZE);
        });
        return picturePromise;
      }
    };
    try {
      await Promise.resolve(symbolTypes[symbol.type]());
      window.document.body.removeChild(container);
      return draw.svg();
    } catch (error) {
      console.error(error);
      return this.generateBlankSymbology();
    }
    function makeStroke(overrides) {
      return Object.assign({}, DEFAULT_STROKE, overrides);
    }
    function parseEsriColour(c) {
      if (c) {
        return {
          colour: `rgb(${c.r},${c.g},${c.b})`,
          opacity: c.a
        };
      } else {
        return {
          colour: "rgb(0, 0, 0)",
          opacity: 0
        };
      }
    }
  }
  /**
   * Renders a specified image on an svg element. This is a helper function that wraps around async `draw.image` call in the svg library.
   *
   * @function svgDrawImage
   * @private
   * @param {Object} draw svg element to render the image onto
   * @param {String} imageUri image url or dataURL of the image to render
   * @param {Number} width [optional = 0] width of the image
   * @param {Number} height [optional = 0] height of the image
   * @param {Boolean} crossOrigin [optional = true] specifies if the image should be loaded as crossOrigin
   * @return {Promise} promise resolving with the loaded image and its loader object (see svg.js http://documentup.com/wout/svg.js#image for details)
   */
  async svgDrawImage(draw, imageUri, width = 0, height = 0, crossOrigin = true) {
    return new Promise((resolve, reject) => {
      const image = draw.image(imageUri, width, height, crossOrigin).loaded((loader) => resolve({ image, loader })).error((err) => {
        reject(err);
        console.error(err);
      });
    });
  }
  /**
   * Fits svg element in the size specified
   * @param {Object} element svg element to fit
   * @param {Number} CONTAINER_SIZE width/height of a container to fit the element into
   */
  fitInto(element, CONTAINER_SIZE) {
    const elementRbox = element.node.getBoundingClientRect();
    const scale = CONTAINER_SIZE / Math.max(elementRbox.width, elementRbox.height);
    if (scale < 1) {
      element.scale(scale);
    }
  }
  /**
   * Generate a legend object based on an ESRI renderer.
   *
   * @param  {Object} renderer an ESRI renderer object in server JSON form
   * @return {Array} list of legend symbologies
   */
  rendererToLegend(renderer) {
    let finalSymbols;
    const allRendererSUs = renderer.symbolUnits.slice(0);
    if (renderer.defaultUnit) {
      allRendererSUs.push(renderer.defaultUnit);
    }
    if (renderer.falseRenderer) {
      finalSymbols = allRendererSUs.map((rsu) => [rsu]);
    } else {
      const legendCollater = /* @__PURE__ */ new Map();
      allRendererSUs.forEach((su) => {
        const lblArray = legendCollater.get(su.label);
        if (lblArray) {
          lblArray.push(su);
        } else {
          legendCollater.set(su.label, [su]);
        }
      });
      finalSymbols = [];
      legendCollater.forEach((lblArray) => finalSymbols.push(lblArray));
    }
    return finalSymbols.map((suSet) => {
      const firstSu = suSet[0];
      const legendSym = {
        uid: this.$iApi.geo.shared.generateUUID(),
        label: firstSu.label || "",
        definitionClause: suSet.length === 1 ? firstSu.definitionClause : `(${suSet.map((su) => su.definitionClause).join(" OR ")})`,
        svgcode: "",
        // TODO is '' ok? maybe we need white square svg? or some loading icon?
        esriStandard: true,
        // is ESRI standard symbology
        visibility: true,
        lastVisbility: true,
        drawPromise: this.symbolToSvg(firstSu.symbol).then((svg) => {
          legendSym.svgcode = svg;
          suSet.forEach((su) => {
            su.svgCode = svg;
          });
        })
      };
      return legendSym;
    });
  }
  /**
   * Returns the legend information of an ESRI map service.
   *
   * @function getMapServerLegend
   * @private
   * @param  {String} layerUrl service url (root service, not indexed endpoint)
   * @returns {Promise} resolves in an array of legend data in arcgis server json format
   *
   */
  async getMapServerLegend(layerUrl) {
    if (!layerUrl) {
      throw new Error("Legend server request is missing the required url.");
    }
    const reqParams = {
      query: { f: "json" }
    };
    const fakeData = { layers: [] };
    const [err, serviceResult] = await to(EsriRequest(`${layerUrl}/legend`, reqParams));
    if (!serviceResult) {
      console.error(`Error loading legend for ${layerUrl}`, err);
      return fakeData;
    }
    if (!serviceResult.data) {
      console.error(`Error loading legend data for ${layerUrl}`);
      return fakeData;
    }
    return serviceResult.data;
  }
  /**
   * Our symbology engine works off of renderers. When dealing with layers with no renderers,
   * we need to take server-side legend and convert it to a fake renderer, which lets us
   * leverage all the existing symbology code.
   *
   * @function mapServerLegendToRenderer
   * @private
   * @param {Object} serverLegend legend json from an esri map server
   * @param {Integer} layerIndex  the index of the layer in the legend we are interested in
   * @returns {Object} a fake unique value renderer based off the legend
   *
   */
  mapServerLegendToRenderer(serverLegend, layerIndex) {
    const layerLegend = serverLegend.layers.find((l) => {
      return l.layerId === layerIndex;
    });
    let renderer;
    if (typeof layerLegend !== "undefined") {
      renderer = {
        type: "uniqueValue",
        field: "fakefield",
        uniqueValueInfos: layerLegend.legend.map((ll) => {
          return {
            label: ll.label,
            value: ll.label,
            symbol: {
              type: "esriPMS",
              imageData: ll.imageData,
              contentType: ll.contentType
            }
          };
        })
      };
      return this.makeRenderer(fromJSON$1(renderer), [], true);
    } else {
      throw new Error("attempted to make renderer from non-existing legend data");
    }
  }
  /**
   * Our symbology engine works off of renderers. When dealing with layers with no renderers,
   * we need to take server-side legend and convert it to a fake renderer, which lets us
   * leverage all the existing symbology code.
   *
   * Same as mapServerLegendToRenderer function but combines all layer renderers.
   *
   * @function mapServerLegendToRendererAll
   * @private
   * @param {Object} serverLegend legend json from an esri map server
   * @returns {Object} a fake unique value renderer based off the legend
   */
  mapServerLegendToRendererAll(serverLegend) {
    const layerRenders = serverLegend.layers.map(
      (layer) => layer.legend.map((layerLegend) => ({
        label: layerLegend.label,
        value: layerLegend.label,
        symbol: {
          type: "esriPMS",
          imageData: layerLegend.imageData,
          contentType: layerLegend.contentType
        }
      }))
    );
    const fullRenderer = {
      type: "uniqueValue",
      field1: "fakefield",
      uniqueValueInfos: [].concat(...layerRenders)
    };
    return this.makeRenderer(fromJSON$1(fullRenderer), [], true);
  }
  /**
   * Orchestrator function that will:
   * - Fetch a legend from an esri map server
   * - Extract legend for a specific sub layer
   * - Convert server legend to a temporary renderer
   * - Convert temporary renderer to a viewer-formatted legend (return value)
   *
   * @function mapServerToLocalLegend
   * @param {String}    mapServerUrl  service url (root service, not indexed endpoint)
   * @param {Integer}   [layerIndex]  the index of the layer in the legend we are interested in. If not provided, all layers will be collapsed into a single legend
   * @returns {Promise} resolves in a viewer-compatible legend for the given server and layer index
   *
   */
  async mapServerToLocalLegend(mapServerUrl, layerIndex = void 0) {
    const serverLegendData = await this.getMapServerLegend(mapServerUrl);
    let fakeRenderer;
    let intIndex;
    if (typeof layerIndex === "undefined") {
      intIndex = 0;
      fakeRenderer = this.mapServerLegendToRendererAll(serverLegendData);
    } else {
      intIndex = parseInt(layerIndex);
      fakeRenderer = this.mapServerLegendToRenderer(serverLegendData, intIndex);
    }
    return this.rendererToLegend(fakeRenderer);
  }
}

class QueryAPI extends APIScope {
  constructor(iApi) {
    super(iApi);
  }
  /**
   * Gets an array of OIDs from an arcgis server feature source that satisfy a query
   *
   * @param options contains properties that define the query and specificy request particulars.
   * @returns resolves with array of object ids.
   */
  async arcGisServerQueryIds(options) {
    if (!(options.filterGeometry || options.filterSql)) {
      console.error("arcGisServerQueryIds called without any filter");
      return [];
    }
    const query = new EsriQuery();
    query.returnGeometry = false;
    if (options.filterSql) {
      query.where = options.filterSql;
    }
    if (options.filterGeometry) {
      query.geometry = await this.queryGeometryHelper(
        options.filterGeometry,
        false,
        this.$iApi.geo.map.getScale(),
        options.sourceSR
      );
      query.spatialRelationship = "intersects";
    }
    const oids = await executeForIds(options.url, query);
    return Array.isArray(oids) ? oids : [];
  }
  /**
   * Gets an array of graphics from a locally stored feature layer (file, geojson) that satisfy a query
   *
   * @param options contains properties that define the query and specificy request particulars.
   * @returns resolves with array of graphic result objects.
   */
  async geoJsonQuery(options) {
    const query = new EsriQuery();
    query.returnGeometry = !!options.includeGeometry;
    query.outFields = ["*"];
    if (options.filterGeometry) {
      query.geometry = await this.queryGeometryHelper(options.filterGeometry, true);
      query.spatialRelationship = "intersects";
    }
    if (options.filterSql) {
      query.where = options.filterSql;
    }
    if (options.filterOIDs) {
      query.objectIds = options.filterOIDs;
    }
    await options.layer.loadPromise();
    if (!options.layer.esriLayer) {
      throw new Error("file layer being queried contains no ESRI layer");
    }
    const featSet = await options.layer.esriLayer.queryFeatures(query);
    return featSet.features.map((f, i) => {
      let geom;
      if (query.returnGeometry) {
        geom = this.$iApi.geo.geom.geomEsriToRamp(f.geometry, `queryResult${i}`);
      } else {
        geom = new NoGeometry();
      }
      return new Graphic(geom, "", f.attributes);
    });
  }
  /**
   * Helper function to modify input geometries for queries. Will attempt to avoid various pitfalls,
   * usually around projections
   *
   * @private
   * @param {BaseGeometry} geometry the geometry to be used in a query as a filter
   * @param {Boolean} isFileLayer true if layer is not tied to an arcgis server
   * @param {Integer} [mapScale] optional scale value of the map to help detect problem situations
   * @param {SpatialReference} [sourceSR] optional spatial reference of the layer being queried to help detect problem situations
   * @return {Promise<Geometry>} resolves the input geometry in the most appropriate form based on the inputs
   */
  async queryGeometryHelper(geometry, isFileLayer, mapScale, sourceSR) {
    if (!isFileLayer && geometry.type === GeometryType.EXTENT && sourceSR && !sourceSR.isEqual(geometry.sr) && !(mapScale && mapScale > 2e7 && geometry.sr.wkid === 3978 && sourceSR.wkid === 4326)) {
      const rampWarpedExtent = await this.$iApi.geo.proj.projectExtent(sourceSR, geometry);
      return rampWarpedExtent.toESRI();
    } else {
      return geometry.toESRI();
    }
  }
  /**
   * Create an extent centered around a point, that is appropriate for the current map scale.
   *
   * @function makeClickBuffer
   * @param {Point} point         point on the map for extent center
   * @param {Integer} tolerance   optional. distance in pixels from mouse point that qualifies as a hit. default is 5
   * @return {Extent} an extent of desired size and location
   */
  makeClickBuffer(point, tolerance = 5) {
    const map = this.$iApi.geo.map;
    const mapExt = map.getExtent();
    const buffSize = tolerance * (mapExt.xmax - mapExt.xmin) / map.getPixelWidth();
    return new Extent(
      "ze_buffer",
      [point.x - buffSize, point.y - buffSize],
      [point.x + buffSize, point.y + buffSize],
      point.sr
    );
  }
}

class GeoAPI extends APIScope {
  attributes;
  geom;
  layer;
  map;
  proj;
  query;
  shared;
  symbology;
  /**
   * @constructor
   * @param {InstanceAPI} iApi the RAMP instance
   */
  constructor(iApi) {
    super(iApi);
    this.geom = geo.geom;
    this.proj = geo.proj;
    this.shared = geo.sharedUtils;
    this.map = new MapAPI(iApi);
    this.layer = new LayerAPI(iApi);
    this.attributes = new AttributeAPI(iApi);
    this.query = new QueryAPI(iApi);
    this.symbology = new SymbologyAPI(iApi);
    if (!Array.isArray(EsriConfig.request.interceptors)) {
      EsriConfig.request.interceptors = [];
    }
    EsriConfig.request.interceptors.push({
      before: (prams) => {
        if (prams.url.includes("?blankTile=false")) {
          prams.url = prams.url.replace("?blankTile=false", "?blankTile=true");
        }
      }
    });
  }
  /**
   * Set a proxy service to allow consumption of cross-domain non-CORS resources.
   *
   * @param {string} proxyUrl Url to proxy or empty string to clear. Must be relative url on host domain, or full url to CORS supported server
   */
  set proxy(proxyUrl) {
    EsriConfig.request.proxyUrl = proxyUrl;
  }
  /**
   * Read the current proxy setting, returns url string, empty string if no proxy
   */
  get proxy() {
    return EsriConfig.request.proxyUrl || "";
  }
}

const fixtureModules = /* #__PURE__ */ Object.assign({"../fixtures/appbar/index.ts": () => Promise.resolve().then(() => index$t),"../fixtures/areas-of-interest/index.ts": () => Promise.resolve().then(() => index$s),"../fixtures/basemap/index.ts": () => Promise.resolve().then(() => index$r),"../fixtures/crosshairs/index.ts": () => Promise.resolve().then(() => index$q),"../fixtures/details/index.ts": () => Promise.resolve().then(() => index$p),"../fixtures/export-footnote/index.ts": () => Promise.resolve().then(() => index$o),"../fixtures/export-legend/index.ts": () => Promise.resolve().then(() => index$n),"../fixtures/export-map/index.ts": () => Promise.resolve().then(() => index$m),"../fixtures/export-northarrow/index.ts": () => Promise.resolve().then(() => index$l),"../fixtures/export-scalebar/index.ts": () => Promise.resolve().then(() => index$k),"../fixtures/export-timestamp/index.ts": () => Promise.resolve().then(() => index$j),"../fixtures/export-title/index.ts": () => Promise.resolve().then(() => index$i),"../fixtures/export/index.ts": () => Promise.resolve().then(() => index$h),"../fixtures/extentguard/index.ts": () => Promise.resolve().then(() => index$g),"../fixtures/gazebo/index.ts": () => Promise.resolve().then(() => index$f),"../fixtures/geosearch/index.ts": () => Promise.resolve().then(() => index$e),"../fixtures/grid/index.ts": () => Promise.resolve().then(() => index$d),"../fixtures/help/index.ts": () => Promise.resolve().then(() => index$c),"../fixtures/hilight/index.ts": () => Promise.resolve().then(() => index$b),"../fixtures/layer-reorder/index.ts": () => Promise.resolve().then(() => index$a),"../fixtures/legend/index.ts": () => Promise.resolve().then(() => index$9),"../fixtures/mapnav/index.ts": () => Promise.resolve().then(() => index$8),"../fixtures/metadata/index.ts": () => Promise.resolve().then(() => index$7),"../fixtures/northarrow/index.ts": () => Promise.resolve().then(() => index$6),"../fixtures/overviewmap/index.ts": () => Promise.resolve().then(() => index$5),"../fixtures/panguard/index.ts": () => Promise.resolve().then(() => index$4),"../fixtures/scrollguard/index.ts": () => Promise.resolve().then(() => index$3),"../fixtures/settings/index.ts": () => Promise.resolve().then(() => index$2),"../fixtures/snowman/index.ts": () => Promise.resolve().then(() => index$1),"../fixtures/wizard/index.ts": () => Promise.resolve().then(() => index)});
class FixtureAPI extends APIScope {
  /**
   * Creates an instance of FixtureAPI.
   *
   * @param {InstanceAPI} iApi
   * @memberof FixtureAPI
   */
  constructor(iApi) {
    super(iApi);
  }
  /**
   * Returns whether a given fixture exists.
   *
   * @param {string} id the fixture ID to be checked
   * @returns {boolean} whether the fixture identified by 'id' exists
   * @memberof FixtureAPI
   */
  exists(id) {
    return id in useFixtureStore(this.$vApp.$pinia).items;
  }
  /**
   * Loads a (built-in) fixture or adds supplied fixture into the R4MP Vue instance.
   *
   * @param {string} id
   * @param {IFixtureBase} [constructor]
   * @returns {Promise<FixtureBase>}
   * @memberof FixtureAPI
   */
  // TODO: implement overload to add a list of features
  async add(id, constructor) {
    let fixture;
    if (id in useFixtureStore(this.$vApp.$pinia).items) {
      return this.get(id);
    }
    if (constructor) {
      if (typeof constructor !== "function") {
        throw new Error("malformed fixture constructor");
      }
      fixture = FixtureInstance.updateBaseToInstance(new constructor(), id, this.$iApi);
    } else {
      const instanceConstructor = (await fixtureModules[`../fixtures/${id}/index.ts`]()).default;
      fixture = new instanceConstructor(id, this.$iApi);
    }
    useFixtureStore(this.$vApp.$pinia).addFixture(fixture);
    this.$iApi.event.emit(GlobalEvents.FIXTURE_ADDED, fixture);
    if (this.$iApi.geo.map.created) fixture.initialized?.();
    return fixture;
  }
  /**
   * Removes the specified fixture from R4MP instance.
   *
   * @template T
   * @param {(FixtureBase | string)} fixtureOrId
   * @returns {T}
   * @memberof FixtureAPI
   */
  remove(fixtureOrId) {
    const fixture = this.get(fixtureOrId);
    if (!fixture) {
      throw new Error(`Could not find fixture ${fixtureOrId} for removal`);
    }
    useFixtureStore(this.$vApp.$pinia).removeFixture(fixture);
    this.$iApi.event.emit(GlobalEvents.FIXTURE_REMOVED, fixture);
    return fixture;
  }
  // See https://github.com/ramp4-pcar4/ramp4-pcar4/issues/2296#issuecomment-2262964384 for background of flush and restore.
  /**
   * Remove every fixture whose persist flag is set to false from the R4MP instance.
   * For all other fixtures, simply call their removed hook.
   */
  flush() {
    const fixtureStore = useFixtureStore(this.$vApp.$pinia);
    const fixtureIds = Object.keys(fixtureStore.items);
    fixtureIds.forEach((id) => {
      const fixture = this.get(id);
      if (fixture?.persist && typeof fixture?.removed === "function") {
        fixture.removed();
      } else if (fixture) {
        this.remove(id);
      }
    });
  }
  /**
   * Restores every remaining fixture by calling its added/initialized hooks.
   */
  restore() {
    const fixtureStore = useFixtureStore(this.$vApp.$pinia);
    const fixtureIds = Object.keys(fixtureStore.items);
    fixtureIds.forEach((id) => {
      const fixture = fixtureStore.items[id];
      if (typeof fixture.added === "function") {
        fixture.added();
      }
      if (this.$iApi.geo.map.created && typeof fixture.initialized === "function") {
        fixture.initialized();
      }
    });
  }
  get(item) {
    const ids = [];
    if (typeof item === "string") {
      ids.push(item);
    } else if (Array.isArray(item)) {
      ids.push(...item);
    } else {
      ids.push(item.id);
    }
    const fixtures = ids.map((id) => {
      const fixture = useFixtureStore(this.$vApp.$pinia).items[id];
      if (!fixture) {
        return void 0;
      }
      return fixture;
    });
    return fixtures.length === 1 ? fixtures[0] : fixtures;
  }
  /**
   * Provides a promise that resolves when the fixture(s) have finished loading.
   *
   * @param {(string | string[])} fixtureId the fixture ID(s) for which the promise is requested
   * @memberof FixtureAPI
   */
  isLoaded(fixtureId) {
    const fixtureStore = useFixtureStore(this.$vApp.$pinia);
    const idsToCheck = Array.isArray(fixtureId) ? fixtureId : [fixtureId];
    idsToCheck.forEach((id) => {
      if (fixtureStore.loadPromises[id] === void 0) {
        fixtureStore.addLoadPromise(id);
      }
    });
    const proms = fixtureStore.getLoadPromises(idsToCheck);
    return Array.isArray(fixtureId) ? Promise.all(proms) : proms[0];
  }
  /**
   * Loads the set of standard, built-in fixtures to the R4MP Vue instance.
   * This will quickly set up the vanilla version of RAMP.
   * Note this function is automatically run by the instance startup unless the loadDefaultFixtures option is
   * set to false. The function is exposed to allow custom pages the ability to call it at a different point
   * in the startup. Also, a subset of standard fixtures can be provided on the optional parameter if one
   * wishes to omit some of the standard fixtures.
   *
   * @param {Array<string>} [fixtureNames] list of built-in fixtures names to add. omission means all built-in fixtures will be added
   * @returns {Promise<Array<FixtureBase>>} resolves with array of default fixtures
   * @memberof FixtureAPI
   */
  addDefaultFixtures(fixtureNames) {
    if (!Array.isArray(fixtureNames) || fixtureNames.length === 0) {
      fixtureNames = [
        "appbar",
        "basemap",
        "crosshairs",
        "details",
        "geosearch",
        "grid",
        "help",
        "hilight",
        "layer-reorder",
        "legend",
        "mapnav",
        "northarrow",
        "overviewmap",
        "panguard",
        "scrollguard",
        "settings",
        "wizard"
      ];
    }
    const configStore = useConfigStore(this.$vApp.$pinia);
    configStore.startingFixtures = fixtureNames;
    return Promise.all(fixtureNames.map((fn) => this.add(fn)));
  }
}
class FixtureInstance extends APIScope {
  /**
   * Adds missing functions and properties to the object implementing FixtureBase interface.
   * This is only needed for external fixtures as they can't inherit from FixtureInstance.
   *
   * TODO: If you know a better way to deep-mixin props/getters/functions from a class into another class instance, please tell me. I honestly don't know 🤷‍♂️.
   *
   * @static
   * @param {FixtureBase} value
   * @param {string} id
   * @param {InstanceAPI} $iApi
   * @returns {FixtureInstance}
   * @memberof FixtureInstance
   */
  static updateBaseToInstance(rawFixture, id, $iApi) {
    const instance = new FixtureInstance(id, $iApi);
    Object.defineProperties(rawFixture, {
      id: { value: id },
      $iApi: { value: $iApi },
      persist: { value: rawFixture.persist ?? true },
      $vApp: {
        get() {
          return instance.$vApp;
        }
      },
      remove: { value: instance.remove },
      extend: { value: instance.extend },
      config: {
        get() {
          return instance.config;
        }
      },
      mount: { value: instance.mount }
    });
    return rawFixture;
  }
  /**
   * ID of this fixture.
   *
   * @type {string}
   * @memberof FixtureInstance
   */
  id;
  persist;
  /**
   * Creates an instance of FixtureInstance.
   *
   * @param {string} id
   * @param {InstanceAPI} iApi
   * @memberof FixtureInstance
   */
  constructor(id, iApi) {
    super(iApi);
    this.id = id;
    this.persist = true;
  }
  /**
   * Removes the specified fixture from R4MP instance.
   * This is a proxy to `rInstance.fixture.remove(...)`.
   *
   * @returns {this}
   * @memberof FixtureInstance
   */
  remove() {
    this.$iApi.fixture.remove(this);
    return this;
  }
  /**
   * A helper function to create a "subclass" of the base Vue constructor
   *
   * @param {VueConstructor<Vue>} vueComponent
   * @param {ComponentOptions<Vue>} [options={}]
   * @returns {Vue}
   * @memberof FixtureInstance
   */
  extend(vueComponent, options = {}) {
    const component = defineComponent({
      extends: vueComponent,
      iApi: this.$iApi,
      data() {
        return {
          ...options
        };
      }
    });
    const componentApp = createApp$1(component);
    const { el } = this.mount(component, {
      props: { ...options.propsData },
      app: componentApp
    });
    return el;
  }
  /**
   * Helper with programatically creating a component in Vue 3 (replaces the deprecated Vue.extend)
   *
   * @param {Component} component
   * @param {object} props
   * @param {any} children
   * @param {HTMLElement} element
   * @param {App} app
   * @returns {VNode, function, HTMLElement}
   * @memberof FixtureInstance
   */
  mount(component, { props, children, element, app } = {}) {
    let el = element;
    let vNode = h(component, props, children);
    if (app && app._context) {
      vNode.appContext = app._context;
    }
    el ? render(vNode, el) : render(vNode, el = document.createElement("div"));
    const destroy = () => {
      if (el) {
        render(null, el);
      }
      el = null;
      vNode = null;
    };
    return { vNode, destroy, el };
  }
  /**
   * Returns the fixture config section (JSON) taken from the global config.
   *
   * @readonly
   * @type {*}
   * @memberof FixtureInstance
   */
  get config() {
    const configStore = useConfigStore(this.$vApp.$pinia);
    return configStore.config.fixtures[this.id];
  }
  /**
   * Get this fixture's config from the layer config with the given layer id
   * Will return `undefined` if layer config did not specify a config for this fixture
   *
   * @param {string} layerId The layer's id
   * @returns {any} This fixture's config for the given layer
   */
  getLayerFixtureConfig(layerId) {
    const fixtureConfigs = this.getLayerFixtureConfigs();
    return fixtureConfigs[layerId];
  }
  /**
   * Combines this fixtures configs from layer configs into an indexed-dictionary
   *
   * @returns {{ [layerId: string]: any }} Dictionary where key is the layer id and the value is this fixture's config for that layer
   */
  getLayerFixtureConfigs() {
    const fixtureConfigs = {};
    const layerCrawler = (layer, parent = void 0) => {
      if (layer.fixtures && layer.fixtures[this.id] !== void 0) {
        let layerId = layer.id;
        if (parent !== void 0) {
          layerId = `${parent.id}-${layer.index}`;
        }
        fixtureConfigs[layerId] = layer.fixtures[this.id];
      }
      if (layer.sublayers) {
        layer.sublayers.forEach((sublayer) => layerCrawler(sublayer, layer));
      }
    };
    this.$iApi.geo.layer.allLayers().forEach((layer) => layerCrawler(layer.config));
    return fixtureConfigs;
  }
  /**
   * If the `panelWidth` property is provided, handle default and specified panel widths for the given fixture.
   *
   * @param {Array<string>} panels list of panel names for the calling fixture
   */
  handlePanelWidths(panels) {
    if (this.config?.panelWidth) {
      const panelWidths = {};
      if (typeof this.config?.panelWidth == "number") {
        this.config.panelWidth = {
          default: this.config?.panelWidth
        };
      }
      if (this.config.panelWidth.default) {
        panels.forEach((item) => {
          panelWidths[item] = this.config.panelWidth.default;
        });
      }
      for (const item in this.config.panelWidth) {
        if (item == "default") continue;
        panelWidths[item] = this.config.panelWidth[item];
      }
      for (const item in panelWidths) {
        const panel = this.$iApi.panel.get(item);
        this.$iApi.panel.setStyle(panel, {
          "flex-basis": `${panelWidths[item]}px`
        });
      }
    }
  }
  /**
   * If the `panelTeleport` property is provided, handle specified panelTeleport for the given fixture.
   *
   * @param {Array<string>} panels list of panel names for the calling fixture
   */
  handlePanelTeleports(panels) {
    if (this.config?.panelTeleport) {
      const panelStore = usePanelStore(this.$vApp.$pinia);
      const oneConfig = !!this.config.panelTeleport.target;
      panels.forEach((p) => {
        panelStore.items[p].teleport = oneConfig ? this.config.panelTeleport : this.config.panelTeleport[p];
        panelStore.items[p].style.width = "100%";
      });
    }
  }
}

class PanelAPI extends APIScope {
  panelStore = usePanelStore(this.$vApp.$pinia);
  /** Updates the content of a specific HTML-based screen of a panel, using HTML content
   *
   * @param {PanelInstance | string} panel The `PanelInstance` object, or its respective id, that corresponds to
   * the panel whose content is to be updated.
   * @param {{ [key: string]: string | HTMLElement }} html keyed language object containing HTML content for each
   * language, represented as an HTMLElement object or a string.
   * @param {string} [screenId] id of the screen to be updated. If not provided, it will update the first screen in the panel
   * @memberof PanelAPI
   */
  updateHTML(panel, html, screenId) {
    const panelInstance = this.get(panel);
    const screen = screenId ? panelInstance.screens[screenId] : Object.values(panelInstance.screens)[0];
    if (isHTMLScreen(screen)) {
      for (const lang in html) {
        screen[lang].innerHTML = html[lang] instanceof HTMLElement ? html[lang].outerHTML : html[lang];
      }
    } else {
      console.error("Screen must be an HTML object");
    }
  }
  /**
   * Helper for `registerHTML()`. Creates and returns the `PanelConfigSet` required to register the HTML panel
   *
   * @param {HTMLPanelInstance} htmlPanel a `HTMLPanelInstance` object, excluding its `options` (if it exists), corresponding
   * to the new html panel
   * @returns {PanelConfigSet} The `PanelConfigSet` corresponding to the panel that is to be created
   * @memberof PanelAPI
   */
  registerHTMLConfig(htmlPanel) {
    for (const lang in htmlPanel.content) {
      if (typeof htmlPanel.content[lang] === "string") {
        const newHtml = document.createElement("div");
        newHtml.innerHTML = htmlPanel.content[lang];
        htmlPanel.content[lang] = newHtml;
      }
    }
    const panelConfig = {};
    panelConfig[htmlPanel.id] = {
      screens: {},
      style: htmlPanel.style ?? {
        width: "350px"
      },
      alertName: htmlPanel.alertName
    };
    panelConfig[htmlPanel.id].screens[htmlPanel.id] = htmlPanel.content;
    return panelConfig;
  }
  /** Registers a new panel containing a screen of HTML content and returns the PanelInstance
   *
   * @param {HTMLPanelInstance} htmlPanel a HTMLPanelInstance object corresponding to the new html panel
   * @memberof PanelAPI
   */
  registerHTML(htmlPanel) {
    const existingPanel = this.get(htmlPanel.id);
    if (existingPanel) {
      console.error("panel already exist");
      return existingPanel;
    }
    const panelConfig = this.registerHTMLConfig(htmlPanel);
    const panel = this.register(panelConfig, htmlPanel.options);
    return panel;
  }
  register(value, options) {
    const panelConfigs = isPanelConfigPair(value) ? { [value.id]: value.config } : value;
    if (options) {
      const i18n = options.i18n || {};
      const $i18n = this.$iApi.$i18n;
      Object.entries(i18n.messages || {}).forEach((value2) => $i18n.mergeLocaleMessage(...value2));
      Object.entries(i18n.dateTimeFormats || {}).forEach((value2) => $i18n.mergeDateTimeFormat(...value2));
      Object.entries(i18n.numberFormats || {}).forEach((value2) => $i18n.mergeNumberFormat(...value2));
    }
    const panels = Object.entries(panelConfigs).reduce((map, [id, config]) => {
      map.push(new PanelInstance(this.$iApi, id, config));
      return map;
    }, []);
    panels.forEach((panel) => this.panelStore.registerPanel(panel));
    if (panels.length === 1) {
      return panels[0];
    } else {
      return panels.reduce((map, panel) => {
        map[panel.id] = panel;
        return map;
      }, {});
    }
  }
  /**
   * Provides a promise that resolves when the panel(s) have finished registration.
   *
   * @param {(string | string[])} panelId the panel ID(s) for which the promise is requested
   * @memberof PanelAPI
   */
  async isRegistered(panelId) {
    const idsToCheck = Array.isArray(panelId) ? panelId : [panelId];
    idsToCheck.forEach((id) => {
      if (this.panelStore.regPromises[id] === void 0) {
        this.panelStore.addRegPromise(id);
      }
    });
    const proms = this.panelStore.getRegPromises(idsToCheck);
    return Array.isArray(panelId) ? Promise.all(proms) : proms[0];
  }
  /**
   * Removes a panel instance
   *
   * @param {(string | PanelInstance)} value
   * @memberof PanelAPI
   */
  remove(value) {
    const panel = this.get(value);
    if (!panel) {
      return;
    }
    if (panel.isOpen) {
      this.close(panel);
    }
    this.panelStore.removePanel(panel);
  }
  /**
   * Finds and returns a panel with the id specified.
   *
   * @param {(string | PanelInstance)} value
   * @returns {PanelInstance}
   * @memberof PanelAPI
   */
  // TODO: implement overload to get a list of panels, similar to `feature.get([...])`
  get(value) {
    const id = typeof value === "string" ? value : value.id;
    return this.panelStore.items[id];
  }
  /**
   * Opens a registered panel in the panel stack.
   *
   *  - `rInstance.panel.open('panel-id')` -- opens the 'panel-id' panel on the first screen in the set
   *  - `rInstance.panel.open(<PanelInstance>)` -- opens the provided `PanelInstance` object on the first screen in the set
   *  - `rInstance.panel.open({ id: 'panel-id', screen: 'screen-id' })` -- opens the 'panel-id' panel on the 'screen-id' screen
   *  - `rInstance.panel.open({ id: 'panel-id', screen: 'screen-id', props: {... } })` -- opens the 'panel-id' panel on the 'screen-id' screen passing supplied `props` to it
   *
   * @param {(string | PanelInstance | PanelInstancePath)} value a panel id, a `PanelInstance` object or an object of the form `{ id: <panel-id>, screen: <id>, props: <object> }`.
   * @returns {PanelInstance | undefined} the panel instance if the panel is currently registered, undefined otherwise.
   * @memberof PanelAPI
   */
  open(value) {
    let panel, screen, props;
    if (typeof value === "string" || value instanceof PanelInstance) {
      panel = this.get(value);
    } else {
      panel = this.get(value.id);
      ({ screen, props } = value);
    }
    if (!panel) {
      return panel;
    }
    if (panel.isOpen && !panel.isVisible) {
      panel.minimize();
    } else if (panel.isOpen) {
      return panel;
    }
    if (!screen) {
      if (panel.route && !props) {
        ({ screen, props } = panel.route);
      } else {
        screen = Object.keys(panel.screens).pop();
      }
    }
    if (this.show(panel, { screen, props })) {
      this.panelStore.openPanel(panel);
      this.$iApi.updateAlert(
        this.$iApi.$i18n.t(`panels.alert.open`, {
          name: panel.alertName ? this.$iApi.$i18n.t(panel.alertName) : panel.id
        })
      );
      this.$iApi.event.emit(GlobalEvents.PANEL_OPENED, panel);
    } else {
      console.error(`Failed to open ${panel.id} panel.`);
    }
    return panel;
  }
  /**
   * Returns an array of open `PanelInstance` objects.
   *
   * @readonly
   * @type {PanelInstance[]}
   * @memberof PanelAPI
   */
  get opened() {
    return this.panelStore.orderedItems.concat(this.panelStore.teleported);
  }
  /**
   * Returns an array of visible `PanelInstance` object.
   * This is not every *open* panel, only the ones currently visible to the user.
   *
   * @readonly
   * @type {PanelInstance[]}
   * @memberof PanelAPI
   */
  get visible() {
    return this.panelStore.visible.concat(this.panelStore.teleported);
  }
  /**
   * Closes the panel specified.
   *
   * @param {(string | PanelInstance)} value
   * @returns {PanelInstance | undefined} the panel instance if the panel is currently registered, undefined otherwise.
   * @memberof PanelAPI
   */
  close(value) {
    const panel = this.get(value);
    if (!panel) {
      return panel;
    }
    if (panel.isPinned) {
      panel.pin(false);
    }
    this.panelStore.closePanel(panel);
    this.$iApi.updateAlert(
      this.$iApi.$i18n.t(`panels.alert.close`, {
        name: panel.alertName ? this.$iApi.$i18n.t(panel.alertName) : panel.id
      })
    );
    this.$iApi.event.emit(GlobalEvents.PANEL_CLOSED, panel);
    return panel;
  }
  /**
   * Minimizes the panel specified, mechanically the same as closing however it does not emit the close event so that temporary appbar buttons stay.
   *
   * @param {(string | PanelInstance)} value
   * @returns {PanelInstance | undefined} the panel instance if the panel is currently registered, undefined otherwise.
   * @memberof PanelAPI
   */
  minimize(value) {
    const panel = this.get(value);
    if (!panel) {
      return panel;
    }
    if (panel.isPinned) {
      panel.pin(false);
    }
    this.panelStore.closePanel(panel);
    this.$iApi.updateAlert(
      this.$iApi.$i18n.t(`panels.alert.minimize`, {
        name: panel.alertName ? this.$iApi.$i18n.t(panel.alertName) : panel.id
      })
    );
    this.$iApi.event.emit(GlobalEvents.PANEL_MINIMIZED, panel);
    return panel;
  }
  /**
   * Moves the specifed visible panel to the left or right.
   *
   * @param {(string | PanelInstance)} value
   * @param {PanelDirection} direction the direction of movement, either "left" or "right".
   * @returns {PanelInstance | undefined} the panel instance if the panel is currently registered, undefined otherwise.
   * @memberof PanelAPI
   */
  move(value, direction) {
    const panel = this.get(value);
    if (!panel) {
      return panel;
    }
    this.panelStore.movePanel(panel, direction);
    return panel;
  }
  /**
   * Toggle panel.
   *
   * @param {string | PanelInstance | PanelInstancePath} [value]
   * @param {boolean} toggle Optional param. True forces a panel open, false forces the panel to close.
   * @returns {PanelInstance | undefined} the panel instance if the panel is currently registered, undefined otherwise.
   * @memberof PanelAPI
   */
  toggle(value, toggle) {
    let panel;
    if (typeof value === "string" || value instanceof PanelInstance) {
      panel = this.get(value);
    } else {
      panel = this.get(value.id);
    }
    if (!panel) {
      return panel;
    }
    toggle = typeof toggle !== "undefined" ? toggle : !panel.isVisible;
    if (toggle !== panel.isVisible) {
      toggle ? this.open(value) : this.close(panel);
    }
    return panel;
  }
  /**
   * Toggle panel's minimized state
   *
   * @param {string | PanelInstance | PanelInstancePath} [value]
   * @param {boolean} toggle Optional param. True forces a panel open, false forces the panel to minimize.
   * @returns {PanelInstance | undefined} the panel instance if the panel is currently registered, undefined otherwise.
   * @memberof PanelAPI
   */
  toggleMinimize(value, toggle) {
    let panel;
    if (typeof value === "string" || value instanceof PanelInstance) {
      panel = this.get(value);
    } else {
      panel = this.get(value.id);
    }
    if (!panel) {
      return panel;
    }
    toggle = typeof toggle !== "undefined" ? toggle : !panel.isVisible;
    if (toggle !== panel.isVisible) {
      toggle ? this.open(panel) : this.minimize(panel);
    }
    return panel;
  }
  /**
   * Pin/unpin/toggle (if no value provided) pin status of the provided panel. When pinning, automatically unpins any previous pinned panel if exists.
   *
   * @param {(string | PanelInstance)} value
   * @param {boolean} [pin]
   * @returns {PanelInstance | undefined} the panel instance if the panel is currently registered, undefined otherwise.
   * @memberof PanelAPI
   */
  pin(value, pin) {
    const panel = this.get(value);
    if (!panel) {
      return panel;
    }
    pin = typeof pin !== "undefined" ? pin : !panel.isPinned;
    if (!panel.isPinned && !pin) {
      return panel;
    }
    this.panelStore.pinned = pin ? panel : void 0;
    return panel;
  }
  /**
   * Returns the currently pinned panel instance, if exists.
   *
   * @readonly
   * @type {(PanelInstance | undefined)}
   * @memberof PanelAPI
   */
  get pinned() {
    return this.panelStore.pinned || void 0;
  }
  /**
   * Sets route to the specified screen id and pass props to the panel screen components.
   *
   * @param {(string | PanelInstance)} value
   * @param {PanelConfigRoute} route
   * @returns {PanelInstance | undefined} the panel instance if the panel is currently registered and the specified screen exists, undefined otherwise.
   * @memberof PanelAPI
   */
  // TODO: implement panel route history
  show(value, route) {
    const panel = this.get(value);
    if (!panel) {
      return panel;
    }
    if (!panel.screens[route.screen]) {
      return void 0;
    }
    if (panel.screens[route.screen]?.props) {
      const propsToCheck = Object.keys(panel.screens[route.screen]?.props).filter((pr) => pr !== "panel");
      const propsPassed = route.props ? Object.keys(route.props) : [];
      for (let i = 0; i < propsToCheck.length; i++) {
        if (!propsPassed.includes(propsToCheck[i]) && panel.screens[route.screen].props[propsToCheck[i]].required) {
          return void 0;
        }
      }
    }
    if (!(route.screen in this.$element._context.components)) {
      panel.registerScreen(route.screen);
    }
    if (panel.teleport) {
      route.props = {
        header: !!panel.teleport?.showHeader,
        ...route.props
      };
    }
    this.panelStore.items[panel.id].route = route;
    return panel;
  }
  /**
   * Sets the styles of the specified panel by using a provided CSS styles object.
   *
   * @param {(string | PanelInstance)} value
   * @param {object} style
   * @param {boolean} [replace=false] merge with existing styles if `false`; replace if `true`
   * @returns {PanelInstance | undefined} the panel instance if the panel is currently registered, undefined otherwise.
   * @memberof PanelAPI
   */
  setStyle(value, style, replace = false) {
    const panel = this.get(value);
    if (!panel) {
      return panel;
    }
    this.panelStore.items[panel.id].style = replace ? style : { ...panel.style, ...style };
    return panel;
  }
  /**
   * Expands/collapses the expand state of the panel. Toggles whether the panel expands if no expand value is given.
   *
   * @param {(string | PanelInstance)} value
   * @param {boolean} expand Optional. Whether the panel should expand, toggles the value if not set
   * @returns {PanelInstance | undefined} the panel instance if the panel is currently registered, undefined otherwise.
   * @memberof PanelAPI
   */
  expand(value, expand) {
    const panel = this.get(value);
    if (!panel) {
      return panel;
    }
    this.panelStore.items[panel.id].expanded = expand !== void 0 ? expand : !panel.expanded;
    return panel;
  }
}
function isPanelConfigPair(value) {
  return value.id !== void 0 && typeof value.id === "string" && value.config !== void 0;
}

const _sfc_main$1f = {};

function _sfc_render$3(_ctx, _cache) {
  const _component_panel_screen = resolveComponent("panel-screen");

  return (openBlock(), createBlock(_component_panel_screen, {
    header: false,
    class: "screen-spinner"
  }, {
    content: withCtx(() => _cache[0] || (_cache[0] = [
      createElementVNode("div", { class: "loader" }, null, -1)
    ])),
    _: 1
  }))
}
const ScreenSpinnerV = /*#__PURE__*/_export_sfc(_sfc_main$1f, [['render',_sfc_render$3],['__scopeId',"data-v-a3c61802"]]);

const screenModules = /* #__PURE__ */ Object.assign({"../fixtures/areas-of-interest/screen.vue": () => Promise.resolve().then(() => screen$b),"../fixtures/basemap/screen.vue": () => Promise.resolve().then(() => screen$a),"../fixtures/export/screen.vue": () => Promise.resolve().then(() => screen$9),"../fixtures/geosearch/screen.vue": () => Promise.resolve().then(() => screen$8),"../fixtures/grid/screen.vue": () => Promise.resolve().then(() => screen$1),"../fixtures/help/screen.vue": () => Promise.resolve().then(() => screen$7),"../fixtures/layer-reorder/screen.vue": () => Promise.resolve().then(() => screen$6),"../fixtures/legend/screen.vue": () => Promise.resolve().then(() => screen$5),"../fixtures/metadata/screen.vue": () => Promise.resolve().then(() => screen$4),"../fixtures/settings/screen.vue": () => Promise.resolve().then(() => screen$3),"../fixtures/wizard/screen.vue": () => Promise.resolve().then(() => screen$2)});
class PanelInstance extends APIScope {
  /**
   * ID of this panel.
   *
   * @type {string}
   * @memberof PanelInstance
   */
  id;
  /**
   * A collection of panel screens to be displayed inside the panel.
   *
   * @type {PanelConfigScreens}
   * @memberof PanelInstance
   */
  screens;
  /**
   * A list of screen component ids which are loaded and ready to be rendered.
   *
   * @private
   * @type {string[]}
   * @memberof PanelInstance
   */
  loadedScreens = [];
  alertName;
  /**
   * The config for the element to render the panel screen in (instead of its usual spot in the panel stack).
   */
  teleport;
  controls;
  button;
  /**
   * Checks if a given screen component id is already loaded and ready to render.
   *
   * @param {string} id
   * @returns {boolean}
   * @memberof PanelInstance
   */
  isScreenLoaded(id) {
    return this.loadedScreens.indexOf(id) !== -1;
  }
  /**
   * Loads and register panel screen components.
   * This function should be called just before the screen is to be shown; this will avoid needlessly loading components upfront
   * (sometimes certain screens might not get used at all).
   *
   * @param {string} id
   * @memberof PanelInstance
   */
  registerScreen(id) {
    const screen = this.screens[id];
    let payload;
    if (isComponentOptions(screen) || isVueConstructor(screen)) {
      payload = screen;
      this.loadedScreens.push(id);
    } else if (isHTMLScreen(screen)) {
      payload = {
        template: `<panel-screen :panel="this" :screenId="'${id}'">
                           </panel-screen>`
      };
    } else {
      let asyncComponent;
      if (typeof screen === "string") {
        asyncComponent = screenModules[`../fixtures/${screen}`]();
      } else {
        asyncComponent = screen();
      }
      const component = new Promise((resolve, reject) => {
        asyncComponent.then((data) => {
          this.loadedScreens.push(id);
          resolve(isTypeofImportVue(data) ? data.default : data);
        });
        asyncComponent.catch((error) => reject(error));
      });
      payload = defineAsyncComponent({
        // The component to load (should be a Promise)
        loader: () => component,
        // A component to use while the async component is loading
        loadingComponent: ScreenSpinnerV,
        // A component to use if the load fails
        // TODO: add error component
        // error: ErrorComponent,
        // Delay before showing the loading component. Default: 200ms.
        delay: 200
        // The error component will be displayed if a timeout is
        // provided and exceeded. Default: Infinity.
        // TODO: restore the error timeout
        // timeout: 3000,
      });
    }
    this.$iApi.$element.component(id, payload);
  }
  /**
   * The style object applied to the panel.
   *
   * @type {PanelConfigStyle}
   * @memberof PanelInstance
   */
  style;
  /**
   * Whether the panel expands to fill empty space.
   *
   * @type {boolean}
   * @memberof PanelInstance
   */
  expanded;
  /**
   * Returns the width of the panel in pixels or undefined if not set.
   *
   * @readonly
   * @type {(number | undefined)}
   * @memberof PanelInstance
   */
  get width() {
    if (!this.style.width || this.style.width.slice(-2) !== "px") {
      return void 0;
    }
    return parseInt(this.style.width);
  }
  /**
   * Specifies which panel screen to display and optional props to be passed to the screen panel component.
   *
   * @type {PanelConfigRoute}
   * @memberof PanelConfig
   */
  route;
  /**
   * Creates an instance of PanelInstance.
   *
   * @param {InstanceAPI} iApi
   * @param {string} id
   * @param {PanelConfig} config
   * @param {PanelRegistrationOptions} [options={}]
   * @memberof PanelInstance
   */
  constructor(iApi, id, config) {
    super(iApi);
    ({
      id: this.id,
      screens: this.screens,
      style: this.style,
      expanded: this.expanded,
      alertName: this.alertName,
      button: this.button,
      controls: this.controls
    } = {
      id,
      style: {},
      expanded: false,
      controls: {
        expand: false,
        ...config.controls
      },
      ...config
    });
    if (Object.keys(this.screens).length === 0) {
      throw new Error("panel must have at least a single screen");
    }
    this.route = { screen: Object.keys(this.screens).pop() };
    if (!this.style["flex-basis"]) {
      this.style["flex-basis"] = this.style.width || "350px";
    }
    this.style["width"] = "80%";
  }
  /**
   * Opens a registered panel in the panel stack.
   * This is a proxy to `InstanceAPI.panel.open(...)`.
   *
   *  - `somePanel.open()` -- opens the panel on the first screen in the set
   *  - `somePanel.open('screen-id')` -- opens the panel on the 'screen-id' screen
   *  - `somePanel.open({ screen: 'screen-id', props: {... } })` -- opens the panel on the 'screen-id' screen passing supplied `props` to it
   *
   * @param {(string | { screen: string; props?: object })} value a screen id, or an object of the form `{ screen: <id>, props: <object> }`.
   * @returns {this}
   * @memberof PanelInstance
   */
  open(value) {
    if (typeof value === "undefined") {
      this.$iApi.panel.open(this);
    } else {
      this.$iApi.panel.open({
        id: this.id,
        ...typeof value === "string" ? { screen: value } : value
      });
    }
    return this;
  }
  /**
   * Checks if the panel is open or not.
   *
   * @readonly
   * @type {boolean}
   * @memberof PanelInstance
   */
  get isOpen() {
    return this.$iApi.panel.opened.indexOf(this) !== -1;
  }
  /**
   * true if the panel is currently visible
   *
   * @readonly
   * @type {boolean}
   * @memberof PanelInstance
   */
  get isVisible() {
    return this.$iApi.panel.visible.indexOf(this) !== -1;
  }
  /**
   * Close this panel.
   * This is a proxy to `InstanceAPI.panel.close(...)`.
   *
   * @returns {this}
   * @memberof PanelInstance
   */
  close() {
    this.$iApi.panel.close(this);
    return this;
  }
  /**
   * Minimize this panel.
   * This is a proxy to `InstanceAPI.panel.minimize(...)`.
   *
   * @returns {this}
   * @memberof PanelInstance
   */
  minimize() {
    this.$iApi.panel.minimize(this);
    return this;
  }
  /**
   * Move this panel left or right in the stack.
   * This is a proxy to `InstanceAPI.panel.move(...)`.
   *
   * @param {PanelDirection} direction the direction of movement, either "left" or "right".
   * @returns {this}
   * @memberof PanelInstance
   */
  move(direction) {
    this.$iApi.panel.move(this, direction);
    return this;
  }
  /**
   * Checks if this panel is the leftmost visible and not-teleported panel.
   *
   * @readonly
   * @type {boolean}
   * @memberof PanelInstance
   */
  get isLeftMostPanel() {
    if (this.$iApi.panel.visible.length > 0) {
      for (const panel of this.$iApi.panel.visible) {
        if (!panel.teleport) {
          if (this.id === panel.id) {
            return true;
          }
          return false;
        }
      }
    }
    return false;
  }
  /**
   * Checks if this panel is the rightmost visible and non-teleported panel.
   * Note that a traditional for each loop is used due to reverse traversal of the array.
   *
   * @readonly
   * @type {boolean}
   * @memberof PanelInstance
   */
  get isRightMostPanel() {
    if (this.$iApi.panel.visible.length > 0) {
      for (let i = this.$iApi.panel.visible.length - 1; i >= 0; i--) {
        if (!this.$iApi.panel.visible[i].teleport) {
          if (this.id === this.$iApi.panel.visible[i].id) {
            return true;
          }
          return false;
        }
      }
    }
    return false;
  }
  /**
   * Remove this panel.
   * This is a proxy to `InstanceAPI.panel.remove(...)`.
   *
   * @returns {this}
   * @memberof PanelInstance
   */
  remove() {
    this.$iApi.panel.remove(this);
    return this;
  }
  /**
   * Toggle panel.
   * This is a proxy to `InstanceAPI.panel.toggle(...)`.
   *
   * @param {(boolean | { screen: string; props?: object; toggle?: boolean })} [value]
   * @returns {this}
   * @memberof PanelInstance
   */
  toggle(value) {
    if (typeof value === "undefined") {
      this.$iApi.panel.toggle(this, !this.isOpen);
    } else if (typeof value === "boolean") {
      if (value !== this.isOpen) {
        this.$iApi.panel.toggle(this, value);
      }
    } else {
      this.$iApi.panel.toggle(
        { id: this.id, screen: value.screen, props: value.props },
        typeof value.toggle !== "undefined" ? value.toggle : !this.isOpen
      );
    }
    return this;
  }
  /**
   * Toggle panel's minimize state.
   * This is a proxy to `InstanceAPI.panel.toggleMinimize(...)`.
   *
   * @param {(boolean | { screen: string; props?: object; toggle?: boolean })} [value]
   * @returns {this}
   * @memberof PanelInstance
   */
  toggleMinimize(value) {
    if (typeof value === "undefined" || typeof value === "boolean") {
      this.$iApi.panel.toggleMinimize(this, value);
    } else {
      this.$iApi.panel.toggleMinimize(
        { id: this.id, screen: value.screen, props: value.props },
        typeof value.toggle !== "undefined" ? value.toggle : !this.isOpen
      );
    }
    return this;
  }
  /**
   * Pin/unpin/toggle (if no value provided) pin status of this panel. When pinning, automatically unpins any previous pinned panel if exists.
   * This is a proxy to `InstanceAPI.panel.pin(...)`.
   *
   *
   * @param {boolean} [value]
   * @returns {this}
   * @memberof PanelInstance
   */
  pin(value) {
    value = typeof value !== "undefined" ? value : !this.isPinned;
    this.$iApi.panel.pin(this, value);
    return this;
  }
  /**
   * Checks if this panel is pinned or not.
   *
   * @readonly
   * @type {boolean}
   * @memberof PanelInstance
   */
  get isPinned() {
    return !!this.$iApi.panel.pinned && this.$iApi.panel.pinned.id === this.id;
  }
  /**
   * Sets route to the specified screen id and pass props to the panel screen components.
   * This is a proxy to `InstanceAPI.panel.route(...)`.
   *
   * @param {(string | PanelConfigRoute)} value
   * @returns {this}
   * @memberof PanelInstance
   */
  show(value) {
    const route = typeof value === "string" ? { screen: value } : value;
    this.route = route;
    this.$iApi.panel.show(this, route);
    return this;
  }
  /**
   * Sets the styles of the specified panel by using a provided CSS styles object.
   * This is a proxy to `InstanceAPI.panel.setStyles(...)`.
   *
   * @param {object} style
   * @param {boolean} [replace=false]
   * @returns {this}
   * @memberof PanelInstance
   */
  setStyles(style, replace = false) {
    this.$iApi.panel.setStyle(this, style, replace);
    return this;
  }
  /**
   * Expands/collapses/toggles the expand state of the panel. Panels set to expand fill empty space.
   * This is a proxy to `InstanceAPI.panel.expand(...)`.
   *
   * @param {boolean} expand Optional. Whether the panel should expand. Toggles if no value is given.
   * @returns {this}
   * @memberof PanelInstance
   */
  expand(expand) {
    this.$iApi.panel.expand(this, expand);
    return this;
  }
}

function configUpgrade2to4(r2c) {
  const r4c = {};
  const r2cs = Array.isArray(r2c) ? r2c : [r2c];
  r2cs.forEach((c) => {
    if (!c.language) {
      console.warn("RAMP2 config with no language supplied. Defaulting to English");
      c.language = "en";
    }
    const nugget = individualConfigUpgrader(c);
    r4c[c.language] = nugget;
  });
  const allFixturesEnabled = Object.entries(r4c).map((langConfigPair) => {
    const fixturesEnabled = langConfigPair[1].fixturesEnabled;
    delete langConfigPair[1].fixturesEnabled;
    return fixturesEnabled;
  });
  let mismatch = false;
  const startingFixtures = allFixturesEnabled.reduce(
    (a, b) => a.filter((c) => {
      const includes = b.includes(c);
      mismatch = mismatch || !includes;
      return includes;
    })
  );
  if (mismatch) {
    console.warn(
      "Configs attempted to load different sets of fixtures. Only common fixtures will be loaded (all configs must load the same fixtures)."
    );
  }
  startingFixtures.push("grid", "crosshairs", "scrollguard", "panguard", "wizard", "layer-reorder", "details");
  return {
    startingFixtures,
    configs: r4c
  };
}
function individualConfigUpgrader(r2c) {
  const r4c = {
    // TODO is there a current version variable anywhere? I can see us forgetting to update this.
    //      on the other hand, any updates to the target version will need to edit this file.
    version: "4.0",
    fixtures: {},
    layers: [],
    map: {},
    panels: { open: [] },
    system: { animate: true, exposeOid: false, exposeMeasurements: true },
    fixturesEnabled: []
    // this will be removed in the final step of configUpgrade2to4
  };
  servicesUpgrader(r2c.services, r4c);
  mapUpgrader(r2c.map, r4c);
  uiUpgrader(r2c.ui, r4c);
  if (r2c.plugins) pluginsUpgrader(r2c.plugins, r4c);
  return r4c;
}
function mapUpgrader(r2Map, r4c) {
  if (r2Map.layers) {
    r2Map.layers.forEach((r2layer) => {
      r4c.layers.unshift(layerUpgrader(r2layer));
    });
  }
  if (r2Map.initialBasemapId) {
    r4c.map.initialBasemapId = r2Map.initialBasemapId;
  }
  if (r2Map.components) {
    if (r2Map.components.geoSearch) {
      if (r2Map.components.geoSearch.enabled) {
        r4c.fixturesEnabled.push("geosearch");
      }
      if (typeof r2Map.components.geoSearch.showGraphic !== "undefined") {
        console.warn(
          `showGraphic property provided in geoSearch map component cannot be mapped and will be skipped.`
        );
      }
      if (typeof r2Map.components.geoSearch.showInfo !== "undefined") {
        console.warn(
          `showInfo property provided in geoSearch map component cannot be mapped and will be skipped.`
        );
      }
    }
    if (r2Map.components.overviewMap && r2Map.components.overviewMap.enabled) {
      if (!r4c.fixtures.overviewmap) {
        r4c.fixtures.overviewmap = {
          basemaps: {}
        };
        r4c.fixturesEnabled.push("overviewmap");
      }
      r4c.fixtures.overviewmap.startMinimized = !r2Map.components.overviewMap.initiallyExpanded;
      r4c.fixtures.overviewmap.expandFactor = r2Map.components.overviewMap.expandFactor ?? 1.5;
    }
    if (r2Map.components.northArrow && r2Map.components.northArrow.enabled) {
      const r4na = {};
      if (r2Map.components.northArrow.arrowIcon) {
        r4na.arrowIcon = r2Map.components.northArrow.arrowIcon;
      }
      if (r2Map.components.northArrow.poleIcon) {
        r4na.poleIcon = r2Map.components.northArrow.poleIcon;
      }
      if (r4na) {
        r4c.fixtures.northarrow = r4na;
        r4c.fixturesEnabled.push("northarrow");
      }
    }
    if (r2Map.components.scaleBar && r2Map.components.scaleBar.enabled) {
      r4c.map.caption = {
        mapCoords: {
          disabled: false
        },
        scaleBar: {
          disabled: false,
          imperialScale: r2Map?.components?.scaleBar?.scalebarUnit === "english" || r2Map?.components?.scaleBar?.scalebarUnit === "dual" && Math.floor(Math.random() * 2) === 0
        }
      };
      switch (r2Map.components?.mouseInfo?.spatialReference?.wkid) {
        case 4326:
          r4c.map.caption.mapCoords.formatter = "LAT_LONG_DMS";
          break;
        case 3978:
          r4c.map.caption.mapCoords.formatter = "CANADA_ATLAS_LAMBERT";
          break;
        case 102100:
          r4c.map.caption.mapCoords.formatter = "WEB_MERCATOR";
          break;
        default:
          r4c.map.caption.mapCoords.formatter = "LAT_LONG_DMS";
          break;
      }
      if (r2Map.components.scaleBar.attachTo) {
        console.warn(
          `attachTo property provided in scaleBar map component cannot be mapped and will be skipped.`
        );
      }
    }
    if (r2Map.components.basemap && r2Map.components.basemap.enabled) {
      r4c.fixturesEnabled.push("basemap");
    }
  }
  if (r2Map.extentSets) {
    r4c.map.extentSets = [];
    r2Map.extentSets.forEach((r2es) => {
      const r4es = {
        id: r2es.id,
        default: {
          xmin: r2es.default.xmin,
          xmax: r2es.default.xmax,
          ymin: r2es.default.ymin,
          ymax: r2es.default.ymax,
          spatialReference: r2es.spatialReference
        }
      };
      if (r2es.full) {
        r4es.full = {
          xmin: r2es.full.xmin,
          xmax: r2es.full.xmax,
          ymin: r2es.full.ymin,
          ymax: r2es.full.ymax,
          spatialReference: r2es.spatialReference
        };
      }
      if (r2es.maximum) {
        r4es.maximum = {
          xmin: r2es.maximum.xmin,
          xmax: r2es.maximum.xmax,
          ymin: r2es.maximum.ymin,
          ymax: r2es.maximum.ymax,
          spatialReference: r2es.spatialReference
        };
      }
      r4c.map.extentSets.push(r4es);
    });
  }
  if (r2Map.lodSets) {
    r4c.map.lodSets = r2Map.lodSets;
  }
  if (r2Map.tileSchemas) {
    r4c.map.tileSchemas = [];
    r2Map.tileSchemas.forEach((r2ts) => {
      const r4ts = {
        id: r2ts.id,
        name: r2ts.name,
        extentSetId: r2ts.extentSetId,
        lodSetId: r2ts.lodSetId,
        thumbnailTileUrls: [],
        // TODO: use some defaulting here?
        hasNorthPole: r2ts.hasNorthPole || false
      };
      if (r2ts.overviewUrl) {
        if (!r4c.fixtures.overviewmap) {
          r4c.fixtures.overviewmap = {
            basemaps: {}
          };
          r4c.fixturesEnabled.push("overviewmap");
        }
        r4c.fixtures.overviewmap.basemaps[r2ts.id] = {
          id: r2ts.overviewUrl.id || `overviewmap-basemap-${r2ts.id}`,
          tileSchemaId: r2ts.id,
          layers: [
            {
              id: r2ts.overviewUrl.id || `overviewmap-basemap-${r2ts.id}-0`,
              layerType: r2ts.overviewUrl.layerType === "esriDynamic" ? LayerType.MAPIMAGE : LayerType.TILE,
              url: r2ts.overviewUrl.url,
              opacity: r2ts.overviewUrl.opacity ?? 1
            }
          ]
        };
      }
      r4c.map.tileSchemas.push(r4ts);
    });
  }
  if (r2Map.baseMaps) {
    r4c.map.basemaps = [];
    r2Map.baseMaps.forEach((r2bm) => {
      const r4bm = {
        id: r2bm.id,
        tileSchemaId: r2bm.tileSchemaId,
        name: r2bm.name,
        description: r2bm.description,
        altText: r2bm.altText,
        thumbnailUrl: r2bm.thumbnailUrl,
        layers: []
        // populated later
      };
      if (r2bm.attribution) {
        r4bm.attribution = {
          text: {},
          logo: {}
        };
        if (r2bm.attribution.text) {
          r4bm.attribution.text.disabled = !r2bm.attribution.text.enabled;
          r4bm.attribution.text.value = r2bm.attribution.text.value;
        }
        if (r2bm.attribution.logo) {
          r4bm.attribution.logo.disabled = !r2bm.attribution.logo.enabled;
          r4bm.attribution.logo.altText = r2bm.attribution.logo.altText;
          r4bm.attribution.logo.value = r2bm.attribution.logo.value;
          r4bm.attribution.logo.link = r2bm.attribution.logo.link;
        }
      }
      r2bm.layers.forEach((r2bml, idx) => {
        const r4bml = {
          id: r2bml.id || `${r2bm.id}-${idx}`,
          layerType: r2bml.layerType === "esriDynamic" ? LayerType.MAPIMAGE : LayerType.TILE,
          url: r2bml.url,
          opacity: r2bml.opacity ?? 1
        };
        r4bm.layers.push(r4bml);
      });
      r4c.map.basemaps.push(r4bm);
    });
  }
  if (r2Map.legend) {
    r4c.fixturesEnabled.push("legend");
    if (r2Map.legend.type === "autopopulate") {
      r4c.fixtures.legend = {
        root: {
          name: "I'm root",
          children: []
        }
      };
      if (r4c.layers) {
        r4c.layers.toReversed().forEach((r4layer) => {
          if (r4layer.type === "esri-map-image" || r4layer.type === "ogc-wms") {
            const entryGroup = {
              name: r4layer.name ?? `${r4layer.id} Group`,
              children: []
            };
            r4layer.sublayers.forEach((r4Sublayer) => {
              const entry = {
                layerId: r4layer.id
              };
              if (r4Sublayer.name) {
                entry.name = r4Sublayer.name;
              }
              if (r4Sublayer.controls) {
                entry.controls = r4Sublayer.controls;
              }
              if (r4Sublayer.disabledControls) {
                entry.disabledControls = r4Sublayer.disabledControls;
              }
              if (r4layer.type === "esri-map-image") {
                entry.sublayerIndex = r4Sublayer.index;
              } else {
                entry.sublayerId = r4Sublayer.id;
                console.warn(
                  `sublayerId property defined in legend entry ${entry.layerId} is currently not supported.`
                );
              }
              entryGroup.children.push(entry);
            });
            r4c.fixtures.legend.root.children.push(entryGroup);
          } else {
            const entry = {
              layerId: r4layer.id
            };
            if (r4layer.controls) {
              entry.controls = r4layer.controls;
            }
            if (r4layer.disabledControls) {
              entry.disabledControls = r4layer.disabledControls;
            }
            r4c.fixtures.legend.root.children.push(entry);
          }
        });
      }
    } else {
      r4c.fixtures.legend = {
        root: legendGroupUpgrader(r2Map.legend.root)
      };
    }
  }
}
function legendGroupUpgrader(r2legendGroup) {
  const r4legendGroup = { name: r2legendGroup.name, children: [] };
  if (typeof r2legendGroup.hidden !== "undefined") {
    r4legendGroup.hidden = r2legendGroup.hidden;
  }
  if (typeof r2legendGroup.expanded !== "undefined") {
    r4legendGroup.expanded = r2legendGroup.expanded;
  }
  const allowedControls = ["identify", "opacity", "reload", "remove", "settings", "symbology", "visibility"];
  if (r2legendGroup.controls && r2legendGroup.controls.length > 0) {
    r4legendGroup.controls = controlsUpgrader(r2legendGroup.controls, allowedControls);
    if (r2legendGroup.controls.includes("visibility")) {
      r4legendGroup.controls.push("visibilityButton");
    }
    if (r2legendGroup.controls.length !== 1 || r2legendGroup.controls[0] !== "visibility") {
      console.warn(
        `Legend entry groups currently support only the visibility control. All other controls are currently not supported.`
      );
    }
    r4legendGroup.controls.push("expandButton");
  }
  if (r2legendGroup.disabledControls && r2legendGroup.disabledControls.length > 0) {
    r4legendGroup.disabledControls = controlsUpgrader(r2legendGroup.disabledControls, allowedControls);
    if (r2legendGroup.disabledControls.includes("visibility")) {
      r4legendGroup.disabledControls.push("visibilityButton");
    }
    if (r2legendGroup.disabledControls.length !== 1 || r2legendGroup.disabledControls[0] !== "visibility") {
      console.warn(
        `Legend entry groups currently support only the visibility control. All other controls are currently not supported.`
      );
    }
  }
  r2legendGroup.children.forEach((child) => {
    if (child.layerId) {
      r4legendGroup.children.push(legendEntryUpgrader(child));
    } else if (child.infoType) {
      if (child.infoType === "unboundLayer") {
        console.warn(
          `unboundLayer infoType in infoSection in children list of legend entry group ${r4legendGroup.name} cannot be mapped and will be skipped.`
        );
      } else {
        r4legendGroup.children.push({
          infoType: child.infoType,
          content: child.content
        });
        if (typeof child.export !== "undefined") {
          console.warn(
            `export property in infoSection in children list of legend entry group ${r4legendGroup.name} cannot be mapped and will be skipped.`
          );
        }
      }
    } else if (child.exclusiveVisibility) {
      const visibilitySet = {
        name: "Visibility Set",
        children: [],
        exclusive: true
      };
      if (typeof child.collapse !== "undefined") {
        console.warn(
          `collapse property in visibilitySet in children list of legend entry group ${r4legendGroup.name} cannot be mapped and will be skipped.`
        );
      }
      child.exclusiveVisibility.forEach((item) => {
        if (item.layerId) {
          visibilitySet.children.push(legendEntryUpgrader(item));
        } else {
          visibilitySet.children.push(legendGroupUpgrader(item));
        }
      });
      r4legendGroup.children.push(visibilitySet);
    } else {
      r4legendGroup.children.push(legendGroupUpgrader(child));
    }
  });
  return r4legendGroup;
}
function legendEntryUpgrader(r2legendEntry) {
  const r4legendEntry = r2legendEntry;
  const allowedControls = [
    "boundaryZoom",
    "datatable",
    "identify",
    "metadata",
    "opacity",
    "refresh",
    "reload",
    "remove",
    "settings",
    "symbology",
    "visibility"
  ];
  if (r2legendEntry.controls && r2legendEntry.controls.length > 0) {
    r4legendEntry.layerControls = controlsUpgrader(r2legendEntry.controls, allowedControls);
    r4legendEntry.layerControls.push("symbology");
  }
  if (r2legendEntry.disabledControls && r2legendEntry.disabledControls.length > 0) {
    r4legendEntry.disabledLayerControls = controlsUpgrader(r2legendEntry.disabledControls, allowedControls);
  }
  if (r2legendEntry.controlledIds) {
    console.warn(
      `controlledIds property defined in legend entry ${r2legendEntry.layerId} cannot be mapped and will be skipped.`
    );
    delete r4legendEntry.controlledIds;
  }
  if (r2legendEntry.entryIndex) {
    r4legendEntry.sublayerIndex = r2legendEntry.entryIndex;
    delete r2legendEntry.entryIndex;
  }
  if (r2legendEntry.entryId) {
    console.warn(
      `entryId property defined in legend entry ${r2legendEntry.layerId} cannot be mapped and will be skipped.`
    );
  }
  return r4legendEntry;
}
function layerUpgrader(r2layer) {
  const r4layer = layerCommonPropertiesUpgrader(r2layer);
  r4layer.id = r2layer.id;
  r4layer.url = r2layer.url;
  if (r2layer.refreshInterval) {
    r4layer.refreshInterval = r2layer.refreshInterval;
    console.warn("Property refreshInterval in layer is currently not supported.");
  }
  if (r2layer.expectedResponseTime) {
    r4layer.expectedLoadTime = r2layer.expectedResponseTime;
  }
  if (r2layer.metadataUrl) {
    r4layer.metadata = {
      url: r2layer.metadataUrl
    };
  }
  if (r2layer.catalogueUrl) {
    r4layer.catalogueUrl = r2layer.catalogueUrl;
  }
  if (typeof r2layer.enableStructuredDelete !== "undefined") {
    console.warn(
      `enableStructuredDelete property provided in layer ${r2layer.id} cannot be mapped and will be skipped.`
    );
  }
  if (r2layer.tooltipField) {
    r4layer.tooltipField = r2layer.tooltipField;
  }
  if (r2layer.tolerance) {
    r4layer.mouseTolerance = r2layer.tolerance;
    if (r2layer.layerType === "esriDynamic") {
      r4layer.touchTolerance = r2layer.tolerance + 10;
    }
  }
  if (r2layer.customRenderer) {
    r4layer.customRenderer = r2layer.customRenderer;
  }
  switch (r2layer.layerType) {
    case "esriDynamic":
      r4layer.layerType = "esri-map-image";
      if (typeof r2layer.singleEntryCollapse !== "undefined") {
        r4layer.singleEntryCollapse = r2layer.singleEntryCollapse;
      }
      if (r2layer.imageFormat) {
        r4layer.imageFormat = r2layer.imageFormat;
      }
      if (r2layer.layerEntries) {
        r4layer.sublayers = [];
        r2layer.layerEntries.forEach((r2LayerEntry) => {
          const r4Sublayer = layerCommonPropertiesUpgrader(r2LayerEntry);
          r4Sublayer.index = r2LayerEntry.index;
          r4layer.sublayers.push(r4Sublayer);
        });
      }
      break;
    case "esriFeature":
      r4layer.layerType = "esri-feature";
      if (r2layer.fileType) {
        r4layer.layerType = r2layer.fileType === "shapefile" ? "file-shape" : `file-${r2layer.fileType}`;
        if (r2layer.colour) {
          r4layer.colour = r2layer.colour;
        }
        if (r2layer.latField) {
          r4layer.latField = r2layer.latField;
        }
        if (r2layer.longField) {
          r4layer.longField = r2layer.longField;
        }
      }
      break;
    case "ogcWfs":
      r4layer.layerType = "ogc-wfs";
      if (r2layer.colour) {
        r4layer.colour = r2layer.colour;
      }
      if (typeof r2layer.xyInAttribs !== "undefined") {
        r4layer.xyInAttribs = r2layer.xyInAttribs;
      }
      break;
    case "ogcWms":
      r4layer.layerType = "ogc-wms";
      if (r2layer.suppressGetCapabilities) {
        console.warn(
          `suppressGetCapabilities property provided in layer ${r2layer.id} cannot be mapped and will be skipped.`
        );
      }
      if (r2layer.featureInfoMimeType) {
        if (r2layer.featureInfoMimeType === "text/html;fgpv=summary") {
          r4layer.featureInfoMimeType = "text/html";
        } else {
          r4layer.featureInfoMimeType = r2layer.featureInfoMimeType;
        }
      }
      if (r2layer.legendMimeType) {
        console.warn(
          `legendMimeType property provided in layer ${r2layer.id} cannot be mapped and will be skipped.`
        );
      }
      if (r2layer.layerEntries) {
        r4layer.sublayers = [];
        r2layer.layerEntries.forEach((r2LayerEntry) => {
          const r4Sublayer = layerCommonPropertiesUpgrader(r2LayerEntry);
          r4Sublayer.id = r2LayerEntry.id;
          if (r2LayerEntry.currentStyle) {
            r4Sublayer.currentStyle = r2LayerEntry.currentStyle;
            console.warn(
              `currentStyle property provided in layer entry ${r2LayerEntry.id} of layer ${r2layer.id} is currently not supported.`
            );
          }
          if (r2LayerEntry.allStyles) {
            console.warn(
              `allStyles property provided in layer entry ${r2LayerEntry.id} of layer ${r2layer.id} cannot be mapped and will be skipped.`
            );
          }
          r4layer.sublayers.push(r4Sublayer);
        });
      }
      break;
    case "esriImage":
      r4layer.layerType = "esri-imagery";
      break;
    case "esriTile":
      r4layer.layerType = "esri-tile";
      break;
    default:
      console.warn(`Unhandled layer type in ramp 2 config ${r2layer.layerType}`);
  }
  if (r2layer.details) {
    console.warn(`Details config provided in layer ${r2layer.id} cannot be mapped and will be skipped.`);
  }
  return r4layer;
}
function layerCommonPropertiesUpgrader(r2layer) {
  const r4layer = {};
  if (r2layer.name) {
    r4layer.name = r2layer.name;
  }
  if (r2layer.nameField) {
    r4layer.nameField = r2layer.nameField;
  }
  if (r2layer.extent) {
    r4layer.extent = r2layer.extent;
  }
  const allowedControls = [
    "boundaryZoom",
    "datatable",
    "identify",
    "metadata",
    "opacity",
    "refresh",
    "reload",
    "remove",
    "settings",
    "symbology",
    "visibility"
  ];
  if (r2layer.controls && r2layer.controls.length > 0) {
    r4layer.controls = controlsUpgrader(r2layer.controls, allowedControls);
    r4layer.controls.push("symbology");
  }
  if (r2layer.disabledControls && r2layer.disabledControls.length > 0) {
    r4layer.disabledControls = controlsUpgrader(r2layer.disabledControls, allowedControls);
  }
  if (r2layer.state) {
    r4layer.state = {
      opacity: r2layer.state.opacity ?? 1,
      visibility: r2layer.state.visibility ?? true,
      identify: r2layer.state.query ?? true,
      hovertips: r2layer.state.hovertips ?? true
    };
    if (typeof r2layer.state.snapshot !== "undefined") {
      console.warn(
        `snapshot property provided in initialLayer settings in layer ${r2layer.id} cannot be mapped and will be skipped.`
      );
    }
    if (typeof r2layer.state.boundingBox !== "undefined") {
      console.warn(
        `boundingBox property provided in initialLayer settings in layer ${r2layer.id} cannot be mapped and will be skipped.`
      );
    }
  }
  if (typeof r2layer.stateOnly !== "undefined") {
    r4layer.cosmetic = r2layer.stateOnly;
  }
  if (r2layer.initialFilteredQuery) {
    r4layer.initialFilteredQuery = r2layer.initialFilteredQuery;
  }
  fieldsSausageGrinder(r2layer, r4layer);
  if (typeof r2layer.toggleSymbology !== "undefined" || r2layer.table) {
    r4layer.fixtures = {};
    if (typeof r2layer.toggleSymbology !== "undefined") {
      r4layer.fixtures.legend = {
        toggleSymbology: r2layer.toggleSymbology
      };
    }
    if (r2layer.table) {
      r4layer.fixtures.grid = {};
      if (r2layer.table.title) {
        r4layer.fixtures.grid.title = r2layer.table.title;
      }
      if (r2layer.table.description) {
        console.warn(
          `description property provided in table property in layer ${r2layer.id} cannot be mapped and will be skipped.`
        );
      }
      if (typeof r2layer.table.maximize !== "undefined") {
        console.warn(
          `maximize property provided in table property in layer ${r2layer.id} cannot be mapped and will be skipped.`
        );
      }
      if (r2layer.table.search) {
        if (r2layer.table.search.enabled) {
          r4layer.fixtures.grid.search = r2layer.table.search.enabled;
        }
        if (r2layer.table.search.value) {
          r4layer.fixtures.grid.searchFilter = r2layer.table.search.value;
        }
      }
      if (typeof r2layer.table.lazyFilter !== "undefined") {
        console.warn(
          `lazyFilter property provided in table property in layer ${r2layer.id} cannot be mapped and will be skipped.`
        );
      }
      if (typeof r2layer.table.applyMap !== "undefined") {
        r4layer.fixtures.grid.applyMap = r2layer.table.applyMap;
      }
      if (typeof r2layer.table.showFilter !== "undefined") {
        r4layer.fixtures.grid.showFilter = r2layer.table.showFilter;
      }
      if (typeof r2layer.table.filterByExtent !== "undefined") {
        r4layer.fixtures.grid.filterByExtent = r2layer.table.filterByExtent;
      }
      if (typeof r2layer.table.searchStrictMatch !== "undefined") {
        console.warn(
          `searchStrictMatch property provided in table property in layer ${r2layer.id} cannot be mapped and will be skipped.`
        );
      }
      if (typeof r2layer.table.printEnabled !== "undefined") {
        console.warn(
          `printEnabled property provided in table property in layer ${r2layer.id} cannot be mapped and will be skipped.`
        );
      }
      if (r2layer.table.columns) {
        r4layer.fixtures.grid.columns = [];
        r2layer.table.columns.forEach((r2tableColumn) => {
          const r4tableColumn = {
            field: r2tableColumn.data
          };
          if (r2tableColumn.title) {
            r4tableColumn.title = r2tableColumn.title;
          }
          if (r2tableColumn.description) {
            console.warn(
              `description property provided in column property in table property in layer ${r2layer.id} cannot be mapped and will be skipped.`
            );
          }
          if (typeof r2tableColumn.visible !== "undefined") {
            r4tableColumn.visible = r2tableColumn.visible;
          }
          if (r2tableColumn.width) {
            r4tableColumn.width = r2tableColumn.width;
          }
          if (r2tableColumn.sort) {
            r4tableColumn.sort = r2tableColumn.sort;
          }
          if (typeof r2tableColumn.searchable !== "undefined") {
            r4tableColumn.searchable = r2tableColumn.searchable;
          }
          if (r2tableColumn.filter) {
            r4tableColumn.filter = r2tableColumn.filter;
          }
          r4layer.fixtures.grid.columns.push(r4tableColumn);
        });
      }
    }
  }
  return r4layer;
}
function controlsUpgrader(r2controls, allowedControls) {
  const r4controls = [];
  r2controls.forEach((control) => {
    if (allowedControls.includes("identify") && control === "query") {
      r4controls.push("identify");
    } else if (allowedControls.includes("datatable") && control === "data") {
      r4controls.push("datatable");
    } else if (allowedControls.includes(control)) {
      r4controls.push(control);
    } else {
      console.warn(`Ignored invalid control: ${control}`);
    }
  });
  return r4controls;
}
function servicesUpgrader(r2Services, r4c) {
  if (!r2Services) {
    return;
  }
  if (r2Services.search) {
    r4c.fixtures.geosearch = {};
    r4c.fixtures.geosearch.serviceUrls = {
      geoNames: r2Services.search.serviceUrls.geoNames,
      geoLocation: r2Services.search.serviceUrls.geoLocation,
      geoProvince: r2Services.search.serviceUrls.provinces,
      geoTypes: r2Services.search.serviceUrls.types
    };
    if (r2Services.search.serviceUrls.geoSuggest) {
      console.warn(
        `geoSuggest property provided in serviceUrls of search service cannot be mapped and will be skipped.`
      );
    }
    if (r2Services.search.settings) {
      r4c.fixtures.geosearch.settings = r2Services.search.settings;
    }
    if (r2Services.search.disabledSearches) {
      r4c.fixtures.geosearch.settings.disabledSearchTypes = r2Services.search.disabledSearches.filter(
        (s) => s !== "SCALE"
      );
    }
  }
  if (r2Services.export) {
    if (!r4c.fixtures.export) {
      r4c.fixtures.export = {};
      r4c.fixturesEnabled.push("export");
    }
    if (r2Services.export.title) {
      r4c.fixtures.export.title = {
        selected: r2Services.export.title.isSelected ?? true,
        selectable: r2Services.export.title.isSelectable ?? true,
        value: r2Services.export.title.value ?? "RAMP-Map / PCAR-Carte"
      };
    }
    if (r2Services.export.map) {
      r4c.fixtures.export.map = {
        selected: r2Services.export.map.isSelected ?? true,
        selectable: r2Services.export.map.isSelectable ?? true
      };
      if (r2Services.export.map.value) {
        console.warn(`value property provided in map export component cannot be mapped and will be skipped.`);
      }
    }
    if (r2Services.export.mapElements) {
      r4c.fixtures.export.mapElements = {
        selected: r2Services.export.mapElements.isSelected ?? true,
        selectable: r2Services.export.mapElements.isSelectable ?? true
      };
      if (r2Services.export.mapElements.value) {
        console.warn(
          `value property provided in mapElements export component cannot be mapped and will be skipped.`
        );
      }
    }
    if (r2Services.export.legend) {
      r4c.fixtures.export.legend = {
        selected: r2Services.export.legend.isSelected ?? true,
        selectable: r2Services.export.legend.isSelectable ?? true
      };
      if (r2Services.export.legend.columnWidth) {
        r4c.fixtures.export.legend.columnWidth = r2Services.export.legend.columnWidth;
      }
      if (r2Services.export.legend.value) {
        console.warn(
          `value property provided in legend export component cannot be mapped and will be skipped.`
        );
      }
      if (typeof r2Services.export.legend.showInfoSymbology !== "undefined") {
        console.warn(
          `showInfoSymbology property provided in legend export component cannot be mapped and will be skipped.`
        );
      }
      if (typeof r2Services.export.legend.showControlledSymbology !== "undefined") {
        console.warn(
          `showControlledSymbology property provided in legend export component cannot be mapped and will be skipped.`
        );
      }
    }
    if (r2Services.export.footnote) {
      r4c.fixtures.export.footnote = {
        selected: r2Services.export.footnote.isSelected ?? true,
        selectable: r2Services.export.footnote.isSelectable ?? true,
        value: r2Services.export.footnote.value ?? ""
      };
    }
    if (r2Services.export.timestamp) {
      r4c.fixtures.export.timestamp = {
        selected: r2Services.export.timestamp.isSelected ?? true,
        selectable: r2Services.export.timestamp.isSelectable ?? true
      };
      if (r2Services.export.timestamp.value) {
        console.warn(
          `value property provided in timestamp export component cannot be mapped and will be skipped.`
        );
      }
    }
    if (r2Services.export.timeout) {
      console.warn(
        `timeout property provided in export property of services config cannot be mapped and will be skipped.`
      );
    }
    if (typeof r2Services.cleanCanvas !== "undefined") {
      console.warn(
        `cleanCanvas property provided in export property of services config cannot be mapped and will be skipped.`
      );
    }
  }
  if (r2Services.proxyUrl) {
    r4c.system.proxyUrl = r2Services.proxyUrl;
  }
  const unused = [
    "corsEverywhere",
    "exportMapUrl",
    "geometryUrl",
    "googleAPIKey",
    "esriLibUrl",
    "geolocation",
    "coordInfo",
    "print"
  ];
  unused.forEach((property) => {
    if (typeof r2Services[property] !== "undefined") {
      console.warn(`${property} property provided in services config cannot be mapped and will be skipped.`);
    }
  });
}
function uiUpgrader(r2ui, r4c) {
  if (r2ui.navBar) {
    r4c.fixtures.mapnav = {
      zoomOption: r2ui.navBar.zoom || "buttons",
      items: []
    };
    const allowedItems = [
      "geolocator",
      "zoom",
      "home",
      "basemap",
      "help",
      "fullscreen",
      "geosearch",
      "legend"
    ];
    r2ui.navBar.extra.forEach((item) => {
      const itemLower = item.toLowerCase();
      if (!allowedItems.includes(itemLower)) {
        console.warn(`Ignored invalid mapnav item: ${item}`);
      } else {
        r4c.fixtures.mapnav.items.push(itemLower);
      }
    });
    r4c.fixturesEnabled.push("mapnav");
  }
  if (r2ui.help) {
    r4c.fixtures.help = {
      location: r2ui.help.folderName && r2ui.help.folderName !== "default" ? `./${r2ui.help.folderName}` : "./help",
      panelWidth: 350
    };
    r4c.fixturesEnabled.push("help");
  }
  if (r2ui.legend) {
    const headerControls = ["groupToggle", "visibilityToggle"];
    if (r2ui.legend.reorderable) {
      headerControls.push("layerReorder");
    }
    if (r2ui.legend.allowImport) {
      headerControls.push("wizard");
    }
    if (r4c.fixtures.legend) {
      r4c.fixtures.legend.headerControls = headerControls;
    } else {
      r4c.fixturesEnabled.push("legend");
      r4c.fixtures.legend = {
        headerControls,
        root: {}
      };
    }
    if (r2ui.legend.isOpen && r2ui.legend.isOpen.large) {
      r4c.panels.open.push({ id: "legend" });
    }
  }
  r4c.fixtures.appbar = { items: [] };
  r4c.fixturesEnabled.push("appbar");
  const validItems = ["layers", "basemap", "export", "help", "geoSearch"];
  if (r2ui.appBar) {
    if (r2ui.appBar.layers !== false) {
      r4c.fixtures.appbar.items.push("legend");
      if (!r4c.fixturesEnabled.includes("legend")) {
        r4c.fixturesEnabled.push("legend");
      }
    }
    if (r2ui.appBar.geoSearch !== false && r4c.fixturesEnabled.includes("geosearch")) {
      r4c.fixtures.appbar.items.push("geosearch");
    }
    if (r2ui.appBar.basemap !== false) {
      r4c.fixtures.appbar.items.push("basemap");
    }
  } else {
    r4c.fixtures.appbar.items.push("legend");
    if (!r4c.fixturesEnabled.includes("legend")) {
      r4c.fixturesEnabled.push("legend");
    }
    r4c.fixtures.appbar.items.push("geosearch");
    r4c.fixtures.appbar.items.push("basemap");
  }
  if (r2ui.sideMenu && r2ui.sideMenu.items && r2ui.sideMenu.items.length > 0) {
    r2ui.sideMenu.items.forEach((r2SideMenuButtons) => {
      r2SideMenuButtons.forEach((button) => {
        if (button === "layers" && !r4c.fixtures.appbar.items.includes("legend")) {
          r4c.fixtures.appbar.items.push("legend");
          if (!r4c.fixturesEnabled.includes("legend")) {
            r4c.fixturesEnabled.push("legend");
          }
        } else if (button !== "layers" && validItems.includes(button) && !r4c.fixtures.appbar.items.includes(button.toLowerCase())) {
          r4c.fixtures.appbar.items.push(button.toLowerCase());
          if (button.toLowerCase() === "help" || button.toLowerCase() === "export" && !r4c.fixturesEnabled.includes(button.toLowerCase())) {
            r4c.fixturesEnabled.push(button.toLowerCase());
          }
        }
      });
    });
  }
  if (r2ui.tableIsOpen && // r2ui.tableIsOpen.id &&
  r2ui.tableIsOpen.large) ;
  const unused = [
    "fullscreen",
    "theme",
    "logoUrl",
    "failureFeedback",
    "title",
    "restrictNavigation",
    "about"
  ];
  unused.forEach((property) => {
    if (typeof r2ui[property] !== "undefined") {
      console.warn(`${property} property provided in services config cannot be mapped and will be skipped.`);
    }
  });
}
function pluginsUpgrader(r2plugins, r4c) {
  if (r2plugins.areasOfInterest.enable) {
    if (!r4c.fixturesEnabled.includes("areas-of-interest")) {
      r4c.fixturesEnabled.push("areas-of-interest");
    }
    if (r2plugins.areasOfInterest.areas) {
      r4c.fixtures["areas-of-interest"] = {
        areas: r2plugins.areasOfInterest.areas.map((area) => {
          return {
            title: `${area["title-en-CA"]} / ${area["title-fr-CA"]}`,
            thumbnail: area.thumbnailUrl,
            altText: area.altText ?? "",
            description: area.description ?? "",
            extent: {
              xmin: area.xmin,
              xmax: area.xmax,
              ymin: area.ymin,
              ymax: area.ymax,
              spatialReference: {
                wkid: area.wkid
              }
            }
          };
        })
      };
    }
  }
}
function fieldsSausageGrinder(r2layer, r4layer) {
  const hasOutfields = r2layer.outfields && r2layer.outfields !== "*";
  if (!hasOutfields && !r2layer.fieldMetadata) {
    return;
  }
  const struct = {
    fieldInfo: [],
    exclusiveFields: false,
    enforceOrder: false
  };
  if (r2layer.fieldMetadata) {
    struct.fieldInfo = r2layer.fieldMetadata.map((fmd) => {
      const newNugget = {
        name: fmd.data
      };
      if (fmd.alias) {
        newNugget.alias = fmd.alias;
      }
      return newNugget;
    });
    if (hasOutfields) {
      const checkFields = r2layer.outfields.split(",").map((s) => s.trim());
      checkFields.forEach((cf) => {
        if (struct.fieldInfo.findIndex((fi) => fi.name === cf) === -1) {
          struct.fieldInfo.push({ name: cf });
        }
      });
      struct.exclusiveFields = true;
    }
  } else if (hasOutfields) {
    struct.fieldInfo = r2layer.outfields.split(",").map((s) => ({ name: s.trim() }));
    struct.exclusiveFields = true;
  }
  r4layer.fieldMetadata = struct;
}

var define_RAMP_VERSION_default = { major: "4", minor: "9", patch: "0", timestamp: "Tue Nov 5 13:22:05 2024 -0500", hash: "a2e8b37e42e17a72e234eba3d8767dc890f4c50f" };
console.info(
  `RAMP v${define_RAMP_VERSION_default.major}.${define_RAMP_VERSION_default.minor}.${define_RAMP_VERSION_default.patch} [${define_RAMP_VERSION_default.hash.slice(0, 9)}] (Built on ${new Date(
    define_RAMP_VERSION_default.timestamp.toString()
  ).toLocaleString()})`
);
const version = define_RAMP_VERSION_default;
function configUpgrade(ramp2Config) {
  return configUpgrade2to4(ramp2Config);
}
function layerConfigUpgrade(ramp2LayerConfig) {
  return layerUpgrader(ramp2LayerConfig);
}
const createInstance = (el, config, opts) => {
  return new InstanceAPI(el, config, opts);
};
const geo = new GeoCommonAPI();

const _hoisted_1$13 = ["innerHTML"];
const _sfc_main$1e = /* @__PURE__ */ defineComponent({
  __name: "default-button",
  props: {
    panelId: {
      type: String,
      required: true
    },
    minimize: {
      type: Boolean,
      default: false
    },
    overflow: {
      type: Boolean
    }
  },
  setup(__props) {
    const { t } = useI18n();
    const iApi = inject("iApi");
    const props = __props;
    const panelButton = computed(() => iApi?.panel.get(props.panelId)?.button);
    const onClickFunction = () => {
      if (props.minimize) {
        iApi?.panel.toggleMinimize(props.panelId);
      } else {
        iApi?.panel.toggle(props.panelId);
      }
    };
    return (_ctx, _cache) => {
      const _component_appbar_button = resolveComponent("appbar-button");
      return panelButton.value ? (openBlock(), createBlock(_component_appbar_button, {
        key: 0,
        onClickFunction,
        tooltip: unref(t)(panelButton.value.tooltip),
        id: __props.panelId
      }, {
        default: withCtx(() => [
          createElementVNode("div", {
            class: normalizeClass(["default fill-current w-24 h-24 ml-8 sm:ml-20", { "ml-20": __props.overflow }]),
            innerHTML: panelButton.value.icon
          }, null, 10, _hoisted_1$13)
        ]),
        _: 1
      }, 8, ["tooltip", "id"])) : createCommentVNode("", true);
    };
  }
});

const _sfc_main$1d = {};

const _hoisted_1$12 = { class: "border-b p-0 self-center w-2/3" };

function _sfc_render$2(_ctx, _cache) {
  return (openBlock(), createElementBlock("span", _hoisted_1$12))
}
const Divider = /*#__PURE__*/_export_sfc(_sfc_main$1d, [['render',_sfc_render$2],['__scopeId',"data-v-5d32b715"]]);

const _hoisted_1$11 = ["content", "aria-label"];
const _sfc_main$1c = /* @__PURE__ */ defineComponent({
  __name: "more-button",
  props: {
    position: {
      type: String,
      default: "right-end"
    },
    popperOptions: {
      type: Object,
      default() {
        return {};
      }
    },
    numItems: {
      type: Number,
      default: 1
    },
    renderWatch: {
      type: Number,
      default: 0
    }
  },
  emits: ["updateParent"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const { t } = useI18n();
    const iApi = inject("iApi");
    const props = __props;
    const emit = __emit;
    function updateParent() {
      emit("updateParent");
    }
    const open = ref(false);
    const numRenders = ref(0);
    const el = ref();
    const dropdownTrigger = ref();
    const dropdown = ref();
    function rerender() {
      updateParent();
      nextTick(() => {
        popperSetUp();
        open.value = !open.value;
      });
    }
    watch(
      () => props.renderWatch,
      () => {
        rerender();
      }
    );
    const popperSetUp = () => {
      open.value = !open.value;
      const innerShell = iApi.$vApp.$el.querySelector(".inner-shell");
      const applyMaxSize = {
        name: "applyMaxSize",
        enabled: true,
        phase: "beforeWrite",
        requires: ["maxSize"],
        fn({ state }) {
          const { width } = state.modifiersData.maxSize;
          state.styles.popper = {
            ...state.styles.popper,
            maxWidth: `${width}px`,
            maxHeight: `${innerShell.offsetHeight - 45}px`
          };
          const realHeight = Math.min(
            props.numItems <= 0 ? 0 : 55 + 44 * (props.numItems - 1),
            innerShell.offsetHeight - 45
          );
          state.styles.popper.height = `${realHeight}px`;
          if (dropdown?.value?.offsetHeight) {
            dropdown.value.style.height = `${realHeight}px`;
          }
          state.styles.popper.overflowY = "auto";
          state.styles.popper.overflowX = "hidden";
        }
      };
      if (dropdownTrigger.value && dropdown.value) {
        numRenders.value++;
        createPopper(dropdownTrigger.value, dropdown.value, {
          placement: props.position || "right-end",
          modifiers: [
            {
              ...maxSize,
              options: {
                boundary: innerShell
              }
            },
            applyMaxSize,
            {
              name: "offset",
              options: {
                offset: [0, 5]
              }
            },
            {
              name: "preventOverflow",
              enabled: true,
              options: {
                boundary: innerShell
              }
            }
          ],
          ...props.popperOptions
        });
      }
      if (numRenders.value === 1) rerender();
    };
    onMounted(() => {
      window.addEventListener(
        "click",
        (event) => {
          if (event.target instanceof HTMLElement && !el.value?.contains(event.target)) {
            open.value = false;
          }
        },
        { capture: true }
      );
    });
    onBeforeUnmount(() => {
      window.removeEventListener(
        "click",
        (event) => {
          if (event.target instanceof HTMLElement && !el.value?.contains(event.target)) {
            open.value = false;
          }
        },
        { capture: true }
      );
    });
    __expose({
      rerender
    });
    return (_ctx, _cache) => {
      const _directive_focus_item = resolveDirective("focus-item");
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", {
        class: "appbar-item relative inset-x-0 w-full text-center",
        ref_key: "el",
        ref: el
      }, [
        withDirectives((openBlock(), createElementBlock("button", {
          type: "button",
          class: "text-gray-400 w-full h-48 focus:outline-none hover:text-white",
          onClick: _cache[0] || (_cache[0] = ($event) => popperSetUp()),
          content: unref(t)("appbar.more"),
          "aria-label": unref(t)("appbar.more"),
          ref_key: "dropdownTrigger",
          ref: dropdownTrigger
        }, _cache[1] || (_cache[1] = [
          createElementVNode("svg", {
            class: "fill-current w-24 h-24 m-auto",
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24"
          }, [
            createElementVNode("path", {
              d: "M0 0h24v24H0z",
              fill: "none"
            }),
            createElementVNode("path", { d: "M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" })
          ], -1)
        ]), 8, _hoisted_1$11)), [
          [_directive_focus_item],
          [_directive_tippy, { placement: "right-end" }]
        ]),
        withDirectives(createElementVNode("div", {
          id: "dropdown",
          class: "dropdown shadow-md border border-gray:200 absolute w-64 flex flex-col bg-white rounded",
          ref_key: "dropdown",
          ref: dropdown
        }, [
          renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ], 512), [
          [vShow, open.value]
        ])
      ], 512);
    };
  }
});

const MoreButton = /* @__PURE__ */ _export_sfc(_sfc_main$1c, [["__scopeId", "data-v-93661050"]]);

const _hoisted_1$10 = {
  key: 0,
  class: "number absolute top-1 right-2 text-white w-18 rounded-full"
};
const _sfc_main$1b = /* @__PURE__ */ defineComponent({
  __name: "appbar-button",
  setup(__props) {
    const notificationStore = useNotificationStore();
    const { t } = useI18n();
    const iApi = inject("iApi");
    const number = computed(() => notificationStore.notificationNumber);
    const onClick = () => {
      iApi.panel.toggle("notifications");
    };
    return (_ctx, _cache) => {
      const _component_appbar_button = resolveComponent("appbar-button", true);
      return openBlock(), createBlock(_component_appbar_button, {
        onClickFunction: onClick,
        tooltip: unref(t)("notifications.title"),
        class: "notification-button",
        id: ""
      }, {
        default: withCtx(() => [
          _cache[0] || (_cache[0] = createElementVNode("svg", {
            class: "fill-current w-24 h-24 mx-8 sm:mx-20",
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24"
          }, [
            createElementVNode("path", { d: "M12 22c1.1 0 2-.9 2-2h-4c0 1.1.89 2 2 2zm6-6v-5c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2z" })
          ], -1)),
          number.value && number.value > 0 ? (openBlock(), createElementBlock("span", _hoisted_1$10, toDisplayString(number.value), 1)) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["tooltip"]);
    };
  }
});

const NotificationsAppbarButton = /* @__PURE__ */ _export_sfc(_sfc_main$1b, [["__scopeId", "data-v-787da765"]]);

const _hoisted_1$$ = ["content"];
const _sfc_main$1a = /* @__PURE__ */ defineComponent({
  __name: "appbar",
  setup(__props) {
    const panelStore = usePanelStore();
    const appbarStore = useAppbarStore();
    const numberOverflow = ref(0);
    const popperRerender = ref(0);
    const items = computed(() => appbarStore.visible);
    const temporaryItems = computed(() => appbarStore.temporary);
    const { t } = useI18n();
    const overflow = ref(false);
    const overflowFlags = ref({});
    const el = ref();
    const rerender = () => {
      nextTick(() => {
        const instance = getCurrentInstance();
        instance?.proxy?.$forceUpdate();
      });
    };
    const blurEvent = () => {
      el.value._tippy.hide();
    };
    const keyupEvent = (e) => {
      const evt = e;
      if (evt.key === "Tab" && el.value?.matches(":focus")) {
        el.value._tippy.show();
      }
    };
    onMounted(() => {
      el.value?.addEventListener("blur", blurEvent);
      el.value?.addEventListener("keyup", keyupEvent);
    });
    onBeforeMount(() => {
      const instance = getCurrentInstance();
      window.addEventListener("resize", () => instance?.proxy?.$forceUpdate());
    });
    onBeforeUnmount(() => {
      const instance = getCurrentInstance();
      window.removeEventListener("resize", () => instance?.proxy?.$forceUpdate());
      el.value?.removeEventListener("blur", blurEvent);
      el.value?.removeEventListener("keyup", keyupEvent);
    });
    onUpdated(() => {
      nextTick(() => {
        const element = el.value;
        let key = void 0;
        let children = [...element.children];
        let bound = children[children.length - 2].getBoundingClientRect().top;
        if (!panelStore.mobileView) {
          bound = element.getBoundingClientRect().bottom - 38;
        }
        let dropdown = element.querySelector("#dropdown");
        for (let i = children.length - 4; i >= 0; i--) {
          let bottom = children[i].getBoundingClientRect().bottom;
          if (bound && dropdown && (bottom > bound || overflow.value && bottom + 56 > bound)) {
            children[i].classList.forEach((cl) => {
              if (cl.includes("identifier")) {
                key = cl.slice(11);
              }
            });
            if (key) {
              overflowFlags.value[key] = true;
              if (!key.includes("divider")) {
                numberOverflow.value++;
              }
              popperRerender.value++;
            }
            if (!overflow.value) overflow.value = true;
          } else if (bottom !== 0) {
            break;
          }
        }
        let more = element.querySelector("#more");
        let moreBottom = more.getBoundingClientRect().bottom;
        key = void 0;
        if (overflow.value && bound && more && dropdown && moreBottom !== 0 && (moreBottom <= bound - 56 || dropdown.childElementCount == 1 && moreBottom <= bound)) {
          let buttonsRemaining = dropdown.childElementCount;
          let index = 0;
          while (moreBottom <= bound - 56 || buttonsRemaining == 1) {
            let item = dropdown.children[index];
            if (item) {
              item.classList.forEach((cl) => {
                if (cl.includes("identifier")) {
                  key = cl.slice(11);
                }
              });
              if (key) {
                overflowFlags.value[key] = false;
                if (!key.includes("divider")) {
                  numberOverflow.value--;
                }
              }
              moreBottom += 48;
              buttonsRemaining -= 1;
              index += 1;
            }
            if (buttonsRemaining === 0) {
              overflow.value = false;
              break;
            }
          }
        }
        Object.keys(overflowFlags.value).forEach((key2) => {
          if (!element.querySelector(`.identifier-${key2}`)) {
            delete overflowFlags.value[key2];
            if (!key2.includes("divider")) {
              numberOverflow.value = Math.max(0, numberOverflow.value - 1);
            }
            popperRerender.value++;
          }
        });
      });
    });
    return (_ctx, _cache) => {
      const _directive_focus_list = resolveDirective("focus-list");
      const _directive_tippy = resolveDirective("tippy");
      return withDirectives((openBlock(), createElementBlock("div", {
        class: "absolute top-0 left-0 bottom-28 flex flex-col w-40 pointer-events-auto appbar z-50 sm:z-20 bg-black-75 sm:w-64 sm:bottom-38",
        content: unref(t)("panels.controls.items"),
        ref_key: "el",
        ref: el
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(items.value, (subArray, index) => {
          return openBlock(), createElementBlock(Fragment, null, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(subArray, (item, index2) => {
              return openBlock(), createElementBlock(Fragment, null, [
                typeof item === "string" && overflowFlags.value[`${item}-${index2}`] !== true ? (openBlock(), createBlock(_sfc_main$1e, {
                  key: `${item}-${index2}-default`,
                  panelId: item,
                  class: normalizeClass(["appbar-item h-48", `identifier-${item}-${index2}`])
                }, null, 8, ["panelId", "class"])) : overflowFlags.value[`${item}-${index2}`] !== true ? (openBlock(), createBlock(resolveDynamicComponent(item.componentId), {
                  key: `${item}-${index2}-custom`,
                  options: item.options,
                  class: normalizeClass(["appbar-item h-48", `identifier-${item}-${index2}`]),
                  id: item.id
                }, null, 8, ["options", "id", "class"])) : createCommentVNode("", true)
              ], 64);
            }), 256)),
            overflowFlags.value[`divider-${index}`] !== true ? (openBlock(), createBlock(Divider, {
              class: normalizeClass(["appbar-item", `identifier-divider-${index}`]),
              key: `${subArray}-${index}-default`
            }, null, 8, ["class"])) : createCommentVNode("", true)
          ], 64);
        }), 256)),
        (openBlock(true), createElementBlock(Fragment, null, renderList(temporaryItems.value?.filter((t2) => overflowFlags.value[`${t2}-temp`] !== true), (item) => {
          return openBlock(), createBlock(_sfc_main$1e, {
            panelId: item,
            minimize: true,
            key: `${item}-temp`,
            class: normalizeClass([`identifier-${item}-temp`, "appbar-item h-48"])
          }, null, 8, ["panelId", "class"]);
        }), 128)),
        withDirectives(createVNode(MoreButton, {
          id: "more",
          numItems: numberOverflow.value,
          renderWatch: popperRerender.value,
          onUpdateParent: rerender
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(items.value, (subArray, index) => {
              return openBlock(), createElementBlock(Fragment, { key: index }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(subArray, (item, index2) => {
                  return openBlock(), createElementBlock(Fragment, null, [
                    typeof item === "string" && overflowFlags.value[`${item}-${index2}`] ? (openBlock(), createBlock(_sfc_main$1e, {
                      key: `${item}-${index2}-default`,
                      panelId: item,
                      class: normalizeClass(["text-black hover:bg-gray my-4 h-36", `identifier-${item}-${index2}`]),
                      overflow: ""
                    }, null, 8, ["panelId", "class"])) : overflowFlags.value[`${item}-${index2}`] ? (openBlock(), createBlock(resolveDynamicComponent(item.componentId), {
                      key: `${item}-${index2}-custom`,
                      options: item.options,
                      id: item.id,
                      class: normalizeClass(["appbar-item h-48", `identifier-${item}-${index2}`])
                    }, null, 8, ["options", "id", "class"])) : createCommentVNode("", true)
                  ], 64);
                }), 256)),
                overflowFlags.value[`divider-${index}`] ? (openBlock(), createBlock(Divider, {
                  key: 0,
                  class: normalizeClass(["border-black my-4", `identifier-divider-${index}`])
                }, null, 8, ["class"])) : createCommentVNode("", true)
              ], 64);
            }), 128)),
            (openBlock(true), createElementBlock(Fragment, null, renderList(temporaryItems.value?.filter((t2) => overflowFlags.value[`${t2}-temp`]), (item) => {
              return openBlock(), createBlock(_sfc_main$1e, {
                panelId: item,
                minimize: true,
                key: `${item}-temp`,
                class: normalizeClass([`identifier-${item}-temp`, "text-black hover:bg-gray my-4 h-36"]),
                overflow: ""
              }, null, 8, ["panelId", "class"]);
            }), 128))
          ]),
          _: 1
        }, 8, ["numItems", "renderWatch"]), [
          [vShow, overflow.value]
        ]),
        createVNode(NotificationsAppbarButton, { class: "appbar-item bottom-48 h-48 sm:display-none" }),
        createVNode(AboutRampDropdown, {
          class: "absolute bottom-0 h-40 sm:display-none w-full text-center",
          position: "right-start"
        })
      ], 8, _hoisted_1$$)), [
        [_directive_focus_list],
        [_directive_tippy, {
          trigger: "manual",
          placement: "top-end",
          popperOptions: {
            placement: "top",
            modifiers: [
              { name: "preventOverflow", options: { altAxis: true } },
              { name: "flip", options: { fallbackPlacements: ["top"] } }
            ]
          }
        }]
      ]);
    };
  }
});

class AppbarAPI extends FixtureInstance {
  /**
   * Returns `AppbarFixtureConfig` section of the global config file.
   *
   * @readonly
   * @type {AppbarFixtureConfig}
   * @memberof AppbarFixture
   */
  get config() {
    return super.config;
  }
  /**
   * Parses the appbar config JSON snippet from the config file and save resulting objects to the fixture store.
   *
   * @param {AppbarFixtureConfig} [appbarConfig]
   * @returns
   * @memberof AppbarAPI
   */
  _parseConfig(appbarConfig) {
    if (!appbarConfig) {
      return;
    }
    const appbarStore = useAppbarStore(this.$vApp.$pinia);
    let config;
    if (!Array.isArray(appbarConfig.items[0])) {
      config = [appbarConfig.items];
    } else {
      config = appbarConfig.items;
    }
    const appbarItems = [];
    config.forEach((appbarItemList) => {
      appbarItems.push(
        appbarItemList.map((item) => {
          if (typeof item === "string") {
            return item;
          }
          return new AppbarItemInstance(item);
        })
      );
    });
    appbarStore.items = appbarItems.flat().reduce((map, item) => {
      map[item instanceof AppbarItemInstance ? item.id : item] = item;
      return map;
    }, {});
    appbarStore.order = appbarItems.map(
      (subArray) => subArray.map((item) => item instanceof AppbarItemInstance ? item.id : item)
    );
    this._validateItems();
  }
  /**
   * Checks if components specified as appbar items are registered or not.
   *
   * @memberof AppbarAPI
   */
  _validateItems() {
    const appbarStore = useAppbarStore(this.$vApp.$pinia);
    appbarStore.order.flat().forEach((id) => {
      if (typeof appbarStore.items[id] === "string") {
        return;
      }
      [id].some((v) => {
        if (this.$iApi.fixture.exists(v) && !appbarStore.items[id]) {
          appbarStore.items[id].componentId = `${v}-appbar-button`;
        }
      });
    });
  }
}

const messages$h = {"en":{"appbar.navigation":"Navigation","appbar.more":"More","navigation.export":"Export","navigation.map.export":"Export Map"},"fr":{"appbar.navigation":"Navigation","appbar.more":"Plus","navigation.export":"Exporter","navigation.map.export":"Exporter la Carte"}};

class AppbarFixture extends AppbarAPI {
  initialized() {
  }
  async added() {
    Object.entries(messages$h).forEach((value) => this.$iApi.$i18n.mergeLocaleMessage(...value));
    const { destroy, el } = this.mount(_sfc_main$1a, {
      app: this.$element
    });
    const innerShell = this.$vApp.$el.getElementsByClassName("inner-shell")[0];
    innerShell.insertBefore(el.childNodes[0], innerShell.querySelector(".panel-stack"));
    this._parseConfig(this.config);
    const unwatch = this.$vApp.$watch(
      () => this.config,
      (value) => this._parseConfig(value)
    );
    const eventHandlers = [];
    eventHandlers.push(
      this.$iApi.event.on(GlobalEvents.COMPONENT, () => {
        this._parseConfig(this.config);
      })
    );
    this.removed = () => {
      const appbarStore = useAppbarStore(this.$vApp.$pinia);
      unwatch();
      eventHandlers.forEach((h) => this.$iApi.event.off(h));
      const items = { ...appbarStore.items };
      const tempItems = [...appbarStore.temporary];
      Object.keys(items).forEach((item) => appbarStore.removeButton(item));
      tempItems.forEach((item) => appbarStore.removeButton(item));
      destroy();
      appbarStore.$reset();
    };
  }
}

const index$t = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: AppbarFixture
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$_ = { class: "mt-10" };
const _hoisted_2$N = ["aria-label"];
const _hoisted_3$C = ["alt", "src"];
const _hoisted_4$o = ["alt"];
const _hoisted_5$i = { class: "absolute flex w-full bg-black opacity-75 text-white h-30 bottom-6 items-center" };
const _hoisted_6$h = { class: "pl-5" };
const _hoisted_7$h = { class: "ml-auto pr-5" };
const _hoisted_8$d = ["content"];
const _sfc_main$19 = /* @__PURE__ */ defineComponent({
  __name: "item",
  props: {
    area: {
      type: Object,
      required: true
    },
    showThumbnail: {
      type: Boolean
    }
  },
  setup(__props) {
    const { t } = useI18n();
    const iApi = inject("iApi");
    const selectAreaOfInterest = (area) => {
      if (!area.extent) {
        console.error("selected area of interest doesn't have an extent specified.");
        return;
      }
      iApi?.geo.map.zoomMapTo(Extent.fromConfig(`area-of-interest-extent`, area.extent));
    };
    return (_ctx, _cache) => {
      const _directive_truncate = resolveDirective("truncate");
      const _directive_tippy = resolveDirective("tippy");
      const _directive_focus_item = resolveDirective("focus-item");
      return openBlock(), createElementBlock("div", _hoisted_1$_, [
        withDirectives((openBlock(), createElementBlock("button", {
          type: "button",
          class: normalizeClass(["area-of-interest-item-button bg-gray-300 w-full", { "border border-gray-300": __props.showThumbnail }]),
          "aria-label": unref(t)("areas-of-interest.select"),
          onClick: _cache[2] || (_cache[2] = ($event) => selectAreaOfInterest(__props.area))
        }, [
          createElementVNode("div", null, [
            createElementVNode("div", {
              class: normalizeClass(["flex hover:opacity-50 area-of-interest-item-image", __props.showThumbnail ? "h-180" : "h-30"])
            }, [
              __props.area.thumbnail ? (openBlock(), createElementBlock("img", {
                key: 0,
                class: "w-full bg-white object-contain",
                alt: __props.area.altText || __props.area.title,
                src: __props.area.thumbnail
              }, null, 8, _hoisted_3$C)) : __props.showThumbnail ? (openBlock(), createElementBlock("img", {
                key: 1,
                class: "w-full bg-white object-contain py-30",
                alt: __props.area.altText || __props.area.title,
                src: "https://openclipart.org/image/800px/160615"
              }, null, 8, _hoisted_4$o)) : createCommentVNode("", true)
            ], 2)
          ]),
          createElementVNode("div", _hoisted_5$i, [
            withDirectives((openBlock(), createElementBlock("div", _hoisted_6$h, [
              createElementVNode("span", null, toDisplayString(__props.area.title), 1)
            ])), [
              [_directive_truncate]
            ]),
            withDirectives(createElementVNode("div", _hoisted_7$h, [
              withDirectives((openBlock(), createElementBlock("a", {
                onClick: _cache[0] || (_cache[0] = withModifiers(() => {
                }, ["stop"])),
                onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(() => {
                }, ["prevent"]), ["enter", "space"])),
                content: __props.area.description
              }, _cache[3] || (_cache[3] = [
                createElementVNode("svg", {
                  class: "fill-current w-16 h-16",
                  xmlns: "http://www.w3.org/2000/svg",
                  viewBox: "0 0 24 24"
                }, [
                  createElementVNode("path", {
                    d: "M0 0h24v24H0z",
                    fill: "none"
                  }),
                  createElementVNode("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z" })
                ], -1)
              ]), 40, _hoisted_8$d)), [
                [_directive_tippy, {
                  placement: "bottom",
                  trigger: "click focus"
                }]
              ])
            ], 512), [
              [vShow, __props.area.description]
            ])
          ])
        ], 10, _hoisted_2$N)), [
          [_directive_focus_item]
        ])
      ]);
    };
  }
});

const AreaItem = /* @__PURE__ */ _export_sfc(_sfc_main$19, [["__scopeId", "data-v-06be115a"]]);

const _hoisted_1$Z = { class: "h-600 overflow-y-auto" };
const _hoisted_2$M = { class: "mx-5" };
const _hoisted_3$B = { key: 0 };
const _sfc_main$18 = /* @__PURE__ */ defineComponent({
  __name: "screen",
  props: {
    panel: {
      type: Object
    }
  },
  setup(__props) {
    const { t } = useI18n();
    const areasOfInterestStore = useAreasOfInterestStore();
    const areas = computed(() => areasOfInterestStore.areas);
    let showThumbnail = ref(false);
    onMounted(() => {
      showThumbnail.value = !!areas.value?.some((area) => area.thumbnail);
    });
    return (_ctx, _cache) => {
      const _component_panel_screen = resolveComponent("panel-screen");
      const _directive_focus_list = resolveDirective("focus-list");
      return openBlock(), createBlock(_component_panel_screen, { panel: __props.panel }, {
        header: withCtx(() => [
          createTextVNode(toDisplayString(unref(t)("areas-of-interest.title")), 1)
        ]),
        content: withCtx(() => [
          createElementVNode("div", _hoisted_1$Z, [
            createElementVNode("div", _hoisted_2$M, [
              areas.value.length > 0 ? withDirectives((openBlock(), createElementBlock("ul", _hoisted_3$B, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(areas.value, (area, idx) => {
                  return openBlock(), createElementBlock("li", { key: idx }, [
                    createVNode(AreaItem, {
                      area,
                      "show-thumbnail": unref(showThumbnail),
                      class: "block relative overflow-hidden"
                    }, null, 8, ["area", "show-thumbnail"])
                  ]);
                }), 128))
              ])), [
                [_directive_focus_list]
              ]) : createCommentVNode("", true)
            ])
          ])
        ]),
        _: 1
      }, 8, ["panel"]);
    };
  }
});

const screen$b = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: _sfc_main$18
}, Symbol.toStringTag, { value: 'Module' }));

const messages$g = {"en":{"areas-of-interest.title":"Areas of Interest","areas-of-interest.select":"Select area of interest"},"fr":{"areas-of-interest.title":"Zones d'intérêt","areas-of-interest.select":"Sélectionner la zone d'intérêt"}};

class AreasOfInterestAPI extends FixtureInstance {
  /**
   * Get the current areas of interest config
   */
  get config() {
    return super.config;
  }
  /**
   * Parses the areas of interest config snippet from the config json
   */
  _parseConfig(areasOfInterest) {
    if (!areasOfInterest) {
      return;
    }
    const areasOfInterestStore = useAreasOfInterestStore(this.$vApp.$pinia);
    areasOfInterestStore.areas = areasOfInterest.areas;
    this.handlePanelTeleports(["areas-of-interest"]);
  }
}

class AreasOfInterestFixture extends AreasOfInterestAPI {
  added() {
    this.$iApi.panel.register(
      {
        "areas-of-interest": {
          screens: {
            "areas-of-interest-screen": markRaw(_sfc_main$18)
          },
          style: {
            width: "350px"
          },
          button: {
            tooltip: "areas-of-interest.title",
            icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M12 10.9c-.61 0-1.1.49-1.1 1.1s.49 1.1 1.1 1.1c.61 0 1.1-.49 1.1-1.1s-.49-1.1-1.1-1.1zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm2.19 12.19L6 18l3.81-8.19L18 6l-3.81 8.19z"/></svg>'
          },
          alertName: "areas-of-interest.title"
        }
      },
      {
        i18n: { messages: messages$g }
      }
    );
    this._parseConfig(this.config);
    const unwatch = this.$vApp.$watch(
      () => this.config,
      (value) => this._parseConfig(value)
    );
    this.removed = () => {
      unwatch();
      if (this.$iApi.fixture.exists("appbar")) {
        const appbarStore = useAppbarStore(this.$vApp.$pinia);
        appbarStore.removeButton("areas-of-interest");
      }
      this.$iApi.panel.remove("areas-of-interest");
      const areasOfInterestStore = useAreasOfInterestStore(this.$vApp.$pinia);
      areasOfInterestStore.$reset();
    };
  }
}

const index$s = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: AreasOfInterestFixture
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$Y = { class: "mb-10" };
const _hoisted_2$L = ["aria-label"];
const _hoisted_3$A = {
  key: 0,
  class: "w-full h-30 hidden"
};
const _hoisted_4$n = ["alt", "src"];
const _hoisted_5$h = ["alt", "src"];
const _hoisted_6$g = ["alt"];
const _hoisted_7$g = { class: "pl-5" };
const _hoisted_8$c = { class: "ml-auto pr-5" };
const _hoisted_9$9 = ["content"];
const _hoisted_10$8 = {
  key: 0,
  class: "rv-basemap-check absolute top-0 right-0"
};
const _sfc_main$17 = /* @__PURE__ */ defineComponent({
  __name: "item",
  props: {
    basemap: {
      type: Object,
      required: true
    },
    tileSchema: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const { t } = useI18n();
    const iApi = inject("iApi");
    const configStore = useConfigStore();
    const selectedBasemap = computed(() => configStore.activeBasemapConfig);
    const selectBasemap = (basemap) => {
      if (basemap.id !== selectedBasemap.value.id) {
        iApi?.geo.map.setBasemap(basemap.id);
      }
    };
    return (_ctx, _cache) => {
      const _directive_truncate = resolveDirective("truncate");
      const _directive_tippy = resolveDirective("tippy");
      const _directive_focus_item = resolveDirective("focus-item");
      return openBlock(), createElementBlock("div", _hoisted_1$Y, [
        withDirectives((openBlock(), createElementBlock("button", {
          class: "basemap-item-button bg-gray-300 w-full h-full",
          type: "button",
          "aria-label": unref(t)("basemap.select"),
          onClick: _cache[2] || (_cache[2] = ($event) => selectBasemap(__props.basemap))
        }, [
          createElementVNode("div", null, [
            createElementVNode("div", {
              class: normalizeClass(["flex hover:opacity-50 basemap-item-image basemap-item-container", !__props.basemap.hideThumbnail ? "h-180" : "h-30"])
            }, [
              __props.basemap.hideThumbnail ? (openBlock(), createElementBlock("div", _hoisted_3$A)) : __props.basemap.thumbnailUrl ? (openBlock(), createElementBlock("img", {
                key: 1,
                class: "w-full h-180",
                alt: __props.basemap.altText,
                src: __props.basemap.thumbnailUrl
              }, null, 8, _hoisted_4$n)) : __props.tileSchema.thumbnailTileUrls && __props.tileSchema.thumbnailTileUrls.length > 0 && __props.basemap.layers.every((layer) => layer.layerType === "esri-tile") ? (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(__props.basemap.layers, (layer) => {
                return openBlock(), createElementBlock("div", {
                  key: layer.id,
                  class: "flex basemap-item-inner h-180"
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(__props.tileSchema.thumbnailTileUrls, (url, idx) => {
                    return openBlock(), createElementBlock("img", {
                      class: "w-full",
                      alt: __props.basemap.altText,
                      src: layer.url + url,
                      key: idx
                    }, null, 8, _hoisted_5$h);
                  }), 128))
                ]);
              }), 128)) : (openBlock(), createElementBlock("img", {
                key: 3,
                class: "w-full bg-white h-180",
                alt: __props.basemap.altText,
                src: "https://openclipart.org/image/800px/275366"
              }, null, 8, _hoisted_6$g))
            ], 2)
          ]),
          createElementVNode("div", {
            class: normalizeClass(["absolute flex w-full bg-black text-white h-30 bottom-6 items-center", __props.basemap.hideThumbnail && __props.basemap.id === selectedBasemap.value.id ? "opacity-85" : "opacity-75"])
          }, [
            withDirectives((openBlock(), createElementBlock("div", _hoisted_7$g, [
              createElementVNode("span", null, toDisplayString(__props.basemap.name), 1)
            ])), [
              [_directive_truncate]
            ]),
            createElementVNode("div", _hoisted_8$c, [
              withDirectives((openBlock(), createElementBlock("a", {
                onClick: _cache[0] || (_cache[0] = withModifiers(() => {
                }, ["stop"])),
                onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(() => {
                }, ["prevent"]), ["enter", "space"])),
                content: __props.basemap.description
              }, _cache[3] || (_cache[3] = [
                createElementVNode("svg", {
                  class: "fill-current w-16 h-16",
                  xmlns: "http://www.w3.org/2000/svg",
                  viewBox: "0 0 24 24"
                }, [
                  createElementVNode("path", {
                    d: "M0 0h24v24H0z",
                    fill: "none"
                  }),
                  createElementVNode("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z" })
                ], -1)
              ]), 40, _hoisted_9$9)), [
                [_directive_tippy, {
                  placement: "bottom",
                  trigger: "click focus"
                }]
              ])
            ])
          ], 2),
          __props.basemap.id === selectedBasemap.value.id && !__props.basemap.hideThumbnail ? (openBlock(), createElementBlock("div", _hoisted_10$8, _cache[4] || (_cache[4] = [
            createElementVNode("svg", {
              class: "fill-current w-25 h-25 relative",
              xmlns: "http://www.w3.org/2000/svg",
              viewBox: "0 0 24 24"
            }, [
              createElementVNode("path", { d: "M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z" })
            ], -1)
          ]))) : createCommentVNode("", true)
        ], 8, _hoisted_2$L)), [
          [_directive_focus_item]
        ])
      ]);
    };
  }
});

const BasemapItem = /* @__PURE__ */ _export_sfc(_sfc_main$17, [["__scopeId", "data-v-7cf27f80"]]);

const _hoisted_1$X = { class: "h-600 overflow-y-auto" };
const _hoisted_2$K = { class: "font-bold text-xl" };
const _hoisted_3$z = {
  key: 0,
  class: "border-t border-b border-gray-600"
};
const _sfc_main$16 = /* @__PURE__ */ defineComponent({
  __name: "screen",
  props: {
    panel: {
      type: Object
    }
  },
  setup(__props) {
    const { t } = useI18n();
    const configStore = useConfigStore();
    const tileSchemas = ref([]);
    const basemaps = ref([]);
    onMounted(() => {
      const mapConfig = configStore.config.map;
      tileSchemas.value = mapConfig.tileSchemas;
      basemaps.value = mapConfig.basemaps;
    });
    const filterBasemaps = (schemaId) => basemaps.value.filter((basemap) => basemap.tileSchemaId === schemaId);
    return (_ctx, _cache) => {
      const _component_panel_screen = resolveComponent("panel-screen");
      const _directive_truncate = resolveDirective("truncate");
      const _directive_focus_list = resolveDirective("focus-list");
      return openBlock(), createBlock(_component_panel_screen, { panel: __props.panel }, {
        header: withCtx(() => [
          createTextVNode(toDisplayString(unref(t)("basemap.title")), 1)
        ]),
        content: withCtx(() => [
          createElementVNode("div", _hoisted_1$X, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(tileSchemas.value, (tileSchema, idx) => {
              return openBlock(), createElementBlock("div", {
                class: "mx-5",
                key: tileSchema.id
              }, [
                createElementVNode("div", {
                  class: normalizeClass((idx === 0 ? "mt-5" : "mt-36") + " flex mb-5")
                }, [
                  withDirectives((openBlock(), createElementBlock("h3", _hoisted_2$K, [
                    createTextVNode(toDisplayString(tileSchema.name), 1)
                  ])), [
                    [_directive_truncate]
                  ])
                ], 2),
                basemaps.value.length > 0 ? withDirectives((openBlock(), createElementBlock("ul", _hoisted_3$z, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(filterBasemaps(tileSchema.id), (basemap) => {
                    return openBlock(), createElementBlock("li", {
                      key: basemap.id
                    }, [
                      createVNode(BasemapItem, {
                        basemap,
                        tileSchema,
                        class: "block relative overflow-hidden"
                      }, null, 8, ["basemap", "tileSchema"])
                    ]);
                  }), 128))
                ])), [
                  [_directive_focus_list]
                ]) : createCommentVNode("", true)
              ]);
            }), 128))
          ])
        ]),
        _: 1
      }, 8, ["panel"]);
    };
  }
});

const screen$a = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: _sfc_main$16
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$15 = /* @__PURE__ */ defineComponent({
  __name: "nav-button",
  setup(__props) {
    const { t } = useI18n();
    const iApi = inject("iApi");
    const togglePanel = () => iApi?.panel.toggle("basemap");
    return (_ctx, _cache) => {
      const _component_mapnav_button = resolveComponent("mapnav-button");
      return openBlock(), createBlock(_component_mapnav_button, {
        onClickFunction: togglePanel,
        tooltip: unref(t)("basemap.title")
      }, {
        default: withCtx(() => _cache[0] || (_cache[0] = [
          createElementVNode("svg", {
            class: "fill-current w-32 h-20",
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24"
          }, [
            createElementVNode("path", {
              d: "M0 0h24v24H0z",
              fill: "none"
            }),
            createElementVNode("path", { d: "M20.5 3l-.16.03L15 5.1 9 3 3.36 4.9c-.21.07-.36.25-.36.48V20.5c0 .28.22.5.5.5l.16-.03L9 18.9l6 2.1 5.64-1.9c.21-.07.36-.25.36-.48V3.5c0-.28-.22-.5-.5-.5zM15 19l-6-2.11V5l6 2.11V19z" })
          ], -1)
        ])),
        _: 1
      }, 8, ["tooltip"]);
    };
  }
});

const messages$f = {"en":{"basemap.select":"Select basemap","basemap.title":"Basemap"},"fr":{"basemap.select":"Sélectionner la carte de base","basemap.title":"Carte de base"}};

class BasemapFixture extends FixtureInstance {
  added() {
    this.$iApi.component("basemap-nav-button", _sfc_main$15);
    this.$iApi.panel.register(
      {
        id: "basemap",
        config: {
          screens: { "basemap-component": markRaw(_sfc_main$16) },
          button: {
            tooltip: "basemap.title",
            icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.5 3l-.16.03L15 5.1 9 3 3.36 4.9c-.21.07-.36.25-.36.48V20.5c0 .28.22.5.5.5l.16-.03L9 18.9l6 2.1 5.64-1.9c.21-.07.36-.25.36-.48V3.5c0-.28-.22-.5-.5-.5zM15 19l-6-2.11V5l6 2.11V19z"/><path d="M0 0h24v24H0z" fill="none" /></svg>'
          },
          alertName: "basemap.title"
        }
      },
      { i18n: { messages: messages$f } }
    );
    this.handlePanelTeleports(["basemap"]);
  }
  removed() {
    if (this.$iApi.fixture.exists("appbar")) {
      const appbarStore = useAppbarStore(this.$vApp.$pinia);
      appbarStore.removeButton("basemap");
    }
    if (this.$iApi.fixture.exists("mapnav")) {
      const mapnavStore = useMapnavStore(this.$vApp.$pinia);
      mapnavStore.removeItem("basemap");
    }
    this.$iApi.panel.remove("basemap");
  }
}

const index$r = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: BasemapFixture
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$14 = /* @__PURE__ */ defineComponent({
  __name: "crosshairs",
  setup(__props) {
    const iApi = inject("iApi");
    const visible = ref(false);
    const handlers = ref([]);
    onMounted(() => {
      handlers.value.push(
        iApi.event.on(GlobalEvents.MAP_EXTENTCHANGE, () => {
          if (iApi.geo.map.keysActive) {
            visible.value = true;
          }
        })
      );
      handlers.value.push(
        iApi.event.on(GlobalEvents.MAP_FOCUS, () => {
          if (!iApi.geo.map.mouseFocus) {
            visible.value = true;
          }
        })
      );
      handlers.value.push(
        iApi.event.on(GlobalEvents.MAP_MOUSEDOWN, () => {
          visible.value = false;
        })
      );
      handlers.value.push(
        iApi.event.on(GlobalEvents.MAP_BLUR, () => {
          visible.value = false;
        })
      );
    });
    onBeforeUnmount(() => {
      handlers.value.forEach((h) => iApi.event.off(h));
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["crosshairs absolute duration-150 top-1/2 left-1/2 h-230 w-230", { "opacity-0": !visible.value }])
      }, _cache[0] || (_cache[0] = [
        createElementVNode("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          fit: "",
          height: "100%",
          width: "100%",
          preserveAspectRatio: "xMidYMid meet",
          viewBox: "0 0 24 24",
          focusable: "false"
        }, [
          createElementVNode("g", {
            fill: "#545353",
            stroke: "#fff",
            id: "crosshairs"
          }, [
            createElementVNode("ellipse", {
              ry: ".254",
              rx: ".262",
              id: "path3808",
              cx: "12",
              cy: "12",
              "stroke-width": ".076"
            }),
            createElementVNode("path", {
              d: "M.045 12.047l6.093.051 4.264.068v-.332l-4.264.067-6.093.064v.039z",
              id: "rect4632-6",
              "stroke-width": ".09"
            }),
            createElementVNode("path", {
              d: "M12.047 23.955l.051-6.093.068-4.264h-.332l.067 4.264.064 6.093h.039z",
              id: "rect4632-6-0",
              "stroke-width": ".09"
            }),
            createElementVNode("path", {
              d: "M23.955 11.953l-6.093-.051-4.264-.068v.332l4.264-.067 6.093-.064v-.039z",
              id: "rect4632-6-4",
              "stroke-width": ".09"
            }),
            createElementVNode("path", {
              d: "M11.953.045l-.051 6.093-.068 4.264h.332l-.067-4.264-.064-6.093h-.039z",
              id: "rect4632-6-9",
              "stroke-width": ".09"
            })
          ])
        ], -1)
      ]), 2);
    };
  }
});

const CrosshairsV = /* @__PURE__ */ _export_sfc(_sfc_main$14, [["__scopeId", "data-v-55a2f166"]]);

class CrosshairsFixture extends FixtureInstance {
  added() {
    const { destroy, el } = this.mount(CrosshairsV, {
      app: this.$element
    });
    const innerShell = this.$vApp.$el.getElementsByClassName("inner-shell")[0];
    innerShell.appendChild(el.childNodes[0]);
    this.removed = () => {
      destroy();
    };
  }
}

const index$q = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: CrosshairsFixture
}, Symbol.toStringTag, { value: 'Module' }));

const HILIGHT_LAYER_NAME = "Ramp-Hilight";
const FOG_HILIGHT_LAYER_NAME = "Ramp-Hilight-Fog-Basemap";
const DEFAULT_CONFIG = {
  mode: "glow",
  options: {
    haloColor: [0, 255, 0],
    // lime green
    haloOpacity: 0.8
  }
};
var HilightMode = /* @__PURE__ */ ((HilightMode2) => {
  HilightMode2["NONE"] = "none";
  HilightMode2["GLOW"] = "glow";
  HilightMode2["LIFT"] = "lift";
  HilightMode2["FOG"] = "fog";
  return HilightMode2;
})(HilightMode || {});

const ORIGIN_DETAILS = "details";
class DetailsAPI extends FixtureInstance {
  detailsStore = useDetailsStore(this.$vApp.$pinia);
  get config() {
    return super.config;
  }
  /**
   * Updates the identify result in the store, and then opens the details panel.
   *
   * @param {IdentifyResult[]} payload
   * @memberof DetailsAPI
   */
  openDetails(payload) {
    this.detailsStore.payload = payload;
    const panel = this.$iApi.panel.get("details");
    this.detailsStore.origin = "identify";
    panel.button.tooltip = "details.layers.title.identifyOrigin";
    payload.forEach((p) => {
      const layer = this.$iApi.useStore("layer").getLayerByUid(p.uid);
      this._loadDetailsConfig(layer);
    });
    const detailsPanel = this.$iApi.panel.get("details");
    if (!detailsPanel.isOpen) {
      this.$iApi.panel.open({
        id: "details"
      });
    }
  }
  /**
   * Provided with the data for a single feature, shows or hides details panel.
   * If panel is closed or incoming data is different than current content, panel is shown.
   * If panel open and incoming data is what is currently shown, panel closes.
   * The `open` parameter can override the behavior.
   * featureData payload (can be empty if forcing closed)
   * - uid     : uid string of the layer hosting the feature
   * - format  : structure of the data. IdentifyResultFormat value.
   * - data    : source information for the feature. Analogous to the data property of an IdentifyItem
   * - layerId : optional layerId string of the layer hosting the feature. Will be looked up if not provided
   *
   * @param {{data: any, uid: string, format: IdentifyResultFormat}} featureData
   * @param {boolean | undefined} open can force the panel to open (true) or close (false) regardless of current panel state
   * @memberof DetailsAPI
   */
  toggleFeature(featureData, open) {
    const panel = this.$iApi.panel.get("details");
    if (open === false) {
      panel.close();
      this.detailsStore.currentFeatureId = void 0;
      return;
    }
    const layer = this.$iApi.geo.layer.getLayer(featureData.uid);
    const currFeatureId = `${featureData.uid}-${// see https://github.com/ramp4-pcar4/ramp4-pcar4/issues/1767 for the reasoning behind this
    layer?.supportsFeatures ? featureData.data[layer?.oidField ?? ""] : JSON.stringify(featureData.data)}`;
    if (panel.isOpen && currFeatureId === this.detailsStore.currentFeatureId && !(open === true)) {
      panel.close();
      this.detailsStore.currentFeatureId = void 0;
      return;
    }
    this.detailsStore.origin = "toggleEvent";
    panel.button.tooltip = "details.layers.title.gridOrigin";
    this.detailsStore.currentFeatureId = currFeatureId;
    this._loadDetailsConfig(layer);
    const fakeResult = {
      items: [ReactiveIdentifyFactory.makeRawItem(featureData.format, featureData.data)],
      uid: featureData.uid,
      layerId: featureData.layerId || layer?.id || "error-not-found",
      loading: Promise.resolve(),
      loaded: true,
      errored: false,
      requestTime: Date.now()
    };
    this.detailsStore.payload = [fakeResult];
    if (!panel.isOpen) {
      panel.open();
    }
  }
  /**
   * Read the details section of the layers' fixture config
   *
   * @param {DetailsConfig} [config]
   * @memberof DetailsAPI
   */
  _parseConfig(config) {
    if (config && config.templates) {
      this.detailsStore.defaultTemplates = config.templates;
    }
    this.handlePanelWidths(["details"]);
    this.handlePanelTeleports(["details"]);
    const layerDetailsConfigs = this.getLayerFixtureConfigs();
    const detailsConfigItems = [];
    Object.keys(layerDetailsConfigs).forEach((layerId) => {
      detailsConfigItems.push({
        id: layerId,
        name: layerDetailsConfigs[layerId].name,
        template: layerDetailsConfigs[layerId].template,
        fields: layerDetailsConfigs[layerId].fields
      });
    });
    const detailsItems = detailsConfigItems.map((item) => new DetailsItemInstance(item));
    this.detailsStore.properties = detailsItems.reduce((map, item) => {
      map[item.id] = item;
      return map;
    }, {});
    this._validateItems();
  }
  _loadDetailsConfig(layer) {
    if (layer) {
      const detailsItem = this.detailsStore.properties[layer.id];
      if (detailsItem === void 0) {
        const layerDetailsConfigs = this.getLayerFixtureConfigs();
        if (layerDetailsConfigs[layer.id] !== void 0) {
          this.detailsStore.addConfigProperty({
            id: layer.id,
            name: layerDetailsConfigs[layer.id].name,
            template: layerDetailsConfigs[layer.id].template,
            fields: layerDetailsConfigs[layer.id].fields
          });
        }
      }
    }
  }
  /**
   * Check to see if the stored components are registered properly.
   *
   * @memberof DetailsAPI
   */
  _validateItems() {
    Object.values(this.detailsStore.properties).forEach((item) => {
      if (item.template in this.$vApp.$options.components) {
        this.detailsStore.properties[item.id].componentId = item.template;
      }
    });
  }
  /**
   * Highlight identified items
   * @param items items to add
   * @param layerUid uid of layer the items belong to
   */
  async hilightDetailsItems(items, layerUid) {
    const hItems = items instanceof Array ? items : [items];
    const hilightFix = this.$iApi.fixture.get("hilight");
    if (hilightFix) {
      const gsByKey = await hilightFix.getGraphicsByKey(ORIGIN_DETAILS);
      await hilightFix.removeHilight(gsByKey);
      const thisHighlight = Date.now();
      this.detailsStore.lastHilight = thisHighlight;
      const graphics = await this.getHilightGraphics(hItems, layerUid);
      if (this.detailsStore.lastHilight === thisHighlight) {
        await hilightFix.addHilight(graphics);
        if (this.detailsStore.lastHilight !== thisHighlight) {
          hilightFix.removeHilight(graphics);
        }
      }
    }
  }
  /**
   * Remove all details panel map hilights.
   */
  async removeDetailsHilight() {
    const hilightFix = this.$iApi.fixture.get("hilight");
    if (hilightFix) {
      this.detailsStore.lastHilight = Date.now();
      const gsByKey = await hilightFix.getGraphicsByKey(ORIGIN_DETAILS);
      await hilightFix.removeHilight(gsByKey);
    }
  }
  /**
   * Reload map elements of the hilighter for a set of identify items.
   *
   * @param {IdentifyItem | Array<IdentifyItem>} items items to reload
   * @param {string} layerUid uid of layer the items belong to
   */
  async reloadDetailsHilight(items, layerUid) {
    const hItems = items instanceof Array ? items : [items];
    const hilightFix = this.$iApi.fixture.get("hilight");
    if (hilightFix) {
      const graphics = await this.getHilightGraphics(hItems, layerUid);
      hilightFix.reloadHilight(graphics);
    }
  }
  /**
   * Return the graphics of the given IdentifyItems once the items have loaded.
   * @param {Array<IdentifyItem>} items identify items to hilight. Items should be of ESRI format
   * @param layerUid uid of layer the items belong to
   * @returns {Promise<Array<Graphic>>} resolves with array of graphics
   */
  async getHilightGraphics(items, layerUid) {
    const layer = this.$iApi.geo.layer.getLayer(layerUid);
    const hilightFix = this.$iApi.fixture.get("hilight");
    const gs = [];
    if (layer) {
      await Promise.all(
        items.map(async (item) => {
          await item.loading;
          const oid = item.data[layer.oidField];
          const g = await layer.getGraphic(oid, {
            getGeom: true,
            getAttribs: true,
            getStyle: true
          });
          g.id = hilightFix.constructGraphicKey(ORIGIN_DETAILS, layerUid, oid);
          gs.push(g);
        })
      );
    }
    return gs;
  }
  /**
   * Updates hilighted graphics when the hilight toggler is toggled.
   *
   * @param {boolean} hilightOn Whether the toggler has been turned on/off
   * @param {IdentifyItem | Array<IdentifyItem>} items The identify items to highlight. Only required if turning on
   * @param {string} layerUid the layer UID that owns the items. Only required if turning on
   */
  onHilightToggle(hilightOn, items, layerUid) {
    this.detailsStore.hilightToggle = hilightOn;
    if (hilightOn && items && layerUid) {
      this.hilightDetailsItems(items, layerUid);
    } else if (!hilightOn) {
      this.removeDetailsHilight();
    }
  }
  /**
   * Return whether or not a HilightMode has been defined (other than NONE)
   */
  hasHilighter() {
    const hilightFix = this.$iApi.fixture.get("hilight");
    return hilightFix && hilightFix.hilightMode.mode !== HilightMode.NONE;
  }
}

const _hoisted_1$W = {
  key: 0,
  class: "relative"
};
const _hoisted_2$J = {
  key: 0,
  class: "relative"
};
const _hoisted_3$y = ["innerHTML"];
const _hoisted_4$m = ["src"];
const _hoisted_5$g = {
  key: 1,
  class: "w-32 h-32"
};
const _hoisted_6$f = { class: "symbologyIcon" };
const _hoisted_7$f = ["innerHTML"];
const _hoisted_8$b = ["src"];
const _hoisted_9$8 = { class: "badge z-50 rounded-full text-white absolute h-10 w-10 p-8 inline-flex items-center justify-center" };
const _hoisted_10$7 = {
  key: 0,
  class: "px-5"
};
const _hoisted_11$7 = {
  key: 1,
  class: "inline-flex justify-center items-center relative"
};
const _sfc_main$13 = /* @__PURE__ */ defineComponent({
  __name: "symbology-stack",
  props: {
    layer: { type: Object, required: true },
    result: { type: Object, required: true }
  },
  setup(__props) {
    const props = __props;
    const stack = ref([]);
    onMounted(() => {
      stack.value = props.layer.legend;
    });
    return (_ctx, _cache) => {
      return __props.result.loaded ? (openBlock(), createElementBlock("div", _hoisted_1$W, [
        createElementVNode("div", {
          class: normalizeClass(__props.result.items.length === 0 ? "opacity-50" : "")
        }, [
          stack.value.length > 1 ? (openBlock(), createElementBlock("div", _hoisted_2$J, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(stack.value.slice(0, 3).reverse(), (item, idx) => {
              return openBlock(), createElementBlock("div", {
                class: normalizeClass(["absolute", [idx == 0 ? "symbol-0" : idx == 1 ? "left-3" : "left-6"]]),
                style: normalizeStyle({ "z-index": 3 - idx }),
                key: idx
              }, [
                stack.value[idx].svgcode ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  class: "symbologyIcon w-28 h-28",
                  innerHTML: stack.value[idx].svgcode
                }, null, 8, _hoisted_3$y)) : stack.value[idx].imgUrl ? (openBlock(), createElementBlock("img", {
                  key: 1,
                  class: "symbologyIcon w-28 h-28",
                  src: stack.value[idx].imgUrl
                }, null, 8, _hoisted_4$m)) : createCommentVNode("", true)
              ], 6);
            }), 128))
          ])) : stack.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_5$g, [
            createElementVNode("div", _hoisted_6$f, [
              stack.value[0].svgcode ? (openBlock(), createElementBlock("span", {
                key: 0,
                innerHTML: stack.value[0].svgcode
              }, null, 8, _hoisted_7$f)) : stack.value[0].imgUrl ? (openBlock(), createElementBlock("img", {
                key: 1,
                class: "symbologyIcon w-full h-full",
                src: stack.value[0].imgUrl
              }, null, 8, _hoisted_8$b)) : createCommentVNode("", true)
            ])
          ])) : createCommentVNode("", true)
        ], 2),
        createElementVNode("div", _hoisted_9$8, [
          __props.result.loaded ? (openBlock(), createElementBlock("div", _hoisted_10$7, toDisplayString(__props.result.items.length), 1)) : createCommentVNode("", true)
        ])
      ])) : (openBlock(), createElementBlock("div", _hoisted_11$7, _cache[0] || (_cache[0] = [
        createElementVNode("div", { class: "symbologyIcon h-32 w-32" }, [
          createElementVNode("div", { class: "relative animate-spin spinner h-24 w-24" })
        ], -1)
      ])));
    };
  }
});

const SymbologyStack$1 = /* @__PURE__ */ _export_sfc(_sfc_main$13, [["__scopeId", "data-v-496d788d"]]);

const _hoisted_1$V = ["content"];
const _hoisted_2$I = { class: "symbologyLayerName truncate" };
const _sfc_main$12 = /* @__PURE__ */ defineComponent({
  __name: "symbology-item",
  props: {
    layer: { type: Object, required: true },
    result: { type: Object, required: true },
    selected: { type: Boolean, required: true }
  },
  setup(__props) {
    const detailsStore = useDetailsStore();
    const detailProperties = computed(() => detailsStore.properties);
    const props = __props;
    const layerName = () => {
      const layer = props.layer;
      if (layer && detailProperties.value[layer.id] && detailProperties.value[layer.id].name) {
        return detailProperties.value[layer.id].name;
      }
      return layer?.name ?? "";
    };
    return (_ctx, _cache) => {
      const _directive_tippy = resolveDirective("tippy");
      return withDirectives((openBlock(), createElementBlock("button", {
        class: normalizeClass(["flex flex-grow justify-start items-center px-7 py-10 default-focus-style symbologyStackButton truncate", __props.selected ? "detailsButtonSelected" : "px-11"]),
        onClick: _cache[0] || (_cache[0] = withModifiers(() => {
        }, ["stop"])),
        content: layerName()
      }, [
        createVNode(SymbologyStack$1, {
          class: "symbStack w-32 h-32 mr-10",
          layer: __props.layer,
          result: __props.result
        }, null, 8, ["layer", "result"]),
        createElementVNode("div", _hoisted_2$I, toDisplayString(layerName()), 1)
      ], 10, _hoisted_1$V)), [
        [_directive_tippy, { placement: "right", sticky: true }]
      ]);
    };
  }
});

const _hoisted_1$U = ["content"];
const _sfc_main$11 = /* @__PURE__ */ defineComponent({
  __name: "symbology-list",
  props: {
    results: { type: Object, required: true },
    selected: { type: String, required: true }
  },
  emits: ["selection-changed"],
  setup(__props, { emit: __emit }) {
    const { t } = useI18n();
    const layerStore = useLayerStore();
    const el = ref();
    const blurEvent = () => {
      el.value._tippy.hide();
    };
    const keyupEvent = (e) => {
      const evt = e;
      if (evt.key === "Tab" && el.value?.matches(":focus")) {
        el.value._tippy.show();
      }
    };
    const emit = __emit;
    const props = __props;
    const selectedLayer = ref("");
    const watchers = ref([]);
    const expanded = ref(false);
    const hovering = ref(false);
    const getLayerInfo = (uid) => {
      let layer = layerStore.getLayerByUid(uid);
      return layer;
    };
    const handleItemClick = (uid) => {
      selectedLayer.value = uid;
      emit("selection-changed", uid);
      expanded.value = false;
    };
    const handleMouseOver = () => {
      if (!hovering.value) {
        setTimeout(() => {
          expanded.value = hovering.value;
        }, 500);
      }
      hovering.value = true;
    };
    const handleMouseLeave = () => {
      expanded.value = hovering.value = false;
    };
    const handleItemFocus = () => {
      if (!hovering.value) {
        expanded.value = true;
      }
      hovering.value = true;
    };
    const handleItemBlur = () => {
      expanded.value = hovering.value = false;
    };
    onBeforeMount(() => {
      watchers.value.push(
        watch(props, () => {
          selectedLayer.value = props.selected;
        })
      );
    });
    onMounted(() => {
      el.value?.addEventListener("blur", blurEvent);
      el.value?.addEventListener("keyup", keyupEvent);
    });
    onBeforeUnmount(() => {
      watchers.value.forEach((unwatch) => unwatch());
      el.value?.removeEventListener("blur", blurEvent);
      el.value?.removeEventListener("keyup", keyupEvent);
    });
    return (_ctx, _cache) => {
      const _directive_focus_item = resolveDirective("focus-item");
      const _directive_focus_list = resolveDirective("focus-list");
      const _directive_tippy = resolveDirective("tippy");
      return withDirectives((openBlock(), createElementBlock("div", {
        class: normalizeClass(["symbology-list absolute overflow-hidden z-50 p-0 w-48 bg-white text-sm inline-flex flex-col", { "symbology-list-expanded": expanded.value }]),
        onMouseover: handleMouseOver,
        onMouseleave: handleMouseLeave,
        onFocus: handleItemFocus,
        onBlur: withModifiers(handleItemBlur, ["self"]),
        content: unref(t)("details.layers.results.list.tooltip"),
        ref_key: "el",
        ref: el
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(props.results, (item, idx) => {
          return openBlock(), createElementBlock("div", {
            class: "flex justify-start relative",
            key: idx
          }, [
            withDirectives((openBlock(), createBlock(_sfc_main$12, {
              key: item.uid,
              layer: getLayerInfo(item.uid),
              result: item,
              selected: item.uid === selectedLayer.value,
              onClick: ($event) => handleItemClick(item.uid)
            }, null, 8, ["layer", "result", "selected", "onClick"])), [
              [_directive_focus_item]
            ])
          ]);
        }), 128))
      ], 42, _hoisted_1$U)), [
        [_directive_focus_list],
        [_directive_tippy, {
          trigger: "manual",
          placement: "top-start"
        }]
      ]);
    };
  }
});

const _hoisted_1$T = { class: "inline font-bold" };
const _hoisted_2$H = ["innerHTML"];
const _sfc_main$10 = /* @__PURE__ */ defineComponent({
  __name: "esri-default",
  props: {
    fixtureFields: {
      type: Object,
      required: false
    },
    fields: {
      type: Object,
      required: true
    },
    identifyData: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const { t } = useI18n();
    const iApi = inject("iApi");
    const props = __props;
    const findAndDelete = (fields, propertyType, property, helper) => {
      const field = fields.find((f) => f[propertyType].toLowerCase() === property.toLowerCase());
      if (field) delete helper[field.name];
    };
    const itemData = () => {
      const clonePayload = Object.assign({}, props.identifyData.data);
      findAndDelete(props.fields, "type", "geometry", clonePayload);
      if (!iApi?.ui.exposeOids) {
        findAndDelete(props.fields, "type", "oid", clonePayload);
      }
      if (!iApi?.ui.exposeMeasurements) {
        findAndDelete(props.fields, "name", "shape_length", clonePayload);
        findAndDelete(props.fields, "name", "shape_area", clonePayload);
      }
      const fieldsMetadata = {};
      props.fields.forEach((field) => {
        const checkField = props.fixtureFields?.find((item) => field.name === item.field);
        fieldsMetadata[field.name] = {
          name: checkField?.alias || field.alias || field.name,
          type: field.type,
          visible: checkField?.visible ?? true
        };
      });
      const displayMetadata = {};
      Object.keys(clonePayload).forEach((key) => {
        const fieldMD = fieldsMetadata[key];
        if (fieldMD && fieldMD.visible) {
          const cloneValue = clonePayload[key];
          displayMetadata[key] = {
            value: typeof cloneValue === "number" ? iApi?.ui.formatNumber(cloneValue) : cloneValue,
            alias: fieldMD.name,
            type: fieldMD.type
          };
        }
      });
      for (const [key] of Object.entries(displayMetadata)) {
        if (iApi.ui.isPlainText(displayMetadata[key].value)) {
          displayMetadata[key].value = iApi.ui.escapeHtml(displayMetadata[key].value);
        }
      }
      return displayMetadata;
    };
    const formatValues = (html, alias, type) => {
      switch (type) {
        case "date":
          return makeDate(html);
        default:
          return makeHtmlLink(html, alias);
      }
    };
    const makeHtmlLink = (html, alias) => {
      if (!html) {
        return html;
      }
      if (!!html.trim().match(/\.(jpeg|jpg|gif|png)$/) || !!html.trim().match(
        /^\s*data:([a-z]+\/[a-z]+(;[a-z\-]+\=[a-z\-]+)?)?(;base64)?,[a-z0-9\!\$\&\'\,\(\)\*\+\,\;\=\-\.\_\~\:\@\/\?\%\s]*\s*$/i
        //eslint-disable-line
      )) {
        return `<img src="${html}" alt="${t("details.item.alert.defaultAltText", { alias })}" />`;
      }
      const classes = "underline text-blue-700 break-all";
      const div = document.createElement("div");
      div.innerHTML = html.trim();
      if (div.firstElementChild?.tagName == "A") {
        div.firstElementChild.className = classes;
        return div.innerHTML;
      } else {
        const options = {
          className: classes,
          target: "_blank",
          validate: {
            url: (value) => /^https?:\/\//.test(value)
            // only links that begin with a protocol will be hyperlinked
          }
        };
        return linkifyHtml(html, options);
      }
    };
    const makeDate = (html) => {
      const numericDate = parseInt(html);
      if (isNaN(numericDate)) {
        return html;
      }
      const formattedDate = new Date(numericDate);
      return formattedDate.toISOString().split("T")[0];
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(itemData(), (val, name, itemIdx) => {
          return openBlock(), createElementBlock("div", {
            class: "p-5 pl-3 flex justify-end flex-wrap even:bg-gray-300",
            key: itemIdx
          }, [
            createElementVNode("span", _hoisted_1$T, toDisplayString(val.alias), 1),
            _cache[0] || (_cache[0] = createElementVNode("span", { class: "flex-auto" }, null, -1)),
            createElementVNode("span", {
              class: "inline",
              innerHTML: formatValues(val.value, val.alias, val.type)
            }, null, 8, _hoisted_2$H)
          ]);
        }), 128))
      ]);
    };
  }
});

const _hoisted_1$S = ["innerHTML"];
const _hoisted_2$G = { key: 1 };
const _sfc_main$$ = /* @__PURE__ */ defineComponent({
  __name: "html-default",
  props: {
    identifyData: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      return __props.identifyData ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "whitespace-pre-wrap break-words h-full overflow-auto",
        innerHTML: __props.identifyData.data.data ?? __props.identifyData.data
      }, null, 8, _hoisted_1$S)) : (openBlock(), createElementBlock("div", _hoisted_2$G, toDisplayString(unref(t)("details.layers.results.empty")), 1));
    };
  }
});

const _hoisted_1$R = { class: "relative flex flex-grow truncate" };
const _hoisted_2$F = {
  key: 0,
  class: "flex flex-grow items-center truncate"
};
const _hoisted_3$x = { class: "flex p-8 items-center" };
const _hoisted_4$l = ["innerHTML"];
const _hoisted_5$f = {
  key: 1,
  class: "symbologyIcon p-6"
};
const _hoisted_6$e = ["content", "innerHTML", "tabindex"];
const _hoisted_7$e = {
  key: 1,
  class: "flex p-6 flex-grow"
};
const _hoisted_8$a = {
  key: 2,
  class: "zoomButton text-center p-3"
};
const _hoisted_9$7 = ["content", "aria-label"];
const _hoisted_10$6 = {
  key: 0,
  class: "m-auto animate-spin spinner h-20 w-20"
};
const _hoisted_11$6 = {
  key: 1,
  xmlns: "http://www.w3.org/2000/svg",
  fill: "none",
  viewBox: "0 0 24 24",
  "stroke-width": "1.5",
  stroke: "green",
  class: "m-auto w-20 h-20"
};
const _hoisted_12$6 = {
  key: 2,
  xmlns: "http://www.w3.org/2000/svg",
  fill: "none",
  viewBox: "0 0 24 24",
  "stroke-width": "1.5",
  stroke: "red",
  class: "m-auto w-20 h-20"
};
const _hoisted_13$5 = ["innerHTML"];
const _sfc_main$_ = /* @__PURE__ */ defineComponent({
  __name: "result-item",
  props: {
    uid: { type: String, required: true },
    data: { type: Object, required: true },
    open: { type: Boolean, required: false },
    inList: { type: Boolean, required: false }
  },
  setup(__props) {
    const layerStore = useLayerStore();
    const props = __props;
    const iApi = inject("iApi");
    const watchers = ref([]);
    const detailsStore = useDetailsStore();
    const { t } = useI18n();
    const icon = ref("");
    const zoomStatus = ref("none");
    const zoomButton = ref();
    const getLayerInfo = () => {
      let layer = layerStore.getLayerByUid(props.uid);
      return layer;
    };
    const detailProperties = computed(() => detailsStore.properties);
    const defaultTemplates = computed(() => detailsStore.defaultTemplates);
    const supportsFeatures = computed(() => {
      return getLayerInfo()?.supportsFeatures ?? false;
    });
    const isMapLayer = computed(() => {
      return getLayerInfo()?.mapLayer ?? false;
    });
    const itemName = computed(() => {
      const nameField = getLayerInfo()?.nameField;
      let returnValue = nameField && props.data.loaded ? props.data.data[nameField] : iApi.$i18n.t("details.items.title");
      if (iApi.ui.isPlainText(returnValue)) {
        returnValue = iApi.ui.escapeHtml(returnValue);
      }
      return returnValue;
    });
    const makeHtmlLink = (html) => {
      if (typeof html === "string") {
        const classes = "underline text-blue-700 break-all";
        const div = document.createElement("div");
        div.innerHTML = html.trim();
        if (div.firstElementChild?.tagName == "A") {
          div.firstElementChild.className = classes;
          return div.innerHTML;
        } else {
          const options = {
            className: classes,
            target: "_blank",
            validate: {
              url: (value) => /^https?:\/\//.test(value)
              // only links that begin with a protocol will be hyperlinked
            }
          };
          return linkifyHtml(html, options);
        }
      }
      return html;
    };
    const itemChanged = () => {
      updateZoomStatus("none");
      if (props.data.loaded) {
        fetchIcon();
      } else {
        props.data.load().then(() => {
          fetchIcon();
        });
      }
    };
    const fetchIcon = () => {
      icon.value = "";
      if (!(props.data && props.data.loaded)) {
        return;
      }
      const layer = getLayerInfo();
      if (layer === void 0) {
        console.warn(`could not find layer for uid ${props.uid} during icon lookup`);
        return;
      }
      if (layer.supportsFeatures) {
        const oidField = layer.oidField;
        layer.getIcon(props.data.data[oidField]).then((value) => {
          icon.value = value;
        });
      }
    };
    const detailsTemplate = computed(() => {
      const layer = getLayerInfo();
      if (layer && detailProperties.value[layer.id] && detailProperties.value[layer.id].template) {
        return detailProperties.value[layer.id].template;
      }
      if (defaultTemplates.value && defaultTemplates.value[props.data.format]) {
        return defaultTemplates.value[props.data.format];
      }
      if (!supportsFeatures.value) {
        return _sfc_main$$;
      } else {
        return _sfc_main$10;
      }
    });
    const fieldsList = computed(() => {
      if (!supportsFeatures.value) {
        return [];
      }
      const layer = getLayerInfo();
      const fields = layer?.fields;
      return fields || [];
    });
    const fixtureFields = computed(() => {
      const layer = getLayerInfo();
      if (layer && detailProperties.value[layer.id] && detailProperties.value[layer.id].fields) {
        return detailProperties.value[layer.id].fields;
      }
      return void 0;
    });
    const updateZoomStatus = (value) => {
      if (value === "zoomed" || value === "error") {
        setTimeout(() => {
          zoomStatus.value = value;
          zoomButton.value?._tippy.show();
          setTimeout(() => {
            zoomButton.value?._tippy.hide();
            zoomStatus.value = "none";
          }, 3e3);
        }, 300);
      } else {
        zoomStatus.value = value;
      }
    };
    const zoomToFeature = () => {
      if (zoomStatus.value !== "none") {
        return;
      }
      updateZoomStatus("zooming");
      const layer = getLayerInfo();
      if (layer === void 0 || !layer.isLoaded) {
        console.warn(`Could not find layer for uid ${props.uid} during zoom geometry lookup`);
        updateZoomStatus("error");
        return;
      }
      if (!props.data.loaded) {
        console.warn("Details zoomToFeature call on item that is still loading. Should be impossible, alert the devs.");
        updateZoomStatus("error");
        return;
      }
      const oid = props.data.data[layer.oidField];
      const zoomUsingGraphic = () => {
        const opts = { getGeom: true };
        layer.getGraphic(oid, opts).then((g) => {
          if (g.geometry.invalid()) {
            console.error(`Could not find graphic for objectid ${oid}`);
            updateZoomStatus("error");
          } else {
            iApi.geo.map.zoomMapTo(g.geometry);
            updateZoomStatus("zoomed");
            iApi.updateAlert(iApi.$i18n.t("details.item.alert.zoom"));
          }
        }).catch(() => {
          updateZoomStatus("error");
        });
      };
      if (layer.layerType === LayerType.FEATURE && layer.geomType !== GeometryType.POINT) {
        layer.getGraphicExtent(oid).then((e) => {
          iApi.geo.map.zoomMapTo(e);
          updateZoomStatus("zoomed");
          iApi.updateAlert(iApi.$i18n.t("details.item.alert.zoom"));
        }).catch(() => {
          zoomUsingGraphic();
        });
      } else {
        zoomUsingGraphic();
      }
    };
    onBeforeMount(() => {
      watchers.value.push(
        watch(
          props,
          () => {
            itemChanged();
          },
          {
            deep: false,
            immediate: true
          }
        )
      );
    });
    onBeforeUnmount(() => {
      watchers.value.forEach((unwatch) => unwatch());
    });
    return (_ctx, _cache) => {
      const _directive_truncate = resolveDirective("truncate");
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock(Fragment, null, [
        createElementVNode("div", _hoisted_1$R, [
          supportsFeatures.value ? (openBlock(), createElementBlock("div", _hoisted_2$F, [
            createElementVNode("div", _hoisted_3$x, [
              __props.data.loaded && icon.value ? (openBlock(), createElementBlock("span", {
                key: 0,
                class: "flex-none symbologyIcon",
                innerHTML: icon.value
              }, null, 8, _hoisted_4$l)) : (openBlock(), createElementBlock("div", _hoisted_5$f, _cache[1] || (_cache[1] = [
                createElementVNode("div", { class: "animate-spin spinner h-20 w-20" }, null, -1)
              ])))
            ]),
            __props.data.loaded ? withDirectives((openBlock(), createElementBlock("span", {
              key: 0,
              class: "pl-3 text-left flex-grow itemName",
              content: itemName.value,
              innerHTML: makeHtmlLink(itemName.value),
              tabindex: __props.inList ? -1 : 0
            }, null, 8, _hoisted_6$e)), [
              [_directive_truncate, {
                options: { placement: "right" }
              }]
            ]) : (openBlock(), createElementBlock("div", _hoisted_7$e, toDisplayString(unref(t)("details.loading")), 1)),
            __props.data.loaded ? (openBlock(), createElementBlock("span", _hoisted_8$a, [
              isMapLayer.value ? withDirectives((openBlock(), createElementBlock("button", {
                key: 0,
                type: "button",
                content: unref(t)(`details.item.zoom${zoomStatus.value === "none" ? "" : `.${zoomStatus.value}`}`),
                "aria-label": unref(t)(`grid.cells.zoom${zoomStatus.value === "none" ? "" : `.${zoomStatus.value}`}`),
                ref_key: "zoomButton",
                ref: zoomButton,
                onClick: _cache[0] || (_cache[0] = (e) => {
                  e.stopPropagation();
                  zoomToFeature();
                }),
                class: "text-gray-600 w-24 h-24 p-2 flex justify-center items-center"
              }, [
                zoomStatus.value === "zooming" ? (openBlock(), createElementBlock("div", _hoisted_10$6)) : zoomStatus.value === "zoomed" ? (openBlock(), createElementBlock("svg", _hoisted_11$6, _cache[2] || (_cache[2] = [
                  createElementVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    d: "M4.5 12.75l6 6 9-13.5"
                  }, null, -1)
                ]))) : zoomStatus.value === "error" ? (openBlock(), createElementBlock("svg", _hoisted_12$6, _cache[3] || (_cache[3] = [
                  createElementVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    d: "M6 18L18 6M6 6l12 12"
                  }, null, -1)
                ]))) : (openBlock(), createElementBlock("span", {
                  key: 3,
                  innerHTML: unref(iApi).ui.getZoomIcon()
                }, null, 8, _hoisted_13$5))
              ], 8, _hoisted_9$7)), [
                [_directive_tippy, { placement: "bottom" }]
              ]) : createCommentVNode("", true)
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        !!__props.open ? (openBlock(), createBlock(resolveDynamicComponent(detailsTemplate.value), {
          key: 0,
          identifyData: __props.data,
          fields: fieldsList.value,
          fixtureFields: fixtureFields.value,
          class: "p-8"
        }, null, 8, ["identifyData", "fields", "fixtureFields"])) : createCommentVNode("", true)
      ], 64);
    };
  }
});

const _hoisted_1$Q = { class: "flex flex-row rv-label" };
const _hoisted_2$E = { class: "flex items-center" };
const _hoisted_3$w = ["innerHTML"];
const _sfc_main$Z = /* @__PURE__ */ defineComponent({
  __name: "toggle-switch-control",
  props: {
    config: {
      type: Object,
      required: true
    },
    name: String,
    icon: String,
    ariaLabel: String
  },
  emits: ["toggled"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const props = __props;
    const isOn = ref(props.config.value);
    const isDisabled = ref(!!props.config.disabled);
    const toggleKey = ref(0);
    const watchers = reactive([]);
    const toggleWrapper = ref(null);
    watchers.push(
      watch(
        toRef(props, "config"),
        (nConf, oConf) => {
          isOn.value = nConf.value;
          isDisabled.value = !!nConf.disabled;
          toggleKey.value += isDisabled.value !== oConf.disabled ? 1 : 0;
        },
        { deep: true }
      ),
      watch(toggleWrapper, (newValue) => {
        if (newValue) {
          addAriaLabel();
        }
      })
    );
    const handleKeyup = () => {
      if (!isDisabled.value) {
        isOn.value = !isOn.value;
        emit("toggled", isOn.value);
      }
    };
    const addAriaLabel = () => {
      if (toggleWrapper.value) {
        const checkbox = toggleWrapper.value.querySelector('input[type="checkbox"]');
        if (checkbox && props.ariaLabel) {
          checkbox.setAttribute("aria-label", props.ariaLabel);
        }
      }
    };
    onBeforeUnmount(() => {
      watchers.forEach((unwatch) => unwatch());
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$Q, [
        createElementVNode("div", _hoisted_2$E, [
          createElementVNode("div", {
            innerHTML: __props.icon,
            class: "p-8 pl-0"
          }, null, 8, _hoisted_3$w),
          createTextVNode(" " + toDisplayString(__props.name), 1)
        ]),
        _cache[2] || (_cache[2] = createElementVNode("div", { class: "flex-1" }, null, -1)),
        createElementVNode("div", {
          ref_key: "toggleWrapper",
          ref: toggleWrapper
        }, [
          (openBlock(), createBlock(unref(Toggle), {
            onChange: _cache[0] || (_cache[0] = (value) => emit("toggled", value)),
            onKeyupCapture: [
              withKeys(withModifiers(handleKeyup, ["stop"]), ["enter"]),
              withKeys(withModifiers(handleKeyup, ["stop"]), ["space"])
            ],
            disabled: isDisabled.value,
            key: toggleKey.value,
            modelValue: isOn.value,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => isOn.value = $event),
            classes: {
              container: "inline-block rounded-full outline-none focus:ring focus:ring-blue-500 focus:ring-opacity-30",
              toggle: "flex w-40 h-15 rounded-full relative cursor-pointer transition items-center box-content border-2 text-xs leading-none",
              toggleOn: "bg-blue-500 border-blue-500 justify-start text-white",
              toggleOff: "bg-gray-200 border-gray-200 justify-end text-gray-700",
              toggleOnDisabled: "bg-gray-300 border-gray-300 justify-start text-gray-400 cursor-not-allowed",
              toggleOffDisabled: "bg-gray-200 border-gray-200 justify-end text-gray-400 cursor-not-allowed",
              handle: "inline-block bg-white w-15 h-15 top-0 rounded-full absolute transition-all",
              handleOn: "left-full transform -translate-x-full",
              handleOff: "left-0",
              handleOnDisabled: "bg-gray-100 left-full transform -translate-x-full",
              handleOffDisabled: "bg-gray-100 left-0",
              label: "text-center w-8 border-box whitespace-nowrap select-none"
            }
          }, null, 8, ["onKeyupCapture", "disabled", "modelValue"]))
        ], 512)
      ]);
    };
  }
});

const ToggleSwitchControl = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["__scopeId", "data-v-188debd2"]]);

const _hoisted_1$P = {
  key: 0,
  class: "layerName w-full flex-grow p-5 pb-8 font-bold truncate",
  tabIndex: "0"
};
const _hoisted_2$D = {
  key: 1,
  class: "p-8 mb-8 bg-gray-100 flex justify-between"
};
const _hoisted_3$v = { for: "toggle" };
const _hoisted_4$k = {
  key: 2,
  class: "flex flex-col justify-between p-8 mb-8 bg-gray-100"
};
const _hoisted_5$e = { class: "flex" };
const _hoisted_6$d = ["aria-label"];
const _hoisted_7$d = ["content", "aria-label", "disabled"];
const _hoisted_8$9 = { class: "px-3 text-center flex-grow" };
const _hoisted_9$6 = ["content", "aria-label", "disabled"];
const _hoisted_10$5 = { key: 3 };
const _hoisted_11$5 = { key: 0 };
const _hoisted_12$5 = ["content"];
const _hoisted_13$4 = ["onClick"];
const _hoisted_14$3 = {
  key: 1,
  class: "text-center"
};
const _hoisted_15$3 = {
  key: 4,
  class: "p-5"
};
const _sfc_main$Y = /* @__PURE__ */ defineComponent({
  __name: "result-list",
  props: {
    uid: { type: String, required: true },
    results: { type: Object, required: true }
  },
  setup(__props) {
    const el = ref();
    const blurEvent = () => {
      el.value._tippy.hide();
    };
    const keyupEvent = (e) => {
      const evt = e;
      if (evt.key === "Tab" && el.value?.matches(":focus")) {
        el.value._tippy.show();
      }
    };
    const iApi = inject("iApi");
    const detailsStore = useDetailsStore();
    const layerStore = useLayerStore();
    const props = __props;
    const { t } = useI18n();
    const layerExists = ref(false);
    const detailsFixture = ref(iApi.fixture.get("details"));
    const hilightToggle = ref(true);
    const showList = ref(false);
    const currentIdx = ref(0);
    const itemsPerPage = ref(20);
    const handlers = ref([]);
    const watchers = ref([]);
    const activeGreedy = computed(() => detailsStore.activeGreedy);
    const detailProperties = computed(() => detailsStore.properties);
    const endIdx = computed(() => currentIdx.value + itemsPerPage.value);
    const getBoundLayer = () => {
      return layerStore.getLayerByUid(props.uid);
    };
    const getBoundLayerResult = () => {
      return props.results.find((layerIR) => {
        return layerIR.uid === props.uid;
      });
    };
    const isLayerResultLoaded = computed(() => {
      const results = getBoundLayerResult();
      return results?.loaded ?? false;
    });
    const itemRequestTime = computed(() => {
      const results = getBoundLayerResult();
      return results?.requestTime;
    });
    const showPaginator = computed(
      () => layerExists.value && (!showList.value && getLayerIdentifyItems().length > 1 || showList.value && getLayerIdentifyItems().length > itemsPerPage.value)
    );
    const layerName = computed(() => {
      const layer = getBoundLayer();
      if (layer && detailProperties.value[layer.id] && detailProperties.value[layer.id].name) {
        return detailProperties.value[layer.id].name;
      }
      return layer?.name ?? "";
    });
    const uidCompute = computed(() => {
      return props.uid;
    });
    const getLayerIdentifyItems = () => {
      const results = getBoundLayerResult();
      return results ? results.items : [];
    };
    const currentIdentifyItem = computed(() => {
      return getLayerIdentifyItems()[currentIdx.value];
    });
    const canHighlight = computed(() => {
      if (detailsFixture.value.hasHilighter()) {
        const layer = getBoundLayer();
        if (layer) {
          return layer.mapLayer && layer.supportsFeatures;
        }
      }
      return false;
    });
    const onHilightToggle = (value) => {
      hilightToggle.value = value;
      detailsStore.hilightToggle = value;
      updateHighlight();
    };
    const initDetails = () => {
      const layer = getBoundLayer();
      currentIdx.value = currentIdx.value ?? 0;
      hilightToggle.value = detailsStore.hilightToggle ?? hilightToggle.value;
      showList.value = false;
      layerExists.value = !!layer;
      updateHighlight();
    };
    const advanceItemIndex = (direction) => {
      if (showList.value) {
        currentIdx.value += direction * itemsPerPage.value;
        updateHighlight();
      } else {
        currentIdx.value += direction;
      }
    };
    const updateHighlight = () => {
      const resultItems = getLayerIdentifyItems();
      if (hilightToggle.value && isLayerResultLoaded.value && resultItems.length > 0 && canHighlight.value) {
        if (showList.value) {
          detailsFixture.value.hilightDetailsItems(resultItems.slice(currentIdx.value, endIdx.value), props.uid);
        } else {
          const currItem = resultItems[currentIdx.value];
          if (currItem) {
            detailsFixture.value.hilightDetailsItems([currItem], props.uid);
          }
        }
      } else {
        detailsFixture.value.removeDetailsHilight();
      }
    };
    const clickShowList = () => {
      showList.value = true;
      currentIdx.value = Math.floor(currentIdx.value / itemsPerPage.value) * itemsPerPage.value;
      updateHighlight();
    };
    const detailsClosed = () => {
      detailsFixture.value.removeDetailsHilight();
    };
    const detailsMinimized = () => {
      detailsFixture.value.removeDetailsHilight();
    };
    const clickListItem = (idx) => {
      const secretIdx = currentIdx.value;
      currentIdx.value = idx;
      showList.value = false;
      if (secretIdx === idx) {
        updateHighlight();
      }
    };
    onMounted(() => {
      handlers.value.push(
        iApi.event.on(GlobalEvents.LAYER_REMOVE, (removedLayer) => {
          const detailsPanel = iApi.panel.get("details");
          if (props.uid === removedLayer.uid && !!detailsPanel) {
            detailsPanel.close();
          }
        })
      );
      handlers.value.push(
        iApi.event.on(GlobalEvents.PANEL_CLOSED, (panel) => {
          if (panel.id === "details") {
            detailsClosed();
          }
        })
      );
      handlers.value.push(
        iApi.event.on(GlobalEvents.PANEL_MINIMIZED, (panel) => {
          if (panel.id === "details") {
            detailsMinimized();
          }
        })
      );
      handlers.value.push(
        iApi.event.on(GlobalEvents.MAP_BASEMAPCHANGE, (payload) => {
          if (hilightToggle.value && payload.schemaChanged) {
            updateHighlight();
          }
        })
      );
      el.value?.addEventListener("blur", blurEvent);
      el.value?.addEventListener("keyup", keyupEvent);
    });
    onBeforeMount(() => {
      watchers.value.push(
        watch(
          currentIdentifyItem,
          () => {
            if (!showList.value) {
              initDetails();
              if (currentIdentifyItem.value === void 0) {
                detailsFixture.value.removeDetailsHilight();
              }
            }
          },
          {
            deep: false,
            immediate: true
          }
        )
      );
      watchers.value.push(
        watch(
          uidCompute,
          () => {
            const localUid = props.uid;
            if (showList.value && localUid) {
              const layerIR = getBoundLayerResult();
              if (layerIR) {
                layerIR.loading.then(() => {
                  if (props.uid === localUid && showList.value) {
                    updateHighlight();
                  }
                });
              }
            }
          },
          {
            deep: false,
            immediate: true
          }
        )
      );
      watchers.value.push(
        watch(itemRequestTime, () => {
          currentIdx.value = 0;
        })
      );
      watchers.value.push(
        watch(
          () => props.uid,
          () => {
            currentIdx.value = 0;
          }
        )
      );
    });
    onBeforeUnmount(() => {
      watchers.value.forEach((unwatch) => unwatch());
      handlers.value.forEach((handler) => iApi.event.off(handler));
      el.value?.removeEventListener("blur", blurEvent);
      el.value?.removeEventListener("keyup", keyupEvent);
    });
    return (_ctx, _cache) => {
      const _directive_truncate = resolveDirective("truncate");
      const _directive_tippy = resolveDirective("tippy");
      const _directive_focus_item = resolveDirective("focus-item");
      const _directive_focus_list = resolveDirective("focus-list");
      return isLayerResultLoaded.value && activeGreedy.value === 0 ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "detailsContent relative flex flex-col flex-grow pl-5",
        style: normalizeStyle(__props.results.length > 1 ? { "margin-left": "42px" } : "")
      }, [
        layerExists.value ? withDirectives((openBlock(), createElementBlock("h1", _hoisted_1$P, [
          createTextVNode(toDisplayString(layerName.value), 1)
        ])), [
          [_directive_truncate, { options: { placement: "top-start" } }]
        ]) : createCommentVNode("", true),
        canHighlight.value ? (openBlock(), createElementBlock("div", _hoisted_2$D, [
          createElementVNode("label", _hoisted_3$v, toDisplayString(unref(t)("details.togglehilight.title")), 1),
          createVNode(ToggleSwitchControl, {
            config: {
              value: hilightToggle.value,
              disabled: false
            },
            onToggled: onHilightToggle
          }, null, 8, ["config"])
        ])) : createCommentVNode("", true),
        showPaginator.value ? (openBlock(), createElementBlock("div", _hoisted_4$k, [
          createElementVNode("div", _hoisted_5$e, [
            !showList.value ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              class: "px-8 font-bold hover:bg-gray-200 focus:bg-gray-200",
              "aria-label": unref(t)("details.item.see.list"),
              onClick: _cache[0] || (_cache[0] = ($event) => clickShowList())
            }, toDisplayString(unref(t)("details.item.see.list")), 9, _hoisted_6$d)) : createCommentVNode("", true),
            createElementVNode("div", {
              class: normalizeClass(["flex ml-auto bg-gray-200 py-8 items-center", { "w-full": showList.value }])
            }, [
              withDirectives((openBlock(), createElementBlock("button", {
                type: "button",
                content: unref(t)(showList.value ? "details.items.previous" : "details.item.previous.item"),
                onClick: _cache[1] || (_cache[1] = ($event) => advanceItemIndex(-1)),
                class: "mx-2 opacity-60 hover:opacity-90 disabled:opacity-30 disabled:cursor-default",
                "aria-label": unref(t)(showList.value ? "details.items.previous" : "details.item.previous.item"),
                disabled: currentIdx.value === 0
              }, _cache[3] || (_cache[3] = [
                createElementVNode("svg", {
                  height: "24",
                  width: "24",
                  viewBox: "0 0 23 23"
                }, [
                  createElementVNode("g", null, [
                    createElementVNode("path", { d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z" })
                  ])
                ], -1)
              ]), 8, _hoisted_7$d)), [
                [_directive_tippy, { placement: "top" }]
              ]),
              createElementVNode("span", _hoisted_8$9, toDisplayString(showList.value ? unref(t)("details.items.range", [
                currentIdx.value + 1,
                Math.min(endIdx.value, getLayerIdentifyItems().length),
                getLayerIdentifyItems().length
              ]) : unref(t)("details.item.count", [currentIdx.value + 1, getLayerIdentifyItems().length])), 1),
              withDirectives((openBlock(), createElementBlock("button", {
                type: "button",
                content: unref(t)(showList.value ? "details.items.next" : "details.item.next.item"),
                onClick: _cache[2] || (_cache[2] = ($event) => advanceItemIndex(1)),
                class: "mx-2 rotate-180 opacity-60 hover:opacity-90 disabled:opacity-30 disabled:cursor-default",
                "aria-label": unref(t)(showList.value ? "details.items.next" : "details.item.next.item"),
                disabled: !showList.value && currentIdx.value === getLayerIdentifyItems().length - 1 || showList.value && endIdx.value >= getLayerIdentifyItems().length
              }, _cache[4] || (_cache[4] = [
                createElementVNode("svg", {
                  height: "24",
                  width: "24",
                  viewBox: "0 0 23 23"
                }, [
                  createElementVNode("g", null, [
                    createElementVNode("path", { d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z" })
                  ])
                ], -1)
              ]), 8, _hoisted_9$6)), [
                [_directive_tippy, { placement: "top" }]
              ])
            ], 2)
          ])
        ])) : createCommentVNode("", true),
        layerExists.value ? (openBlock(), createElementBlock("div", _hoisted_10$5, [
          getLayerIdentifyItems().length > 0 ? (openBlock(), createElementBlock("div", _hoisted_11$5, [
            showList.value ? withDirectives((openBlock(), createElementBlock("div", {
              key: 0,
              class: "flex flex-col",
              content: unref(t)("details.layers.results.list.tooltip"),
              ref_key: "el",
              ref: el
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(getLayerIdentifyItems().slice(currentIdx.value, endIdx.value), (item, idx) => {
                return withDirectives((openBlock(), createElementBlock("button", {
                  class: "flex flex-grow truncate default-focus-style hover:bg-gray-200",
                  key: idx,
                  onClick: ($event) => clickListItem(currentIdx.value + idx)
                }, [
                  createVNode(_sfc_main$_, {
                    data: item,
                    uid: __props.uid,
                    open: false,
                    "in-list": true
                  }, null, 8, ["data", "uid"])
                ], 8, _hoisted_13$4)), [
                  [_directive_focus_item, "show-truncate"]
                ]);
              }), 128))
            ], 8, _hoisted_12$5)), [
              [_directive_focus_list],
              [_directive_tippy, {
                trigger: "manual",
                placement: "top-start"
              }]
            ]) : (openBlock(), createBlock(_sfc_main$_, {
              key: 1,
              data: currentIdentifyItem.value,
              uid: __props.uid,
              open: true,
              "in-list": false
            }, null, 8, ["data", "uid"]))
          ])) : (openBlock(), createElementBlock("div", _hoisted_14$3, toDisplayString(unref(t)("details.layers.results.empty.currentLayer")), 1))
        ])) : (openBlock(), createElementBlock("div", _hoisted_15$3, toDisplayString(unref(t)("details.item.no.data")), 1))
      ], 4)) : (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(["flex justify-center py-10 items-center", __props.results.length > 1 ? "ml-42" : ""])
      }, [
        _cache[5] || (_cache[5] = createElementVNode("span", { class: "animate-spin spinner h-20 w-20 px-5 mr-8" }, null, -1)),
        createTextVNode(" " + toDisplayString(unref(t)("details.item.loading")), 1)
      ], 2));
    };
  }
});

const ResultList = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["__scopeId", "data-v-4c39ec75"]]);

const _hoisted_1$O = { class: "relative h-full" };
const _hoisted_2$C = { class: "detailsContentSection overflow-y-auto h-full" };
const _sfc_main$X = /* @__PURE__ */ defineComponent({
  __name: "details-screen",
  props: {
    panel: {
      type: Object
    }
  },
  setup(__props) {
    const { t } = useI18n();
    const iApi = inject("iApi");
    const detailsStore = useDetailsStore();
    const handlers = ref([]);
    const watchers = ref([]);
    const layerResults = ref([]);
    const noResults = ref(false);
    const selectedLayer = ref("");
    const userSelectedLayer = ref(false);
    const activeGreedy = computed(() => detailsStore.activeGreedy);
    const payload = computed(() => detailsStore.payload);
    const detailProperties = computed(() => detailsStore.properties);
    const changeLayerSelection = (uid) => {
      selectedLayer.value = uid;
      userSelectedLayer.value = true;
    };
    const loadPayloadItems = (newPayload) => {
      if (newPayload === void 0) {
        return;
      }
      const greedyMode = newPayload.length === 0 ? 0 : newPayload[0].requestTime;
      detailsStore.activeGreedy = greedyMode;
      detailsStore.slowLoadingFlag = false;
      layerResults.value = newPayload;
      autoOpen(newPayload);
    };
    const autoOpen = (newPayload) => {
      if (userSelectedLayer.value) {
        const lastIdx = layerResults.value.findIndex((item) => item.uid === selectedLayer.value);
        if (lastIdx !== -1) {
          const lastIdentify = layerResults.value[lastIdx];
          lastIdentify.loading.then(() => {
            if (lastIdentify.requestTime !== activeGreedy.value) {
              return;
            }
            if (lastIdentify.items.length > 0) {
              detailsStore.activeGreedy = 0;
              userSelectedLayer.value = false;
              noResults.value = false;
            } else {
              autoOpenAny(newPayload);
            }
          });
        } else {
          autoOpenAny(newPayload);
        }
      } else {
        autoOpenAny(newPayload);
      }
      setTimeout(() => {
        if (activeGreedy.value !== 0 && newPayload[0].requestTime === activeGreedy.value) {
          detailsStore.slowLoadingFlag = true;
        }
      }, 500);
    };
    const autoOpenAny = (newPayload) => {
      const loadingResults = newPayload.map(
        (item) => item.loading.then(() => item.items.length > 0 ? Promise.resolve(item) : Promise.reject())
      );
      const lastTime = newPayload.length === 0 ? 0 : newPayload[0].requestTime;
      Promise.any(loadingResults).then((res) => {
        if (res.requestTime !== activeGreedy.value) {
          return;
        }
        const idx = layerResults.value.find((item) => item.uid === res.uid);
        detailsStore.activeGreedy = 0;
        if (idx !== void 0) {
          selectedLayer.value = idx.uid;
          noResults.value = false;
        }
      }).catch(() => {
        if (lastTime !== activeGreedy.value) {
          return;
        }
        detailsStore.activeGreedy = 0;
        noResults.value = true;
      });
    };
    onBeforeMount(() => {
      watchers.value.push(
        watch(
          payload,
          (newPayload) => {
            loadPayloadItems(newPayload);
          },
          {
            deep: false,
            // was true when our array had undefineds. now that objects arrive intact, we dont want this triggering when innards update
            immediate: true
          }
        )
      );
      watchers.value.push(
        watch(activeGreedy, (newGreedy) => {
          if (newGreedy === 0) {
            detailsStore.slowLoadingFlag = false;
          }
        })
      );
    });
    onBeforeUnmount(() => {
      handlers.value.forEach((handler) => iApi.event.off(handler));
      watchers.value.forEach((unwatch) => unwatch());
    });
    return (_ctx, _cache) => {
      const _component_panel_screen = resolveComponent("panel-screen");
      return openBlock(), createBlock(_component_panel_screen, { panel: __props.panel }, {
        header: withCtx(() => [
          createTextVNode(toDisplayString(
            // Show different titles based on what requested the panel
            unref(detailsStore).origin === "toggleEvent" ? unref(t)("details.layers.title.gridOrigin") : unref(t)("details.layers.title.identifyOrigin")
          ), 1)
        ]),
        content: withCtx(() => [
          createElementVNode("div", _hoisted_1$O, [
            layerResults.value.length > 1 ? (openBlock(), createBlock(_sfc_main$11, {
              key: 0,
              results: layerResults.value,
              detailsProperties: detailProperties.value,
              selected: selectedLayer.value,
              onSelectionChanged: changeLayerSelection
            }, null, 8, ["results", "detailsProperties", "selected"])) : createCommentVNode("", true),
            createElementVNode("div", _hoisted_2$C, [
              !noResults.value ? (openBlock(), createBlock(ResultList, {
                key: 0,
                uid: selectedLayer.value,
                results: layerResults.value
              }, null, 8, ["uid", "results"])) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(["text-center", { "ml-42": layerResults.value.length > 1 }])
              }, toDisplayString(layerResults.value.length >= 1 ? unref(t)("details.layers.results.empty") : unref(t)("details.layers.results.empty.noLayers")), 3))
            ])
          ])
        ]),
        _: 1
      }, 8, ["panel"]);
    };
  }
});

const DetailsScreenV = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["__scopeId", "data-v-4932c3fb"]]);

const messages$e = {"en":{"details.layers.title.identifyOrigin":"Identify Details","details.layers.title.gridOrigin":"Details","details.layers.found":"Found {numResults} results in {numLayers} layers","details.layers.loading":"The layer is loading...","details.layers.error":"Error","details.layers.results.empty":"No results found for any layer.","details.layers.results.empty.currentLayer":"No results found for the selected layer.","details.layers.results.empty.noLayers":"No layers for identification.","details.layers.results.list.tooltip":"Use the arrow keys to navigate the items","details.result.default.name":"Identify Item {0}","details.loading":"Loading...","details.items.title":"Details","details.items.range":"{0} - {1} of {2}","details.items.next":"Next page","details.items.previous":"Previous page","details.items.page":"Items per page","details.item.see.list":"See List","details.item.zoom":"Zoom to feature","details.item.zoom.zooming":"Zooming...","details.item.zoom.error":"Zoom failed","details.item.zoom.zoomed":"Zoomed","details.item.previous.item":"Previous item","details.item.next.item":"Next item","details.item.count":"{0} of {1}","details.item.loading":"Loading results...","details.item.no.data":"No data to show because the layer has been removed","details.item.alert.zoom":"Zoomed into feature","details.item.alert.show.item":"Showing result {itemName}","details.item.alert.show.list":"Showing all results for {layerName}","details.item.alert.defaultAltText":"Image associated with {alias} field","details.togglehilight.title":"Toggle Highlight","details.item.open":"Expand","details.item.collapse":"Collapse"},"fr":{"details.layers.title.identifyOrigin":"Identifier les détails","details.layers.title.gridOrigin":"Détails","details.layers.found":"{numResults} résultats trouvés dans {numLayers} couches","details.layers.loading":"La couche est en cours de chargement...","details.layers.error":"Erreur","details.layers.results.empty":"Aucun résultat trouvé pour aucune couche.","details.layers.results.empty.currentLayer":"Aucun résultat trouvé pour la couche sélectionnée.","details.layers.results.empty.noLayers":"Pas de couches pour l'identification.","details.layers.results.list.tooltip":"Utilisez les touches fléchées pour naviguer entre les éléments","details.result.default.name":"Désigner l'élément {0}","details.loading":"Chargement en cours...","details.items.title":"Détails","details.items.range":"{0} - {1} de {2}","details.items.next":"Page suivante","details.items.previous":"Page précédente","details.items.page":"éléments par page","details.item.see.list":"Voir la liste","details.item.zoom":"Zoom à l'élément","details.item.zoom.zooming":"Zoom en cours...","details.item.zoom.error":"Échec du zoom","details.item.zoom.zoomed":"Zoom terminé","details.item.previous.item":"Élément précédent","details.item.next.item":"Élément suivant","details.item.count":"{0} de {1}","details.item.loading":"Chargement des résultats...","details.item.no.data":"Aucune donnée à afficher","details.item.alert.zoom":"Zoom sur la caractéristique","details.item.alert.show.item":"Affichage du résultat {itemName}","details.item.alert.show.list":"Affichage de tous les résultats pour {layerName}","details.item.alert.defaultAltText":"Image associée au champ {alias}","details.togglehilight.title":"Basculer vers l'élément principal","details.item.open":"Développer","details.item.collapse":"Réduire"}};

class DetailsFixture extends DetailsAPI {
  async added() {
    this.$iApi.panel.register(
      {
        details: {
          screens: {
            "details-screen": markRaw(DetailsScreenV)
          },
          style: {
            width: "425px"
          },
          button: {
            tooltip: "details.layers.title.identifyOrigin",
            // https://fonts.google.com/icons?selected=Material%20Icons%3Aarticle%3A
            icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none" /><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z" /></svg>'
          },
          alertName: "details.items.title"
        }
      },
      { i18n: { messages: messages$e } }
    );
    this._parseConfig(this.config);
    const unwatch = this.$vApp.$watch(
      () => this.config,
      (value) => this._parseConfig(value)
    );
    this.removed = () => {
      unwatch();
      this.$iApi.panel.remove("details");
      if (this.$iApi.fixture.exists("appbar")) {
        const appbarStore = useAppbarStore(this.$vApp.$pinia);
        appbarStore.removeButton("details");
      }
      const detailsStore = useDetailsStore(this.$vApp.$pinia);
      detailsStore.$reset();
    };
  }
}

const index$p = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: DetailsFixture
}, Symbol.toStringTag, { value: 'Module' }));

class ExportFootnoteFixture extends FixtureInstance {
  get config() {
    const fixtureConfig = this.$iApi.fixture.get("export").config;
    return fixtureConfig?.footnote;
  }
  make(options) {
    const footnoteFixtureConfig = this.config;
    const fabricTextConfig = {
      text: "RAMP-PCAR",
      fontFamily: "Montserrat, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif",
      fill: "#000",
      fontSize: 20,
      top: 0
    };
    if (footnoteFixtureConfig?.value !== void 0) {
      fabricTextConfig.text = footnoteFixtureConfig.value;
    }
    const config = merge(fabricTextConfig, options || {});
    const fbFootnote = new fabric.Textbox(config.text, config);
    return Promise.resolve(fbFootnote);
  }
}

const index$o = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: ExportFootnoteFixture
}, Symbol.toStringTag, { value: 'Module' }));

const SEGMENT_TOP_MARGIN = 30;
const SEGMENT_BOTTOM_MARGIN = 20;
const CHUNK_TOP_MARGIN = 16;
const CHUNK_BOTTOM_MARGIN = 12;
const ITEM_MARGIN = 8;
const ROW_HEIGHT = 32;
const ICON_WIDTH = 32;
const MIN_COLUMN_WIDTH = 350;
const COLUMN_SPACING = 20;
const DEFAULT_FONT = "Montserrat, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif";
class ExportLegendFixture extends FixtureInstance {
  get config() {
    const fixtureConfig = this.$iApi.fixture.get("export").config;
    return fixtureConfig?.legend;
  }
  async make(options) {
    const layers = this.$iApi.geo.layer.allLayersOnMap().filter((layer) => !layer.isCosmetic);
    if (layers.length === 0) {
      return new fabric.Group([], {
        originX: "left"
      });
    }
    const columns = Math.min(
      layers.length,
      Math.floor(options.width / (MIN_COLUMN_WIDTH + COLUMN_SPACING)) || 1
      // round to 1 if floor is 0
    );
    const columnWidth = (options.width - (columns - 1) * COLUMN_SPACING) / columns;
    let runningHeight = 0;
    const segments = await Promise.all(this._makeSegments(layers, columnWidth));
    const fbAllItems = segments.map(({ title: segmentTitle, items: chunks }, segmentIndex) => {
      if (segmentIndex > 0) {
        runningHeight += SEGMENT_TOP_MARGIN;
      }
      segmentTitle.top = runningHeight;
      runningHeight += segmentTitle.height + SEGMENT_BOTTOM_MARGIN;
      const allChunkItems = chunks.map(({ title: chunkTitle, items: chunkItems }, chunkIndex) => {
        const result = [];
        if (chunkTitle && !(chunks.length === 1 && chunkTitle.text === segmentTitle.text)) {
          if (chunkIndex > 0) {
            runningHeight += CHUNK_TOP_MARGIN;
          }
          chunkTitle.top = runningHeight;
          runningHeight += chunkTitle.height + CHUNK_BOTTOM_MARGIN;
          result.push(chunkTitle);
        }
        chunkItems.forEach((item) => {
          item.top = runningHeight;
          runningHeight += item.height + ITEM_MARGIN;
        });
        return [...result, ...chunkItems].filter((a) => a);
      });
      return new fabric.Group([segmentTitle, ...allChunkItems.flat()]);
    }).flat();
    const fbLegend = this._makeColumns(fbAllItems, columnWidth, columns);
    return Promise.resolve(fbLegend);
  }
  /**
   * Breaks up legend layers into columns
   *
   * @private
   * @param {fabric.Group[]} items
   * @param {number} columnWidth
   * @param {number} columns
   * @returns {fabric.Group}
   * @memberof ExportLegendFixture
   */
  _makeColumns(items, columnWidth, columns) {
    let curColumn = 0;
    let curTop = 0;
    let accumLength = 0;
    const targetHeight = items[items.length - 1].aCoords.bl.y / columns;
    items.forEach((group, index) => {
      const height = index !== items.length - 1 ? items[index + 1].top - group.top : group.height;
      const columnFull = accumLength > targetHeight * (curColumn + 1);
      const longLayer = curTop !== 0 && height > targetHeight;
      const fillColumns = columns - curColumn > items.length - index;
      if ((columnFull || longLayer || fillColumns) && curColumn < columns) {
        ++curColumn;
        curTop = 0;
      }
      group.left = curColumn * (columnWidth + COLUMN_SPACING);
      group.top = curTop;
      curTop += height;
      accumLength += height;
    });
    return new fabric.Group(items, {
      originX: "left"
    });
  }
  /**
   * Create segments of the export image based on the provided layers and layer configs.
   *
   * @private
   * @param {LayerInstance[]} layers
   * @param {RampLayerConfig[]} layerConfigs
   * @returns {Promise<Segment>[]}
   * @memberof ExportLegendFixture
   */
  _makeSegments(layers, segmentWidth) {
    return layers.map(async (layer) => {
      const title = new fabric.Textbox(layer.name, {
        fontSize: 24,
        fontFamily: DEFAULT_FONT,
        width: segmentWidth
      });
      const ids = this._getLayerTreeIds(layer);
      let items = [];
      items = layer.supportsSublayers ? await Promise.all(
        this._makeSegmentChunks(ids, layer, segmentWidth)
        // pass list of flatenned sublayer ids
      ) : await Promise.all(
        this._makeSegmentChunks([-1], layer, segmentWidth)
        // pass single -1 id so the root gets processed
      );
      return { title, items };
    });
  }
  /**
   * Creates segment chunks based on the provided layer and layer entry id.
   *
   * Used for layers that support sublayers (e.g. MapImageLayers)
   *
   * @private
   * @param {(number[] | string[])} ids
   * @param {LayerInstance} layer
   * @returns {Promise<SegmentChunk>[]}
   * @memberof ExportLegendFixture
   */
  _makeSegmentChunks(ids, layer, segmentWidth) {
    const rootLayer = layer;
    return ids.map(async (idx) => {
      const currLayer = idx === -1 ? rootLayer : rootLayer.getSublayer(idx);
      if (!currLayer) {
        return {
          title: new fabric.Textbox("ERROR", {
            fontSize: 20,
            fontFamily: DEFAULT_FONT,
            width: segmentWidth
          }),
          items: []
        };
      }
      await Promise.all(currLayer.legend.map((lg) => lg.drawPromise));
      const symbologyStack = currLayer.legend;
      const title = new fabric.Textbox(currLayer.name, {
        fontSize: 20,
        fontFamily: DEFAULT_FONT,
        width: segmentWidth
      });
      const items = await Promise.all(this._makeChunkItems(symbologyStack, segmentWidth));
      return {
        title,
        items
      };
    });
  }
  /**
   * Creates layer entry symbology based on the provided symbology stack.
   *
   * @private
   * @param {LegendSymbology[]} symbologyStack
   * @returns {Promise<fabric.Group>[]}
   * @memberof ExportLegendFixture
   */
  _makeChunkItems(symbologyStack, segmentWidth) {
    return symbologyStack.map(async (symbol) => {
      const fbSymbol = (await promisify(fabric.loadSVGFromString)(symbol.svgcode))[0];
      if (!symbol.esriStandard) {
        const fbLabel = new fabric.Textbox(symbol.label, {
          fontSize: 12,
          fontFamily: DEFAULT_FONT,
          originY: "center",
          left: 0,
          top: ROW_HEIGHT / 2,
          width: segmentWidth
        });
        const symbolWidth = Number(symbol.imgWidth);
        const symbolHeight = Number(symbol.imgHeight);
        const scale = Math.min(1, segmentWidth / symbolWidth);
        if (fbSymbol) {
          fbSymbol.originY = "center";
          fbSymbol.top = symbolHeight * scale / 2 + ROW_HEIGHT;
          fbSymbol.scaleToHeight(symbolHeight * scale);
          fbSymbol.scaleToWidth(symbolWidth * scale);
        }
        return new fabric.Group([fbLabel, fbSymbol].filter(Boolean), {
          height: symbolHeight * scale + ROW_HEIGHT
        });
      } else {
        fbSymbol.originY = "center";
        fbSymbol.top = ROW_HEIGHT / 2;
        const fbLabel = new fabric.Textbox(symbol.label, {
          fontSize: 12,
          fontFamily: DEFAULT_FONT,
          originY: "center",
          left: ICON_WIDTH + 20,
          top: ROW_HEIGHT / 2,
          width: segmentWidth - ICON_WIDTH - 20
        });
        return new fabric.Group([fbSymbol, fbLabel], {
          height: ROW_HEIGHT
        });
      }
    });
  }
  /**
   * Gets flattened array of ids from layer tree
   *
   * @private
   * @param {TreeNode} node
   * @returns {number[]}
   * @memberof ExportLegendFixture
   */
  _getLayerTreeIds(rootLayer) {
    const ids = [];
    const queue = [...rootLayer.sublayers];
    while (queue.length > 0) {
      const sublayer = queue.shift();
      if (!sublayer) {
        continue;
      }
      sublayer.visibility && ids.push(sublayer.layerIdx);
      queue.push(...sublayer.sublayers);
    }
    return ids;
  }
}
const promisify = (fn) => {
  return (args) => new Promise((resolve) => {
    fn(args, (callbackArgs) => {
      resolve(callbackArgs);
    });
  });
};

const index$n = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: ExportLegendFixture
}, Symbol.toStringTag, { value: 'Module' }));

class ExportMapFixture extends FixtureInstance {
  get config() {
    const fixtureConfig = this.$iApi.fixture.get("export").config;
    return fixtureConfig?.map;
  }
  async make(options) {
    const screenshot = await this.$iApi.geo.map.takeScreenshot({
      quality: 1,
      format: "png"
    });
    const img = new Image();
    img.src = screenshot.dataUrl;
    const esriImage = await new Promise((resolve) => img.onload = () => resolve(img));
    return new fabric.Image(esriImage, options);
  }
}

const index$m = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: ExportMapFixture
}, Symbol.toStringTag, { value: 'Module' }));

class ExportNorthArrowFixture extends FixtureInstance {
  get config() {
    const fixtureConfig = this.$iApi.fixture.get("export").config;
    return fixtureConfig?.mapElements;
  }
  async make(options) {
    let calculateNorthArrowAngle = (normalizedPositionX2) => {
      return 0;
    };
    let normalizedPositionX = 0;
    const arrowSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 61.06 96.62"><g transform="translate(-1.438 30.744)"><g fill="none" stroke="#000"><path d="m61 35c0 16.02-12.984 29-29 29-16.02 0-29-12.984-29-29 0-16.02 12.984-29 29-29 16.02 0 29 12.984 29 29z" stroke-width="3"/><path d="m55 35c0 12.979-10.521 23.5-23.5 23.5-12.979 0-23.5-10.521-23.5-23.5 0-12.979 10.521-23.5 23.5-23.5 12.979 0 23.5 10.521 23.5 23.5z" transform="matrix(1.01148 0 0 .99988-.089.004)" stroke-width=".497"/><path d="m32 35v-32" stroke-width=".25"/></g><path d="m32-9.453l28.938 73.826-29-29-29 29z" fill="#fff" stroke="#fff" stroke-width="3"/><path d="m32-9.453l29 73.45-29-29-29 29z" fill="none" stroke="#000" stroke-linecap="square"/><text x="22.71" y="-10.854" font-family="OPEN SANS" word-spacing="0" line-height="125%" letter-spacing="0" font-size="40"><tspan x="22.71" y="-10.854" font-family="Adobe Heiti Std R" font-size="26">N</tspan></text></g><g transform="translate(0-3.829)" fill="none" stroke="#000" stroke-width=".25"><path d="m4 92.82l6.74-3.891"/><path d="m4.603 90.7l10.397-6"/><path d="m3 95.17l4-2.309"/><path d="m5.442 88.45l13.856-8"/><path d="m12 72.26l18.686-10.812"/><path d="m14.593 65.45l16.09-9.291"/><path d="m15.343 63.24l15.343-8.858"/><path d="m16.877 60.58l13.809-7.972"/><path d="m17.511 58.45l13.174-7.606"/><path d="m18.412 56.15l12.274-7.087"/><path d="m19 54.04l11.427-6.597"/><path d="m20 51.757l10.822-6.311"/><path d="m20.826 49.45l9.86-5.693"/><path d="m21.48 47.3l9.206-5.315"/><path d="m23 44.647l7.686-4.437"/><path d="m23.744 42.45l6.928-4"/><path d="m24.549 40.21l6.137-3.543"/><path d="m25 38.18l5.686-3.283"/><path d="m26.663 35.446l4.02-2.323"/><path d="m27.617 33.12l3.069-1.772"/><path d="m28 31.13l2.686-1.551"/><path d="m29.15 28.694l1.534-.886"/><path d="m13 69.909l17.686-10.211"/><path d="m9.206 79.19l21.48-12.402"/><path d="m8.36 81.45l22.326-12.89"/><path d="m7.671 83.62l19.946-11.516"/><path d="m6.137 86.27l17.02-9.827"/><path d="m10 76.956l20.686-11.943"/><path d="m11.279 74.45l19.407-11.205"/><path d="m14 67.56l16.686-9.634"/><path d="m30.562 65.744v-43.566" transform="translate(0 3.829)"/></g></svg>';
    const innerShell = document.querySelector(".inner-shell");
    const sr = this.$iApi.geo.map.getSR();
    let angle = 0;
    if (sr.isWebMercator()) {
      angle = 0;
    } else {
      const arrowWidth = 50;
      const pole = new Point("pole", { x: -96, y: 90 });
      const projPole = await this.$iApi.geo.proj.projectGeometry(sr, pole);
      const poleScreenPos = this.$iApi.geo.map.mapPointToScreenPoint(projPole);
      const bcScreenPos = {
        screenX: innerShell.clientWidth / 2,
        screenY: innerShell.clientHeight
      };
      angle = Math.atan(
        (poleScreenPos.screenX - bcScreenPos.screenX) / (bcScreenPos.screenY - poleScreenPos.screenY)
      ) * 180 / Math.PI;
      const arrowLeft = innerShell.clientWidth / 2 + innerShell.clientHeight * Math.tan(angle * Math.PI / 180) - arrowWidth / 2;
      const positionX = Math.round(arrowLeft / innerShell.clientWidth * 100);
      normalizedPositionX = Math.min(Math.max(positionX, 0), 100);
      calculateNorthArrowAngle = (normalizedPositionX2) => {
        if (normalizedPositionX2 < 0 || normalizedPositionX2 > 100) {
          throw new Error("Normalized position must be between 0 and 100");
        }
        const screenPosX = innerShell.clientWidth * normalizedPositionX2 / 100;
        return Math.atan((poleScreenPos.screenX - screenPosX) / (arrowWidth / 2 - poleScreenPos.screenY)) * (180 / Math.PI);
      };
    }
    const fbImgConfig = {
      top: 0,
      left: 0,
      originX: "center",
      originY: "center",
      angle
    };
    const group = [];
    let loadedObjects = new fabric.Group();
    fabric.loadSVGFromString(
      arrowSVG,
      () => {
        loadedObjects = new fabric.Group(group);
        loadedObjects.positionX = normalizedPositionX;
        loadedObjects.getAngleFromPosition = calculateNorthArrowAngle;
      },
      (_, object) => {
        group.push(object);
      }
    );
    loadedObjects.set(merge(fbImgConfig, options || {}));
    return Promise.resolve(loadedObjects);
  }
}

const index$l = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: ExportNorthArrowFixture
}, Symbol.toStringTag, { value: 'Module' }));

class ExportScalebarFixture extends FixtureInstance {
  get config() {
    const fixtureConfig = this.$iApi.fixture.get("export").config;
    return fixtureConfig?.mapElements;
  }
  make(options) {
    const sInfo = this.$iApi.geo.map.caption.scaleHelper();
    const fbObjs = [];
    for (let i = 0; i < 2; i++) {
      const fbScaleText = new fabric.Text(
        this.$iApi.$i18n.t("export.scaleBar.approx", [
          `${this.$iApi.$i18n.n(sInfo[i].distance, "number")}${sInfo[i].units}`
        ]),
        {
          fontFamily: "Montserrat, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif",
          fill: "#000",
          fontSize: 16,
          top: i * 50,
          left: 0,
          originX: "left",
          originY: "top"
        }
      );
      const fbScaleLine = new fabric.Line([0, i === 0 ? 30 : 40, sInfo[i].pixels, i === 0 ? 30 : 40], {
        stroke: "black",
        strokeWidth: 3
      });
      fbObjs.push(new fabric.Group([fbScaleLine, fbScaleText]));
    }
    return Promise.resolve(new fabric.Group(fbObjs, options));
  }
}

const index$k = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: ExportScalebarFixture
}, Symbol.toStringTag, { value: 'Module' }));

class ExportTimestampFixture extends FixtureInstance {
  get config() {
    const fixtureConfig = this.$iApi.fixture.get("export").config;
    return fixtureConfig?.timestamp;
  }
  make(options) {
    const timestampFixtureConfig = this.config;
    const fabricTextConfig = {
      text: (/* @__PURE__ */ new Date()).toLocaleString("en-CA"),
      fontFamily: "Montserrat, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif",
      fill: "#000",
      fontSize: 20,
      top: 0,
      left: 0,
      originX: "left"
    };
    if (timestampFixtureConfig?.value !== void 0) {
      fabricTextConfig.text = timestampFixtureConfig.value;
    }
    const config = merge(fabricTextConfig, options || {});
    const fbTimestamp = new fabric.Textbox(config.text, config);
    return Promise.resolve(fbTimestamp);
  }
}

const index$j = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: ExportTimestampFixture
}, Symbol.toStringTag, { value: 'Module' }));

class ExportTitleFixture extends FixtureInstance {
  get config() {
    const fixtureConfig = this.$iApi.fixture.get("export").config;
    return fixtureConfig?.title;
  }
  make(options) {
    const titleFixtureConfig = this.config;
    const fabricTextConfig = {
      text: "RAMP-Map / PCAR-Carte",
      // default name
      fontFamily: "Montserrat, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif",
      fill: "#000",
      fontSize: 30,
      top: 0,
      left: 0,
      originX: "center",
      originY: "top"
    };
    if (titleFixtureConfig?.value !== void 0) {
      fabricTextConfig.text = titleFixtureConfig.value;
    }
    const config = merge(fabricTextConfig, options || {});
    const fbTitle = new fabric.Textbox(config.text, config);
    return Promise.resolve(fbTitle);
  }
}

const index$i = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: ExportTitleFixture
}, Symbol.toStringTag, { value: 'Module' }));

const DEFAULT_WIDTH = 1200;
const GLOBAL_MARGIN = {
  TOP: 40,
  RIGHT: 40,
  BOTTOM: 40,
  LEFT: 40
};
class ExportAPI extends FixtureInstance {
  fcFabric;
  // download canvas will remain unscaled and only be used for download
  fcFabricDownload;
  options = {
    runningHeight: 0,
    scale: 1
  };
  // stores the custom render function if provided
  customRendererFunc = void 0;
  /**
   * Allows for a custom render callback function to be passed in to render the export canvas.
   * The function should accept the blank ramp canvas as its first parameter and use that canvas to draw on.
   * The width of the canvas is already set to the panel width, so the function only needs to set the height.
   *
   * Individual export elements like the map or the legend can be accessed from the `fabricObjects` object as the second parameter.
   * You can pick and chose which elements to add to the canvas, or modify them as needed. You can also add custom elements to the canvas.
   *
   * Finally, the `options` object is passed in as the third parameter. This object contains useful information such as the panel width, the default margins, the default canvas width, and the fabric object itself.
   *
   * Some canvas operations are asynchronous like fetching an image or cloning objects. In these cases you should return a promise so ramp waits for your operations to complete, otherwise returning nothing (void) is fine.
   *
   * ramp uses Fabric.js instead of the native canvas API. Read more about Fabric.js here: [Fabric.js](http://fabricjs.com/)
   *
   * @param {RenderCallback} renderCallback
   * @example myWatermarkingRenderer((canvas, fabricObjects, options) => {
   *   const watermark = new fabric.Text('Watermark', { ... });
   *   fabricObjects.map.addWithUpdate(watermark);
   *   canvas.add(fabricObjects.map);
   *   canvas.setHeight(1000);
   * });
   *
   * rInstance.fixture.isLoaded('export').then(() => {
   *   rInstance.fixture.get('export').customRenderer(myWatermarkingRenderer);
   * });
   * @memberof ExportAPI
   */
  customRenderer(renderCallback) {
    this.customRendererFunc = renderCallback;
  }
  /**
   * Returns `ExportConfig` section of the global config file.
   *
   * @readonly
   * @type {ExportConfig}
   * @memberof ExportAPI
   */
  get config() {
    return super.config;
  }
  /**
   * Parses the export config JSON snippet from the config file and save to the fixture store.
   *
   * @param {ExportConfig} [exportConfig]
   * @memberof ExportAPI
   */
  _parseConfig(exportConfig) {
    if (!exportConfig) return;
    const exportStore = useExportStore(this.$vApp.$pinia);
    exportStore.componentSelectedState = {
      title: exportConfig.title?.selected ?? true,
      map: exportConfig.map?.selected ?? true,
      mapElements: exportConfig.mapElements?.selected ?? true,
      legend: exportConfig.legend?.selected ?? true,
      footnote: exportConfig.footnote?.selected ?? true,
      timestamp: exportConfig.timestamp?.selected ?? true
    };
    exportStore.fileName = exportConfig.fileName || "";
    this.handlePanelWidths(["export"]);
    this.handlePanelTeleports(["export"]);
  }
  /**
   * Fetches an Export sub fixture
   *
   * @private
   * @param {string} name
   * @returns {ExportSubFixture | undefined}
   * @memberof ExportAPI
   */
  getSubFixture(name) {
    return this.$iApi.fixture.get(name);
  }
  /**
   * Creates an export canvas.
   *
   * @param {HTMLCanvasElement} canvas
   * @param {number} panelWidth
   * @returns {Promise<void>}
   * @memberof ExportAPI
   */
  async make(canvas, panelWidth) {
    const { fabric } = await import('fabric');
    fabric.Object.prototype.objectCaching = false;
    const exportStore = useExportStore(this.$vApp.$pinia);
    const selectedFabricObjects = {};
    this.fcFabric = new fabric.StaticCanvas(canvas, {
      backgroundColor: "#fff"
    });
    this.fcFabricDownload = new fabric.StaticCanvas(null, {
      backgroundColor: "#fff"
    });
    this.options.runningHeight = 0;
    const selectedState = exportStore.componentSelectedState;
    const exportTitleFixture = this.getSubFixture("export-title");
    const exportMapFixture = this.getSubFixture("export-map");
    const exportScaleBarFixture = this.getSubFixture("export-scalebar");
    const exportNorthArrowFixture = this.getSubFixture("export-northarrow");
    const exportLegendFixture = this.getSubFixture("export-legend");
    const exportFootnoteFixture = this.getSubFixture("export-footnote");
    const exportTimestampFixture = this.getSubFixture("export-timestamp");
    let fbTitle;
    let fbMap;
    let fbScaleBar;
    let fbNorthArrow;
    let fbLegend;
    let fbFootnote;
    let fbTimestamp;
    if (selectedState.title && exportTitleFixture) {
      fbTitle = await exportTitleFixture.make({
        /* text: '😸🤖🧙‍♂️🤦‍♀️🎶', */
        top: this.options.runningHeight,
        left: 0,
        originX: "left",
        width: panelWidth,
        textAlign: "center"
      });
      this.options.runningHeight += fbTitle.height + 40;
      selectedFabricObjects.title = fbTitle;
    }
    if (selectedState.map && exportMapFixture) {
      fbMap = await exportMapFixture.make({
        top: this.options.runningHeight
      });
      if (fbTitle) {
        fbTitle.left = fbMap.width / 2;
        fbTitle.originX = "center";
      }
      this.options.runningHeight += fbMap.height + 40;
      selectedFabricObjects.map = fbMap;
    }
    if (!fbMap && fbTitle) {
      fbTitle.width = DEFAULT_WIDTH;
    }
    this.options.scale = panelWidth / ((fbMap?.width ?? DEFAULT_WIDTH) + GLOBAL_MARGIN.LEFT + GLOBAL_MARGIN.RIGHT);
    if (selectedState.mapElements && exportScaleBarFixture) {
      fbScaleBar = await exportScaleBarFixture.make({
        top: this.options.runningHeight,
        left: 0
      });
      this.options.runningHeight += fbScaleBar.height + 40;
      selectedFabricObjects.scaleBar = fbScaleBar;
      if (exportNorthArrowFixture) {
        fbNorthArrow = await exportNorthArrowFixture.make({
          top: fbScaleBar.top,
          left: panelWidth / this.options.scale
        });
        fbNorthArrow.top += fbNorthArrow.height / 2 - 20;
        fbNorthArrow.left += -fbNorthArrow.width * 2;
        selectedFabricObjects.northArrow = fbNorthArrow;
      }
    }
    if (selectedState.legend && exportLegendFixture) {
      fbLegend = await exportLegendFixture.make({
        width: exportLegendFixture.config?.columnWidth ?? fbMap?.width ?? DEFAULT_WIDTH
      });
      fbLegend.top = this.options.runningHeight;
      this.options.runningHeight += fbLegend.height;
      selectedFabricObjects.legend = fbLegend;
    }
    if (selectedState.timestamp && exportTimestampFixture) {
      fbTimestamp = await exportTimestampFixture.make({
        top: this.options.runningHeight + 40,
        width: panelWidth
      });
      this.options.runningHeight += !selectedState.footnote || !exportFootnoteFixture ? fbTimestamp.height + 40 : fbTimestamp.height + 20;
      selectedFabricObjects.timestamp = fbTimestamp;
    }
    if (selectedState.footnote && exportFootnoteFixture) {
      fbFootnote = await exportFootnoteFixture.make({
        top: this.options.runningHeight - 2.5,
        // Magic number 2.5 prevents weird vertical offset between timestamp/footer
        left: panelWidth / this.options.scale + 40
      });
      const BUFFER = 30;
      if (selectedState.timestamp && exportTimestampFixture) {
        if (panelWidth - selectedFabricObjects.timestamp.getMinWidth() <= fbFootnote.getMinWidth() + BUFFER) {
          fbFootnote.top += 30;
          fbFootnote.left = 0;
          fbFootnote.originX = "left";
          this.options.runningHeight += 20;
        } else {
          fbFootnote.left += -fbFootnote.width * 2;
        }
      } else {
        fbFootnote.top += 20;
        fbFootnote.left += -fbFootnote.width * 2;
        this.options.runningHeight += 20;
      }
      this.options.runningHeight += fbFootnote.height;
      selectedFabricObjects.footnote = fbFootnote;
    }
    if (this.customRendererFunc) {
      this.fcFabric.setWidth(panelWidth);
      const options = {
        panelWidth,
        margin: GLOBAL_MARGIN,
        defaultWidth: DEFAULT_WIDTH,
        fabric
      };
      await this.customRendererFunc(this.fcFabric, selectedFabricObjects, options);
      this.fcFabric.renderAll();
      this.fcFabric.clone((clonedCanvas) => {
        this.fcFabricDownload = clonedCanvas;
        this.fcFabricDownload.setDimensions({
          width: this.fcFabric?.getWidth(),
          height: this.fcFabric.getHeight()
        });
        this.fcFabricDownload.renderAll();
      });
    } else {
      const fbGroup = new fabric.Group(Object.values(selectedFabricObjects), {
        top: GLOBAL_MARGIN.TOP * this.options.scale,
        left: GLOBAL_MARGIN.LEFT * this.options.scale
      });
      const fbGroupDownload = await new Promise((resolve) => {
        fbGroup.clone((g) => {
          resolve(g);
        });
      });
      fbGroupDownload.top = GLOBAL_MARGIN.TOP;
      fbGroupDownload.left = GLOBAL_MARGIN.LEFT;
      this.fcFabricDownload.add(fbGroupDownload);
      fbGroup.scale(this.options.scale);
      this.fcFabric.add(fbGroup);
      this.fcFabric.setDimensions({
        width: panelWidth,
        height: (this.options.runningHeight + GLOBAL_MARGIN.TOP + GLOBAL_MARGIN.BOTTOM) * this.options.scale
      });
      this.fcFabric.renderAll();
      this.fcFabricDownload.setDimensions({
        width: (fbMap?.width ?? DEFAULT_WIDTH) + GLOBAL_MARGIN.LEFT + GLOBAL_MARGIN.RIGHT,
        height: this.options.runningHeight + GLOBAL_MARGIN.TOP + GLOBAL_MARGIN.BOTTOM
      });
      this.fcFabricDownload.renderAll();
    }
  }
  export() {
    if (!this.fcFabric) {
      return;
    }
    const now = /* @__PURE__ */ new Date();
    const fileName = this.config?.fileName || `map-carte - ${now.getFullYear()}-${now.getMonth()}-${now.getDay()}, ${now.getHours()}_${now.getMinutes()}`;
    FileSaver.saveAs(
      this.fcFabricDownload.toDataURL({
        format: "png",
        quality: 1
      }),
      `${fileName}.png`
    );
  }
}

const _hoisted_1$N = ["onClick", "aria-label"];
const _hoisted_2$B = { class: "md-icon-small inline" };
const _sfc_main$W = /* @__PURE__ */ defineComponent({
  __name: "settings-button",
  props: {
    componentSelectedState: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const { t } = useI18n();
    const panelStore = usePanelStore();
    const exportStore = useExportStore();
    const dropdownPlacement = computed(() => panelStore.mobileView ? "top-end" : "left-end");
    const toggleComponent = (component) => {
      if (!component.selectable) {
        return;
      }
      exportStore.toggleSelected({
        name: component.name
      });
    };
    return (_ctx, _cache) => {
      const _component_dropdown_menu = resolveComponent("dropdown-menu");
      const _directive_focus_item = resolveDirective("focus-item");
      return withDirectives((openBlock(), createBlock(_component_dropdown_menu, {
        position: dropdownPlacement.value,
        tooltip: unref(t)("export.menu"),
        tooltipPlacement: "top"
      }, {
        header: withCtx(() => _cache[0] || (_cache[0] = [
          createElementVNode("div", { class: "flex items-center text-gray-400 w-full h-full hover:text-black p-4 sm:p-8" }, [
            createElementVNode("svg", {
              class: "fill-current w-24 h-24 m-auto",
              xmlns: "http://www.w3.org/2000/svg",
              viewBox: "0 0 24 24"
            }, [
              createElementVNode("g", null, [
                createElementVNode("path", {
                  d: "M0,0h24v24H0V0z",
                  fill: "none"
                }),
                createElementVNode("path", { d: "M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z" })
              ])
            ])
          ], -1)
        ])),
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.componentSelectedState, (component) => {
            return openBlock(), createElementBlock("a", {
              key: component.name,
              onClick: ($event) => toggleComponent(component),
              href: "javascript:;",
              class: normalizeClass(`text-left text-sm sm:text-base ${component.selectable ? "cursor-pointer" : "cursor-default"}`),
              "aria-label": component.name
            }, [
              createElementVNode("div", _hoisted_2$B, [
                (openBlock(), createElementBlock("svg", {
                  height: "20",
                  width: "20",
                  viewBox: "0 0 24 24",
                  class: normalizeClass(`inline mx-8 ${!component.selected ? "invisible" : ""}`)
                }, _cache[1] || (_cache[1] = [
                  createElementVNode("g", null, [
                    createElementVNode("path", { d: "M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z" })
                  ], -1)
                ]), 2)),
                createElementVNode("span", {
                  class: normalizeClass(`inline ${!component.selectable ? "text-gray-300" : ""}
                    `)
                }, toDisplayString(unref(t)(`export.menu.component.${component.name}`)), 3)
              ])
            ], 10, _hoisted_1$N);
          }), 128))
        ]),
        _: 1
      }, 8, ["position", "tooltip"])), [
        [_directive_focus_item]
      ]);
    };
  }
});

const _hoisted_1$M = { ref: "componentEl" };
const _hoisted_2$A = { class: "flex" };
const _hoisted_3$u = ["aria-label"];
const _hoisted_4$j = ["aria-label"];
const _sfc_main$V = /* @__PURE__ */ defineComponent({
  __name: "screen",
  props: {
    panel: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const { t } = useI18n();
    const iApi = inject("iApi");
    const exportStore = useExportStore();
    const fixture = ref();
    const resizeObserver = ref(void 0);
    const watchers = ref([]);
    const el = useTemplateRef("componentEl");
    const componentSelectedState = computed(() => exportStore.componentSelectedState);
    const selectedComponents = computed(() => {
      let state = {};
      if (fixture.value) {
        Object.keys(componentSelectedState.value).forEach((component) => {
          state[component] = {
            name: component,
            selected: componentSelectedState.value[component] ?? false,
            selectable: (fixture.value?.config)[component]?.selectable ?? true
          };
        });
      }
      return state;
    });
    const hasCustomRenderer = computed(() => {
      return !!fixture.value?.customRendererFunc;
    });
    const make = debounce(300, () => {
      if (!fixture.value || !el.value) {
        return;
      }
      const canvasElement = el.value.querySelector(".export-canvas");
      fixture.value.make(canvasElement, el.value.clientWidth);
    });
    onBeforeMount(() => {
      props.panel.exportMake = make;
      watchers.value.push(
        // Listen for any changes to the settings, and refresh the image when they do change
        watch(selectedComponents, () => {
          make();
        })
      );
    });
    onMounted(() => {
      fixture.value = iApi.fixture.get("export");
      resizeObserver.value = new ResizeObserver(() => {
        make();
      });
      resizeObserver.value.observe(iApi?.$vApp.$root?.$el);
    });
    onBeforeUnmount(() => {
      resizeObserver.value.disconnect();
      watchers.value.forEach((unwatch) => unwatch());
    });
    return (_ctx, _cache) => {
      const _component_panel_screen = resolveComponent("panel-screen");
      return openBlock(), createElementBlock("div", _hoisted_1$M, [
        createVNode(_component_panel_screen, {
          panel: __props.panel,
          footer: true
        }, {
          header: withCtx(() => [
            createTextVNode(toDisplayString(unref(t)("export.title")), 1)
          ]),
          content: withCtx(() => _cache[2] || (_cache[2] = [
            createElementVNode("div", { class: "overflow-hidden border border-gray-200" }, [
              createElementVNode("canvas", { class: "export-canvas !w-[100%]" })
            ], -1)
          ])),
          footer: withCtx(() => [
            createElementVNode("div", _hoisted_2$A, [
              createElementVNode("button", {
                type: "button",
                onClick: _cache[0] || (_cache[0] = ($event) => fixture.value?.export()),
                class: "bg-green-700 hover:bg-green-800 text-white font-bold py-8 px-4 sm:px-16 mr-8 sm:mr-16",
                "aria-label": unref(t)("export.download")
              }, toDisplayString(unref(t)("export.download")), 9, _hoisted_3$u),
              createElementVNode("button", {
                type: "button",
                onClick: _cache[1] || (_cache[1] = ($event) => unref(make)()),
                class: "py-8 px-4 sm:px-16",
                "aria-label": unref(t)("export.refresh")
              }, toDisplayString(unref(t)("export.refresh")), 9, _hoisted_4$j),
              !hasCustomRenderer.value ? (openBlock(), createBlock(_sfc_main$W, {
                key: 0,
                componentSelectedState: selectedComponents.value,
                class: "ml-auto flex px-4 sm:px-8"
              }, null, 8, ["componentSelectedState"])) : createCommentVNode("", true)
            ])
          ]),
          _: 1
        }, 8, ["panel"])
      ], 512);
    };
  }
});

const screen$9 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: _sfc_main$V
}, Symbol.toStringTag, { value: 'Module' }));

const messages$d = {"en":{"export.title":"Export","export.alertName":"Export","export.download":"Download image","export.refresh":"Refresh","export.scaleBar.approx":"{0} approx.","export.menu":"Settings Menu","export.menu.component.title":"Title","export.menu.component.map":"Map","export.menu.component.mapElements":"North arrow and scalebar","export.menu.component.legend":"Legend","export.menu.component.footnote":"Footnote","export.menu.component.timestamp":"Timestamp"},"fr":{"export.title":"Exporter","export.alertName":"Exporter","export.download":"Télécharger l'image","export.refresh":"Rafraîchir","export.scaleBar.approx":"Environ {0}","export.menu":"Menu des paramètres","export.menu.component.title":"Titre","export.menu.component.map":"Carte","export.menu.component.mapElements":"Flèche du nord et échelle graphique","export.menu.component.legend":"Légende","export.menu.component.footnote":"Référence","export.menu.component.timestamp":"Horodatage"}};

class ExportFixture extends ExportAPI {
  initialized() {
  }
  async needed() {
    const exportTitle = (await Promise.resolve().then(() => index$i)).default;
    const exportMap = (await Promise.resolve().then(() => index$m)).default;
    const exportLegend = (await Promise.resolve().then(() => index$n)).default;
    const exportNorthArrow = (await Promise.resolve().then(() => index$l)).default;
    const exportScalebar = (await Promise.resolve().then(() => index$k)).default;
    const exportTimestamp = (await Promise.resolve().then(() => index$j)).default;
    const exportFootnote = (await Promise.resolve().then(() => index$o)).default;
    this.$iApi.fixture.add("export-title", exportTitle);
    this.$iApi.fixture.add("export-map", exportMap);
    this.$iApi.fixture.add("export-legend", exportLegend);
    this.$iApi.fixture.add("export-northarrow", exportNorthArrow);
    this.$iApi.fixture.add("export-scalebar", exportScalebar);
    this.$iApi.fixture.add("export-timestamp", exportTimestamp);
    this.$iApi.fixture.add("export-footnote", exportFootnote);
  }
  added() {
    this.$iApi.panel.register(
      {
        id: "export",
        config: {
          screens: {
            "export-screen": markRaw(_sfc_main$V)
          },
          style: {
            "flex-grow": "1",
            "max-width": "800px"
          },
          button: {
            tooltip: "export.title",
            // https://fonts.google.com/icons?selected=Material+Icons:layers&icon.query=export
            icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none" /><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z" /></svg>'
          },
          alertName: "export.alertName"
        }
      },
      { i18n: { messages: messages$d } }
    );
    const neededHandler = this.$iApi.event.on(GlobalEvents.PANEL_OPENED, async (panel) => {
      if (panel.id === "export") {
        this.$iApi.event.off(neededHandler);
        await this.needed();
        panel.exportMake();
      }
    });
    this._parseConfig(this.config);
    const unwatch = this.$vApp.$watch(
      () => this.config,
      (value) => this._parseConfig(value)
    );
    this.removed = () => {
      unwatch();
      this.$iApi.fixture.get("export-title")?.remove();
      this.$iApi.fixture.get("export-map")?.remove();
      this.$iApi.fixture.get("export-legend")?.remove();
      this.$iApi.fixture.get("export-northarrow")?.remove();
      this.$iApi.fixture.get("export-scalebar")?.remove();
      this.$iApi.fixture.get("export-timestamp")?.remove();
      this.$iApi.fixture.get("export-footnote")?.remove();
      if (this.$iApi.fixture.exists("appbar")) {
        const appbarStore = useAppbarStore(this.$vApp.$pinia);
        appbarStore.removeButton("export");
      }
      const exportStore = useExportStore(this.$vApp.$pinia);
      exportStore.$reset();
      this.$iApi.panel.remove("export");
    };
  }
}

const index$h = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: ExportFixture
}, Symbol.toStringTag, { value: 'Module' }));

class ExtentguardAPI extends FixtureInstance {
  /**
   * Parses the extentguard config JSON snippet from the config file and save to the fixture store.
   *
   * @param {extentguardConfig} [ExtentguardConfig]
   * @memberof ExtentguardAPI
   */
  _parseConfig(extentguardConfig) {
    if (extentguardConfig) {
      const store = useExtentguardStore(this.$vApp.$pinia);
      if (extentguardConfig.alwaysOn) {
        store.setAlwaysOn(true);
      }
      const esi = extentguardConfig.extentSetIds;
      if (esi && Array.isArray(esi) && esi.length > 0) {
        store.setExtentSetIds(esi);
      }
    }
  }
  get config() {
    return super.config;
  }
}

function clipCoords(testMax, testMin, boundingMax, boundingMin) {
  const testLength = testMax - testMin;
  const middle = testMin + testLength / 2;
  const safeLength = Math.min(testLength, boundingMax - boundingMin);
  if (middle > boundingMax) {
    return {
      min: boundingMax - safeLength,
      max: boundingMax,
      changed: true
    };
  } else if (middle < boundingMin) {
    return {
      min: boundingMin,
      max: boundingMin + safeLength,
      changed: true
    };
  } else {
    return {
      min: testMin,
      max: testMax,
      changed: false
    };
  }
}
class ExtentguardFixture extends ExtentguardAPI {
  /**
   * Schema change event handler name
   */
  schemaEH = "";
  /**
   * Extent change event handler name
   */
  extentEH = "";
  added() {
    this._parseConfig(this.config);
    const unwatch = this.$vApp.$watch(
      () => this.config,
      (value) => this._parseConfig(value)
    );
    this.removed = () => {
      unwatch();
      const store = useExtentguardStore(this.$vApp.$pinia);
      store.$reset();
      this.evtOff("schemaEH");
      this.evtOff("extentEH");
    };
    this.schemaEH = this.$iApi.event.on(GlobalEvents.MAP_BASEMAPCHANGE, (payload) => {
      if (payload.schemaChanged) {
        this.checkActive();
      }
    });
    if (this.$iApi.geo.map.created) {
      this.checkActive();
    } else {
      this.$iApi.event.once(GlobalEvents.MAP_CREATED, () => {
        this.checkActive();
      });
    }
  }
  /**
   * Examines current state of the instance and activates or deactivates appropriately
   */
  checkActive() {
    const store = useExtentguardStore(this.$vApp.$pinia);
    if (store.alwaysOn || store.extentSetIds.includes(this.$iApi.geo.map.getExtentSet().id)) {
      if (!store.active) {
        store.setActive(true);
        this.extentEH = this.$iApi.event.on(GlobalEvents.MAP_EXTENTCHANGE, (extent) => {
          if (!store.enforcing) {
            this.enforceBoundary(extent, false);
          }
        });
      }
    } else if (store.active) {
      store.setActive(false);
      this.evtOff("extentEH");
    }
  }
  /**
   * Wraps the act of checking if an event handler exists, and if so, removing it.
   * Just a reapeated code saver
   * @param eventPropName property name of this class that can hold an event handler name
   * @private
   */
  evtOff(eventPropName) {
    if (this[eventPropName]) {
      this.$iApi.event.off(this[eventPropName]);
      this[eventPropName] = "";
    }
  }
  /**
   * Checks if the center of the given extent is outside of the maps maximum extent. If it is,
   * will pan the map back to something appropriate
   *
   * @function enforceBoundary
   * @param {Extent} extent an extent to adjudicate
   * @param {boolean} safetyCheck indicates if this enforcement is a check against an original enforcement
   */
  enforceBoundary(extent, safetyCheck) {
    const maxExtent = this.$iApi.geo.map.getExtentSet().maximumExtent;
    const xTest = clipCoords(extent.xmax, extent.xmin, maxExtent.xmax, maxExtent.xmin);
    const yTest = clipCoords(extent.ymax, extent.ymin, maxExtent.ymax, maxExtent.ymin);
    if (yTest.changed || xTest.changed) {
      if (safetyCheck) {
        this.$iApi.geo.map.esriView.extent = maxExtent.toESRI();
      }
      const respectfulExtent = Extent.fromParams(
        "extguard",
        xTest.min,
        yTest.min,
        xTest.max,
        yTest.max,
        extent.sr
      );
      const store = useExtentguardStore(this.$vApp.$pinia);
      store.setEnforcing(true);
      setTimeout(() => {
        this.$iApi.geo.map.zoomMapTo(respectfulExtent, void 0, true, 400, "ease-in-out").then(() => {
          store.setEnforcing(false);
          this.enforceBoundary(this.$iApi.geo.map.getExtent(), true);
        });
      }, 150);
    }
  }
}

const index$g = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: ExtentguardFixture
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$U = /* @__PURE__ */ defineComponent({
  __name: "appbar-button",
  props: {
    options: {
      type: Object
    }
  },
  setup(__props) {
    const iApi = inject("iApi");
    const onClick = () => {
      iApi.panel.toggle({ id: "p2", screen: "p-2-screen-2" });
    };
    return (_ctx, _cache) => {
      const _component_appbar_button = resolveComponent("appbar-button", true);
      return openBlock(), createBlock(_component_appbar_button, {
        onClickFunction: onClick,
        tooltip: "Gazebo"
      }, {
        default: withCtx(() => [
          createElementVNode("span", {
            style: normalizeStyle({ color: __props.options?.colour ?? "#BDBDBD" })
          }, "G ", 4)
        ]),
        _: 1
      });
    };
  }
});

const _hoisted_1$L = { class: "flex flex-col items-center" };
const _sfc_main$T = /* @__PURE__ */ defineComponent({
  __name: "p1-screen-1",
  props: {
    panel: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_panel_screen = resolveComponent("panel-screen");
      return openBlock(), createBlock(_component_panel_screen, { panel: __props.panel }, {
        header: withCtx(() => _cache[1] || (_cache[1] = [
          createTextVNode(" Gazebo/Panel 1/Screen A ")
        ])),
        controls: withCtx(() => _cache[2] || (_cache[2] = [
          createElementVNode("a", { href: "javascript:;" }, "Option 1", -1),
          createElementVNode("a", { href: "javascript:;" }, "Option 2", -1),
          createElementVNode("a", { href: "javascript:;" }, "Option 3", -1)
        ])),
        content: withCtx(() => [
          createElementVNode("div", _hoisted_1$L, [
            createElementVNode("button", {
              type: "button",
              onClick: _cache[0] || (_cache[0] = ($event) => __props.panel.show({ screen: "p-1-screen-2" })),
              class: "bg-blue-500 hover:bg-blue-700 text-white font-bold py-8 px-16"
            }, " See Gazebo 2 "),
            _cache[3] || (_cache[3] = createElementVNode("br", null, null, -1)),
            _cache[4] || (_cache[4] = createElementVNode("img", {
              src: "https://c.tenor.com/RJ3ZG5beDhIAAAAC/napoleon-dynamite-napoleon.gif",
              alt: "Gazebo1"
            }, null, -1))
          ])
        ]),
        _: 1
      }, 8, ["panel"]);
    };
  }
});

const _hoisted_1$K = { class: "flex flex-col items-center" };
const _sfc_main$S = /* @__PURE__ */ defineComponent({
  __name: "p1-screen-2",
  props: {
    panel: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_panel_screen = resolveComponent("panel-screen");
      return openBlock(), createBlock(_component_panel_screen, { panel: __props.panel }, {
        header: withCtx(() => _cache[1] || (_cache[1] = [
          createTextVNode(" Gazebo/Panel 1/Screen B ")
        ])),
        content: withCtx(() => [
          createElementVNode("div", _hoisted_1$K, [
            createElementVNode("button", {
              type: "button",
              onClick: _cache[0] || (_cache[0] = ($event) => __props.panel.show({ screen: "p-1-screen-1" })),
              class: "bg-blue-500 hover:bg-blue-700 text-white font-bold py-8 px-16"
            }, " See Gazebo 1 "),
            _cache[2] || (_cache[2] = createElementVNode("br", null, null, -1)),
            _cache[3] || (_cache[3] = createElementVNode("img", {
              src: "http://nesn.com/wp-content/uploads/2014/09/jeternephew.gif",
              alt: "Gazebo2"
            }, null, -1))
          ])
        ]),
        _: 1
      }, 8, ["panel"]);
    };
  }
});

const _hoisted_1$J = { class: "flex flex-row justify-center items-center mt-16" };
const _hoisted_2$z = { class: "mt-16" };
const _sfc_main$R = /* @__PURE__ */ defineComponent({
  __name: "p2-screen-2",
  props: {
    panel: { type: Object, required: true },
    greeting: { type: String }
  },
  setup(__props) {
    const props = __props;
    const { t } = useI18n();
    const iApi = inject("iApi");
    const enhancedCatActivities = () => {
      props.panel.show("p-2-screen-3");
      iApi.event.emit("gazebo/beholdMyText", "I am a cat");
    };
    return (_ctx, _cache) => {
      const _component_panel_screen = resolveComponent("panel-screen");
      return openBlock(), createBlock(_component_panel_screen, { panel: __props.panel }, {
        header: withCtx(() => _cache[2] || (_cache[2] = [
          createTextVNode(" Gazebo/Panel 2/Screen B ")
        ])),
        content: withCtx(() => [
          createTextVNode(toDisplayString(unref(t)("gz.hello2")) + " ", 1),
          createElementVNode("div", _hoisted_1$J, [
            createElementVNode("button", {
              type: "button",
              onClick: _cache[0] || (_cache[0] = ($event) => __props.panel.show({
                screen: "p-2-screen-1",
                props: { greeting: "Greeting from Screen B" }
              })),
              class: "bg-green-500 hover:bg-green-700 text-white font-bold py-8 px-16"
            }, " Switch to Screen A "),
            createElementVNode("button", {
              type: "button",
              onClick: _cache[1] || (_cache[1] = ($event) => enhancedCatActivities()),
              class: "bg-blue-500 hover:bg-blue-700 text-white font-bold py-8 px-16 m-2"
            }, " See a cat ")
          ]),
          createElementVNode("p", _hoisted_2$z, toDisplayString(__props.greeting), 1)
        ]),
        _: 1
      }, 8, ["panel"]);
    };
  }
});

const _hoisted_1$I = { class: "flex flex-col items-center mt-16" };
const _hoisted_2$y = { class: "ml-32 font-bold" };
const _hoisted_3$t = { class: "ml-32 font-bold" };
const _hoisted_4$i = { class: "ml-32 font-bold" };
const _sfc_main$Q = /* @__PURE__ */ defineComponent({
  __name: "p2-screen-3",
  props: {
    panel: { type: Object, required: true }
  },
  setup(__props) {
    const { t } = useI18n({
      messages: {
        en: {
          lang_native: "En",
          who: "[me cat]"
        },
        fr: {
          lang_native: "Fr",
          who: "[moi chat]"
        }
      }
    });
    return (_ctx, _cache) => {
      const _component_panel_screen = resolveComponent("panel-screen");
      return openBlock(), createBlock(_component_panel_screen, { panel: __props.panel }, {
        header: withCtx(() => _cache[1] || (_cache[1] = [
          createTextVNode(" Gazebo/Panel 2/Screen C ")
        ])),
        content: withCtx(() => [
          createElementVNode("div", _hoisted_1$I, [
            createElementVNode("button", {
              type: "button",
              onClick: _cache[0] || (_cache[0] = ($event) => __props.panel.show({
                screen: "p-2-screen-1",
                props: { greeting: "Greeting from Screen C" }
              })),
              class: "bg-green-500 hover:bg-green-700 text-white font-bold py-8 px-16"
            }, " Switch to Screen A "),
            _cache[5] || (_cache[5] = createElementVNode("img", {
              class: "my-16",
              src: "https://media.giphy.com/media/iWkHDNtcHpB5e/giphy.gif",
              alt: "",
              srcset: ""
            }, null, -1)),
            _cache[6] || (_cache[6] = createElementVNode("p", null, "Locale merging:", -1)),
            createElementVNode("dl", null, [
              _cache[2] || (_cache[2] = createElementVNode("dt", null, "global locale:", -1)),
              createElementVNode("dd", _hoisted_2$y, toDisplayString(unref(t)("lang_native")), 1),
              _cache[3] || (_cache[3] = createElementVNode("dt", null, "fixture locale:", -1)),
              createElementVNode("dd", _hoisted_3$t, toDisplayString(unref(t)("gz.hello")), 1),
              _cache[4] || (_cache[4] = createElementVNode("dt", null, "common panels locale:", -1)),
              createElementVNode("dd", _hoisted_4$i, toDisplayString(unref(t)("who")), 1)
            ])
          ])
        ]),
        _: 1
      }, 8, ["panel"]);
    };
  }
});

const messages$c = {"en":{"gz.hello":"I'm a simple panel - but from a locale file","gz.hello2":"I'm a simple panel","gz.alert1":"Gazebo","gz.alert2":"Gazebo two"},"fr":{"gz.hello":"Bonjour. Je suis un panel\"","gz.hello2":"Bonjour. Je suis un panel\"","gz.alert1":"Gazebo","gz.alert2":"Gazebo deux"}};

const BEHOLD_TEXT_EVENT = "gazebo/beholdMyText";
class GazeboFixture extends FixtureInstance {
  added() {
    this.$iApi.event.registerEventName(BEHOLD_TEXT_EVENT);
    this.$iApi.component("gazebo-appbar-button", _sfc_main$U);
    this.$iApi.panel.register(
      {
        // panel-1 has examples of how not to bind things and interact with stuff; bad panel ❌
        // it generally avoids using API and goes straight to the store; fixtures/panels/screens should not do that;
        id: "p1",
        config: {
          screens: {
            "p-1-screen-1": markRaw(_sfc_main$T),
            "p-1-screen-2": markRaw(_sfc_main$S)
          },
          style: {
            "flex-grow": "1",
            "max-width": "500px"
          },
          alertName: "gz.alert1"
        }
      },
      { i18n: { messages: messages$c } }
    );
    this.$iApi.panel.register(
      {
        // panel-2 has examples of how properly bind things and interact with stuff; good panel ✔
        // use API functions; underlying store structure might change and all the code accessing the store directly will break
        id: "p2",
        config: {
          screens: {
            /**
             * // This should work:
             * manually lazy-loading a screen component
             */
            //'p-2-screen-1': () => import(/* webpackChunkName: "p-2-screen-1" */ `./p2-screen-1.vue`),
            /**
             * // This should work:
             * for the demo purposes, delay resolution of a component by 2 seconds
             */
            "p-2-screen-1": () => {
              return new Promise(
                (resolve) => setTimeout(
                  () => Promise.resolve().then(() => p2Screen1).then((data) => {
                    resolve(data);
                  }),
                  2e3
                )
              );
            },
            /**
             * // This should work:
             * letting the core to lazy-load a screen component; need to provide a path relative to the fixtures home folder
             */
            "p-2-screen-2": markRaw(_sfc_main$R),
            /**
             * // This should work:
             * returning a `VueConstructor` in a promise
             */
            "p-2-screen-3": () => {
              return new Promise((resolve) => resolve(markRaw(_sfc_main$Q)));
            }
          },
          style: {
            "flex-grow": "1",
            "max-width": "500px"
          },
          alertName: "gz.alert2"
        }
      },
      { i18n: { messages: messages$c } }
    );
    this.handlePanelTeleports(["p1", "p2"]);
  }
}

const index$f = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: GazeboFixture
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$H = { class: "rv-geosearch-bar relative h-26 mx-8 mb-8" };
const _hoisted_2$x = ["placeholder", "value", "aria-label"];
const _hoisted_3$s = { class: "absolute inset-y-0 right-8 grid w-10 place-content-center" };
const _hoisted_4$h = ["aria-label", "content"];
const _sfc_main$P = /* @__PURE__ */ defineComponent({
  __name: "search-bar",
  setup(__props) {
    const { t } = useI18n();
    const geosearchStore = useGeosearchStore();
    const panelStore = usePanelStore();
    const searchVal = computed(() => geosearchStore.searchVal);
    const badChars = computed(
      () => ['"', "$", "!", "*", "+", "?", "^", "{", "}", "(", ")", "|", "[", "]"].filter((bc) => geosearchStore.searchVal.includes(bc)).join("")
    );
    const setSearchTerm = (value) => {
      geosearchStore.setSearchTerm(value);
      geosearchStore.setSearchRegex(value);
    };
    const onSearchTermChange = debounce(500, (searchTerm) => {
      setSearchTerm(searchTerm);
    });
    return (_ctx, _cache) => {
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", _hoisted_1$H, [
        createElementVNode("input", {
          type: "text",
          class: normalizeClass(["border-b w-full text-base py-8 outline-none focus:shadow-outline border-gray-600 h-full min-w-0", { "border-yellow-500": badChars.value }]),
          placeholder: unref(t)("geosearch.searchText"),
          value: searchVal.value,
          onInput: _cache[0] || (_cache[0] = ($event) => unref(onSearchTermChange)($event.target.value)),
          onKeyup: _cache[1] || (_cache[1] = withKeys(($event) => {
            if (unref(panelStore).mobileView) {
              $event.target.blur();
            }
          }, ["enter"])),
          "aria-label": unref(t)("geosearch.searchText"),
          onKeypress: _cache[2] || (_cache[2] = withKeys(withModifiers(() => {
          }, ["prevent"]), ["enter"])),
          enterkeyhint: "done"
        }, null, 42, _hoisted_2$x),
        createElementVNode("span", _hoisted_3$s, [
          badChars.value ? withDirectives((openBlock(), createElementBlock("button", {
            key: 0,
            class: "cursor-default",
            "aria-label": unref(t)("geosearch.badChars", { chars: badChars.value }),
            content: unref(t)("geosearch.badChars", { chars: badChars.value })
          }, _cache[3] || (_cache[3] = [
            createTextVNode(" ⚠ ")
          ]), 8, _hoisted_4$h)), [
            [_directive_tippy]
          ]) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const _hoisted_1$G = { class: "rv-geosearch-top-filters sm:flex items-center w-full ml-8 mb-14" };
const _hoisted_2$w = { class: "w-fit inline-block sm:w-1/2 h-26 mb-8 sm:mb-0 pr-16 sm:pr-0" };
const _hoisted_3$r = ["value", "aria-label"];
const _hoisted_4$g = {
  value: "",
  disabled: "",
  hidden: ""
};
const _hoisted_5$d = { class: "sm:w-1/2 h-26 sm:mx-16 flex" };
const _hoisted_6$c = ["value", "aria-label"];
const _hoisted_7$c = {
  value: "",
  disabled: "",
  hidden: ""
};
const _hoisted_8$8 = ["disabled", "content", "aria-label"];
const _sfc_main$O = /* @__PURE__ */ defineComponent({
  __name: "top-filters",
  setup(__props) {
    const { t } = useI18n();
    const iApi = inject("iApi");
    const geosearchStore = useGeosearchStore();
    const provinces = ref([]);
    const types = ref([]);
    const watchers = ref([]);
    const queryParams = computed(() => geosearchStore.queryParams);
    const language = computed(() => iApi.language);
    const setProvince = (payload) => geosearchStore.setProvince(payload);
    const setType = (payload) => geosearchStore.setType(payload);
    const clearFilters = () => {
      setProvince({});
      setType({});
    };
    const updateProvincesAndTypes = () => {
      geosearchStore.initService(iApi.language, iApi.fixture.get("geosearch").config);
      const queryProvCode = provinces.value.find((prov) => queryParams.value.province === prov.name)?.code;
      const queryTypeCode = types.value.find((type) => queryParams.value.type === type.name)?.code;
      geosearchStore.getProvinces.then((provs) => {
        provinces.value = provs;
        setProvince({
          province: provs.find((prov) => prov.code === queryProvCode)?.name,
          forceReRun: true
        });
      });
      geosearchStore.getTypes.then((typs) => {
        types.value = typs;
        setType({
          type: typs.find((type) => type.code === queryTypeCode)?.name,
          forceReRun: true
        });
      });
    };
    onBeforeMount(() => {
      updateProvincesAndTypes();
      watchers.value.push(watch(language, updateProvincesAndTypes));
    });
    onBeforeUnmount(() => {
      watchers.value.forEach((unwatch) => unwatch());
    });
    return (_ctx, _cache) => {
      const _directive_truncate = resolveDirective("truncate");
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", _hoisted_1$G, [
        createElementVNode("div", _hoisted_2$w, [
          withDirectives((openBlock(), createElementBlock("select", {
            class: "border-b border-b-gray-600 w-full h-full py-0 cursor-pointer",
            value: queryParams.value.province,
            "aria-label": unref(t)("geosearch.filters.province"),
            onChange: _cache[0] || (_cache[0] = ($event) => setProvince({
              province: $event.target.value
            }))
          }, [
            withDirectives((openBlock(), createElementBlock("option", _hoisted_4$g, [
              createTextVNode(toDisplayString(unref(t)("geosearch.filters.province")), 1)
            ])), [
              [_directive_truncate]
            ]),
            (openBlock(true), createElementBlock(Fragment, null, renderList(provinces.value, (province) => {
              return withDirectives((openBlock(), createElementBlock("option", {
                key: province.code
              }, [
                createTextVNode(toDisplayString(province.name), 1)
              ])), [
                [_directive_truncate]
              ]);
            }), 128))
          ], 40, _hoisted_3$r)), [
            [_directive_truncate]
          ])
        ]),
        createElementVNode("div", _hoisted_5$d, [
          withDirectives((openBlock(), createElementBlock("select", {
            class: "border-b border-b-gray-600 w-full h-full py-0 cursor-pointer max-w-150",
            value: queryParams.value.type,
            "aria-label": unref(t)("geosearch.filters.type"),
            onChange: _cache[1] || (_cache[1] = ($event) => setType({
              type: $event.target.value
            }))
          }, [
            createElementVNode("option", _hoisted_7$c, toDisplayString(unref(t)("geosearch.filters.type")), 1),
            (openBlock(true), createElementBlock(Fragment, null, renderList(types.value, (t2) => {
              return openBlock(), createElementBlock("option", {
                key: t2.code
              }, toDisplayString(t2.name), 1);
            }), 128))
          ], 40, _hoisted_6$c)), [
            [_directive_truncate]
          ]),
          withDirectives((openBlock(), createElementBlock("button", {
            type: "button",
            class: "text-gray-500 w-1/8 h-24 pl-8 pr-16 sm:pr-8 hover:text-black disabled:cursor-default disabled:text-gray-400",
            disabled: !queryParams.value.type && !queryParams.value.province,
            onClick: clearFilters,
            content: unref(t)("geosearch.filters.clear"),
            "aria-label": unref(t)("geosearch.filters.clear")
          }, _cache[2] || (_cache[2] = [
            createElementVNode("div", { class: "rv-geosearch-icon" }, [
              createElementVNode("svg", {
                class: "fill-current w-18 h-18",
                viewBox: "0 0 23 21"
              }, [
                createElementVNode("path", { d: "M 14.7574,20.8284L 17.6036,17.9822L 14.7574,15.1716L 16.1716,13.7574L 19.0178,16.568L 21.8284,13.7574L 23.2426,15.1716L 20.432,17.9822L 23.2426,20.8284L 21.8284,22.2426L 19.0178,19.3964L 16.1716,22.2426L 14.7574,20.8284 Z M 2,2L 19.9888,2.00001L 20,2.00001L 20,2.01122L 20,3.99999L 19.9207,3.99999L 13,10.9207L 13,22.909L 8.99999,18.909L 8.99999,10.906L 2.09405,3.99999L 2,3.99999L 2,2 Z " })
              ])
            ], -1)
          ]), 8, _hoisted_8$8)), [
            [_directive_tippy, { placement: "bottom" }]
          ])
        ])
      ]);
    };
  }
});

const _hoisted_1$F = { class: "rv-geosearch-bottom-filters" };
const _hoisted_2$v = { class: "bg-white" };
const _hoisted_3$q = { class: "ml-8 cursor-pointer font-normal" };
const _hoisted_4$f = ["checked"];
const _sfc_main$N = /* @__PURE__ */ defineComponent({
  __name: "bottom-filters",
  setup(__props) {
    const { t } = useI18n();
    const iApi = inject("iApi");
    const geosearchStore = useGeosearchStore();
    const resultsVisible = computed(() => geosearchStore.resultsVisible);
    const onMapExtentChange = debounce(300, (newExtent) => {
      latLongExtent(newExtent).then((e) => {
        setMapExtent({
          extent: e,
          visible: resultsVisible.value
        });
      });
    });
    const setMapExtent = (mapExtent) => {
      geosearchStore.setMapExtent(mapExtent);
    };
    const latLongExtent = async (ext) => {
      if (ext.sr.wkid === 4326) {
        return ext;
      } else {
        const pExt = await iApi.geo.proj.projectGeometry(4326, ext);
        return pExt;
      }
    };
    const updateMapExtent = (visible) => {
      latLongExtent(iApi.geo.map.getExtent()).then((e) => {
        setMapExtent({
          extent: e,
          visible
        });
      });
    };
    onMounted(() => {
      iApi.event.on(GlobalEvents.MAP_EXTENTCHANGE, onMapExtentChange, "geosearch_map_extent");
    });
    onBeforeUnmount(() => {
      iApi.event.off("geosearch_map_extent");
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$F, [
        createElementVNode("div", _hoisted_2$v, [
          createElementVNode("label", _hoisted_3$q, [
            createElementVNode("input", {
              type: "checkbox",
              class: "border-2 mx-8 border-gray-600 cursor-pointer",
              checked: resultsVisible.value,
              onChange: _cache[0] || (_cache[0] = ($event) => updateMapExtent($event.target.checked)),
              onKeypress: _cache[1] || (_cache[1] = withKeys(withModifiers(() => {
              }, ["prevent"]), ["enter"]))
            }, null, 40, _hoisted_4$f),
            createTextVNode(toDisplayString(unref(t)("geosearch.visible")), 1)
          ])
        ])
      ]);
    };
  }
});

const _sfc_main$M = {};

const _hoisted_1$E = { class: "w-full h-6 relative overflow-hidden rounded-full indeterminate mb-14" };
const _hoisted_2$u = {
  class: "h-full progressbar bg-blue-800 rounded-full top-0",
  "aria-valuemin": "0",
  "aria-valuemax": "100"
};
const _hoisted_3$p = { class: "flex items-center h-full" };

function _sfc_render$1(_ctx, _cache) {
  return (openBlock(), createElementBlock("div", _hoisted_1$E, [
    createElementVNode("div", _hoisted_2$u, [
      createElementVNode("span", _hoisted_3$p, [
        renderSlot(_ctx.$slots, "default", {}, undefined, true)
      ])
    ])
  ]))
}
const LoadingBar = /*#__PURE__*/_export_sfc(_sfc_main$M, [['render',_sfc_render$1],['__scopeId',"data-v-0a8d1c36"]]);

const _hoisted_1$D = { class: "flex flex-col h-full" };
const _hoisted_2$t = {
  key: 1,
  class: "text-red-900 text-xs px-8 mb-10"
};
const _hoisted_3$o = {
  key: 2,
  class: "px-8 mb-10 py-8 flex-grow text-wrap border-y border-gray-600 overflow-y-auto"
};
const _hoisted_4$e = { class: "relative h-48" };
const _hoisted_5$c = { class: "font-bold text-blue-600" };
const _hoisted_6$b = {
  key: 3,
  class: "rv-results-list flex-grow mb-5 border-t border-b border-gray-600 overflow-y-auto"
};
const _hoisted_7$b = ["onClick"];
const _hoisted_8$7 = { class: "rv-result-description px-8" };
const _hoisted_9$5 = { class: "flex-1 text-left truncate font-bold leading-tight" };
const _hoisted_10$4 = ["innerHTML"];
const _hoisted_11$4 = {
  key: 0,
  class: "text-gray-600 text-sm"
};
const _hoisted_12$4 = {
  key: 1,
  class: "hidden"
};
const _hoisted_13$3 = {
  key: 2,
  class: "text-sm font-normal"
};
const _sfc_main$L = /* @__PURE__ */ defineComponent({
  __name: "screen",
  props: {
    panel: {
      type: Object
    }
  },
  setup(__props) {
    const { t } = useI18n();
    const iApi = inject("iApi");
    const geosearchStore = useGeosearchStore();
    const cleanedSearchVal = computed(() => geosearchStore.searchVal.replace(/["!*$+?^{}()|[\]\\]/g, "").trim());
    const searchResults = computed(() => geosearchStore.searchResults);
    const loadingResults = computed(() => geosearchStore.loadingResults);
    const failedServices = computed(() => geosearchStore.failedServices);
    const zoomIn = (result) => {
      let zoom = new Polygon(
        "zoomies",
        [
          [
            [result.bbox[0], result.bbox[1]],
            [result.bbox[0], result.bbox[3]],
            [result.bbox[2], result.bbox[3]],
            [result.bbox[2], result.bbox[1]],
            [result.bbox[0], result.bbox[1]]
          ]
        ],
        SpatialReference.latLongSR(),
        true
      );
      iApi.geo.map.zoomMapTo(zoom);
    };
    const highlightSearchTerm = (name, province) => {
      const highlightedResult = name.replace(
        new RegExp(`${geosearchStore.searchRegex}`, "gi"),
        (match) => '<span class="font-bold text-blue-600">' + match + "</span>"
      );
      return province ? highlightedResult + "," : highlightedResult;
    };
    return (_ctx, _cache) => {
      const _component_panel_screen = resolveComponent("panel-screen");
      const _directive_truncate = resolveDirective("truncate");
      const _directive_focus_item = resolveDirective("focus-item");
      const _directive_focus_list = resolveDirective("focus-list");
      return openBlock(), createBlock(_component_panel_screen, { panel: __props.panel }, {
        header: withCtx(() => [
          createTextVNode(toDisplayString(unref(t)("geosearch.title")), 1)
        ]),
        content: withCtx(() => [
          createElementVNode("div", _hoisted_1$D, [
            createVNode(_sfc_main$P),
            createVNode(_sfc_main$O),
            loadingResults.value ? (openBlock(), createBlock(LoadingBar, {
              key: 0,
              class: "flex-none"
            })) : createCommentVNode("", true),
            failedServices.value.length > 0 && !loadingResults.value ? (openBlock(), createElementBlock("div", _hoisted_2$t, toDisplayString(unref(t)("geosearch.serviceError", {
              services: failedServices.value.join(", ")
            })), 1)) : createCommentVNode("", true),
            cleanedSearchVal.value && searchResults.value.length === 0 && !loadingResults.value ? (openBlock(), createElementBlock("div", _hoisted_3$o, [
              createElementVNode("span", _hoisted_4$e, [
                createTextVNode(toDisplayString(unref(t)("geosearch.noResults")), 1),
                createElementVNode("span", _hoisted_5$c, '"' + toDisplayString(cleanedSearchVal.value) + '"', 1)
              ])
            ])) : createCommentVNode("", true),
            searchResults.value.length > 0 ? withDirectives((openBlock(), createElementBlock("ul", _hoisted_6$b, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(searchResults.value, (result, idx) => {
                return openBlock(), createElementBlock("li", {
                  class: "relative h-56",
                  key: idx
                }, [
                  withDirectives((openBlock(), createElementBlock("button", {
                    type: "button",
                    class: "absolute inset-0 h-full w-full hover:bg-gray-300 default-focus-style",
                    onClick: ($event) => zoomIn(result),
                    style: { "border-bottom": "1px solid lightgray" },
                    "truncate-trigger": ""
                  }, [
                    createElementVNode("div", _hoisted_8$7, [
                      withDirectives((openBlock(), createElementBlock("div", _hoisted_9$5, [
                        createElementVNode("span", {
                          innerHTML: highlightSearchTerm(result.name, result.location.province)
                        }, null, 8, _hoisted_10$4),
                        result.location.province ? (openBlock(), createElementBlock("span", _hoisted_11$4, toDisplayString(result.location.city ? " " + result.location.city + ", " + result.location.province.abbr : " " + result.location.province.abbr), 1)) : createCommentVNode("", true),
                        result.type ? (openBlock(), createElementBlock("span", _hoisted_12$4, "; ")) : createCommentVNode("", true),
                        result.type ? (openBlock(), createElementBlock("span", _hoisted_13$3, [
                          _cache[0] || (_cache[0] = createElementVNode("br", null, null, -1)),
                          createTextVNode(toDisplayString(result.type), 1)
                        ])) : createCommentVNode("", true)
                      ])), [
                        [_directive_truncate, {
                          externalTrigger: true,
                          options: { placement: "top-start" }
                        }]
                      ])
                    ])
                  ], 8, _hoisted_7$b)), [
                    [_directive_focus_item, "show-truncate"]
                  ])
                ]);
              }), 128))
            ])), [
              [_directive_focus_list]
            ]) : createCommentVNode("", true),
            createVNode(_sfc_main$N, { class: "mt-auto" })
          ])
        ]),
        _: 1
      }, 8, ["panel"]);
    };
  }
});

const screen$8 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: _sfc_main$L
}, Symbol.toStringTag, { value: 'Module' }));

class GeosearchAPI extends FixtureInstance {
}

const _sfc_main$K = /* @__PURE__ */ defineComponent({
  __name: "nav-button",
  setup(__props) {
    const { t } = useI18n();
    const iApi = inject("iApi");
    const togglePanel = () => {
      iApi?.panel.toggle("geosearch");
    };
    return (_ctx, _cache) => {
      const _component_mapnav_button = resolveComponent("mapnav-button");
      return openBlock(), createBlock(_component_mapnav_button, {
        onClickFunction: togglePanel,
        tooltip: unref(t)("geosearch.title")
      }, {
        default: withCtx(() => _cache[0] || (_cache[0] = [
          createElementVNode("svg", {
            class: "fill-current w-32 h-20",
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24"
          }, [
            createElementVNode("path", { d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" }),
            createElementVNode("path", {
              d: "M0 0h24v24H0z",
              fill: "none"
            })
          ], -1)
        ])),
        _: 1
      }, 8, ["tooltip"]);
    };
  }
});

const messages$b = {"en":{"geosearch.title":"Geolocation Search","geosearch.noResults":"No results to show for ","geosearch.searchText":"Search for a location...","geosearch.visible":"Visible on map","geosearch.filters.province":"Province","geosearch.filters.type":"Type","geosearch.filters.clear":"Clear filters","geosearch.serviceError":"No response from {services} service(s)","geosearch.badChars":"The character(s) {chars} are not supported and will be ignored"},"fr":{"geosearch.title":"Recherche géolocalisée","geosearch.noResults":"Aucun résultat à afficher pour ","geosearch.searchText":"Rechercher un emplacement...","geosearch.visible":"Visible sur la carte","geosearch.filters.province":"Province","geosearch.filters.type":"Type","geosearch.filters.clear":"Effacer les filtres","geosearch.serviceError":"Pas de réponse de la part des services de {services}","geosearch.badChars":"Les caractères {chars} ne sont pas pris en charge et seront ignorés"}};

class GeosearchFixture extends GeosearchAPI {
  async added() {
    const geosearchStore = useGeosearchStore(this.$vApp.$pinia);
    geosearchStore.initService(this.$iApi.language, this.config);
    this.$iApi.component("geosearch-nav-button", _sfc_main$K);
    this.$iApi.panel.register(
      {
        id: "geosearch",
        config: {
          screens: {
            "geosearch-component": markRaw(_sfc_main$L)
          },
          button: {
            tooltip: "geosearch.title",
            icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" /><path d="M0 0h24v24H0z" fill="none" /></svg>'
          },
          alertName: "geosearch.title"
        }
      },
      { i18n: { messages: messages$b } }
    );
    this.handlePanelTeleports(["geosearch"]);
  }
  removed() {
    if (this.$iApi.fixture.exists("appbar")) {
      const appbarStore = useAppbarStore(this.$vApp.$pinia);
      appbarStore.removeButton("geosearch");
    }
    if (this.$iApi.fixture.exists("mapnav")) {
      const mapnavStore = useMapnavStore(this.$vApp.$pinia);
      mapnavStore.removeItem("geosearch");
    }
    const geosearchStore = useGeosearchStore(this.$vApp.$pinia);
    geosearchStore.$reset();
    this.$iApi.panel.remove("geosearch");
  }
}

const index$e = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: GeosearchFixture
}, Symbol.toStringTag, { value: 'Module' }));

class ColumnStateManager {
  constructor(columnConfig) {
    this.columnConfig = columnConfig;
    this._field = columnConfig?.field;
    this._title = columnConfig?.title;
    this._visible = columnConfig.visible ?? true;
    this._width = columnConfig?.width;
    this._sort = columnConfig.sort ?? "none";
    this._searchable = columnConfig.searchable ?? true;
    this._filter = {
      type: columnConfig?.filter?.type ?? "string",
      value: columnConfig?.filter?.value ?? "",
      min: columnConfig?.filter?.min ?? null,
      max: columnConfig?.filter?.max ?? null,
      static: columnConfig?.filter?.static ?? false
    };
    this._template = columnConfig.template ?? "";
  }
  /**
   * Returns the field of the column.
   *
   * @memberof ColumnStateManager
   */
  get field() {
    return this._field;
  }
  /**
   * Returns the title of the column.
   *
   * @memberof ColumnStateManager
   */
  get title() {
    return this._title;
  }
  /**
   * Sets the title of the column.
   *
   * @memberof ColumnStateManager
   */
  set title(val) {
    this._title = val;
  }
  /**
   * Returns whether column is visible.
   *
   * @memberof ColumnStateManager
   */
  get visible() {
    return this._visible;
  }
  /**
   * Sets column visibility.
   *
   * @memberof ColumnStateManager
   */
  set visible(val) {
    this._visible = val;
  }
  /**
   * Returns the column width.
   *
   * @memberof ColumnStateManager
   */
  get width() {
    return this._width;
  }
  /**
   * Sets the column width.
   *
   * @memberof ColumnStateManager
   */
  set width(val) {
    this._width = val;
  }
  /**
   * Returns whether the column is sorted.
   *
   * @memberof ColumnStateManager
   */
  get sort() {
    return this._sort;
  }
  /**
   * Sets the column to be sorted.
   *
   * @memberof ColumnStateManager
   */
  set sort(val) {
    this._sort = val;
  }
  /**
   * Returns whether the column search is currently enabled.
   *
   * @memberof ColumnStateManager
   */
  get searchable() {
    return this._searchable;
  }
  /**
   * Sets the column search to enabled or disabled.
   *
   * @memberof ColumnStateManager
   */
  set searchable(val) {
    this._searchable = val;
  }
  /**
   * Returns the filter configuration of the column.
   *
   * @memberof ColumnStateManager
   */
  get filter() {
    return this._filter;
  }
  /**
   * Sets the filter configuration of the column.
   *
   * @memberof ColumnStateManager
   */
  set filter(val) {
    this._filter = val;
  }
  /**
   * Sets the vue template of the column
   * @memberof ColumnStateManager
   */
  set template(val) {
    this._template = val;
  }
  get template() {
    return this._template;
  }
}

class TableStateManager {
  constructor(options) {
    this.state = options ?? {};
    this._title = options?.title ?? "";
    this._showFilter = options?.showFilter ?? true;
    this._filterByExtent = options?.filterByExtent ?? false;
    this._columns = {};
    this._open = true;
    this._filtered = true;
    this._search = options?.search ?? true;
    this._searchFilter = options?.searchFilter ?? "";
    this._applyToMap = options?.applyToMap ?? false;
    this._controls = options?.controls ?? ["zoom", "details"];
    this.parsecolumns();
  }
  /**
   * Parses any given configurations of columns.
   *
   * @memberof TableStateManager
   */
  parsecolumns() {
    if (this.state.columns) {
      this.state.columns.forEach((columnConfig) => {
        this._columns[columnConfig.field] = new ColumnStateManager(columnConfig);
      });
    }
  }
  /**
   * Returns the stored filter value for the given column field.
   *
   * @param {*} colDefField
   * @param {string} range
   * @returns {string | number}
   * @memberof TableStateManager
   */
  getColumnFilterValue(colDefField, range) {
    const filter = this._columns[colDefField].filter;
    if (range === "min") {
      return filter.min;
    } else if (range === "max") {
      return filter.max;
    } else {
      return filter.value;
    }
  }
  /**
   * Saves the current value of the filter for the given column field.
   *
   * @param {*} colDefField
   * @param {(string | number)} filterValue
   * @param {string} range
   * @memberof TableStateManager
   */
  setColumnFilterValue(colDefField, filterValue, range) {
    let newFilterValue = filterValue;
    if (filterValue && typeof filterValue === "string") {
      const escRegex = /[(!"#$%&'+,.\\/:;<=>?@[\]^`{|}~)]/g;
      newFilterValue = filterValue.replace(escRegex, "\\$&");
    }
    if (range === "min") {
      this._columns[colDefField].filter.min = newFilterValue;
    } else if (range === "max") {
      this._columns[colDefField].filter.max = newFilterValue;
    } else {
      this._columns[colDefField].filter.value = newFilterValue;
    }
    if (this._columns[colDefField].filter.value !== "") {
      this._filtered = true;
    } else {
      this._checkFilters();
    }
  }
  /**
   * Clears all saved filters.
   *
   * @memberof TableStateManager
   */
  clearFilters() {
    Object.entries(this._columns).forEach(([, config]) => {
      if (!config.filter.static) {
        config.filter.min = null;
        config.filter.max = null;
        config.filter.value = "";
      }
    });
    this._filterByExtent = false;
    this._filtered = false;
    this._searchFilter = "";
  }
  _checkFilters() {
    this._filtered = Object.values(this._columns).some((config) => {
      return config.filter.value !== "" || config.filter.min || config.filter.max;
    });
  }
  get filtered() {
    return this._filtered;
  }
  /**
   * Returns the title of the datatable.
   *
   * @memberof TableStateManager
   */
  get title() {
    return this._title;
  }
  /**
   * Sets the title of the datatable.
   *
   * @memberof TableStateManager
   */
  set title(val) {
    this._title = val;
  }
  /**
   * Returns whether column filters are enabled for the table.
   *
   * @memberof TableStateManager
   */
  get colFilter() {
    return this._showFilter;
  }
  /**
   * Sets column filters to on or off.
   *
   * @memberof TableStateManager
   */
  set colFilter(val) {
    this._showFilter = val;
  }
  /**
   * Returns whether the grid is filtering by map extent.
   *
   * @memberof TableStateManager
   */
  get filterByExtent() {
    return this._filterByExtent;
  }
  /**
   * Sets the extent filter to on or off.
   *
   * @memberof TableStateManager
   */
  set filterByExtent(val) {
    this._filterByExtent = val;
  }
  /**
   * Returns whether the grid is currently open.
   *
   * @memberof TableStateManager
   */
  get open() {
    return this._open;
  }
  /**
   * Sets the grid status to open or closed.
   *
   * @memberof TableStateManager
   */
  set open(val) {
    this._open = val;
  }
  /**
   * Returns whether the global search is currently enabled.
   *
   * @memberof TableStateManager
   */
  get search() {
    return this._search;
  }
  /**
   * Sets the global search to enabled or disabled.
   *
   * @memberof TableStateManager
   */
  set search(val) {
    this._search = val;
  }
  /**
   * Returns the value of the global search.
   *
   * @memberof TableStateManager
   */
  get searchFilter() {
    return this._searchFilter;
  }
  /**
   * Sets the value of the global search.
   *
   * @memberof TableStateManager
   */
  set searchFilter(val) {
    this._searchFilter = val;
  }
  /**
   * Returns whether grid filters should apply to the map.
   *
   * @memberof TableStateManager
   */
  get applyToMap() {
    return this._applyToMap;
  }
  /**
   * Sets the grid to enable or disable filtering results on the map.
   *
   * @memberof TableStateManager
   */
  set applyToMap(val) {
    this._applyToMap = val;
  }
  /**
   * Returns an array of column configs.
   *
   * @memberof TableStateManager
   */
  get columns() {
    return this._columns;
  }
  /**
   * Sets column configs
   *
   * @memberof TableStateManager
   */
  set columns(val) {
    this._columns = val;
  }
  /**
   * Returns an array of grid action buttons.
   *
   * @memberof TableStateManager
   */
  get controls() {
    return this._controls;
  }
}

class GridAPI extends FixtureInstance {
  gridStore = useGridStore(this.$vApp.$pinia);
  /**
   * Open the grid with the given id.
   *
   * @param {string} id
   * @param {boolean} [open] force panel open or closed
   * @memberof GridAPI
   */
  toggleGrid(id, open) {
    const gridId = this.gridStore.getGridId(id);
    if (!gridId) {
      const layerGridConfigs = this.getLayerFixtureConfigs();
      this.gridStore.addGrid({
        id,
        layerIds: [id],
        state: new TableStateManager(layerGridConfigs[id]),
        fieldMap: {}
      });
    }
    const prevId = this.gridStore.currentId;
    this.gridStore.currentId = gridId ?? id;
    const panel = this.$iApi.panel.get("grid");
    if (open === false) {
      panel.close();
      return;
    }
    if (!panel.isOpen || !panel.isVisible) {
      this.$iApi.panel.open("grid");
    } else if (prevId !== id || open === true) {
      panel.show({ screen: "grid-screen", props: { key: id } });
    } else {
      panel.close();
    }
  }
  /**
   * Parses the grid config JSON snippet from the config file.
   *
   * @param {any} config
   * @memberof GridAPI
   */
  _parseConfig(config) {
    this.handlePanelWidths(["grid"]);
    this.handlePanelTeleports(["grid"]);
    const layerGridConfigs = this.getLayerFixtureConfigs();
    if (config && config.mergeGrids) {
      config.mergeGrids.forEach((mergeGrid) => {
        const layerIds = [];
        const { gridId, layers, fieldMap, options } = mergeGrid;
        layers.forEach((layer) => {
          if (layer.sublayers) {
            layer.sublayers?.forEach((sl) => {
              layerIds.push(`${layer.layerId}-${sl}`);
              delete layerGridConfigs[`${layer.layerId}-${sl}`];
            });
          } else {
            layerIds.push(layer.layerId);
            delete layerGridConfigs[layer.layerId];
          }
        });
        const mapping = {};
        fieldMap?.forEach((map) => {
          map.sources.forEach((source) => {
            mapping[source] = map.field;
          });
        });
        const gridConfig = {
          id: gridId,
          layerIds,
          state: new TableStateManager(options),
          fieldMap: mapping
        };
        this.gridStore.addGrid(gridConfig);
      });
    }
    Object.keys(layerGridConfigs).forEach((layerId) => {
      const gridConfig = {
        id: layerId,
        layerIds: [layerId],
        state: new TableStateManager(layerGridConfigs[layerId]),
        fieldMap: {}
      };
      this.gridStore.addGrid(gridConfig);
    });
  }
}

const messages$a = {"en":{"grid.title":"Datatable","grid.alertName":"Grid","grid.splash.error":"Error: Failed to load the layer's data.","grid.splash.loading":"Loading data...","grid.splash.building":"Building table...","grid.splash.cancel":"Cancel","grid.clearAll":"Clear search and filters","grid.layer.loading":"The layer is loading...","grid.label.pinColumns":"Pin columns","grid.label.export":"Export","grid.label.columns":"Hide columns","grid.label.copied":"Copied","grid.label.copy":"Press ctrl + c or double click to copy","grid.label.specialColumn":"Special Column","grid.label.filters.show":"Show filters","grid.label.filters.hide":"Hide filters","grid.label.filters.apply":"Apply filters to map","grid.header.sort.0":"Sort ascending","grid.header.sort.1":"Sort descending","grid.header.sort.2":"Sort default","grid.header.reorder.left":"Move left","grid.header.reorder.right":"Move right","grid.filters.label.global":"Search table","grid.filters.column.label.text":"Search {0}...","grid.filters.clear":"Clear filters","grid.filters.number.max":"Max","grid.filters.number.min":"Min","grid.filters.date.max":"Max Date","grid.filters.date.min":"Min Date","grid.filters.label.info":"{range} of {total} entries shown","grid.filters.label.filtered":"(filtered from {max} total entries)","grid.filters.label.extent":"Filter by extent","grid.cells.zoom":"Zoom to feature","grid.cells.zoom.zooming":"Zooming...","grid.cells.zoom.error":"Zoom failed","grid.cells.zoom.zoomed":"Zoomed","grid.cells.alert.zoom":"Zoomed into feature","grid.cells.details":"Details","grid.button.title":"Grid"},"fr":{"grid.title":"Tableau de données","grid.alertName":"Grille","grid.splash.error":"Erreur : Échec du chargement des données de la couche.","grid.splash.loading":"Chargement des données...","grid.splash.building":"Création du tableau...","grid.splash.cancel":"Annuler","grid.clearAll":"Effacer la recherche et les filtres","grid.layer.loading":"La couche est en cours de téléchargement...","grid.label.pinColumns":"Épingler les colonnes","grid.label.export":"Exporter","grid.label.columns":"Masquer les colonnes","grid.label.copied":"Copié","grid.label.copy":"Appuyez sur Ctrl + C ou double-cliquez pour copier","grid.label.specialColumn":"Colonne spéciale","grid.label.filters.show":"Afficher les filtres","grid.label.filters.hide":"Masquer les filtres","grid.label.filters.apply":"Appliquer les filtres à la carte","grid.header.sort.0":"Tri ascendant","grid.header.sort.1":"Tri descendant","grid.header.sort.2":"Tri par défaut","grid.header.reorder.left":"Déplacer vers la gauche","grid.header.reorder.right":"Déplacer vers la droite","grid.filters.label.global":"Tableau de recherche","grid.filters.column.label.text":"Rechercher {0}...","grid.filters.clear":"Supprimer les filtres","grid.filters.number.max":"Max","grid.filters.number.min":"Min","grid.filters.date.max":"Date max","grid.filters.date.min":"Date min","grid.filters.label.info":"{range} de {total} saisies affichées","grid.filters.label.filtered":"(filtré à partir d'un total de {max} saisies)","grid.filters.label.extent":"Filtrer par étendue","grid.cells.zoom":"Zoom à l'élément","grid.cells.zoom.zooming":"Zoom en cours...","grid.cells.zoom.error":"Échec du zoom","grid.cells.zoom.zoomed":"Zoom terminé","grid.cells.alert.zoom":"Zoom sur la caractéristique","grid.cells.details":"Détails","grid.button.title":"Grille"}};

class GridFixture extends GridAPI {
  async added() {
    this.$iApi.panel.register(
      {
        grid: {
          screens: {
            "grid-screen": () => markRaw(Promise.resolve().then(() => screen$1))
          },
          style: {
            width: "450px"
          },
          controls: {
            expand: true
          },
          button: {
            tooltip: "grid.button.title",
            // https://fonts.google.com/icons?selected=Material%20Icons%3Atable_chart
            icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0V0z" fill="none" /> <path d="M10 10.02h5V21h-5zM17 21h3c1.1 0 2-.9 2-2v-9h-5v11zm3-18H5c-1.1 0-2 .9-2 2v3h19V5c0-1.1-.9-2-2-2zM3 19c0 1.1.9 2 2 2h3V10H3v9z" /></svg>'
          },
          expanded: true,
          alertName: "grid.alertName"
        }
      },
      { i18n: { messages: messages$a } }
    );
    this._parseConfig(this.config);
  }
  removed() {
    if (this.$iApi.fixture.exists("appbar")) {
      const appbarStore = useAppbarStore(this.$vApp.$pinia);
      appbarStore.removeButton("grid");
    }
    const gridStore = useGridStore(this.$vApp.$pinia);
    gridStore.$reset();
    this.$iApi.panel.remove("grid");
  }
}

const index$d = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: GridFixture
}, Symbol.toStringTag, { value: 'Module' }));

class HelpAPI extends FixtureInstance {
  /**
   * Toggles help panel
   *
   * @param {boolean} [open] force panel open or closed
   * @memberof HelpAPI
   */
  toggleHelp(open) {
    const panel = this.$iApi.panel.get("help");
    this.$iApi.panel.toggle(panel, open);
  }
  /**
   * Returns `HelpConfig` section of the global config file.
   *
   * @readonly
   * @type {HelpConfig}
   * @memberof HelpAPI
   */
  get config() {
    return super.config;
  }
  /**
   * Parses the help config JSON snippet from the config file and save to the fixture store.
   *
   * @param {HelpConfig} [helpConfig]
   * @memberof HelpAPI
   */
  _parseConfig(helpConfig) {
    const helpStore = useHelpStore(this.$vApp.$pinia);
    helpStore.location = helpConfig?.location ?? "./help/";
    this.handlePanelWidths(["help"]);
    this.handlePanelTeleports(["help"]);
  }
}

const _hoisted_1$C = { key: 0 };
const _hoisted_2$s = ["content"];
const _hoisted_3$n = { class: "text-lg text-left flex-grow" };
const _hoisted_4$d = ["innerHTML"];
const _sfc_main$J = /* @__PURE__ */ defineComponent({
  __name: "section",
  props: {
    helpSection: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      const _directive_tippy = resolveDirective("tippy");
      return __props.helpSection.drawn ? (openBlock(), createElementBlock("div", _hoisted_1$C, [
        createElementVNode("div", null, [
          withDirectives((openBlock(), createElementBlock("button", {
            type: "button",
            class: "help-section-header flex items-center py-15 px-25 hover:bg-gray-200 cursor-pointer select-none w-full",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("expand")),
            content: unref(t)(__props.helpSection.expanded ? "help.section.collapse" : "help.section.expand")
          }, [
            createElementVNode("span", _hoisted_3$n, toDisplayString(__props.helpSection.header), 1),
            createElementVNode("div", {
              class: normalizeClass(["dropdown-icon", { "transform -rotate-180": __props.helpSection.expanded }])
            }, _cache[1] || (_cache[1] = [
              createElementVNode("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                height: "24",
                viewBox: "0 0 24 24",
                width: "24"
              }, [
                createElementVNode("path", {
                  d: "M0 0h24v24H0V0z",
                  fill: "none"
                }),
                createElementVNode("path", { d: "M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" })
              ], -1)
            ]), 2)
          ], 8, _hoisted_2$s)), [
            [_directive_tippy, { placement: "top-end", hideOnClick: false }]
          ]),
          createVNode(Transition, {
            name: "help-item",
            mode: "out-in"
          }, {
            default: withCtx(() => [
              withDirectives(createElementVNode("div", {
                innerHTML: __props.helpSection.info,
                class: "ramp-markdown section-body px-20 pt-5 ml-10 overflow-hidden"
              }, null, 8, _hoisted_4$d), [
                [vShow, __props.helpSection.expanded]
              ])
            ]),
            _: 1
          })
        ])
      ])) : createCommentVNode("", true);
    };
  }
});

const HelpSection = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["__scopeId", "data-v-7dc61532"]]);

const _hoisted_1$B = { class: "h-26 mb-8 mx-8" };
const _hoisted_2$r = ["placeholder", "aria-label"];
const _hoisted_3$m = { key: 0 };
const _sfc_main$I = /* @__PURE__ */ defineComponent({
  __name: "screen",
  props: {
    panel: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const iApi = inject("iApi");
    const helpStore = useHelpStore();
    const { t } = useI18n();
    const location = computed(() => helpStore.location);
    const helpSections = ref([]);
    const originalTextArray = ref([]);
    const watchers = ref([]);
    const noResults = ref(false);
    let numResults;
    let searchTerm;
    function findInfo(searchTerm2, section) {
      const segments = section.info.split(/(<[^>]*>)/);
      for (const [i, segment] of segments.entries()) {
        if (i % 2 === 0) {
          if (segment.toLowerCase().indexOf(searchTerm2.toLowerCase()) > -1) {
            return true;
          }
        }
      }
      return false;
    }
    function highlightSearchTerm(searchTerm2, idx) {
      const originalText = originalTextArray.value[idx];
      const segments = originalText.split(/(<[^>]*>)/);
      let highlightedText = "";
      for (const [i, segment] of segments.entries()) {
        if (i % 2 === 0) {
          highlightedText += segment.replace(
            new RegExp(searchTerm2, "gi"),
            (match) => `<mark>${match}</mark>`
          );
        } else {
          highlightedText += segment;
        }
      }
      helpSections.value[idx].info = highlightedText;
    }
    function doSearch(searchTerm2, sections) {
      numResults = 0;
      sections.forEach((section, index) => {
        section.info = originalTextArray.value[index];
        section.drawn = findInfo(searchTerm2, section) || section.header.toLowerCase().indexOf(searchTerm2.toLowerCase()) > -1;
        numResults = section.drawn ? numResults + 1 : numResults;
        section.expanded = section.drawn && searchTerm2.length > 2;
        if (section.drawn && searchTerm2.length > 2) {
          highlightSearchTerm(searchTerm2, index);
        }
      });
      noResults.value = numResults === 0;
    }
    function toggleExpanded(section) {
      section.expanded = !section.expanded;
    }
    onBeforeMount(() => {
      watchers.value.push(
        watch(
          () => iApi.language,
          (newLocale, oldLocale) => {
            if (newLocale === oldLocale) return;
            const renderer = new marked.Renderer();
            const loc = location.value.slice(-1) === "/" ? location.value : `${location.value}/`;
            renderer.image = (href, title, text) => {
              if (href.indexOf("http") === -1) {
                href = `${loc}images/` + href;
              }
              return `<img src="${href}" alt="${text}">`;
            };
            axios.get(`${loc}${newLocale}.md`).then((r) => {
              const reg = /^#\s(.*)\n{2}(?:.+|\n(?!\n{2,}))*/gm;
              let helpMd = r.data.replace(new RegExp(String.fromCharCode(13), "g"), "");
              helpSections.value = [];
              let section;
              while (section = reg.exec(helpMd)) {
                helpSections.value.push({
                  header: section[1],
                  // parse markdown on info section, split/splice/join removes the header
                  // since we can't put info section into its own regex grouping
                  info: marked(section[0].split("\n").splice(2).join("\n"), {
                    renderer
                  }),
                  drawn: true,
                  expanded: false
                });
                originalTextArray.value.push(
                  marked(section[0].split("\n").splice(2).join("\n"), {
                    renderer
                  })
                );
              }
            });
          },
          { immediate: true }
        )
      );
    });
    onBeforeUnmount(() => {
      watchers.value.forEach((unwatch) => unwatch());
    });
    return (_ctx, _cache) => {
      const _component_panel_screen = resolveComponent("panel-screen");
      return openBlock(), createBlock(_component_panel_screen, { panel: __props.panel }, {
        header: withCtx(() => [
          createTextVNode(toDisplayString(unref(t)("help.title")), 1)
        ]),
        content: withCtx(() => [
          createElementVNode("div", _hoisted_1$B, [
            withDirectives(createElementVNode("input", {
              type: "search",
              class: "rv-help-search-bar border-b w-full text-base py-8 outline-none focus:shadow-outline border-gray-600 h-full min-w-0",
              placeholder: unref(t)("help.search"),
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(searchTerm) ? searchTerm.value = $event : searchTerm = $event),
              "aria-label": unref(t)("help.search"),
              onInput: _cache[1] || (_cache[1] = ($event) => doSearch(unref(searchTerm), helpSections.value)),
              onKeypress: _cache[2] || (_cache[2] = withKeys(withModifiers(() => {
              }, ["prevent"]), ["enter"])),
              enterkeyhint: "done"
            }, null, 40, _hoisted_2$r), [
              [vModelText, unref(searchTerm)]
            ])
          ]),
          noResults.value ? (openBlock(), createElementBlock("div", _hoisted_3$m, [
            createElementVNode("p", null, toDisplayString(unref(t)("help.noResults")), 1)
          ])) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(helpSections.value, (section, idx) => {
            return openBlock(), createBlock(HelpSection, {
              helpSection: section,
              key: idx,
              onExpand: ($event) => toggleExpanded(section)
            }, null, 8, ["helpSection", "onExpand"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["panel"]);
    };
  }
});

const screen$7 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: _sfc_main$I
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$H = /* @__PURE__ */ defineComponent({
  __name: "nav-button",
  setup(__props) {
    const iApi = inject("iApi");
    const { t } = useI18n();
    const onClick = () => iApi.event.emit(GlobalEvents.HELP_TOGGLE);
    return (_ctx, _cache) => {
      const _component_mapnav_button = resolveComponent("mapnav-button");
      return openBlock(), createBlock(_component_mapnav_button, {
        onClickFunction: onClick,
        tooltip: unref(t)("help.title")
      }, {
        default: withCtx(() => _cache[0] || (_cache[0] = [
          createElementVNode("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24",
            class: "fill-current w-32 h-20"
          }, [
            createElementVNode("path", {
              d: "M0 0h24v24H0z",
              fill: "none"
            }),
            createElementVNode("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z" })
          ], -1)
        ])),
        _: 1
      }, 8, ["tooltip"]);
    };
  }
});

const messages$9 = {"en":{"help.title":"Help","help.search":"Search Help","help.section.expand":"Expand section","help.section.collapse":"Collapse section","help.noResults":"Nothing is found. Please try a different search."},"fr":{"help.title":"Aide","help.search":"Aide à la recherche","help.section.expand":"Développer une section","help.section.collapse":"Réduire une section","help.noResults":"Aucun résultat. Veuillez essayer une autre recherche."}};

class HelpFixture extends HelpAPI {
  added() {
    this.$iApi.component("help-nav-button", _sfc_main$H);
    this.$iApi.panel.register(
      {
        help: {
          screens: {
            "help-screen": markRaw(_sfc_main$I)
          },
          style: {
            "flex-grow": "1",
            "max-width": "750px"
          },
          alertName: "help.title"
        }
      },
      {
        i18n: { messages: messages$9 }
      }
    );
    this._parseConfig(this.config);
    const unwatch = this.$vApp.$watch(
      () => this.config,
      (value) => this._parseConfig(value)
    );
    this.removed = () => {
      unwatch();
      if (this.$iApi.fixture.exists("mapnav")) {
        const mapnavStore = useMapnavStore(this.$vApp.$pinia);
        mapnavStore.removeItem("help");
      }
      const helpStore = useHelpStore(this.$vApp.$pinia);
      helpStore.$reset();
      this.$iApi.panel.remove("help");
    };
  }
}

const index$c = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: HelpFixture
}, Symbol.toStringTag, { value: 'Module' }));

class BaseHilightMode extends APIScope {
  config = {};
  mode = HilightMode.NONE;
  constructor(config, iApi) {
    super(iApi);
    this.config = config;
    this.mode = config.mode;
  }
  /**
   * Adds the given graphics to the hilighter.
   *
   * @param {Graphic | Array<Graphic>} graphics one or more RAMP Graphics to hilight
   * @returns {Promise} resolves when graphics have been added
   */
  async add(graphics) {
    this.notImplementedError("addGraphics");
  }
  /**
   * Removes the given graphics from the hilighter. No parmeter removes all graphics.
   *
   * @param {Graphic | Array<Graphic> | undefined} graphics one or more RAMP Graphics to remove
   * @returns {Promise} resolves when graphics have been added
   */
  async remove(graphics) {
    this.notImplementedError("removeGraphics");
  }
  /**
   * Reload the provided graphics that are currently highlighted.
   *
   * @param {Graphic | Array<Graphic>} graphics one or more RAMP Graphics to reload
   * @returns {Promise} resolves when graphics have been reloaded
   */
  async reloadHilight(graphics) {
    this.notImplementedError("reloadHilight");
  }
  /**
   * Returns the Hilight layer, if it exists.
   *
   * @returns {Promise<CommonGraphicLayer | undefined>}
   */
  async getHilightLayer() {
    const hilightLayer = await this.layerFetcher();
    if (hilightLayer) {
      if (hilightLayer.isLoaded && hilightLayer instanceof CommonGraphicLayer) {
        return hilightLayer;
      } else {
        console.warn("Hilight layer exists but is in bad form.");
        return void 0;
      }
    } else {
      console.warn("Hilight layer could not be fetched.");
      return void 0;
    }
  }
  notImplementedError(method) {
    console.warn(`Hilight mode method ${method} was not implemented by subclass.`);
  }
  /**
   * Provides a short grace period to avoid scenarios where the layer is still getting created.
   * Not overly long, as the highlight layer is a local graphics layer so no server lag involved.
   *
   * @returns Promise resolving in the LayerInstace, or undefined if we could not locate the layer.
   */
  layerFetcher() {
    const precheckLayer = this.$iApi.geo.layer.getLayer(HILIGHT_LAYER_NAME);
    if (precheckLayer) {
      return Promise.resolve(precheckLayer);
    } else {
      return new Promise((resolve) => {
        let timeElapsed = 0;
        const layerWatcher = setInterval(() => {
          const layer = this.$iApi.geo.layer.getLayer(HILIGHT_LAYER_NAME);
          if (layer) {
            clearInterval(layerWatcher);
            resolve(layer);
          } else {
            timeElapsed += 125;
            if (timeElapsed >= 1125) {
              clearInterval(layerWatcher);
              resolve(void 0);
              return;
            }
          }
        }, 125);
      });
    }
  }
}

class LiftHilightMode extends BaseHilightMode {
  async add(graphics) {
    const hilightLayer = await this.getHilightLayer();
    if (!hilightLayer) {
      return;
    }
    await hilightLayer.addGraphic(graphics);
  }
  async remove(graphics) {
    const hilightLayer = await this.getHilightLayer();
    if (!hilightLayer) {
      return;
    }
    hilightLayer.removeGraphic(graphics);
  }
  async reloadHilight(graphics) {
    await this.remove(graphics);
    await this.add(graphics);
  }
}

class FogHilightMode extends LiftHilightMode {
  handlers = [];
  // TODO: make these configurable later
  // See https://github.com/ramp4-pcar4/ramp4-pcar4/issues/1353
  onOpacity;
  offOpacity;
  lastAdd = 0;
  constructor(config, iApi) {
    super(config, iApi);
    this.onOpacity = config.options?.onOpacity ?? 0.75;
    this.offOpacity = config.options?.offOpacity > 0.02 ? config.options.offOpacity : 0.02;
    if (this.$iApi.geo.map.created) {
      this.hilightSetup();
    } else {
      this.handlers.push(
        this.$iApi.event.on(GlobalEvents.MAP_CREATED, () => {
          this.hilightSetup();
        })
      );
    }
    this.handlers.push(
      this.$iApi.event.on(GlobalEvents.MAP_BASEMAPCHANGE, () => {
        this.getHilightLayer().then((hilightLayer) => {
          if (hilightLayer && hilightLayer.graphics.length === 0) {
            this.updateFogLayer();
          }
        });
      })
    );
  }
  async hilightSetup() {
    const mapConfig = useConfigStore(this.$vApp.$pinia).activeBasemapConfig;
    try {
      const fogLayer = this.$iApi.geo.layer.createLayer({
        id: FOG_HILIGHT_LAYER_NAME,
        layerType: LayerType.TILE,
        cosmetic: true,
        // TODO: what if there's more than 1 URL provided?
        // See https://github.com/ramp4-pcar4/ramp4-pcar4/discussions/1352
        url: mapConfig.layers[0].url
      });
      await this.$iApi.geo.map.addLayer(fogLayer);
      fogLayer.opacity = this.offOpacity;
      await this.reorderFogLayer();
    } catch {
      console.error("Something went wrong while setting up the hilighter.");
    }
  }
  async updateFogLayer() {
    this.$iApi.geo.map.removeLayer(FOG_HILIGHT_LAYER_NAME);
    await this.hilightSetup();
  }
  async reorderFogLayer() {
    const fogLayer = this.getFogLayer();
    const hilightLayer = await this.getHilightLayer();
    if (!hilightLayer || !fogLayer) {
      return;
    }
    const layerOrder = this.$iApi.geo.layer.layerOrderIds();
    const fogIdx = layerOrder.indexOf(fogLayer.id);
    const hilightIdx = layerOrder.indexOf(hilightLayer.id);
    if (hilightIdx < fogIdx && hilightIdx > -1 && fogIdx > -1) {
      this.$iApi.geo.map.reorder(hilightLayer, fogIdx, false);
    }
  }
  async add(graphics) {
    this.lastAdd = Date.now();
    const fogLayer = this.getFogLayer();
    if (!fogLayer) {
      return;
    }
    fogLayer.opacity = this.onOpacity;
    await super.add(graphics);
  }
  async remove(graphics) {
    await super.remove(graphics);
    const fogLayer = this.getFogLayer();
    if (!fogLayer) {
      return;
    }
    const lastRemove = Date.now();
    const hilightLayer = await this.getHilightLayer();
    if (!hilightLayer) {
      return;
    }
    setTimeout(() => {
      if (this.lastAdd < lastRemove && !hilightLayer.getGraphicCount()) {
        fogLayer.opacity = this.offOpacity;
      }
    }, 300);
  }
  async reloadHilight(graphics) {
    await this.updateFogLayer();
    await super.reloadHilight(graphics);
  }
  /**
   * Returns the "fog" tile layer.
   */
  getFogLayer() {
    const hilightLayer = this.$iApi.geo.layer.getLayer(FOG_HILIGHT_LAYER_NAME);
    if (hilightLayer && hilightLayer instanceof TileLayer) {
      return hilightLayer;
    } else {
      console.warn("Hilight fog layer could not be fetched.");
      return void 0;
    }
  }
}

class GlowHilightMode extends LiftHilightMode {
  handlers = [];
  constructor(config, iApi) {
    super(config, iApi);
    this.hilightSetup(config);
    this.handlers.push(
      this.$iApi.event.on(GlobalEvents.MAP_CREATED, () => {
        this.hilightSetup(config);
      })
    );
  }
  hilightSetup(config) {
    this.$iApi.geo.map.viewPromise.then(() => {
      this.$iApi.geo.map.esriView.highlightOptions = config.options;
    });
  }
  async add(graphics) {
    await super.add(graphics);
    const hilightLayer = this.$iApi.geo.layer.getLayer(HILIGHT_LAYER_NAME);
    if (hilightLayer && hilightLayer.esriLayer && hilightLayer.isLoaded && hilightLayer instanceof GraphicLayer) {
      const gs = graphics instanceof Array ? graphics : [graphics];
      this.$iApi.geo.map.esriView?.whenLayerView(hilightLayer.esriLayer)?.then(function(layerView) {
        layerView.highlight(gs.map((g) => hilightLayer.getEsriGraphic(g.id)));
      });
    }
  }
  async remove(graphics) {
    await super.remove(graphics);
    return;
  }
}

class HilightAPI extends FixtureInstance {
  hilightMode = new BaseHilightMode({}, this.$iApi);
  initialized() {
    this.initHilightLayer();
  }
  _parseConfig(hilightConfig) {
    if (hilightConfig) {
      switch (hilightConfig.mode) {
        case HilightMode.NONE:
          this.hilightMode = new BaseHilightMode(hilightConfig, this.$iApi);
          break;
        case HilightMode.GLOW:
          this.hilightMode = new GlowHilightMode(hilightConfig, this.$iApi);
          break;
        case HilightMode.LIFT:
          this.hilightMode = new LiftHilightMode(hilightConfig, this.$iApi);
          break;
        case HilightMode.FOG:
          this.hilightMode = new FogHilightMode(hilightConfig, this.$iApi);
          break;
        default:
          console.error("Could not find hilight mode:", hilightConfig.mode);
          break;
      }
    } else {
      this.hilightMode = new GlowHilightMode(DEFAULT_CONFIG, this.$iApi);
    }
  }
  /**
   * Initialize the Hilight layer.
   *
   * @returns {Promise} resolves when layer is initialized
   */
  async initHilightLayer() {
    const hilightLayer = this.$iApi.geo.layer.createLayer({
      id: HILIGHT_LAYER_NAME,
      layerType: LayerType.GRAPHIC,
      cosmetic: true,
      url: ""
    });
    await this.$iApi.geo.map.addLayer(hilightLayer);
  }
  /**
   * Add the given Graphics to the Hilighter
   *
   * @param {Graphic | Array<Graphic>} graphics Graphics to add
   * @returns {Promise} resolves when graphics have been added
   */
  async addHilight(graphics) {
    const gs = graphics instanceof Array ? graphics : [graphics];
    await this.hilightMode.add(gs);
  }
  /**
   * Remove the given Graphics from the Hilighter. If no graphics are provided,
   * all highlighted items will be removed.
   *
   * @param {Graphic | Array<Graphic> | undefined} graphics Graphics to remove
   * @returns {Promise} resolves when graphics have been removed
   */
  async removeHilight(graphics) {
    const gs = graphics ? graphics instanceof Array ? graphics : [graphics] : void 0;
    await this.hilightMode.remove(gs);
  }
  /**
   * Reload the provided graphics that are currently highlighted.
   *
   * @param {Array<Graphic> | Graphic} graphics
   */
  async reloadHilight(graphics) {
    const gs = graphics instanceof Array ? graphics : [graphics];
    await this.hilightMode.reloadHilight(gs);
  }
  /**
   * Return all Graphics that match the given origin/uid/oid
   *
   * @param origin Graphic origin
   * @param uid Associated layer UID of the Graphic
   * @param oid Associated OID of the Graphic
   */
  async getGraphicsByKey(origin, uid, oid) {
    const hilightLayer = await this.getHilightLayer();
    if (!hilightLayer) {
      return [];
    }
    let keys = hilightLayer.graphics.map((g) => ({
      ...this.deconstructGraphicKey(g.id),
      og: g
    }));
    if (origin) {
      keys = keys.filter((k) => k.origin === origin);
    }
    if (uid) {
      keys = keys.filter((k) => k.uid === uid);
    }
    if (oid) {
      keys = keys.filter((k) => k.oid === oid);
    }
    return keys.map((k) => k.og);
  }
  /**
   * Return a well-formed graphic key
   */
  constructGraphicKey(origin, uid, oid) {
    return `${HILIGHT_LAYER_NAME}~${origin}~${uid}~${oid}`;
  }
  /**
   * Return a deconstructed graphic key.
   *
   * @param key The graphic key to deconstruct
   */
  deconstructGraphicKey(key) {
    const ids = key.split("~");
    if (ids.length !== 4) {
      console.warn("Malformed Hilight Graphic key provided:", key);
    }
    return { origin: ids[1], uid: ids[2], oid: parseInt(ids[3]) };
  }
  /**
   * Return the hilightLayer
   */
  async getHilightLayer() {
    if (this.hilightMode) {
      return await this.hilightMode.getHilightLayer();
    } else {
      console.warn("API get layer request before highlight mode object exists");
      return void 0;
    }
  }
}

class HilightFixture extends HilightAPI {
  async added() {
    this._parseConfig(this.config);
    const unwatch = this.$vApp.$watch(
      () => this.config,
      (value) => this._parseConfig(value)
    );
    this.removed = () => {
      unwatch();
    };
  }
}

const index$b = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: HilightFixture
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$A = ["content", "aria-label"];
const _hoisted_2$q = ["disabled", "aria-label"];
const _sfc_main$G = /* @__PURE__ */ defineComponent({
  __name: "reorder-button",
  props: {
    disabled: {
      type: Boolean
    },
    direction: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      const _directive_tippy = resolveDirective("tippy");
      const _directive_focus_item = resolveDirective("focus-item");
      return !__props.disabled ? withDirectives((openBlock(), createElementBlock("button", {
        key: 0,
        type: "button",
        class: normalizeClass(`pb-10 text-gray-500 hover:text-black p-8 ${__props.direction === "up" ? "rotate-180" : ""}`),
        content: unref(t)(`layer-reorder.move.${__props.direction}`),
        "aria-label": unref(t)(`layer-reorder.move.${__props.direction}`)
      }, _cache[0] || (_cache[0] = [
        createElementVNode("svg", {
          class: "fill-current w-20 h-20",
          viewBox: "0 0 23 21"
        }, [
          createElementVNode("path", { d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z" })
        ], -1)
      ]), 10, _hoisted_1$A)), [
        [_directive_tippy, {
          placement: "top-start",
          aria: "describedby"
        }],
        [_directive_focus_item]
      ]) : (openBlock(), createElementBlock("button", {
        key: 1,
        type: "button",
        class: normalizeClass(`pb-10 text-gray-300 p-8 ${__props.direction === "up" ? "rotate-180" : ""}`),
        disabled: __props.disabled,
        "aria-label": unref(t)(`layer-reorder.move.${__props.direction}`)
      }, _cache[1] || (_cache[1] = [
        createElementVNode("svg", {
          class: "fill-current w-20 h-20",
          viewBox: "0 0 23 21"
        }, [
          createElementVNode("path", { d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z" })
        ], -1)
      ]), 10, _hoisted_2$q));
    };
  }
});

const ReorderButton = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["__scopeId", "data-v-d96028bc"]]);

const _hoisted_1$z = {
  key: 0,
  class: "flex-1 ms-10"
};
const _hoisted_2$p = { class: "p-5" };
const _hoisted_3$l = ["aria-label", "content"];
const _hoisted_4$c = { class: "flex items-center p-5 h-44 cursor-pointer hover:bg-gray-200" };
const _hoisted_5$b = ["onClick", "content", "aria-label"];
const _hoisted_6$a = {
  key: 0,
  class: "fill-current w-20 h-20 mx-4",
  viewBox: "0 0 24 24"
};
const _hoisted_7$a = {
  key: 1,
  class: "fill-current w-20 h-20 mx-4",
  viewBox: "0 0 24 24"
};
const _hoisted_8$6 = { class: "flex-1 mx-10" };
const _hoisted_9$4 = {
  key: 0,
  class: "items-center p-5 pl-30 default-focus-style cursor-pointer"
};
const _hoisted_10$3 = ["content", "aria-label"];
const _hoisted_11$3 = ["content", "aria-label"];
const _hoisted_12$3 = { class: "flex-1 mx-10" };
const _sfc_main$F = /* @__PURE__ */ defineComponent({
  __name: "layer-component",
  setup(__props) {
    const iApi = inject("iApi");
    const { t } = useI18n();
    const layersModel = ref([]);
    const oldOrder = ref([]);
    const handlers = ref([]);
    const watchers = ref([]);
    const isAnimationEnabled = computed(() => iApi.animate);
    const loadLayers = () => {
      let layerExpandedState = {};
      layersModel.value.forEach((layer) => {
        layerExpandedState[layer.id] = layer.isExpanded;
      });
      layersModel.value = [];
      const layerOrderIds = iApi.geo.layer.layerOrderIds();
      const mainLayerList = [...toRaw(iApi.geo.layer.allLayersOnMap(true))].filter(
        (layer) => !layer.isCosmetic && layer.layerState !== LayerState.ERROR
      );
      layersModel.value = mainLayerList.reverse().map((layer, index) => {
        const trueIdx = layerOrderIds.indexOf(layer.id);
        let model = {
          id: layer.id,
          uid: layer.uid,
          name: "",
          orderIdx: trueIdx,
          componentIdx: index,
          isExpanded: layerExpandedState[layer.id] || false,
          isLoaded: false,
          supportsSublayers: layer.supportsSublayers,
          sublayers: []
        };
        return model;
      });
      mainLayerList.forEach((layer) => {
        layer.loadPromise().then(() => {
          loadLayerData(layer);
        }).catch(() => 1);
      });
    };
    const loadLayerData = (layer) => {
      let model = layersModel.value.find((layerModel) => layerModel.id === layer.id);
      if (!model) {
        return;
      }
      model.name = layer.name;
      model.sublayers = layer.sublayers.filter((sublayer) => sublayer !== void 0 && !sublayer.isRemoved).map((sublayer) => {
        return {
          id: sublayer.id,
          name: sublayer.name
        };
      });
      model.isLoaded = true;
    };
    const toggleExpand = (layerModel) => {
      if (!layerModel.supportsSublayers) {
        return;
      }
      layerModel.isExpanded = !layerModel.isExpanded;
      iApi.updateAlert(
        t(layerModel.isExpanded ? "layer-reorder.expanded" : "layer-reorder.collapsed", {
          name: layerModel.name
        })
      );
    };
    const onMoveLayerDragStart = () => {
      oldOrder.value = layersModel.value.map((layerModel) => layerModel.orderIdx);
    };
    const onMoveLayerDragEnd = (evt) => {
      if (!evt.moved) {
        return;
      }
      const layerModel = evt.moved.element;
      const oldRelativeIdx = evt.moved.oldIndex;
      const newRelativeIdx = evt.moved.newIndex;
      if (oldRelativeIdx === newRelativeIdx) {
        return;
      }
      const layer = iApi.geo.layer.getLayer(layerModel.uid);
      const newGlobalIdx = oldOrder.value[newRelativeIdx];
      iApi.geo.map.reorder(layer, newGlobalIdx);
      iApi.updateAlert(
        t("layer-reorder.layermoved", {
          name: layerModel.name,
          index: newGlobalIdx
        })
      );
    };
    const onMoveLayerButton = (layerModel, direction) => {
      const layer = iApi.geo.layer.getLayer(layerModel.id);
      const currRelativeIdx = layersModel.value.indexOf(layerModel);
      if (layer === void 0 || currRelativeIdx === -1) {
        return;
      }
      const newRelativeIdx = currRelativeIdx - direction;
      const newGlobalIdx = layersModel.value[newRelativeIdx].orderIdx;
      iApi.geo.map.reorder(layer, newGlobalIdx);
      iApi.updateAlert(
        t("layer-reorder.layermoved", {
          name: layerModel.name,
          index: newGlobalIdx
        })
      );
    };
    const _isBoundary = (index) => {
      return index < 0 || index > layersModel.value.length - 1;
    };
    onMounted(() => {
      loadLayers();
      handlers.value.push(
        iApi.event.on(GlobalEvents.LAYER_REMOVE, () => {
          loadLayers();
        })
      );
      handlers.value.push(
        iApi.event.on(GlobalEvents.LAYER_LAYERSTATECHANGE, () => {
          loadLayers();
        })
      );
      handlers.value.push(
        iApi.event.on(GlobalEvents.MAP_REORDER, () => {
          loadLayers();
        })
      );
    });
    onBeforeUnmount(() => {
      handlers.value.forEach((handler) => iApi.event.off(handler));
      watchers.value.forEach((unwatch) => unwatch());
    });
    return (_ctx, _cache) => {
      const _directive_truncate = resolveDirective("truncate");
      const _directive_focus_item = resolveDirective("focus-item");
      const _directive_tippy = resolveDirective("tippy");
      const _directive_focus_container = resolveDirective("focus-container");
      const _directive_focus_list = resolveDirective("focus-list");
      return openBlock(), createElementBlock("div", null, [
        layersModel.value.length === 0 ? withDirectives((openBlock(), createElementBlock("div", _hoisted_1$z, [
          createElementVNode("span", _hoisted_2$p, toDisplayString(unref(t)("layer-reorder.nolayers")), 1)
        ])), [
          [_directive_truncate]
        ]) : (openBlock(), createBlock(unref(draggable), {
          key: 1,
          class: "p-3",
          modelValue: layersModel.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => layersModel.value = $event),
          "item-key": "uid",
          animation: isAnimationEnabled.value ? 200 : 0,
          onChange: onMoveLayerDragEnd,
          onStart: onMoveLayerDragStart
        }, {
          item: withCtx(({ element }) => [
            element.isLoaded ? withDirectives((openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(`
                        mt-4
                        relative
                        ${element.isExpanded ? "hover:bg-gray-200" : ""}
                        border-2
                        border-gray-300
                        default-focus-style
                    `),
              "aria-label": element.name,
              content: element.name
            }, [
              _cache[3] || (_cache[3] = createElementVNode("div", { class: "display-none" }, null, -1)),
              createElementVNode("div", _hoisted_4$c, [
                element.supportsSublayers ? withDirectives((openBlock(), createElementBlock("button", {
                  key: 0,
                  type: "button",
                  onClick: ($event) => toggleExpand(element),
                  class: "text-gray-500 hover:text-black p-5",
                  content: unref(t)(`layer-reorder.${!element.isExpanded ? "expand" : "collapse"}`),
                  "aria-label": unref(t)(`layer-reorder.${!element.isExpanded ? "expand" : "collapse"}`)
                }, [
                  element.isExpanded ? (openBlock(), createElementBlock("svg", _hoisted_6$a, _cache[1] || (_cache[1] = [
                    createElementVNode("path", {
                      d: "M0 0h24v24H0z",
                      fill: "none"
                    }, null, -1),
                    createElementVNode("path", { d: "M19 13H5v-2h14v2z" }, null, -1)
                  ]))) : (openBlock(), createElementBlock("svg", _hoisted_7$a, _cache[2] || (_cache[2] = [
                    createElementVNode("path", { d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" }, null, -1)
                  ])))
                ], 8, _hoisted_5$b)), [
                  [_directive_focus_item],
                  [_directive_tippy, {
                    placement: "right",
                    aria: "describedby"
                  }]
                ]) : createCommentVNode("", true),
                withDirectives((openBlock(), createElementBlock("div", _hoisted_8$6, [
                  createElementVNode("span", null, toDisplayString(element.name), 1)
                ])), [
                  [_directive_truncate]
                ]),
                createVNode(ReorderButton, {
                  disabled: _isBoundary(element.componentIdx - 1),
                  direction: "up",
                  class: "px-7",
                  onClick: ($event) => onMoveLayerButton(element, 1)
                }, null, 8, ["disabled", "onClick"]),
                createVNode(ReorderButton, {
                  disabled: _isBoundary(element.componentIdx + 1),
                  direction: "down",
                  class: "px-7",
                  onClick: ($event) => onMoveLayerButton(element, -1)
                }, null, 8, ["disabled", "onClick"])
              ]),
              element.isExpanded && element.sublayers.length > 0 ? withDirectives((openBlock(), createElementBlock("div", _hoisted_9$4, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(element.sublayers, (sublayer) => {
                  return withDirectives((openBlock(), createElementBlock("div", {
                    key: sublayer.id,
                    class: "m-15 default-focus-style",
                    content: sublayer.name,
                    "aria-label": sublayer.name
                  }, [
                    createTextVNode(toDisplayString(sublayer.name), 1)
                  ], 8, _hoisted_10$3)), [
                    [_directive_truncate],
                    [_directive_tippy, {
                      placement: "bottom-start",
                      aria: "describedby"
                    }],
                    [_directive_focus_container]
                  ]);
                }), 128))
              ])), [
                [_directive_focus_list]
              ]) : createCommentVNode("", true)
            ], 10, _hoisted_3$l)), [
              [_directive_tippy, {
                placement: "top-start",
                aria: "describedby"
              }],
              [_directive_focus_container]
            ]) : withDirectives((openBlock(), createElementBlock("div", {
              key: 1,
              class: "flex items-center p-5 mx-8 h-44 default-focus-style",
              content: unref(t)("layer-reorder.loading"),
              "aria-label": unref(t)("layer-reorder.loading"),
              "truncate-trigger": ""
            }, [
              _cache[4] || (_cache[4] = createElementVNode("div", { class: "animate-spin spinner h-20 w-20 px-5" }, null, -1)),
              createElementVNode("div", _hoisted_12$3, [
                createElementVNode("span", null, toDisplayString(unref(t)("layer-reorder.loading")), 1)
              ])
            ], 8, _hoisted_11$3)), [
              [_directive_tippy, {
                placement: "top-start",
                aria: "describedby"
              }],
              [_directive_focus_container]
            ])
          ]),
          _: 1
        }, 8, ["modelValue", "animation"]))
      ]);
    };
  }
});

const _sfc_main$E = /* @__PURE__ */ defineComponent({
  __name: "screen",
  props: {
    panel: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      const _component_panel_screen = resolveComponent("panel-screen");
      return openBlock(), createBlock(_component_panel_screen, { panel: __props.panel }, {
        header: withCtx(() => [
          createTextVNode(toDisplayString(unref(t)("layer-reorder.title")), 1)
        ]),
        content: withCtx(() => [
          createVNode(_sfc_main$F)
        ]),
        _: 1
      }, 8, ["panel"]);
    };
  }
});

const screen$6 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: _sfc_main$E
}, Symbol.toStringTag, { value: 'Module' }));

const messages$8 = {"en":{"layer-reorder.title":"Reorder Layers","layer-reorder.nolayers":"No Layers","layer-reorder.loading":"Loading","layer-reorder.expand":"Expand Sublayers","layer-reorder.expanded":"{name} sublayers expanded","layer-reorder.collapse":"Collapse Sublayers","layer-reorder.collapsed":"{name} sublayers collapsed","layer-reorder.move.up":"Move up","layer-reorder.move.down":"Move down","layer-reorder.layermoved":"{name} moved to index {index}"},"fr":{"layer-reorder.title":"Réorganiser les couches","layer-reorder.nolayers":"Aucune couche","layer-reorder.loading":"Chargement","layer-reorder.expand":"Développer les sous-couches","layer-reorder.expanded":"Sous-couches {name} développées","layer-reorder.collapse":"Réduire les sous-couches","layer-reorder.collapsed":"Sous-couches {name} réduites","layer-reorder.move.up":"Déplacer vers le haut","layer-reorder.move.down":"Déplacer vers le bas","layer-reorder.layermoved":"{name} déplacé vers l'index {index}"}};

class LayerReorderAPI extends FixtureInstance {
  /**
   * Opens or closes the layer reorder fixture panel
   *
   * @param {boolean} [open] force panel open or closed
   * @memberof LayerReorderAPI
   */
  toggleLayerReorder(open) {
    const panel = this.$iApi.panel.get("layer-reorder");
    this.$iApi.panel.toggle(panel, open);
  }
}

class LayerReorderFixture extends LayerReorderAPI {
  added() {
    this.$iApi.panel.register(
      {
        "layer-reorder": {
          screens: {
            "layer-reorder-screen": markRaw(_sfc_main$E)
          },
          style: {
            width: "350px"
          },
          button: {
            tooltip: "layer-reorder.title",
            // https://fonts.google.com/icons?selected=Material+Icons:low_priority
            icon: '<svg class="flip" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none" /><path d="M14 5h8v2h-8zm0 5.5h8v2h-8zm0 5.5h8v2h-8zM2 11.5C2 15.08 4.92 18 8.5 18H9v2l3-3-3-3v2h-.5C6.02 16 4 13.98 4 11.5S6.02 7 8.5 7H12V5H8.5C4.92 5 2 7.92 2 11.5z" /></svg>'
          },
          alertName: "layer-reorder.title"
        }
      },
      {
        i18n: { messages: messages$8 }
      }
    );
    this.handlePanelTeleports(["layer-reorder"]);
  }
  removed() {
    if (this.$iApi.fixture.exists("appbar")) {
      const appbarStore = useAppbarStore(this.$vApp.$pinia);
      appbarStore.removeButton("layer-reorder");
    }
    this.$iApi.panel.remove("layer-reorder");
  }
}

const index$a = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: LayerReorderFixture
}, Symbol.toStringTag, { value: 'Module' }));

class LegendAPI extends FixtureInstance {
  /**
   * Parses the legend config JSON snippet from the config file and save resulting objects to the fixture store.
   *
   * @param {LegendConfig | undefined} legendConfig
   */
  _parseConfig(legendConfig) {
    const controls = legendConfig?.headerControls?.slice() ?? [
      "wizard",
      "layerReorder",
      "groupToggle",
      "visibilityToggle"
    ];
    useLegendStore(this.$vApp.$pinia).headerControls = controls;
    if (!legendConfig || !legendConfig.root.children) {
      return;
    }
    useLegendStore(this.$vApp.$pinia).multilineItems = legendConfig.multilineItems?.enabled ?? true;
    const lineClampValues = [1, 2, 3, 4, 5, 6];
    if (!legendConfig.multilineItems?.maxLines || !lineClampValues.includes(legendConfig.multilineItems?.maxLines)) {
      useLegendStore(this.$vApp.$pinia).maxLines = 3;
    } else {
      useLegendStore(this.$vApp.$pinia).maxLines = legendConfig.multilineItems.maxLines;
    }
    this.handlePanelWidths(["legend"]);
    this.handlePanelTeleports(["legend"]);
    const layerLegendConfigs = this.getLayerFixtureConfigs();
    legendConfig.root.children.forEach((legendItem) => {
      legendItem.layerLegendConfigs = layerLegendConfigs;
      this.addItem(legendItem);
    });
    this.$iApi.geo.layer.allLayers().forEach((l) => {
      this.updateLegend(l);
    });
  }
  // Create
  /**
   * Construct a legend item given the legend config
   *
   * @param {any} itemConf legend item config
   * @param {LegendItem | undefined} parent the parent legend item for the created item
   * @returns {LegendItem} returns the constructed legend item
   * @memberof LegendAPI
   */
  createItem(itemConf, parent) {
    let item = void 0;
    if (itemConf.layerId === void 0) {
      item = new SectionItem(this.$iApi, itemConf, parent);
    } else {
      if (itemConf.sublayerIndex !== void 0) {
        itemConf.layerId = `${itemConf.layerId}-${itemConf.sublayerIndex}`;
      }
      item = new LayerItem(this.$iApi, itemConf, parent);
    }
    const children = itemConf.children;
    if (children) {
      children.forEach((childConf) => {
        if (itemConf.layerLegendConfigs !== void 0) {
          childConf.layerLegendConfigs = itemConf.layerLegendConfigs;
        }
        item.children.push(this.createItem(childConf, item));
      });
    }
    return item;
  }
  /**
   * Add a legend item given the legend config, or legend item instance
   *
   * @param {any | LegendItem} item the config for the legend item or a legend item instance
   * @param {LegendItem | undefined} parent optional parent item to create this item under
   * @returns {LegendItem} the added legend item
   * @memberof LegendAPI
   */
  addItem(item, parent) {
    const constructedItem = item instanceof LegendItem ? item : this.createItem(item, parent);
    this._insertItem(constructedItem, parent);
    return constructedItem;
  }
  /**
   * Add a layer legend item given a layer instance
   *
   * @param {LayerInstance} layer the layer to create an item for
   * @param {LegendItem | undefined} parent optional parent item to create this item under
   * @returns {Promise<LegendItem>} a promise that resolves with the added layer item
   * @memberof LegendAPI
   */
  async addLayerItem(layer, parent) {
    const item = new LayerItem(
      this.$iApi,
      {
        layerId: layer.id,
        sublayerIndex: layer.isSublayer ? layer.layerIdx : void 0,
        name: layer.name
      },
      parent
    );
    this._insertItem(item, parent);
    this.updateLegend(layer);
    return item;
  }
  // Read
  /**
   * Returns `LegendConfig` section of the global config file.
   *
   * @readonly
   * @type {LegendConfig}
   * @memberof LegendAPI
   */
  get config() {
    return super.config;
  }
  /**
   * Returns the full legend tree.
   * Note: This returns a direct reference to the legend tree. Mutations will persist.
   *
   * @returns {Array<LegendItem>} returns the full legend tree
   * @memberof LegendAPI
   */
  getLegend() {
    return useLegendStore(this.$vApp.$pinia).children || [];
  }
  /**
   * Maps the current legend tree into a legend config snippet.
   *
   * In addition to legend config schema properties, this snippet will also include
   * properties such as the item type, item's uid, layer uid etc.
   *
   * @returns {any} returns the legend config
   * @memberof LegendAPI
   */
  getLegendConfig() {
    return {
      root: {
        children: this.getLegend().map((item) => item.getConfig())
      }
    };
  }
  /**
   * Get a legend item given its uid.
   *
   * @param {string} uid the uid of the legend item
   * @returns {LegendItem | undefined} return legend item with given uid. returns undefined if item is not found.
   * @memberof LegendAPI
   */
  getItem(uid) {
    const legend = this.getLegend();
    let result;
    legend.some((topItem) => {
      result = this.searchTreeFirst(topItem, (item) => item.uid === uid);
      return result !== void 0;
    });
    return result;
  }
  /**
   * Get the first found layer item connected to the layer with the given id/uid or the given layer instance.
   *
   * @param {string | LayerInstance} layer the id/uid of the layer or layer instance
   * @returns {LegendItem | undefined} return layer item tied to the found layer. returns undefined if no such item is found.
   * @memberof LegendAPI
   */
  getLayerItem(layer) {
    let uid;
    let id;
    let result;
    if (typeof layer === "string") {
      id = layer;
      uid = layer;
    } else {
      id = layer.id;
      uid = layer.uid;
    }
    const legend = this.getLegend();
    legend.some((topItem) => {
      result = this.searchTreeFirst(
        topItem,
        (item) => item instanceof LayerItem && (item.layerId === id || item.uid === uid)
      );
      return result !== void 0;
    });
    return result;
  }
  /**
   * Get all legend items with the given expanded state.
   * Not specifying the expanded state will return all items with expanded set to `true`
   *
   * @param {boolean | undefined} expanded the expanded state to check for
   * @returns {Array<LegendItem>} the items with the given expanded state
   * @memberof LegendAPI
   */
  getAllExpanded(expanded) {
    const check = expanded ?? true;
    return this.searchLegend((item) => item.children.length > 0 && item.expanded === check);
  }
  /**
   * Get all legend items with the given visibility state.
   * Not specifying the visibility state will return all items with visibility set to `true`
   *
   * @param {boolean | undefined} visibility the visibility state to check for
   * @returns {Array<LegendItem>} the items with the given expanded state
   * @memberof LegendAPI
   */
  getAllVisible(visibility) {
    const check = visibility ?? true;
    return this.searchLegend((item) => item.visibility === check);
  }
  /**
   * Return every legend block bound to a registered layer. Parent-child layer types will
   * return everything tied to the entire layer (parent & children)
   *
   * @param {LayerInstance | string} layer a layer instance, layer id, or layer uid
   * @returns {Array<LayerItem>} all legend items bound to the layer
   */
  getLayerBoundItems(layer) {
    let parentMostId = "";
    const layerInstance = layer instanceof LayerInstance ? layer : this.$iApi.geo.layer.getLayer(layer);
    if (layerInstance) {
      parentMostId = layerInstance.isSublayer ? layerInstance.parentLayer?.id || "" : layerInstance.id;
    } else {
      return [];
    }
    return this.searchLegend(
      (block) => block instanceof LayerItem && (block.layerId === parentMostId || block.parentLayerId === parentMostId)
    );
  }
  // Update
  /**
   * Update all layer items bound to the given layer.
   * Does nothing if no layer items are found
   *
   * @param {LayerInstance} layer the layer to update the legend with
   * @memberof LegendAPI
   */
  updateLegend(layer) {
    const updateLayerItem = (sourceLayer, error) => {
      const layerItem = this.getLayerItem(sourceLayer);
      if (error) {
        if (layerItem && sourceLayer instanceof LayerInstance) {
          layerItem.layer = sourceLayer;
        }
        layerItem?.error();
      } else {
        layerItem?.load(sourceLayer instanceof LayerInstance ? sourceLayer : void 0);
      }
    };
    layer.loadPromise().then(() => {
      let layerItem = this.getLayerItem(layer);
      if (layer.layerType === LayerType.MAPIMAGE) {
        const treeParser = (node) => {
          if (node.isLayerRoot && !node.isLogicalLayer) {
            layerItem = this.getLayerItem(layer);
            updateLayerItem(layer, false);
            if (layerItem && !layerItem.treeGrown) {
              node.children.map((childNode) => this._treeWalker(layer, childNode)).map((childConf) => this.addItem(childConf, layerItem));
              layerItem.treeGrown = true;
            }
            node.children.forEach((childNode) => treeParser(childNode));
          } else if (!node.isLayerRoot && !node.isLogicalLayer) {
            layerItem = this.getLayerItem(`${layer.id}-${node.layerIdx}`);
            if (layerItem) {
              const layerItemConf = layerItem.getConfig();
              delete layerItemConf.layerId;
              delete layerItemConf.sublayerIndex;
              delete layerItemConf.children;
              if (!layerItemConf.name) {
                delete layerItemConf.name;
              }
              const replacementConf = {
                ...this._treeWalker(layer, node),
                ...layerItemConf
              };
              const replacementItem = this.createItem(replacementConf);
              this._replaceItem(layerItem, replacementItem);
            }
            node.children.forEach((childNode) => treeParser(childNode));
          } else if (node.isLogicalLayer) {
            updateLayerItem(this._treeWalker(layer, node).layer, false);
          }
        };
        treeParser(layer.getLayerTree());
      } else {
        updateLayerItem(layer, false);
      }
    }).catch(() => {
      updateLayerItem(layer, true);
      if (layer.supportsSublayers) {
        layer.config.sublayers.forEach((sublayer) => {
          updateLayerItem(`${layer.id}-${sublayer.index}`, true);
        });
      }
    });
  }
  /**
   * Set the expanded state of legend items to `expanded`
   *
   * @param {boolean} expanded the expanded state the items will be set to
   * @param {LegendItem | undefined} root the root item to start updating the expanded state from
   * @memberof LegendAPI
   */
  expandItems(expanded, root) {
    const legend = this.getLegend();
    const items = root === void 0 ? legend : root.children;
    if (root !== void 0) {
      this._toggleState(root, { expanded });
    }
    items.forEach((item) => {
      this._toggleState(item, { expanded });
    });
  }
  /**
   * Set the visibility state of legend items to `visibility`
   *
   * @param {boolean} visibility the visibility state the items will be set to
   * @param {LegendItem | undefined} root the root item to start updating the visibility state from
   * @memberof LegendAPI
   */
  showItems(visibility, root) {
    const legend = this.getLegend();
    const items = root === void 0 ? legend : root.children;
    if (root !== void 0) {
      this._toggleState(root, { visibility });
    }
    items.forEach((item) => {
      this._toggleState(item, { visibility });
    });
  }
  /**
   * Reload the all legend items connected to the given layer.
   * This preps the items for the reload. It does not reload the actual layer.
   * Parent-child layer types will prep all items related to the layer (both
   * parent and sublayers)
   *
   * @param {LayerInstance | string} layer a layer instance, layer id, or layer uid referencing the reloaded layer
   * @returns {boolean} returns true if item was successfully reloaded, false otherwise
   * @memberof LegendAPI
   */
  reloadLayerItem(layer) {
    const affectedBlocks = this.getLayerBoundItems(layer);
    affectedBlocks.forEach((block) => block.reload());
    return affectedBlocks.length > 0;
  }
  // Delete
  /**
   * Removes the legend item with the given uid, or the item instance.
   *
   * @param {string | LegendItem} item the uid of item or legend item instance to be removed
   * @returns {boolean} returns true if item was removed, false otherwise
   * @memberof LegendAPI
   */
  removeItem(item) {
    const itemToRemove = typeof item === "string" ? this.getItem(item) : item;
    if (itemToRemove !== void 0) {
      return this._deleteItem(itemToRemove);
    }
    return false;
  }
  /**
   * Remove the layer item connected to the layer with the given id/uid or the given layer instance.
   *
   * @param {string | LayerInstance} layer the id/uid of the layer or layer instance
   * @returns {boolean} returns true if item was removed, false otherwise
   * @memberof LegendAPI
   */
  removeLayerItem(layer) {
    const itemToRemove = this.getLayerItem(layer);
    if (itemToRemove !== void 0) {
      return this._deleteItem(itemToRemove);
    }
    return false;
  }
  // _Helpers
  /**
   * Search for the first legend item that satisfies the predicate, starting from the given root item.
   *
   * @param {LegendItem} root the root item to start searching from
   * @param {(item: LegendItem) => boolean} predicate boolean predicate to test each item
   * @returns {LegendItem \ undefined} return the first item that satisfies the given predicate. returns undefined if item is not found.
   */
  searchTreeFirst(root, predicate) {
    if (predicate(root)) {
      return root;
    } else {
      let result;
      root.children.some((child) => {
        result = this.searchTreeFirst(child, predicate);
        return result !== void 0;
      });
      return result;
    }
  }
  /**
   * Search for all legend items that satisfy the predicate, starting from the given root item.
   *
   * @param {LegendItem} root the root item to start searching from
   * @param {(item: LegendItem) => boolean} predicate predicate boolean predicate to test each item
   * @returns {Array<LegendItem>} return all items that satisfies the given predicate.
   */
  searchTreeAll(root, predicate) {
    const items = [];
    const queue = [root];
    while (queue.length > 0) {
      const item = queue.shift();
      if (item && predicate(item)) {
        items.push(item);
      }
      if (item) {
        queue.push(...item.children);
      }
    }
    return items;
  }
  /**
   * Search the entire legend for items that satisfy the predicate
   *
   * @param {(item: LegendItem) => boolean} predicate predicate boolean predicate to test each item
   * @returns {Array<LegendItem>} return all items that satisfies the given predicate.
   */
  searchLegend(predicate) {
    return this.getLegend().map((rootChildItem) => this.searchTreeAll(rootChildItem, predicate)).flat();
  }
  /**
   * Toggles visibility for all items or expands/collapses all groups.
   *
   * @param {LegendItem} item current legend item that is being checked
   * @param {any} options specifies whether visibility or expand/collapse functionality is to be changed
   */
  _toggleState(item, options) {
    const visibility = options.visibility;
    const expanded = options.expanded;
    if (visibility !== void 0) {
      item.toggleVisibility(visibility);
    }
    if (expanded !== void 0 && item.children.length > 0) {
      item.toggleExpanded(expanded);
    }
    if (item.children && item.children.length > 0) {
      item.children.forEach((ch) => {
        this._toggleState(ch, options);
      });
    }
  }
  /**
   * Add the given legend item to the legend store
   *
   * @param {Legenditem} item the legend item to be added
   * @param {LegendItem | undefined} parent the parent legend item for this item
   */
  _insertItem(item, parent) {
    useLegendStore(this.$vApp.$pinia).addItem({ item, parent });
  }
  /**
   * Deletes the given legend item from the legend store
   *
   * @param {Legenditem} item the legend item to be deleted
   * @returns {boolean} returns true if item was removed, false otherwise
   */
  _deleteItem(item) {
    const store = useLegendStore(this.$vApp.$pinia);
    const removeItemAndDescendants = (itemToRemove) => {
      if (itemToRemove.children.length > 0) {
        itemToRemove.children.forEach((child) => {
          removeItemAndDescendants(child);
        });
      }
      if (itemToRemove instanceof LayerItem) {
        itemToRemove.handlers.forEach((handler) => this.$iApi.event.off(handler));
      }
      store.removeItem(itemToRemove);
    };
    removeItemAndDescendants(item);
    return true;
  }
  _replaceItem(oldItem, newItem) {
    useLegendStore(this.$vApp.$pinia).replaceItem({ oldItem, newItem });
  }
  // map out layer's layer tree children into a legend configs
  _treeWalker(layer, node, extraConfig) {
    const getLayer = (uid) => {
      const queue = [layer];
      while (queue.length > 0) {
        const l = queue.shift();
        if (l && l.uid === uid) {
          return l;
        }
        if (l) {
          queue.push(...l.sublayers);
        }
      }
    };
    const currLayer = getLayer(node.uid);
    const currItem = {};
    if (node.isLayerRoot && !node.isLogicalLayer) {
      currItem.layer = currLayer;
      currItem.name = currLayer.name;
      currItem.children = node.children.map((childNode) => this._treeWalker(layer, childNode, extraConfig));
    } else if (!node.isLayerRoot && !node.isLogicalLayer) {
      currItem.name = node.name;
      currItem.children = node.children.map((childNode) => this._treeWalker(layer, childNode, extraConfig));
    } else if (node.isLogicalLayer) {
      currItem.layer = currLayer;
      currItem.name = currLayer.name;
      currItem.layerId = currLayer.id;
      currItem.sublayerIndex = layer.isSublayer ? layer.layerIdx : void 0;
    }
    return { ...currItem, ...extraConfig };
  }
}

const _sfc_main$D = /* @__PURE__ */ defineComponent({
  __name: "nav-button",
  setup(__props) {
    const { t } = useI18n();
    const iApi = inject("iApi");
    const togglePanel = () => {
      iApi.panel.toggle("legend");
    };
    return (_ctx, _cache) => {
      const _component_mapnav_button = resolveComponent("mapnav-button");
      return openBlock(), createBlock(_component_mapnav_button, {
        onClickFunction: togglePanel,
        tooltip: unref(t)("legend.title")
      }, {
        default: withCtx(() => _cache[0] || (_cache[0] = [
          createElementVNode("svg", {
            class: "fill-current w-32 h-20",
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24"
          }, [
            createElementVNode("path", {
              d: "M0 0h24v24H0z",
              fill: "none"
            }),
            createElementVNode("path", { d: "M11.99 18.54l-7.37-5.73L3 14.07l9 7 9-7-1.63-1.27-7.38 5.74zM12 16l7.36-5.73L21 9l-9-7-9 7 1.63 1.27L12 16z" })
          ], -1)
        ])),
        _: 1
      }, 8, ["tooltip"]);
    };
  }
});

const _hoisted_1$y = ["content"];
const _sfc_main$C = /* @__PURE__ */ defineComponent({
  __name: "screen",
  props: {
    panel: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const legendHeader = defineAsyncComponent(() => Promise.resolve().then(() => header$1));
    const legendItem = defineAsyncComponent(() => Promise.resolve().then(() => item$1));
    const { t } = useI18n();
    const iApi = inject("iApi");
    const el = ref();
    const blurEvent = () => {
      el.value._tippy.hide();
    };
    const keyupEvent = (e) => {
      const evt = e;
      if (evt.key === "Tab" && el.value?.matches(":focus")) {
        el.value._tippy.show();
      }
    };
    onMounted(() => {
      el.value?.addEventListener("blur", blurEvent);
      el.value?.addEventListener("keyup", keyupEvent);
    });
    onBeforeUnmount(() => {
      el.value?.removeEventListener("blur", blurEvent);
      el.value?.removeEventListener("keyup", keyupEvent);
    });
    const children = computed(() => {
      let legendApi = iApi.fixture.get("legend");
      if (legendApi) {
        return [...legendApi.getLegend()];
      }
      return [];
    });
    return (_ctx, _cache) => {
      const _component_panel_screen = resolveComponent("panel-screen");
      const _directive_focus_list = resolveDirective("focus-list");
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createBlock(_component_panel_screen, { panel: __props.panel }, {
        header: withCtx(() => [
          createTextVNode(toDisplayString(unref(t)("legend.title")), 1)
        ]),
        content: withCtx(() => [
          createVNode(unref(legendHeader)),
          withDirectives((openBlock(), createElementBlock("div", {
            content: unref(t)("panels.controls.items"),
            ref_key: "el",
            ref: el
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(children.value, (item) => {
              return openBlock(), createBlock(unref(legendItem), {
                legendItem: item,
                key: item.uid
              }, null, 8, ["legendItem"]);
            }), 128))
          ], 8, _hoisted_1$y)), [
            [_directive_focus_list],
            [_directive_tippy, {
              trigger: "manual",
              placement: "top-end",
              maxWidth: 190
            }]
          ])
        ]),
        _: 1
      }, 8, ["panel"]);
    };
  }
});

const screen$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: _sfc_main$C
}, Symbol.toStringTag, { value: 'Module' }));

const messages$7 = {"en":{"legend.title":"Legend","legend.header.addlayer":"Add Layer","legend.header.reorderlayers":"Reorder Layers","legend.header.groups":"Toggle Groups","legend.header.groups.expand":"Expand All","legend.header.groups.collapse":"Collapse All","legend.header.visible":"Toggle Visibility","legend.header.visible.show":"Show All","legend.header.visible.hide":"Hide All","legend.group.expand":"Expand Group","legend.group.collapse":"Collapse Group","legend.visibility.showLayer":"Show layer","legend.visibility.hideLayer":"Hide layer","legend.visibility.showSymbol":"Show symbol","legend.visibility.hideSymbol":"Hide symbol","legend.visibility.showGroup":"Show group","legend.visibility.hideGroup":"Hide group","legend.symbology.expand":"Expand legend","legend.symbology.hide":"Hide legend","legend.symbology.loading":"Loading...","legend.layer.data":"Show more data","legend.layer.data.only":"Layer not on map","legend.layer.offscale":"Layer out of scale","legend.layer.zoomToVisible":"Zoom to visible scale","legend.layer.options":"More options","legend.layer.controls.metadata":"Metadata","legend.layer.controls.settings":"Settings","legend.layer.controls.datatable":"Datatable","legend.layer.controls.symbology":"Legend","legend.layer.controls.boundaryzoom":"Zoom to Layer Boundary","legend.layer.controls.cancel":"Cancel","legend.layer.controls.remove":"Remove","legend.layer.controls.reload":"Reload","legend.layer.controls.reloadDisabled":"Layer cannot be reloaded","legend.alert.symbologyExpanded":"Layer legend expanded","legend.alert.symbologyCollapsed":"Layer legend collapsed","legend.alert.groupExpanded":"Legend group expanded","legend.alert.groupCollapsed":"Legend group collapsed","legend.alert.layerAdded":"{name} layer added to legend","legend.alert.layerRemoved":"{name} layer removed from legend"},"fr":{"legend.title":"Légende","legend.header.addlayer":"Ajouter une couche","legend.header.reorderlayers":"Réorganiser les couches","legend.header.groups":"Basculer les Groupes","legend.header.groups.expand":"Élargir les groupes","legend.header.groups.collapse":"Réduire les groupes","legend.header.visible":"Basculer la Visibilité","legend.header.visible.show":"Montrer tout","legend.header.visible.hide":"Cacher tout","legend.group.expand":"Développer un groupe","legend.group.collapse":"Réduire un groupe","legend.visibility.showLayer":"Afficher la couche","legend.visibility.hideLayer":"Masquer la couche","legend.visibility.showSymbol":"Afficher le symbole","legend.visibility.hideSymbol":"Masquer le symbole","legend.visibility.showGroup":"Afficher le groupe","legend.visibility.hideGroup":"Masquer le groupe","legend.symbology.expand":"Développer la légende","legend.symbology.hide":"Masquer la légende","legend.symbology.loading":"Chargement en cours...","legend.layer.data":"Afficher plus de données","legend.layer.data.only":"Couche non visualisable","legend.layer.offscale":"Couche hors de portée","legend.layer.zoomToVisible":"Zoom sur l'échelle visible","legend.layer.options":"Plus d'options","legend.layer.controls.metadata":"Métadonnées","legend.layer.controls.settings":"Paramètres","legend.layer.controls.datatable":"Tableau de données","legend.layer.controls.symbology":"Légende","legend.layer.controls.boundaryzoom":"Zoomer à la limite","legend.layer.controls.cancel":"Annuler","legend.layer.controls.remove":"Retirer","legend.layer.controls.reload":"Recharger","legend.layer.controls.reloadDisabled":"Le calque ne peut pas être rechargé","legend.alert.symbologyExpanded":"Légende de la couche développée","legend.alert.symbologyCollapsed":"Légende de la couche réduite","legend.alert.groupExpanded":"Groupe de légende développé","legend.alert.groupCollapsed":"Groupe de légende réduit","legend.alert.layerAdded":"{name} couche ajoutée à la légende","legend.alert.layerRemoved":"Couche {name} retiré de la légende"}};

class LegendFixture extends LegendAPI {
  added() {
    this.$iApi.component("legend-nav-button", _sfc_main$D);
    this.$iApi.panel.register(
      {
        legend: {
          screens: {
            "legend-screen": markRaw(_sfc_main$C)
          },
          style: {
            width: "350px"
          },
          alertName: "legend.title",
          button: {
            tooltip: "legend.title",
            // https://material.io/resources/icons/?icon=layers&style=baseline
            icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none" /><path d="M11.99 18.54l-7.37-5.73L3 14.07l9 7 9-7-1.63-1.27-7.38 5.74zM12 16l7.36-5.73L21 9l-9-7-9 7 1.63 1.27L12 16z" /></svg>'
          }
        }
      },
      {
        i18n: { messages: messages$7 }
      }
    );
    this._parseConfig(this.config !== void 0 ? JSON.parse(JSON.stringify(this.config)) : void 0);
    const unwatch = this.$vApp.$watch(
      () => this.config,
      (value) => this._parseConfig(value !== void 0 ? JSON.parse(JSON.stringify(value)) : void 0)
    );
    this.removed = () => {
      unwatch();
      if (this.$iApi.fixture.exists("appbar")) {
        const appbarStore = useAppbarStore(this.$vApp.$pinia);
        appbarStore.removeButton("legend");
      }
      if (this.$iApi.fixture.exists("mapnav")) {
        const mapnavStore = useMapnavStore(this.$vApp.$pinia);
        mapnavStore.removeItem("legend");
      }
      const legendStore = useLegendStore();
      legendStore.$reset();
      this.$iApi.panel.remove("legend");
    };
  }
}

const index$9 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: LegendFixture
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$B = {};

const _hoisted_1$x = { class: "border-b p-0 self-center w-2/3" };

function _sfc_render(_ctx, _cache) {
  return (openBlock(), createElementBlock("span", _hoisted_1$x))
}
const DividerNav = /*#__PURE__*/_export_sfc(_sfc_main$B, [['render',_sfc_render]]);

const _sfc_main$A = /* @__PURE__ */ defineComponent({
  __name: "zoom-nav",
  setup(__props) {
    const { t } = useI18n();
    const iApi = inject("iApi");
    const zoomIn = throttle(400, true, () => iApi.geo.map.zoomIn());
    const zoomOut = throttle(400, true, () => iApi.geo.map.zoomOut());
    return (_ctx, _cache) => {
      const _component_mapnav_button = resolveComponent("mapnav-button");
      return openBlock(), createElementBlock("div", null, [
        createVNode(_component_mapnav_button, {
          onClickFunction: unref(zoomIn),
          tooltip: unref(t)("mapnav.zoomIn")
        }, {
          default: withCtx(() => _cache[0] || (_cache[0] = [
            createElementVNode("svg", {
              xmlns: "http://www.w3.org/2000/svg",
              viewBox: "0 0 24 24",
              class: "fill-current w-32 h-20"
            }, [
              createElementVNode("path", { d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" }),
              createElementVNode("path", {
                d: "M0 0h24v24H0z",
                fill: "none"
              })
            ], -1)
          ])),
          _: 1
        }, 8, ["onClickFunction", "tooltip"]),
        createVNode(DividerNav),
        createVNode(_component_mapnav_button, {
          onClickFunction: unref(zoomOut),
          tooltip: unref(t)("mapnav.zoomOut")
        }, {
          default: withCtx(() => _cache[1] || (_cache[1] = [
            createElementVNode("svg", {
              xmlns: "http://www.w3.org/2000/svg",
              viewBox: "0 0 24 24",
              class: "fill-current w-32 h-20"
            }, [
              createElementVNode("path", { d: "M19 13H5v-2h14v2z" }),
              createElementVNode("path", {
                d: "M0 0h24v24H0z",
                fill: "none"
              })
            ], -1)
          ])),
          _: 1
        }, 8, ["onClickFunction", "tooltip"])
      ]);
    };
  }
});

const _hoisted_1$w = { class: "mapnav absolute right-0 bottom-0 pb-36 sm:pb-48 pr-12" };
const _hoisted_2$o = ["content"];
const _hoisted_3$k = { class: "mapnav-section bg-white-75 hover:bg-white" };
const _sfc_main$z = /* @__PURE__ */ defineComponent({
  __name: "mapnav",
  setup(__props) {
    const mapnavStore = useMapnavStore();
    const { t } = useI18n();
    const el = ref();
    const blurEvent = () => {
      el.value._tippy.hide();
    };
    const keyupEvent = (e) => {
      const evt = e;
      if (evt.key === "Tab" && el.value?.matches(":focus")) {
        el.value._tippy.show();
      }
    };
    onMounted(() => {
      el.value?.addEventListener("blur", blurEvent);
      el.value?.addEventListener("keyup", keyupEvent);
    });
    onBeforeUnmount(() => {
      el.value?.removeEventListener("blur", blurEvent);
      el.value?.removeEventListener("keyup", keyupEvent);
    });
    const visible = computed(() => mapnavStore.order.map((id) => mapnavStore.items[id]).filter((item) => item.componentId));
    return (_ctx, _cache) => {
      const _directive_focus_list = resolveDirective("focus-list");
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", _hoisted_1$w, [
        withDirectives((openBlock(), createElementBlock("div", {
          class: "flex flex-col",
          content: unref(t)("panels.controls.items"),
          ref_key: "el",
          ref: el
        }, [
          createVNode(_sfc_main$A, { class: "mapnav-section bg-white-75 hover:bg-white" }),
          _cache[0] || (_cache[0] = createElementVNode("span", { class: "py-1" }, null, -1)),
          createElementVNode("div", _hoisted_3$k, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(visible.value, (button, index) => {
              return openBlock(), createElementBlock(Fragment, {
                key: button.id + "button"
              }, [
                (openBlock(), createBlock(resolveDynamicComponent(button.id + "-nav-button"))),
                index !== visible.value.length - 1 ? (openBlock(), createBlock(DividerNav, {
                  key: 0,
                  class: "mapnav-divider"
                })) : createCommentVNode("", true)
              ], 64);
            }), 128))
          ])
        ], 8, _hoisted_2$o)), [
          [_directive_focus_list],
          [_directive_tippy, {
            trigger: "manual",
            placement: "top-end",
            maxWidth: 190
          }]
        ])
      ]);
    };
  }
});

const MapnavV = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["__scopeId", "data-v-dde7576f"]]);

class MapnavAPI extends FixtureInstance {
  mapnavStore = useMapnavStore(this.$vApp.$pinia);
  /**
   * Returns `MapnavFixtureConfig` section of the global config file.
   *
   * @readonly
   * @type {MapnavFixtureConfig}
   * @memberof MapnavFixture
   */
  get config() {
    return super.config;
  }
  /**
   * Parses the mapnav config JSON snippet from the config file and save resulting objects to the fixture store.
   *
   * @param {MapnavFixtureConfig} [mapnavConfig]
   * @returns
   * @memberof MapnavAPI
   */
  _parseConfig(mapnavConfig) {
    if (!mapnavConfig) {
      return;
    }
    const mapnavItems = mapnavConfig.items.map((item) => ({
      id: item
    }));
    this.mapnavStore.items = mapnavItems.reduce((map, item) => {
      map[item.id] = item;
      return map;
    }, {});
    this.mapnavStore.order = mapnavItems.map((item) => item.id);
    this._validateItems();
  }
  /**
   * Checks if components specified as mapnav items are registered or not.
   * Will check the literal id values, and id values with `-nav-button` suffixes appended.
   *
   * @memberof MapnavAPI
   */
  _validateItems() {
    const systemControls = ["geolocator", "zoom", "home", "fullscreen"];
    this.mapnavStore.order.forEach((id) => {
      if (this.$iApi.fixture.exists(id) || systemControls.includes(id)) {
        this.mapnavStore.items[id].componentId = `${id}-nav-button`;
      }
    });
  }
}

const messages$6 = {"en":{"mapnav.zoomIn":"Zoom In","mapnav.zoomOut":"Zoom Out","mapnav.home":"Home","mapnav.fullscreen":"Full Screen","mapnav.geolocator":"Your Location","mapnav.geolocator.error.permission":"The location request was denied. Please check your browser permission settings.","mapnav.geolocator.error.internal":"Your location could not be found."},"fr":{"mapnav.zoomIn":"Zoom avant","mapnav.zoomOut":"Zoom arrière","mapnav.home":"Accueil","mapnav.fullscreen":"Plein Écran","mapnav.geolocator":"Votre position","mapnav.geolocator.error.permission":"Demande de localisation refusée. Veuillez vérifier les paramètres d'autorisation de votre navigateur.","mapnav.geolocator.error.internal":"Votre emplacement n'a pu être trouvé."}};

class MapnavFixture extends MapnavAPI {
  async added() {
    Object.entries(messages$6).forEach((value) => this.$iApi.$i18n.mergeLocaleMessage(...value));
    const { destroy, el } = this.mount(MapnavV, {
      app: this.$element
    });
    const innerShell = this.$vApp.$el.getElementsByClassName("inner-shell")[0];
    innerShell.appendChild(el.childNodes[0]);
    this._parseConfig(this.config);
    const unwatch = this.$vApp.$watch(
      () => this.config,
      (value) => this._parseConfig(value)
    );
    const handler = this.$iApi.event.on(GlobalEvents.COMPONENT, () => {
      this._parseConfig(this.config);
    });
    this.removed = () => {
      unwatch();
      this.$iApi.event.off(handler);
      const mapnavStore = useMapnavStore(this.$vApp.$pinia);
      const items = { ...mapnavStore.items };
      Object.keys(items).forEach((item) => mapnavStore.removeItem(item));
      mapnavStore.$reset();
      destroy();
    };
  }
}

const index$8 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: MapnavFixture
}, Symbol.toStringTag, { value: 'Module' }));

class MetadataAPI extends FixtureInstance {
  /**
   * Toggles the metadata panel. Provides the given payload as a prop to the panel.
   * @param payload
   */
  toggleMetadata(payload, open) {
    const panel = this.$iApi.panel.get("metadata");
    if (open === false) {
      panel.close();
      return;
    }
    if (!panel.isOpen || !panel.isVisible) {
      this.$iApi.panel.open({
        id: "metadata",
        props: { payload }
      });
    } else {
      const currentUid = panel.route.props.payload.layer.uid;
      if (currentUid !== payload?.layer?.uid || open) {
        panel.show({
          screen: "metadata-screen-content",
          props: { payload }
        });
      } else {
        panel.close();
      }
    }
  }
}

const XSLT_en = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xsl:stylesheet version=\"1.0\"\n                xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n                xmlns:gmd=\"http://www.isotc211.org/2005/gmd\"\n                xmlns:gco=\"http://www.isotc211.org/2005/gco\"\n                xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n                xmlns:gmdl=\"http://www.canada.gc.ca/ns/gmdl\"\n                xmlns:napec=\"http://www.ec.gc.ca/data_donnees/standards/schemas/napec\"\n                xmlns:gml=\"http://www.opengis.net/gml\"\n                xmlns:geonet=\"http://www.fao.org/geonetwork\"\n                xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n                xsi:schemaLocation=\"http://www.ec.gc.ca/data_donnees/standards/schemas/napec/schema.xsd\">\n\n  <xsl:param name=\"catalogue_url\" />\n  <xsl:decimal-format NaN=\"\"/>\n\n  <xsl:template match=\"/\">\n\n    <div class=\"metadata-view\">\n\n      <xsl:if test=\"//gmd:abstract/gco:CharacterString/text() != ''\">\n        <h5 class=\"text-xl font-bold mb-3\">{{metadata.xslt.Abstract}}</h5>\n        <p>\n          <xsl:value-of select=\"//gmd:abstract/gco:CharacterString/text()\" />\n        </p>\n      </xsl:if>\n\n      <xsl:comment>\n        <h5 class=\"text-xl font-bold mb-3\">{{metadata.xslt.Scope}}</h5>\n        <p>{{metadata.xslt.hereBeScope}}</p>\n      </xsl:comment>\n\n      <xsl:if test=\"//gml:TimePeriod//* != ''\">\n        <h5 class=\"text-xl font-bold mb-3\">{{metadata.xslt.timePeriod}}</h5>\n        <p>\n          <xsl:value-of select=\"//gml:TimePeriod//gml:beginPosition\" />\n          <xsl:if test=\"//gml:TimePeriod//gml:beginPosition/text() != '' and //gml:TimePeriod//gml:endPosition/text() != ''\">\n            -\n          </xsl:if>\n          <xsl:value-of select=\"//gml:TimePeriod//gml:endPosition\" />\n        </p>\n      </xsl:if>\n\n      <xsl:comment>\n        <xsl:if test=\"//gmd:supplementalInformation/gco:CharacterString/text() != ''\">\n          <h5 class=\"text-xl font-bold mb-3\">{{metadata.xslt.supplementalData}}</h5>\n          <p>\n            <xsl:value-of select=\"//gmd:supplementalInformation/gco:CharacterString/text()\" />\n          </p>\n        </xsl:if>\n      </xsl:comment>\n\n      <xsl:if test=\"//gmd:pointOfContact//gmd:individualName/* != '' \n              or //gmd:pointOfContact//gmd:organisationName/gco:CharacterString/text() != ''\n              or //gmd:pointOfContact//gmd:positionName/gco:CharacterString/text() != ''\n              or //gmd:pointOfContact//gmd:electronicMailAddress/* != ''\n              or //gmd:pointOfContact//gmd:role/gmd:CI_RoleCode/@codeListValue != ''\">\n        <h5 class=\"text-xl font-bold mb-3\">{{metadata.xslt.contactInfo}}</h5>\n        <p>\n          <xsl:value-of select=\"//gmd:pointOfContact//gmd:individualName\" />\n        </p>\n        <p>\n          <xsl:value-of select=\"//gmd:pointOfContact//gmd:organisationName/gco:CharacterString/text()\" />\n        </p>\n        <p>\n          <xsl:value-of select=\"//gmd:pointOfContact//gmd:positionName/gco:CharacterString/text()\" />\n        </p>\n        <p>\n          <a href=\"mailto:{//gmd:pointOfContact//gmd:electronicMailAddress/gco:CharacterString/text()}?Subject={//gmd:identificationInfo//gmd:title/gco:CharacterString/text()}\">\n            <xsl:value-of select=\"//gmd:pointOfContact//gmd:electronicMailAddress\" />\n          </a>\n        </p>\n        <p>\n          <xsl:variable name=\"roleCode\" >\n            <xsl:value-of select=\"concat(substring(//gmd:pointOfContact//gmd:role/gmd:CI_RoleCode/@codeListValue,1,1),\n                        substring(//gmd:pointOfContact//gmd:role/gmd:CI_RoleCode/@codeListValue, 2))\" />\n          </xsl:variable>\n\n          <xsl:choose>\n            <xsl:when test=\"$roleCode = 'resourceProvider'\">{{metadata.xslt.resourceProvider}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'custodian'\">{{metadata.xslt.custodian}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'owner'\">{{metadata.xslt.owner}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'user'\">{{metadata.xslt.user}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'distributor'\">{{metadata.xslt.distributor}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'originator'\">{{metadata.xslt.originator}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'pointOfContact'\">{{metadata.xslt.pointOfContact}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'principalInvestigator'\">{{metadata.xslt.principalInvestigator}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'processor'\">{{metadata.xslt.processor}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'publisher'\">{{metadata.xslt.publisher}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'author'\">{{metadata.xslt.author}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'collaborator'\">{{metadata.xslt.collaborator}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'editor'\">{{metadata.xslt.editor}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'mediator'\">{{metadata.xslt.mediator}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'rightsHolder'\">{{metadata.xslt.rightsHolder}}</xsl:when>\n          </xsl:choose>\n        </p>\n      </xsl:if>\n\n      <xsl:if test=\"$catalogue_url != ''\">\n        <h5 class=\"text-xl font-bold mb-3\">{{metadata.xslt.cataloguePage}}</h5>\n        <p>\n          <a href=\"{$catalogue_url}\"\n             rel=\"external\" target=\"_blank\" class=\"ui-link\">\n            {{metadata.xslt.metadata}}\n          </a>\n        </p>\n      </xsl:if>\n    </div>\n  </xsl:template>\n</xsl:stylesheet>\n";

const XSLT_fr = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xsl:stylesheet version=\"1.0\"\n                xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n                xmlns:gmd=\"http://www.isotc211.org/2005/gmd\"\n                xmlns:gco=\"http://www.isotc211.org/2005/gco\"\n                xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n                xmlns:gmdl=\"http://www.canada.gc.ca/ns/gmdl\"\n                xmlns:napec=\"http://www.ec.gc.ca/data_donnees/standards/schemas/napec\"\n                xmlns:gml=\"http://www.opengis.net/gml\"\n                xmlns:geonet=\"http://www.fao.org/geonetwork\"\n                xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n                xsi:schemaLocation=\"http://www.ec.gc.ca/data_donnees/standards/schemas/napec/schema.xsd\">\n\n  <xsl:param name=\"catalogue_url\" />\n  <xsl:decimal-format NaN=\"\"/>\n\n  <xsl:template match=\"/\">\n\n    <div class=\"metadata-view\">\n\n      <xsl:if test=\"//gmd:abstract//gmd:LocalisedCharacterString[@locale='#fra']/text() != ''\">\n        <h5 class=\"text-xl font-bold mb-3\">{{metadata.xslt.Abstract}}</h5>\n        <p>\n          <xsl:value-of select=\"//gmd:abstract//gmd:LocalisedCharacterString[@locale='#fra']/text()\" />\n        </p>\n      </xsl:if>\n\n      <xsl:comment>\n        <h5 class=\"text-xl font-bold mb-3\">{{metadata.xslt.Scope}}</h5>\n        <p>{{metadata.xslt.hereBeScope}}</p>\n      </xsl:comment>\n\n      <xsl:if test=\"//gml:TimePeriod//* != ''\">\n        <h5 class=\"text-xl font-bold mb-3\">{{metadata.xslt.timePeriod}}</h5>\n        <p>\n          <xsl:value-of select=\"//gml:TimePeriod//gml:beginPosition\" />\n          <xsl:if test=\"//gml:TimePeriod//gml:beginPosition/text() != '' and //gml:TimePeriod//gml:endPosition/text() != ''\">\n            -\n          </xsl:if>\n          <xsl:value-of select=\"//gml:TimePeriod//gml:endPosition\" />\n        </p>\n      </xsl:if>\n\n      <xsl:comment>\n        <xsl:if test=\"//gmd:supplementalInformation//gmd:LocalisedCharacterString[@locale='#fra']/text() != ''\">\n          <h5 class=\"text-xl font-bold mb-3\">{{metadata.xslt.supplementalData}}</h5>\n          <p>\n            <xsl:value-of select=\"//gmd:supplementalInformation//gmd:LocalisedCharacterString[@locale='#fra']/text()\" />\n          </p>\n        </xsl:if>\n      </xsl:comment>\n\n      <xsl:if test=\"//gmd:pointOfContact//gmd:individualName/* != '' \n              or //gmd:pointOfContact//gmd:organisationName//gmd:LocalisedCharacterString[@locale='#fra']/text() != ''\n              or //gmd:pointOfContact//gmd:positionName//gmd:LocalisedCharacterString[@locale='#fra']/text() != ''\n              or //gmd:pointOfContact//gmd:electronicMailAddress/* != ''\n              or //gmd:pointOfContact//gmd:role/gmd:CI_RoleCode/@codeListValue != ''\">\n        <h5 class=\"text-xl font-bold mb-3\">{{metadata.xslt.contactInfo}}</h5>\n        <p>\n          <xsl:value-of select=\"//gmd:pointOfContact//gmd:individualName\" />\n        </p>\n        <p>\n          <xsl:value-of select=\"//gmd:pointOfContact//gmd:organisationName//gmd:LocalisedCharacterString[@locale='#fra']/text()\" />\n        </p>\n        <p>\n          <xsl:value-of select=\"//gmd:pointOfContact//gmd:positionName//gmd:LocalisedCharacterString[@locale='#fra']/text()\" />\n        </p>\n        <p>\n          <a href=\"mailto:{//gmd:pointOfContact//gmd:electronicMailAddress//gmd:LocalisedCharacterString[@locale='#fra']/text()}?Subject={//gmd:identificationInfo//gmd:title//gmd:LocalisedCharacterString[@locale='#fra']/text()}\">\n            <xsl:value-of select=\"//gmd:pointOfContact//gmd:electronicMailAddress\" />\n          </a>\n        </p>\n        <p>\n          <xsl:variable name=\"roleCode\" >\n            <xsl:value-of select=\"concat(substring(//gmd:pointOfContact//gmd:role/gmd:CI_RoleCode/@codeListValue,1,1),\n                        substring(//gmd:pointOfContact//gmd:role/gmd:CI_RoleCode/@codeListValue, 2))\" />\n          </xsl:variable>\n\n          <xsl:choose>\n            <xsl:when test=\"$roleCode = 'resourceProvider'\">{{metadata.xslt.resourceProvider}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'custodian'\">{{metadata.xslt.custodian}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'owner'\">{{metadata.xslt.owner}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'user'\">{{metadata.xslt.user}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'distributor'\">{{metadata.xslt.distributor}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'originator'\">{{metadata.xslt.originator}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'pointOfContact'\">{{metadata.xslt.pointOfContact}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'principalInvestigator'\">{{metadata.xslt.principalInvestigator}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'processor'\">{{metadata.xslt.processor}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'publisher'\">{{metadata.xslt.publisher}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'author'\">{{metadata.xslt.author}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'collaborator'\">{{metadata.xslt.collaborator}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'editor'\">{{metadata.xslt.editor}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'mediator'\">{{metadata.xslt.mediator}}</xsl:when>\n            <xsl:when test=\"$roleCode = 'rightsHolder'\">{{metadata.xslt.rightsHolder}}</xsl:when>\n          </xsl:choose>\n        </p>\n      </xsl:if>\n\n      <xsl:if test=\"$catalogue_url != ''\">\n        <h5 class=\"text-xl font-bold mb-3\">{{metadata.xslt.cataloguePage}}</h5>\n        <p>\n          <a href=\"{$catalogue_url}\"\n             rel=\"external\" target=\"_blank\" class=\"ui-link\">\n            {{metadata.xslt.metadata}}\n          </a>\n        </p>\n      </xsl:if>\n    </div>\n  </xsl:template>\n</xsl:stylesheet>\n";

const _hoisted_1$v = { key: 0 };
const _hoisted_2$n = { class: "flex justify-center" };
const _hoisted_3$j = {
  key: 0,
  class: "flex flex-col justify-center text-center"
};
const _hoisted_4$b = ["innerHTML"];
const _hoisted_5$a = ["innerHTML"];
const _hoisted_6$9 = {
  key: 3,
  class: "flex flex-col justify-center text-center"
};
const _hoisted_7$9 = { class: "text-xl mt-20" };
const _hoisted_8$5 = {
  key: 1,
  class: "p-5"
};
const _sfc_main$y = /* @__PURE__ */ defineComponent({
  __name: "screen",
  props: {
    panel: {
      type: Object,
      required: true
    },
    payload: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const metadataStore = useMetadataStore();
    const { t } = useI18n();
    const iApi = inject("iApi");
    const el = ref();
    const props = __props;
    const status = computed(() => metadataStore.status);
    const response = computed(() => metadataStore.response);
    const layerExists = ref(false);
    const cache = reactive({});
    const handlers = reactive([]);
    const watchers = reactive([]);
    onMounted(() => {
      loadMetadata();
      handlers.push(
        iApi.event.on(GlobalEvents.LAYER_REMOVE, (removedLayer) => {
          if (props.payload.layer?.uid === removedLayer.uid) {
            props.panel.close();
          }
        })
      );
      watchers.push(
        watch(
          () => props.payload.layer.uid,
          (newUid, oldUid) => {
            if (newUid !== oldUid) {
              loadMetadata();
            }
          }
        )
      );
    });
    onBeforeUnmount(() => {
      handlers.forEach((handler) => iApi.event.off(handler));
      watchers.forEach((unwatch) => unwatch());
    });
    const loadMetadata = () => {
      layerExists.value = props.payload.layer !== void 0 && !props.payload.layer.isRemoved;
      if (props.payload.type === "xml") {
        loadFromURL(props.payload.url, []).then((r) => {
          metadataStore.status = "success";
          if (r !== null) {
            const textContainer = document.createElement("div");
            textContainer.appendChild(stringToFragment(`${r.firstElementChild.outerHTML}`));
            if (props.payload.catalogueUrl || props.payload.url) {
              textContainer.appendChild(
                stringToFragment(`<h5 class="text-xl font-bold mb-3">${t("metadata.xslt.metadata")}</h5>`)
              );
            }
            if (props.payload.catalogueUrl) {
              textContainer.appendChild(
                stringToFragment(
                  `<p><a style="color: blue;" href="${props.payload.catalogueUrl}" target="_blank">${t(
                    "metadata.xslt.cataloguePage"
                  )}</a></p>`
                )
              );
            }
            textContainer.appendChild(
              stringToFragment(
                `<p><a style="color: blue;" href="${props.payload.url}" target="_blank">${t(
                  "metadata.xslt.metadataPage"
                )}</a> (xml)</p>`
              )
            );
            metadataStore.response = textContainer.outerHTML;
          }
        });
      } else if (props.payload.type === "html") {
        requestContent(props.payload.url).then((r) => {
          metadataStore.status = r.status;
          metadataStore.response = r.response;
        });
      } else if (props.payload.type === "md") {
        requestContent(props.payload.url).then((r) => {
          metadataStore.status = r.status;
          metadataStore.response = marked(r.response);
        });
      }
    };
    const loadFromURL = (xmlUrl, params) => {
      let XSLT = iApi.language === "en" ? XSLT_en : XSLT_fr;
      XSLT = XSLT.replace(/\{\{([\w.]+)\}\}/g, (_, tag) => t(tag));
      if (!cache[xmlUrl]) {
        return requestContent(xmlUrl).then((xmlData) => {
          cache[xmlUrl] = xmlData.response;
          return applyXSLT(cache[xmlUrl], XSLT, params);
        });
      } else {
        return Promise.resolve(applyXSLT(cache[xmlUrl], XSLT, params));
      }
    };
    const applyXSLT = (xmlString, xslString, params) => {
      let output = null;
      if (window.XSLTProcessor) {
        const xsltProc = new window.XSLTProcessor();
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlString, "text/xml");
        const xslDoc = parser.parseFromString(xslString, "text/xml");
        xsltProc.importStylesheet(xslDoc);
        if (params) {
          params.forEach((p) => xsltProc.setParameter("", p.key, p.value || ""));
        }
        output = xsltProc.transformToFragment(xmlDoc, document);
      }
      return output;
    };
    const requestContent = (url) => {
      return new Promise((resolve) => {
        const xobj = new XMLHttpRequest();
        xobj.open("GET", url, true);
        xobj.responseType = "text";
        xobj.onload = () => {
          if (xobj.status === 200) {
            resolve({ status: "success", response: xobj.response });
          } else {
            resolve({
              status: "error",
              response: "Could not load results from remote service."
            });
          }
        };
        xobj.onerror = () => {
          resolve({
            status: "error",
            response: "Could not load results from remote service."
          });
        };
        xobj.send();
      });
    };
    function stringToFragment(string) {
      const temp = document.createElement("div");
      temp.innerHTML = string;
      return temp;
    }
    return (_ctx, _cache) => {
      const _component_panel_screen = resolveComponent("panel-screen");
      return openBlock(), createBlock(_component_panel_screen, {
        panel: __props.panel,
        ref_key: "el",
        ref: el
      }, {
        header: withCtx(() => [
          createTextVNode(toDisplayString(unref(t)("metadata.title")) + ": " + toDisplayString(__props.payload.layerName), 1)
        ]),
        content: withCtx(() => [
          layerExists.value ? (openBlock(), createElementBlock("div", _hoisted_1$v, [
            createElementVNode("div", _hoisted_2$n, [
              status.value == "loading" ? (openBlock(), createElementBlock("div", _hoisted_3$j, toDisplayString(unref(t)("metadata.loading")), 1)) : __props.payload.type === "xml" && status.value == "success" ? (openBlock(), createElementBlock("div", {
                key: 1,
                innerHTML: response.value,
                class: "flex flex-col justify-center xml-content"
              }, null, 8, _hoisted_4$b)) : (__props.payload.type === "html" || __props.payload.type === "md") && status.value == "success" ? (openBlock(), createElementBlock("div", {
                key: 2,
                innerHTML: response.value,
                class: "flex flex-col justify-center max-w-full metadata-view"
              }, null, 8, _hoisted_5$a)) : (openBlock(), createElementBlock("div", _hoisted_6$9, [
                _cache[0] || (_cache[0] = createElementVNode("img", { src: "https://i.imgur.com/fA5EqV6.png" }, null, -1)),
                createElementVNode("span", _hoisted_7$9, toDisplayString(unref(t)("metadata.error")), 1)
              ]))
            ])
          ])) : (openBlock(), createElementBlock("div", _hoisted_8$5, [
            createElementVNode("span", null, toDisplayString(unref(t)("metadata.label.no.layer")), 1)
          ]))
        ]),
        _: 1
      }, 8, ["panel"]);
    };
  }
});

const screen$4 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: _sfc_main$y
}, Symbol.toStringTag, { value: 'Module' }));

const messages$5 = {"en":{"metadata.title":"Metadata","metadata.loading":"Loading...","metadata.error":"There was an error retrieving this resource. Please try again.","metadata.label.no.layer":"No metadata to show because the layer has been removed","metadata.xslt.Abstract":"Abstract","metadata.xslt.Scope":"Scope","metadata.xslt.hereBeScope":"here be scope","metadata.xslt.timePeriod":"Time Period","metadata.xslt.supplementalData":"Supplemental Data","metadata.xslt.contactInfo":"Contact Information","metadata.xslt.resourceProvider":"Resource Provider","metadata.xslt.custodian":"Custodian","metadata.xslt.owner":"Owner","metadata.xslt.user":"User","metadata.xslt.distributor":"Distributor","metadata.xslt.originator":"Originator","metadata.xslt.pointOfContact":"Point of Contact","metadata.xslt.principalInvestigator":"Principal Investigator","metadata.xslt.processor":"Processor","metadata.xslt.publisher":"Publisher","metadata.xslt.author":"Author","metadata.xslt.collaborator":"Collaborator","metadata.xslt.editor":"Editor","metadata.xslt.mediator":"Mediator","metadata.xslt.rightsHolder":"Rights Holder","metadata.xslt.cataloguePage":"Data Catalogue Page","metadata.xslt.metadataPage":"Raw Metadata","metadata.xslt.metadata":"Metadata"},"fr":{"metadata.title":"Métadonnées","metadata.loading":"Chargement en cours...","metadata.error":"Une erreur s'est produite lors du chargement de cette ressource. Veuillez essayer de nouveau.","metadata.label.no.layer":"Aucune métadonnée à afficher","metadata.xslt.Abstract":"Résumé","metadata.xslt.Scope":"Portée","metadata.xslt.hereBeScope":"la portée jusqu'ici","metadata.xslt.timePeriod":"Période","metadata.xslt.supplementalData":"Données supplémentaires","metadata.xslt.contactInfo":"Coordonnées","metadata.xslt.resourceProvider":"Fournisseur de la ressource","metadata.xslt.custodian":"Dépositaire","metadata.xslt.owner":"Propriétaire","metadata.xslt.user":"Utilisateur","metadata.xslt.distributor":"Distributeur","metadata.xslt.originator":"Auteur","metadata.xslt.pointOfContact":"Point de contact","metadata.xslt.principalInvestigator":"Chercheur principal","metadata.xslt.processor":"Préparateur","metadata.xslt.publisher":"Éditeur","metadata.xslt.author":"Auteur","metadata.xslt.collaborator":"Collaborateur","metadata.xslt.editor":"Éditeur","metadata.xslt.mediator":"Médiateur","metadata.xslt.rightsHolder":"Titulaire des droits","metadata.xslt.cataloguePage":"Page des données du catalogue","metadata.xslt.metadataPage":"Métadonnées brutes","metadata.xslt.metadata":"Métadonnées"}};

class MetadataFixture extends MetadataAPI {
  async added() {
    this.$iApi.panel.register(
      {
        metadata: {
          screens: {
            "metadata-screen-content": markRaw(_sfc_main$y)
          },
          style: {
            width: "350px"
          },
          button: {
            tooltip: "metadata.title",
            // https://fonts.google.com/icons?selected=Material%20Icons%3Adescription
            icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none" /><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z" /></svg>'
          },
          alertName: "metadata.title"
        }
      },
      { i18n: { messages: messages$5 } }
    );
    this.handlePanelTeleports(["metadata"]);
    this.removed = () => {
      if (this.$iApi.fixture.exists("appbar")) {
        const appbarStore = useAppbarStore(this.$vApp.$pinia);
        appbarStore.removeButton("metadata");
      }
      const metadataStore = useMetadataStore(this.$vApp.$pinia);
      metadataStore.$reset();
      this.$iApi.panel.remove("metadata");
    };
  }
}

const index$7 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: MetadataFixture
}, Symbol.toStringTag, { value: 'Module' }));

class NortharrowAPI extends FixtureInstance {
  /**
   * Parses the north arrow config JSON snippet from the config file and save to the fixture store.
   *
   * @param {NortharrowConfig} [northarrowConfig]
   * @memberof NortharrowAPI
   */
  _parseConfig(northarrowConfig) {
    const northarrowStore = useNortharrowStore(this.$vApp.$pinia);
    if (!northarrowConfig) return;
    northarrowStore.arrowIcon = northarrowConfig.arrowIcon;
    northarrowStore.poleIcon = northarrowConfig.poleIcon;
  }
  get config() {
    return super.config;
  }
}

const style = "path";
const size = 12;
const path = "M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z";
const colour = "#ff0000ff";
const xOffset = 5;
const yOffset = 6;
const flag = {
	style: style,
	size: size,
	path: path,
	colour: colour,
	xOffset: xOffset,
	yOffset: yOffset
};

const _hoisted_1$u = ["innerHTML"];
const _sfc_main$x = /* @__PURE__ */ defineComponent({
  __name: "northarrow",
  setup(__props) {
    const configStore = useConfigStore();
    const northarrowStore = useNortharrowStore();
    const iApi = inject("iApi");
    const el = ref();
    const arrowIcon = computed(() => northarrowStore.arrowIcon);
    const poleIcon = computed(() => northarrowStore.poleIcon);
    const angle = ref(0);
    const arrowLeft = ref(0);
    const displayArrow = ref(false);
    const arrow = ref(`<svg xmlns="http://www.w3.org/2000/svg" fit=""  width="25" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24" focusable="false">
                <g id="northarrow" transform="translate(-285.24 -142.234)">
                    <path id="path3770-7" d="M305.91 156.648a8.652 8.652 0 0 1-8.654 8.653 8.652 8.652 0 0 1-8.653-8.653 8.653 8.653 0 0 1 8.653-8.653 8.653 8.653 0 0 1 8.653 8.653z" fill="#fff" stroke="#fff" stroke-width=".895"/>
                    <path id="path3770" d="M304.982 156.648a7.725 7.725 0 0 1-7.726 7.726 7.725 7.725 0 0 1-7.726-7.726 7.725 7.725 0 0 1 7.726-7.726 7.725 7.725 0 0 1 7.726 7.726z" fill="none" stroke="#6d6d6d" stroke-width=".799"/>
                    <path id="path3774" d="M297.256 156.648v-8.525" fill="none" stroke="#000" stroke-width=".067"/>
                    <path d="M297.258 143.48l8.793 22.432-8.811-8.812-8.812 8.812z" id="path3778" fill="#fff" stroke="#fff" stroke-width=".912"/>
                    <path d="M297.256 144.805l7.726 19.568-7.726-7.726-7.726 7.726z" id="path3780" fill="#d6d6d6" stroke="#000" stroke-width=".266" stroke-linecap="square"/>
                    <path id="path6038" d="M297.256 144.666l-7.726 19.568 7.726-7.726" fill="#6d6d6d" stroke-width=".296" stroke-linecap="square"/>
                </g>
            </svg>`);
    const poleMarkerAdded = ref(false);
    const handlers = reactive([]);
    const tileSchemas = ref([]);
    let basemap;
    onMounted(() => {
      const mapConfig = configStore.config.map;
      tileSchemas.value = mapConfig.tileSchemas;
      if (arrowIcon?.value) {
        arrow.value = `<img width='25' src='${arrowIcon.value}'>`;
      }
      if (iApi.geo.map.esriView?.ready) {
        updateNortharrow(iApi.geo.map.getExtent());
      }
      handlers.push(iApi.event.on(GlobalEvents.MAP_EXTENTCHANGE, debounce(300, updateNortharrow)));
    });
    onBeforeUnmount(() => {
      handlers.forEach((h) => iApi.event.off(h));
    });
    const updateNortharrow = async (newExtent) => {
      basemap = configStore.activeBasemapConfig;
      let hasNorthPole;
      for (const tile of tileSchemas.value) {
        if (basemap?.tileSchemaId === tile.id) {
          hasNorthPole = tile?.hasNorthPole;
          break;
        }
      }
      const innerShell = document.querySelector(".inner-shell");
      const arrowWidth = el.value.querySelector(".northarrow").getBoundingClientRect().width;
      const appbarWidth = document.querySelector(".appbar")?.clientWidth || 0;
      const sr = newExtent.sr;
      if (hasNorthPole || typeof hasNorthPole === "undefined" && !sr.isWebMercator()) {
        const pole = new Point("pole", { x: -96, y: 90 });
        const projPole = await iApi.geo.proj.projectGeometry(sr, pole);
        const poleScreenPos = iApi.geo.map.mapPointToScreenPoint(projPole);
        if (poleScreenPos.screenY < 0) {
          displayArrow.value = true;
          const bcScreenPos = {
            screenX: innerShell.clientWidth / 2,
            screenY: innerShell.clientHeight
          };
          angle.value = Math.atan(
            (poleScreenPos.screenX - bcScreenPos.screenX) / (bcScreenPos.screenY - poleScreenPos.screenY)
          ) * 180 / Math.PI;
          arrowLeft.value = innerShell.clientWidth / 2 + innerShell.clientHeight * Math.tan(angle.value * Math.PI / 180) - arrowWidth / 2;
          arrowLeft.value = Math.max(
            appbarWidth - arrowWidth / 2,
            Math.min(iApi.geo.map.getPixelWidth() - arrowWidth / 2, arrowLeft.value)
          );
        } else {
          displayArrow.value = false;
          if (!poleMarkerAdded.value) {
            poleMarkerAdded.value = true;
            let poleStyleParams;
            if (poleIcon.value) {
              poleStyleParams = {
                style: PointStyleType.ICON,
                icon: poleIcon.value,
                height: 16.5,
                width: 16.5
              };
            } else {
              poleStyleParams = flag;
            }
            const poleLayer = iApi.geo.layer.createLayer({
              id: POLE_MARKER_LAYER_ID,
              layerType: LayerType.GRAPHIC,
              url: "",
              cosmetic: true
              // mark this layer as a cosmetic layer
            });
            iApi.geo.map.addLayer(poleLayer);
            poleLayer.loadPromise().then(() => {
              const poleGraphic = new Graphic(projPole, "northpole");
              const poleStyle = new PointStyle(
                poleStyleParams
              );
              poleGraphic.style = poleStyle;
              poleLayer.addGraphic(poleGraphic);
            });
          }
        }
      } else {
        displayArrow.value = true;
        angle.value = 0;
        arrowLeft.value = appbarWidth + (innerShell.clientWidth - appbarWidth - arrowWidth) / 2;
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "absolute transition-all duration-300 ease-out",
        style: normalizeStyle({
          "transform-origin": `top center`,
          transform: `rotate(${angle.value}deg)`,
          left: `${arrowLeft.value}px`,
          visibility: displayArrow.value ? `visible` : `hidden`
        }),
        ref_key: "el",
        ref: el
      }, [
        createElementVNode("span", {
          class: "northarrow",
          innerHTML: arrow.value
        }, null, 8, _hoisted_1$u)
      ], 4);
    };
  }
});

const POLE_MARKER_LAYER_ID = "RampPoleMarker";
class NortharrowFixture extends NortharrowAPI {
  async added() {
    this._parseConfig(this.config);
    const unwatch = this.$vApp.$watch(
      () => this.config,
      (value) => this._parseConfig(value)
    );
    const { destroy, el } = this.mount(_sfc_main$x, {
      app: this.$element
    });
    const innerShell = this.$vApp.$el.getElementsByClassName("inner-shell")[0];
    innerShell.appendChild(el.childNodes[0]);
    this.removed = () => {
      unwatch();
      if (this.$iApi.geo.layer.getLayer(POLE_MARKER_LAYER_ID)) {
        this.$iApi.geo.map.removeLayer(POLE_MARKER_LAYER_ID);
      }
      const northarrowStore = useNortharrowStore(this.$vApp.$pinia);
      northarrowStore.$reset();
      destroy();
    };
  }
}

const index$6 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    POLE_MARKER_LAYER_ID,
    default: NortharrowFixture
}, Symbol.toStringTag, { value: 'Module' }));

class OverviewmapAPI extends FixtureInstance {
  /**
   * Parses the overview map config JSON snippet from the config file and save to the fixture store.
   *
   * @param {OverviewmapConfig} [OverviewmapConfig]
   * @memberof OverviewmapAPI
   */
  _parseConfig(overviewmapConfig) {
    const overviewmapStore = useOverviewmapStore(this.$vApp.$pinia);
    overviewmapStore.basemaps = overviewmapConfig?.basemaps || {};
    overviewmapStore.mapConfig.basemaps = overviewmapConfig ? Object.values(overviewmapConfig.basemaps) : [];
    overviewmapStore.startMinimized = overviewmapConfig?.startMinimized ?? true;
    overviewmapStore.expandFactor = overviewmapConfig?.expandFactor ?? 1.5;
    overviewmapStore.borderColour = overviewmapConfig?.borderColour ?? "#FF0000";
    overviewmapStore.borderWidth = overviewmapConfig?.borderWidth ?? 1;
    overviewmapStore.areaColour = overviewmapConfig?.areaColour ?? "#000000";
    overviewmapStore.areaOpacity = overviewmapConfig?.areaOpacity ?? 0.25;
  }
  get config() {
    return super.config;
  }
}

const _hoisted_1$t = { class: "relative h-full w-full overflow-hidden" };
const _hoisted_2$m = { class: "absolute h-30 w-30 top-0 right-0" };
const _hoisted_3$i = ["content", "aria-label"];
const _sfc_main$w = /* @__PURE__ */ defineComponent({
  __name: "overviewmap",
  setup(__props) {
    const overviewmapStore = useOverviewmapStore();
    const { t } = useI18n();
    const iApi = inject("iApi");
    const configStore = useConfigStore();
    const el = ref();
    const activeBasemap = computed(() => configStore.activeBasemapConfig);
    const mapConfig = computed(() => overviewmapStore.mapConfig);
    const basemaps = computed(() => overviewmapStore.basemaps);
    const startMinimized = computed(() => overviewmapStore.startMinimized);
    let overviewMap = reactive(new OverviewMapAPI(iApi));
    const minimized = ref(true);
    const hoverOnExtent = ref(false);
    const handlers = reactive([]);
    onMounted(() => {
      iApi.geo.map.viewPromise.then(async () => {
        _adaptBasemap();
        overviewMap.createMap(mapConfig.value, el.value.querySelector(".overviewmap"));
        await overviewMap.viewPromise;
        await overviewMap.addMapGraphicLayer();
        minimized.value = startMinimized.value;
        let updatePromise = overviewMap.updateOverview(iApi.geo.map.getExtent());
        handlers.push(
          iApi.event.on(
            GlobalEvents.MAP_EXTENTCHANGE,
            debounce(100, (newExtent) => {
              updatePromise.then(() => {
                overviewMap.updateOverview(newExtent);
              });
            })
          )
        );
        handlers.push(
          iApi.event.on(GlobalEvents.MAP_CREATED, () => {
            _adaptBasemap();
          })
        );
        handlers.push(
          iApi.event.on(GlobalEvents.MAP_REFRESH_END, () => {
            _adaptBasemap();
          })
        );
        handlers.push(
          iApi.event.on(GlobalEvents.MAP_BASEMAPCHANGE, async (payload) => {
            if (!payload.schemaChanged && overviewMap.created) {
              if (activeBasemap.value && basemaps.value[activeBasemap.value.tileSchemaId] === void 0) {
                await overviewMap.removeMapGraphicLayer();
                overviewMap.setBasemap(payload.basemapId);
                await overviewMap.addMapGraphicLayer();
              }
            }
          })
        );
      });
    });
    onBeforeUnmount(() => {
      handlers.forEach((handler) => iApi.event.off(handler));
      overviewMap.destroyMap();
    });
    const cursorHitTest = async (e) => {
      hoverOnExtent.value = !minimized.value && await overviewMap.cursorHitTest(e);
    };
    const mapStyle = () => {
      return {
        height: `${minimized.value ? 48 : 200}px`,
        width: `${minimized.value ? 48 : 200}px`
      };
    };
    const toggleStyle = () => {
      return {
        top: `${minimized.value ? -6 : -3}px`,
        right: `${minimized.value ? -6 : -3}px`,
        transform: `rotate(${minimized.value ? 225 : 45}deg)`
      };
    };
    const _adaptBasemap = () => {
      if (!activeBasemap.value) {
        console.error("Overview Map could not obtain the basemap config used by the main map");
        return;
      }
      try {
        const tileSchemaId = activeBasemap.value?.tileSchemaId;
        if (!tileSchemaId) {
          throw new Error("Overview Map could not obtain the tile schema of the main map");
        }
        const basemap = basemaps.value[tileSchemaId];
        if (!basemap) {
          throw new Error(
            "Overview Map could not find a suitable basemap that matches the tile schema of the main map"
          );
        }
        if (!overviewMap.created) {
          overviewmapStore.updateInitialBasemap(basemap.id);
        }
        if (overviewMap.created) {
          overviewMap.viewPromise.then(() => overviewMap.setBasemap(basemap.id));
        }
      } catch (err) {
        if (!overviewMap.created) {
          overviewmapStore.updateInitialBasemap(activeBasemap.value.id);
        }
        overviewMap.viewPromise.then(() => overviewMap.setBasemap(activeBasemap.value.id));
      }
    };
    return (_ctx, _cache) => {
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", {
        class: "relative",
        ref_key: "el",
        ref: el
      }, [
        createElementVNode("div", {
          style: normalizeStyle(mapStyle()),
          class: "pointer-events-auto absolute top-0 right-0 mt-12 mr-12 shadow-tm border-4 border-solid border-white bg-white transition-all duration-300 ease-out"
        }, [
          createElementVNode("div", _hoisted_1$t, [
            createElementVNode("div", {
              class: normalizeClass(["overviewmap absolute top-0 right-0 h-192 w-192", { "cursor-move": hoverOnExtent.value }]),
              onMousemove: cursorHitTest
            }, null, 34)
          ]),
          createElementVNode("div", _hoisted_2$m, [
            withDirectives((openBlock(), createElementBlock("button", {
              type: "button",
              tabindex: "0",
              class: "cursor-pointer absolute h-full w-full",
              onClick: _cache[0] || (_cache[0] = ($event) => minimized.value = !minimized.value),
              content: unref(t)(minimized.value ? "overviewmap.expand" : "overviewmap.minimize"),
              "aria-label": unref(t)(minimized.value ? "overviewmap.expand" : "overviewmap.minimize")
            }, [
              (openBlock(), createElementBlock("svg", {
                class: "absolute fill-current text-gray-500 transition-all duration-300 ease-out",
                style: normalizeStyle(toggleStyle()),
                xmlns: "http://www.w3.org/2000/svg",
                fit: "",
                height: "100%",
                width: "100%",
                preserveAspectRatio: "xMidYMid meet",
                viewBox: "0 0 24 24",
                focusable: "false"
              }, _cache[1] || (_cache[1] = [
                createElementVNode("g", { id: "apple-keyboard-control" }, [
                  createElementVNode("path", { d: "M 19.7782,11.7782L 18.364,13.1924L 12,6.82843L 5.63604,13.1924L 4.22183,11.7782L 12,4L 19.7782,11.7782 Z " })
                ], -1)
              ]), 4))
            ], 8, _hoisted_3$i)), [
              [_directive_tippy, { placement: "left", hideOnClick: false }]
            ])
          ])
        ], 4)
      ], 512);
    };
  }
});

const OverviewmapV = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["__scopeId", "data-v-461fd934"]]);

const messages$4 = {"en":{"overviewmap.expand":"Expand Overview","overviewmap.minimize":"Minimize Overview"},"fr":{"overviewmap.expand":"Développer l'aperçu","overviewmap.minimize":"Réduire l'aperçu"}};

class OverviewmapFixture extends OverviewmapAPI {
  added() {
    Object.entries(messages$4).forEach((value) => this.$iApi.$i18n.mergeLocaleMessage(...value));
    this._parseConfig(this.config);
    const unwatch = this.$vApp.$watch(
      () => this.config,
      (value) => this._parseConfig(value)
    );
    const { destroy, el } = this.mount(OverviewmapV, {
      app: this.$element
    });
    const innerShell = this.$vApp.$el.getElementsByClassName("inner-shell")[0];
    innerShell.appendChild(el.childNodes[0]);
    this.removed = () => {
      unwatch();
      destroy();
      const overviewmapStore = useOverviewmapStore(this.$vApp.$pinia);
      overviewmapStore.$reset();
    };
  }
}

const index$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: OverviewmapFixture
}, Symbol.toStringTag, { value: 'Module' }));

const messages$3 = {"en":{"panguard.instructions":"Use two fingers to pan the map"},"fr":{"panguard.instructions":"Utilisez deux doigts pour faire un panoramique de la carte"}};

const _hoisted_1$s = { class: "pg-label" };
const _sfc_main$v = /* @__PURE__ */ defineComponent({
  __name: "map-panguard",
  setup(__props) {
    const { t } = useI18n();
    const iApi = inject("iApi");
    const panGuard = ref();
    const timeoutID = ref(-1);
    const esriHandlers = reactive([]);
    const rampHanders = reactive([]);
    onMounted(() => {
      setup();
      rampHanders.push(
        iApi.event.on(GlobalEvents.MAP_CREATED, () => {
          setup();
        })
      );
      rampHanders.push(
        iApi.event.on(GlobalEvents.MAP_DESTROYED, () => {
          esriHandlers.forEach((h) => h.remove());
        })
      );
      rampHanders.push(
        iApi.event.on(GlobalEvents.MAP_REFRESH_START, () => {
          esriHandlers.forEach((h) => h.remove());
        })
      );
      rampHanders.push(
        iApi.event.on(GlobalEvents.MAP_REFRESH_END, () => {
          setup();
        })
      );
    });
    onBeforeUnmount(() => {
      rampHanders.forEach((h) => iApi.event.off(h));
      esriHandlers.forEach((h) => h.remove());
    });
    const setup = () => {
      const pointers = /* @__PURE__ */ new Map();
      iApi.geo.map.viewPromise.then(() => {
        esriHandlers.push(
          iApi.geo.map.esriView.on("pointer-down", (e) => {
            if (e.pointerType !== "touch") return;
            pointers.set(e.pointerId, { x: e.x, y: e.y });
          })
        );
        esriHandlers.push(
          //@ts-ignore
          iApi.geo.map.esriView.on(["pointer-up", "pointer-leave"], (e) => {
            if (e.pointerType !== "touch") return;
            window.setTimeout(() => {
              pointers.delete(e.pointerId);
            }, 200);
          })
        );
        esriHandlers.push(
          iApi.geo.map.esriView.on("pointer-move", (e) => {
            const { pointerId, pointerType, x, y } = e;
            const pointer = pointers.get(pointerId);
            if (!pointer || pointerType !== "touch" || pointers.size !== 1) {
              panGuard.value.classList.remove("pg-active");
              return;
            }
            const distance = Math.sqrt(Math.pow(x - pointer.x, 2) + Math.pow(y - pointer.y, 2));
            if (distance < 20) return;
            panGuard.value.classList.add("pg-active");
            if (timeoutID.value !== -1) {
              clearTimeout(timeoutID.value);
            }
            timeoutID.value = window.setTimeout(() => {
              panGuard.value.classList.remove("pg-active");
            }, 2e3);
            window.scrollBy(pointer.x - x, pointer.y - y);
          })
        );
      });
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "pg",
        ref_key: "panGuard",
        ref: panGuard
      }, [
        createElementVNode("p", _hoisted_1$s, toDisplayString(unref(t)("panguard.instructions")), 1)
      ], 512);
    };
  }
});

const PanguardV = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["__scopeId", "data-v-e91f9000"]]);

class PanguardFixture extends FixtureInstance {
  added() {
    Object.entries(messages$3).forEach((value) => this.$iApi.$i18n.mergeLocaleMessage(...value));
    const { destroy, el } = this.mount(PanguardV, {
      app: this.$element
    });
    const innerShell = this.$vApp.$el.getElementsByClassName("inner-shell")[0];
    innerShell.appendChild(el.childNodes[0]);
    this.removed = () => {
      destroy();
    };
  }
}

const index$4 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: PanguardFixture
}, Symbol.toStringTag, { value: 'Module' }));

const messages$2 = {"en":{"scrollguard.instructions":"Use ctrl + scroll to zoom the map"},"fr":{"scrollguard.instructions":"Utilisez les touches Ctrl et + pour faire un zoom de la carte"}};

const _hoisted_1$r = { class: "sg-label" };
const _sfc_main$u = /* @__PURE__ */ defineComponent({
  __name: "map-scrollguard",
  setup(__props) {
    const scrollguardStore = useScrollguardStore();
    const { t } = useI18n();
    const iApi = inject("iApi");
    const scrollGuard = ref();
    const enabled = computed(() => scrollguardStore.enabled);
    onMounted(() => {
      iApi.$vApp.$el.querySelector(".inner-shell + .esri-view")?.addEventListener(
        "wheel",
        wheelHandler,
        {
          capture: true
        }
      );
      iApi.event.on(GlobalEvents.MAP_CREATED, () => {
        iApi.$vApp.$el.querySelector(".inner-shell + .esri-view")?.addEventListener(
          "wheel",
          wheelHandler,
          {
            capture: true
          }
        );
      });
    });
    onBeforeUnmount(() => {
      iApi.$vApp.$el.querySelector(".inner-shell + .esri-view")?.removeEventListener(
        "wheel",
        wheelHandler,
        {
          capture: true
        }
      );
    });
    const wheelHandler = (event) => {
      if (!enabled.value) return;
      const scrollGuardClassList = scrollGuard.value.classList;
      if (!event.ctrlKey) {
        event.stopPropagation();
        scrollGuardClassList.remove("sg-scrolling");
        scrollGuardClassList.add("sg-active");
        window.setTimeout(() => scrollGuardClassList.remove("sg-active"), 2e3);
      } else {
        scrollGuardClassList.remove("sg-active");
        scrollGuardClassList.add("sg-scrolling");
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "sg",
        ref_key: "scrollGuard",
        ref: scrollGuard
      }, [
        createElementVNode("p", _hoisted_1$r, toDisplayString(unref(t)("scrollguard.instructions")), 1)
      ], 512);
    };
  }
});

const ScrollguardV = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["__scopeId", "data-v-bf6386a4"]]);

class ScrollguardAPI extends FixtureInstance {
  /**
   * Enables the scrollguard on the map if set to true.
   *
   * @param {boolean} value
   * @memberof ScrollguardAPI
   */
  setEnabled(value) {
    useScrollguardStore(this.$vApp.$pinia).enabled = value;
  }
  /**
   * Parses the scrollguard config JSON snippet from the config file and save to the fixture store.
   *
   * @param {ScrollguardConfig} [ScrollguardConfig]
   * @memberof ScrollguardAPI
   */
  _parseConfig(scrollguardConfig) {
    useScrollguardStore(this.$vApp.$pinia).enabled = scrollguardConfig?.enabled || false;
  }
  get config() {
    return super.config;
  }
}

class ScrollguardFixture extends ScrollguardAPI {
  added() {
    Object.entries(messages$2).forEach((value) => this.$iApi.$i18n.mergeLocaleMessage(...value));
    this._parseConfig(this.config);
    const unwatch = this.$vApp.$watch(
      () => this.config,
      (value) => this._parseConfig(value)
    );
    const { destroy, el } = this.mount(ScrollguardV, {
      app: this.$element
    });
    const innerShell = this.$vApp.$el.getElementsByClassName("inner-shell")[0];
    innerShell.appendChild(el.childNodes[0]);
    this.removed = () => {
      unwatch();
      destroy();
      const scrollguardStore = useScrollguardStore(this.$vApp.$pinia);
      scrollguardStore.$reset();
    };
  }
}

const index$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: ScrollguardFixture
}, Symbol.toStringTag, { value: 'Module' }));

class SettingsAPI extends FixtureInstance {
  /**
   * Opens the settings panel. Passes the provided LayerInstance object to the panel.
   *
   * @param {LayerInstance} layer controlled layer
   * @param {boolean} open force panel open or closed
   */
  toggleSettings(layer, open) {
    const panel = this.$iApi.panel.get("settings");
    if (!panel.isOpen && open !== false) {
      this.$iApi.panel.open({
        id: "settings",
        props: { layer }
      });
    } else {
      const currentUid = panel.route.props.layer.uid;
      if (open !== true) panel.close();
      if (currentUid !== layer.uid) {
        setTimeout(() => {
          this.$iApi.panel.open({
            id: "settings",
            props: { layer }
          });
        }, 100);
      }
    }
  }
}

const _hoisted_1$q = { class: "rv-label" };
const _hoisted_2$l = ["innerHTML"];
const _hoisted_3$h = { class: "flex flex-row pl-30" };
const _sfc_main$t = /* @__PURE__ */ defineComponent({
  __name: "slider-control",
  props: {
    name: String,
    icon: String,
    config: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const value = ref(props.config.value);
    const isDisabled = ref(!!props.config.disabled);
    const watchers = reactive([]);
    watchers.push(
      // watch the config for changes to the opacity value
      watch(
        () => props.config,
        (newConfig) => {
          value.value = newConfig.value;
          isDisabled.value = !!newConfig.disabled;
        },
        { deep: true }
      )
    );
    onBeforeUnmount(() => {
      watchers.forEach((unwatch) => unwatch());
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createElementVNode("div", _hoisted_1$q, [
          createElementVNode("div", {
            innerHTML: __props.icon,
            class: "p-8 pl-0"
          }, null, 8, _hoisted_2$l),
          createTextVNode(" " + toDisplayString(__props.name), 1)
        ]),
        createElementVNode("div", _hoisted_3$h, [
          createVNode(unref(VueSlider), {
            class: "mr-16",
            onChange: __props.config.onChange,
            modelValue: value.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => value.value = $event),
            disabled: isDisabled.value,
            width: 250,
            min: 0,
            max: 100
          }, null, 8, ["onChange", "modelValue", "disabled"]),
          createTextVNode(" " + toDisplayString(__props.config.value) + "% ", 1)
        ])
      ]);
    };
  }
});

const SliderControl = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["__scopeId", "data-v-9f0c5af5"]]);

const _hoisted_1$p = { class: "rv-label text-sm pt-10" };
const _hoisted_2$k = { class: "flex flex-row" };
const _hoisted_3$g = ["value", "disabled"];
const _hoisted_4$a = { class: "text-xs pt-10 text-gray-600 mb-20" };
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  __name: "input-control",
  props: {
    config: {
      type: Object,
      required: true
    },
    name: {
      type: String,
      required: true
    },
    icon: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    const { t } = useI18n();
    const props = __props;
    const isDisabled = ref(!!props.config.disabled);
    const watchers = reactive([]);
    watchers.push(
      // watch the config for changes to the opacity value
      watch(
        () => props.config,
        (newConfig) => {
          isDisabled.value = !!newConfig.disabled;
        },
        { deep: true }
      )
    );
    onBeforeUnmount(() => {
      watchers.forEach((unwatch) => unwatch());
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createElementVNode("div", _hoisted_1$p, toDisplayString(__props.name), 1),
        createElementVNode("div", _hoisted_2$k, [
          createElementVNode("input", {
            onKeypress: _cache[0] || (_cache[0] = withKeys(withModifiers(() => {
            }, ["prevent"]), ["enter"])),
            class: "rv-input text-md w-full",
            type: "number",
            value: unref(EsriConfig).value,
            disabled: isDisabled.value,
            min: "0",
            max: "100"
          }, null, 40, _hoisted_3$g)
        ]),
        createElementVNode("div", _hoisted_4$a, toDisplayString(unref(t)("settings.label.refreshOff")), 1)
      ]);
    };
  }
});

const InputControl = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["__scopeId", "data-v-86d3b932"]]);

const svgIcons = {
  visibility: '<svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 0 24 24" width="20"><path d="M0 0h24v24H0z" fill="none"/><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>',
  opacity: '<svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 0 24 24" width="20"><path d="M24 0H0v24h24V0zm0 0H0v24h24V0zM0 24h24V0H0v24z" fill="none"/><path d="M17.66 8L12 2.35 6.34 8C4.78 9.56 4 11.64 4 13.64s.78 4.11 2.34 5.67 3.61 2.35 5.66 2.35 4.1-.79 5.66-2.35S20 15.64 20 13.64 19.22 9.56 17.66 8zM6 14c.01-2 .62-3.27 1.76-4.4L12 5.27l4.24 4.38C17.38 10.77 17.99 12 18 14H6z"/></svg>',
  box: '<svg xmlns="http://www.w3.org/2000/svg" fit="" height="20" width="20" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24" focusable="false"><g id="cube-outline"><path d="M 21,16.5C 21,16.8812 20.7867,17.2125 20.473,17.3813L 12.5664,21.8243C 12.4054,21.9351 12.2103,22 12,22C 11.7897,22 11.5946,21.9351 11.4336,21.8243L 3.52716,17.3814C 3.21335,17.2127 3,16.8812 3,16.5L 3,7.5C 3,7.11876 3.21334,6.78735 3.52716,6.61864L 11.4336,2.17575C 11.5946,2.0649 11.7897,2.00001 12,2.00001C 12.2103,2.00001 12.4053,2.06489 12.5664,2.17574L 20.473,6.61872C 20.7867,6.78746 21,7.11883 21,7.5L 21,16.5 Z M 12.0009,4.15093L 6.04124,7.5L 12.0009,10.8491L 17.9591,7.5L 12.0009,4.15093 Z M 5,15.9149L 11,19.2866L 11,12.5806L 5,9.209L 5,15.9149 Z M 19,15.9149L 19,9.20901L 13,12.5806L 13,19.2875L 19,15.9149 Z "></path></g></svg>',
  location: '<svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 0 24 24" width="20"><path d="M0 0h24v24H0z" fill="none"/><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>',
  refresh: '<svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 0 24 24" width="20"><path d="M0 0h24v24H0z" fill="none"/><path d="M12 6v3l4-4-4-4v3c-4.42 0-8 3.58-8 8 0 1.57.46 3.03 1.24 4.26L6.7 14.8c-.45-.83-.7-1.79-.7-2.8 0-3.31 2.69-6 6-6zm6.76 1.74L17.3 9.2c.44.84.7 1.79.7 2.8 0 3.31-2.69 6-6 6v-3l-4 4 4 4v-3c4.42 0 8-3.58 8-8 0-1.57-.46-3.03-1.24-4.26z"/></svg>'
};

const _sfc_main$r = /* @__PURE__ */ defineComponent({
  __name: "component",
  props: {
    type: {
      type: String,
      required: true
    },
    config: {
      type: Object,
      required: true
    },
    name: {
      type: String,
      required: true
    },
    icon: {
      type: String,
      required: true
    },
    ariaLabel: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    const icons = reactive(svgIcons);
    const templates = reactive({
      slider: markRaw(SliderControl),
      toggle: markRaw(ToggleSwitchControl),
      input: markRaw(InputControl)
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(templates[__props.type]), {
        icon: icons[__props.icon],
        name: __props.name,
        config: __props.config,
        "aria-label": __props.ariaLabel
      }, null, 8, ["icon", "name", "config", "aria-label"]);
    };
  }
});

const _hoisted_1$o = { key: 0 };
const _hoisted_2$j = { class: "p-8 font-bold break-words mb-8 bg-gray-100" };
const _hoisted_3$f = { class: "flex flex-col justify-center" };
const _hoisted_4$9 = { class: "rv-subheader" };
const _hoisted_5$9 = { class: "flex flex-col justify-center" };
const _hoisted_6$8 = { class: "rv-subheader" };
const _hoisted_7$8 = {
  key: 1,
  class: "p-5"
};
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  __name: "screen",
  props: {
    panel: { type: Object, required: true },
    layer: { type: Object, required: true }
  },
  setup(__props) {
    const { t } = useI18n();
    const iApi = inject("iApi");
    const props = __props;
    const layerName = ref("");
    const uid = ref(props.layer.uid);
    const visibilityModel = ref(props.layer.visibility);
    const opacityModel = ref(props.layer.opacity * 100);
    const identifyModel = ref(props.layer.identify);
    const layerExists = ref(false);
    const handlers = reactive([]);
    const watchers = reactive([]);
    layerExists.value = props.layer !== void 0 && !props.layer.isRemoved;
    watchers.push(
      watch(
        () => props.layer.uid,
        (newUid, oldUid) => {
          if (newUid !== oldUid) {
            loadLayerProperties();
          }
        }
      )
    );
    onMounted(() => {
      loadLayerProperties();
      handlers.push(
        iApi.event.on(GlobalEvents.LAYER_VISIBILITYCHANGE, (newVisibility) => {
          if (uid.value === newVisibility.layer.uid) {
            visibilityModel.value = newVisibility.visibility;
          }
        })
      );
      handlers.push(
        iApi.event.on(GlobalEvents.LAYER_OPACITYCHANGE, (newOpacity) => {
          if (uid.value === newOpacity.layer.uid) {
            opacityModel.value = Math.round(newOpacity.opacity * 100);
          }
        })
      );
      handlers.push(
        iApi.event.on(GlobalEvents.LAYER_RELOAD_END, (reloadedLayer) => {
          reloadedLayer.loadPromise().then(() => {
            if (uid.value === reloadedLayer.uid) {
              loadLayerProperties();
            }
          });
        })
      );
      handlers.push(
        iApi.event.on(GlobalEvents.LAYER_REMOVE, (removedLayer) => {
          if (uid.value === removedLayer.uid) {
            props.panel.close();
          }
        })
      );
    });
    onBeforeUnmount(() => {
      handlers.forEach((handler) => iApi.event.off(handler));
      watchers.forEach((unwatch) => unwatch());
    });
    const controlAvailable = (control) => {
      const fixture = iApi.fixture.get("settings");
      if (!fixture || Object.keys(fixture).length === 0) {
        console.warn("Settings panel cannot check for layer control because it could not find settings fixture api");
        return false;
      }
      const settingsConfig = fixture?.getLayerFixtureConfig(props.layer.id);
      return settingsConfig && (settingsConfig.controls || settingsConfig.disabledControls) ? iApi.geo.shared.controlAvailable(control, settingsConfig) : props.layer.controlAvailable(control);
    };
    const updateVisibility = (val) => {
      props.layer.visibility = val;
      visibilityModel.value = val;
    };
    const updateOpacity = (val) => {
      props.layer.opacity = val / 100;
      opacityModel.value = val;
    };
    const updateIdentify = (val) => {
      props.layer.identify = val;
      identifyModel.value = val;
    };
    const loadLayerProperties = () => {
      layerExists.value = props.layer !== void 0 && !props.layer.isRemoved;
      const oldUid = props.layer.uid;
      props.layer.loadPromise().then(() => {
        if (oldUid === props.layer.uid) {
          visibilityModel.value = props.layer.visibility;
          opacityModel.value = Math.round(props.layer.opacity * 100);
          identifyModel.value = props.layer.identify;
          layerName.value = props.layer.name;
        }
      });
    };
    return (_ctx, _cache) => {
      const _component_panel_screen = resolveComponent("panel-screen");
      return openBlock(), createBlock(_component_panel_screen, { panel: __props.panel }, {
        header: withCtx(() => [
          createTextVNode(toDisplayString(unref(t)("settings.title")), 1)
        ]),
        content: withCtx(() => [
          layerExists.value ? (openBlock(), createElementBlock("div", _hoisted_1$o, [
            createElementVNode("div", _hoisted_2$j, toDisplayString(layerName.value), 1),
            createElementVNode("div", _hoisted_3$f, [
              createElementVNode("span", _hoisted_4$9, toDisplayString(unref(t)("settings.label.display")), 1),
              _cache[0] || (_cache[0] = createElementVNode("div", { class: "rv-settings-divider" }, null, -1)),
              createVNode(_sfc_main$r, {
                class: "rv-subsection",
                type: "toggle",
                icon: "visibility",
                onToggled: updateVisibility,
                name: unref(t)("settings.label.visibility"),
                config: {
                  value: visibilityModel.value,
                  disabled: !controlAvailable(unref(LayerControl).Visibility)
                },
                ariaLabel: unref(t)("settings.label.visibility")
              }, null, 8, ["name", "config", "ariaLabel"]),
              _cache[1] || (_cache[1] = createElementVNode("div", { class: "rv-settings-divider" }, null, -1)),
              createVNode(_sfc_main$r, {
                class: "rv-subsection",
                type: "slider",
                name: unref(t)("settings.label.opacity"),
                icon: "opacity",
                config: {
                  onChange: updateOpacity,
                  value: opacityModel.value,
                  disabled: !controlAvailable(unref(LayerControl).Opacity)
                },
                ariaLabel: unref(t)("settings.label.opacity")
              }, null, 8, ["name", "config", "ariaLabel"]),
              _cache[2] || (_cache[2] = createElementVNode("div", { class: "rv-settings-divider" }, null, -1))
            ]),
            createElementVNode("div", _hoisted_5$9, [
              createElementVNode("span", _hoisted_6$8, toDisplayString(unref(t)("settings.label.data")), 1),
              _cache[3] || (_cache[3] = createElementVNode("div", { class: "rv-settings-divider" }, null, -1)),
              createVNode(_sfc_main$r, {
                class: "rv-subsection",
                type: "toggle",
                name: unref(t)("settings.label.identify"),
                icon: "location",
                onToggled: updateIdentify,
                config: {
                  value: identifyModel.value,
                  disabled: !(controlAvailable(unref(LayerControl).Identify) && props.layer.supportsIdentify)
                },
                ariaLabel: unref(t)("settings.label.identify")
              }, null, 8, ["name", "config", "ariaLabel"]),
              _cache[4] || (_cache[4] = createElementVNode("div", { class: "rv-settings-divider" }, null, -1))
            ])
          ])) : (openBlock(), createElementBlock("div", _hoisted_7$8, [
            createElementVNode("span", null, toDisplayString(unref(t)("settings.label.no.layer")), 1)
          ]))
        ]),
        _: 1
      }, 8, ["panel"]);
    };
  }
});

const SettingsScreenV = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["__scopeId", "data-v-72efbdd5"]]);

const screen$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: SettingsScreenV
}, Symbol.toStringTag, { value: 'Module' }));

const messages$1 = {"en":{"settings.title":"Settings","settings.layer.loading":"The layer is loading...","settings.label.display":"Display","settings.label.visibility":"Show layer","settings.label.opacity":"Opacity","settings.label.boundingBox":"Bounding box","settings.label.data":"Data","settings.label.identify":"Toggle identify","settings.label.interval":"Refresh interval","settings.label.refreshHint":"Refresh interval in minutes","settings.label.refreshOff":" Leave blank or 0 to turn off automatic refresh","settings.label.no.layer":"The layer has been removed"},"fr":{"settings.title":"Paramètres","settings.layer.loading":"La couche est en cours de chargement...","settings.label.display":"Affichage","settings.label.visibility":"Afficher la couche","settings.label.opacity":"Opacité","settings.label.boundingBox":"Zone de délimitation","settings.label.data":"Données","settings.label.identify":"Basculer vers la désignation","settings.label.interval":"Intervalle d'actualisation","settings.label.refreshHint":"Intervalle d'actualisation en minutes","settings.label.refreshOff":"Laisser le champ vide ou y inscrire 0 pour désactiver l'actualisation automatique","settings.label.no.layer":"La couche a été supprimée."}};

class SettingsFixture extends SettingsAPI {
  async added() {
    this.$iApi.panel.register(
      {
        settings: {
          screens: {
            "settings-screen-content": markRaw(SettingsScreenV)
          },
          style: {
            width: "350px"
          },
          button: {
            tooltip: "settings.title",
            // https://fonts.google.com/icons?selected=Material%20Icons%3Asettings
            icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M0,0h24v24H0V0z" fill="none" /><path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z" /></g></svg>'
          },
          alertName: "settings.title"
        }
      },
      { i18n: { messages: messages$1 } }
    );
    this.handlePanelTeleports(["settings"]);
  }
  removed() {
    if (this.$iApi.fixture.exists("appbar")) {
      const appbarStore = useAppbarStore(this.$vApp.$pinia);
      appbarStore.removeButton("settings");
    }
    this.$iApi.panel.remove("settings");
  }
}

const index$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: SettingsFixture
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$n = ["src"];
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "snowman",
  props: {
    fixture: {
      type: FixtureInstance,
      required: true
    },
    message: String
  },
  setup(__props) {
    const props = __props;
    const el = ref();
    const url = ref("https://i.imgur.com/p13yknD.png");
    onMounted(() => {
      setTimeout(() => {
        el.value.parentNode.removeChild(el.value);
        props.fixture.remove();
      }, 6e3);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "absolute top-0 right-0",
        ref_key: "el",
        ref: el
      }, [
        createElementVNode("img", {
          style: { "width": "250px" },
          src: url.value,
          alt: "Snowman",
          srcset: ""
        }, null, 8, _hoisted_1$n)
      ], 512);
    };
  }
});

const _sfc_main$o = /* @__PURE__ */ defineComponent({
  __name: "appbar-button",
  setup(__props) {
    const iApi = inject("iApi");
    const togglePanel = () => {
      iApi.fixture.add("snowman");
    };
    return (_ctx, _cache) => {
      const _component_appbar_button = resolveComponent("appbar-button", true);
      return openBlock(), createBlock(_component_appbar_button, {
        onClickFunction: togglePanel,
        tooltip: "⛄"
      }, {
        default: withCtx(() => _cache[0] || (_cache[0] = [
          createElementVNode("span", { class: "block h-24" }, "⛄", -1)
        ])),
        _: 1
      });
    };
  }
});

class SnowmanFixture extends FixtureInstance {
  added() {
    this.$iApi.component("snowman-appbar-button", _sfc_main$o);
    const { el } = this.mount(_sfc_main$p, {
      app: this.$element,
      props: { message: "This is a snowman prop.", fixture: this }
    });
    this.$vApp.$el.appendChild(el.childNodes[0]);
  }
  removed() {
  }
}

const index$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: SnowmanFixture
}, Symbol.toStringTag, { value: 'Module' }));

class WizardAPI extends FixtureInstance {
  /**
   * Opens or closes the wizard fixture panel
   *
   * @memberof WizardAPI
   * @param open force panel open or closed
   */
  toggleWizard(open) {
    const panel = this.$iApi.panel.get("wizard");
    this.$iApi.panel.toggle(panel, open);
  }
}

const _hoisted_1$m = { class: "flex justify-end mb-20" };
const _hoisted_2$i = ["disabled", "animation"];
const _hoisted_3$e = { class: "button-text" };
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  __name: "form-footer",
  props: {
    animation: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: true
    }
  },
  setup(__props) {
    const { t } = useI18n();
    const props = __props;
    const submitButton = ref();
    watch(toRef(props, "disabled"), (disabled) => {
      if (!disabled && submitButton.value.classList.contains("button--loading")) {
        submitButton.value.classList.remove("button--loading");
      }
    });
    const loadButton = () => {
      if (props.animation) submitButton.value.classList.toggle("button--loading");
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$m, [
        createElementVNode("button", {
          class: "hover:bg-gray-200 text-gray-600 font-bold py-8 px-16 m-2",
          type: "button",
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("cancel"))
        }, toDisplayString(unref(t)("wizard.step.cancel")), 1),
        createElementVNode("button", {
          class: "button bg-blue-700 hover:bg-blue-700 text-white font-bold py-8 px-16 m-2 disabled:bg-gray-200 disabled:cursor-default disabled:text-gray-400",
          ref_key: "submitButton",
          ref: submitButton,
          type: "button",
          disabled: __props.disabled,
          animation: __props.animation,
          onClick: _cache[1] || (_cache[1] = ($event) => {
            _ctx.$emit("submit");
            loadButton();
          })
        }, [
          createElementVNode("span", _hoisted_3$e, toDisplayString(unref(t)("wizard.step.continue")), 1)
        ], 8, _hoisted_2$i)
      ]);
    };
  }
});

const WizardFormFooter = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["__scopeId", "data-v-5e77d8d6"]]);

const _hoisted_1$l = { key: 0 };
const _hoisted_2$h = { class: "text-base font-bold" };
const _hoisted_3$d = {
  class: "relative py-8 mb-0.5 h-75",
  "data-type": "file"
};
const _hoisted_4$8 = ["aria-label"];
const _hoisted_5$8 = { class: "text-gray-500 text-xs mb-1" };
const _hoisted_6$7 = { key: 1 };
const _hoisted_7$7 = { class: "text-base font-bold" };
const _hoisted_8$4 = {
  class: "mb-0.5",
  "data-type": "url"
};
const _hoisted_9$3 = ["value", "aria-label"];
const _hoisted_10$2 = {
  key: 0,
  class: "text-red-900 text-xs"
};
const _hoisted_11$2 = { key: 2 };
const _hoisted_12$2 = { class: "text-base font-bold" };
const _hoisted_13$2 = {
  class: "relative mb-0.5",
  "data-type": "select"
};
const _hoisted_14$2 = { key: 0 };
const _hoisted_15$2 = {
  key: 0,
  class: "text-red-900 text-xs"
};
const _hoisted_16$2 = { key: 1 };
const _hoisted_17$2 = ["size", "value", "aria-label"];
const _hoisted_18$2 = ["value"];
const _hoisted_19$2 = {
  key: 0,
  class: "text-red-900 text-xs"
};
const _hoisted_20$2 = {
  key: 1,
  class: "text-red-900 text-xs"
};
const _hoisted_21$2 = { key: 3 };
const _hoisted_22$2 = ["aria-label"];
const _hoisted_23$2 = { class: "text-base font-bold" };
const _hoisted_24$2 = { key: 4 };
const _hoisted_25$2 = { class: "text-base font-bold" };
const _hoisted_26$2 = { class: "relative mb-0.5" };
const _hoisted_27$2 = ["value", "aria-label"];
const _hoisted_28$2 = {
  key: 0,
  class: "text-red-900 text-xs"
};
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  __name: "form-input",
  props: {
    defaultOption: {
      type: Boolean,
      default: false
    },
    formatError: {
      type: Boolean,
      default: false
    },
    failureError: {
      type: Boolean,
      default: false
    },
    help: {
      type: [String, Boolean],
      default: false
    },
    label: {
      type: [String, Boolean],
      default: false
    },
    modelValue: {
      type: [String, Array],
      default: ""
    },
    name: {
      type: [String, Boolean],
      default: false
    },
    options: {
      type: Array,
      default() {
        return [];
      }
    },
    selectedValues: {
      type: Array,
      default: () => []
    },
    size: {
      type: [Number, String],
      default: 0
    },
    sublayerOptions: {
      type: Function,
      default() {
        return [];
      }
    },
    multiple: {
      type: Boolean,
      default: false
    },
    searchable: {
      type: Boolean,
      default: false
    },
    type: {
      type: String,
      default: "text"
    },
    url: {
      type: [String, Boolean],
      default: false
    },
    validation: {
      type: Boolean,
      default: false
    },
    validationMessages: {
      type: Object
    },
    ariaLabel: {
      type: String,
      default: false
    }
  },
  emits: ["update:modelValue", "link", "select", "upload", "text", "nested"],
  setup(__props, { emit: __emit }) {
    const iApi = inject("iApi");
    const { t } = useI18n();
    const emit = __emit;
    const props = __props;
    const el = ref();
    const valid = ref(false);
    const urlError = ref(false);
    const nameError = ref(false);
    const sublayersError = ref(false);
    const selected = ref([...props.selectedValues]);
    const valueLabel = ref("value-label");
    const optionLabel = ref("option-label");
    const resizeObserver = ref(void 0);
    const treeWrapper = ref(null);
    const watchers = reactive([]);
    if (props.defaultOption && props.modelValue === "" && props.options.length) {
      let defaultValue = props.options[0].value;
      if (props.name === "latField") {
        const latNames = new RegExp(/^(y|lat.*)$/i);
        const latCandidate = props.options.find((option) => latNames.test(option.label));
        defaultValue = latCandidate?.value || defaultValue;
      } else if (props.name === "longField") {
        const longNames = new RegExp(/^(x|long.*)$/i);
        const longCandidate = props.options.find((option) => longNames.test(option.label));
        defaultValue = longCandidate?.value || defaultValue;
      }
      emit("update:modelValue", defaultValue);
    }
    const validName = (name) => {
      if (name.trim() !== "") valid.value = true;
      else {
        valid.value = false;
        iApi.updateAlert(t("wizard.configure.name.error.required"));
      }
    };
    const validUrl = (url) => {
      let newUrl;
      try {
        newUrl = new URL(url);
      } catch (_) {
        valid.value = false;
        return false;
      }
      const link = newUrl.protocol === "http:" || newUrl.protocol === "https:";
      link ? valid.value = true : valid.value = false;
    };
    const handleUpload = (event) => {
      emit("upload", event.target.files[0]);
      event.target.value = "";
    };
    const handleUrlInput = (event) => {
      validUrl(event.target.value);
      emit("link", event.target.value, valid);
      urlError.value = false;
    };
    const handleServiceSelection = (size, event) => {
      size ? emit("select", event.target.value) : emit("update:modelValue", event.target.value);
    };
    const handleNestedChecked = (event) => {
      emit("nested", event.target.checked);
    };
    const handleNameInput = (event) => {
      validName(event.target.value);
      emit("link", event.target.value, valid);
      nameError.value = false;
    };
    const handleSelection = () => {
      emit("select", props.sublayerOptions(selected.value));
      selected.value && selected.value.length > 0 ? sublayersError.value = false : sublayersError.value = true;
    };
    const truncateVal = (selected2) => {
      if (selected2.length > 5) {
        return `${selected2.slice(0, 5)}...`;
      }
      return selected2;
    };
    function observeHeight() {
      resizeObserver.value = new ResizeObserver(function() {
        setHeight();
      });
      resizeObserver.value.observe(iApi.$vApp.$el.querySelector(".vue-treeselect__control"));
      resizeObserver.value.observe(iApi.$vApp.$el.querySelector(".vue-treeselect__menu"));
    }
    const setHeight = () => {
      const menuHeight = iApi.$vApp.$el.querySelector(".vue-treeselect__menu")?.clientHeight;
      const selectHeight = iApi.$vApp.$el.querySelector(".vue-treeselect__control")?.clientHeight;
      el.value.style.height = `${menuHeight + selectHeight + 30}px`;
    };
    watchers.push(
      watch(treeWrapper, (newValue) => {
        if (newValue) {
          addAriaLabel();
        }
      })
    );
    const addAriaLabel = () => {
      if (treeWrapper.value) {
        const input = treeWrapper.value.querySelector('input[type="text"]');
        if (input) {
          input.setAttribute("aria-label", t("wizard.configure.sublayers.select"));
        }
      }
    };
    onBeforeUnmount(() => {
      resizeObserver.value.disconnect();
      watchers.forEach((unwatch) => unwatch());
    });
    return (_ctx, _cache) => {
      const _directive_truncate = resolveDirective("truncate");
      return openBlock(), createElementBlock("div", {
        class: "input-wrapper mb-12",
        ref_key: "el",
        ref: el
      }, [
        __props.type === "file" ? (openBlock(), createElementBlock("div", _hoisted_1$l, [
          createElementVNode("label", _hoisted_2$h, toDisplayString(__props.label), 1),
          createElementVNode("div", _hoisted_3$d, [
            createElementVNode("input", {
              class: "absolute w-full opacity-0 inset-0 cursor-pointer",
              type: "file",
              name: "file",
              accept: ".geojson,.json,.csv,.zip",
              "aria-label": props.ariaLabel,
              onInput: _cache[0] || (_cache[0] = (event) => {
                handleUpload(event);
              })
            }, null, 40, _hoisted_4$8),
            _cache[11] || (_cache[11] = createElementVNode("div", { class: "upload-mask absolute inset-0 flex border-dashed border-2 border-gray-400 pointer-events-none justify-center" }, [
              createElementVNode("svg", {
                class: "w-30 h-30 m-auto",
                fill: "#a8a8a8",
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 58 58"
              }, [
                createElementVNode("path", { d: "M29,58A29,29,0,1,0,0,29,29,29,0,0,0,29,58ZM29,4A25,25,0,1,1,4,29,25,25,0,0,1,29,4Z" }),
                createElementVNode("polygon", { points: "27 22 27 44.4 31 44.4 31 22 41.7 31.1 44.3 28.1 29 15 13.7 28.1 16.3 31.1 27 22" })
              ])
            ], -1))
          ]),
          createElementVNode("div", _hoisted_5$8, toDisplayString(__props.help), 1)
        ])) : __props.type === "url" ? (openBlock(), createElementBlock("div", _hoisted_6$7, [
          createElementVNode("label", _hoisted_7$7, toDisplayString(__props.label), 1),
          createElementVNode("div", _hoisted_8$4, [
            createElementVNode("input", {
              class: "text-sm w-full border-solid border-gray-300 mb-5 focus:border-green-500",
              type: "url",
              name: "url",
              value: __props.modelValue,
              "aria-label": props.ariaLabel,
              onChange: _cache[1] || (_cache[1] = ($event) => valid.value ? urlError.value = false : urlError.value = true),
              onInput: _cache[2] || (_cache[2] = (event) => {
                handleUrlInput(event);
              })
            }, null, 40, _hoisted_9$3)
          ]),
          urlError.value ? (openBlock(), createElementBlock("div", _hoisted_10$2, toDisplayString(__props.modelValue ? __props.validationMessages?.invalid : __props.validationMessages?.required), 1)) : createCommentVNode("", true)
        ])) : __props.type === "select" ? (openBlock(), createElementBlock("div", _hoisted_11$2, [
          createElementVNode("label", _hoisted_12$2, toDisplayString(__props.label), 1),
          createElementVNode("div", _hoisted_13$2, [
            __props.multiple ? (openBlock(), createElementBlock("div", _hoisted_14$2, [
              createElementVNode("div", {
                ref_key: "treeWrapper",
                ref: treeWrapper
              }, [
                createVNode(unref(Treeselect), {
                  modelValue: selected.value,
                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => selected.value = $event),
                  multiple: true,
                  options: __props.options,
                  "default-expand-level": 1,
                  "always-open": true,
                  "open-direction": "bottom",
                  "max-height": 300,
                  limit: 4,
                  disableFuzzyMatching: true,
                  searchable: __props.searchable,
                  childrenIgnoreDisabled: true,
                  placeholder: unref(t)("wizard.configure.sublayers.select"),
                  noResultsText: unref(t)("wizard.configure.sublayers.results"),
                  clearAllText: unref(t)("wizard.configure.sublayers.clearAll"),
                  onSelect: _cache[4] || (_cache[4] = ($event) => {
                    _ctx.$nextTick(() => {
                      handleSelection();
                    });
                  }),
                  onDeselect: _cache[5] || (_cache[5] = ($event) => {
                    _ctx.$nextTick(() => {
                      handleSelection();
                    });
                  }),
                  onOpen: _cache[6] || (_cache[6] = ($event) => {
                    _ctx.$nextTick(() => {
                      observeHeight();
                    });
                  })
                }, {
                  [valueLabel.value]: withCtx(({ node }) => [
                    createElementVNode("label", null, toDisplayString(truncateVal(node.label)), 1)
                  ]),
                  [optionLabel.value]: withCtx(({ node, labelClassName }) => [
                    withDirectives((openBlock(), createElementBlock("label", {
                      class: normalizeClass(labelClassName)
                    }, [
                      createTextVNode(toDisplayString(node.label), 1)
                    ], 2)), [
                      [_directive_truncate, {
                        options: {
                          placement: "top",
                          hideOnClick: false,
                          theme: "ramp4",
                          animation: "scale"
                        }
                      }]
                    ])
                  ]),
                  _: 2
                }, 1032, ["modelValue", "options", "searchable", "placeholder", "noResultsText", "clearAllText"])
              ], 512),
              __props.validation && sublayersError.value ? (openBlock(), createElementBlock("div", _hoisted_15$2, toDisplayString(__props.validationMessages?.required), 1)) : createCommentVNode("", true)
            ])) : (openBlock(), createElementBlock("div", _hoisted_16$2, [
              createElementVNode("select", {
                class: normalizeClass(["block border-solid border-gray-300 w-full p-3 overflow-y-auto", __props.size && "configure-select"]),
                size: __props.size,
                value: __props.modelValue,
                onInput: _cache[7] || (_cache[7] = ($event) => handleServiceSelection(__props.size, $event)),
                "aria-label": props.ariaLabel
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(__props.options, (option) => {
                  return openBlock(), createElementBlock("option", {
                    class: "p-6",
                    key: option.label,
                    value: option.value
                  }, toDisplayString(option.label), 9, _hoisted_18$2);
                }), 128))
              ], 42, _hoisted_17$2),
              __props.validation && __props.formatError ? (openBlock(), createElementBlock("div", _hoisted_19$2, toDisplayString(__props.validationMessages?.invalid), 1)) : createCommentVNode("", true),
              __props.validation && __props.failureError ? (openBlock(), createElementBlock("div", _hoisted_20$2, toDisplayString(__props.validationMessages?.failure), 1)) : createCommentVNode("", true)
            ]))
          ])
        ])) : __props.type === "checkbox" ? (openBlock(), createElementBlock("div", _hoisted_21$2, [
          createElementVNode("input", {
            class: "text-sm border-solid border-gray-300 mb-5 focus:border-green-500 mr-10",
            type: "checkbox",
            name: "nested",
            checked: true,
            "aria-label": props.ariaLabel,
            onChange: _cache[8] || (_cache[8] = (event) => {
              handleNestedChecked(event);
            })
          }, null, 40, _hoisted_22$2),
          createElementVNode("label", _hoisted_23$2, toDisplayString(__props.label), 1)
        ])) : (openBlock(), createElementBlock("div", _hoisted_24$2, [
          createElementVNode("label", _hoisted_25$2, toDisplayString(__props.label), 1),
          createElementVNode("div", _hoisted_26$2, [
            createElementVNode("input", {
              class: normalizeClass(["border-solid border-gray-300 p-3 w-full", { "error-border": !valid.value && !__props.modelValue }]),
              type: "text",
              value: __props.modelValue,
              "aria-label": props.ariaLabel,
              onChange: _cache[9] || (_cache[9] = ($event) => valid.value ? nameError.value = false : nameError.value = true),
              onInput: _cache[10] || (_cache[10] = (event) => {
                handleNameInput(event);
              })
            }, null, 42, _hoisted_27$2)
          ]),
          __props.validation && !__props.modelValue ? (openBlock(), createElementBlock("div", _hoisted_28$2, toDisplayString(__props.validationMessages?.required), 1)) : createCommentVNode("", true)
        ]))
      ], 512);
    };
  }
});

const WizardInput = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__scopeId", "data-v-be5c9863"]]);

const _hoisted_1$k = { class: "step relative flex flex-col px-12" };
const _hoisted_2$g = { class: "stepper-header flex pb-24" };
const _hoisted_3$c = {
  key: 1,
  class: "flex-none stepper-check w-24 h-24 text-gray-400"
};
const _hoisted_4$7 = { class: "flex flex-col overflow-hidden" };
const _hoisted_5$7 = { class: "pl-12 flex items-center text-md" };
const _hoisted_6$6 = { class: "pl-12 text-xs transition-opacity duration-1000 ease-out" };
const _hoisted_7$6 = { class: "pl-36" };
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  __name: "stepper-item",
  props: {
    title: {
      type: String,
      required: true
    },
    summary: {
      type: String
    }
  },
  setup(__props) {
    const stepper = inject("stepper");
    const index = ref(-1);
    onMounted(() => {
      index.value = stepper.numSteps++;
    });
    const done = () => {
      return stepper.activeIndex > index.value;
    };
    const active = () => {
      return stepper.activeIndex === index.value;
    };
    return (_ctx, _cache) => {
      const _directive_truncate = resolveDirective("truncate");
      return openBlock(), createElementBlock("div", _hoisted_1$k, [
        createElementVNode("div", _hoisted_2$g, [
          !done() ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(["w-24 h-24 bg-gray-500 rounded-full flex justify-center items-center text-white text-xs font-semibold", { "bg-blue-500": active }])
          }, toDisplayString(index.value + 1), 3)) : (openBlock(), createElementBlock("div", _hoisted_3$c, _cache[0] || (_cache[0] = [
            createElementVNode("svg", {
              xmlns: "http://www.w3.org/2000/svg",
              height: "100%",
              width: "100%",
              preserveAspectRatio: "xMidYMid meet",
              viewBox: "0 0 24 24",
              focusable: "false"
            }, [
              createElementVNode("g", { id: "check_circle" }, [
                createElementVNode("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z" })
              ])
            ], -1)
          ]))),
          createElementVNode("div", _hoisted_4$7, [
            createElementVNode("div", _hoisted_5$7, toDisplayString(__props.title), 1),
            withDirectives((openBlock(), createElementBlock("div", _hoisted_6$6, [
              createTextVNode(toDisplayString(__props.summary), 1)
            ])), [
              [vShow, !active()],
              [_directive_truncate]
            ])
          ])
        ]),
        createVNode(Transition, {
          name: "step",
          mode: "out-in"
        }, {
          default: withCtx(() => [
            withDirectives(createElementVNode("div", _hoisted_7$6, [
              renderSlot(_ctx.$slots, "default", {}, void 0, true)
            ], 512), [
              [vShow, active()]
            ])
          ]),
          _: 3
        })
      ]);
    };
  }
});

const StepperItem = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__scopeId", "data-v-686fab2c"]]);

const _hoisted_1$j = { class: "py-12 h-auto stepper" };
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  __name: "stepper",
  props: {
    activeStep: {
      type: Number,
      default: 0
    }
  },
  setup(__props) {
    const props = __props;
    const step = computed(() => props.activeStep);
    const watchers = reactive([]);
    const stepper = reactive({
      activeIndex: props.activeStep,
      numSteps: 0
    });
    provide("stepper", stepper);
    watchers.push(
      watch(step, () => {
        stepper.activeIndex = props.activeStep;
      })
    );
    onBeforeUnmount(() => {
      watchers.forEach((unwatch) => unwatch());
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$j, [
        renderSlot(_ctx.$slots, "default")
      ]);
    };
  }
});

const _hoisted_1$i = {
  key: 0,
  class: "inline-flex items-center mb-10"
};
const _hoisted_2$f = { class: "px-5 text-xs" };
const _hoisted_3$b = { key: 5 };
const _hoisted_4$6 = ["for"];
const _hoisted_5$6 = {
  key: 6,
  class: "text-base font-bold"
};
const _hoisted_6$5 = { class: "sr-only" };
const _hoisted_7$5 = { class: "sr-only" };
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "screen",
  props: {
    panel: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const wizardStore = useWizardStore();
    const { t } = useI18n();
    const iApi = inject("iApi");
    const formElement = ref();
    const handlers = ref([]);
    const layerSource = computed(() => wizardStore.layerSource);
    const step = computed(() => wizardStore.currStep);
    const colour = ref();
    const colourPickerId = ref();
    const componentKey = ref(0);
    const disabled = ref(false);
    const formatError = ref(false);
    const failureError = ref(false);
    const goNext = ref(false);
    const finishStep = ref(false);
    const validation = ref(false);
    const layerReady = ref(false);
    const layerUploaded = ref(true);
    const layerName = ref("");
    const displayFormat = ref("");
    const selectedValues = ref([]);
    const serviceTypeOptions = reactive([
      {
        value: LayerType.FEATURE,
        label: t("wizard.layerType.esriFeature")
      },
      {
        value: LayerType.MAPIMAGE,
        label: t("wizard.layerType.esriMapImage")
      },
      {
        value: LayerType.TILE,
        label: t("wizard.layerType.esriTile")
      },
      {
        value: LayerType.IMAGERY,
        label: t("wizard.layerType.esriImagery")
      },
      {
        value: LayerType.WMS,
        label: t("wizard.layerType.ogcWms")
      },
      {
        value: LayerType.WFS,
        label: t("wizard.layerType.ogcWfs")
      }
    ]);
    const fileTypeOptions = reactive([
      {
        value: LayerType.GEOJSON,
        label: t("wizard.fileType.geojson")
      },
      {
        value: LayerType.SHAPEFILE,
        label: t("wizard.fileType.shapefile")
      },
      { value: LayerType.CSV, label: t("wizard.fileType.csv") }
    ]);
    const url = computed({
      get() {
        return wizardStore.url;
      },
      set(newValue) {
        wizardStore.url = newValue;
      }
    });
    const fileData = computed({
      get() {
        return wizardStore.fileData;
      },
      set(newValue) {
        wizardStore.fileData = newValue;
      }
    });
    const typeSelection = computed({
      get() {
        return wizardStore.typeSelection;
      },
      set(newValue) {
        wizardStore.typeSelection = newValue;
      }
    });
    const layerInfo = computed({
      get() {
        return wizardStore.layerInfo;
      },
      set(newValue) {
        wizardStore.layerInfo = newValue;
      }
    });
    const IsCorsRequired = computed(() => {
      let hasProxy = iApi.geo.proxy !== "";
      switch (typeSelection.value) {
        case LayerType.FEATURE:
        case LayerType.MAPIMAGE:
        case LayerType.TILE:
        case LayerType.IMAGERY:
          return !hasProxy;
        case LayerType.WFS:
          return true;
        case LayerType.WMS:
          return !hasProxy;
        case LayerType.GEOJSON:
        case LayerType.SHAPEFILE:
        case LayerType.CSV:
          if (isFileLayer() && !fileData.value) {
            return true;
          } else {
            return false;
          }
        default:
          return false;
      }
    });
    onErrorCaptured(() => {
      if (step.value === WizardStep.FORMAT || step.value === WizardStep.CONFIGURE) {
        formatError.value = true;
        wizardStore.goToStep(WizardStep.FORMAT);
      }
      return false;
    });
    onMounted(() => {
      handlers.value.push(
        iApi.event.on(GlobalEvents.LAYER_LAYERSTATECHANGE, (payload) => {
          if (payload.layer.userAdded) {
            layerName.value = payload.layer.name;
            layerReady.value = payload.state !== LayerState.LOADING && payload.state !== LayerState.NEW;
            layerUploaded.value = layerReady.value && payload.state === LayerState.LOADED;
          }
        })
      );
      if (step.value === WizardStep.CONFIGURE) {
        if (layerInfo.value?.configOptions.includes("colour")) {
          generateColour();
        }
        finishStep.value = !layerInfo.value?.configOptions.includes(`sublayers`) && !!layerInfo.value?.config.name;
      }
    });
    onBeforeUnmount(() => {
      handlers.value.forEach((handler) => iApi.event.off(handler));
    });
    const uploadFile = async (file) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        fileData.value = reader.result;
        url.value = file.name;
        onUploadContinue(e);
      };
      reader.readAsArrayBuffer(file);
    };
    const onUploadContinue = (event) => {
      event?.preventDefault();
      typeSelection.value = layerSource.value.guessFormatFromURL(url.value);
      wizardStore.goToStep(WizardStep.FORMAT);
    };
    const onSelectContinue = async (event) => {
      event?.preventDefault();
      disabled.value = true;
      failureError.value = false;
      validation.value = true;
      displayFormat.value = isFileLayer() ? fileTypeOptions.find((element) => element.value === typeSelection.value)?.label : serviceTypeOptions.find((element) => element.value === typeSelection.value)?.label;
      try {
        layerInfo.value = isFileLayer() ? await layerSource.value.fetchFileInfo(url.value, typeSelection.value, fileData.value) : await layerSource.value.fetchServiceInfo(
          url.value,
          typeSelection.value,
          wizardStore.nested
        );
        if (isFileLayer() && fileData.value) {
          layerInfo.value.config.url = "";
        }
      } catch (_) {
        disabled.value = false;
        failureError.value = true;
        return;
      }
      const featureError = typeSelection.value === LayerType.FEATURE && !(layerInfo.value && layerInfo.value.fields);
      if (!layerInfo.value || featureError) {
        formatError.value = true;
        layerInfo.value = {
          config: {
            id: "Placeholder",
            layerType: LayerType.UNKNOWN,
            url: ""
          },
          configOptions: []
        };
        disabled.value = false;
        return;
      }
      generateColour();
      wizardStore.goToStep(WizardStep.CONFIGURE);
      finishStep.value = !(layerInfo.value.configOptions.includes("sublayers") || !layerInfo.value.config.name);
      disabled.value = false;
      validation.value = false;
    };
    const onConfigureContinue = async (data) => {
      data?.preventDefault();
      const config = Object.assign(layerInfo.value.config, data);
      selectedValues.value = [];
      displayFormat.value = "";
      const layer = iApi.geo.layer.createLayer(config);
      iApi.geo.map.addLayer(layer).catch(() => {
      });
      layer.userAdded = true;
      iApi.event.emit(GlobalEvents.USER_LAYER_ADDED, layer);
      goNext.value = false;
      wizardStore.goToStep(WizardStep.UPLOAD);
    };
    const fieldOptions = () => {
      return layerInfo.value?.fields.map((field) => {
        return {
          value: field.name,
          label: field.alias || field.name
        };
      });
    };
    const latLonOptions = (fieldName) => {
      return layerInfo.value?.latLonFields[fieldName].map((field) => {
        return {
          value: field,
          label: field
        };
      });
    };
    const isFileLayer = () => {
      return fileData.value || url.value.match(/\.(zip|csv|json|geojson)$/);
    };
    const updateFile = (newFile) => {
      uploadFile(newFile);
      url.value = "";
    };
    const updateUrl = (urlVal, valid) => {
      url.value = urlVal.trim();
      valid ? goNext.value = true : goNext.value = false;
    };
    const updateTypeSelection = (type) => {
      typeSelection.value = type;
      formatError.value = false;
    };
    const updateLayerName = (name) => {
      layerInfo.value.config.name = name.trim();
      const sublayers = layerInfo.value?.config.sublayers;
      const canFinish = sublayers ? name && sublayers.length > 0 : name.trim();
      canFinish ? finishStep.value = true : finishStep.value = false;
    };
    const updateSublayers = (sublayer) => {
      layerInfo.value.config.sublayers = sublayer;
      sublayer.length > 0 && layerInfo.value?.config.name ? finishStep.value = true : finishStep.value = false;
    };
    const updateNested = (isNested) => {
      wizardStore.nested = isNested;
      selectedValues.value = [];
      componentKey.value += 1;
      if (typeSelection.value === LayerType.MAPIMAGE) {
        layerInfo.value.layers = layerSource.value.createLayerHierarchy(
          layerInfo.value.layersRaw,
          wizardStore.nested
        );
        const previouslySelected = new Set(
          (layerInfo.value?.config?.sublayers ?? []).map((sl) => sl.index)
        );
        if (wizardStore.nested) populateNested(layerInfo, previouslySelected);
        else populateFlat(layerInfo, previouslySelected);
      } else if (typeSelection.value === LayerType.WMS) {
        layerInfo.value.layers = layerSource.value.mapWmsLayerList(
          layerInfo.value.layersRaw,
          wizardStore.nested
        );
        const previouslySelected = new Set((layerInfo.value?.config?.sublayers ?? []).map((sl) => sl.id));
        if (wizardStore.nested) populateNestedWMS(layerInfo, previouslySelected);
        else populateFlatWMS(layerInfo, previouslySelected);
      }
      updateSublayers(sublayerOptions(selectedValues.value));
    };
    const populateNested = (layerInfo2, previouslySelected) => {
      const parentChildMap = /* @__PURE__ */ new Map();
      for (const rawLayer of layerInfo2.value.layersRaw) {
        if (rawLayer.parentLayerId !== -1) {
          const children = parentChildMap.get(rawLayer.parentLayerId) || [];
          children.push(rawLayer.id);
          parentChildMap.set(rawLayer.parentLayerId, children);
        }
      }
      const allChildrenSelected = (parentId) => {
        const children = parentChildMap.get(parentId);
        if (!children) return false;
        return children.every((childId) => {
          if (parentChildMap.has(childId)) return allChildrenSelected(childId);
          return previouslySelected.has(childId);
        });
      };
      const addSelectedValues = (parentId) => {
        if (!allChildrenSelected(parentId)) {
          const children = parentChildMap.get(parentId);
          if (children) {
            for (const child of children) {
              if (previouslySelected.has(child)) {
                selectedValues.value.push(child);
              }
            }
          }
        } else selectedValues.value.push(parentId);
      };
      for (const parentId of parentChildMap.keys()) addSelectedValues(parentId);
      for (const rawLayer of layerInfo2.value.layersRaw) {
        if (rawLayer.parentLayerId === -1 && !parentChildMap.has(rawLayer.id) && previouslySelected.has(rawLayer.id)) {
          selectedValues.value.push(rawLayer.id);
        }
      }
      selectedValues.value = Array.from(new Set(selectedValues.value));
    };
    const populateNestedWMS = (layerInfo2, previouslySelected) => {
      const allDescendantsSelected = (layer) => {
        if (!layer.layers || layer.layers.length === 0) return previouslySelected.has(layer.name);
        return layer.layers.every((child) => allDescendantsSelected(child));
      };
      const addSelectedLayerNames = (layer) => {
        if (allDescendantsSelected(layer)) selectedValues.value.push(layer.name);
        else if (layer.layers) layer.layers.forEach(addSelectedLayerNames);
      };
      const topLayer = layerInfo2.value.layersRaw[0];
      if (topLayer && topLayer.layers) {
        topLayer.layers.forEach((parentLayer) => addSelectedLayerNames(parentLayer));
      }
      selectedValues.value = Array.from(new Set(selectedValues.value));
    };
    const populateFlat = (layerInfo2, previouslySelected) => {
      const lowestChildren = (parentId) => {
        const children = layerInfo2.value.layersRaw.filter((rl) => rl.parentLayerId === parentId);
        if (children.length > 0) {
          for (const child of children) {
            if (previouslySelected.has(child.id)) selectedValues.value.push(child.id);
            else lowestChildren(child.id);
          }
        } else selectedValues.value.push(parentId);
      };
      for (const rawLayer of layerInfo2.value.layersRaw)
        if (previouslySelected.has(rawLayer.id)) lowestChildren(rawLayer.id);
      selectedValues.value = Array.from(new Set(selectedValues.value));
    };
    const populateFlatWMS = (layerInfo2, previouslySelected) => {
      const addLeafLayers = (layer) => {
        if (layer.layers && layer.layers.length > 0) layer.layers.forEach(addLeafLayers);
        else selectedValues.value.push(layer.name);
      };
      const topLayer = layerInfo2.value.layersRaw[0];
      for (const prev of previouslySelected) {
        const parentLayer = topLayer.layers.find((layer) => layer.name === prev);
        if (parentLayer && parentLayer.layers && parentLayer.layers.length > 0) addLeafLayers(parentLayer);
        else if (parentLayer) selectedValues.value.push(parentLayer.name);
      }
      selectedValues.value = Array.from(new Set(selectedValues.value));
    };
    const sublayerOptions = (layers) => {
      return layers.map((layerIdx) => {
        switch (typeSelection.value) {
          case LayerType.MAPIMAGE:
            return {
              index: layerIdx,
              state: { opacity: 1, visibility: true }
            };
          case LayerType.WMS: {
            const removeHash = layerIdx.lastIndexOf("#");
            return { id: layerIdx.substring(0, removeHash) };
          }
          default:
            return {
              id: layerIdx
            };
        }
      });
    };
    const generateColour = () => {
      colour.value = layerInfo.value?.config.colour ?? "#" + Math.floor(Math.random() * 16777215).toString(16).padStart(6, "0");
      do {
        colourPickerId.value = Math.random().toString(36).substring(2, 9);
      } while (document.getElementById(colourPickerId.value + "-hue-slider") !== null);
    };
    const updateColour = (eventData) => {
      layerInfo.value.config.colour = eventData.colors.hex.substring(0, 7);
      nextTick(() => {
        formElement.value.querySelector(".vacp-copy-button").style.backgroundColor = layerInfo.value?.config.colour;
      });
    };
    const cancelServiceStep = () => {
      goNext.value = false;
      wizardStore.goToStep(0);
    };
    const cancelNameStep = () => {
      selectedValues.value = [];
      finishStep.value = false;
      wizardStore.goToStep(1);
    };
    return (_ctx, _cache) => {
      const _component_panel_screen = resolveComponent("panel-screen");
      return openBlock(), createBlock(_component_panel_screen, { panel: __props.panel }, {
        header: withCtx(() => [
          createTextVNode(toDisplayString(unref(t)("wizard.title")), 1)
        ]),
        content: withCtx(() => [
          createVNode(_sfc_main$k, { activeStep: step.value }, {
            default: withCtx(() => [
              createVNode(StepperItem, {
                title: unref(t)("wizard.upload.title"),
                summary: url.value
              }, {
                default: withCtx(() => [
                  createElementVNode("form", {
                    name: "upload",
                    onSubmit: onUploadContinue,
                    onClick: _cache[1] || (_cache[1] = ($event) => layerReady.value = false)
                  }, [
                    createVNode(WizardInput, {
                      type: "file",
                      name: "file",
                      label: unref(t)("wizard.upload.file.label"),
                      help: unref(t)("wizard.upload.file.help"),
                      onUpload: updateFile,
                      "aria-label": unref(t)("wizard.upload.file.label")
                    }, null, 8, ["label", "help", "aria-label"]),
                    _cache[12] || (_cache[12] = createElementVNode("span", { class: "block text-center mb-10" }, "or", -1)),
                    createVNode(WizardInput, {
                      type: "url",
                      name: "url",
                      modelValue: url.value,
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => url.value = $event),
                      label: unref(t)("wizard.upload.url.label"),
                      onLink: updateUrl,
                      validation: true,
                      "validation-messages": {
                        required: unref(t)("wizard.upload.url.error.required"),
                        invalid: unref(t)("wizard.upload.url.error.url")
                      },
                      "aria-label": unref(t)("wizard.upload.url.label")
                    }, null, 8, ["modelValue", "label", "validation-messages", "aria-label"]),
                    createVNode(WizardFormFooter, {
                      onSubmit: onUploadContinue,
                      onCancel: cancelServiceStep,
                      disabled: !goNext.value
                    }, null, 8, ["disabled"])
                  ], 32)
                ]),
                _: 1
              }, 8, ["title", "summary"]),
              createVNode(StepperItem, {
                title: unref(t)("wizard.format.title"),
                summary: displayFormat.value
              }, {
                default: withCtx(() => [
                  createElementVNode("form", {
                    name: "format",
                    onSubmit: onSelectContinue
                  }, [
                    IsCorsRequired.value ? (openBlock(), createElementBlock("div", _hoisted_1$i, [
                      _cache[13] || (_cache[13] = createElementVNode("svg", {
                        class: "inline-block fill-current w-16 h-16",
                        xmlns: "http://www.w3.org/2000/svg",
                        viewBox: "0 0 24 24"
                      }, [
                        createElementVNode("path", {
                          d: "M0 0h24v24H0z",
                          fill: "none"
                        }),
                        createElementVNode("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z" })
                      ], -1)),
                      createElementVNode("span", _hoisted_2$f, toDisplayString(unref(t)("wizard.format.info.cors")), 1)
                    ])) : createCommentVNode("", true),
                    createVNode(WizardInput, {
                      type: "select",
                      name: "type",
                      modelValue: typeSelection.value,
                      "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => typeSelection.value = $event),
                      onSelect: updateTypeSelection,
                      size: isFileLayer() ? fileTypeOptions.length : serviceTypeOptions.length,
                      label: isFileLayer() ? unref(t)("wizard.format.type.file") : unref(t)("wizard.format.type.service"),
                      options: isFileLayer() ? fileTypeOptions : serviceTypeOptions,
                      formatError: formatError.value,
                      failureError: failureError.value,
                      validation: validation.value,
                      "validation-messages": {
                        required: unref(t)("wizard.format.type.error.required"),
                        invalid: unref(t)("wizard.format.type.error.invalid"),
                        failure: `${unref(t)("wizard.format.type.error.failure")}.${IsCorsRequired.value ? " " + unref(t)("wizard.format.warn.cors") + "." : ""}${" " + unref(t)("wizard.format.warn.vpn") + "."}`
                      },
                      onKeydown: _cache[3] || (_cache[3] = withModifiers(() => {
                      }, ["stop"])),
                      "aria-label": unref(t)("wizard.format.type.service")
                    }, null, 8, ["modelValue", "size", "label", "options", "formatError", "failureError", "validation", "validation-messages", "aria-label"]),
                    createVNode(WizardFormFooter, {
                      onSubmit: onSelectContinue,
                      onCancel: _cache[4] || (_cache[4] = () => {
                        disabled.value = false;
                        formatError.value = false;
                        failureError.value = false;
                        url.value ? goNext.value = true : goNext.value = false;
                        validation.value = false;
                        unref(wizardStore).goToStep(0);
                        displayFormat.value = "";
                      }),
                      animation: true,
                      disabled: disabled.value
                    }, null, 8, ["disabled"])
                  ], 32)
                ]),
                _: 1
              }, 8, ["title", "summary"]),
              createVNode(StepperItem, {
                title: unref(t)("wizard.configure.title")
              }, {
                default: withCtx(() => [
                  createElementVNode("form", {
                    name: "configure",
                    onSubmit: onConfigureContinue,
                    ref_key: "formElement",
                    ref: formElement
                  }, [
                    layerInfo.value?.configOptions.includes(`name`) ? (openBlock(), createBlock(WizardInput, {
                      key: 0,
                      type: "text",
                      name: "name",
                      modelValue: layerInfo.value.config.name,
                      "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => layerInfo.value.config.name = $event),
                      onLink: updateLayerName,
                      label: unref(t)("wizard.configure.name.label"),
                      "aria-label": unref(t)("wizard.configure.name.label"),
                      validation: true,
                      "validation-messages": {
                        required: unref(t)("wizard.configure.name.error.required")
                      }
                    }, null, 8, ["modelValue", "label", "aria-label", "validation-messages"])) : createCommentVNode("", true),
                    layerInfo.value?.configOptions.includes(`nameField`) ? (openBlock(), createBlock(WizardInput, {
                      key: 1,
                      type: "select",
                      name: "nameField",
                      modelValue: layerInfo.value.config.nameField,
                      "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => layerInfo.value.config.nameField = $event),
                      label: unref(t)("wizard.configure.nameField.label"),
                      "aria-label": unref(t)("wizard.configure.nameField.label"),
                      defaultOption: true,
                      options: fieldOptions()
                    }, null, 8, ["modelValue", "label", "aria-label", "options"])) : createCommentVNode("", true),
                    layerInfo.value?.configOptions.includes(`tooltipField`) ? (openBlock(), createBlock(WizardInput, {
                      key: 2,
                      type: "select",
                      name: "tooltipField",
                      modelValue: layerInfo.value.config.tooltipField,
                      "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => layerInfo.value.config.tooltipField = $event),
                      label: unref(t)("wizard.configure.tooltipField.label"),
                      "aria-label": unref(t)("wizard.configure.tooltipField.label"),
                      options: fieldOptions()
                    }, null, 8, ["modelValue", "label", "aria-label", "options"])) : createCommentVNode("", true),
                    layerInfo.value?.configOptions.includes(`latField`) ? (openBlock(), createBlock(WizardInput, {
                      key: 3,
                      type: "select",
                      name: "latField",
                      modelValue: layerInfo.value.config.latField,
                      "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => layerInfo.value.config.latField = $event),
                      defaultOption: true,
                      label: unref(t)("wizard.configure.latField.label"),
                      "aria-label": unref(t)("wizard.configure.latField.label"),
                      options: latLonOptions("lat")
                    }, null, 8, ["modelValue", "label", "aria-label", "options"])) : createCommentVNode("", true),
                    layerInfo.value?.configOptions.includes(`longField`) ? (openBlock(), createBlock(WizardInput, {
                      key: 4,
                      type: "select",
                      name: "longField",
                      modelValue: layerInfo.value.config.longField,
                      "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => layerInfo.value.config.longField = $event),
                      defaultOption: true,
                      label: unref(t)("wizard.configure.longField.label"),
                      "aria-label": unref(t)("wizard.configure.longField.label"),
                      options: latLonOptions("lon")
                    }, null, 8, ["modelValue", "label", "aria-label", "options"])) : createCommentVNode("", true),
                    layerInfo.value?.configOptions.includes(`sublayers`) ? (openBlock(), createElementBlock("div", _hoisted_3$b, [
                      createVNode(WizardInput, {
                        type: "checkbox",
                        name: "nested",
                        onNested: updateNested,
                        label: unref(t)("wizard.configure.sublayers.nested"),
                        "aria-label": unref(t)("wizard.configure.sublayers.nested")
                      }, null, 8, ["label", "aria-label"]),
                      (openBlock(), createBlock(WizardInput, {
                        type: "select",
                        key: componentKey.value,
                        name: "sublayers",
                        modelValue: layerInfo.value.config.sublayers,
                        "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => layerInfo.value.config.sublayers = $event),
                        onSelect: updateSublayers,
                        label: unref(t)("wizard.configure.sublayers.label"),
                        "aria-label": unref(t)("wizard.configure.sublayers.label"),
                        options: layerInfo.value.layers,
                        selectedValues: selectedValues.value,
                        sublayerOptions,
                        multiple: true,
                        searchable: true,
                        validation: true,
                        "validation-messages": {
                          required: unref(t)("wizard.configure.sublayers.error.required")
                        },
                        onKeydown: _cache[11] || (_cache[11] = withModifiers(() => {
                        }, ["stop"]))
                      }, null, 8, ["modelValue", "label", "aria-label", "options", "selectedValues", "validation-messages"]))
                    ])) : createCommentVNode("", true),
                    createElementVNode("label", {
                      class: "sr-only",
                      for: `${colourPickerId.value}-color-hex`
                    }, toDisplayString(unref(t)("wizard.configure.colour.hex")), 9, _hoisted_4$6),
                    layerInfo.value?.configOptions.includes("colour") ? (openBlock(), createElementBlock("label", _hoisted_5$6, toDisplayString(unref(t)("wizard.configure.colour.label")), 1)) : createCommentVNode("", true),
                    layerInfo.value?.configOptions.includes("colour") ? (openBlock(), createBlock(unref(ColorPicker), {
                      key: 7,
                      "alpha-channel": "hide",
                      "visible-formats": ["hex"],
                      "default-format": "hex",
                      id: colourPickerId.value,
                      color: colour.value,
                      onColorChange: updateColour
                    }, {
                      "hue-range-input-label": withCtx(() => [
                        createElementVNode("span", _hoisted_6$5, toDisplayString(unref(t)("wizard.configure.colour.hue")), 1)
                      ]),
                      "copy-button": withCtx(() => [
                        createElementVNode("span", _hoisted_7$5, toDisplayString(unref(t)("wizard.configure.colour.copy")), 1),
                        _cache[14] || (_cache[14] = createElementVNode("svg", {
                          "aria-hidden": "true",
                          xmlns: "http://www.w3.org/2000/svg",
                          width: "15",
                          height: "15",
                          viewBox: "0 0 15 15"
                        }, [
                          createElementVNode("path", {
                            d: "M5 0v2H1v13h12v-3h-1v2H2V5h10v3h1V2H9V0zm1 1h2v2h3v1H3V3h3z",
                            fill: "currentColor"
                          }),
                          createElementVNode("path", {
                            d: "M10 7v2h5v2h-5v2l-3-3zM3 6h5v1H3zm0 2h3v1H3zm0 2h3v1H3zm0 2h5v1H3z",
                            fill: "currentColor"
                          })
                        ], -1))
                      ]),
                      _: 1
                    }, 8, ["id", "color"])) : createCommentVNode("", true),
                    createVNode(WizardFormFooter, {
                      onSubmit: onConfigureContinue,
                      onCancel: cancelNameStep,
                      disabled: !finishStep.value
                    }, null, 8, ["disabled"])
                  ], 544)
                ]),
                _: 1
              }, 8, ["title"])
            ]),
            _: 1
          }, 8, ["activeStep"]),
          layerReady.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(["p-3 border-solid border-2", layerUploaded.value ? "bg-green-100 !border-green-900" : "bg-red-100 !border-red-900"])
          }, toDisplayString(layerName.value) + " " + toDisplayString(unref(t)(`wizard.upload.${layerUploaded.value ? "success" : "fail"}`)), 3)) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["panel"]);
    };
  }
});

const WizardScreenV = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__scopeId", "data-v-085c20bf"]]);

const screen$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: WizardScreenV
}, Symbol.toStringTag, { value: 'Module' }));

class LayerSource extends APIScope {
  layerCount = 0;
  sublayerCount = 0;
  constructor($iApi) {
    super($iApi);
  }
  /**
   * Get layer info from a file url or data
   *
   * @param {string} url a service url to load, name of file if file data is provided
   * @param {string} fileType format of the file (layer type)
   * @param {ArrayBuffer} [fileData] raw file data buffer
   * @returns {Promise<LayerInfo | undefined>} LayerInfo object
   */
  async fetchFileInfo(url, fileType, fileData) {
    if (!fileData) {
      fileData = await this.$iApi.geo.layer.files.fetchFileData(url, fileType);
    }
    switch (fileType) {
      case LayerType.GEOJSON:
        return this.getGeojsonInfo(url, fileData);
      case LayerType.SHAPEFILE:
        return this.getShapfileInfo(url, fileData);
      case LayerType.CSV:
        return this.getCsvInfo(url, fileData);
      default:
        console.error(`Unsupported file type passed to fetchFileInfo - '${fileType}'`);
    }
  }
  async getGeojsonInfo(url, fileData) {
    if (fileData instanceof ArrayBuffer) {
      fileData = JSON.parse(new TextDecoder("utf-8").decode(new Uint8Array(fileData)));
    }
    const config = {
      id: `geojson#${++this.layerCount}`,
      layerType: LayerType.GEOJSON,
      url,
      name: url.substring(url.lastIndexOf("/") + 1),
      state: { opacity: 1, visibility: true },
      rawData: fileData
    };
    return {
      config,
      fields: [{ name: "OBJECTID", type: "oid" }].concat(
        this.$iApi.geo.layer.files.extractGeoJsonFields(fileData)
      ),
      configOptions: ["name", "nameField", "tooltipField", "colour"]
    };
  }
  async getCsvInfo(url, fileData) {
    if (fileData instanceof ArrayBuffer) {
      fileData = new TextDecoder("utf-8").decode(new Uint8Array(fileData));
    }
    const config = {
      id: `csv#${++this.layerCount}`,
      layerType: LayerType.CSV,
      url,
      name: url.substring(url.lastIndexOf("/") + 1),
      state: { opacity: 1, visibility: true },
      rawData: fileData
    };
    return {
      config,
      fields: [{ name: "OBJECTID", type: "oid" }].concat(this.$iApi.geo.layer.files.extractCsvFields(fileData)),
      latLonFields: this.$iApi.geo.layer.files.filterCsvLatLonFields(fileData),
      configOptions: ["name", "nameField", "tooltipField", "latField", "longField", "colour"]
    };
  }
  async getShapfileInfo(url, fileData) {
    const jsonData = await this.$iApi.geo.layer.files.shapefileToGeoJson(fileData);
    return this.getGeojsonInfo(url, jsonData);
  }
  /**
   * Get layer info from a service url
   *
   * @param {string} url a service url to load
   * @param {string} serviceType type of layer
   * @returns {Promise<LayerInfo | undefined>} LayerInfo object
   */
  async fetchServiceInfo(url, serviceType, nested) {
    switch (serviceType) {
      case LayerType.FEATURE:
        return this.getFeatureInfo(url);
      case LayerType.MAPIMAGE:
        return this.getMapImageInfo(url, nested);
      case LayerType.TILE:
        return this.getTileInfo(url);
      case LayerType.IMAGERY:
        return this.getImageryInfo(url);
      case LayerType.WFS:
        return this.getWfsInfo(url);
      case LayerType.WMS:
        return this.getWmsInfo(url, nested);
    }
  }
  async getFeatureInfo(url) {
    const response = await axios.get(url, { params: { f: "json" } });
    const config = {
      id: `${LayerType.FEATURE}#${++this.layerCount}`,
      url,
      layerType: LayerType.FEATURE,
      name: response.data.name,
      nameField: response.data.displayField,
      tooltipField: response.data.displayField,
      state: { opacity: 1, visibility: true }
    };
    return {
      config,
      fields: response.data.fields,
      configOptions: ["name", "nameField", "tooltipField"]
    };
  }
  /**
   * Gets MIL data from source, formats it as a tree, and returns a promise of the data with configuration
   *
   * @param {string} url
   * @returns {Promise<LayerInfo>} data configuration
   */
  async getMapImageInfo(url, nested) {
    const response = await axios.get(url, { params: { f: "json" } });
    const config = {
      id: `${LayerType.MAPIMAGE}#${++this.layerCount}`,
      url,
      layerType: LayerType.MAPIMAGE,
      name: response.data.mapName,
      sublayers: [],
      state: { opacity: 1, visibility: true }
    };
    return {
      config,
      layers: this.createLayerHierarchy(response.data.layers, nested),
      configOptions: ["name", "sublayers"],
      layersRaw: response.data.layers
    };
  }
  createLayerHierarchy(layers, nested) {
    layers.sort((l1, l2) => l1.id - l2.id);
    const findParent = (id, sublayers) => {
      if (sublayers === void 0) {
        return false;
      }
      let parent;
      if (sublayers.find((sl) => sl.id === id)) {
        return sublayers.find((sl) => sl.id === id);
      } else {
        for (const sublayer of sublayers) {
          parent = findParent(id, sublayer.children);
          if (parent !== false) {
            return parent;
          }
        }
        return false;
      }
    };
    const opts = [];
    const parentIds = new Set(
      layers.filter((layer) => layer.subLayerIds && layer.subLayerIds.length > 0).map((layer) => layer.id)
    );
    for (const layer of layers) {
      if (nested && layer.parentLayerId === -1) {
        opts.push({
          id: layer.id,
          label: layer.name,
          children: layer.subLayerIds ? [] : void 0
        });
      } else if (nested) {
        const parentLayer = findParent(layer.parentLayerId, opts);
        parentLayer.children = [
          ...parentLayer.children,
          {
            id: layer.id,
            label: layer.name,
            children: layer.subLayerIds ? [] : void 0
          }
        ];
      } else if (!parentIds.has(layer.id)) {
        opts.push({
          id: layer.id,
          label: layer.name,
          children: void 0
        });
      }
    }
    return opts;
  }
  async getTileInfo(url) {
    const response = await axios.get(url, { params: { f: "json" } });
    const config = {
      id: `${LayerType.TILE}#${++this.layerCount}`,
      url,
      layerType: LayerType.TILE,
      name: response.data.mapName,
      state: { opacity: 1, visibility: true }
    };
    return {
      config,
      configOptions: ["name"]
    };
  }
  async getImageryInfo(url) {
    const response = await axios.get(url, { params: { f: "json" } });
    const config = {
      id: `${LayerType.IMAGERY}#${++this.layerCount}`,
      url,
      layerType: LayerType.IMAGERY,
      name: response.data.name,
      state: { opacity: 1, visibility: true }
    };
    return {
      config,
      configOptions: ["name"]
    };
  }
  async getWfsInfo(url) {
    const wrapper = new UrlWrapper(url);
    const { offset, limit } = wrapper.queryMap;
    const wfsJson = await this.$iApi.geo.layer.ogc.loadWfsData(
      url,
      -1,
      parseInt(offset) || 0,
      parseInt(limit) || 1e3
    );
    return this.getGeojsonInfo(url.match(/\/([^/]+)\/items/)?.[1] || "Layer", wfsJson);
  }
  /**
   * Gets WMS data from source, formats it, and returns a promise of the data with configuration
   *
   * @param {string} url
   * @returns {Promise<LayerInfo>} data configuration
   */
  async getWmsInfo(url, nested) {
    const capabilities = await this.$iApi.geo.layer.ogc.parseCapabilities(url);
    const config = {
      id: `${LayerType.WMS}#${++this.layerCount}`,
      url,
      layerType: LayerType.WMS,
      name: url,
      featureInfoMimeType: capabilities.queryTypes[0],
      state: { opacity: 1, visibility: true }
    };
    return {
      config,
      layers: this.mapWmsLayerList(capabilities.layers, nested),
      configOptions: ["name", "sublayers"],
      layersRaw: capabilities.layers
    };
  }
  mapWmsLayerList(layers, nested) {
    let modLayers = [];
    layers.forEach((layer) => {
      if (layer.name === null && layer.layers) {
        modLayers = [...modLayers, ...layer.layers];
      } else {
        modLayers.push(layer);
      }
    });
    if (nested) {
      return modLayers.flatMap((layer) => {
        return {
          id: `${layer.name}#${++this.sublayerCount}`,
          label: layer.title,
          children: layer.layers.length > 0 ? this.mapWmsLayerList(layer.layers, nested) : void 0
        };
      });
    } else {
      return modLayers.flatMap(
        (layer) => layer.layers && layer.layers.length > 0 ? this.mapWmsLayerList(layer.layers, nested) : {
          id: `${layer.name}#${++this.sublayerCount}`,
          label: layer.title
        }
      );
    }
  }
  /**
   * Guesses type of file or service given a URL
   *
   * @param {string} url
   * @returns {string} file or layer type
   */
  guessFormatFromURL(url) {
    switch (url.match(/\.(zip|csv|geojson|json)$/)?.[1]) {
      case "zip":
        return LayerType.SHAPEFILE;
      case "csv":
        return LayerType.CSV;
      case "geojson":
      case "json":
        return LayerType.GEOJSON;
    }
    if (url.match(/\/ImageServer\/?$/gi)) {
      return LayerType.IMAGERY;
    }
    if (url.match(/\/collections\//gi)) {
      return LayerType.WFS;
    }
    if (url.match(/arcgis\/rest\/services\//gi)) {
      if (url.match(/\/\d+\/?$/g)) {
        return LayerType.FEATURE;
      }
      return LayerType.MAPIMAGE;
    }
    if (url.match(/service=|version=|\/wms/gi)) {
      return LayerType.WMS;
    }
    return "";
  }
}

const messages = {"en":{"wizard.title":"Import Layer","wizard.upload.title":"Upload data","wizard.upload.or":"or","wizard.upload.file.label":"Upload a file","wizard.upload.file.help":"Drop or select a file to upload","wizard.upload.file.error.failed":"File upload failed","wizard.upload.url.label":"URL to file or service","wizard.upload.url.error.required":"URL is required","wizard.upload.url.error.url":"Please enter a valid URL","wizard.format.title":"Select format","wizard.format.type.service":"Service type","wizard.format.type.file":"File format","wizard.format.type.error.required":"Service or file type is required","wizard.format.type.error.invalid":"Invalid file or service type","wizard.format.type.error.failure":"Failed to load data from file/service","wizard.format.info.cors":"Service needs to be CORS enabled","wizard.format.warn.cors":"Service may not support CORS","wizard.format.warn.vpn":"Service may require a VPN connection","wizard.fileType.csv":"CSV","wizard.fileType.shapefile":"zipped Shapefile","wizard.fileType.geojson":"GeoJSON","wizard.layerType.esriFeature":"ESRI Feature Layer","wizard.layerType.esriMapImage":"ESRI Map Image Layer","wizard.layerType.esriImagery":"ESRI Imagery Layer","wizard.layerType.esriTile":"ESRI Tile Layer","wizard.layerType.ogcWms":"OGC Web Map Service","wizard.layerType.ogcWfs":"OGC Web Feature Service","wizard.configure.title":"Configure layer","wizard.configure.name.error.required":"Name is required","wizard.configure.name.label":"Layer Name","wizard.configure.nameField.label":"Primary Field","wizard.configure.tooltipField.label":"Tooltip Field","wizard.configure.latField.label":"Latitude Field","wizard.configure.longField.label":"Longitude Field","wizard.configure.sublayers.error.required":"Sublayers are required","wizard.configure.sublayers.label":"Layers","wizard.configure.sublayers.results":"No results","wizard.configure.sublayers.search":"Search layers","wizard.configure.sublayers.select":"Select layer(s)","wizard.configure.sublayers.clearAll":"Clear all","wizard.configure.sublayers.nested":"Nested","wizard.configure.colour.label":"Colour","wizard.configure.colour.hue":"Hue","wizard.configure.colour.copy":"Copy colour","wizard.configure.colour.hex":"Hex","wizard.step.cancel":"Cancel","wizard.step.continue":"Continue","wizard.upload.success":"has been uploaded successfully.","wizard.upload.fail":"failed to upload."},"fr":{"wizard.title":"Importer un fichier","wizard.upload.title":"Charger des données","wizard.upload.or":"ou","wizard.upload.file.label":"Télécharger un fichier","wizard.upload.file.help":"Déposer ou sélectionner un fichier à télécharger","wizard.upload.file.error.failed":"Le téléchargement du fichier a échoué","wizard.upload.url.label":"URL vers fichier ou service","wizard.upload.url.error.required":"L'URL est requise","wizard.upload.url.error.url":"Veuillez saisir une adresse URL valide","wizard.format.title":"Choisir un format","wizard.format.type.service":"Type de service","wizard.format.type.file":"Format du fichier","wizard.format.type.error.required":"Le service ou le type de fichier est requis","wizard.format.type.error.invalid":"Type de fichier ou de service non valide","wizard.format.type.error.failure":"Échec du chargement des données à partir du fichier/service","wizard.format.info.cors":"Le service doit être compatible CORS.","wizard.format.warn.cors":"Le service ne pend peut-être pas en charge CORS.","wizard.format.warn.vpn":"Le service peut nécessiter une connexion RPV","wizard.fileType.csv":"CSV","wizard.fileType.shapefile":"Shapefile zippé","wizard.fileType.geojson":"GeoJSON","wizard.layerType.esriFeature":"Couche d'éléments d'ESRI","wizard.layerType.esriMapImage":"Couche d'image de la carte ESRI","wizard.layerType.esriImagery":"Couche d'imagerie d'ESRI","wizard.layerType.esriTile":"Couche de tuiles d'ESRI","wizard.layerType.ogcWms":"Couche WMS de l'OGC","wizard.layerType.ogcWfs":"Service d'entités Web OGC","wizard.configure.title":"Configurer la couche","wizard.configure.name.error.required":"Le champ Nom est obligatoire","wizard.configure.name.label":"Nom de la couche","wizard.configure.nameField.label":"Champ clé","wizard.configure.tooltipField.label":"Champ infobulle","wizard.configure.latField.label":"Champ latitude","wizard.configure.longField.label":"Champ longitude","wizard.configure.sublayers.error.required":"Des sous-couches sont requises","wizard.configure.sublayers.label":"Couches","wizard.configure.sublayers.results":"Aucun résultat","wizard.configure.sublayers.search":"Rechercher des couches","wizard.configure.sublayers.select":"Sélectionner les couches","wizard.configure.sublayers.clearAll":"Effacer tout","wizard.configure.sublayers.nested":"Imbriquées","wizard.configure.colour.label":"Couleur","wizard.configure.colour.hue":"Teinte","wizard.configure.colour.copy":"Copier la couleur","wizard.configure.colour.hex":"Hex","wizard.step.cancel":"Annuler","wizard.step.continue":"Continuer","wizard.upload.success":"a été téléversé avec succès.","wizard.upload.fail":"n'a pas pu être téléversé."}};

class WizardFixture extends WizardAPI {
  added() {
    this.$iApi.panel.register(
      {
        wizard: {
          screens: {
            "wizard-screen": markRaw(WizardScreenV)
          },
          button: {
            tooltip: "wizard.title",
            icon: '<svg class="fill-current" viewBox="0 0 23 21"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></svg>'
          },
          style: {
            width: "350px"
          },
          alertName: "wizard.title"
        }
      },
      {
        i18n: { messages }
      }
    );
    this.handlePanelTeleports(["wizard"]);
    let layerSource = new LayerSource(this.$iApi);
    const wizardStore = useWizardStore(this.$vApp.$pinia);
    wizardStore.layerSource = layerSource;
    this.removed = () => {
      this.$iApi.panel.remove("wizard");
      layerSource = void 0;
      wizardStore.$reset();
    };
  }
}

const index = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: WizardFixture
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$h = ["onClick"];
const _hoisted_2$e = { class: "md-icon-small inline" };
const _hoisted_3$a = {
  key: 0,
  height: "18",
  width: "18",
  viewBox: "0 0 24 24",
  class: "inline float-right"
};
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "column-dropdown",
  props: {
    columnDefs: { type: Object, required: true },
    columnApi: { type: Object },
    systemCols: { type: Object }
  },
  setup(__props) {
    const iApi = inject("iApi");
    const { t } = useI18n();
    return (_ctx, _cache) => {
      const _component_dropdown_menu = resolveComponent("dropdown-menu");
      return openBlock(), createBlock(_component_dropdown_menu, {
        class: "relative",
        position: "bottom-end",
        tooltip: unref(t)("grid.label.columns"),
        tooltipPlacementAlt: "left",
        centered: false
      }, {
        header: withCtx(() => _cache[0] || (_cache[0] = [
          createElementVNode("div", { class: "flex p-8" }, [
            createElementVNode("svg", {
              xmlns: "http://www.w3.org/2000/svg",
              fit: "",
              height: "24px",
              width: "24px",
              preserveAspectRatio: "xMidYMid meet",
              viewBox: "0 0 23 24",
              focusable: "false",
              class: "inline fill-current"
            }, [
              createElementVNode("g", { id: "format-list-checks_cache966" }, [
                createElementVNode("path", { d: "M3,5H9V11H3V5M5,7V9H7V7H5M11,7H21V9H11V7M11,15H21V17H11V15M5,20L1.5,16.5L2.91,15.09L5,17.17L9.59,12.59L11,14L5,20Z" })
              ])
            ])
          ], -1)
        ])),
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.columnDefs.filter(
            (c) => c.headerName && c.headerName.length > 0 && !(!unref(iApi).ui.exposeOids && __props.systemCols?.has(c.headerName)) && !(!unref(iApi).ui.exposeMeasurements && (__props.systemCols?.has(c.headerName) || __props.systemCols?.has(c.field)))
          ), (col) => {
            return openBlock(), createElementBlock("a", {
              key: col.headerName,
              onClick: ($event) => {
                __props.columnApi?.setColumnVisible(col.field, col.hide);
                col.hide = !col.hide;
                _ctx.$emit("refreshHeaders");
              },
              href: "javascript:;",
              class: "flex leading-snug items-center w-256"
            }, [
              createElementVNode("div", _hoisted_2$e, [
                createTextVNode(toDisplayString(col.headerName) + " ", 1),
                !col.hide ? (openBlock(), createElementBlock("svg", _hoisted_3$a, _cache[1] || (_cache[1] = [
                  createElementVNode("g", { id: "done" }, [
                    createElementVNode("path", { d: "M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z" })
                  ], -1)
                ]))) : createCommentVNode("", true)
              ])
            ], 8, _hoisted_1$h);
          }), 128))
        ]),
        _: 1
      }, 8, ["tooltip"]);
    };
  }
});

const GRID_SELECTOR = ".ag-root";
const HEADER_ROW_SELECTOR = ".ag-header-viewport .ag-header-row";
class GridAccessibilityManager {
  element;
  agGrid;
  headerRows;
  agGridApi;
  agColumnApi;
  mousedown = false;
  /**
   * Triggered by ag-grid whenever a key is pressed on a focused/active cell.
   * For our use case we open a new browser tab (or window, it's based on the users browser settings)
   * for each href attribute found in the cell content when the 'Enter' key is pressed.
   *
   * Note that for security/performance purposes some browsers limit the number
   * of tabs that can be opened to one. The user can disable this limitation by
   * allowing popups from the website hosting a ramp map (shows up as an icon in the url bar of chrome,
   * other browser may vary).
   */
  static onCellKeyPress({ event }) {
    function childNodeTraversal(childNodes) {
      childNodes.forEach((cN) => {
        if (cN.href) {
          window.open(cN.href);
        }
        if (cN.childNodes.length > 0) {
          childNodeTraversal(cN.childNodes);
        }
      });
    }
    if (event.key == "Enter") {
      childNodeTraversal(event.target.childNodes);
    }
  }
  /**
   * Initializes focus lists and listeners for grid keyboard navigation.
   *
   * @param {HTMLElement} element The grid element
   * @param {GridApi} agGridApi The ag-grid grid api
   * @param {ColumnApi} agColumnApi The ag-grid column api
   */
  constructor(element, agGridApi, agColumnApi) {
    this.element = element;
    this.agGridApi = agGridApi;
    this.agColumnApi = agColumnApi;
    this.agGrid = this.element.querySelector(GRID_SELECTOR);
    this.headerRows = Array.prototype.slice.call(
      this.element.querySelectorAll(HEADER_ROW_SELECTOR)
    );
    this.element.querySelector(".ag-body-horizontal-scroll-viewport")?.setAttribute("tabindex", "-1");
    this.initAccessibilityListeners();
    this.initScrollListeners();
  }
  /**
   * Set up the listeners for the grid
   */
  initAccessibilityListeners() {
    const headerCells = Array.prototype.slice.call(
      this.headerRows[0].querySelectorAll(".ag-header-cell")
    );
    headerCells.forEach((cell, index) => {
      if (index < 3) {
        return;
      }
      const buttons = Array.prototype.slice.call(cell.querySelectorAll("button"));
      cell.addEventListener("keydown", (event) => {
        this.cellKeydownHandler(event, cell, buttons);
      });
      cell.addEventListener("blur", (event) => {
        this.cellBlurHandler(event, cell, buttons);
      });
      buttons[buttons.length - 1].addEventListener("keydown", (event) => {
        this.cellButtonTabHandler(event, cell, buttons, false);
      });
      buttons[0].addEventListener("keydown", (event) => {
        this.cellButtonTabHandler(event, cell, buttons, true);
      });
    });
  }
  /**
   * Remove all accessibility listeners from the grid
   */
  removeAccessibilityListeners() {
    const headerCells = Array.prototype.slice.call(
      this.headerRows[0].querySelectorAll(".ag-header-cell")
    );
    headerCells.forEach((cell, index) => {
      if (index < 3) {
        return;
      }
      const buttons = Array.prototype.slice.call(cell.querySelectorAll("button"));
      cell.removeEventListener("keydown", (event) => {
        this.cellKeydownHandler(event, cell, buttons);
      });
      cell.removeEventListener("blur", (event) => {
        this.cellBlurHandler(event, cell, buttons);
      });
      buttons[buttons.length - 1].removeEventListener("keydown", (event) => {
        this.cellButtonTabHandler(event, cell, buttons, false);
      });
      buttons[0].removeEventListener("keydown", (event) => {
        this.cellButtonTabHandler(event, cell, buttons, true);
      });
    });
  }
  /**
   * Makes `enter` allow navigation within the cell
   *
   * @param {KeyboardEvent} event The event to handle
   * @param {HTMLElement} cell The grid header cell
   * @param {HTMLElement[]} buttons The list of buttons in the cell
   */
  cellKeydownHandler(event, cell, buttons) {
    if (event.key === "Enter" && event.target === cell) {
      event.preventDefault();
      buttons.forEach((item) => {
        item.setAttribute("tabindex", "0");
      });
      buttons[0].focus();
    }
  }
  /**
   * Removes ability to tab to inner items when focus leaves the cell (and inner items)
   *
   * @param {FocusEvent} event The event to handle
   * @param {HTMLElement} cell The grid header cell
   * @param {HTMLElement[]} buttons The list of buttons in the cell
   */
  cellBlurHandler(event, cell, buttons) {
    if (event.target === cell && !buttons.includes(event.relatedTarget)) {
      buttons.forEach((item) => {
        item.setAttribute("tabindex", "-1");
      });
    }
  }
  /**
   * Handles giving focus back to the cell after shift+tabbing on the first inner item or tabbing on the last
   *
   * @param event The event to handle
   * @param cell The grid header cell
   * @param buttons The list of buttons in the cell
   * @param shift Whether to handle shift tab or regular tab
   */
  cellButtonTabHandler(event, cell, buttons, shift) {
    if (event.key === "Tab" && (shift && event.shiftKey || !shift && !event.shiftKey)) {
      event.preventDefault();
      cell.focus();
      buttons.forEach((item) => {
        item.setAttribute("tabindex", "-1");
      });
    }
  }
  //  **** CLICK & DRAG SCROLLING ****
  /**
   * Initializes the handlers needed for click + drag scrolling
   */
  initScrollListeners() {
    this.agGrid.style.cursor = "grab";
    this.agGrid.addEventListener("mousedown", (event) => {
      this.scrollMouseDownHandler(event);
    });
  }
  /**
   * Removes the handlers for click + drag scrolling
   */
  removeScrollListeners() {
    this.agGrid.style.cursor = "default";
    this.agGrid.removeEventListener("mousedown", (event) => {
      this.scrollMouseDownHandler(event);
    });
  }
  /**
   * Handles starting click + drag scrolling on mousedown
   *
   * @param {MouseEvent} event The mousedown event
   */
  scrollMouseDownHandler(event) {
    const scrollBar = this.element.querySelector(".ag-body-horizontal-scroll-viewport");
    const scrollStart = scrollBar.scrollLeft;
    const mouseStart = event.clientX;
    this.agGrid.style.cursor = "grabbing";
    const scrollMouseMoveHandler = (event2) => {
      const change = event2.clientX - mouseStart;
      scrollBar.scrollLeft = scrollStart - change;
    };
    const endDragScroll = () => {
      this.agGrid.style.cursor = "grab";
      this.agGrid.removeEventListener("mousemove", scrollMouseMoveHandler);
      this.agGrid.removeEventListener("mouseup", endDragScroll);
      this.agGrid.removeEventListener("mouseleave", endDragScroll);
    };
    this.agGrid.addEventListener("mousemove", scrollMouseMoveHandler);
    this.agGrid.addEventListener("mouseup", endDragScroll);
    this.agGrid.addEventListener("mouseleave", endDragScroll);
  }
}
function tabToNextHeaderHandler(params) {
  const column = params.previousHeaderPosition.column;
  const lastIndex = params.previousHeaderPosition.headerRowIndex;
  let headerRowIndex = params.backwards ? lastIndex - 1 : lastIndex + 1;
  if (headerRowIndex === -1) {
    return null;
  } else if (headerRowIndex === params.headerRowCount) {
    headerRowIndex = -1;
  }
  return { headerRowIndex, column };
}
function tabToNextCellHandler(params) {
  if (params.backwards) {
    return { column: params.previousCellPosition.column, rowIndex: -1 };
  }
  return null;
}

const _hoisted_1$g = { class: "h-full flex items-center justify-center" };
const _hoisted_2$d = ["placeholder", "aria-label", "disabled"];
const _hoisted_3$9 = ["placeholder", "aria-label", "disabled"];
const __default__$3 = {
  methods: {
    onParentModelChanged() {
    }
  }
};
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  ...__default__$3,
  __name: "custom-number-filter",
  props: ["params"],
  setup(__props) {
    const panelStore = usePanelStore();
    const { t } = useI18n();
    const props = __props;
    const minVal = ref("");
    const maxVal = ref("");
    const fixed = ref(props.params.stateManager.columns[props.params.column.colDef.field].filter.static);
    const minValChanged = () => {
      minVal.value = minVal.value !== "" && !isNaN(minVal.value) ? minVal.value : null;
      props.params.parentFilterInstance((instance) => {
        setFilterModel(instance);
        props.params.stateManager.setColumnFilterValue(props.params.column.colDef.field, minVal.value, "min");
      });
    };
    const maxValChanged = () => {
      maxVal.value = maxVal.value !== "" && !isNaN(maxVal.value) ? maxVal.value : null;
      props.params.parentFilterInstance((instance) => {
        setFilterModel(instance);
        props.params.stateManager.setColumnFilterValue(props.params.column.colDef.field, maxVal.value, "max");
      });
    };
    const setFilterModel = (instance) => {
      if (isNaN(minVal.value) || minVal.value === null) minVal.value = "";
      if (isNaN(maxVal.value) || maxVal.value === null) maxVal.value = "";
      if (maxVal.value !== "" && minVal.value !== "") {
        instance.setModel({
          filterType: "number",
          type: "inRange",
          filter: minVal.value,
          filterTo: maxVal.value
        });
      } else if (minVal.value === "") {
        instance.setModel({
          filterType: "number",
          type: "lessThanOrEqual",
          filter: maxVal.value
        });
      } else if (maxVal.value === "") {
        instance.setModel({
          filterType: "number",
          type: "greaterThanOrEqual",
          filter: minVal.value
        });
      } else {
        instance.setModel(null);
      }
      props.params.api.onFilterChanged();
    };
    onBeforeMount(() => {
      minVal.value = props.params.stateManager.getColumnFilterValue(props.params.column.colDef.field, "min");
      maxVal.value = props.params.stateManager.getColumnFilterValue(props.params.column.colDef.field, "max");
      minValChanged();
      maxValChanged();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$g, [
        withDirectives(createElementVNode("input", {
          class: normalizeClass(["rv-min rv-input bg-white text-black-75 h-24 py-16 px-8 border-2 rounded", {
            "cursor-not-allowed": fixed.value
          }]),
          style: { "width": "45%" },
          type: "number",
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => minVal.value = $event),
          onInput: _cache[1] || (_cache[1] = ($event) => minValChanged()),
          onMousedown: _cache[2] || (_cache[2] = withModifiers(() => {
          }, ["stop"])),
          onKeypress: _cache[3] || (_cache[3] = withKeys(withModifiers(() => {
          }, ["prevent"]), ["enter"])),
          onKeyup: _cache[4] || (_cache[4] = withKeys(($event) => {
            if (unref(panelStore).mobileView) {
              $event.target.blur();
            }
          }, ["enter"])),
          enterkeyhint: "done",
          placeholder: unref(t)("grid.filters.number.min"),
          "aria-label": unref(t)("grid.filters.number.min"),
          disabled: fixed.value
        }, null, 42, _hoisted_2$d), [
          [vModelText, minVal.value]
        ]),
        _cache[10] || (_cache[10] = createElementVNode("span", { class: "w-12" }, null, -1)),
        withDirectives(createElementVNode("input", {
          class: normalizeClass(["rv-max rv-input bg-white text-black-75 h-24 py-16 px-8 border-2 rounded", {
            "cursor-not-allowed": fixed.value
          }]),
          style: { "width": "45%" },
          type: "number",
          "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => maxVal.value = $event),
          onInput: _cache[6] || (_cache[6] = ($event) => maxValChanged()),
          onMousedown: _cache[7] || (_cache[7] = withModifiers(() => {
          }, ["stop"])),
          onKeypress: _cache[8] || (_cache[8] = withKeys(withModifiers(() => {
          }, ["prevent"]), ["enter"])),
          onKeyup: _cache[9] || (_cache[9] = withKeys(($event) => {
            if (unref(panelStore).mobileView) {
              $event.target.blur();
            }
          }, ["enter"])),
          enterkeyhint: "done",
          placeholder: unref(t)("grid.filters.number.max"),
          "aria-label": unref(t)("grid.filters.number.max"),
          disabled: fixed.value
        }, null, 42, _hoisted_3$9), [
          [vModelText, maxVal.value]
        ])
      ]);
    };
  }
});

const GridCustomNumberFilterV = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__scopeId", "data-v-6583eadd"]]);

const _hoisted_1$f = { class: "h-full flex items-center justify-center" };
const _hoisted_2$c = ["placeholder", "aria-label", "disabled"];
const __default__$2 = {
  methods: {
    onParentModelChanged() {
    }
  }
};
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  ...__default__$2,
  __name: "custom-text-filter",
  props: ["params"],
  setup(__props) {
    const panelStore = usePanelStore();
    const { t } = useI18n();
    const props = __props;
    const filterValue = ref("");
    const fixed = ref(props.params.stateManager.columns[props.params.column.colDef.field].filter.static);
    const valueChanged = () => {
      props.params.parentFilterInstance((instance) => {
        filterValue.value = filterValue.value ? filterValue.value : "";
        instance.setModel({
          filterType: "text",
          type: "contains",
          filter: filterValue.value
        });
        props.params.stateManager.setColumnFilterValue(props.params.column.colDef.field, filterValue.value);
        props.params.api.onFilterChanged();
      });
    };
    onBeforeMount(() => {
      filterValue.value = props.params.stateManager.getColumnFilterValue(props.params.column.colDef.field);
      valueChanged();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$f, [
        withDirectives(createElementVNode("input", {
          class: normalizeClass(["rv-input w-full bg-white text-black-75 h-24 py-16 px-8 border-2 rounded", {
            "cursor-not-allowed": fixed.value
          }]),
          type: "text",
          onInput: _cache[0] || (_cache[0] = ($event) => valueChanged()),
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => filterValue.value = $event),
          onMousedown: _cache[2] || (_cache[2] = withModifiers(() => {
          }, ["stop"])),
          onKeypress: _cache[3] || (_cache[3] = withKeys(withModifiers(() => {
          }, ["prevent"]), ["enter"])),
          onKeyup: _cache[4] || (_cache[4] = withKeys(($event) => {
            if (unref(panelStore).mobileView) {
              $event.target.blur();
            }
          }, ["enter"])),
          enterkeyhint: "done",
          placeholder: unref(t)("grid.filters.column.label.text", [__props.params.column.colDef.headerName]),
          "aria-label": unref(t)("grid.filters.column.label.text", [__props.params.column.colDef.headerName]),
          disabled: fixed.value
        }, null, 42, _hoisted_2$c), [
          [vModelText, filterValue.value]
        ])
      ]);
    };
  }
});

const _hoisted_1$e = { class: "h-full flex items-center justify-center" };
const _hoisted_2$b = ["aria-label", "disabled"];
const _hoisted_3$8 = ["value"];
const __default__$1 = {
  methods: {
    onParentModelChanged() {
    }
  }
};
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  ...__default__$1,
  __name: "custom-selector-filter",
  props: ["params"],
  setup(__props) {
    const props = __props;
    const selectedOption = ref("");
    const options = ref([]);
    const fixed = ref(props.params.stateManager.columns[props.params.column.colDef.field].filter.static);
    const selectionChanged = () => {
      selectedOption.value = selectedOption.value ? selectedOption.value : "";
      props.params.parentFilterInstance((instance) => {
        if (selectedOption.value === "...") {
          instance.setModel(null);
          selectedOption.value = "";
        } else {
          instance.setModel({
            filterType: "text",
            type: "contains",
            filter: selectedOption.value
          });
        }
        props.params.stateManager.setColumnFilterValue(props.params.column.colDef.field, selectedOption.value);
        props.params.api.onFilterChanged();
      });
    };
    onBeforeMount(() => {
      selectedOption.value = props.params.stateManager.getColumnFilterValue(props.params.column.colDef.field);
      let rowData = props.params.rowData;
      rowData = rowData.map((row) => row[props.params.column.colId]);
      options.value = rowData.filter((item, idx) => rowData.indexOf(item) === idx);
      options.value.unshift("...");
      selectionChanged();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$e, [
        withDirectives(createElementVNode("select", {
          class: normalizeClass(["rv-input w-full bg-white text-black-75 h-24 py-0 px-8 border-2 rounded", {
            "cursor-not-allowed": fixed.value
          }]),
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedOption.value = $event),
          onChange: _cache[1] || (_cache[1] = ($event) => selectionChanged()),
          onMousedown: _cache[2] || (_cache[2] = withModifiers(() => {
          }, ["stop"])),
          "aria-label": selectedOption.value,
          disabled: fixed.value
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(options.value, (option) => {
            return openBlock(), createElementBlock("option", {
              value: option,
              key: option
            }, toDisplayString(option), 9, _hoisted_3$8);
          }), 128))
        ], 42, _hoisted_2$b), [
          [vModelSelect, selectedOption.value]
        ])
      ]);
    };
  }
});

const GridCustomSelectorFilterV = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__scopeId", "data-v-f1c7aa13"]]);

const _hoisted_1$d = { class: "h-full flex items-center justify-center w-full" };
const _hoisted_2$a = ["placeholder", "aria-label", "disabled"];
const _hoisted_3$7 = ["placeholder", "aria-label", "disabled"];
const __default__ = {
  methods: {
    onParentModelChanged() {
    }
  }
};
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  ...__default__,
  __name: "custom-date-filter",
  props: ["params"],
  setup(__props) {
    const panelStore = usePanelStore();
    const { t } = useI18n();
    const props = __props;
    const minVal = ref("");
    const maxVal = ref("");
    const fixed = ref(props.params.stateManager.columns[props.params.column.colDef.field].filter.static);
    const minValChanged = () => {
      props.params.parentFilterInstance((instance) => {
        setFilterModel(instance);
        props.params.stateManager.setColumnFilterValue(props.params.column.colDef.field, minVal.value, "min");
      });
    };
    const maxValChanged = () => {
      props.params.parentFilterInstance((instance) => {
        setFilterModel(instance);
        props.params.stateManager.setColumnFilterValue(props.params.column.colDef.field, maxVal.value, "max");
      });
    };
    const setFilterModel = (instance) => {
      if (maxVal.value === "" && minVal.value === "") {
        instance.setModel(null);
      } else if (maxVal.value !== "" && minVal.value !== "") {
        instance.setModel({
          filterType: "date",
          type: "inRange",
          dateFrom: minVal.value,
          dateTo: maxVal.value
        });
      } else if (minVal.value === "") {
        instance.setModel({
          filterType: "date",
          type: "lessThan",
          dateFrom: maxVal.value
        });
      } else if (maxVal.value === "") {
        instance.setModel({
          filterType: "date",
          type: "greaterThan",
          dateFrom: minVal.value
        });
      }
      props.params.api.onFilterChanged();
    };
    onBeforeMount(() => {
      minVal.value = props.params.stateManager.getColumnFilterValue(props.params.column.colDef.field, "min") || "";
      maxVal.value = props.params.stateManager.getColumnFilterValue(props.params.column.colDef.field, "max") || "";
      minValChanged();
      maxValChanged();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$d, [
        withDirectives(createElementVNode("input", {
          class: normalizeClass(["m-0 py-1 w-1/2 rv-input bg-white text-black-75 h-24 py-16 px-8 border-2 rounded", {
            "cursor-not-allowed": fixed.value
          }]),
          type: "date",
          placeholder: unref(t)("grid.filters.date.min"),
          "aria-label": unref(t)("grid.filters.date.min"),
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => minVal.value = $event),
          onInput: _cache[1] || (_cache[1] = ($event) => minValChanged()),
          onMousedown: _cache[2] || (_cache[2] = withModifiers(() => {
          }, ["stop"])),
          onKeypress: _cache[3] || (_cache[3] = withKeys(withModifiers(() => {
          }, ["prevent"]), ["enter"])),
          onKeyup: _cache[4] || (_cache[4] = withKeys(($event) => {
            if (unref(panelStore).mobileView) {
              $event.target.blur();
            }
          }, ["enter"])),
          enterkeyhint: "done",
          disabled: fixed.value
        }, null, 42, _hoisted_2$a), [
          [vModelText, minVal.value]
        ]),
        _cache[10] || (_cache[10] = createElementVNode("span", { class: "w-12" }, null, -1)),
        withDirectives(createElementVNode("input", {
          class: normalizeClass(["m-0 py-1 w-1/2 rv-input bg-white text-black-75 h-24 py-16 px-8 border-2 rounded", {
            "cursor-not-allowed": fixed.value
          }]),
          type: "date",
          placeholder: unref(t)("grid.filters.date.max"),
          "aria-label": unref(t)("grid.filters.date.max"),
          "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => maxVal.value = $event),
          onInput: _cache[6] || (_cache[6] = ($event) => maxValChanged()),
          onMousedown: _cache[7] || (_cache[7] = withModifiers(() => {
          }, ["stop"])),
          onKeypress: _cache[8] || (_cache[8] = withKeys(withModifiers(() => {
          }, ["prevent"]), ["enter"])),
          onKeyup: _cache[9] || (_cache[9] = withKeys(($event) => {
            if (unref(panelStore).mobileView) {
              $event.target.blur();
            }
          }, ["enter"])),
          enterkeyhint: "done",
          disabled: fixed.value
        }, null, 42, _hoisted_3$7), [
          [vModelText, maxVal.value]
        ])
      ]);
    };
  }
});

const GridCustomDateFilterV = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__scopeId", "data-v-9db9be0a"]]);

const _hoisted_1$c = ["content", "disabled"];
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "clear-filter",
  props: ["params"],
  setup(__props) {
    const props = __props;
    const { t } = useI18n();
    const el = ref();
    const clearFilters = () => props.params.clearFilters();
    onMounted(async () => {
      await nextTick();
      const headerCell = el.value?.closest(".ag-header-cell");
      const grid = headerCell.closest(".ag-pinned-left-header");
      headerCell.addEventListener("keydown", async (e) => {
        if (e.key === "Enter") {
          e.stopPropagation();
          clearFilters();
          await nextTick();
          grid.querySelector(".ag-header-cell.ag-floating-filter").focus();
        }
      });
      headerCell.addEventListener("focus", () => {
        el.value._tippy.show();
      });
      headerCell.addEventListener("blur", () => {
        el.value._tippy.hide();
      });
    });
    onBeforeUnmount(() => {
      const headerCell = el.value?.closest(".ag-header-cell");
      const grid = headerCell.closest(".ag-pinned-left-header");
      headerCell.removeEventListener("keydown", async (e) => {
        if (e.key === "Enter") {
          e.stopPropagation();
          clearFilters();
          await nextTick();
          grid.querySelector(".ag-header-cell.ag-floating-filter").focus();
        }
      });
      headerCell.removeEventListener("focus", () => {
        el.value._tippy.show();
      });
      headerCell.removeEventListener("blur", () => {
        el.value._tippy.hide();
      });
    });
    return (_ctx, _cache) => {
      const _directive_tippy = resolveDirective("tippy");
      return withDirectives((openBlock(), createElementBlock("button", {
        type: "button",
        class: "clearFilterButton flex items-center justify-center w-full h-full disabled:opacity-30 disabled:cursor-default text-gray-500 hover:text-black",
        onClick: clearFilters,
        content: unref(t)("grid.filters.clear"),
        disabled: !__props.params.stateManager.filtered,
        tabindex: "-1",
        ref_key: "el",
        ref: el
      }, _cache[0] || (_cache[0] = [
        createElementVNode("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          "enable-background": "new 0 0 24 24",
          class: "h-24 w-24 fill-current",
          viewBox: "0 0 24 24"
        }, [
          createElementVNode("g", null, [
            createElementVNode("rect", {
              fill: "none",
              height: "24",
              width: "24"
            })
          ]),
          createElementVNode("g", null, [
            createElementVNode("g", null, [
              createElementVNode("path", { d: "M19.79,5.61C20.3,4.95,19.83,4,19,4H6.83l7.97,7.97L19.79,5.61z" }),
              createElementVNode("path", { d: "M2.81,2.81L1.39,4.22L10,13v6c0,0.55,0.45,1,1,1h2c0.55,0,1-0.45,1-1v-2.17l5.78,5.78l1.41-1.41L2.81,2.81z" })
            ])
          ])
        ], -1)
      ]), 8, _hoisted_1$c)), [
        [_directive_tippy, { placement: "bottom" }]
      ]);
    };
  }
});

const _hoisted_1$b = {
  key: 0,
  class: "flex flex-1 items-center min-w-0",
  "truncate-trigger": ""
};
const _hoisted_2$9 = ["content", "aria-label"];
const _hoisted_3$6 = {
  key: 1,
  class: "customHeaderLabel",
  role: "columnheader"
};
const _hoisted_4$5 = {
  key: 2,
  class: "flex"
};
const _hoisted_5$5 = {
  key: 0,
  class: "w-24 inline-block"
};
const _hoisted_6$4 = {
  key: 1,
  class: "customSortDownLabel"
};
const _hoisted_7$4 = {
  key: 2,
  class: "customSortUpLabel"
};
const _hoisted_8$3 = ["content", "aria-label", "disabled"];
const _hoisted_9$2 = ["content", "aria-label", "disabled"];
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "custom-header",
  props: ["params"],
  setup(__props) {
    const { t } = useI18n();
    const props = __props;
    const el = ref();
    const sort = ref(0);
    const sortable = ref(false);
    const canMoveLeft = ref(false);
    const canMoveRight = ref(false);
    const columnApi = ref(null);
    const onColumnReorder = () => {
      const columns = columnApi.value.getAllDisplayedColumns();
      const columnIdx = columns.indexOf(props.params.column);
      canMoveLeft.value = columnIdx > 3 && !columns[columnIdx - 1].colDef.isStatic;
      canMoveRight.value = columnIdx < columns.length - 1 && !columns[columnIdx + 1].colDef.isStatic;
    };
    const moveLeft = () => {
      const columns = columnApi.value.getAllDisplayedColumns();
      const allColumns = columnApi.value.getAllGridColumns();
      const index = allColumns.indexOf(columns[columns.indexOf(props.params.column) - 1]);
      if (canMoveLeft.value) {
        columnApi.value.moveColumn(props.params.column, index);
        props.params.api.ensureColumnVisible(allColumns[index]);
        el.value?.closest(".ag-header-row")?.querySelector(`[col-id="${props.params.column.colId}"]`)?.querySelector(".move-left")?.focus();
      }
    };
    const moveRight = () => {
      const columns = columnApi.value.getAllDisplayedColumns();
      const allColumns = columnApi.value.getAllGridColumns();
      const index = allColumns.indexOf(columns[columns.indexOf(props.params.column) + 1]);
      if (canMoveRight.value) {
        columnApi.value.moveColumn(props.params.column, index);
        props.params.api.ensureColumnVisible(allColumns[index]);
      }
    };
    const onSortRequested = (event) => {
      sort.value = (sort.value + 1) % 3;
      if (sort.value === 1) {
        props.params.setSort("asc", event.shiftKey);
      } else if (sort.value === 2) {
        props.params.setSort("desc", event.shiftKey);
      } else {
        props.params.setSort("none", event.shiftKey);
      }
    };
    onMounted(() => {
      sortable.value = props.params.column.colDef.sortable;
      columnApi.value = props.params.columnApi;
      if (props.params.sort === "asc") {
        sort.value = 1;
        props.params.setSort("asc");
      } else if (props.params.sort === "desc") {
        sort.value = 2;
        props.params.setSort("desc");
      }
      onColumnReorder();
      props.params.column.addEventListener("leftChanged", () => {
        onColumnReorder();
      });
    });
    onBeforeUnmount(() => {
      props.params.column.removeEventListener("leftChanged", () => {
        onColumnReorder();
      });
    });
    return (_ctx, _cache) => {
      const _directive_truncate = resolveDirective("truncate");
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", {
        class: "ag-custom-header flex flex-1 items-center h-full w-full",
        ref_key: "el",
        ref: el
      }, [
        sortable.value ? (openBlock(), createElementBlock("div", _hoisted_1$b, [
          withDirectives((openBlock(), createElementBlock("button", {
            type: "button",
            onClick: _cache[0] || (_cache[0] = ($event) => onSortRequested($event)),
            content: unref(t)(`grid.header.sort.${sort.value}`),
            "aria-label": unref(t)(`grid.header.sort.${sort.value}`),
            class: "customHeaderLabel hover:bg-gray-300 font-bold p-8 max-w-full",
            role: "columnheader",
            tabindex: "-1"
          }, [
            withDirectives((openBlock(), createElementBlock("div", null, [
              createTextVNode(toDisplayString(__props.params.displayName), 1)
            ])), [
              [_directive_truncate, { externalTrigger: true }]
            ])
          ], 8, _hoisted_2$9)), [
            [_directive_tippy, { placement: "top", hideOnClick: false }]
          ])
        ])) : withDirectives((openBlock(), createElementBlock("span", _hoisted_3$6, [
          createTextVNode(toDisplayString(__props.params.displayName), 1)
        ])), [
          [_directive_truncate]
        ]),
        sortable.value ? (openBlock(), createElementBlock("div", _hoisted_4$5, [
          __props.params.enableSorting && sort.value === 0 ? (openBlock(), createElementBlock("span", _hoisted_5$5)) : createCommentVNode("", true),
          __props.params.enableSorting && sort.value === 1 ? (openBlock(), createElementBlock("span", _hoisted_6$4, _cache[3] || (_cache[3] = [
            createElementVNode("div", { class: "md-icon-small" }, [
              createElementVNode("svg", {
                height: "24",
                width: "24"
              }, [
                createElementVNode("g", { id: "arrow_upward" }, [
                  createElementVNode("path", { d: "M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z" })
                ])
              ])
            ], -1)
          ]))) : createCommentVNode("", true),
          __props.params.enableSorting && sort.value === 2 ? (openBlock(), createElementBlock("span", _hoisted_7$4, _cache[4] || (_cache[4] = [
            createElementVNode("div", { class: "md-icon-small" }, [
              createElementVNode("svg", {
                height: "24",
                width: "24"
              }, [
                createElementVNode("g", { id: "arrow_downward" }, [
                  createElementVNode("path", { d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z" })
                ])
              ])
            ], -1)
          ]))) : createCommentVNode("", true),
          withDirectives((openBlock(), createElementBlock("button", {
            type: "button",
            content: unref(t)("grid.header.reorder.left"),
            "aria-label": unref(t)("grid.header.reorder.left"),
            onClick: _cache[1] || (_cache[1] = ($event) => moveLeft()),
            class: "move-left opacity-60 hover:opacity-90 disabled:opacity-30 disabled:cursor-default flex justify-center items-center",
            tabindex: "-1",
            disabled: !canMoveLeft.value
          }, _cache[5] || (_cache[5] = [
            createElementVNode("div", { class: "inline-block" }, [
              createElementVNode("svg", {
                height: "24",
                width: "24"
              }, [
                createElementVNode("g", { id: "keyboard_arrow_left" }, [
                  createElementVNode("path", { d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z" })
                ])
              ])
            ], -1)
          ]), 8, _hoisted_8$3)), [
            [_directive_tippy, { placement: "top" }]
          ]),
          withDirectives((openBlock(), createElementBlock("button", {
            type: "button",
            content: unref(t)("grid.header.reorder.right"),
            "aria-label": unref(t)("grid.header.reorder.right"),
            onClick: _cache[2] || (_cache[2] = ($event) => moveRight()),
            class: "move-right opacity-60 hover:opacity-90 disabled:opacity-30 disabled:cursor-default flex justify-center items-center",
            tabindex: "-1",
            disabled: !canMoveRight.value
          }, _cache[6] || (_cache[6] = [
            createElementVNode("div", { class: "inline-block" }, [
              createElementVNode("svg", {
                height: "24",
                width: "24"
              }, [
                createElementVNode("g", { id: "keyboard_arrow_right" }, [
                  createElementVNode("path", { d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z" })
                ])
              ])
            ], -1)
          ]), 8, _hoisted_9$2)), [
            [_directive_tippy, { placement: "top" }]
          ])
        ])) : createCommentVNode("", true)
      ], 512);
    };
  }
});

const _hoisted_1$a = ["content"];
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "details-button-renderer",
  props: ["params"],
  setup(__props) {
    const props = __props;
    const { t } = useI18n();
    const iApi = inject("iApi");
    const el = ref();
    const openDetails = async () => {
      const rowData = props.params.data;
      const layerUid = rowData["rvUid"];
      const layer = iApi.geo.layer.getLayer(layerUid);
      const realOidField = layer.oidField;
      const mapperPair = props.params.layerCols[layer.id].find(
        (attrPair) => {
          return attrPair.origAttr === realOidField;
        }
      );
      const dataOidField = mapperPair?.mappedAttr || realOidField;
      const sourceGraphic = await layer.getGraphic(rowData[dataOidField], {
        getAttribs: true
      });
      iApi.event.emit(
        GlobalEvents.DETAILS_TOGGLE,
        {
          data: sourceGraphic.attributes,
          uid: layerUid,
          format: IdentifyResultFormat.ESRI
        },
        true
      );
      if (props.params.isTeleport) {
        iApi.scrollToInstance();
      }
    };
    onMounted(() => {
      props.params.eGridCell.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          openDetails();
        }
      });
      props.params.eGridCell.addEventListener("focus", () => {
        el.value._tippy.show();
      });
      props.params.eGridCell.addEventListener("blur", () => {
        el.value._tippy.hide();
      });
    });
    onBeforeUnmount(() => {
      props.params.eGridCell.removeEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          openDetails();
        }
      });
      props.params.eGridCell.removeEventListener("focus", () => {
        el.value._tippy.show();
      });
      props.params.eGridCell.removeEventListener("blur", () => {
        el.value._tippy.hide();
      });
    });
    return (_ctx, _cache) => {
      const _directive_tippy = resolveDirective("tippy");
      return withDirectives((openBlock(), createElementBlock("button", {
        type: "button",
        class: "flex items-center justify-center w-40 h-36",
        content: unref(t)("grid.cells.details"),
        onClick: openDetails,
        tabindex: "-1",
        ref_key: "el",
        ref: el
      }, _cache[0] || (_cache[0] = [
        createElementVNode("svg", {
          class: "m-auto",
          xmlns: "http://www.w3.org/2000/svg",
          height: "16",
          viewBox: "0 0 24 24",
          width: "16"
        }, [
          createElementVNode("path", {
            d: "M0 0h24v24H0z",
            fill: "none"
          }),
          createElementVNode("path", {
            style: { "fill": "#979797" },
            d: "M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"
          })
        ], -1)
      ]), 8, _hoisted_1$a)), [
        [_directive_tippy, { placement: "top" }]
      ]);
    };
  }
});

const _hoisted_1$9 = ["content"];
const _hoisted_2$8 = {
  key: 0,
  class: "m-auto animate-spin spinner h-20 w-20"
};
const _hoisted_3$5 = {
  key: 1,
  xmlns: "http://www.w3.org/2000/svg",
  fill: "none",
  viewBox: "0 0 24 24",
  "stroke-width": "1.5",
  stroke: "green",
  class: "w-20 h-20"
};
const _hoisted_4$4 = {
  key: 2,
  xmlns: "http://www.w3.org/2000/svg",
  fill: "none",
  viewBox: "0 0 24 24",
  "stroke-width": "1.5",
  stroke: "red",
  class: "w-20 h-20"
};
const _hoisted_5$4 = ["innerHTML"];
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "zoom-button-renderer",
  props: ["params"],
  setup(__props) {
    const zoomStatus = ref("none");
    const props = __props;
    const iApi = inject("iApi");
    const layerStore = useLayerStore();
    const button = ref();
    const { t } = useI18n();
    const isMapLayer = computed(() => {
      const layer = layerStore.getLayerByUid(props.params.data.rvUid);
      return !!layer && layer.mapLayer;
    });
    const zoomToFeature = () => {
      if (zoomStatus.value !== "none") {
        return;
      }
      zoomStatus.value = "zooming";
      const layer = layerStore.getLayerByUid(props.params.data.rvUid);
      if (layer === void 0 || !layer.isLoaded) {
        updateZoomStatus("error");
        return;
      }
      const oidPair = props.params.layerCols[layer.id].find((pair) => pair.origAttr === layer.oidField);
      const oid = props.params.data[oidPair ? oidPair.mappedAttr ?? oidPair.origAttr : layer.oidField];
      const zoomUsingGraphic = () => {
        const opts = { getGeom: true };
        layer.getGraphic(oid, opts).then((g) => {
          if (g.geometry.invalid()) {
            console.error(`Could not find graphic for objectid ${oid}`);
            updateZoomStatus("error");
          } else {
            iApi.geo.map.zoomMapTo(g.geometry);
            updateZoomStatus("zoomed");
            iApi.updateAlert(iApi.$i18n.t("grid.cells.alert.zoom"));
            if (props.params.isTeleport) {
              iApi.scrollToInstance();
            }
          }
        }).catch(() => {
          updateZoomStatus("error");
        });
      };
      if (layer.layerType === LayerType.FEATURE && layer.geomType !== GeometryType.POINT) {
        layer.getGraphicExtent(oid).then((e) => {
          iApi.geo.map.zoomMapTo(e);
          updateZoomStatus("zoomed");
          iApi.updateAlert(iApi.$i18n.t("grid.cells.alert.zoom"));
          if (props.params.isTeleport) {
            iApi.scrollToInstance();
          }
        }).catch(() => {
          zoomUsingGraphic();
        });
      } else {
        zoomUsingGraphic();
      }
    };
    const updateZoomStatus = (value) => {
      if (value === "zoomed" || value === "error") {
        setTimeout(() => {
          zoomStatus.value = value;
          button.value?._tippy.show();
          setTimeout(() => {
            button.value?._tippy.hide();
            zoomStatus.value = "none";
          }, 3e3);
        }, 300);
      } else {
        zoomStatus.value = value;
      }
    };
    onMounted(() => {
      if (isMapLayer.value) {
        props.params.eGridCell.addEventListener("keydown", (e) => {
          if (e.key === "Enter" && zoomStatus.value === "none") {
            zoomToFeature();
          }
        });
        props.params.eGridCell.addEventListener("focus", () => {
          button.value?._tippy.show();
        });
        props.params.eGridCell.addEventListener("blur", () => {
          button.value?._tippy.hide();
        });
      }
    });
    onBeforeUnmount(() => {
      if (isMapLayer.value) {
        props.params.eGridCell.removeEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            zoomToFeature();
          }
        });
        props.params.eGridCell.removeEventListener("focus", () => {
          button.value?._tippy.show();
        });
        props.params.eGridCell.removeEventListener("blur", () => {
          button.value?._tippy.hide();
        });
      }
    });
    return (_ctx, _cache) => {
      const _directive_tippy = resolveDirective("tippy");
      return isMapLayer.value ? withDirectives((openBlock(), createElementBlock("button", {
        key: 0,
        type: "button",
        class: "flex items-center justify-center w-40 h-36",
        content: unref(t)(`grid.cells.zoom${zoomStatus.value === "none" ? "" : `.${zoomStatus.value}`}`),
        onClick: zoomToFeature,
        tabindex: "-1",
        ref_key: "button",
        ref: button
      }, [
        zoomStatus.value === "zooming" ? (openBlock(), createElementBlock("div", _hoisted_2$8)) : zoomStatus.value === "zoomed" ? (openBlock(), createElementBlock("svg", _hoisted_3$5, _cache[0] || (_cache[0] = [
          createElementVNode("path", {
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M4.5 12.75l6 6 9-13.5"
          }, null, -1)
        ]))) : zoomStatus.value === "error" ? (openBlock(), createElementBlock("svg", _hoisted_4$4, _cache[1] || (_cache[1] = [
          createElementVNode("path", {
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            d: "M6 18L18 6M6 6l12 12"
          }, null, -1)
        ]))) : (openBlock(), createElementBlock("span", {
          key: 3,
          innerHTML: unref(iApi).ui.getZoomIcon()
        }, null, 8, _hoisted_5$4))
      ], 8, _hoisted_1$9)), [
        [_directive_tippy, { placement: "top" }]
      ]) : createCommentVNode("", true);
    };
  }
});

const _hoisted_1$8 = ["content"];
const _hoisted_2$7 = ["innerHTML"];
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "custom-button-renderer",
  props: ["params"],
  setup(__props) {
    const props = __props;
    const iApi = inject("iApi");
    const el = ref();
    const isButtonVisible = computed(() => {
      let data = Object.assign({}, props.params.data);
      const layer = iApi.geo.layer.getLayer(data["rvUid"]);
      const visibility = props.params.config.displayOn;
      if (!layer || visibility === "geo" && !layer.mapLayer || visibility === "data" && layer.mapLayer) {
        return false;
      }
      return true;
    });
    const onButtonClick = () => {
      let data = Object.assign({}, props.params.data);
      const layer = iApi.geo.layer.getLayer(data["rvUid"]);
      const oidPair = props.params.layerCols[layer.id].find((pair) => pair.origAttr === layer.oidField);
      const oid = oidPair.mappedAttr ? data[oidPair.mappedAttr] : data[oidPair.origAttr];
      layer.getGraphic(oid, { getAttribs: true }).then((g) => {
        iApi.event.emit(props.params.config.actionEvent, {
          data: g.attributes,
          layer,
          uid: props.params.data.rvUid,
          oid
        });
      });
    };
    onMounted(() => {
      props.params.eGridCell.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          onButtonClick();
        }
      });
      props.params.eGridCell.addEventListener("focus", () => {
        el.value._tippy.show();
      });
      props.params.eGridCell.addEventListener("blur", () => {
        el.value._tippy.hide();
      });
    });
    onBeforeUnmount(() => {
      props.params.eGridCell.removeEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          onButtonClick();
        }
      });
      props.params.eGridCell.removeEventListener("focus", () => {
        el.value._tippy.show();
      });
      props.params.eGridCell.removeEventListener("blur", () => {
        el.value._tippy.hide();
      });
    });
    return (_ctx, _cache) => {
      const _directive_tippy = resolveDirective("tippy");
      return isButtonVisible.value ? withDirectives((openBlock(), createElementBlock("button", {
        key: 0,
        type: "button",
        class: "flex items-center justify-center w-42 h-38",
        content: props.params.config.tooltip,
        onClick: onButtonClick,
        tabindex: "-1",
        ref_key: "el",
        ref: el
      }, [
        createElementVNode("span", {
          innerHTML: props.params.config.icon
        }, null, 8, _hoisted_2$7)
      ], 8, _hoisted_1$8)), [
        [_directive_tippy, { placement: "top" }]
      ]) : createCommentVNode("", true);
    };
  }
});

const _hoisted_1$7 = ["name", "content", "innerHTML"];
const _hoisted_2$6 = ["content"];
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "cell-renderer",
  props: ["params"],
  setup(__props) {
    const panelStore = usePanelStore();
    const iApi = inject("iApi");
    const { t } = useI18n();
    const copyTooltip = ref();
    const el = ref();
    const isCopied = ref(false);
    const props = __props;
    const mobileMode = computed(() => panelStore.mobileView);
    const copy = () => {
      if (!el.value?.textContent) {
        return;
      }
      isCopied.value = true;
      copyTooltip.value?._tippy.show();
      navigator.clipboard.writeText(el.value?.textContent);
      setTimeout(() => {
        isCopied.value = false;
      }, 2e3);
    };
    const formatValue = computed(() => {
      if (props.params.type === "number") {
        if (props.params.value == null) return "";
        return iApi.ui.formatNumber(props.params.value);
      } else if (props.params.type === "date") {
        return props.params.value == null ? "" : new Date(props.params.value).toISOString().slice(0, 10);
      } else if (props.params.type === "string") {
        if (!props.params.value) {
          return props.params.value;
        }
        if (/<a[^>]*>[^<]+<\/a>/g.test(props.params.value)) {
          return props.params.value;
        }
        return linkifyHtml(props.params.value, {
          target: "_blank",
          validate: {
            url: (value) => /^https?:\/\//.test(value)
            // only links that begin with a protocol will be hyperlinked
          }
        });
      }
      return "";
    });
    const containsLinks = computed(() => {
      return /<a[^>]*>[^<]+<\/a>/g.test(props.params.value) || /(http(s)?:\/\/.*)/g.test(props.params.value);
    });
    onMounted(() => {
      props.params.eGridCell.addEventListener("dblclick", () => {
        copy();
      });
      props.params.eGridCell.addEventListener("keydown", (e) => {
        if (e.ctrlKey && e.code === "KeyC") {
          copy();
        }
      });
      props.params.eGridCell.addEventListener("blur", () => {
        el.value._tippy.hide();
        copyTooltip.value?._tippy.hide();
      });
      props.params.eGridCell.addEventListener("focus", () => {
        el.value?._tippy.show();
        setTimeout(() => {
          if (document.activeElement === props.params.eGridCell) {
            copyTooltip.value?._tippy.show();
          }
        }, 1e3);
        if (el.value._tippy.reference.clientWidth >= el.value._tippy.reference.scrollWidth) {
          el.value._tippy.hide();
        }
      });
    });
    onBeforeUnmount(() => {
      props.params.eGridCell.removeEventListener("dblclick", () => {
        copy();
      });
      props.params.eGridCell.removeEventListener("keydown", (e) => {
        if (e.ctrlKey && e.code === "KeyC") {
          copy();
        }
      });
      props.params.eGridCell.removeEventListener("blur", () => {
        el.value._tippy.hide();
        copyTooltip.value?._tippy.hide();
      });
      props.params.eGridCell.removeEventListener("focus", () => {
        el.value._tippy.show();
        copyTooltip.value?._tippy.show();
      });
    });
    return (_ctx, _cache) => {
      const _directive_truncate = resolveDirective("truncate");
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", null, [
        withDirectives(createElementVNode("div", {
          name: formatValue.value,
          content: formatValue.value,
          tabindex: "-1",
          innerHTML: formatValue.value,
          ref_key: "el",
          ref: el
        }, null, 8, _hoisted_1$7), [
          [_directive_truncate, {
            options: {
              placement: "top",
              hideOnClick: false,
              theme: "ramp4",
              maxWidth: mobileMode.value ? 300 : 700,
              // remove this once scrollable tooltip option is implemented
              animation: "scale",
              interactive: containsLinks.value
            }
          }]
        ]),
        el.value?.textContent ? withDirectives((openBlock(), createElementBlock("div", {
          key: 0,
          ref_key: "copyTooltip",
          ref: copyTooltip,
          content: unref(t)(`grid.label.${isCopied.value ? "copied" : "copy"}`)
        }, null, 8, _hoisted_2$6)), [
          [_directive_tippy, {
            triggerTarget: el.value,
            placement: "bottom",
            theme: "ramp4",
            hideOnClick: false,
            delay: [1e3, 0]
          }]
        ]) : createCommentVNode("", true)
      ]);
    };
  }
});

const _hoisted_1$6 = { class: "pl-8" };
const _hoisted_2$5 = { class: "flex flex-col justify-center items-center h-full" };
const _hoisted_3$4 = { class: "flex flex-row" };
const _hoisted_4$3 = { class: "font-bold text-2xl" };
const _hoisted_5$3 = { class: "mt-20 text-xl" };
const _hoisted_6$3 = { class: "my-20" };
const _hoisted_7$3 = { class: "text-sm" };
const _hoisted_8$2 = ["aria-label"];
const _hoisted_9$1 = { class: "flex flex-wrap gap-y-8 items-center pl-8 pb-8" };
const _hoisted_10$1 = { class: "flex flex-1 flex-col max-w-full mr-8" };
const _hoisted_11$1 = { class: "w-full font-bold" };
const _hoisted_12$1 = { class: "w-full text-sm" };
const _hoisted_13$1 = { key: 0 };
const _hoisted_14$1 = { class: "flex flex-1 grow-[1.4] items-center max-w-full" };
const _hoisted_15$1 = { class: "flex flex-1 min-w-0 items-center pb-4 mr-8" };
const _hoisted_16$1 = ["aria-label", "placeholder"];
const _hoisted_17$1 = { class: "-ml-30" };
const _hoisted_18$1 = {
  key: 0,
  xmlns: "http://www.w3.org/2000/svg",
  fit: "",
  preserveAspectRatio: "xMidYMid meet",
  viewBox: "0 0 24 24",
  focusable: "false",
  class: "fill-current w-24 h-24 flex-shrink-0"
};
const _hoisted_19$1 = { class: "pb-2 flex ml-auto justify-end" };
const _hoisted_20$1 = ["content", "aria-label"];
const _hoisted_21$1 = ["aria-label"];
const _hoisted_22$1 = { class: "md-icon-small inline items-start" };
const _hoisted_23$1 = {
  key: 0,
  height: "18",
  width: "18",
  viewBox: "0 0 24 24",
  class: "inline float-right"
};
const _hoisted_24$1 = ["aria-label"];
const _hoisted_25$1 = { class: "md-icon-small inline items-start" };
const _hoisted_26$1 = {
  key: 0,
  height: "18",
  width: "18",
  viewBox: "0 0 24 24",
  class: "inline float-right"
};
const _hoisted_27$1 = ["aria-label"];
const _hoisted_28$1 = { class: "md-icon-small inline items-start" };
const _hoisted_29$1 = {
  key: 0,
  height: "18",
  width: "18",
  viewBox: "0 0 24 24",
  class: "inline float-right"
};
const _hoisted_30$1 = ["aria-label"];
const _hoisted_31$1 = {
  key: 0,
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  class: "fill-current inline w-20 h-20 mr-2 text-gray-500"
};
const _hoisted_32$1 = {
  key: 1,
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  class: "fill-current inline w-20 h-20 mr-2 text-gray-500"
};
const _hoisted_33$1 = {
  key: 2,
  height: "18",
  width: "18",
  viewBox: "0 0 24 24",
  class: "inline float-right"
};
const _hoisted_34$1 = ["aria-label"];
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "table-component",
  props: {
    panel: {
      type: PanelInstance,
      required: true
    },
    gridId: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    const NUM_TYPES = [FieldType.OID, FieldType.DOUBLE, FieldType.SINGLE, FieldType.INTEGER];
    const iApi = inject("iApi");
    const gridStore = useGridStore();
    const panelStore = usePanelStore();
    const mobileView = computed(() => panelStore.mobileView);
    const pinned = ref(!mobileView.value);
    const el = ref();
    const { t, locale } = useI18n();
    const forceUpdate = () => getCurrentInstance()?.proxy?.$forceUpdate();
    const props = __props;
    const config = ref({
      id: "dummy",
      layerIds: [],
      state: new TableStateManager(),
      fieldMap: {}
    });
    const showGrid = ref(true);
    const agGridApi = ref(new GridApi());
    const agGridOptions = ref();
    const frameworkComponents = ref();
    const isLoadingGrid = ref(false);
    const isErrorGrid = ref(false);
    const loadedRecordCount = ref([]);
    const totalRecordCount = ref(0);
    const handlers = ref([]);
    const watchers = ref([]);
    const gridTitle = ref("");
    const columnApi = ref(new ColumnApi());
    const columnDefs = ref([]);
    const rowData = ref([]);
    const oidField = ref("OBJECTID");
    const gridAccessibilityManager = ref(void 0);
    const onCellKeyPress = GridAccessibilityManager.onCellKeyPress;
    const filterInfo = ref({ firstRow: 0, lastRow: 0, visibleRows: 0 });
    const filteredOids = ref({});
    const layer = iApi.geo.layer.getLayer(props.gridId);
    const layerCols = ref({});
    const origLayerIds = ref(gridStore.grids[props.gridId].layerIds);
    const gridLayers = computed(() => {
      if (gridStore.grids[props.gridId]) {
        return gridStore.grids[props.gridId].layerIds.map((id) => iApi.geo.layer.getLayer(id)).filter((layer2) => layer2 !== void 0);
      } else return [];
    });
    const systemCols = ref(/* @__PURE__ */ new Set());
    const filterQueue = ref([]);
    const onGridReady = (params) => {
      agGridApi.value = params.api;
      columnApi.value = params.columnApi;
      gridTitle.value = config.value.state.title || layer?.name || props.gridId;
      updateFilterInfo();
      if (rowData.value.length > 0) {
        columnApi.value.autoSizeAllColumns();
      }
      const addAriaLabels = () => {
        const checkboxInputs = document.querySelectorAll(".ag-input-field-input.ag-checkbox-input");
        checkboxInputs.forEach((input, index) => {
          const allColumns = columnApi.value.getAllDisplayedColumns();
          const column = allColumns[index].getColDef();
          input.setAttribute("aria-label", column.headerName ?? t("grid.label.specialColumn"));
        });
      };
      addAriaLabels();
      agGridApi.value.addEventListener("rowDataChanged", addAriaLabels);
      handlers.value.push(
        iApi.event.on(GlobalEvents.FILTER_CHANGE, ({ uid, filterKey }) => {
          if (filterKey !== CoreFilter.GRID && uid && gridLayers.value.map((layer2) => layer2.uid).includes(uid)) {
            applyLayerFilters();
          }
        })
      );
      handlers.value.push(
        iApi.event.on(
          GlobalEvents.LAYER_VISIBILITYCHANGE,
          ({ layer: layer2 }) => {
            if (layer2.uid && gridLayers.value.map((layer3) => layer3.uid).includes(layer2.uid)) {
              applyLayerFilters();
            }
          }
        )
      );
      handlers.value.push(
        iApi.event.on(GlobalEvents.LAYER_RELOAD_END, (reloadedLayer) => {
          reloadedLayer.loadPromise().then(() => {
            if (gridLayers.value.map((layer2) => layer2.uid).includes(reloadedLayer.uid)) {
              applyLayerFilters();
            }
          });
        })
      );
      handlers.value.push(
        iApi.event.on(GlobalEvents.CONFIG_CHANGE, () => {
          agGridApi.value.redrawRows({
            force: true
          });
        })
      );
      handlers.value.push(
        iApi.event.on(
          GlobalEvents.MAP_EXTENTCHANGE,
          debounce(100, () => {
            if (config.value.state.filterByExtent) {
              applyLayerFilters();
            }
          })
        )
      );
      handlers.value.push(
        iApi.event.on(GlobalEvents.LAYER_REMOVE, (removedLayer) => {
          if (origLayerIds.value.includes(removedLayer.id) && gridLayers.value.length !== 0) {
            setUpColumns();
          }
        })
      );
      applyLayerFilters();
    };
    const gridRendered = () => {
      columnApi.value.autoSizeAllColumns();
      gridAccessibilityManager.value = new GridAccessibilityManager(
        el.value,
        agGridApi.value,
        columnApi.value
      );
    };
    const updateQuickSearch = () => {
      agGridApi.value.setQuickFilter(config.value.state.searchFilter);
    };
    const resetQuickSearch = () => {
      config.value.state.searchFilter = "";
      updateQuickSearch();
    };
    const clearSearchAndFilters = () => {
      resetQuickSearch();
      clearFilters();
      applyLayerFilters();
    };
    const toggleFilterByExtent = () => {
      config.value.state.filterByExtent = !config.value.state.filterByExtent;
      applyLayerFilters();
    };
    const toggleShowFilters = () => {
      let colDefs = agGridOptions.value.api.getColumnDefs();
      config.value.state.colFilter = !config.value.state.colFilter;
      colDefs.forEach((col) => {
        col.floatingFilter = config.value.state.colFilter;
      });
      agGridOptions.value.api.setColumnDefs(colDefs);
    };
    const updateFilterInfo = () => {
      if (agGridApi.value && !isLoadingGrid.value) {
        if (config.value.state.searchFilter !== "") updateQuickSearch();
        if (config.value.state.applyToMap) {
          applyFiltersToMap();
        }
        nextTick(() => {
          let cols = columnApi.value.getAllDisplayedColumns();
          agGridOptions.value.api.refreshCells({
            columns: [cols[0]]
            // Limits the refresh action to the row number column.
          });
          updateRowInfo();
        });
      }
    };
    const updateRowInfo = () => {
      filterInfo.value.firstRow = agGridApi.value.getFirstDisplayedRow() + 1;
      filterInfo.value.lastRow = agGridApi.value.getLastDisplayedRow() + 1;
      filterInfo.value.visibleRows = agGridApi.value.getDisplayedRowCount();
    };
    const clearFilters = () => {
      agGridApi.value.setFilterModel({});
      config.value.state.clearFilters();
      agGridApi.value.refreshHeader();
    };
    const togglePinned = () => {
      pinned.value = !pinned.value;
      let cols = columnApi.value.getAllDisplayedColumns();
      columnApi.value.setColumnsPinned(cols.slice(1, 3), pinned.value ? "left" : "");
    };
    const exportData = () => {
      const columnsToExport = columnApi.value.getAllDisplayedColumns().filter((column) => !column.getColDef().preventExport);
      agGridApi.value.exportDataAsCsv({
        columnKeys: columnsToExport,
        suppressQuotes: true,
        processCellCallback: (cell) => {
          let cellType = cell.column.getColDef().cellRendererParams;
          if (!cell.value || cellType && cellType.type === "number") return cell.value;
          else if (cellType && cellType.type === "date")
            return `"${new Date(cell.value).toLocaleDateString("en-CA", {
              timeZone: "UTC",
              year: "numeric",
              month: "2-digit",
              day: "2-digit",
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit"
            })}"`;
          else return `"${cell.value.toString().replace(/"/g, '""')}"`;
        }
      });
    };
    const setUpDateFilter = (colDef, state) => {
      colDef.floatingFilterComponent = "dateFloatingFilter";
      colDef.filterParams.comparator = function(filterDate, entryDate) {
        let entry = new Date(entryDate);
        if (entry.getUTCFullYear() > filterDate.getUTCFullYear()) {
          return 1;
        } else if (entry.getUTCFullYear() < filterDate.getUTCFullYear()) {
          return -1;
        }
        if (entry.getUTCMonth() > filterDate.getUTCMonth()) {
          return 1;
        } else if (entry.getUTCMonth() < filterDate.getUTCMonth()) {
          return -1;
        }
        return entry.getUTCDate() - filterDate.getUTCDate();
      };
      colDef.filterParams.inRangeInclusive = true;
      colDef.floatingFilterComponentParams = {
        suppressFilterButton: true,
        stateManager: state
      };
    };
    const setUpSelectorFilter = (colDef, rowData2, state) => {
      colDef.floatingFilterComponent = "selectorFloatingFilter";
      colDef.filterParams.inRangeInclusive = true;
      colDef.floatingFilterComponentParams = {
        suppressFilterButton: true,
        stateManager: state,
        rowData: rowData2
      };
    };
    const setUpNumberFilter = (colDef, state) => {
      colDef.floatingFilterComponent = "numberFloatingFilter";
      colDef.filterParams.inRangeInclusive = true;
      colDef.floatingFilterComponentParams = {
        suppressFilterButton: true,
        stateManager: state
      };
    };
    const setUpTextFilter = (colDef, state) => {
      colDef.floatingFilterComponent = "textFloatingFilter";
      colDef.floatingFilterComponentParams = {
        suppressFilterButton: true,
        stateManager: state
      };
      colDef.filterParams.textMatcher = function(params) {
        const newFilterText = params.filterText.replace(/\*/, "\\*").replace(/[()\[\]]/g, "\\$&");
        const re = new RegExp(`^.*${newFilterText}.*`);
        return re.test(params.value);
      };
      let disregardAccents = function(s) {
        let r = s.toLowerCase();
        r = r.replace(new RegExp("[àáâãäå]", "g"), "a");
        r = r.replace(new RegExp("æ", "g"), "ae");
        r = r.replace(new RegExp("ç", "g"), "c");
        r = r.replace(new RegExp("[èéêë]", "g"), "e");
        r = r.replace(new RegExp("[ìíîï]", "g"), "i");
        r = r.replace(new RegExp("ñ", "g"), "n");
        r = r.replace(new RegExp("[òóôõö]", "g"), "o");
        r = r.replace(new RegExp("œ", "g"), "oe");
        r = r.replace(new RegExp("[ùúûü]", "g"), "u");
        r = r.replace(new RegExp("[ýÿ]", "g"), "y");
        return r;
      };
      colDef.filterParams.textFormatter = function(s) {
        return disregardAccents(s);
      };
    };
    const setUpSpecialColumns = (col, colDef, state) => {
      if (col.field === "rvRowIndex") {
        let indexDef = {
          sortable: false,
          lockPosition: true,
          valueGetter: "node.rowIndex + 1",
          suppressMovable: true,
          suppressMenu: true,
          floatingFilter: config.value.state.colFilter,
          pinned: "left",
          maxWidth: 42,
          cellStyle: () => {
            return {
              "padding-left": "2px",
              "padding-right": "2px",
              display: "flex",
              "justify-content": "center"
            };
          },
          floatingFilterComponent: "clearFloatingFilter",
          floatingFilterComponentParams: {
            stateManager: state,
            clearFilters,
            suppressFilterButton: true
          },
          filter: true,
          preventExport: true
        };
        colDef.push(indexDef);
      }
      if (col.field === "rvInteractive") {
        const buttonControls = config.value.state.controls;
        let detailsDef = {
          sortable: false,
          pinned: mobileView.value ? "" : "left",
          filter: false,
          lockPosition: true,
          isStatic: true,
          maxWidth: 42,
          cellStyle: () => {
            return {
              padding: "0px"
            };
          },
          cellRenderer: _sfc_main$b,
          cellRendererParams: {
            $iApi: iApi,
            t,
            layerCols: layerCols.value,
            isTeleport: props.panel.teleport !== void 0
          },
          preventExport: true
        };
        if (buttonControls.includes("details")) {
          colDef.push(detailsDef);
        }
        if (hasMapLayers.value) {
          let zoomDef = {
            sortable: false,
            pinned: mobileView.value ? "" : "left",
            filter: false,
            lockPosition: true,
            isStatic: true,
            maxWidth: 42,
            cellStyle: () => {
              return {
                padding: "0px"
              };
            },
            cellRenderer: _sfc_main$a,
            cellRendererParams: {
              $iApi: iApi,
              layerCols: layerCols.value,
              isTeleport: props.panel.teleport !== void 0
            },
            preventExport: true
          };
          if (buttonControls.includes("zoom")) {
            colDef.push(zoomDef);
          }
        }
        buttonControls.forEach((buttonConfig) => {
          if (buttonConfig === "zoom" || buttonConfig === "details") return;
          let buttonDef = {
            sortable: false,
            pinned: mobileView.value ? "" : "left",
            filter: false,
            lockPosition: true,
            isStatic: true,
            maxWidth: 42,
            cellStyle: () => {
              return {
                padding: "0px"
              };
            },
            cellRenderer: _sfc_main$9,
            cellRendererParams: {
              $iApi: iApi,
              t,
              layerCols: layerCols.value,
              config: buttonConfig
            },
            preventExport: true
          };
          colDef.push(buttonDef);
        });
      }
      if (col.field === "rvSymbol") {
        let iconDef = {
          sortable: false,
          filter: false,
          lockPosition: true,
          isStatic: true,
          maxWidth: 42,
          cellRenderer: (cell) => {
            const layer2 = iApi.geo.layer.getLayer(cell.data.rvUid);
            if (layer2 === void 0) return;
            const iconContainer = document.createElement("span");
            const oid = cell.data[oidField.value];
            layer2.getIcon(oid).then((i) => {
              iconContainer.innerHTML = i;
            });
            return iconContainer;
          },
          cellStyle: () => {
            return {
              paddingTop: "3px",
              textAlign: "center",
              paddingLeft: "5px",
              paddingRight: "0px"
            };
          },
          cellRendererParams: {
            $iApi: iApi,
            oidField: oidField.value
          },
          preventExport: true
        };
        colDef.push(iconDef);
      }
    };
    const isExternalFilterPresent = () => {
      return !Object.values(filteredOids.value).every((oids) => oids === void 0);
    };
    const doesExternalFilterPass = (node) => {
      const oids = filteredOids.value[node.data.rvUid];
      return oids === void 0 || oids.includes(node.data[oidField.value]);
    };
    const applyLayerFilters = async () => {
      const thisFilterDef = new DefPromise();
      const activeFilterPromises = filterQueue.value.slice().map((d) => d.getPromise());
      filterQueue.value.push(thisFilterDef);
      await Promise.all(activeFilterPromises);
      await Promise.all(
        gridLayers.value.map(async (layer2) => {
          if (layer2 && layer2.visibility) {
            await layer2.getFilterOIDs(
              [CoreFilter.GRID],
              config.value.state.filterByExtent ? iApi.geo.map.getExtent() : void 0
            ).then((oids) => {
              filteredOids.value[layer2.uid] = oids;
            });
          } else {
            filteredOids.value[layer2.uid] = [];
          }
        })
      );
      agGridApi.value.onFilterChanged();
      thisFilterDef.resolveMe();
      const idx = filterQueue.value.indexOf(thisFilterDef);
      if (idx === -1) {
        console.error("Grid could not find filter blocker in filter queue");
      } else {
        filterQueue.value.splice(idx, 1);
      }
    };
    const toggleFiltersToMap = () => {
      config.value.state.applyToMap = !config.value.state.applyToMap;
      applyFiltersToMap();
    };
    const applyFiltersToMap = () => {
      gridLayers.value.filter((layer2) => layer2.mapLayer).forEach((layer2) => {
        if (!config.value.state.applyToMap) {
          layer2.setSqlFilter(CoreFilter.GRID, "");
        } else {
          const mapFilterQuery = getFiltersQuery(layer2.id);
          layer2.setSqlFilter(CoreFilter.GRID, mapFilterQuery);
        }
      });
    };
    const getFiltersQuery = (id) => {
      const filterModel = agGridApi.value.getFilterModel();
      let colStrs = [];
      Object.keys(filterModel).forEach((col) => {
        const attrs = getAttrPair(id, col);
        if (attrs) {
          colStrs.push(filterToSql(attrs.origAttr, filterModel[col]));
        } else {
          colStrs.push("1=2");
        }
      });
      if (config.value.state.searchFilter && config.value.state.searchFilter.length > 0) {
        const globalSearchVal = globalSearchToSql(id) || "1=2";
        if (globalSearchVal.length > 0) {
          colStrs.push(`(${globalSearchVal})`);
        }
      }
      return colStrs.join(" AND ");
    };
    const filterToSql = (col, colFilter) => {
      switch (colFilter.filterType) {
        case "number": {
          switch (colFilter.type) {
            case "greaterThanOrEqual":
              return `${col} >= ${colFilter.filter}`;
            case "lessThanOrEqual":
              return `${col} <= ${colFilter.filter}`;
            case "inRange":
              return `${col} >= ${colFilter.filter} AND ${col} <= ${colFilter.filterTo}`;
          }
          break;
        }
        case "text": {
          let val = colFilter.filter.replace(/'/g, /''/);
          if (val !== "") {
            const escRegex = /\\[(!"#$&'+,.\\/:;<=>?@[\]^`{|}~)]/g;
            let remVal = val;
            let newVal = "";
            let escMatch = escRegex.exec(val);
            let lastIdx = 0;
            while (escMatch) {
              newVal = newVal + val.substr(lastIdx, escMatch.index - lastIdx) + escMatch[0].slice(-1);
              lastIdx = escMatch.index + 2;
              remVal = val.substr(escMatch.index + 2);
              escMatch = escRegex.exec(val);
            }
            newVal = newVal + remVal;
            newVal = newVal.replace(/%/g, "ௌ%");
            newVal = newVal.replace(/_/g, "ௌ_");
            newVal = `*${newVal}`;
            let sqlWhere = `UPPER(${col}) LIKE '${newVal.replace(/\*/g, "%").toUpperCase()}%'`;
            return sqlWhere.includes("ௌ%") || sqlWhere.includes("ௌ_") ? `${sqlWhere} ESCAPE 'ௌ'` : sqlWhere;
          }
          break;
        }
        case "date": {
          const dateFrom = new Date(colFilter.dateFrom ?? 0);
          const dateTo = new Date(colFilter.dateTo ?? 864e13);
          const from = dateFrom ? `${dateFrom.getMonth() + 1}/${dateFrom.getDate()}/${dateFrom.getFullYear()}` : void 0;
          const to = dateTo ? `${dateTo.getMonth() + 1}/${dateTo.getDate()}/${dateTo.getFullYear()}` : void 0;
          switch (colFilter.type) {
            case "greaterThan":
              return `${col} >= DATE '${from}'`;
            case "lessThan":
              return `${col} <= DATE '${from}'`;
            case "inRange":
              return `${col} >= DATE '${from}' AND ${col} <= DATE '${to}'`;
          }
        }
      }
    };
    const globalSearchToSql = (id) => {
      let val = config.value.state.searchFilter.replace(/'/g, "''");
      const searchVals = val.split(" ");
      const sortedRows = agGridApi.value.rowModel.rowsToDisplay;
      const columns = columnApi.value.getAllDisplayedColumns().filter(
        (column) => (column.colDef.filter === "agTextColumnFilter" || column.colDef.filter === "agNumberColumnFilter") && getAttrPair(id, column.getColId())
      );
      let filteredColumns = [];
      sortedRows.forEach((row) => {
        let rowMatch = true;
        let rowSql = "";
        for (let searchVal of searchVals) {
          const re = new RegExp(`.*${searchVal.split(" ").join(".*").toUpperCase()}`);
          const filterVal = `%${searchVal.replace(/\*/g, "%").split(" ").join("%").toUpperCase()}`;
          let foundVal = false;
          for (let column of columns) {
            const colId = column.getColId();
            const origColId = getAttrPair(id, column.getColId())?.origAttr;
            const colDef = column.getColDef();
            if (row.data[colId] === void 0) {
              foundVal = false;
            } else if (colDef.filter === "agTextColumnFilter") {
              const cellData = row.data[colId] === null ? null : row.data[colId].toString();
              if (cellData !== null && re.test(cellData.toUpperCase())) {
                rowSql ? rowSql = rowSql.concat(" AND ", `(UPPER(${origColId}) LIKE '${filterVal}%')`) : rowSql = rowSql.concat("(", `(UPPER(${origColId}) LIKE '${filterVal}%')`);
                filteredColumns.includes(rowSql + ")") ? foundVal = false : foundVal = true;
                break;
              }
            } else if (colDef.filter === "agNumberColumnFilter") {
              const cellData = row.data[colId] === null ? null : row.data[colId];
              if (cellData !== null && re.test(cellData)) {
                rowSql ? rowSql = rowSql.concat(" AND ", `(${origColId} = ${cellData})`) : rowSql = rowSql.concat("(", `(${origColId} = ${cellData})`);
                filteredColumns.includes(rowSql + ")") ? foundVal = false : foundVal = true;
                break;
              }
            }
          }
          if (!foundVal) {
            rowMatch = false;
            break;
          }
        }
        if (rowMatch) {
          filteredColumns.push(rowSql + ")");
        }
      });
      return filteredColumns.join(" OR ");
    };
    const stopArrowKeyProp = (event) => {
      const arrowKeys = ["ArrowDown", "Down", "ArrowLeft", "Left", "ArrowUp", "Up", "ArrowRight", "Right"];
      if (arrowKeys.includes(event.key)) {
        event.stopPropagation();
      }
    };
    const closeGrid = () => {
      cancelAttributeLoad();
      if (props.panel.isOpen) {
        props.panel.close();
      }
    };
    const cancelAttributeLoad = () => {
      if (isLoadingGrid.value || isErrorGrid.value) {
        gridLayers.value.forEach((layer2) => {
          layer2.abortAttributeLoad();
          layer2.clearFeatureCache();
        });
      }
    };
    const filtersStatus = computed(() => {
      const filterable = gridLayers.value.map((layer2) => {
        return layer2.visibility && layer2.canModifyLayer && layer2.mapLayer;
      });
      const unmodifiableExists = gridLayers.value.some(
        (layer2) => layer2.visibility && layer2.mapLayer && !layer2.canModifyLayer
      );
      const filterableExists = filterable.some(Boolean);
      return unmodifiableExists && filterableExists ? "partial" : filterableExists ? "enabled" : "disabled";
    });
    const hasMapLayers = computed(
      () => gridLayers.value.some((layer2) => layer2.isLoaded && layer2.supportsFeatures && layer2.mapLayer)
    );
    const getAttrPair = (id, attr) => {
      return layerCols.value[id].find((layer2) => (layer2.mappedAttr ?? layer2.origAttr) === attr);
    };
    const setUpColumns = () => {
      const fancyLayers = gridLayers.value.filter(
        (layer2) => layer2 && layer2.supportsFeatures && layer2.isLoaded
      );
      if (fancyLayers.length === 0) {
        closeGrid();
      }
      totalRecordCount.value = fancyLayers.reduce((count, { featureCount }) => count + featureCount, 0);
      loadedRecordCount.value = new Array(gridLayers.value.length).fill(0);
      fancyLayers.forEach((fl, idx) => loadedRecordCount.value[idx] += fl.downloadedAttributes());
      fancyLayers.forEach((fl, idx) => {
        watchers.value.push(
          watch(
            () => fl.downloadedAttributes(),
            (count) => {
              loadedRecordCount.value[idx] = count;
            }
          )
        );
      });
      Promise.all(fancyLayers.map((l) => l.loadPromise())).then(() => {
        const tableAttributePromises = fancyLayers.map((fl) => {
          return markRaw(fl).getTabularAttributes().then((tabularAttrSet) => {
            const gridConfig = config?.value?.state?.state;
            if (gridConfig?.columns && gridConfig.columnMetadata?.exclusiveColumns) {
              const selectedColumnNames = gridConfig.columns.map((column) => column.field);
              tabularAttrSet.columns = tabularAttrSet.columns.filter(
                (column) => selectedColumnNames.includes(column.data)
              );
            }
            return tabularAttrSet;
          });
        });
        Promise.all(tableAttributePromises).then((tableAttributes) => {
          if (fancyLayers.every((fl) => fl.attribLoadAborted())) {
            isLoadingGrid.value = false;
            return;
          }
          const mergedTableAttrs = {
            columns: [],
            rows: [],
            fields: [],
            oidField: ""
          };
          tableAttributes.forEach((ta, idx) => {
            const attrMap = [];
            const id = fancyLayers[idx].id;
            ta.columns.forEach((col) => {
              if (config.value.fieldMap && config.value.fieldMap[col.data]) {
                attrMap.push({
                  origAttr: col.data,
                  mappedAttr: config.value.fieldMap[col.data]
                });
                col.data = config.value.fieldMap[col.data];
                col.title = col.data;
              } else {
                attrMap.push({
                  origAttr: col.data,
                  mappedAttr: void 0
                });
              }
              if (!mergedTableAttrs.columns.map((c) => c.data).includes(col.data)) {
                mergedTableAttrs.columns.push(col);
              }
            });
            mergedTableAttrs.rows = mergedTableAttrs.rows.concat(
              ta.rows.map((row) => {
                if (config.value.fieldMap) {
                  for (const [oldAttr, newAttr] of Object.entries(config.value.fieldMap)) {
                    if (row[oldAttr] !== void 0 && row[newAttr] === void 0) {
                      row[newAttr] = row[oldAttr];
                      delete row[oldAttr];
                    }
                  }
                }
                return row;
              })
            );
            for (let i = 0; i < mergedTableAttrs.rows.length; i++) {
              for (const [key] of Object.entries(mergedTableAttrs.rows[i])) {
                if (iApi.ui.isPlainText(mergedTableAttrs.rows[i][key])) {
                  mergedTableAttrs.rows[i][key] = iApi.ui.escapeHtml(mergedTableAttrs.rows[i][key]);
                }
              }
            }
            mergedTableAttrs.fields = mergedTableAttrs.fields.concat(
              ta.fields.map((field) => {
                if (!iApi.ui.exposeOids && field.type === "oid" || !iApi.ui.exposeMeasurements && (field.name.toLowerCase() === "shape_length" || field.name.toLowerCase() === "shape_area")) {
                  systemCols.value.add(field.name);
                }
                return {
                  name: config.value.fieldMap && config.value.fieldMap[field.name] ? config.value.fieldMap[field.name] : field.name,
                  type: field.type,
                  alias: field.alias ?? void 0,
                  length: field.length ?? void 0
                };
              })
            );
            mergedTableAttrs.oidField = config.value.fieldMap && config.value.fieldMap[ta.oidField] ? config.value.fieldMap[ta.oidField] : ta.oidField;
            layerCols.value[id] = attrMap;
          });
          oidField.value = mergedTableAttrs.oidField;
          ["rvRowIndex", "rvInteractive", "rvSymbol", ...mergedTableAttrs.columns].forEach((column) => {
            if (config.value.state?.columns[column.data] === void 0) {
              config.value.state.columns[column.data] = new ColumnStateManager({
                field: column.data,
                title: column.title
              });
            }
            if ((!iApi.ui.exposeOids || !iApi.ui.exposeMeasurements) && systemCols.value.has(column.data)) {
              config.value.state.columns[column.data].visible = false;
            }
            let colConfig = config.value.state?.columns[column.data];
            let col = {
              headerName: colConfig.title ?? column.title,
              headerComponent: "agColumnHeader",
              headerComponentParams: {
                sort: colConfig.sort
              },
              field: column.data ?? column,
              isSelector: colConfig.filter.type === "selector",
              sortable: true,
              lockPosition: true,
              filterParams: {},
              floatingFilter: config.value.state.colFilter && colConfig.searchable,
              hide: !colConfig?.visible,
              minWidth: colConfig.width,
              maxWidth: colConfig.width ?? 400,
              cellRenderer: (cell) => {
                return cell.value;
              },
              suppressHeaderKeyboardEvent: (params) => {
                const keyboardEvent = params.event;
                if (params.headerRowIndex === 0 && (keyboardEvent.key === "Enter" || !keyboardEvent.target.classList.contains("ag-header-cell") && keyboardEvent.key === "Tab")) {
                  return true;
                }
                return false;
              }
            };
            let fieldInfo = mergedTableAttrs.fields.find((field) => field.name === col.field);
            if (column === "rvRowIndex" || column === "rvSymbol" || column === "rvInteractive") {
              setUpSpecialColumns(col, columnDefs.value, config.value.state);
            } else {
              if (NUM_TYPES.indexOf(fieldInfo.type) > -1) {
                setUpNumberFilter(col, config.value.state);
                col.filter = "agNumberColumnFilter";
                col.autoHeight = true;
                col.cellRenderer = colConfig.template === "" ? _sfc_main$8 : iApi.component(colConfig.template);
                col.cellRendererParams = {
                  type: "number"
                };
              } else if (fieldInfo.type === FieldType.DATE) {
                setUpDateFilter(col, config.value.state);
                col.filter = "agDateColumnFilter";
                col.autoHeight = true;
                col.minWidth = 400;
                col.cellRenderer = colConfig.template === "" ? _sfc_main$8 : iApi.component(colConfig.template);
                col.cellRendererParams = {
                  type: "date"
                };
              } else if (fieldInfo.type === FieldType.STRING) {
                if (col.isSelector) {
                  setUpSelectorFilter(col, mergedTableAttrs.rows, config.value.state);
                } else {
                  setUpTextFilter(col, config.value.state);
                }
                col.filter = "agTextColumnFilter";
                col.autoHeight = true;
                col.cellRenderer = colConfig.template === "" ? _sfc_main$8 : iApi.component(colConfig.template);
                col.cellRendererParams = {
                  type: "string"
                };
              }
              columnDefs.value.push(col);
            }
          });
          rowData.value = markRaw(mergedTableAttrs.rows);
          columnDefs.value = markRaw(columnDefs.value);
          updateFilterInfo();
          isLoadingGrid.value = false;
        }).catch((e) => {
          console.error(e);
          isErrorGrid.value = true;
          isLoadingGrid.value = false;
        });
      });
    };
    onBeforeMount(() => {
      config.value = gridStore.grids[props.gridId];
      isLoadingGrid.value = true;
      forceUpdate();
      filterInfo.value = {
        firstRow: 0,
        lastRow: 0,
        visibleRows: 0
      };
      frameworkComponents.value = {
        agColumnHeader: _sfc_main$c,
        numberFloatingFilter: GridCustomNumberFilterV,
        textFloatingFilter: _sfc_main$g,
        selectorFloatingFilter: GridCustomSelectorFilterV,
        dateFloatingFilter: GridCustomDateFilterV,
        clearFloatingFilter: _sfc_main$d
      };
      agGridOptions.value = {
        // lets header navigation be predictable, otherwise focus lists will be out of sync as soon as a column is shifted
        ensureDomOrder: true,
        rowHeight: 40,
        suppressRowTransform: true,
        onFilterChanged: () => {
          applyFiltersToMap();
          updateFilterInfo();
        },
        onBodyScroll: () => {
          [...document.querySelectorAll("[id^=tippy]")].forEach((element) => {
            if (element._tippy && el.value?.contains(element._tippy.reference)) {
              element._tippy.hide();
            }
          });
        },
        onBodyScrollEnd: () => {
          updateRowInfo();
        },
        rowBuffer: 0,
        suppressColumnVirtualisation: true,
        // shift tab -> header, tab -> out of grid
        tabToNextCell: tabToNextCellHandler,
        // tab vertically instead of horizontally
        tabToNextHeader: tabToNextHeaderHandler,
        onModelUpdated: debounce(300, () => columnApi.value.autoSizeAllColumns())
      };
      setUpColumns();
      if (filtersStatus.value === "partial") {
        iApi.notify.show(NotificationType.WARNING, iApi.$i18n.t(`layer.filterwarning`));
      }
      watchers.value.push(
        watch(locale, () => {
          showGrid.value = false;
          setTimeout(() => {
            showGrid.value = true;
          }, 10);
        })
      );
      watchers.value.push(
        watch(filtersStatus, (newStatus) => {
          if (newStatus === "partial") {
            iApi.notify.show(NotificationType.WARNING, iApi.$i18n.t(`layer.filterwarning`));
          }
        })
      );
    });
    onBeforeUnmount(() => {
      cancelAttributeLoad();
      handlers.value.forEach((handler) => iApi.event.off(handler));
      watchers.value.forEach((unwatch) => unwatch());
      gridAccessibilityManager.value?.removeAccessibilityListeners();
      gridAccessibilityManager.value?.removeScrollListeners();
    });
    return (_ctx, _cache) => {
      const _component_dropdown_menu = resolveComponent("dropdown-menu");
      const _directive_truncate = resolveDirective("truncate");
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", {
        class: "flex flex-col w-full h-full bg-white",
        ref_key: "el",
        ref: el
      }, [
        withDirectives(createElementVNode("div", null, [
          createElementVNode("p", _hoisted_1$6, toDisplayString(unref(t)("grid.splash.error")), 1)
        ], 512), [
          [vShow, isErrorGrid.value]
        ]),
        withDirectives(createElementVNode("div", _hoisted_2$5, [
          createElementVNode("div", _hoisted_3$4, [
            createElementVNode("span", _hoisted_4$3, toDisplayString(loadedRecordCount.value.reduce((sum, count) => sum + count, 0)), 1),
            _cache[12] || (_cache[12] = createElementVNode("svg", {
              class: "stroke-black stroke-1",
              height: "50",
              width: "25"
            }, [
              createElementVNode("line", {
                x1: "0",
                y1: "50",
                x2: "25",
                y2: "0"
              })
            ], -1)),
            createElementVNode("span", _hoisted_5$3, toDisplayString(totalRecordCount.value), 1)
          ]),
          createElementVNode("div", _hoisted_6$3, [
            createElementVNode("span", _hoisted_7$3, toDisplayString(loadedRecordCount.value.reduce((sum, count) => sum + count, 0) < totalRecordCount.value ? unref(t)("grid.splash.loading") : unref(t)("grid.splash.building")), 1)
          ]),
          createElementVNode("div", null, [
            createElementVNode("button", {
              type: "button",
              onClick: closeGrid,
              class: "py-8 px-8 sm:px-16 bg-gray-300",
              "aria-label": unref(t)("grid.splash.cancel")
            }, toDisplayString(unref(t)("grid.splash.cancel")), 9, _hoisted_8$2)
          ])
        ], 512), [
          [vShow, isLoadingGrid.value && !isErrorGrid.value]
        ]),
        withDirectives(createElementVNode("div", _hoisted_9$1, [
          createElementVNode("div", _hoisted_10$1, [
            withDirectives((openBlock(), createElementBlock("div", _hoisted_11$1, [
              createTextVNode(toDisplayString(gridTitle.value), 1)
            ])), [
              [vShow, gridTitle.value !== ""],
              [_directive_truncate]
            ]),
            withDirectives((openBlock(), createElementBlock("div", _hoisted_12$1, [
              createTextVNode(toDisplayString(unref(t)("grid.filters.label.info", {
                range: filterInfo.value.visibleRows !== 0 ? `${filterInfo.value.firstRow} - ${filterInfo.value.lastRow}` : "0",
                total: filterInfo.value.visibleRows
              })) + " ", 1),
              filterInfo.value.visibleRows !== rowData.value.length ? (openBlock(), createElementBlock("span", _hoisted_13$1, toDisplayString(unref(t)("grid.filters.label.filtered", {
                max: rowData.value.length
              })), 1)) : createCommentVNode("", true)
            ])), [
              [_directive_truncate]
            ])
          ]),
          createElementVNode("div", _hoisted_14$1, [
            withDirectives(createElementVNode("div", _hoisted_15$1, [
              withDirectives(createElementVNode("input", {
                onInput: _cache[0] || (_cache[0] = ($event) => updateQuickSearch()),
                onKeypress: _cache[1] || (_cache[1] = withKeys(withModifiers(() => {
                }, ["prevent"]), ["enter"])),
                onKeyup: _cache[2] || (_cache[2] = withKeys(($event) => {
                  if (unref(panelStore).mobileView) {
                    $event?.target?.blur();
                  }
                }, ["enter"])),
                enterkeyhint: "done",
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => config.value.state.searchFilter = $event),
                class: "rv-global-search rv-input pr-32 min-w-0",
                "aria-invalid": "false",
                "aria-label": unref(t)("grid.filters.label.global"),
                placeholder: unref(t)("grid.filters.label.global")
              }, null, 40, _hoisted_16$1), [
                [vModelText, config.value.state.searchFilter]
              ]),
              createElementVNode("div", _hoisted_17$1, [
                config.value.state.searchFilter.length < 3 ? (openBlock(), createElementBlock("svg", _hoisted_18$1, _cache[13] || (_cache[13] = [
                  createElementVNode("g", { id: "search_cache224" }, [
                    createElementVNode("path", { d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" })
                  ], -1)
                ]))) : (openBlock(), createElementBlock("button", {
                  key: 1,
                  class: "flex justify-center fill-current ml-6 cursor-pointer",
                  onClick: _cache[4] || (_cache[4] = ($event) => resetQuickSearch())
                }, _cache[14] || (_cache[14] = [
                  createElementVNode("svg", {
                    "data-v-486a0302": "",
                    xmlns: "http://www.w3.org/2000/svg",
                    viewBox: "0 0 352 512",
                    class: "w-18 h-18 mt-2"
                  }, [
                    createElementVNode("path", {
                      "data-v-486a0302": "",
                      d: "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"
                    })
                  ], -1)
                ])))
              ])
            ], 512), [
              [vShow, config.value.state.search]
            ]),
            createElementVNode("div", _hoisted_19$1, [
              createVNode(_sfc_main$i, {
                columnApi: columnApi.value,
                columnDefs: columnDefs.value,
                systemCols: systemCols.value,
                onRefreshHeaders: _cache[5] || (_cache[5] = ($event) => agGridApi.value.refreshHeader())
              }, null, 8, ["columnApi", "columnDefs", "systemCols"]),
              withDirectives((openBlock(), createElementBlock("button", {
                type: "button",
                class: "grid-clearall p-4 h-40 text-gray-500 hover:text-black",
                onClick: _cache[6] || (_cache[6] = ($event) => clearSearchAndFilters()),
                content: unref(t)("grid.clearAll"),
                "aria-label": unref(t)("grid.clearAll")
              }, _cache[15] || (_cache[15] = [
                createElementVNode("svg", {
                  xmlns: "http://www.w3.org/2000/svg",
                  height: "24px",
                  width: "24px",
                  viewBox: "0 0 24 24",
                  class: "inline fill-current"
                }, [
                  createElementVNode("g", { id: "filter_cache958" }, [
                    createElementVNode("path", { d: "M 14.7574,20.8284L 17.6036,17.9822L 14.7574,15.1716L 16.1716,13.7574L 19.0178,16.568L 21.8284,13.7574L 23.2426,15.1716L 20.432,17.9822L 23.2426,20.8284L 21.8284,22.2426L 19.0178,19.3964L 16.1716,22.2426L 14.7574,20.8284 Z M 2,2L 19.9888,2.00001L 20,2.00001L 20,2.01122L 20,3.99999L 19.9207,3.99999L 13,10.9207L 13,22.909L 8.99999,18.909L 8.99999,10.906L 2.09405,3.99999L 2,3.99999L 2,2 Z " })
                  ])
                ], -1)
              ]), 8, _hoisted_20$1)), [
                [_directive_tippy, {
                  placement: "bottom"
                }]
              ]),
              createVNode(_component_dropdown_menu, {
                class: "h-40 w-40",
                position: "bottom-end",
                tooltip: unref(t)("panels.controls.optionsMenu"),
                centered: false
              }, {
                header: withCtx(() => _cache[16] || (_cache[16] = [
                  createElementVNode("svg", {
                    xmlns: "http://www.w3.org/2000/svg",
                    viewBox: "0 0 24 24",
                    class: "fill-current m-8 w-24 h-24"
                  }, [
                    createElementVNode("path", { d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" })
                  ], -1)
                ])),
                default: withCtx(() => [
                  createElementVNode("a", {
                    href: "javascript:;",
                    class: normalizeClass(["flex leading-snug items-center w-256", {
                      hover: filtersStatus.value !== "disabled" ? "none" : "text-black",
                      disabled: filtersStatus.value === "disabled"
                    }]),
                    onClick: _cache[7] || (_cache[7] = ($event) => filtersStatus.value !== "disabled" && toggleFiltersToMap()),
                    role: "button",
                    "aria-label": unref(t)("grid.label.filters.apply")
                  }, [
                    createElementVNode("div", _hoisted_22$1, [
                      _cache[18] || (_cache[18] = createElementVNode("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        viewBox: "0 0 24 24",
                        class: "fill-current inline w-20 h-20 mr-2 text-gray-500"
                      }, [
                        createElementVNode("path", { d: "m 15.585999,21.223066 2.414,-2.414 v 1.811 A 3.616,3.616 0 0 0 21.2,15.309066 l 0.881,-0.881 a 4.82,4.82 0 0 1 -4.080001,7.4 v 1.811 z m -13.5859988,-9.224 a 10,10 0 1 1 19.9999998,0 c 0,0.172 0,0.346 -0.013,0.517 a 5.971,5.971 0 0 0 -2.014001,-1.184001 7.935,7.935 0 0 0 -4.973,-6.742999 v 0.41 a 2,2 0 0 1 -2,2 h -2 v 2 A 1,1 0 0 1 10,9.9990662 H 8.0000002 v 1.9999998 h 5.9999988 a 1,1 0 0 1 0.495,0.131 6,6 0 0 0 -0.184,9.6 10.009,10.009 0 0 1 -12.3109988,-9.731 z m 2,0 a 8,8 0 0 0 6.9999988,7.93 v -1.93 a 2,2 0 0 1 -1.9999988,-2 v -1 l -4.79,-4.79 a 8.07,8.07 0 0 0 -0.21,1.79 z m 9.1729988,5 a 4.827,4.827 0 0 1 4.827,-4.828 v -1.81 l 2.414,2.414 -2.414,2.413 v -1.809 a 3.623,3.623 0 0 0 -3.62,3.62 3.537,3.537 0 0 0 0.42,1.69 l -0.881,0.881 a 4.787,4.787 0 0 1 -0.746,-2.571 z" })
                      ], -1)),
                      createTextVNode(" " + toDisplayString(unref(t)("grid.label.filters.apply")) + " ", 1),
                      filtersStatus.value !== "disabled" && config.value.state.applyToMap ? (openBlock(), createElementBlock("svg", _hoisted_23$1, _cache[17] || (_cache[17] = [
                        createElementVNode("g", { id: "done" }, [
                          createElementVNode("path", { d: "M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z" })
                        ], -1)
                      ]))) : createCommentVNode("", true)
                    ])
                  ], 10, _hoisted_21$1),
                  createElementVNode("a", {
                    href: "javascript:;",
                    class: "flex leading-snug items-center w-256 hover:text-black",
                    onClick: _cache[8] || (_cache[8] = ($event) => toggleShowFilters()),
                    role: "button",
                    "aria-label": unref(t)("grid.label.filters.show")
                  }, [
                    createElementVNode("div", _hoisted_25$1, [
                      _cache[20] || (_cache[20] = createElementVNode("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        viewBox: "0 0 24 24",
                        class: "fill-current inline w-20 h-20 mr-2 text-gray-500"
                      }, [
                        createElementVNode("path", { d: "M 3,2L 20.9888,2L 21,2L 21,2.01122L 21,3.99999L 20.9207,3.99999L 14,10.9207L 14,22.909L 9.99999,18.909L 10,10.906L 3.09405,3.99999L 3,3.99999L 3,2 Z " })
                      ], -1)),
                      createTextVNode(" " + toDisplayString(unref(t)("grid.label.filters.show")) + " ", 1),
                      config.value.state.colFilter ? (openBlock(), createElementBlock("svg", _hoisted_26$1, _cache[19] || (_cache[19] = [
                        createElementVNode("g", { id: "done" }, [
                          createElementVNode("path", { d: "M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z" })
                        ], -1)
                      ]))) : createCommentVNode("", true)
                    ])
                  ], 8, _hoisted_24$1),
                  createElementVNode("a", {
                    href: "javascript:;",
                    class: normalizeClass(["flex leading-snug items-center w-256", {
                      hover: filtersStatus.value !== "disabled" ? "none" : "text-black",
                      disabled: filtersStatus.value === "disabled"
                    }]),
                    onClick: _cache[9] || (_cache[9] = ($event) => filtersStatus.value !== "disabled" && toggleFilterByExtent()),
                    role: "button",
                    "aria-label": unref(t)("grid.filters.label.extent")
                  }, [
                    createElementVNode("div", _hoisted_28$1, [
                      _cache[22] || (_cache[22] = createElementVNode("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        viewBox: "0 0 24 24",
                        class: "fill-current inline w-20 h-20 mr-2 text-gray-500"
                      }, [
                        createElementVNode("path", { d: "M 4 10 Z M 2 2 L 19.9888 2 L 20 2 L 20 2.0112 L 20 4 L 19.9207 4 L 13 10.9207 L 13 22.909 L 9 18.909 L 9 10.906 L 2.0941 4 L 2 4 L 2 2 Z M 24 13 L 21 14 L 18 13 L 15 14 V 22 L 18 21 l 3 1 l 3 -1 z M 21 21 l -3 -1 V 14 l 3 1.055 z" })
                      ], -1)),
                      createTextVNode(" " + toDisplayString(unref(t)("grid.filters.label.extent")) + " ", 1),
                      filtersStatus.value !== "disabled" && config.value.state.filterByExtent ? (openBlock(), createElementBlock("svg", _hoisted_29$1, _cache[21] || (_cache[21] = [
                        createElementVNode("g", { id: "done" }, [
                          createElementVNode("path", { d: "M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z" })
                        ], -1)
                      ]))) : createCommentVNode("", true)
                    ])
                  ], 10, _hoisted_27$1),
                  createElementVNode("a", {
                    href: "javascript:;",
                    class: normalizeClass(["flex leading-snug items-center w-256", { hover: "text-black" }]),
                    onClick: _cache[10] || (_cache[10] = ($event) => togglePinned()),
                    role: "button",
                    "aria-label": unref(t)("grid.label.pinColumns")
                  }, [
                    pinned.value ? (openBlock(), createElementBlock("svg", _hoisted_31$1, _cache[23] || (_cache[23] = [
                      createElementVNode("path", { d: "M18,8H17V6A5,5 0 0,0 12,1A5,5 0 0,0 7,6V8H6A2,2 0 0,0 4,10V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V10A2,2 0 0,0 18,8M12,3A3,3 0 0,1 15,6V8H9V6A3,3 0 0,1 12,3Z" }, null, -1)
                    ]))) : !pinned.value ? (openBlock(), createElementBlock("svg", _hoisted_32$1, _cache[24] || (_cache[24] = [
                      createElementVNode("path", { d: "M18 1.5c2.9 0 5.25 2.35 5.25 5.25v3.75a.75.75 0 01-1.5 0V6.75a3.75 3.75 0 10-7.5 0v3a3 3 0 013 3v6.75a3 3 0 01-3 3H3.75a3 3 0 01-3-3v-6.75a3 3 0 013-3h9v-3c0-2.9 2.35-5.25 5.25-5.25z" }, null, -1)
                    ]))) : createCommentVNode("", true),
                    createTextVNode(" " + toDisplayString(unref(t)("grid.label.pinColumns")) + " ", 1),
                    pinned.value ? (openBlock(), createElementBlock("svg", _hoisted_33$1, _cache[25] || (_cache[25] = [
                      createElementVNode("g", { id: "done" }, [
                        createElementVNode("path", { d: "M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z" })
                      ], -1)
                    ]))) : createCommentVNode("", true)
                  ], 8, _hoisted_30$1),
                  createElementVNode("a", {
                    href: "javascript:;",
                    class: normalizeClass(["flex leading-snug items-center w-256", { hover: "text-black" }]),
                    onClick: _cache[11] || (_cache[11] = ($event) => exportData()),
                    role: "button",
                    "aria-label": unref(t)("grid.label.export")
                  }, [
                    _cache[26] || (_cache[26] = createElementVNode("svg", {
                      xmlns: "http://www.w3.org/2000/svg",
                      viewBox: "0 0 24 24",
                      class: "fill-current inline w-20 h-20 mr-2 text-gray-500"
                    }, [
                      createElementVNode("g", null, [
                        createElementVNode("path", { d: "M6 2c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6H6zm7 7V3.5L18.5 9H13z" })
                      ])
                    ], -1)),
                    createTextVNode(" " + toDisplayString(unref(t)("grid.label.export")), 1)
                  ], 8, _hoisted_34$1)
                ]),
                _: 1
              }, 8, ["tooltip"])
            ])
          ])
        ], 512), [
          [vShow, !isLoadingGrid.value && !isErrorGrid.value]
        ]),
        showGrid.value ? withDirectives((openBlock(), createBlock(unref(AgGridVue), {
          key: 0,
          class: "ag-theme-material flex-grow",
          enableCellTextSelection: "true",
          accentedSort: "true",
          localeText: unref(locale) === "en" ? unref(AG_GRID_LOCALE_EN) : unref(AG_GRID_LOCALE_FR),
          gridOptions: agGridOptions.value,
          columnDefs: columnDefs.value,
          rowData: rowData.value,
          components: frameworkComponents.value,
          onGridReady,
          onKeydown: stopArrowKeyProp,
          onFirstDataRendered: gridRendered,
          onCellKeyPress: unref(onCellKeyPress),
          doesExternalFilterPass,
          isExternalFilterPresent
        }, null, 8, ["localeText", "gridOptions", "columnDefs", "rowData", "components", "onCellKeyPress"])), [
          [vShow, !isLoadingGrid.value && !isErrorGrid.value]
        ]) : createCommentVNode("", true)
      ], 512);
    };
  }
});

const TableComponent = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-e89358eb"]]);

const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "screen",
  props: {
    panel: {
      type: PanelInstance,
      required: true
    }
  },
  setup(__props) {
    const gridStore = useGridStore();
    const { t } = useI18n();
    const currentId = computed(() => gridStore.currentId);
    return (_ctx, _cache) => {
      const _component_panel_screen = resolveComponent("panel-screen");
      return openBlock(), createBlock(_component_panel_screen, { panel: __props.panel }, {
        header: withCtx(() => [
          createTextVNode(toDisplayString(unref(t)("grid.title")), 1)
        ]),
        content: withCtx(() => [
          createVNode(TableComponent, {
            class: "rv-grid",
            gridId: currentId.value,
            panel: __props.panel
          }, null, 8, ["gridId", "panel"])
        ]),
        _: 1
      }, 8, ["panel"]);
    };
  }
});

const screen = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-904e67ef"]]);

const screen$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: screen
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$5 = { class: "flex flex-row justify-center items-center mt-16" };
const _hoisted_2$4 = { class: "mt-16" };
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "p2-screen-1",
  props: {
    panel: { type: Object, required: true },
    greeting: { type: String }
  },
  setup(__props) {
    const { t } = useI18n();
    return (_ctx, _cache) => {
      const _component_panel_screen = resolveComponent("panel-screen");
      return openBlock(), createBlock(_component_panel_screen, { panel: __props.panel }, {
        header: withCtx(() => _cache[2] || (_cache[2] = [
          createTextVNode(" Gazebo/Panel 2/Screen A ")
        ])),
        content: withCtx(() => [
          createTextVNode(toDisplayString(unref(t)("gz.hello")) + " ", 1),
          createElementVNode("div", _hoisted_1$5, [
            createElementVNode("button", {
              type: "button",
              onClick: _cache[0] || (_cache[0] = ($event) => __props.panel.show({
                screen: "p-2-screen-2",
                props: { greeting: "Howdy?" }
              })),
              class: "bg-green-500 hover:bg-green-700 text-white font-bold py-8 px-16 m-2"
            }, " Go back to B "),
            createElementVNode("button", {
              type: "button",
              onClick: _cache[1] || (_cache[1] = ($event) => __props.panel.show("p-2-screen-3")),
              class: "bg-blue-500 hover:bg-blue-700 text-white font-bold py-8 px-16 m-2"
            }, " Go to C ")
          ]),
          createElementVNode("p", _hoisted_2$4, toDisplayString(__props.greeting), 1)
        ]),
        _: 1
      }, 8, ["panel"]);
    };
  }
});

const p2Screen1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: _sfc_main$5
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$4 = { class: "relative legend-header flex align-middle" };
const _hoisted_2$3 = ["content", "aria-label"];
const _hoisted_3$3 = ["content", "aria-label"];
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "header",
  setup(__props) {
    const legendStore = useLegendStore();
    const { t } = useI18n();
    const iApi = inject("iApi");
    const legendApi = computed(() => iApi.fixture.get("legend"));
    const toggleWizard = () => {
      iApi.event.emit(GlobalEvents.WIZARD_TOGGLE);
    };
    const getWizardExists = () => {
      try {
        return iApi.fixture.exists("wizard");
      } catch (e) {
        return false;
      }
    };
    const toggleLayerReorder = () => {
      iApi.event.emit(GlobalEvents.REORDER_TOGGLE);
    };
    const getLayerReorderExists = () => {
      try {
        return iApi.fixture.exists("layer-reorder");
      } catch (e) {
        return false;
      }
    };
    const isControlAvailable = (control) => {
      const hc = legendStore.headerControls;
      return hc.includes(control);
    };
    return (_ctx, _cache) => {
      const _component_dropdown_menu = resolveComponent("dropdown-menu");
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", _hoisted_1$4, [
        createElementVNode("div", null, [
          withDirectives((openBlock(), createElementBlock("button", {
            type: "button",
            onClick: toggleWizard,
            class: "relative mr-auto text-gray-500 hover:text-black",
            content: unref(t)("legend.header.addlayer"),
            "aria-label": unref(t)("legend.header.addlayer")
          }, _cache[4] || (_cache[4] = [
            createElementVNode("div", { class: "p-8" }, [
              createElementVNode("svg", {
                class: "fill-current w-18 h-18 flip",
                viewBox: "0 0 24 24"
              }, [
                createElementVNode("path", { d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" })
              ])
            ], -1)
          ]), 8, _hoisted_2$3)), [
            [vShow, getWizardExists() && isControlAvailable("wizard")],
            [_directive_tippy, { placement: "right" }]
          ])
        ]),
        createElementVNode("div", null, [
          withDirectives((openBlock(), createElementBlock("button", {
            type: "button",
            onClick: toggleLayerReorder,
            class: "relative mr-auto text-gray-500 hover:text-black flex justify-center items-center",
            content: unref(t)("legend.header.reorderlayers"),
            "aria-label": unref(t)("legend.header.reorderlayers")
          }, _cache[5] || (_cache[5] = [
            createElementVNode("div", { class: "p-8" }, [
              createElementVNode("svg", {
                class: "fill-current w-18 h-18 flip",
                viewBox: "0 0 24 24"
              }, [
                createElementVNode("path", {
                  d: "M0 0h24v24H0z",
                  fill: "none"
                }),
                createElementVNode("path", { d: "M14 5h8v2h-8zm0 5.5h8v2h-8zm0 5.5h8v2h-8zM2 11.5C2 15.08 4.92 18 8.5 18H9v2l3-3-3-3v2h-.5C6.02 16 4 13.98 4 11.5S6.02 7 8.5 7H12V5H8.5C4.92 5 2 7.92 2 11.5z" })
              ])
            ], -1)
          ]), 8, _hoisted_3$3)), [
            [vShow, getLayerReorderExists() && isControlAvailable("layerReorder")],
            [_directive_tippy, { placement: "right" }]
          ])
        ]),
        _cache[8] || (_cache[8] = createElementVNode("span", { class: "flex-1" }, null, -1)),
        withDirectives(createVNode(_component_dropdown_menu, {
          class: "relative",
          position: "left-start",
          tooltip: unref(t)("legend.header.groups"),
          tooltipPlacement: "left-start",
          tooltipPlacementAlt: "bottom-end"
        }, {
          header: withCtx(() => _cache[6] || (_cache[6] = [
            createElementVNode("div", { class: "p-8" }, [
              createElementVNode("svg", {
                class: "fill-current w-18 h-18",
                viewBox: "0 0 24 24"
              }, [
                createElementVNode("path", { d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z" })
              ])
            ], -1)
          ])),
          default: withCtx(() => [
            createElementVNode("a", {
              href: "javascript:;",
              class: "flex leading-snug items-center overflow-hidden whitespace-nowrap",
              onClick: _cache[0] || (_cache[0] = ($event) => legendApi.value.expandItems(true))
            }, toDisplayString(unref(t)("legend.header.groups.expand")), 1),
            createElementVNode("a", {
              href: "javascript:;",
              class: "flex leading-snug items-center overflow-hidden whitespace-nowrap",
              onClick: _cache[1] || (_cache[1] = ($event) => legendApi.value.expandItems(false))
            }, toDisplayString(unref(t)("legend.header.groups.collapse")), 1)
          ]),
          _: 1
        }, 8, ["tooltip"]), [
          [vShow, isControlAvailable("groupToggle")]
        ]),
        withDirectives(createVNode(_component_dropdown_menu, {
          class: "relative",
          position: "left-start",
          tooltip: unref(t)("legend.header.visible"),
          tooltipPlacement: "left-start",
          tooltipPlacementAlt: "bottom-end"
        }, {
          header: withCtx(() => _cache[7] || (_cache[7] = [
            createElementVNode("div", { class: "flex p-8" }, [
              createElementVNode("svg", {
                class: "fill-current w-18 h-18",
                viewBox: "0 0 24 24"
              }, [
                createElementVNode("path", { d: "M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z" })
              ])
            ], -1)
          ])),
          default: withCtx(() => [
            createElementVNode("a", {
              href: "javascript:;",
              class: "flex leading-snug items-center overflow-hidden whitespace-nowrap",
              onClick: _cache[2] || (_cache[2] = ($event) => legendApi.value.showItems(true))
            }, toDisplayString(unref(t)("legend.header.visible.show")), 1),
            createElementVNode("a", {
              href: "javascript:;",
              class: "flex leading-snug items-center overflow-hidden whitespace-nowrap",
              onClick: _cache[3] || (_cache[3] = ($event) => legendApi.value.showItems(false))
            }, toDisplayString(unref(t)("legend.header.visible.hide")), 1)
          ]),
          _: 1
        }, 8, ["tooltip"]), [
          [vShow, isControlAvailable("visibilityToggle")]
        ])
      ]);
    };
  }
});

const header = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-e8031c30"]]);

const header$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: header
}, Symbol.toStringTag, { value: 'Module' }));

const _hoisted_1$3 = ["type", "aria-label", "checked", "disabled", "content"];
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "checkbox",
  props: {
    value: {
      type: Object,
      required: true
    },
    legendItem: {
      type: Object,
      required: true
    },
    checked: { type: Boolean },
    label: { type: String },
    isRadio: { type: Boolean },
    disabled: { type: Boolean }
  },
  setup(__props) {
    const { t } = useI18n();
    const props = __props;
    const initialChecked = ref(props.legendItem.visibility);
    onMounted(() => {
      props.legendItem.checkVisibilityRules();
      initialChecked.value = props.legendItem.visibility === props.checked;
    });
    const _noSymbolsVisible = (item) => {
      return !item.symbologyStack.some((item2) => item2.visibility);
    };
    const toggleVisibility = () => {
      if (props.value instanceof LegendItem) {
        props.legendItem.toggleVisibility();
      } else if (props.legendItem instanceof LayerItem) {
        if (_noSymbolsVisible(props.legendItem)) {
          props.legendItem.setSymbologyVisibility(void 0, false);
          props.legendItem.setSymbologyVisibility(props.value.uid, true);
          props.legendItem.toggleVisibility(true);
        } else {
          props.legendItem.setSymbologyVisibility(props.value.uid, !props.value.lastVisbility);
        }
        if (_noSymbolsVisible(props.legendItem)) {
          props.legendItem.toggleVisibility(false);
        }
        if (props.legendItem.layer?.supportsFeatures) {
          const filterGuts = props.legendItem.symbologyStack.filter((item) => item.lastVisbility === true).map((item) => item.definitionClause || "");
          let sql = "";
          if (filterGuts.length === 0) {
            sql = "1=2";
          } else if (filterGuts.length < props.legendItem.symbologyStack.length) {
            sql = filterGuts.join(" OR ");
          }
          props.legendItem.layer?.setSqlFilter(CoreFilter.SYMBOL, sql);
        }
        initialChecked.value = true;
      }
    };
    return (_ctx, _cache) => {
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", {
        class: "relative",
        onMouseover: _cache[3] || (_cache[3] = withModifiers(() => {
        }, ["stop"]))
      }, [
        withDirectives(createElementVNode("input", {
          type: __props.isRadio ? "radio" : "checkbox",
          "aria-label": unref(t)(__props.checked ? `legend.visibility.hide${__props.label}` : `legend.visibility.show${__props.label}`),
          onClick: _cache[0] || (_cache[0] = withModifiers(($event) => toggleVisibility(), ["stop"])),
          checked: __props.checked && initialChecked.value,
          onKeypress: _cache[1] || (_cache[1] = withKeys(withModifiers(() => {
          }, ["prevent"]), ["enter"])),
          onKeyup: _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => toggleVisibility(), ["stop"]), ["enter"])),
          class: normalizeClass([[
            __props.disabled ? "text-gray-400 border-gray-300" : "text-black cursor-pointer border-gray-500 hover:border-black"
          ], "mx-5 h-15 w-15"]),
          tabindex: "-1",
          disabled: __props.disabled,
          content: unref(t)(__props.checked ? `legend.visibility.hide${__props.label}` : `legend.visibility.show${__props.label}`)
        }, null, 42, _hoisted_1$3), [
          [_directive_tippy, { placement: "top-end", hideOnClick: false }]
        ])
      ], 32);
    };
  }
});

const _hoisted_1$2 = ["aria-label"];
const _hoisted_2$2 = ["aria-label"];
const _hoisted_3$2 = ["aria-label"];
const _hoisted_4$2 = ["aria-label"];
const _hoisted_5$2 = ["aria-label"];
const _hoisted_6$2 = ["aria-label"];
const _hoisted_7$2 = ["content", "aria-label"];
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "legend-options",
  props: {
    legendItem: LayerItem
  },
  setup(__props) {
    const { t } = useI18n();
    const iApi = inject("iApi");
    const dropdown = ref();
    const hovered = ref(false);
    const panelStore = usePanelStore();
    const mobileMode = ref(panelStore.mobileView);
    const props = __props;
    const toggleSymbology = () => {
      if (props.legendItem.layerControlAvailable(LayerControl.Symbology)) {
        props.legendItem.toggleSymbology();
      }
    };
    const toggleGrid = () => {
      if (props.legendItem.layerControlAvailable(LayerControl.Datatable) && getFixtureExists("grid")) {
        iApi.event.emit(GlobalEvents.GRID_TOGGLE, props.legendItem.layer);
      }
    };
    const toggleSettings = () => {
      if (props.legendItem.layerControlAvailable(LayerControl.Settings) && getFixtureExists("settings")) {
        iApi.event.emit(GlobalEvents.SETTINGS_TOGGLE, props.legendItem.layer);
      }
    };
    const toggleMetadata = () => {
      if (props.legendItem.layerControlAvailable(LayerControl.Metadata) && getFixtureExists("metadata")) {
        const metaConfig = props.legendItem?.layer?.config.metadata || props.legendItem?.layer?.parentLayer?.config?.metadata || {};
        const name = metaConfig?.name || props.legendItem?.layer?.name || "";
        const catalogueUrl = props.legendItem?.layer?.config?.catalogueUrl || props.legendItem?.layer?.layerType === "sublayer" && props.legendItem?.layer?.parentLayer?.config?.catalogueUrl || void 0;
        if (metaConfig.url) {
          const parseUrl = metaConfig.url.split(".");
          const metadataExtension = parseUrl[parseUrl.length - 1];
          const metadataType = metadataExtension === "xml" || metadataExtension === "md" ? metadataExtension : "html";
          iApi.event.emit(GlobalEvents.METADATA_TOGGLE, {
            type: metadataType,
            layerName: name,
            url: metaConfig.url,
            catalogueUrl,
            layer: props.legendItem.layer
          });
        } else {
          console.warn("Layer does not have a metadata url defined");
        }
      }
    };
    const zoomToLayerBoundary = () => {
      if (props.legendItem.layerControlAvailable(LayerControl.BoundaryZoom)) {
        props.legendItem?.layer?.zoomToLayerBoundary();
      }
    };
    const removeLayer = () => {
      if (props.legendItem.layerControlAvailable(LayerControl.Remove)) {
        iApi.geo.map.removeLayer(props.legendItem.layerUid);
      }
    };
    const reloadLayer = () => {
      if (reloadableLayer.value) {
        toRaw(props.legendItem.layer).reload();
        dropdown.value.open = false;
      }
    };
    const reloadableLayer = computed(() => {
      return props.legendItem.layerControlAvailable(LayerControl.Reload) && props.legendItem instanceof LayerItem && toRaw(props.legendItem.layer)?.canReload;
    });
    const hover = (t2) => {
      hovered.value = true;
      setTimeout(() => {
        if (hovered.value) mobileMode.value ? null : t2._tippy?.show();
      }, 300);
    };
    const getFixtureExists = (fixtureName) => {
      try {
        return iApi.fixture.exists(fixtureName);
      } catch (e) {
        return false;
      }
    };
    return (_ctx, _cache) => {
      const _component_dropdown_menu = resolveComponent("dropdown-menu");
      const _directive_tippy = resolveDirective("tippy");
      return openBlock(), createElementBlock("div", {
        onClick: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["stop"])),
        onMouseover: _cache[3] || (_cache[3] = withModifiers(() => {
        }, ["stop"])),
        class: "options display-block cursor-auto"
      }, [
        createVNode(_component_dropdown_menu, {
          class: "flex-shrink-0",
          position: "bottom-end",
          tooltip: unref(t)("legend.layer.options"),
          tooltipPlacement: "left",
          tooltipPlacementAlt: "left",
          ref_key: "dropdown",
          ref: dropdown
        }, {
          header: withCtx(() => _cache[4] || (_cache[4] = [
            createElementVNode("div", { class: "flex p-4 justify-center items-center" }, [
              createElementVNode("svg", {
                class: "inline-block fill-current w-18 h-18 mx-4",
                viewBox: "0 0 23 21"
              }, [
                createElementVNode("path", { d: "M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" })
              ])
            ], -1)
          ])),
          default: withCtx(() => [
            createElementVNode("a", {
              href: "javascript:;",
              class: normalizeClass(["flex leading-snug items-center text-left w-auto", {
                disabled: !__props.legendItem.layerControlAvailable(unref(LayerControl).Metadata) || !getFixtureExists("metadata")
              }]),
              onClick: toggleMetadata,
              role: "button",
              "aria-label": unref(t)("legend.layer.controls.metadata")
            }, [
              _cache[5] || (_cache[5] = createElementVNode("svg", {
                class: "setting-svg",
                viewBox: "0 0 23 21"
              }, [
                createElementVNode("path", { d: "M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z" })
              ], -1)),
              createTextVNode(" " + toDisplayString(unref(t)("legend.layer.controls.metadata")), 1)
            ], 10, _hoisted_1$2),
            createElementVNode("a", {
              href: "javascript:;",
              class: normalizeClass(["flex leading-snug items-center text-left w-auto", {
                disabled: !__props.legendItem.layerControlAvailable(unref(LayerControl).Settings) || !getFixtureExists("settings")
              }]),
              onClick: toggleSettings,
              role: "button",
              "aria-label": unref(t)("legend.layer.controls.settings")
            }, [
              _cache[6] || (_cache[6] = createElementVNode("svg", {
                class: "setting-svg",
                viewBox: "0 0 23 21"
              }, [
                createElementVNode("g", null, [
                  createElementVNode("path", { d: "M 3,17L 3,19L 9,19L 9,17L 3,17 Z M 3,5L 3,7L 13,7L 13,5L 3,5 Z M 13,21L 13,19L 21,19L 21,17L 13,17L 13,15L 11,15L 11,21L 13,21 Z M 7,9L 7,11L 3,11L 3,13L 7,13L 7,15L 9,15L 9,9L 7,9 Z M 21,13L 21,11L 11,11L 11,13L 21,13 Z M 15,9L 17,9L 17,7L 21,7L 21,5L 17,5L 17,3L 15,3L 15,9 Z " })
                ])
              ], -1)),
              createTextVNode(" " + toDisplayString(unref(t)("legend.layer.controls.settings")), 1)
            ], 10, _hoisted_2$2),
            createElementVNode("a", {
              href: "javascript:;",
              class: normalizeClass(["flex leading-snug items-center text-left w-auto", {
                disabled: !__props.legendItem.layerControlAvailable(unref(LayerControl).Datatable) || !getFixtureExists("grid")
              }]),
              onClick: toggleGrid,
              role: "button",
              "aria-label": unref(t)("legend.layer.controls.datatable")
            }, [
              _cache[7] || (_cache[7] = createElementVNode("svg", {
                class: "setting-svg",
                viewBox: "0 0 23 21"
              }, [
                createElementVNode("path", { d: "M 4.00002,3L 20,3C 21.1046,3 22,3.89543 22,5L 22,20C 22,21.1046 21.1046,22 20,22L 4.00001,22C 2.89544,22 2.00001,21.1046 2.00001,20L 2.00002,5C 2.00002,3.89543 2.89545,3 4.00002,3 Z M 4.00002,7L 4.00001,10L 8,10L 8,7.00001L 4.00002,7 Z M 10,7.00001L 9.99999,10L 14,10L 14,7.00001L 10,7.00001 Z M 20,10L 20,7L 16,7.00001L 16,10L 20,10 Z M 4.00002,12L 4.00002,15L 8,15L 8,12L 4.00002,12 Z M 4.00001,20L 8,20L 8,17L 4.00002,17L 4.00001,20 Z M 9.99999,12L 9.99999,15L 14,15L 14,12L 9.99999,12 Z M 9.99999,20L 14,20L 14,17L 9.99999,17L 9.99999,20 Z M 20,20L 20,17L 16,17L 16,20L 20,20 Z M 20,12L 16,12L 16,15L 20,15L 20,12 Z " })
              ], -1)),
              createTextVNode(" " + toDisplayString(unref(t)("legend.layer.controls.datatable")), 1)
            ], 10, _hoisted_3$2),
            createElementVNode("a", {
              href: "javascript:;",
              class: normalizeClass(["flex leading-snug items-center text-left w-auto", {
                disabled: !__props.legendItem.layerControlAvailable(unref(LayerControl).Symbology)
              }]),
              onClick: toggleSymbology,
              role: "button",
              "aria-label": unref(t)("legend.layer.controls.symbology")
            }, [
              _cache[8] || (_cache[8] = createElementVNode("svg", {
                class: "setting-svg",
                viewBox: "0 0 23 21"
              }, [
                createElementVNode("path", { d: "M11.99 18.54l-7.37-5.73L3 14.07l9 7 9-7-1.63-1.27-7.38 5.74zM12 16l7.36-5.73L21 9l-9-7-9 7 1.63 1.27L12 16z" })
              ], -1)),
              createTextVNode(" " + toDisplayString(unref(t)("legend.layer.controls.symbology")), 1)
            ], 10, _hoisted_4$2),
            createElementVNode("a", {
              href: "javascript:;",
              class: normalizeClass(["flex leading-snug items-center text-left w-auto", {
                disabled: !__props.legendItem.layerControlAvailable(unref(LayerControl).BoundaryZoom)
              }]),
              onClick: zoomToLayerBoundary,
              role: "button",
              "aria-label": unref(t)("legend.layer.controls.boundaryzoom")
            }, [
              _cache[9] || (_cache[9] = createElementVNode("svg", {
                class: "setting-svg",
                viewBox: "0 0 24 24"
              }, [
                createElementVNode("path", { d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" }),
                createElementVNode("path", {
                  d: "M0 0h24v24H0V0z",
                  fill: "none"
                }),
                createElementVNode("path", { d: "M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z" })
              ], -1)),
              createTextVNode(" " + toDisplayString(unref(t)("legend.layer.controls.boundaryzoom")), 1)
            ], 10, _hoisted_5$2),
            createElementVNode("a", {
              href: "javascript:;",
              class: normalizeClass(["flex leading-snug items-center text-left w-auto", {
                disabled: !__props.legendItem.layerControlAvailable(unref(LayerControl).Remove)
              }]),
              onClick: removeLayer,
              role: "button",
              "aria-label": unref(t)("legend.layer.controls.remove")
            }, [
              _cache[10] || (_cache[10] = createElementVNode("svg", {
                class: "setting-svg",
                viewBox: "0 0 23 21"
              }, [
                createElementVNode("path", { d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z" })
              ], -1)),
              createTextVNode(" " + toDisplayString(unref(t)("legend.layer.controls.remove")), 1)
            ], 10, _hoisted_6$2),
            withDirectives((openBlock(), createElementBlock("a", {
              href: "javascript:;",
              class: normalizeClass(["flex leading-snug items-center text-left w-auto", {
                disabled: !reloadableLayer.value
              }]),
              content: !reloadableLayer.value ? unref(t)("legend.layer.controls.reloadDisabled") : "",
              onMouseover: _cache[0] || (_cache[0] = withModifiers(($event) => hover($event.currentTarget), ["stop"])),
              onMouseout: _cache[1] || (_cache[1] = ($event) => (
                //@ts-ignore
                (mobileMode.value ? null : $event.currentTarget?._tippy?.hide(), hovered.value = false)
              )),
              onClick: reloadLayer,
              role: "button",
              "aria-label": unref(t)("legend.layer.controls.reload")
            }, [
              _cache[11] || (_cache[11] = createElementVNode("svg", {
                class: "setting-svg",
                viewBox: "0 0 24 24"
              }, [
                createElementVNode("path", { d: "M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z" })
              ], -1)),
              createTextVNode(" " + toDisplayString(unref(t)("legend.layer.controls.reload")), 1)
            ], 42, _hoisted_7$2)), [
              [_directive_tippy, {
                placement: "top-start",
                trigger: "manual focus",
                aria: "describedby"
              }]
            ])
          ]),
          _: 1
        }, 8, ["tooltip"])
      ], 32);
    };
  }
});

const LegendOptions = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-9590866e"]]);

const _hoisted_1$1 = { key: 0 };
const _hoisted_2$1 = {
  key: 0,
  class: "relative left-3"
};
const _hoisted_3$1 = ["innerHTML"];
const _hoisted_4$1 = ["src"];
const _hoisted_5$1 = {
  key: 1,
  class: "symbologyIcon w-32 h-32"
};
const _hoisted_6$1 = ["innerHTML"];
const _hoisted_7$1 = ["src"];
const _hoisted_8$1 = {
  key: 1,
  class: "h-32 w-32 inline-flex justify-center items-center"
};
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "symbology-stack",
  props: {
    visible: { type: Boolean, required: true },
    legendItem: { type: Object, required: true }
  },
  setup(__props) {
    const props = __props;
    const stack = ref([]);
    onMounted(() => {
      props.legendItem.loadPromise.then(() => {
        if (props.legendItem.layerUid !== void 0) {
          Promise.all(toRaw(props.legendItem.symbologyStack).map((l) => l.drawPromise)).then(() => {
            stack.value = toRaw(props.legendItem).symbologyStack;
          });
        }
      });
    });
    return (_ctx, _cache) => {
      return !__props.visible ? (openBlock(), createElementBlock("div", _hoisted_1$1, [
        stack.value.length > 1 ? (openBlock(), createElementBlock("div", _hoisted_2$1, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(stack.value.slice(0, 3).reverse(), (item, idx) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(["absolute", [idx == 0 ? "symbol-0" : idx == 1 ? "left-3 symbol-1" : "left-6 symbol-2"]]),
              style: normalizeStyle({ "z-index": 3 - idx }),
              key: idx
            }, [
              stack.value[idx].svgcode ? (openBlock(), createElementBlock("span", {
                key: 0,
                class: "symbologyIcon w-28 h-28",
                innerHTML: stack.value[idx].svgcode
              }, null, 8, _hoisted_3$1)) : stack.value[idx].imgUrl ? (openBlock(), createElementBlock("img", {
                key: 1,
                class: "symbologyIcon w-28 h-28",
                src: stack.value[idx].imgUrl
              }, null, 8, _hoisted_4$1)) : createCommentVNode("", true)
            ], 6);
          }), 128))
        ])) : stack.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_5$1, [
          stack.value[0].svgcode ? (openBlock(), createElementBlock("span", {
            key: 0,
            innerHTML: stack.value[0].svgcode
          }, null, 8, _hoisted_6$1)) : stack.value[0].imgUrl ? (openBlock(), createElementBlock("img", {
            key: 1,
            class: "symbologyIcon w-full h-full",
            src: stack.value[0].imgUrl
          }, null, 8, _hoisted_7$1)) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ])) : (openBlock(), createElementBlock("div", _hoisted_8$1, _cache[0] || (_cache[0] = [
        createElementVNode("svg", {
          class: "fill-current w-16 h-16",
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 352 512"
        }, [
          createElementVNode("path", { d: "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z" })
        ], -1)
      ])));
    };
  }
});

const SymbologyStack = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-34dfeccd"]]);

const _hoisted_1 = { class: "relative" };
const _hoisted_2 = ["content"];
const _hoisted_3 = {
  key: 0,
  class: "flex p-5 mr-[13px]"
};
const _hoisted_4 = {
  key: 0,
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  fill: "black",
  width: "24px",
  height: "24px"
};
const _hoisted_5 = {
  key: 1,
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  fill: "black",
  width: "24px",
  height: "24px"
};
const _hoisted_6 = ["disabled", "content", "aria-label"];
const _hoisted_7 = ["src"];
const _hoisted_8 = { class: "h-auto break-words text-ellipsis" };
const _hoisted_9 = {
  key: 4,
  class: "flex-1 pointer-events-none p-5"
};
const _hoisted_10 = {
  key: 5,
  class: "flex-1"
};
const _hoisted_11 = {
  key: 0,
  class: "text-lg font-bold"
};
const _hoisted_12 = { key: 1 };
const _hoisted_13 = { key: 2 };
const _hoisted_14 = ["src"];
const _hoisted_15 = ["innerHTML"];
const _hoisted_16 = {
  key: 6,
  class: "relative"
};
const _hoisted_17 = ["content", "aria-label"];
const _hoisted_18 = {
  key: 8,
  class: "relative"
};
const _hoisted_19 = ["content", "aria-label"];
const _hoisted_20 = { class: "flex p-5" };
const _hoisted_21 = {
  key: 0,
  class: "fill-current w-18 h-18",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 352 512"
};
const _hoisted_22 = {
  key: 1,
  class: "inline-block fill-current w-18 h-18 mr-1",
  viewBox: "0 1 23 22"
};
const _hoisted_23 = ["content"];
const _hoisted_24 = ["content"];
const _hoisted_25 = {
  key: 11,
  class: "relative top-1"
};
const _hoisted_26 = ["content"];
const _hoisted_27 = {
  key: 0,
  class: "h-3 w-full absolute bottom-0"
};
const _hoisted_28 = {
  key: 0,
  class: "symbology-stack default-focus-style"
};
const _hoisted_29 = { key: 0 };
const _hoisted_30 = {
  key: 0,
  class: "m-5"
};
const _hoisted_31 = {
  key: 0,
  class: "items-center grid-cols-1"
};
const _hoisted_32 = {
  key: 0,
  class: "symbologyIcon w-full p-5"
};
const _hoisted_33 = ["src"];
const _hoisted_34 = ["innerHTML"];
const _hoisted_35 = {
  key: 2,
  class: "flex-1 p-5 bg-black-75 text-white"
};
const _hoisted_36 = {
  key: 1,
  class: "flex items-center"
};
const _hoisted_37 = {
  key: 0,
  class: "symbologyIcon"
};
const _hoisted_38 = ["src"];
const _hoisted_39 = {
  key: 1,
  class: "symbologyIcon"
};
const _hoisted_40 = ["innerHTML"];
const _hoisted_41 = { class: "flex-1 ml-15" };
const _hoisted_42 = { key: 1 };
const _hoisted_43 = { class: "flex p-5 ml-48" };
const _hoisted_44 = {
  key: 0,
  class: "relative animate-spin spinner h-20 w-20 mr-10 pt-2"
};
const _hoisted_45 = { class: "flex-1 text-gray-500" };
const _hoisted_46 = {
  key: 1,
  class: "legend-group border-l-2 ml-4 pl-4"
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "item",
  props: {
    legendItem: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const layerStore = useLayerStore();
    const panelStore = usePanelStore();
    const { t } = useI18n();
    const iApi = inject("iApi");
    const el = ref();
    const props = __props;
    const legendStore = useLegendStore();
    const allowMultilineItems = legendStore.multilineItems;
    const maxLines = (props.legendItem instanceof LayerItem && props.legendItem.maxLines) ?? legendStore.maxLines;
    const mobileMode = ref(panelStore.mobileView);
    const layerConfigs = computed(() => layerStore.layerConfigs);
    const symbologyStack = ref([]);
    const symbologyStackLoaded = ref(false);
    const hovered = ref(false);
    const layerType = computed(() => {
      return props.legendItem instanceof LayerItem ? toRaw(props.legendItem.layer)?.layerType : "";
    });
    const modifiableLayer = computed(() => {
      return props.legendItem instanceof LayerItem && toRaw(props.legendItem.layer)?.canModifyLayer;
    });
    const reloadableLayer = computed(() => {
      if (props.legendItem instanceof LayerItem) {
        const rawLayer = toRaw(props.legendItem.layer);
        if (rawLayer) {
          return rawLayer.canReload;
        } else {
          return true;
        }
      } else {
        return false;
      }
    });
    const isAnimationEnabled = computed(() => {
      return iApi.animate;
    });
    const isGroup = computed(() => {
      return props.legendItem.children.length > 0 || // TODO: Determine why Vue reactivity isn't picking updates to the children property of the parent.
      // isGroup is being called on the parent before the children are mapped in legend.ts. After they're mapped, isGroup isn't called again.
      props.legendItem instanceof LayerItem && toRaw(props.legendItem.layer)?.sublayers.length > 0;
    });
    const controlAvailable = (control) => {
      if (control === LegendControl.Expand || control === LegendControl.Visibility)
        return props.legendItem.controlAvailable(control);
      else return props.legendItem.layerControlAvailable(control);
    };
    const markdownToHtml = (md) => {
      return marked(md);
    };
    const toggleExpand = () => {
      if (props.legendItem.children.length === 0 || !controlAvailable(LegendControl.Expand)) {
        return;
      }
      props.legendItem.toggleExpanded();
      iApi.updateAlert(t(`legend.alert.group${props.legendItem.expanded ? "Expanded" : "Collapsed"}`));
    };
    const toggleSymbology = () => {
      if (controlAvailable(LayerControl.Symbology)) {
        const expanded = props.legendItem.toggleSymbology();
        iApi.updateAlert(t(`legend.alert.symbology${expanded ? "Expanded" : "Collapsed"}`));
      }
    };
    const toggleGrid = () => {
      if (controlAvailable(LayerControl.Datatable) && getDatagridExists()) {
        iApi.event.emit(GlobalEvents.GRID_TOGGLE, props.legendItem.layer);
      }
    };
    const getLegendGraphic = (item) => {
      const span = document.createElement("span");
      span.innerHTML = item.svgcode;
      const svg = span.firstElementChild;
      svg?.classList.add("max-w-full");
      svg?.classList.add("h-full");
      svg?.setAttribute("height", item.imgHeight);
      svg?.setAttribute("width", item.imgWidth);
      return span.outerHTML;
    };
    const getDatagridExists = () => {
      try {
        return iApi.fixture.exists("grid");
      } catch (e) {
        return false;
      }
    };
    const reloadLayer = () => {
      props.legendItem.reload();
      setTimeout(() => {
        const layerItemProp = props.legendItem;
        let recreateFromConfig = true;
        if (layerItemProp.layer) {
          toRaw(layerItemProp.layer).reload();
          recreateFromConfig = false;
        } else if (layerItemProp.isSublayer && layerItemProp.parentLayerId) {
          const testParent = iApi.geo.layer.getLayer(layerItemProp.parentLayerId);
          if (testParent) {
            toRaw(testParent).reload();
            recreateFromConfig = false;
          }
        }
        if (recreateFromConfig) {
          const targetId = layerItemProp.isSublayer ? layerItemProp.parentLayerId : layerItemProp.layerId;
          const layerConfig = layerConfigs.value.find((lc) => lc.id === targetId);
          if (layerConfig !== void 0) {
            recreateLayer(layerConfig);
          }
        }
        props.legendItem.loadPromise.catch(() => {
        });
      }, 400);
    };
    const recreateLayer = async (layerConfig) => {
      try {
        const checkLayer = iApi.geo.layer.getLayer(layerConfig.id);
        if (checkLayer) {
          const [reloadErr] = await to(toRaw(checkLayer).reload());
          if (reloadErr) {
            throw new Error();
          } else {
            return checkLayer;
          }
        } else {
          const layer = iApi.geo.layer.createLayer(layerConfig);
          await iApi.geo.map.addLayer(layer).catch(() => {
            throw new Error();
          });
          return layer;
        }
      } catch {
        return;
      }
    };
    const cancelOrRemoveLayer = () => {
      const layerItem = toRaw(props.legendItem);
      let safetyCount = 0;
      if (layerItem.type === LegendType.Error) {
        props.legendItem.toggleHidden(true);
        const removalWatcher = setInterval(() => {
          const rampL = layerItem.layer;
          if (rampL && (rampL.layerExists || rampL.initiationState === InitiationState.NEW || rampL.initiationState === InitiationState.TERMINATING || rampL.initiationState === InitiationState.TERMINATED) || safetyCount > 1200) {
            clearInterval(removalWatcher);
            if (rampL) {
              iApi.geo.map.removeLayer(rampL);
            }
            layerStore.removeLayerConfig(layerItem.layerId);
            iApi.fixture.get("legend")?.removeLayerItem(layerItem.layerId);
          }
          safetyCount++;
        }, 250);
      } else {
        props.legendItem.error();
        const cancelWatcher = setInterval(() => {
          const parentmostId = layerItem.parentLayerId || layerItem.layerId;
          const parentLayer = iApi.geo.layer.getLayer(parentmostId);
          if (parentLayer) {
            clearInterval(cancelWatcher);
            parentLayer.cancelLoad();
            const affectedBlocks = iApi.fixture.get("legend")?.getLayerBoundItems(parentLayer) || [];
            affectedBlocks.forEach((block) => block.error());
          }
          if (safetyCount > 1200) {
            clearInterval(cancelWatcher);
          }
          safetyCount++;
        }, 50);
      }
    };
    const loadSymbologyStack = () => {
      props.legendItem.loadPromise.then(() => {
        symbologyStack.value = [];
        if (!props.legendItem.layer) {
          console.warn("Attempted to mount legend item component with undefined layer");
          return;
        }
        Promise.all(
          toRaw(props.legendItem.symbologyStack.map((item) => item.drawPromise))
        ).then(() => {
          symbologyStack.value = props.legendItem.symbologyStack;
          symbologyStackLoaded.value = true;
        });
      }).catch(() => {
      });
    };
    const hover = (t2) => {
      hovered.value = true;
      setTimeout(() => {
        if (hovered.value) mobileMode.value ? null : t2._tippy?.show();
      }, 300);
    };
    if (props.legendItem instanceof LayerItem) {
      loadSymbologyStack();
      watch(
        () => props.legendItem.symbologyStack,
        () => {
          loadSymbologyStack();
        }
      );
    }
    return (_ctx, _cache) => {
      const _component_item = resolveComponent("item", true);
      const _directive_tippy = resolveDirective("tippy");
      const _directive_truncate = resolveDirective("truncate");
      const _directive_focus_item = resolveDirective("focus-item");
      return !__props.legendItem.hidden ? (openBlock(), createElementBlock("div", {
        key: `${__props.legendItem.uid}-${__props.legendItem.visibility}`,
        ref_key: "el",
        ref: el
      }, [
        createElementVNode("div", _hoisted_1, [
          withDirectives((openBlock(), createElementBlock("div", {
            class: normalizeClass(["flex items-center hover:bg-gray-200 default-focus-style !p-5", [
              __props.legendItem.type === unref(LegendType).Item ? "loaded-item" : __props.legendItem.type === unref(LegendType).Error ? "non-loaded-item bg-red-200" : "non-loaded-item",
              isGroup.value && controlAvailable(unref(LegendControl).Expand) || !isGroup.value && __props.legendItem instanceof unref(LayerItem) && controlAvailable(unref(LayerControl).Datatable) && getDatagridExists() && __props.legendItem.type === unref(LegendType).Item ? "cursor-pointer" : "cursor-default",
              unref(allowMultilineItems) ? "multilined" : "singlelined"
            ]]),
            onMouseover: _cache[9] || (_cache[9] = withModifiers(($event) => hover($event.currentTarget), ["stop"])),
            onMouseout: _cache[10] || (_cache[10] = ($event) => (
              //@ts-ignore
              (mobileMode.value ? null : $event.currentTarget?._tippy?.hide(), hovered.value = false)
            )),
            onClick: _cache[11] || (_cache[11] = () => {
              if (!isGroup.value && __props.legendItem instanceof unref(LayerItem) && controlAvailable(unref(LayerControl).Datatable) && getDatagridExists() && __props.legendItem.type === unref(LegendType).Item) {
                toggleGrid();
              } else if (isGroup.value) {
                toggleExpand();
              }
            }),
            content: isGroup.value && controlAvailable(unref(LegendControl).Expand) ? unref(t)(__props.legendItem.expanded ? "legend.group.collapse" : "legend.group.expand") : __props.legendItem instanceof unref(LayerItem) && __props.legendItem.type === unref(LegendType).Item && controlAvailable(unref(LayerControl).Datatable) && getDatagridExists() ? unref(t)("legend.layer.data") : "",
            "truncate-trigger": ""
          }, [
            __props.legendItem.type !== unref(LegendType).Item ? (openBlock(), createElementBlock("div", _hoisted_3, [
              __props.legendItem.type === unref(LegendType).Placeholder ? (openBlock(), createElementBlock("svg", _hoisted_4, _cache[12] || (_cache[12] = [
                createStaticVNode('<path d="M0 0h24v24H0V0z" fill="none" data-v-b1261e08></path><path d="M0 0h24v24H0V0z" fill="none" data-v-b1261e08></path><circle cx="15.5" cy="9.5" r="1.5" data-v-b1261e08></circle><circle cx="8.5" cy="9.5" r="1.5" data-v-b1261e08></circle><circle cx="15.5" cy="9.5" r="1.5" data-v-b1261e08></circle><circle cx="8.5" cy="9.5" r="1.5" data-v-b1261e08></circle><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm0-2.5c2.33 0 4.32-1.45 5.12-3.5h-1.67c-.69 1.19-1.97 2-3.45 2s-2.75-.81-3.45-2H6.88c.8 2.05 2.79 3.5 5.12 3.5z" data-v-b1261e08></path>', 7)
              ]))) : (openBlock(), createElementBlock("svg", _hoisted_5, _cache[13] || (_cache[13] = [
                createStaticVNode('<path d="M0 0h24v24H0V0z" fill="none" data-v-b1261e08></path><path d="M0 0h24v24H0V0z" fill="none" data-v-b1261e08></path><circle cx="15.5" cy="9.5" r="1.5" data-v-b1261e08></circle><circle cx="8.5" cy="9.5" r="1.5" data-v-b1261e08></circle><circle cx="15.5" cy="9.5" r="1.5" data-v-b1261e08></circle><circle cx="8.5" cy="9.5" r="1.5" data-v-b1261e08></circle><path d="M 20,12C 20,7.6 16.4,4 12,4C 7.6,4 4,7.6 4,12C 4,16.4 7.6,20 12,20C 16.4,20 20,16.4 20,12 Z M 22,12C 22,17.5 17.5,22 12,22C 6.5,22 2,17.5 2,12C 2,6.5 6.5,2.00001 12,2.00001C 17.5,2.00001 22,6.5 22,12 Z M 15.5,8C 16.3,8 17,8.7 17,9.5C 17,10.3 16.3,11 15.5,11C 14.7,11 14,10.3 14,9.5C 14,8.7 14.7,8 15.5,8 Z M 10,9.5C 10,10.3 9.3,11 8.5,11C 7.7,11 7,10.3 7,9.5C 7,8.7 7.7,8 8.5,8C 9.3,8 10,8.7 10,9.5 Z M 12,14C 13.7524,14 15.2943,14.7212 16.1871,15.8129L 14.7697,17.2302C 14.3175,16.5078 13.2477,16 12,16C 10.7523,16 9.68254,16.5078 9.23024,17.2302L 7.81291,15.8129C 8.7057,14.7212 10.2476,14 12,14 Z" data-v-b1261e08></path>', 7)
              ])))
            ])) : createCommentVNode("", true),
            __props.legendItem.type === unref(LegendType).Item && __props.legendItem instanceof unref(LayerItem) && __props.legendItem.layer.legend.length > 0 ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: "relative w-32 h-32 mr-15",
              onMouseover: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["stop"]))
            }, [
              withDirectives((openBlock(), createElementBlock("button", {
                type: "button",
                onClick: withModifiers(toggleSymbology, ["stop"]),
                class: normalizeClass([controlAvailable(unref(LayerControl).Symbology) ? "cursor-pointer" : "cursor-default"]),
                disabled: !controlAvailable(unref(LayerControl).Symbology),
                content: __props.legendItem instanceof unref(LayerItem) && __props.legendItem.symbologyExpanded ? unref(t)("legend.symbology.hide") : unref(t)("legend.symbology.expand"),
                "aria-label": __props.legendItem instanceof unref(LayerItem) && __props.legendItem.symbologyExpanded ? unref(t)("legend.symbology.hide") : unref(t)("legend.symbology.expand")
              }, [
                !__props.legendItem.coverIcon ? (openBlock(), createBlock(SymbologyStack, {
                  key: 0,
                  class: normalizeClass([{
                    "pointer-events-none": !controlAvailable(unref(LayerControl).Symbology)
                  }, "w-32 h-32"]),
                  visible: __props.legendItem instanceof unref(LayerItem) && __props.legendItem.symbologyExpanded,
                  legendItem: __props.legendItem
                }, null, 8, ["class", "visible", "legendItem"])) : (openBlock(), createElementBlock("img", {
                  key: 1,
                  class: normalizeClass([{
                    "pointer-events-none": !controlAvailable(unref(LayerControl).Symbology)
                  }, "w-32 h-32 hover:scale-105"]),
                  src: __props.legendItem.coverIcon,
                  alt: "Cover icon not found :("
                }, null, 10, _hoisted_7))
              ], 10, _hoisted_6)), [
                [_directive_tippy, {
                  placement: "top-start"
                }]
              ])
            ], 32)) : createCommentVNode("", true),
            isGroup.value && controlAvailable(unref(LegendControl).Expand) ? (openBlock(), createElementBlock("div", {
              key: 2,
              class: normalizeClass(["expand-toggle p-8 pointer-events-none", { "rotate-180": __props.legendItem.expanded }])
            }, _cache[14] || (_cache[14] = [
              createElementVNode("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                height: "18",
                viewBox: "0 0 24 24",
                width: "18"
              }, [
                createElementVNode("path", { d: "M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" })
              ], -1)
            ]), 2)) : createCommentVNode("", true),
            __props.legendItem instanceof unref(LayerItem) && unref(allowMultilineItems) ? withDirectives((openBlock(), createElementBlock("div", {
              key: 3,
              class: normalizeClass(["flex-1 pointer-events-none m-5", `line-clamp-${unref(maxLines)}`])
            }, [
              createElementVNode("span", _hoisted_8, toDisplayString(__props.legendItem.name ?? (!__props.legendItem?.layer?.name ? __props.legendItem.layerId : __props.legendItem.layer?.name)), 1)
            ], 2)), [
              [_directive_truncate, {
                externalTrigger: true,
                noTruncateClass: true
              }]
            ]) : __props.legendItem instanceof unref(LayerItem) ? withDirectives((openBlock(), createElementBlock("div", _hoisted_9, [
              createElementVNode("span", null, toDisplayString(__props.legendItem.name ?? (!__props.legendItem.layer || __props.legendItem?.layer?.name === "" ? __props.legendItem.layerId : __props.legendItem.layer?.name)), 1)
            ])), [
              [_directive_truncate, { externalTrigger: true }]
            ]) : __props.legendItem instanceof unref(SectionItem) ? (openBlock(), createElementBlock("div", _hoisted_10, [
              __props.legendItem.infoType === unref(InfoType).Title && __props.legendItem.content ? (openBlock(), createElementBlock("h3", _hoisted_11, toDisplayString(__props.legendItem.content), 1)) : __props.legendItem.infoType === unref(InfoType).Title ? (openBlock(), createElementBlock("h3", _hoisted_12, toDisplayString(__props.legendItem.name), 1)) : __props.legendItem.infoType === unref(InfoType).Text ? (openBlock(), createElementBlock("p", _hoisted_13, toDisplayString(__props.legendItem.content), 1)) : __props.legendItem.infoType === unref(InfoType).Image ? (openBlock(), createElementBlock("img", {
                key: 3,
                src: __props.legendItem.content,
                alt: "InfoType image not found :("
              }, null, 8, _hoisted_14)) : __props.legendItem.infoType === unref(InfoType).Markdown ? (openBlock(), createElementBlock("div", {
                key: 4,
                class: "ramp-markdown",
                innerHTML: markdownToHtml(__props.legendItem.content)
              }, null, 8, _hoisted_15)) : (openBlock(), createBlock(resolveDynamicComponent(`${__props.legendItem.uid}-info-section`), { key: 5 }))
            ])) : createCommentVNode("", true),
            __props.legendItem.type === unref(LegendType).Error && reloadableLayer.value ? (openBlock(), createElementBlock("div", _hoisted_16, [
              withDirectives((openBlock(), createElementBlock("button", {
                type: "button",
                class: "text-gray-500 hover:text-black",
                content: unref(t)("legend.layer.controls.reload"),
                onMouseover: _cache[1] || (_cache[1] = withModifiers(() => {
                }, ["stop"])),
                onClick: withModifiers(reloadLayer, ["stop"]),
                "aria-label": unref(t)("legend.layer.controls.reload")
              }, _cache[15] || (_cache[15] = [
                createElementVNode("div", { class: "flex p-8" }, [
                  createElementVNode("svg", {
                    class: "inline-block fill-current w-18 h-18",
                    viewBox: "0 0 24 24"
                  }, [
                    createElementVNode("path", { d: "M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z" })
                  ])
                ], -1)
              ]), 40, _hoisted_17)), [
                [_directive_tippy, {
                  placement: "top-start"
                }]
              ])
            ])) : createCommentVNode("", true),
            (__props.legendItem.type === unref(LegendType).Item || __props.legendItem.type === unref(LegendType).Placeholder && unref(allowMultilineItems)) && __props.legendItem instanceof unref(LayerItem) ? (openBlock(), createBlock(LegendOptions, {
              key: 7,
              class: normalizeClass({
                invisible: __props.legendItem.type === unref(LegendType).Placeholder
              }),
              legendItem: __props.legendItem
            }, null, 8, ["class", "legendItem"])) : createCommentVNode("", true),
            __props.legendItem.type !== unref(LegendType).Item && __props.legendItem instanceof unref(LayerItem) ? (openBlock(), createElementBlock("div", _hoisted_18, [
              withDirectives((openBlock(), createElementBlock("button", {
                type: "button",
                class: "text-gray-500 hover:text-black",
                content: __props.legendItem.type === unref(LegendType).Error ? unref(t)("legend.layer.controls.remove") : unref(t)("legend.layer.controls.cancel"),
                onMouseover: _cache[2] || (_cache[2] = withModifiers(() => {
                }, ["stop"])),
                onClick: withModifiers(cancelOrRemoveLayer, ["stop"]),
                "aria-label": __props.legendItem.type === unref(LegendType).Error ? unref(t)("legend.layer.controls.remove") : unref(t)("legend.layer.controls.cancel")
              }, [
                createElementVNode("div", _hoisted_20, [
                  __props.legendItem.type === unref(LegendType).Placeholder ? (openBlock(), createElementBlock("svg", _hoisted_21, _cache[16] || (_cache[16] = [
                    createElementVNode("path", { d: "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z" }, null, -1)
                  ]))) : (openBlock(), createElementBlock("svg", _hoisted_22, _cache[17] || (_cache[17] = [
                    createElementVNode("path", { d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z" }, null, -1)
                  ])))
                ])
              ], 40, _hoisted_19)), [
                [_directive_tippy, {
                  placement: "top-start"
                }]
              ])
            ])) : createCommentVNode("", true),
            __props.legendItem.type === unref(LegendType).Item && __props.legendItem instanceof unref(LayerItem) && __props.legendItem.layerOffscale ? withDirectives((openBlock(), createElementBlock("div", {
              key: 9,
              class: "relative p-4 cursor-default",
              content: unref(t)("legend.layer.offscale"),
              onMouseover: _cache[3] || (_cache[3] = withModifiers(() => {
              }, ["stop"])),
              onClick: _cache[4] || (_cache[4] = withModifiers(() => {
              }, ["stop"])),
              "focus-icon": ""
            }, _cache[18] || (_cache[18] = [
              createElementVNode("svg", {
                class: "inline-block fill-gray-400 w-18 h-18",
                viewBox: "0 0 24 24"
              }, [
                createElementVNode("path", { d: "M19.81 14.99l1.19-.92-1.43-1.43-1.19.92 1.43 1.43zm-.45-4.72L21 9l-9-7-2.91 2.27 7.87 7.88 2.4-1.88zM3.27 1L2 2.27l4.22 4.22L3 9l1.63 1.27L12 16l2.1-1.63 1.43 1.43L12 18.54l-7.37-5.73L3 14.07l9 7 4.95-3.85L20.73 21 22 19.73 3.27 1z" })
              ], -1)
            ]), 40, _hoisted_23)), [
              [_directive_tippy, {
                placement: "top-start"
              }]
            ]) : createCommentVNode("", true),
            __props.legendItem.type === unref(LegendType).Item && __props.legendItem instanceof unref(LayerItem) && !__props.legendItem.layer?.mapLayer ? withDirectives((openBlock(), createElementBlock("div", {
              key: 10,
              class: "relative p-4 cursor-default",
              content: unref(t)("legend.layer.data.only"),
              onMouseover: _cache[5] || (_cache[5] = withModifiers(() => {
              }, ["stop"])),
              onClick: _cache[6] || (_cache[6] = withModifiers(() => {
              }, ["stop"])),
              "focus-icon": ""
            }, _cache[19] || (_cache[19] = [
              createElementVNode("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                height: "18",
                viewBox: "0 -960 960 960",
                width: "18",
                class: "inline-block fill-gray-400"
              }, [
                createElementVNode("path", { d: "m776.109-63.565-73.435-69.196q-51.302 32.573-106.091 59.145-54.788 26.572-116.255 26.572-88.94 0-167.803-33.893-78.862-33.894-138.052-93.239-59.19-59.346-93.19-138.205-34-78.86-34-167.619 0-64.607 19.12-125.521Q85.521-666.435 120-719.674l-50.848-50.848 68.761-68.761L844.87-132.326l-68.761 68.76Zm-345.392-92.653v-72.5l-52.25-52.086v-50.009l-219.01-218.752q-3 17.015-5 34.031-2 17.015-2 35.136 0 124.449 78.826 214.674 78.826 90.224 199.434 109.506Zm410.392-85.412-76.739-77.74q21.288-37.275 32.35-77.847 11.062-40.572 11.062-84.059 0-95.003-56.304-169.853-56.304-74.849-145.391-108.893v.522l-174.413 76.087v31.348L241.87-842.109q52.483-34.989 113.387-52.918 60.903-17.93 125.159-17.93 89.709 0 168.127 33.869 78.418 33.868 137.435 93.28 59.016 59.413 92.997 137.683 33.982 78.269 33.982 167.993 0 64.203-18.43 125.111-18.429 60.907-53.418 113.391Z" })
              ], -1)
            ]), 40, _hoisted_24)), [
              [_directive_tippy, {
                placement: "top-end"
              }]
            ]) : createCommentVNode("", true),
            __props.legendItem.type === unref(LegendType).Item && __props.legendItem instanceof unref(LayerItem) && __props.legendItem.layerOffscale ? (openBlock(), createElementBlock("div", _hoisted_25, [
              withDirectives((openBlock(), createElementBlock("button", {
                type: "button",
                class: "p-4",
                content: unref(t)("legend.layer.zoomToVisible"),
                onMouseover: _cache[7] || (_cache[7] = withModifiers(() => {
                }, ["stop"])),
                onClick: _cache[8] || (_cache[8] = withModifiers(($event) => __props.legendItem.layer.zoomToVisibleScale(), ["stop"]))
              }, _cache[20] || (_cache[20] = [
                createElementVNode("svg", {
                  class: "m-auto",
                  xmlns: "http://www.w3.org/2000/svg",
                  height: "18",
                  viewBox: "0 0 24 24",
                  width: "18"
                }, [
                  createElementVNode("path", { d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" }),
                  createElementVNode("path", {
                    d: "M0 0h24v24H0V0z",
                    fill: "none"
                  }),
                  createElementVNode("path", { d: "M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z" })
                ], -1)
              ]), 40, _hoisted_26)), [
                [_directive_tippy, {
                  placement: "top-start"
                }]
              ])
            ])) : __props.legendItem.type === unref(LegendType).Item && controlAvailable(unref(LegendControl).Visibility) ? (openBlock(), createBlock(_sfc_main$3, {
              key: 12,
              checked: __props.legendItem.visibility,
              value: __props.legendItem,
              isRadio: __props.legendItem.parent && __props.legendItem.parent.exclusive,
              legendItem: __props.legendItem,
              disabled: __props.legendItem instanceof unref(LayerItem) && !__props.legendItem.layerControlAvailable(unref(LayerControl).Visibility),
              label: isGroup.value ? "Group" : "Layer"
            }, null, 8, ["checked", "value", "isRadio", "legendItem", "disabled", "label"])) : createCommentVNode("", true)
          ], 42, _hoisted_2)), [
            [_directive_focus_item, "show-truncate"],
            [_directive_tippy, {
              placement: "top-start",
              trigger: "manual focus",
              aria: "describedby"
            }]
          ]),
          __props.legendItem.type === unref(LegendType).Placeholder || __props.legendItem instanceof unref(LayerItem) && __props.legendItem.layerRedrawing && __props.legendItem.visibility ? (openBlock(), createElementBlock("div", _hoisted_27, _cache[21] || (_cache[21] = [
            createElementVNode("div", { class: "progress-line" }, null, -1)
          ]))) : createCommentVNode("", true)
        ]),
        __props.legendItem instanceof unref(LayerItem) && __props.legendItem.symbologyExpanded ? withDirectives((openBlock(), createElementBlock("div", _hoisted_28, [
          symbologyStack.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_29, [
            __props.legendItem instanceof unref(LayerItem) && __props.legendItem.description ? (openBlock(), createElementBlock("p", _hoisted_30, toDisplayString(__props.legendItem.description), 1)) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(symbologyStack.value, (item) => {
              return openBlock(), createElementBlock("div", {
                class: "m-5",
                key: item.uid
              }, [
                item.imgUrl && __props.legendItem.symbologyRenderStyle === "images" || !item.imgUrl && layerType.value === "ogc-wms" ? (openBlock(), createElementBlock("div", _hoisted_31, [
                  item.imgUrl ? (openBlock(), createElementBlock("div", _hoisted_32, [
                    createElementVNode("img", {
                      class: "max-w-full",
                      src: item.imgUrl
                    }, null, 8, _hoisted_33)
                  ])) : item.imgHeight ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: "symbologyIcon w-full p-5",
                    innerHTML: getLegendGraphic(item)
                  }, null, 8, _hoisted_34)) : createCommentVNode("", true),
                  item.label ? withDirectives((openBlock(), createElementBlock("div", _hoisted_35, [
                    createElementVNode("span", null, toDisplayString(item.label), 1),
                    !item.imgUrl && symbologyStack.value.length > 1 || item.imgUrl && item.definitionClause ? (openBlock(), createBlock(_sfc_main$3, {
                      key: 0,
                      class: "float-right",
                      value: item,
                      legendItem: __props.legendItem,
                      checked: item.visibility,
                      disabled: !controlAvailable(unref(LayerControl).Visibility),
                      label: "Symbol"
                    }, null, 8, ["value", "legendItem", "checked", "disabled"])) : createCommentVNode("", true)
                  ])), [
                    [_directive_truncate]
                  ]) : createCommentVNode("", true)
                ])) : (openBlock(), createElementBlock("div", _hoisted_36, [
                  item.imgUrl ? (openBlock(), createElementBlock("div", _hoisted_37, [
                    createElementVNode("img", {
                      class: "w-32 h-32",
                      src: item.imgUrl
                    }, null, 8, _hoisted_38)
                  ])) : item.svgcode ? (openBlock(), createElementBlock("div", _hoisted_39, [
                    createElementVNode("span", {
                      innerHTML: item.svgcode
                    }, null, 8, _hoisted_40)
                  ])) : createCommentVNode("", true),
                  withDirectives((openBlock(), createElementBlock("div", _hoisted_41, [
                    createTextVNode(toDisplayString(item.label), 1)
                  ])), [
                    [_directive_truncate]
                  ]),
                  modifiableLayer.value && __props.legendItem.layer.supportsFeatures && (!item.imgUrl && symbologyStack.value.length > 1 || item.imgUrl && item.definitionClause) ? (openBlock(), createBlock(_sfc_main$3, {
                    key: 2,
                    value: item,
                    legendItem: __props.legendItem,
                    checked: item.visibility,
                    disabled: !controlAvailable(unref(LayerControl).Visibility),
                    label: "Symbol"
                  }, null, 8, ["value", "legendItem", "checked", "disabled"])) : createCommentVNode("", true)
                ]))
              ]);
            }), 128))
          ])) : createCommentVNode("", true),
          !symbologyStackLoaded.value ? (openBlock(), createElementBlock("div", _hoisted_42, [
            withDirectives((openBlock(), createElementBlock("div", _hoisted_43, [
              isAnimationEnabled.value ? (openBlock(), createElementBlock("div", _hoisted_44)) : createCommentVNode("", true),
              withDirectives((openBlock(), createElementBlock("div", _hoisted_45, [
                createElementVNode("span", null, toDisplayString(unref(t)("legend.symbology.loading")), 1)
              ])), [
                [_directive_truncate]
              ])
            ])), [
              [_directive_truncate]
            ])
          ])) : createCommentVNode("", true)
        ])), [
          [_directive_focus_item]
        ]) : createCommentVNode("", true),
        __props.legendItem.expanded ? (openBlock(), createElementBlock("div", _hoisted_46, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.legendItem.children, (item) => {
            return openBlock(), createBlock(_component_item, {
              legendItem: item,
              key: item.uid
            }, null, 8, ["legendItem"]);
          }), 128))
        ])) : createCommentVNode("", true)
      ])) : createCommentVNode("", true);
    };
  }
});

const item = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-b1261e08"]]);

const item$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    default: item
}, Symbol.toStringTag, { value: 'Module' }));

export { configUpgrade, createInstance, geo, layerConfigUpgrade, version };
