{"version":3,"file":"index-BsQzSgqw.js","sources":["../../src/fixtures/export-northarrow/index.ts"],"sourcesContent":["import { fabric } from 'fabric';\nimport merge from 'deepmerge';\n\nimport { FixtureInstance } from '@/api/internal';\nimport type { ExportAPI, ExportSubFixture } from '@/fixtures/export/api/export';\nimport type { ExportConfig } from '../export/store';\nimport { Point, SpatialReference } from '@/geo/api';\n\nclass ExportNorthArrowFixture extends FixtureInstance implements ExportSubFixture {\n    get config(): any {\n        const fixtureConfig: ExportConfig | undefined = this.$iApi.fixture.get<ExportAPI>('export').config;\n        return fixtureConfig?.mapElements;\n    }\n\n    async make(options?: any): Promise<fabric.Object> {\n        /**\n         * This is a placeholder function that always returns 0 (for the case of mercator projection). Actual implementation is further down.\n         * @param normalizedPositionX The X position of the north arrow, normalized to a value between 0 and 100 with 0 being leftmost and 100 being rightmost.\n         * @returns 0\n         * @memberof ExportNorthArrowFixture\n         **/\n        let calculateNorthArrowAngle = (normalizedPositionX: number) => {\n            return 0;\n        };\n        let normalizedPositionX = 0;\n\n        const arrowSVG =\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 61.06 96.62\"><g transform=\"translate(-1.438 30.744)\"><g fill=\"none\" stroke=\"#000\"><path d=\"m61 35c0 16.02-12.984 29-29 29-16.02 0-29-12.984-29-29 0-16.02 12.984-29 29-29 16.02 0 29 12.984 29 29z\" stroke-width=\"3\"/><path d=\"m55 35c0 12.979-10.521 23.5-23.5 23.5-12.979 0-23.5-10.521-23.5-23.5 0-12.979 10.521-23.5 23.5-23.5 12.979 0 23.5 10.521 23.5 23.5z\" transform=\"matrix(1.01148 0 0 .99988-.089.004)\" stroke-width=\".497\"/><path d=\"m32 35v-32\" stroke-width=\".25\"/></g><path d=\"m32-9.453l28.938 73.826-29-29-29 29z\" fill=\"#fff\" stroke=\"#fff\" stroke-width=\"3\"/><path d=\"m32-9.453l29 73.45-29-29-29 29z\" fill=\"none\" stroke=\"#000\" stroke-linecap=\"square\"/><text x=\"22.71\" y=\"-10.854\" font-family=\"OPEN SANS\" word-spacing=\"0\" line-height=\"125%\" letter-spacing=\"0\" font-size=\"40\"><tspan x=\"22.71\" y=\"-10.854\" font-family=\"Adobe Heiti Std R\" font-size=\"26\">N</tspan></text></g><g transform=\"translate(0-3.829)\" fill=\"none\" stroke=\"#000\" stroke-width=\".25\"><path d=\"m4 92.82l6.74-3.891\"/><path d=\"m4.603 90.7l10.397-6\"/><path d=\"m3 95.17l4-2.309\"/><path d=\"m5.442 88.45l13.856-8\"/><path d=\"m12 72.26l18.686-10.812\"/><path d=\"m14.593 65.45l16.09-9.291\"/><path d=\"m15.343 63.24l15.343-8.858\"/><path d=\"m16.877 60.58l13.809-7.972\"/><path d=\"m17.511 58.45l13.174-7.606\"/><path d=\"m18.412 56.15l12.274-7.087\"/><path d=\"m19 54.04l11.427-6.597\"/><path d=\"m20 51.757l10.822-6.311\"/><path d=\"m20.826 49.45l9.86-5.693\"/><path d=\"m21.48 47.3l9.206-5.315\"/><path d=\"m23 44.647l7.686-4.437\"/><path d=\"m23.744 42.45l6.928-4\"/><path d=\"m24.549 40.21l6.137-3.543\"/><path d=\"m25 38.18l5.686-3.283\"/><path d=\"m26.663 35.446l4.02-2.323\"/><path d=\"m27.617 33.12l3.069-1.772\"/><path d=\"m28 31.13l2.686-1.551\"/><path d=\"m29.15 28.694l1.534-.886\"/><path d=\"m13 69.909l17.686-10.211\"/><path d=\"m9.206 79.19l21.48-12.402\"/><path d=\"m8.36 81.45l22.326-12.89\"/><path d=\"m7.671 83.62l19.946-11.516\"/><path d=\"m6.137 86.27l17.02-9.827\"/><path d=\"m10 76.956l20.686-11.943\"/><path d=\"m11.279 74.45l19.407-11.205\"/><path d=\"m14 67.56l16.686-9.634\"/><path d=\"m30.562 65.744v-43.566\" transform=\"translate(0 3.829)\"/></g></svg>';\n\n        // below angle calculation code duplicated from north arrow fixture\n        const innerShell = document.querySelector('.inner-shell')!;\n        const sr: SpatialReference = this.$iApi.geo.map.getSR();\n        let angle = 0;\n\n        if (sr.isWebMercator()) {\n            // the north arrow will always point up in mercator projection\n            angle = 0;\n        } else {\n            const arrowWidth = 50;\n            // north value (set longitude to be half of Canada extent (141° W, 52° W))\n            const pole: Point = new Point('pole', { x: -96, y: 90 });\n            const projPole = (await this.$iApi.geo.proj.projectGeometry(sr, pole)) as Point;\n            const poleScreenPos = this.$iApi.geo.map.mapPointToScreenPoint(projPole);\n            // get angle from bottom centre\n            const bcScreenPos = {\n                screenX: innerShell.clientWidth / 2,\n                screenY: innerShell.clientHeight\n            };\n            // calculate angle\n            angle =\n                (Math.atan(\n                    (poleScreenPos.screenX - bcScreenPos.screenX) / (bcScreenPos.screenY - poleScreenPos.screenY)\n                ) *\n                    180) /\n                Math.PI;\n\n            const arrowLeft =\n                innerShell.clientWidth / 2 +\n                innerShell.clientHeight * Math.tan((angle * Math.PI) / 180) -\n                arrowWidth / 2;\n\n            // Normalize the position to a scale of 0 to 100\n            const positionX = Math.round((arrowLeft / innerShell.clientWidth) * 100);\n\n            // Ensure positionX is clamped between 0 and 100\n            normalizedPositionX = Math.min(Math.max(positionX, 0), 100);\n\n            /**\n             * Calculate the angle of the north arrow based on its provided position on the screen.\n             * @param normalizedPositionX The X position of the north arrow, normalized to a value between 0 and 100 with 0 being leftmost and 100 being rightmost.\n             * @returns The angle the north arrow needs to be rotated by in order to be pointing due north from its position.\n             * @memberof ExportNorthArrowFixture\n             **/\n            calculateNorthArrowAngle = (normalizedPositionX: number) => {\n                if (normalizedPositionX < 0 || normalizedPositionX > 100) {\n                    throw new Error('Normalized position must be between 0 and 100');\n                }\n                const screenPosX = (innerShell.clientWidth * normalizedPositionX) / 100;\n                // We use half of arrowWidth as the X position because we assume the north arrow is always at the top of the screen and\n                // its center point is half the height.\n                return (\n                    Math.atan((poleScreenPos.screenX - screenPosX) / (arrowWidth / 2 - poleScreenPos.screenY)) *\n                    (180 / Math.PI)\n                );\n            };\n        }\n\n        const fbImgConfig: any = {\n            top: 0,\n            left: 0,\n            originX: 'center',\n            originY: 'center',\n            angle: angle\n        };\n\n        // load the svg string into a fabric group\n        const group: Array<fabric.Object> = [];\n        interface CustomGroup extends fabric.Group {\n            positionX: number;\n            getAngleFromPosition: (normalizedPositionX: number) => number;\n        }\n\n        let loadedObjects = new fabric.Group();\n        fabric.loadSVGFromString(\n            arrowSVG,\n            () => {\n                // the fabric group is loaded here\n                loadedObjects = new fabric.Group(group);\n                // Add custom properties to the group including the north arrow X position and the angle calculation function\n                (loadedObjects as CustomGroup).positionX = normalizedPositionX;\n                (loadedObjects as CustomGroup).getAngleFromPosition = calculateNorthArrowAngle;\n            },\n            (_: any, object: any) => {\n                // the group is constructed here\n                group.push(object);\n            }\n        );\n\n        // apply the options\n        loadedObjects.set(merge(fbImgConfig, options || {}));\n        return Promise.resolve(loadedObjects);\n    }\n}\n\nexport default ExportNorthArrowFixture;\n"],"names":["ExportNorthArrowFixture","FixtureInstance","options","calculateNorthArrowAngle","normalizedPositionX","arrowSVG","innerShell","sr","angle","pole","Point","projPole","poleScreenPos","bcScreenPos","arrowLeft","positionX","screenPosX","fbImgConfig","group","loadedObjects","fabric","_","object","merge"],"mappings":";;AAQA,MAAMA,UAAgCC,EAA4C;AAAA,EAC9E,IAAI,SAAc;AAEd,WADgD,KAAK,MAAM,QAAQ,IAAe,QAAQ,EAAE,QACtE;AAAA,EAC1B;AAAA,EAEA,MAAM,KAAKC,GAAuC;AAO1C,QAAAC,IAA2B,CAACC,MACrB,GAEPA,IAAsB;AAE1B,UAAMC,IACF,+lEAGEC,IAAa,SAAS,cAAc,cAAc,GAClDC,IAAuB,KAAK,MAAM,IAAI,IAAI;AAChD,QAAIC,IAAQ;AAER,QAAAD,EAAG;AAEK,MAAAC,IAAA;AAAA,SACL;AAGG,YAAAC,IAAc,IAAIC,EAAM,QAAQ,EAAE,GAAG,KAAK,GAAG,GAAA,CAAI,GACjDC,IAAY,MAAM,KAAK,MAAM,IAAI,KAAK,gBAAgBJ,GAAIE,CAAI,GAC9DG,IAAgB,KAAK,MAAM,IAAI,IAAI,sBAAsBD,CAAQ,GAEjEE,IAAc;AAAA,QAChB,SAASP,EAAW,cAAc;AAAA,QAClC,SAASA,EAAW;AAAA,MAAA;AAGxB,MAAAE,IACK,KAAK;AAAA,SACDI,EAAc,UAAUC,EAAY,YAAYA,EAAY,UAAUD,EAAc;AAAA,MAAA,IAErF,MACJ,KAAK;AAET,YAAME,IACFR,EAAW,cAAc,IACzBA,EAAW,eAAe,KAAK,IAAKE,IAAQ,KAAK,KAAM,GAAG,IAC1D,KAAa,GAGXO,IAAY,KAAK,MAAOD,IAAYR,EAAW,cAAe,GAAG;AAGvE,MAAAF,IAAsB,KAAK,IAAI,KAAK,IAAIW,GAAW,CAAC,GAAG,GAAG,GAQ1DZ,IAA2B,CAACC,MAAgC;AACpDA,YAAAA,IAAsB,KAAKA,IAAsB;AAC3C,gBAAA,IAAI,MAAM,+CAA+C;AAE7D,cAAAY,IAAcV,EAAW,cAAcF,IAAuB;AAIhE,eAAA,KAAK,MAAMQ,EAAc,UAAUI,MAAe,KAAa,IAAIJ,EAAc,QAAQ,KACxF,MAAM,KAAK;AAAA,MAAA;AAAA,IAGxB;AAEA,UAAMK,IAAmB;AAAA,MACrB,KAAK;AAAA,MACL,MAAM;AAAA,MACN,SAAS;AAAA,MACT,SAAS;AAAA,MACT,OAAAT;AAAA,IAAA,GAIEU,IAA8B,CAAA;AAMhC,QAAAC,IAAgB,IAAIC,SAAO;AACxBA,WAAAA,EAAAA,OAAA;AAAA,MACHf;AAAA,MACA,MAAM;AAEc,QAAAc,IAAA,IAAIC,EAAAA,OAAO,MAAMF,CAAK,GAErCC,EAA8B,YAAYf,GAC1Ce,EAA8B,uBAAuBhB;AAAA,MAC1D;AAAA,MACA,CAACkB,GAAQC,MAAgB;AAErB,QAAAJ,EAAM,KAAKI,CAAM;AAAA,MACrB;AAAA,IAAA,GAIJH,EAAc,IAAII,EAAMN,GAAaf,KAAW,CAAE,CAAA,CAAC,GAC5C,QAAQ,QAAQiB,CAAa;AAAA,EACxC;AACJ;"}