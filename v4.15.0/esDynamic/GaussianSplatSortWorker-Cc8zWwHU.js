class m{constructor(e,s,i,c=!1){this.distances=e,this.sortOrderIndices=s,this.numGaussians=i,this.preciseSort=c}}class d{constructor(e,s){this.distances=e,this.sortedOrderIndices=s}}let u=null,o=null;const p=10,y=20,g=.25;function b(n,e){u?.length!==n&&(u=new Uint32Array(n)),o&&o.length===1+(1<<e)?o.fill(0):o=new Uint32Array(1+(1<<e))}function M(n,e){const s=n.length,i=Math.max(p,Math.min(y,Math.round(Math.log2(s/g)))),c=1+(1<<i);b(s,i);let a=n[0],l=n[0];for(let t=0;t<n.length;t++)a=Math.min(a,n[t]),l=Math.max(l,n[t]);const f=l-a;if(f<1e-6)for(let t=0;t<s;++t)u[t]=0,o[0]++;else{const t=(1<<i)/f;for(let r=0;r<s;r++){const h=(n[r]-a)*t>>>0;u[r]=h,o[h]++}}for(let t=1;t<c;t++)o[t]+=o[t-1];for(let t=0;t<s;t++){const r=u[t];e[--o[r]]=t}}async function S(n){const{distances:e,sortOrderIndices:s,preciseSort:i,numGaussians:c}=n,a=e.subarray(0,c),l=s.subarray(0,c);if(a.length===0||l.length===0)return{result:new d(e,s),transferList:[e.buffer,s.buffer]};if(i){const f=Array.from(l.keys());f.sort((r,h)=>a[r]-a[h]||r-h);const t=f.map(r=>l[r]);l.set(t)}else M(a,l);return{result:new d(e,s),transferList:[e.buffer,s.buffer]}}function w(){u=null,o=null}export{m as SplatSortWorkerInput,d as SplatSortWorkerOutput,w as destroy,S as sort};
