import{s as V,dw as se,dx as ae,bb as J,bM as pe,dH as ee,T as E,b2 as ge,dJ as re,kl as Je,gd as xe,km as Le,kn as Ue,G as L,b7 as $e,be as te,bc as Ye,l as _e,a8 as We,ko as z,a9 as Xe,bQ as Fe,gI as Ke,db as et,de as tt,dm as we,dl as it,dn as st,c3 as ne,dc as at,dA as rt,b1 as Se,aW as nt,dB as lt,ak as ot}from"./main-pOgmbpmS.js";import{G as ut}from"./projectionUtils-BiGIzqtS.js";import{P as Ie}from"./normalizeUtils-BXWkPmB4.js";import{u as ct}from"./featureConversionUtils-safiWyiN.js";import{WhereClauseCache as dt}from"./WhereClauseCache-BWkkV7D1.js";import{i as Te}from"./fieldType-C2gJYAmT.js";import{a as U,h as $,y as le,w as be,n as ht,I as Y,l as mt,d as Re}from"./timeSupport-DaYu5Pve.js";import{a as C,h as N,f as oe,S as O,x as ft,B as yt,w as ve,M as pt}from"./queryUtils-DNZ0MRDW.js";import{t as gt}from"./QueryEngineCapabilities-DPRPXYxY.js";import{s as Ae}from"./quantizationUtils-Gg7wbGX3.js";import{b as xt}from"./utils-HHEqtvAe.js";import{m as ue,B as _t,d as Ft,f as Qe,p as Ve,C as wt,k as St,$ as It,E as Tt,P as bt,U as Rt,g as vt,v as At,L as Qt,G as ze}from"./utils-cOmnBGHF.js";import{e as Vt,t as Be}from"./SnappingCandidate-DIiHATRz.js";import{m as zt,n as Bt,a as Et,b as Mt,s as Dt}from"./FixedIntervalBinParameters-CigXOway.js";import{Z as qt}from"./FieldsIndex-CGBGd8H6.js";import{G as Gt}from"./Scheduler-W6yolxj_.js";const Ee=new dt(50,500),W="unsupported-query",Me=" as ",De=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeBigInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong"]),qe=new Set(["esriFieldTypeDate","esriFieldTypeDateOnly","esriFieldTypeTimeOnly","esriFieldTypeTimestampOffset"]),Ct=new Set(["esriFieldTypeString","esriFieldTypeGUID","esriFieldTypeGlobalID",...De,...qe]);function ce(n,e,t={}){const i=P(e,n);if(!i){const a=Ee.getError(e,n);throw new V(W,"invalid SQL expression",{expression:e,error:a})}const s=t.expressionName||"expression";if(t.validateStandardized&&!i.isStandardized)throw new V(W,`${s} is not standard`,{expression:e});if(t.validateAggregate&&!i.isAggregate)throw new V(W,`${s} does not contain a valid aggregate function`,{expression:e});return i.fieldNames}function Nt(n,e,t,i){if(!t)return!0;const s="where clause";return q(n,e,ce(n,t,{validateStandardized:!0,expressionName:s}),{expressionName:s,query:i}),!0}function Ot(n,e,t,i,s){if(!t)return!0;const a="having clause",r=ce(n,t,{validateAggregate:!0,expressionName:a});if(q(n,e,r,{expressionName:a,query:s}),!P(t,n)?.getExpressions().every(l=>{const{aggregateType:u,field:o}=l,d=n.get(o)?.name;return i.some(c=>{const{onStatisticField:h,statisticType:m}=c;return n.get(h)?.name===d&&m.toLowerCase().trim()===u})}))throw new V(W,"expressions in having clause should also exist in outStatistics",{having:t});return!0}function P(n,e){return n?Ee.get(n,e):null}function Ge(n){return/\((.*?)\)/.test(n)?n:n.split(Me)[0]}function Pt(n){return n.split(Me)[1]}function q(n,e,t,i={}){const s=new Map;if(Zt(s,n,e,i.allowedFieldTypes??Ct,t),s.size){const a=i.expressionName??"expression";throw new V(W,`${a} contains invalid or missing fields`,{errors:Array.from(s.values()),query:i.query})}}function Zt(n,e,t,i,s){const a=s.includes("*")?[...t,...s.filter(r=>r!=="*")]:s;for(const r of a)if(e.get(r))Ce(n,e,t,i,r);else try{const l=ce(e,Ge(r),{validateStandardized:!0});for(const u of l)Ce(n,e,t,i,u)}catch(l){n.set(r,{type:"expression-error",expression:r,error:l})}}function Ce(n,e,t,i,s){const a=e.get(s);a?t.has(a.name)?i!=="all"&&i?.has(a.type)===!1&&n.set(s,{type:"invalid-type",fieldName:a.name,fieldType:Te.fromJSON(a.type),allowedFieldTypes:Array.from(i,r=>Te.fromJSON(r))}):n.set(s,{type:"missing-field",fieldName:a.name}):n.set(s,{type:"invalid-field",fieldName:s})}const jt=5;class kt{constructor(){this._storage=new Map,this._purgeInterval=jt,this._sweep=()=>{if(this._timer=void 0,!this._storage)return;const e=1e3*this._purgeInterval,t=performance.now()-e;for(const[i,s]of this._storage){if(!(s.time<t))return void(this._storage.size>0&&(this._timer=setTimeout(this._sweep,e)));this._storage.delete(i)}}}destroy(){this._storage?.clear(),this._storage=null,clearTimeout(this._timer)}put(e,t){this._storage?.set(e,new Jt(t)),this._scheduleSweep()}get(e){const t=this._storage?.get(e);if(t)return this._storage?.delete(e),t.time=performance.now(),this._storage?.set(e,t),t.items}clear(){this._storage?.clear()}_scheduleSweep(){this._storage&&(this._timer??=setTimeout(this._sweep,1e3*this._purgeInterval))}get test(){}}let Ht=0;class Jt{constructor(e){this.items=e,this.time=performance.now(),this.id=Ht++}}let X=class{constructor(n,e,t){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=n.returnDistinctValues??!1,this.fieldsIndex=t,this.featureAdapter=e;const i=n.outFields;if(i&&!i.includes("*")){this.outFields=i;let s=0;for(const a of i){const r=Ge(a),l=this.fieldsIndex.get(r),u=l?null:P(r,t),o=l?l.name:Pt(a)||"FIELD_EXP_"+s++;this._fieldDataCache.set(a,{alias:o,clause:u})}}}countDistinctValues(n){return this.returnDistinctValues?(n.forEach(e=>this.getAttributes(e)),this._returnDistinctMap.size):n.length}getAttributes(n){const e=this._processAttributesForOutFields(n);return this._processAttributesForDistinctValues(e)}getFieldValue(n,e,t){const i=t?t.name:e;let s=null;return this._fieldDataCache.has(i)?s=this._fieldDataCache.get(i)?.clause:t||(s=P(e,this.fieldsIndex),this._fieldDataCache.set(i,{alias:i,clause:s})),t?this.featureAdapter.getAttribute(n,i):s?.calculateValue(n,this.featureAdapter)}getDataValues(n,e,t=!0){const i=e.normalizationType,s=e.normalizationTotal,a=this.fieldsIndex.get(e.field),r=se(a)||ae(a),l=J(a);return n.map(u=>{let o=e.field&&this.getFieldValue(u,e.field,this.fieldsIndex.get(e.field));if(e.field2?(o=`${ue(o)}${e.fieldDelimiter}${ue(this.getFieldValue(u,e.field2,this.fieldsIndex.get(e.field2)))}`,e.field3&&(o=`${o}${e.fieldDelimiter}${ue(this.getFieldValue(u,e.field3,this.fieldsIndex.get(e.field3)))}`)):typeof o=="string"&&t&&(r?o=o?new Date(o).getTime():null:l&&(o=o?xt(o):null)),i&&Number.isFinite(o)){const d=i==="field"&&e.normalizationField?this.getFieldValue(u,e.normalizationField,this.fieldsIndex.get(e.normalizationField)):null;o=_t(o,i,d,s)}return o})}async getExpressionValues(n,e,t,i,s){const{arcadeUtils:a}=await pe(),r=a.hasGeometryOperations(e);r&&await a.enableGeometryOperations();const l=a.createFunction(e),u=a.getViewInfo(t),o={fields:this.fieldsIndex.fields};return n.map(d=>{const c={attributes:this.featureAdapter.getAttributes(d),layer:o,geometry:r?{...U(i.geometryType,i.hasZ,i.hasM,this.featureAdapter.getGeometry(d)),spatialReference:t?.spatialReference}:null},h=a.createExecContext(c,u,s);return a.executeFunction(l,h)})}validateItem(n,e){return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:P(e,this.fieldsIndex)}),this._fieldDataCache.get(e)?.clause?.testFeature(n,this.featureAdapter)??!1}validateItems(n,e){return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:P(e,this.fieldsIndex)}),this._fieldDataCache.get(e)?.clause?.testSet(n,this.featureAdapter)??!1}_processAttributesForOutFields(n){const e=this.outFields;if(!e?.length)return this.featureAdapter.getAttributes(n);const t={};for(const i of e){const{alias:s,clause:a}=this._fieldDataCache.get(i);t[s]=a?a.calculateValue(n,this.featureAdapter):this.featureAdapter.getAttribute(n,s)}return t}_processAttributesForDistinctValues(n){if(n==null||!this.returnDistinctValues)return n;const e=this.outFields,t=[];if(e)for(const a of e){const{alias:r}=this._fieldDataCache.get(a);t.push(n[r])}else for(const a in n)t.push(n[a]);const i=`${(e||["*"]).join(",")}=${t.join(",")}`;let s=this._returnDistinctMap.get(i)||0;return this._returnDistinctMap.set(i,++s),s>1?null:n}};const k="bin";class R{constructor(e,t,i){this.items=e,this.query=t,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const e=new X(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:i,outStatistics:s}=this.query;if(!t?.length)return 1;const a=new Map,r=new Map,l=new Set;for(const u of s){const{statisticType:o}=u,d=o!=="exceedslimit"?u.onStatisticField:void 0;if(!r.has(d)){const h=[];for(const m of t){const f=this._getAttributeValues(e,m,this.items,a);h.push(f)}r.set(d,this._calculateUniqueValues(h,this.items,e.returnDistinctValues))}const c=r.get(d);for(const h in c){const{data:m,items:f}=c[h],y=m.join(",");i&&!e.validateItems(f,i)||l.add(y)}}return l.size}async createQueryResponse(){let e;if(this.query.outStatistics?e=this.query.outStatistics.some(t=>t.statisticType==="exceedslimit")?this._createExceedsLimitQueryResponse():await this._createStatisticsQueryResponse(this.query,this.items):e=this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry){const t=this.query.geometry;ee(this.query.outSR)&&!E(t.spatialReference,this.query.outSR)?e.queryGeometry=$({spatialReference:this.query.outSR,...C(t,t.spatialReference,this.query.outSR)}):e.queryGeometry=$({spatialReference:this.query.outSR,...t})}return e}createSnappingResponse(e,t,i){const s=this.featureAdapter,a=Ne(this.hasZ,this.hasM),{point:r,mode:l}=e,u=typeof e.distance=="number"?e.distance:e.distance.x,o=typeof e.distance=="number"?e.distance:e.distance.y,d={candidates:[]},c=this.geometryType==="esriGeometryPolygon",h=this.geometryType==="esriGeometryPolyline"||this.geometryType==="esriGeometryPoint",m=this._getPointCreator(l,t,this.spatialReference,i),f=new Oe(null,0),y=new Oe(null,0),w={x:0,y:0,z:0};for(const S of this.items){const I=s.getGeometry(S);if(I==null)continue;const{coords:F}=I,x=I.isPoint?Ut:I.lengths;if(f.coords=F,y.coords=F,e.returnEdge){let g=0;for(let _=0;_<x.length;_++){const p=x[_],T=g;for(let b=0;b<p;b++,g+=a){if(!c&&b===p-1)continue;const A=f;A.coordsIndex=g;const v=y;v.coordsIndex=b===p-1?T:g+a;const M=w;if(!Lt(w,r,A,v))continue;const Q=(r.x-M.x)/u,B=(r.y-M.y)/o,G=Q*Q+B*B;G<=1&&d.candidates.push(Vt(s.getObjectId(S),m(M),Math.sqrt(G),m(A),m(v)))}}}if(e.vertexMode==="all"){let g=0;for(let _=0;_<x.length;_++){const p=x[_],T=g,b=y;b.coordsIndex=T;for(let A=0;A<p;A++,g+=a){const v=f;if(v.coordsIndex=g,c&&A===p-1&&v.x===b.x&&v.y===b.y)continue;const M=(r.x-v.x)/u,Q=(r.y-v.y)/o,B=M*M+Q*Q;B<=1&&d.candidates.push(Be(s.getObjectId(S),m(v),Math.sqrt(B)))}}}else if(h&&e.vertexMode==="ends"){let g=0;const _=[];for(let p=0;p<x.length;p++){_.push(g);const T=x[p];g+=T*a,!c&&T>1&&_.push(g-a)}for(const p of _){const T=f;T.coordsIndex=p;const b=(r.x-T.x)/u,A=(r.y-T.y)/o,v=b*b+A*A;v<=1&&d.candidates.push(Be(s.getObjectId(S),m(T),Math.sqrt(v)))}}}return d.candidates.sort((S,I)=>S.distance-I.distance),d}_getPointCreator(e,t,i,s){const a=s==null||E(i,s)?u=>u:u=>C(u,i,s),{hasZ:r}=this,l=0;return e==="3d"?r&&t?({x:u,y:o,z:d})=>a({x:u,y:o,z:d}):({x:u,y:o})=>a({x:u,y:o,z:l}):({x:u,y:o})=>a({x:u,y:o})}async createSummaryStatisticsResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,minValue:l,maxValue:u,scale:o,timeZone:d,outStatisticTypes:c}=e,h=this.fieldsIndex.get(t),m=ge(h)||se(h)||ae(h),f=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:o,timeZone:d},this.items),y=Ft({normalizationType:a,normalizationField:s,minValue:l,maxValue:u}),w={value:.5,fieldType:h?.type},S=re(h)?Qe({values:f,supportsNullCount:y,percentileParams:w,outStatisticTypes:c}):Ve({values:f,minValue:l,maxValue:u,useSampleStdDev:!a,supportsNullCount:y,percentileParams:w,outStatisticTypes:c});return wt(S,c,m)}async createUniqueValuesResponse(e){const{field:t,valueExpression:i,domains:s,returnAllCodedValues:a,scale:r,timeZone:l}=e,u=await this._getDataValues({field:t,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:i,scale:r,timeZone:l},this.items,!1),o=St(u);return It(o,s,a,e.fieldDelimiter)}async createClassBreaksResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:l,standardDeviationInterval:u,minValue:o,maxValue:d,numClasses:c,scale:h,timeZone:m}=e,f=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:h,timeZone:m},this.items),y=Tt(f,{field:t,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:l,standardDeviationInterval:u,minValue:o,maxValue:d,numClasses:c});return bt(y,l)}async createHistogramResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:l,standardDeviationInterval:u,minValue:o,maxValue:d,numBins:c,scale:h,timeZone:m}=e,f=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:h,timeZone:m},this.items);return Rt(f,{field:t,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:l,standardDeviationInterval:u,minValue:o,maxValue:d,numBins:c})}_sortFeatures(e,t,i){if(e.length>1&&t?.length)for(const s of t.slice().reverse()){const a=s.split(" "),r=a[0],l=this.fieldsIndex.get(r),u=!!a[1]&&a[1].toLowerCase()==="desc",o=vt(l?.type,u);e.sort((d,c)=>{const h=i(d,r,l),m=i(c,r,l);return o(h,m)})}}_createFeatureQueryResponse(e){const{items:t,geometryType:i,hasM:s,hasZ:a,objectIdField:r,spatialReference:l}=this,{outFields:u,outSR:o,quantizationParameters:d,resultRecordCount:c,resultOffset:h,returnZ:m,returnM:f}=e,y=c!=null&&t.length>(h||0)+c,w=u&&(u.includes("*")?[...this.fieldsIndex.fields]:u.map(S=>this.fieldsIndex.get(S)));return{exceededTransferLimit:y,features:this._createFeatures(e,t),fields:w,geometryType:i,hasM:s&&f,hasZ:a&&m,objectIdFieldName:r,spatialReference:$(o||l),transform:d&&Ae(d)||null}}_createFeatures(e,t){const i=new X(e,this.featureAdapter,this.fieldsIndex),{hasM:s,hasZ:a}=this,{orderByFields:r,quantizationParameters:l,returnGeometry:u,returnCentroid:o,maxAllowableOffset:d,resultOffset:c,resultRecordCount:h,returnZ:m=!1,returnM:f=!1}=e,y=a&&m,w=s&&f;let S=[],I=0;const F=[...t];if(this._sortFeatures(F,r,(g,_,p)=>i.getFieldValue(g,_,p)),this.geometryType&&(u||o)){const g=Ae(l)??void 0,_=this.geometryType==="esriGeometryPolygon"||this.geometryType==="esriGeometryPolyline";if(u&&!o)for(const p of F){const T=this.featureAdapter.getGeometry(p),b=this._addFeatureJSONMetadata(p,{attributes:i.getAttributes(p),geometry:U(this.geometryType,this.hasZ,this.hasM,T,d,g,y,w)});_&&T&&!b.geometry&&(b.centroid=le(this,this.featureAdapter.getCentroid(p,this),g)),S[I++]=b}else if(!u&&o)for(const p of F)S[I++]=this._addFeatureJSONMetadata(p,{attributes:i.getAttributes(p),centroid:le(this,this.featureAdapter.getCentroid(p,this),g)});else for(const p of F)S[I++]=this._addFeatureJSONMetadata(p,{attributes:i.getAttributes(p),centroid:le(this,this.featureAdapter.getCentroid(p,this),g),geometry:U(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(p),d,g,y,w)})}else for(const g of F){const _=i.getAttributes(g);_&&(S[I++]=this._addFeatureJSONMetadata(g,{attributes:_}))}const x=c||0;if(h!=null){const g=x+h;S=S.slice(x,Math.min(S.length,g))}return S}_addFeatureJSONMetadata(e,t){const i=this.featureAdapter.getMetadata?.(e);return i!==void 0&&(t.metadata=i),t}_createExceedsLimitQueryResponse(){let e=!1,t=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY;for(const a of this.query.outStatistics??[])if(a.statisticType==="exceedslimit"){t=a.maxPointCount!=null?a.maxPointCount:Number.POSITIVE_INFINITY,i=a.maxRecordCount!=null?a.maxRecordCount:Number.POSITIVE_INFINITY,s=a.maxVertexCount!=null?a.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")e=this.items.length>t;else if(this.items.length>i)e=!0;else{const a=Ne(this.hasZ,this.hasM),r=this.featureAdapter;e=this.items.reduce((l,u)=>{const o=r.getGeometry(u);return l+(o!=null&&o.coords.length||0)},0)/a>s}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(e)}}]}}async _createStatisticsQueryResponse(e,t,i={attributes:{}}){const s=[],a=new Map,r=new Map,l=new Map,u=new Map,o=new X(e,this.featureAdapter,this.fieldsIndex),d=e.outStatistics,{groupByFieldsForStatistics:c,having:h,orderByFields:m,resultRecordCount:f}=e,y=c?.length,w=!!y,S=w?c[0]:null,I=w&&!this.fieldsIndex.get(S);for(const x of d??[]){const{outStatisticFieldName:g,statisticType:_}=x,p=x,T=_!=="exceedslimit"?x.onStatisticField:void 0,b=_==="percentile_disc"||_==="percentile_cont",A=_==="EnvelopeAggregate"||_==="CentroidAggregate"||_==="ConvexHullAggregate",v=w&&y===1&&(T===S||I)&&_==="count";if(w){if(!l.has(T)){const G=[];for(const ie of c){const K=this._getAttributeValues(o,ie,t,a);G.push(K)}l.set(T,this._calculateUniqueValues(G,t,!A&&o.returnDistinctValues))}const Q=l.get(T);if(!Q)continue;const B=Object.keys(Q);for(const G of B){const{count:ie,data:K,items:me,itemPositions:je}=Q[G],fe=K.join(",");if(!h||o.validateItems(me,h)){const j=u.get(fe)||{attributes:{}};if(A){j.aggregateGeometries||(j.aggregateGeometries={});const{aggregateGeometries:D,outStatisticFieldName:H}=await this._getAggregateGeometry(p,me);j.aggregateGeometries[H]=D}else{let D=null;if(v)D=ie;else{const H=this._getAttributeValues(o,T,t,a),ye=je.map(He=>H[He]);D=b&&"statisticParameters"in p?this._getPercentileValue(p,ye):this._getStatisticValue(p,ye,null,o.returnDistinctValues)}j.attributes[g]=D}let ke=0;c.forEach((D,H)=>j.attributes[this.fieldsIndex.get(D)?D:"EXPR_"+ ++ke]=K[H]),u.set(fe,j)}}}else if(A){i.aggregateGeometries||(i.aggregateGeometries={});const{aggregateGeometries:Q,outStatisticFieldName:B}=await this._getAggregateGeometry(p,t);i.aggregateGeometries[B]=Q}else{const Q=this._getAttributeValues(o,T,t,a);i.attributes[g]=b&&"statisticParameters"in p?this._getPercentileValue(p,Q):this._getStatisticValue(p,Q,r,o.returnDistinctValues)}const M=_!=="min"&&_!=="max"||!re(this.fieldsIndex.get(T))&&!this._isAnyDateField(T)?null:this.fieldsIndex.get(T)?.type;s.push({name:g,alias:g,type:M||"esriFieldTypeDouble"})}const F=w?Array.from(u.values()):[i];return this._sortFeatures(F,m,(x,g)=>x.attributes[g]),f&&(F.length=Math.min(f,F.length)),{fields:s,features:F}}_isAnyDateField(e){const t=this.fieldsIndex.get(e);return ge(t)||se(t)||ae(t)||J(t)}async _getAggregateGeometry(e,t){const{convexHull:i,union:s}=await import("./geometryEngineJSON-Dgtva7qo.js").then(y=>y.g),{statisticType:a,outStatisticFieldName:r}=e,{featureAdapter:l,spatialReference:u,geometryType:o,hasZ:d,hasM:c}=this,h=t.map(y=>U(o,d,c,l.getGeometry(y))),m=i(u,h,!0)[0],f={aggregateGeometries:null,outStatisticFieldName:null};if(a==="EnvelopeAggregate"){const y=m?Je(m):xe(s(u,h));f.aggregateGeometries={...y,spatialReference:u},f.outStatisticFieldName=r||"extent"}else if(a==="CentroidAggregate"){const y=m?Le(m):Ue(xe(s(u,h)));f.aggregateGeometries={x:y[0],y:y[1],spatialReference:u},f.outStatisticFieldName=r||"centroid"}else a==="ConvexHullAggregate"&&(f.aggregateGeometries=m,f.outStatisticFieldName=r||"convexHull");return f}_getStatisticValue(e,t,i,s){const{onStatisticField:a,statisticType:r}=e;let l=null;return l=i?.has(a)?i.get(a):re(this.fieldsIndex.get(a))||this._isAnyDateField(a)?Qe({values:t,returnDistinct:s}):Ve({values:s?[...new Set(t)]:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(a,l),l[r==="var"?"variance":r]}_getPercentileValue(e,t){const{onStatisticField:i,statisticParameters:s,statisticType:a}=e,{value:r,orderBy:l}=s,u=this.fieldsIndex.get(i);return At(t,{value:r,orderBy:l,fieldType:u?.type,isDiscrete:a==="percentile_disc"})}_getAttributeValues(e,t,i,s){if(s.has(t))return s.get(t);const a=this.fieldsIndex.get(t),r=i.map(l=>e.getFieldValue(l,t,a));return s.set(t,r),r}_calculateUniqueValues(e,t,i){const s={},a=t.length;for(let r=0;r<a;r++){const l=t[r],u=[];for(const d of e)u.push(d[r]);const o=u.join(",");s[o]==null?s[o]={count:1,data:u,items:[l],itemPositions:[r]}:(i||s[o].count++,s[o].items.push(l),s[o].itemPositions.push(r))}return s}async _getDataValues(e,t,i=!0){const s=new X(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:a,scale:r,timeZone:l}=e;return a?s.getExpressionValues(t,a,{viewingMode:"map",scale:r,spatialReference:this.query.outSR||this.spatialReference},{geometryType:this.geometryType,hasZ:this.hasZ,hasM:this.hasM},l):s.getDataValues(t,L(e),i)}_calculateHistogramBins(e,t,i){if(t.min==null&&t.max==null)return[];const s=t.intervals,a=t.min??0,r=t.max??0,l=s.map(([u,o])=>({minValue:u,maxValue:o,count:0,items:[]}));for(let u=0;u<e.length;u++){const o=e[u],d=i[u];if(o!=null&&o>=a&&o<=r){const c=Qt(s,o);c>-1&&(l[c].count++,l[c].items.push(d))}}return l}async createQueryBinsResponse(e){const t=e.bin?.splitBy;if(!t)return this._createBinsResponse(e);const{value:i,outAlias:s,valueType:a}=t,r=[],l=[{name:s??i,alias:s??i,type:a??"esriFieldTypeString"},{name:k,alias:k,type:"esriFieldTypeInteger"}],u=new X(e,this.featureAdapter,this.fieldsIndex),o=new Map,d=[...this.items];this._sortFeatures(d,[i],(m,f,y)=>u.getFieldValue(m,f,y));const c=this._getAttributeValues(u,i,d,o),h=this._calculateUniqueValues([c],d,u.returnDistinctValues);for(const m in h){const{items:f}=h[m],y=await this._createBinsResponse(e,f);if(r.push(...y.features.map(w=>({...w,attributes:{...w.attributes,[s??i]:m}}))),y.fields)for(const w of y.fields)l.some(S=>S.name===w.name)||l.push(w)}return{fields:l,features:r}}async _createBinsResponse(e,t){const i=e.bin;switch(t=t??this.items,i.type){case"autoIntervalBin":return this._createAutoIntervalBinsResponse(Mt.fromJSON(i),e,t);case"dateBin":return this._createDateBinsResponse(Et.fromJSON(i),e,t);case"fixedBoundariesBin":return this._createFixedBoundariesBinsResponse(Bt.fromJSON(i),e,t);case"fixedIntervalBin":return this._createFixedIntervalBinsResponse(zt.fromJSON(i),e,t)}}async _createAutoIntervalBinsResponse(e,t,i){const{field:s,normalizationField:a,numBins:r,normalizationType:l,normalizationTotal:u,start:o,end:d}=e,c=await this._getDataValues({field:e.field,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal,timeZone:t.outTimeReference?.ianaTimeZone},i),h=ze(c,{field:s,normalizationField:a,normalizationType:l,normalizationTotal:u,numBins:r,minValue:N(o,!1),maxValue:N(d,!1)}),m=this._calculateHistogramBins(c,h,i);return this._createFeaturesFromHistogramBins(m,t)}async _createDateBinsResponse(e,t,i){const{field:s,interval:a,start:r,end:l,snapToData:u,returnFullIntervalBin:o}=e,d=a.unit,c=await this._getDataValues({field:e.field,timeZone:t.outTimeReference?.ianaTimeZone},i),h=J(this.fieldsIndex.get(s)),m=Dt.toJSON(d),f=c.filter(Boolean).sort((F,x)=>F-x),y=r!=null?N(r,h):f[0],w=l!=null?N(l,h):f[f.length-1],S=[];if(y!=null&&w!=null){const F={zone:t.outTimeReference?.ianaTimeZone??$e},x=te.fromMillis(y,F),g=te.fromMillis(w,F);if(u==="last"){let _=g;for(;_>x;){const p=_.minus({[m]:a.value});if(p<x){S.unshift([o?p.toMillis():x.toMillis(),_.toMillis()]);break}S.unshift([p.toMillis(),_.toMillis()]),_=p}}else{let _=u==="first"?x:x.startOf(m);for(;_<=g;){const p=_.plus({[m]:a.value});if(p>g){S.push([_.toMillis(),o?p.toMillis():g.toMillis()]);break}S.push([_.toMillis(),p.toMillis()]),_=p}}}const I=this._calculateHistogramBins(c,{intervals:S,min:y,max:w},i);return this._createFeaturesFromHistogramBins(I,t)}async _createFixedBoundariesBinsResponse(e,t,i){const{field:s}=e,a=await this._getDataValues({field:s,timeZone:t.outTimeReference?.ianaTimeZone},i),r=J(this.fieldsIndex.get(s)),l=e.boundaries.map(c=>N(c,r)).sort((c,h)=>c-h),u=[];for(let c=0;c<l.length-1;c++)u.push([l[c],l[c+1]]);const o={intervals:u,min:l.at(0),max:l.at(-1)},d=this._calculateHistogramBins(a,o,i);return this._createFeaturesFromHistogramBins(d,t)}async _createFixedIntervalBinsResponse(e,t,i){const{field:s,interval:a,start:r,end:l}=e,u=await this._getDataValues({field:e.field,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal,timeZone:t.outTimeReference?.ianaTimeZone},i),o=J(this.fieldsIndex.get(s)),d=ze(u,{field:s,classificationMethod:"defined-interval",definedInterval:a,minValue:N(r,o),maxValue:N(l,o)},!0),c=this._calculateHistogramBins(u,d,i);return this._createFeaturesFromHistogramBins(c,t)}async _createFeaturesFromHistogramBins(e,t){const{upperBoundaryAlias:i,lowerBoundaryAlias:s}=t,a=s||"lowerBoundary",r=i||"upperBoundary",l=[],u=[{name:a,alias:a,type:"esriFieldTypeDouble"},{name:r,alias:r,type:"esriFieldTypeDouble"}],o=t.bin?.stackBy?.value,d=t.bin?.stackBy?.outAlias;o&&u.push({name:k,alias:k,type:"esriFieldTypeInteger"},{name:d??o,alias:d??o,type:"esriFieldTypeString"});let c=0;const h=t.bin.type==="dateBin",m=t.outTimeReference?.ianaTimeZone;for(const f of e){const{minValue:y,maxValue:w,items:S}=f,I={attributes:{}};let F;if(I.attributes[a]=h&&m&&y!=null?te.fromMillis(y,{zone:m}).toISO():y,I.attributes[r]=h&&m&&w!=null?te.fromMillis(w,{zone:m}).toISO():w,o?(F=await this._createStatisticsQueryResponse({...t,groupByFieldsForStatistics:[o],orderByFields:[o]},S),I.attributes[k]=++c,t.bin.jsonStyle==="flat"?l.push(...F.features.map(({attributes:{EXPR_1:x,...g},..._})=>({..._,attributes:d??x?{...g,[d??x]:x,...I.attributes}:{...g,...I.attributes}}))):(I.stackedAttributes=F.features.map(({attributes:{EXPR_1:x,...g}})=>d??x?{...g,[d??x]:x}:g),l.push(I))):(t.bin?.splitBy&&(I.attributes[k]=++c),F=await this._createStatisticsQueryResponse(t,S,I),l.push(I)),F.fields)for(const x of F.fields)u.some(g=>g.name===x.name)||u.push(x)}return t.binOrder==="desc"&&l.reverse(),{fields:u,features:l}}}function Lt(n,e,t,i){const s=i.x-t.x,a=i.y-t.y,r=e.x-t.x,l=e.y-t.y,u=s*s+a*a;if(u===0)return!1;const o=r*s+l*a,d=Math.min(1,Math.max(0,o/u));return n.x=t.x+s*d,n.y=t.y+a*d,!0}function Ne(n,e){return n?e?4:3:e?3:2}class Oe{constructor(e,t){this.coords=e,this.coordsIndex=t}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}const Ut=[1],Z="unsupported-query";async function $t(n,e){const t=n.bin;if(!t.onField&&!t.onExpression?.value||t.type==="autoIntervalBin"&&t.parameters.numberOfBins==null||t.type==="dateBin"&&(t.parameters.number==null||t.parameters.unit==null)||t.type==="fixedBoundariesBin"&&t.parameters.boundaries==null||t.type==="fixedIntervalBin"&&t.parameters.interval==null)throw new V(Z,"Unsupported query options",{query:n});return de(n,e)}async function de(n,{fieldsIndex:e,geometryType:t,spatialReference:i,availableFields:s}){if(n.geometryPrecision!=null||n.multipatchOption&&n.multipatchOption!=="xyFootprint"||n.pixelSize||n.relationParam||n.text)throw new V(Z,"Unsupported query options",{query:n});return Pe(e,s,n),Wt(e,s,n),Promise.all([be(n,t,i),oe(i,n.outSR)]).then(()=>n)}function Pe(n,e,t){const{returnDistinctValues:i,outStatistics:s}=t,a=s?s.map(r=>r.outStatisticFieldName&&r.outStatisticFieldName.toLowerCase()).filter(Boolean):[];if("orderByFields"in t&&t.orderByFields&&t.orderByFields.length>0){const r=" asc",l=" desc",u=t.orderByFields.map(o=>{const d=o.toLowerCase();return d.includes(r)?d.split(r)[0]:d.includes(l)?d.split(l)[0]:o}).filter(o=>!a.includes(o));q(n,e,u,{expressionName:"orderByFields",query:t})}if("outFields"in t){if(t.outFields?.length)q(n,e,t.outFields,{expressionName:"outFields",query:t,allowedFieldTypes:"all"});else if(i)throw new V(Z,"outFields should be specified for returnDistinctValues",{query:t})}Nt(n,e,t.where,t)}const Yt=new Set([...De,...qe]);function Wt(n,e,t){const{outStatistics:i,groupByFieldsForStatistics:s,having:a}=t,r=s?.length,l=i?.length;if(a){if(!r||!l)throw new V(Z,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:t});Ot(n,e,a,i,t)}if(l){if(!ei(i))return;const u=i.map(o=>o.onStatisticField).filter(Boolean);q(n,e,u,{expressionName:"onStatisticFields",query:t}),r&&q(n,e,s,{expressionName:"groupByFieldsForStatistics",query:t});for(const o of i){const{onStatisticField:d,statisticType:c}=o;if((c==="percentile_disc"||c==="percentile_cont")&&"statisticParameters"in o){const{statisticParameters:h}=o;if(!h)throw new V(Z,"statisticParameters should be set for percentile type",{definition:o,query:t})}else n.get(d)&&c!=="count"&&c!=="min"&&c!=="max"&&q(n,e,[d],{expressionName:`outStatistics with '${c}' statistic type`,allowedFieldTypes:Yt,query:t})}}}async function Xt(n,e,{fieldsIndex:t,geometryType:i,spatialReference:s,availableFields:a}){if(n.geometryPrecision!=null||n.multipatchOption||n.pixelSize||n.relationParam||n.text||n.outStatistics||n.groupByFieldsForStatistics||n.having||n.orderByFields)throw new V(Z,"Unsupported query options",{query:n});return Pe(t,a,n),Promise.all([Kt(t,a,e,n),be(n,i,s),oe(s,n.outSR)]).then(()=>n)}async function Kt(n,e,t,i){let s=[];if(t.valueExpression){const{arcadeUtils:a}=await pe();s=a.extractFieldNames(t.valueExpression)}if(t.field&&s.push(t.field),t.field2&&s.push(t.field2),t.field3&&s.push(t.field3),t.normalizationField&&s.push(t.normalizationField),!s.length&&!t.valueExpression)throw new V(Z,"field or valueExpression is required",{params:t});q(n,e,s,{expressionName:"statistics",query:i})}function ei(n){return n!=null&&n.every(e=>e.statisticType!=="exceedslimit")}const ti="unsupported-query";class ii{constructor(e){this._changeHandle=null,this.capabilities={query:gt},this.geometryType=e.geometryType,this.hasM=!!e.hasM,this.hasZ=!!e.hasZ,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._cache=e.cache??new kt,this.timeInfo=e.timeInfo,this.featureIdInfo=e.featureIdInfo,e.featureIdInfo.type==="object-id"&&(this.objectIdField=e.featureIdInfo.fieldName),this._changeHandle=this.featureStore.events.on("changed",()=>this._clearCache()),this.fieldsIndex=Ye(e.fieldsIndex)?e.fieldsIndex:qt.fromJSON(e.fieldsIndex),!e.availableFields||e.availableFields.length===1&&e.availableFields[0]==="*"?this.availableFields=new Set(this.fieldsIndex.fields.map(t=>t.name)):this.availableFields=new Set(e.availableFields.map(t=>this.fieldsIndex.get(t)?.name).filter(t=>t!=null)),e.scheduler&&e.priority?this._frameTask=e.scheduler.registerTask(e.priority):this._frameTask=Gt}destroy(){this._changeHandle=_e(this._changeHandle),this._frameTask=_e(this._frameTask),this._clearCache(),We(this._cache)}get featureAdapter(){return this.featureStore.featureAdapter}async executeQuery(e,t){const i=z(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryFeatureSet(e),i)}async executeQueryForCount(e={},t){const i=z(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForCount(e),i)}async executeQueryForExtent(e,t){const i=z(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForExtent(e),i)}async executeQueryForIds(e,t){return Array.from(await this.executeQueryForIdSet(e,t))}async executeQueryForIdSet(e,t){const i=z(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForIdSet(e),i)}async executeQueryForLatestObservations(e,t){const i=z(t);if(!this.timeInfo?.trackIdField)throw new V(ti,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});return await this._frameTask.scheduleGenerator(()=>this._executeQueryForLatestObservations(e),i)}async executeQueryForOpaqueFeatures(e,t){const i=z(t);return(await this._frameTask.scheduleGenerator(()=>this._executeQuery(e,{}),i)).items}async executeAttributeBinsQuery(e,t){const i=z(t);return e=L(e),await this._frameTask.scheduleGenerator(()=>this._executeAttributeBinsQuery(e),i)}async executeQueryForSummaryStatistics(e={},t,i){const s=z(i);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForSummaryStatistics(e,t),s)}async executeQueryForUniqueValues(e={},t,i){const s=z(i);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForUniqueValues(e,t),s)}async executeQueryForClassBreaks(e={},t,i){const s=z(i);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForClassBreaks(e,t),s)}async executeQueryForHistogram(e={},t,i){const s=z(i);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForHistogram(e,t),s)}async executeQueryForSnapping(e,t){const i=z(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForSnapping(e,i),i)}async fetchRecomputedExtents(e){const t=z(e);this._timeExtentPromise||=ht(this.timeInfo,this.featureStore);const[i,s]=await Promise.all([this._getFullExtent(),this._timeExtentPromise]);return Xe(t),{fullExtent:i,timeExtent:s}}_clearCache(){this._cache.clear(),this._allFeaturesPromise=null,this._timeExtentPromise=null,this._fullExtentPromise=null}async*_executeQueryFeatureSet(e){try{const t=yield*this._executeQuery(e,{});return yield,await t.createQueryResponse()}catch(t){if(t!==O)throw t;return await new R([],e,this).createQueryResponse()}}async*_executeQueryForCount(e){try{const t=yield*this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null});return yield,t.createQueryResponseForCount()}catch(t){if(t!==O)throw t;return 0}}async*_executeQueryForExtent(e){const t=e.outSR;try{const i=yield*this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null});yield;const s=i.size;if(!s)return{count:0,extent:null};const a=await this._getBounds(i.items,i.spatialReference,t??this.spatialReference);return yield,{count:s,extent:a}}catch(i){if(i===O)return{count:0,extent:null};throw i}}async*_executeQueryForIdSet(e){try{const t=yield*this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null});yield;const i=t.items,s=new Set;for(const a of i)s.add(t.featureAdapter.getObjectId(a));return s}catch(t){if(t===O)return new Set;throw t}}async*_executeQueryForLatestObservations(e){try{const t=yield*this._executeQuery(e,{});return yield,this._filterLatest(t),yield,await t.createQueryResponse()}catch(t){if(t!==O)throw t;return await new R([],e,this).createQueryResponse()}}async*_executeAttributeBinsQuery(e){let t;try{e=await ft(e,this.definitionExpression,this.spatialReference),yield,e=await $t(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield;const i=yield*this._executeSceneFilterQuery(e);yield,t=yield*this._executeGeometryQuery(e,i),yield,this._executeAggregateIdsQuery(t),yield,this._executeObjectIdsQuery(t),yield,this._executeTimeQuery(t),yield,this._executeAttributesQuery(t),yield}catch(i){if(i!==O)throw i;t=new R([],e,this)}return await t.createQueryBinsResponse(e)}async*_executeQueryForSummaryStatistics(e={},t){const{field:i,normalizationField:s,valueExpression:a}=t,r=yield*this._executeQueryForStatistics(e,{field:i,normalizationField:s,valueExpression:a});return yield,await r.createSummaryStatisticsResponse(t)}async*_executeQueryForUniqueValues(e={},t){const{field:i,field2:s,field3:a,valueExpression:r}=t,l=yield*this._executeQueryForStatistics(e,{field:i,field2:s,field3:a,valueExpression:r});return yield,await l.createUniqueValuesResponse(t)}async*_executeQueryForClassBreaks(e,t){const{field:i,normalizationField:s,valueExpression:a}=t,r=yield*this._executeQueryForStatistics(e,{field:i,normalizationField:s,valueExpression:a});return yield,await r.createClassBreaksResponse(t)}async*_executeQueryForHistogram(e,t){const{field:i,normalizationField:s,valueExpression:a}=t,r=yield*this._executeQueryForStatistics(e,{field:i,normalizationField:s,valueExpression:a});return yield,await r.createHistogramResponse(t)}async*_executeQueryForSnapping(e,t){const{point:i,distance:s,returnEdge:a,vertexMode:r}=e;if(!a&&r==="none")return{candidates:[]};let l=L(e.query);l=await yt(l,this.definitionExpression,this.spatialReference),yield,l=await de(l,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield;const u=!E(i.spatialReference,this.spatialReference);u&&(await oe(i.spatialReference,this.spatialReference),yield);const o=typeof s=="number"?s:s.x,d=typeof s=="number"?s:s.y,c={xmin:i.x-o,xmax:i.x+o,ymin:i.y-d,ymax:i.y+d,spatialReference:i.spatialReference},h=u?C(c,this.spatialReference):c;if(!h)return{candidates:[]};const m=(await Ie(Fe(i),null,{signal:t}))[0];yield;const f=(await Ie(Fe(h),null,{signal:t}))[0];if(yield,m==null||f==null)return{candidates:[]};const y=await this._searchFeatures(he(f.toJSON()));yield;const w=new R(y,l,this);this._executeObjectIdsQuery(w),yield,this._executeTimeQuery(w),yield,this._executeAttributesQuery(w),yield,yield*this._executeGeometryQueryForSnapping(w),yield;const S=m.toJSON(),I=u?C(S,this.spatialReference):S,F=u?Math.max(h.xmax-h.xmin,h.ymax-h.ymin)/2:s;return w.createSnappingResponse({...e,point:I,distance:F},l.returnZ,i.spatialReference)}async _getBounds(e,t,i){const s=Ke(et(),at);return await this.featureStore.forEachBounds(e,a=>tt(s,a)),Ze(s,t,i,this.spatialReference,this.hasZ)}_getFullExtent(){return this._fullExtentPromise||="getFullExtent"in this.featureStore&&this.featureStore.getFullExtent?Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)):this._getAllFeatures().then(e=>this._getBounds(e,this.spatialReference,this.spatialReference)),this._fullExtentPromise}async _getAllFeaturesQueryEngineResult(e){return new R(await this._getAllFeatures(),e,this)}async _getAllFeatures(){if(this._allFeaturesPromise==null){const i=[];this._allFeaturesPromise=(async()=>await this.featureStore.forEach(s=>i.push(s)))().then(()=>we(i))}const e=this._allFeaturesPromise,t=await e;return e===this._allFeaturesPromise?t.slice():this._getAllFeatures()}async*_executeQuery(e,t){e=L(e),e=await ve(e,this.definitionExpression,this.spatialReference),yield,e=await de(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield,e={...e,...t};const i=yield*this._executeSceneFilterQuery(e);yield;const s=yield*this._executeGeometryQuery(e,i);return yield,this._executeAggregateIdsQuery(s),yield,this._executeObjectIdsQuery(s),yield,this._executeTimeQuery(s),yield,this._executeAttributesQuery(s),s}async*_executeSceneFilterQuery(e){if(e.sceneFilter==null)return null;const{outSR:t,returnGeometry:i,returnCentroid:s}=e,a=this.featureStore.featureSpatialReference,r=e.sceneFilter.geometry,l=a==null||E(a,r.spatialReference)?r:C(r,a);if(!l)return null;const u=i||s,o=ee(t)&&!E(this.spatialReference,t)&&u?async f=>this._project(f,t):f=>f;yield;const d=this.featureAdapter,c=await this._searchFeatures(he(l));if(yield,e.sceneFilter.spatialRelationship==="disjoint"){if(!c.length)return null;const f=new Set;for(const x of c)f.add(d.getObjectId(x));const y=await this._getAllFeatures();yield;const w=await Y("esriSpatialRelDisjoint",l,this.geometryType,this.hasZ,this.hasM);yield;const S=x=>!f.has(d.getObjectId(x))||w(d.getGeometry(x)),I=yield*this._runSpatialFilter(y,S);yield;const F=new R(I,e,this);return await o(F)}if(!c.length)return new R([],e,this);if(this._canExecuteSinglePass(l,e))return await o(new R(c,e,this));const h=await Y("esriSpatialRelContains",l,this.geometryType,this.hasZ,this.hasM);yield;const m=yield*this._runSpatialFilter(c,f=>h(d.getGeometry(f)));return yield,await o(new R(m,e,this))}async*_executeGeometryQuery(e,t){if(t!=null&&t.items.length===0)return t;const{geometry:i,outSR:s,returnGeometry:a,returnCentroid:r}=e,l=t?null:this._getCacheKey(e),u=l?this._cache.get(l):null;if(u)return new R(u,e,this);const o=ee(s)&&!E(this.spatialReference,s),d=a||r,c=async F=>(o&&d&&await this._project(F,s),l&&this._cache.put(l,F.items),F),h=this.featureStore.featureSpatialReference,m=!i||h==null||E(h,i.spatialReference)?i:C(i,h);if(!m)return await c(t??await this._getAllFeaturesQueryEngineResult(e));yield;const f=this.featureAdapter;let y=await this._searchFeatures(he(i));yield;const w=e.spatialRel??"esriSpatialRelIntersects";if(w==="esriSpatialRelDisjoint"){if(!y.length)return await c(t??await this._getAllFeaturesQueryEngineResult(e));const F=new Set;for(const b of y)F.add(f.getObjectId(b));let x;t!=null?x=t.items:(yield,x=await this._getAllFeatures(),yield);const g=await Y(w,m,this.geometryType,this.hasZ,this.hasM);yield;const _=b=>!F.has(f.getObjectId(b))||g(f.getGeometry(b)),p=yield*this._runSpatialFilter(x,_);yield;const T=new R(p,e,this);return await c(T)}if(t!=null){const F=new st;y=y.filter(x=>it(t.items,x,t.items.length,F)>=0)}if(!y.length){const F=new R([],e,this);return l&&this._cache.put(l,F.items),F}if(this._canExecuteSinglePass(m,e))return await c(new R(y,e,this));const S=await Y(w,m,this.geometryType,this.hasZ,this.hasM);yield;const I=yield*this._runSpatialFilter(y,F=>S(f.getGeometry(F)));return yield,await c(new R(I,e,this))}_executeAggregateIdsQuery(e){if(e.items.length===0||!e.query.aggregateIds?.length||this.aggregateAdapter==null)return;const t=new Set;for(const s of e.query.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(s).forEach(a=>t.add(a));const i=this.featureAdapter.getObjectId;e.items=e.items.filter(s=>t.has(i(s)))}_executeObjectIdsQuery(e){if(e.items.length===0||!e.query.objectIds?.length)return;const t=new Set(e.query.objectIds),i=this.featureAdapter.getObjectId;e.items=e.items.filter(s=>t.has(i(s)))}_executeTimeQuery(e){if(e.items.length===0)return;const t=mt(this.timeInfo,e.query.timeExtent,this.featureAdapter);t!=null&&(e.items=e.items.filter(t))}_executeAttributesQuery(e){if(e.items.length===0)return;const t=P(e.query.where,this.fieldsIndex);if(t){if(!t.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter(i=>t.testFeature(i,this.featureAdapter))}}async*_executeGeometryQueryForSnapping(e){const{query:t}=e,{spatialRel:i}=t;if(!e?.items?.length||!t.geometry||!i)return;const s=await Y(i,t.geometry,this.geometryType,this.hasZ,this.hasM);yield;const a=this.featureAdapter,r=u=>s(a.getGeometry(u)),l=yield*this._runSpatialFilter(e.items,r);e.items=l}*_runSpatialFilter(e,t){if(!t)return e;if(this._frameTask==null)return e.filter(a=>t(a));let i=yield;const s=new Array;for(const a of e)t(a)&&s.push(a),i.madeProgress(),i.done&&(i=yield);return s}_filterLatest(e){const{trackIdField:t,startTimeField:i,endTimeField:s}=this.timeInfo,a=s||i,r=new Map,l=this.featureAdapter.getAttribute;for(const u of e.items){const o=l(u,t),d=l(u,a),c=r.get(o);(!c||d>l(c,a))&&r.set(o,u)}e.items=Array.from(r.values())}_getCacheKey(e){const{geometry:t,spatialRel:i,returnGeometry:s,returnCentroid:a,outSR:r,resultType:l,cacheHint:u}=e;if(l!=="tile"&&!u)return null;const o=s||a;return ee(r)&&!E(this.spatialReference,r)&&o?JSON.stringify([t,i,r]):JSON.stringify([t,i])}_canExecuteSinglePass(e,t){const{spatialRel:i}=t;return Re(e)&&(i==="esriSpatialRelEnvelopeIntersects"||this.geometryType==="esriGeometryPoint"&&(i==="esriSpatialRelIntersects"||i==="esriSpatialRelContains"))}async _project(e,t){if(!t||E(this.spatialReference,t))return e;const i=this.featureAdapter,s=ut()?await this._getFullExtent():void 0,a=await pt(e.items.map(r=>U(this.geometryType,this.hasZ,this.hasM,i.getGeometry(r))),this.spatialReference,t,{areaOfInterestExtent:s});return e.items=we(a.map((r,l)=>i.cloneWithGeometry(e.items[l],ct(r,this.hasZ,this.hasM)))),e}async _searchFeatures(e){const t=new Set;await Promise.all(e.map(s=>this.featureStore.forEachInBounds(s,a=>t.add(a))));const i=Array.from(t.values());return t.clear(),i}async*_executeQueryForStatistics(e,t){e=L(e);try{e=await ve(e,this.definitionExpression,this.spatialReference),yield,e=await Xt(e,t,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield;const i=yield*this._executeSceneFilterQuery(e);yield;const s=yield*this._executeGeometryQuery(e,i);return yield,this._executeAggregateIdsQuery(s),yield,this._executeObjectIdsQuery(s),yield,this._executeTimeQuery(s),yield,this._executeAttributesQuery(s),yield,s}catch(i){if(i!==O)throw i;return new R([],e,this)}}get test(){}}function he(n){if(Re(n)){if(rt(n))return[Se(Math.min(n.xmin,n.xmax),Math.min(n.ymin,n.ymax),Math.max(n.xmin,n.xmax),Math.max(n.ymin,n.ymax))];if(nt(n))return n.rings.map(e=>Se(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1])))}return[lt(ot(),n)]}function Ze(n,e,t,i,s){const a={xmin:n[0],ymin:n[1],xmax:n[3],ymax:n[4],spatialReference:$(i)};s&&isFinite(n[2])&&isFinite(n[5])&&(a.zmin=n[2],a.zmax=n[5],a.hasZ=!0);const r=C(a,e,t);if(r.spatialReference=$(t),r.xmax-r.xmin===0){const l=ne(r.spatialReference);r.xmin-=l,r.xmax+=l}if(r.ymax-r.ymin===0){const l=ne(r.spatialReference);r.ymin-=l,r.ymax+=l}if(s&&r.zmin!=null&&r.zmax!=null&&r.zmax-r.zmin===0){const l=ne(r.spatialReference);r.zmin-=l,r.zmax+=l}return r}export{R as E,ii as W,Ze as Y};
