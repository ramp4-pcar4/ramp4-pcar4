import{l as m}from"./CollectionFlattener-N3CrRpZy.js";import{_ as l,X as u,Y as p,O as f,i as d,fa as c,at as b,C as g}from"./main-pOgmbpmS.js";function v(o){return new m({getCollections:()=>[o.tables,o.layers],getChildrenFunction:n=>{const a=[];return"tables"in n&&a.push(n.tables),"layers"in n&&a.push(n.layers),a},itemFilterFunction:n=>{const a=n.parent;return!!a&&"tables"in a&&a.tables.includes(n)}})}function L(o){for(const n of o.values())n?.destroy();o.clear()}function y(o,n,a){let e,t;if(o)for(let r=0,i=o.length;r<i;r++){if(e=o.at(r),e?.[n]===a)return e;if(e?.type==="group"&&(t=y(e.layers,n,a),t))return t}}const x=o=>{const n=o;let a=class extends n{constructor(...e){super(...e),this.layers=new f;const t=s=>{s.parent&&s.removeFromParent()},r=s=>{s.parent=this,this.layerAdded(s),s.type!=="elevation"&&s.type!=="base-elevation"||d.getLogger(this).error(`Layer 'title:${s.title}, id:${s.id}' of type '${s.type}' is not supported as an operational layer and will therefore be ignored.`)},i=s=>{s.parent=null,this.layerRemoved(s)};this.addHandles([this.layers.on("before-add",s=>{if(s.item===this)return s.preventDefault(),void d.getLogger(this).error("#add()","Cannot add layer to itself.");t(s.item)}),this.layers.on("after-add",s=>r(s.item)),this.layers.on("after-remove",s=>i(s.item))])}destroy(){const e=this.layers.toArray();for(const t of e)t.destroy();this.layers.destroy()}removeChildLayer(e){this.layers.remove(e),super.removeChildLayer?.(e)}set layers(e){this._set("layers",c(e,this._get("layers")))}add(e,t){const r=this.layers;if(t=r.getNextIndex(t),e instanceof b){const i=e;i.parent===this?this.reorder(i,t):r.add(i,t)}else g(e)?e.then(i=>{this.destroyed||this.add(i,t)}):d.getLogger(this).error("#add()","The item being added is not a Layer or a Promise that resolves to a Layer.")}addMany(e,t){const r=this.layers;let i=r.getNextIndex(t);e.slice().forEach(s=>{s.parent!==this?(r.add(s,i),i+=1):this.reorder(s,i)})}findLayerById(e){return y(this.layers,"id",e)}findLayerByUid(e){return y(this.layers,"uid",e)}remove(e){return this.layers.remove(e)}removeMany(e){return this.layers.removeMany(e)}removeAll(){return this.layers.removeAll()}reorder(e,t){return this.layers.reorder(e,t)}layerAdded(e){}layerRemoved(e){}};return l([u()],a.prototype,"layers",null),a=l([p("esri.support.LayersMixin")],a),a},C=new Set(["feature","subtype-group"]);function h(o,n,a){if(o)for(let e=0,t=o.length;e<t;e++){const r=o.at(e);if(r[n]===a)return r;if(r?.type==="group"){const i=h(r.tables,n,a);if(i)return i}}}const w=o=>{const n=o;let a=class extends n{constructor(...e){super(...e),this.tables=new f,this.addHandles([this.tables.on("after-add",t=>{const r=t.item;r.parent&&r.parent!==this&&r.removeFromParent(),r.parent=this,C.has(r.type)||d.getLogger(this).error(`Layer 'title:${r.title}, id:${r.id}' of type '${r.type}' is not supported as a table and will therefore be ignored.`)}),this.tables.on("after-remove",t=>{t.item.parent=null})])}destroy(){const e=this.tables.toArray();for(const t of e)t.destroy();this.tables.destroy()}removeChildLayer(e){this.tables.remove(e),super.removeChildLayer?.(e)}set tables(e){this._set("tables",c(e,this._get("tables")))}findTableById(e){return h(this.tables,"id",e)}findTableByUid(e){return h(this.tables,"uid",e)}};return l([u()],a.prototype,"tables",null),a=l([p("esri.support.TablesMixin")],a),a};export{x as a,L as b,w as n,v as t};
