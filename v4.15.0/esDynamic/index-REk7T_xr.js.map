{"version":3,"file":"index-REk7T_xr.js","sources":["../../node_modules/but-unzip/index.browser.min.mjs","../../node_modules/shpjs/lib/unzip.js","../../node_modules/shpjs/lib/combine.js","../../node_modules/shpjs/lib/binaryajax.js","../../node_modules/shpjs/lib/parseShp.js","../../node_modules/parsedbf/decoder.js","../../node_modules/parsedbf/index.js","../../node_modules/shpjs/lib/index.js"],"sourcesContent":["var d,g=()=>new DecompressionStream(\"deflate-raw\");try{g(),d=async t=>{let s=g(),e=s.writable.getWriter(),f=s.readable.getReader(),a,i=[],r=0,l=0,o;for(e.write(t),e.close();!(o=await f.read()).done;)a=o.value,i.push(a),r+=a.length;return!i[1]&&a||(a=new Uint8Array(r),i.map(n=>(a.set(n,l),l+=n.length))),a}}catch{}var U=new TextDecoder,u=t=>{throw new Error(\"but-unzip~\"+t)},h=t=>U.decode(t),z=(...t)=>[...m(...t)];function*m(t,s=d){let e=t.length-20,f=Math.max(e-65516,2);for(;(e=t.lastIndexOf(80,e-1))!==-1&&!(t[e+1]===75&&t[e+2]===5&&t[e+3]===6)&&e>f;);e===-1&&u(2);let a=(n,w)=>t.subarray(e+=n,e+=w),i=new DataView(t.buffer,t.byteOffset),r=n=>i.getUint16(n+e,!0),l=n=>i.getUint32(n+e,!0),o=r(10);for(o!==r(8)&&u(3),e=l(16);o--;){let n=r(10),w=r(30),b=r(32),p=l(20),y=l(42),x=h(a(46,r(28))),D=h(a(w,b)),v=e,c;e=y,c=a(30+r(26)+r(28),p),yield{filename:x,comment:D,read:()=>n&8?s(c):n?u(1):c},e=v}}export{d as inflateRaw,m as iter,z as unzip};\n","import { iter } from 'but-unzip';\n\nconst regex = /.+\\.(shp|dbf|json|prj|cpg)$/i;\nexport default async (buffer) => {\n  const files = {};\n  const proms = [];\n  for (const entry of iter(buffer)) {\n    if (!regex.test(entry.filename)) {\n      continue;\n    }\n    proms.push(Promise.resolve(entry.read()).then(bytes => files[entry.filename] = bytes));\n  }\n  await Promise.all(proms);\n  const out = {};\n  const decoder = new TextDecoder();\n  for (const [key, value] of Object.entries(files)) {\n    if (key.slice(-3).toLowerCase() === 'shp' || key.slice(-3).toLowerCase() === 'dbf') {\n      out[key] = new DataView(value.buffer, value.byteOffset, value.byteLength)\n    } else {\n      out[key] = decoder.decode(value);\n    }\n  }\n  return out;\n};\n","const URL = globalThis.URL;\n\nexport default (base, type) => {\n  if (!type) {\n    return base;\n  }\n  const url = new URL(base);\n  url.pathname = `${url.pathname}.${type}`;\n  return url.href;\n};\n","import combine from './combine.js';\n\nexport default async function binaryAjax(_url, type) {\n\n  const url = combine(_url, type);\n  const isOptionalTxt = type === 'prj' || type === 'cpg';\n  try {\n    const resp = await fetch(url);\n    if (resp.status > 399) {\n      throw new Error(resp.statusText);\n    }\n    if (isOptionalTxt) {\n      return resp.text();\n    }\n    const parsed = await resp.arrayBuffer();\n    return new DataView(parsed)\n  } catch (e) {\n    if (isOptionalTxt || type === 'dbf') {\n      return false;\n    }\n    throw e;\n  }\n};\n","\n\nfunction isClockWise(array) {\n  let sum = 0;\n  let i = 1;\n  const len = array.length;\n  let prev, cur;\n  const bbox = [array[0][0], array[0][1], array[0][0], array[0][1]];\n  while (i < len) {\n    prev = cur || array[0];\n    cur = array[i];\n    sum += ((cur[0] - prev[0]) * (cur[1] + prev[1]));\n    i++;\n    if (cur[0] < bbox[0]) {\n      bbox[0] = cur[0];\n    }\n    if (cur[1] < bbox[1]) {\n      bbox[1] = cur[1];\n    }\n    if (cur[0] > bbox[2]) {\n      bbox[2] = cur[0];\n    }\n    if (cur[1] > bbox[3]) {\n      bbox[3] = cur[1];\n    }\n  }\n  return {\n    ring: array,\n    clockWise: sum > 0,\n    bbox,\n    children: []\n  }\n\n}\n\nfunction contains(outer, inner) {\n  if (outer.bbox[0] > inner.bbox[0]) {\n    return false;\n  }\n  if (outer.bbox[1] > inner.bbox[1]) {\n    return false;\n  }\n  if (outer.bbox[2] < inner.bbox[2]) {\n    return false;\n  }\n  if (outer.bbox[3] < inner.bbox[3]) {\n    return false;\n  }\n  return true;\n}\n\n\nfunction handleRings(rings, reversed = false) {\n  const outers = [];\n  const inners = [];\n  for (const ring of rings) {\n    const proccessed = isClockWise(ring);\n    if (proccessed.clockWise !== reversed) {\n      outers.push(proccessed)\n    } else {\n      inners.push(proccessed)\n    }\n  }\n  const orphens = [];\n  for (const inner of inners) {\n    let candidate;\n    for (const outer of outers) {\n      if (contains(outer, inner)) {\n        if (!candidate) {\n          candidate = outer;\n        } else {\n          if (contains(candidate, outer)) {\n            candidate = outer;\n          }\n        }\n\n      }\n    }\n    if (candidate) {\n      candidate.children.push(inner.ring);\n    } else {\n      orphens.push(inner);\n    }\n  }\n  if (reversed) {\n    return {\n      outers, orphens\n    }\n  }\n  if (orphens.length && !reversed) {\n    const otherPosibility = handleRings(rings, true);\n    if (otherPosibility.orphens.length === 0) {\n      const out = [];\n      for (const outer of otherPosibility.outers) {\n        out.push([outer.ring.toReversed()].concat(outer.children.map(item => item.toReversed())));\n      }\n      return out;\n    }\n  }\n  const out = [];\n  for (const outer of outers) {\n    out.push([outer.ring].concat(outer.children));\n  }\n  return out;\n}\nParseShp.prototype.parsePoint = function (data) {\n  return {\n    type: 'Point',\n    coordinates: this.parseCoord(data, 0)\n  };\n};\nParseShp.prototype.parseZPoint = function (data) {\n  const pointXY = this.parsePoint(data);\n  pointXY.coordinates.push(data.getFloat64(16, true));\n  return pointXY;\n};\nParseShp.prototype.parsePointArray = function (data, offset, num) {\n  const out = [];\n  let done = 0;\n  while (done < num) {\n    out.push(this.parseCoord(data, offset));\n    offset += 16;\n    done++;\n  }\n  return out;\n};\nParseShp.prototype.parseZPointArray = function (data, zOffset, num, coordinates) {\n  let i = 0;\n  while (i < num) {\n    coordinates[i].push(data.getFloat64(zOffset, true));\n    i++;\n    zOffset += 8;\n  }\n  return coordinates;\n};\nParseShp.prototype.parseArrayGroup = function (data, offset, partOffset, num, tot) {\n  const out = [];\n  let done = 0;\n  let curNum; let nextNum = 0;\n  let pointNumber;\n  while (done < num) {\n    done++;\n    partOffset += 4;\n    curNum = nextNum;\n    if (done === num) {\n      nextNum = tot;\n    } else {\n      nextNum = data.getInt32(partOffset, true);\n    }\n    pointNumber = nextNum - curNum;\n    if (!pointNumber) {\n      continue;\n    }\n    out.push(this.parsePointArray(data, offset, pointNumber));\n    offset += (pointNumber << 4);\n  }\n  return out;\n};\nParseShp.prototype.parseZArrayGroup = function (data, zOffset, num, coordinates) {\n  let i = 0;\n  while (i < num) {\n    coordinates[i] = this.parseZPointArray(data, zOffset, coordinates[i].length, coordinates[i]);\n    zOffset += (coordinates[i].length << 3);\n    i++;\n  }\n  return coordinates;\n};\nParseShp.prototype.parseMultiPoint = function (data) {\n  const out = {};\n  const num = data.getInt32(32, true);\n  if (!num) {\n    return null;\n  }\n  const mins = this.parseCoord(data, 0);\n  const maxs = this.parseCoord(data, 16);\n  out.bbox = [\n    mins[0],\n    mins[1],\n    maxs[0],\n    maxs[1]\n  ];\n  const offset = 36;\n  if (num === 1) {\n    out.type = 'Point';\n    out.coordinates = this.parseCoord(data, offset);\n  } else {\n    out.type = 'MultiPoint';\n    out.coordinates = this.parsePointArray(data, offset, num);\n  }\n  return out;\n};\nParseShp.prototype.parseZMultiPoint = function (data) {\n  const geoJson = this.parseMultiPoint(data);\n  if (!geoJson) {\n    return null;\n  }\n  let num;\n  if (geoJson.type === 'Point') {\n    geoJson.coordinates.push(data.getFloat64(72, true));\n    return geoJson;\n  } else {\n    num = geoJson.coordinates.length;\n  }\n  const zOffset = 52 + (num << 4);\n  geoJson.coordinates = this.parseZPointArray(data, zOffset, num, geoJson.coordinates);\n  return geoJson;\n};\nParseShp.prototype.parsePolyline = function (data) {\n  const out = {};\n  const numParts = data.getInt32(32, true);\n  if (!numParts) {\n    return null;\n  }\n  const mins = this.parseCoord(data, 0);\n  const maxs = this.parseCoord(data, 16);\n  out.bbox = [\n    mins[0],\n    mins[1],\n    maxs[0],\n    maxs[1]\n  ];\n  const num = data.getInt32(36, true);\n  let offset, partOffset;\n  if (numParts === 1) {\n    out.type = 'LineString';\n    offset = 44;\n    out.coordinates = this.parsePointArray(data, offset, num);\n  } else {\n    out.type = 'MultiLineString';\n    offset = 40 + (numParts << 2);\n    partOffset = 40;\n    out.coordinates = this.parseArrayGroup(data, offset, partOffset, numParts, num);\n  }\n  return out;\n};\nParseShp.prototype.parseZPolyline = function (data) {\n  const geoJson = this.parsePolyline(data);\n  if (!geoJson) {\n    return null;\n  }\n  const num = geoJson.coordinates.length;\n  let zOffset;\n  if (geoJson.type === 'LineString') {\n    zOffset = 60 + (num << 4);\n    geoJson.coordinates = this.parseZPointArray(data, zOffset, num, geoJson.coordinates);\n    return geoJson;\n  } else {\n    const totalPoints = geoJson.coordinates.reduce(function (a, v) {\n      return a + v.length;\n    }, 0);\n    zOffset = 56 + (totalPoints << 4) + (num << 2);\n    geoJson.coordinates = this.parseZArrayGroup(data, zOffset, num, geoJson.coordinates);\n    return geoJson;\n  }\n};\nParseShp.prototype.polyFuncs = function (out) {\n  if (!out) {\n    return out;\n  }\n  if (out.type === 'LineString') {\n    out.type = 'Polygon';\n    out.coordinates = [out.coordinates];\n    return out;\n  } else {\n    out.coordinates = handleRings(out.coordinates)\n    if (out.coordinates.length === 1) {\n      out.type = 'Polygon';\n      out.coordinates = out.coordinates[0];\n      return out;\n    } else {\n      out.type = 'MultiPolygon';\n      return out;\n    }\n  }\n};\nParseShp.prototype.parsePolygon = function (data) {\n  return this.polyFuncs(this.parsePolyline(data));\n};\nParseShp.prototype.parseZPolygon = function (data) {\n  return this.polyFuncs(this.parseZPolyline(data));\n};\nconst shpFuncObj = {\n  1: 'parsePoint',\n  3: 'parsePolyline',\n  5: 'parsePolygon',\n  8: 'parseMultiPoint',\n  11: 'parseZPoint',\n  13: 'parseZPolyline',\n  15: 'parseZPolygon',\n  18: 'parseZMultiPoint'\n};\n\nfunction makeParseCoord(trans) {\n  if (trans) {\n    return function (data, offset) {\n      const args = [data.getFloat64(offset, true), data.getFloat64(offset + 8, true)];\n      return trans.inverse(args);\n    };\n  } else {\n    return function (data, offset) {\n      return [data.getFloat64(offset, true), data.getFloat64(offset + 8, true)];\n    };\n  }\n}\n\nexport function ParseShp(buffer, trans) {\n  if (!(this instanceof ParseShp)) {\n    return new ParseShp(buffer, trans);\n  }\n  this.buffer = buffer;\n  this.headers = this.parseHeader();\n  this.shpFuncs(trans);\n  this.rows = this.getRows();\n}\nParseShp.prototype.shpFuncs = function (tran) {\n  let num = this.headers.shpCode;\n  if (num > 20) {\n    num -= 20;\n  }\n  if (!(num in shpFuncObj)) {\n    throw new Error(`I don't know shp type \"${num}\"`);\n  }\n  this.parseFunc = this[shpFuncObj[num]];\n  this.parseCoord = makeParseCoord(tran);\n};\nParseShp.prototype.getShpCode = function () {\n  return this.parseHeader().shpCode;\n};\nParseShp.prototype.parseHeader = function () {\n  const view = this.buffer;\n  return {\n    length: view.getInt32(6 << 2) << 1,\n    version: view.getInt32(7 << 2, true),\n    shpCode: view.getInt32(8 << 2, true),\n    bbox: [\n      view.getFloat64(9 << 2, true),\n      view.getFloat64(11 << 2, true),\n      view.getFloat64(13 << 2, true),\n      view.getFloat64(15 << 2, true)\n    ]\n  };\n};\nParseShp.prototype.getRows = function () {\n  let offset = 100;\n  const len = this.buffer.byteLength - 8;\n  const out = [];\n  let current;\n  while (offset <= len) {\n    current = this.getRow(offset);\n    if (!current) {\n      break;\n    }\n    offset += 8;\n    offset += current.len;\n    if (current.type) {\n      out.push(this.parseFunc(current.data));\n    } else {\n      out.push(null);\n    }\n  }\n  return out;\n};\nParseShp.prototype.getRow = function (offset) {\n  const id = this.buffer.getInt32(offset);\n  const len = this.buffer.getInt32(offset + 4) << 1;\n  if (len === 0) {\n    return {\n      id: id,\n      len: len,\n      type: 0\n    };\n  }\n\n  if (offset + len + 8 > this.buffer.byteLength) {\n    return;\n  }\n  return {\n    id: id,\n    len: len,\n    data: new DataView(this.buffer.buffer, this.buffer.byteOffset + offset + 12, len - 4),\n    type: this.buffer.getInt32(offset + 8, true)\n  };\n};\nexport default function (buffer, trans) {\n  return new ParseShp(buffer, trans).rows;\n};\n","var regex = /^(?:ANSI\\s)?(\\d+)$/m;\nexport function createDecoder(encoding, second) {\n  if (!encoding) {\n    return browserDecoder;\n  }\n  try {\n    new TextDecoder(encoding.trim());\n  } catch (e) {\n    var match = regex.exec(encoding);\n    if (match && !second) {\n      return createDecoder('windows-' + match[1], true);\n    } else {\n      encoding = undefined;\n      return browserDecoder;\n    }\n  }\n  return browserDecoder;\n  function browserDecoder(buffer) {\n    var decoder = new TextDecoder(encoding ? encoding : undefined);\n    var out = decoder.decode(buffer, {\n      stream: true\n    }) + decoder.decode();\n    return out.replace(/\\0/g, '').trim();\n  }\n}\n","import { createDecoder } from './decoder.js';\nfunction dbfHeader(data) {\n  var out = {};\n  out.lastUpdated = new Date(data.getUint8(1) + 1900, data.getUint8(2), data.getUint8(3));\n  out.records = data.getUint32(4, true);\n  out.headerLen = data.getUint16(8, true);\n  out.recLen = data.getUint16(10, true);\n  return out;\n}\n\nfunction dbfRowHeader(data, headerLen, decoder) {\n  var out = [];\n  var offset = 32;\n  while (offset < headerLen) {\n    out.push({\n      name: decoder(new Uint8Array(data.buffer.slice(data.byteOffset + offset, data.byteOffset + offset + 11))),\n      dataType: String.fromCharCode(data.getUint8(offset + 11)),\n      len: data.getUint8(offset + 16),\n      decimal: data.getUint8(offset + 17)\n    });\n    if (data.getUint8(offset + 32) === 13) {\n      break;\n    } else {\n      offset += 32;\n    }\n  }\n  return out;\n}\n\nfunction rowFuncs(buffer, offset, len, type, decoder) {\n  const data = new Uint8Array(buffer.buffer.slice(buffer.byteOffset + offset, buffer.byteOffset + offset + len));\n\n  var textData = decoder(data);\n  switch (type) {\n    case 'N':\n    case 'F':\n    case 'O':\n      return parseFloat(textData, 10);\n    case 'D':\n      return new Date(textData.slice(0, 4), parseInt(textData.slice(4, 6), 10) - 1, textData.slice(6, 8));\n    case 'L':\n      return textData.toLowerCase() === 'y' || textData.toLowerCase() === 't';\n    default:\n      return textData;\n  }\n}\n\nfunction parseRow(buffer, offset, rowHeaders, decoder) {\n  var out = {};\n  var i = 0;\n  var len = rowHeaders.length;\n  var field;\n  var header;\n  while (i < len) {\n    header = rowHeaders[i];\n    field = rowFuncs(buffer, offset, header.len, header.dataType, decoder);\n    offset += header.len;\n    if (typeof field !== 'undefined') {\n      out[header.name] = field;\n    }\n    i++;\n  }\n  return out;\n}\n\nexport default function (buffer, encoding) {\n  var decoder = createDecoder(encoding);\n  var header = dbfHeader(buffer);\n  var rowHeaders = dbfRowHeader(buffer, header.headerLen - 1, decoder);\n\n  var offset = ((rowHeaders.length + 1) << 5) + 2;\n  var recLen = header.recLen;\n  var records = header.records;\n  var out = [];\n  while (records) {\n    out.push(parseRow(buffer, offset, rowHeaders, decoder));\n    offset += recLen;\n    records--;\n  }\n  return out;\n}\n","import proj4 from 'proj4'\nimport unzip from './unzip.js';\nimport binaryAjax from './binaryajax.js';\nimport parseShp from './parseShp.js';\nimport parseDbf from 'parsedbf';\nconst URL = globalThis.URL;\nconst toUitn8Arr = b => {\n  if (!b) {\n    throw new Error('forgot to pass buffer');\n  }\n  if (isArrayBuffer(b)) {\n    return new Uint8Array(b);\n  }\n  if (isArrayBuffer(b.buffer)) {\n    if (b.BYTES_PER_ELEMENT === 1) {\n      return b;\n    }\n    return new Uint8Array(b.buffer, b.byteOffset, b.byteLength);\n  }\n  throw new Error('invalid buffer like object')\n};\nconst txtDecoder = new TextDecoder();\nconst toString = (possibleString) => {\n  if (!possibleString) {\n    return;\n  }\n  if (typeof possibleString === 'string') {\n    return possibleString;\n  }\n  if (isArrayBuffer(possibleString) || ArrayBuffer.isView(possibleString) || isDataView(possibleString)) {\n    return txtDecoder.decode(possibleString);\n  }\n}\nconst toDataView = b => {\n  if (!b) {\n    throw new Error('forgot to pass buffer');\n  }\n  if (isDataView(b)) {\n    return b;\n  }\n  if (isArrayBuffer(b)) {\n    return new DataView(b);\n  }\n  if (isArrayBuffer(b.buffer)) {\n    return new DataView(b.buffer, b.byteOffset, b.byteLength);\n  }\n  throw new Error('invalid buffer like object')\n};\n\nfunction isArrayBuffer(subject) {\n  return subject instanceof globalThis.ArrayBuffer || Object.prototype.toString.call(subject) === '[object ArrayBuffer]';\n}\nfunction isDataView(subject) {\n  return subject instanceof globalThis.DataView || Object.prototype.toString.call(subject) === '[object DataView]'\n}\n\nexport const combine = function ([shp, dbf]) {\n  const out = {};\n  out.type = 'FeatureCollection';\n  out.features = [];\n  let i = 0;\n  const len = shp.length;\n  if (!dbf) {\n    dbf = [];\n  }\n  while (i < len) {\n    out.features.push({\n      type: 'Feature',\n      geometry: shp[i],\n      properties: dbf[i] || {}\n    });\n    i++;\n  }\n  return out;\n};\nexport const parseZip = async function (buffer, whiteList) {\n  let key;\n  buffer = toUitn8Arr(buffer);\n  const zip = await unzip(buffer);\n  const names = [];\n  whiteList = whiteList || [];\n  for (key in zip) {\n    if (key.indexOf('__MACOSX') !== -1) {\n      continue;\n    }\n    if (key.slice(-4).toLowerCase() === '.shp') {\n      names.push(key.slice(0, -4));\n      zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = zip[key];\n    } else if (key.slice(-4).toLowerCase() === '.prj') {\n      zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = proj4(zip[key]);\n    } else if (key.slice(-5).toLowerCase() === '.json' || whiteList.indexOf(key.split('.').pop()) > -1) {\n      names.push(key.slice(0, -3) + key.slice(-3).toLowerCase());\n    } else if (key.slice(-4).toLowerCase() === '.dbf' || key.slice(-4).toLowerCase() === '.cpg') {\n      zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = zip[key];\n    }\n  }\n  if (!names.length) {\n    throw new Error('no layers founds');\n  }\n  const geojson = names.map(function (name) {\n    let parsed, dbf;\n    const lastDotIdx = name.lastIndexOf('.');\n    if (lastDotIdx > -1 && name.slice(lastDotIdx).indexOf('json') > -1) {\n      parsed = JSON.parse(zip[name]);\n      parsed.fileName = name.slice(0, lastDotIdx);\n    } else if (whiteList.indexOf(name.slice(lastDotIdx + 1)) > -1) {\n      parsed = zip[name];\n      parsed.fileName = name;\n    } else {\n      if (zip[name + '.dbf']) {\n        dbf = parseDbf(zip[name + '.dbf'], zip[name + '.cpg']);\n      }\n      parsed = combine([parseShp(zip[name + '.shp'], zip[name + '.prj']), dbf]);\n      parsed.fileName = name;\n    }\n    return parsed;\n  });\n  if (geojson.length === 1) {\n    return geojson[0];\n  } else {\n    return geojson;\n  }\n};\nasync function getZip(base, whiteList) {\n  const a = await binaryAjax(base);\n  return parseZip(a, whiteList);\n}\nconst handleShp = async (base) => {\n  const args = await Promise.all([\n    binaryAjax(base, 'shp'),\n    binaryAjax(base, 'prj')\n  ]);\n  let prj = false;\n  try {\n    if (args[1]) {\n      prj = proj4(args[1]);\n    }\n  } catch (e) {\n    prj = false;\n  }\n  return parseShp(args[0], prj);\n};\nconst handleDbf = async (base) => {\n  const [dbf, cpg] = await Promise.all([\n    binaryAjax(base, 'dbf'),\n    binaryAjax(base, 'cpg')\n  ]);\n  if (!dbf) {\n    return;\n  }\n  return parseDbf(dbf, cpg);\n};\nconst checkSuffix = (base, suffix) => {\n  const url = new URL(base, globalThis?.document?.location);\n  return url.pathname.slice(-4).toLowerCase() === suffix;\n};\nconst fromObject = ({ shp, dbf, cpg, prj }) => {\n  const things = [\n    _parseShp(shp, prj)\n  ]\n  if (dbf) {\n    things.push(_parseDbf(dbf, cpg));\n  }\n  return combine(things);\n}\nexport const getShapefile = async function (base, whiteList) {\n  if (typeof base !== 'string') {\n    if (isArrayBuffer(base) || ArrayBuffer.isView(base) || isDataView(base)) {\n      return parseZip(base);\n    }\n    if (base.shp) {\n      return fromObject(base);\n    }\n    throw new TypeError('must be a string, some sort of Buffer, or an object with at least a .shp property')\n  }\n  if (checkSuffix(base, '.zip')) {\n    return getZip(base, whiteList);\n  }\n  if (checkSuffix(base, '.shp')) {\n    base = base.slice(0, -4);\n  }\n  const results = await Promise.all([\n    handleShp(base),\n    handleDbf(base)\n  ]);\n  return combine(results);\n};\nconst _parseShp = function (shp, prj) {\n  shp = toDataView(shp);\n  prj = toString(prj);\n  if (typeof prj === 'string') {\n    try {\n      prj = proj4(prj);\n    } catch (e) {\n      prj = false;\n    }\n  }\n  return parseShp(shp, prj);\n};\nconst _parseDbf = function (dbf, cpg) {\n  dbf = toDataView(dbf);\n  cpg = toString(cpg);\n  return parseDbf(dbf, cpg);\n};\nexport default getShapefile;\nexport {\n  _parseDbf as parseDbf,\n  _parseShp as parseShp,\n}"],"names":["d","g","t","s","e","f","a","r","l","o","n","U","u","h","m","w","b","p","y","x","D","v","c","regex","unzip","buffer","files","proms","entry","iter","bytes","out","decoder","key","value","URL","combine$1","base","type","url","binaryAjax","_url","combine","isOptionalTxt","resp","parsed","isClockWise","array","sum","i","len","prev","cur","bbox","contains","outer","inner","handleRings","rings","reversed","outers","inners","ring","proccessed","orphens","candidate","otherPosibility","item","ParseShp","data","pointXY","offset","num","done","zOffset","coordinates","partOffset","tot","curNum","nextNum","pointNumber","mins","maxs","geoJson","numParts","shpFuncObj","makeParseCoord","trans","args","tran","view","current","id","parseShp","createDecoder","encoding","second","browserDecoder","match","dbfHeader","dbfRowHeader","headerLen","rowFuncs","textData","parseRow","rowHeaders","field","header","parseDbf","recLen","records","toUitn8Arr","isArrayBuffer","txtDecoder","toString","possibleString","isDataView","toDataView","subject","shp","dbf","parseZip","whiteList","zip","names","proj4","geojson","name","lastDotIdx","getZip","handleShp","prj","handleDbf","cpg","checkSuffix","suffix","fromObject","things","_parseShp","_parseDbf","getShapefile","results"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}