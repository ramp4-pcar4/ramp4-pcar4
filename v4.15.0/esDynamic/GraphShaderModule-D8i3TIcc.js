import{_ as x,eB as se,t as oe,s as ae,i as Bt}from"./main-pOgmbpmS.js";import"./BufferObject-8WrVGiNx.js";import"./FramebufferObject-CVFiq-un.js";import{s as ce}from"./ProgramTemplate-A0nrytMh.js";import{h as ue,A as he}from"./Texture-DxZPAhdk.js";import{s as de}from"./ShaderBuilder-B9Qsz-VF.js";let pe=class{constructor(){this.drawPhase=89}startup(){}shutdown(t){}};function le(t){return t.split(" ").map((e,r)=>r>0?e.charAt(0).toUpperCase()+e.slice(1):e).join("")}function fe(t,e){const r=[];for(r.push(e);r.length;){const n=r.pop();if(typeof n=="object"&&!t.has(n.uid)){t.add(n.uid);for(const i of n.children)r.push(i)}}}class F{constructor(){this.uid=F.NodeCount++,this._debugName=null,this._isMutable=!1,this.isImplicit=!1}static{this.NodeCount=0}get isMutable(){return this._isMutable}setMutable(){return this._isMutable=!0,this}setDebugName(e){return e=le(e),this._debugName=e,this.isImplicit&&this.children[0]instanceof F&&this.children[0].setDebugName(e),this}get debugInfo(){return{name:this._debugName??""}}cloneInto(e){e._debugName=this._debugName,e._isMutable=this._isMutable,e.isImplicit=this.isImplicit,e.uid=this.uid}}function o(t){return typeof t=="object"?t.clone():t}let w=class extends F{constructor(){super(...arguments),this.shaderType="primitive-node"}},ye=class te extends F{constructor(e){super(),this.child=e,this.shaderType="scope-node"}get children(){return[this.child]}clone(){const e=new te(o(this.child));return this.cloneInto(e),e}};class Kt extends F{constructor(e,r,n){super(),this.property=e,this.target=r,this.returnType=n,this.shaderType="property-access-node"}get children(){const e=[this.target];return typeof this.property!="string"&&e.push(this.property),e}clone(){const e=new Kt(this.property,o(this.target),this.returnType);return this.cloneInto(e),e}}let me=class ee extends F{constructor(e,r,n,i){super(),this.x=e,this.y=r,this.target=n,this.returnType=i,this.shaderType="property-access-2d-node"}get children(){return[this.target,this.x,this.y]}clone(){const e=new ee(this.x,this.y,o(this.target),this.returnType);return this.cloneInto(e),e}};class Dt extends F{constructor(e,r,n){super(),this.condition=e,this.ifTrue=r,this.ifFalse=n,this.shaderType="condition-node"}get children(){return[this.condition,this.ifTrue,this.ifFalse]}clone(){const e=o(this.ifTrue),r=this.ifFalse?o(this.ifFalse):null,n=new Dt(this.condition,e,r);return this.cloneInto(n),n}}let ge=class re extends F{constructor(e,r,n,i){super(),this.captureList=e,this.returnType=r,this.generator=i,this.shaderType="block-node",n&&(this.subgraph=new ye(n))}get children(){return Object.keys(this.captureList).map(e=>this.captureList[e]).concat(this.subgraph??[])}clone(){const e={};for(const n in this.captureList)e[n]=o(this.captureList[n]);const r=new re(e,this.returnType,this.subgraph?o(this.subgraph.child):this.subgraph,this.generator);return this.cloneInto(r),r}},B=class ne extends F{constructor(e,r,n,i,s,u=!1){super(),this.token=e,this._children=r,this.isInfix=n,this.isPropertyAccess=i,this.returnType=s,this.isTernary=u,this.shaderType="function-node"}get children(){return this._children}clone(){const e=new ne(this.token,this._children.map(o),this.isInfix,this.isPropertyAccess,this.returnType,this.isTernary);return this.cloneInto(e),e}};var J,ht,dt,pt,A,lt,ft,yt,mt,gt,bt,wt,vt,xt;function be(t){switch(t.type){case"bool":case"bvec2":case"bvec3":case"bvec4":return N;case"float":case"vec2":case"vec3":case"vec4":return y;case"int":case"ivec2":case"ivec3":case"ivec4":return h;case"uint":case"uvec2":case"uvec3":case"uvec4":return b;default:throw new Error("Unable to handle type")}}function we(t){const e=[["float","vec2","vec3","vec4"],["int","ivec2","ivec3","ivec4"],["uint","uvec2","uvec3","uvec4"],["bool","bvec2","bvec3","bvec4"]];for(const r of e)if(r.includes(t))return r.map(n=>_e[n]);throw new Error("Unable to find type family")}function At(t){return new Proxy(t,{get(e,r){if(r==="constructor")return new Proxy(e.constructor,{construct:(n,i,s)=>At(new n(...i))});if(r in e)return e[r];if(typeof r=="string"){const n=we(t.type);return m(t,r,n[r.length-1])}}})}function T(t){return new Proxy(t,{construct:(e,r,n)=>At(new e(...r))})}function ve(t){return new Proxy(t,{get(e,r){if(r in e)return e[r];if(typeof r=="string"){const n=parseInt(r,10);if(!isNaN(n))return m(t,`[${n}]`,t.elementType.constructor)}}})}function xe(t){return new Proxy(t,{construct:(e,r,n)=>ve(new e(...r))})}class D extends Error{}let rt=class extends w{static{J=this}static{this.type="array"}constructor(t,e){super(),this.elementType=t,this.size=e,this.children=[],this.type="array"}clone(){const t=new J(this.elementType,this.size);return super.cloneInto(t),t}get(t,e){const r=new h(t),n=e!=null?new h(e):null;return n!=null?it(this,r,n,be(this.elementType.constructor)):m(this,r,this.elementType.constructor)}last(){return this.get(this.size-1)}first(){return this.get(0)}findIndex(t,e,r){return ke(this,t,e,r)}glslFindIndex(t,e,r){return Se(this,t,e,r)}static ofType(t,e){const r={construct:(n,i)=>new J(new t,e)};return new Proxy(J,r)}};rt=J=x([xe],rt);class ut extends w{static{this.type="array-2d"}constructor(e,r,n,i=!1){super(),this.elementType=e,this.xSize=r,this.ySize=n,this.isRowMajor=i,this.children=[],this.type="array-2d"}clone(){const e=new ut(this.elementType,this.xSize,this.ySize,this.isRowMajor);return super.cloneInto(e),e}get size(){return this.xSize*this.ySize}get(e,r){return this.isRowMajor?this._getRowMajor(e,r):this._getColumnMajor(e,r)}_getColumnMajor(e,r){const n=new h(e);return m(this,new h(r).add(n.multiply(this.xSize)),this.elementType.constructor)}_getRowMajor(e,r){const n=new h(e),i=new h(r);return m(this,n.add(i.multiply(this.ySize)),this.elementType.constructor)}static ofType(e,r,n,i=!1){return new Proxy(rt,{construct:(s,u)=>new ut(new e,r,n,i)})}}class Ut extends w{constructor(){super(...arguments),this.type="sampler2D",this.children=[]}static{this.type="sampler2D"}clone(){const e=new Ut;return e.children=this.children.map(o),super.cloneInto(e),e}}let y=class q extends w{static{this.type="float"}constructor(e){super(),this.type="float",this.children=[e]}clone(){const e=new q(o(this.children[0]));return super.cloneInto(e),e}multiply(e){return _(this,typeof e=="number"?d(e,q):e)}divide(e){return k(this,typeof e=="number"?d(e,q):e)}add(e){return M(this,typeof e=="number"?d(e,q):e)}subtract(e){return S(this,typeof e=="number"?d(e,q):e)}},z=class extends w{static{ht=this}static{this.type="vec2"}constructor(t,e){super(),this.type="vec2",this.children=[t,e].filter(r=>r!=null)}clone(){const t=new ht(o(this.children[0]),o(this.children[1]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",y)}get 1(){return m(this,"[1]",y)}get 2(){throw new D}get 3(){throw new D}multiply(t){return _(this,typeof t=="number"?d(t,y):t)}divide(t){return k(this,typeof t=="number"?d(t,y):t)}add(t){return M(this,typeof t=="number"?d(t,y):t)}subtract(t){return S(this,typeof t=="number"?d(t,y):t)}};z=ht=x([T],z);let Q=class extends w{static{dt=this}static{this.type="vec3"}constructor(t,e,r){super(),this.type="vec3",this.children=[t,e,r].filter(n=>n!=null)}get 0(){return m(this,"[0]",y)}get 1(){return m(this,"[1]",y)}get 2(){return m(this,"[2]",y)}get 3(){throw new D}clone(){const t=new dt(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(t),t}multiply(t){return _(this,typeof t=="number"?d(t,y):t)}divide(t){return k(this,typeof t=="number"?d(t,y):t)}add(t){return M(this,typeof t=="number"?d(t,y):t)}subtract(t){return S(this,typeof t=="number"?d(t,y):t)}};Q=dt=x([T],Q);let O=class extends w{static{pt=this}static{this.type="vec4"}constructor(t,e,r,n){super(),this.type="vec4",this.children=[t,e,r,n].filter(i=>i!=null)}clone(){const t=new pt(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",y)}get 1(){return m(this,"[1]",y)}get 2(){return m(this,"[2]",y)}get 3(){return m(this,"[3]",y)}multiply(t){return _(this,typeof t=="number"?d(t,y):t)}divide(t){return k(this,typeof t=="number"?d(t,y):t)}add(t){return M(this,typeof t=="number"?d(t,y):t)}subtract(t){return S(this,typeof t=="number"?d(t,y):t)}};O=pt=x([T],O);let b=class extends w{static{A=this}static{this.type="uint"}constructor(t){super(),this.type="uint",this.children=[t]}clone(){const t=new A(o(this.children[0]));return super.cloneInto(t),t}multiply(t){return _(this,d(t,A))}add(t){return M(this,d(t,A))}subtract(t){return S(this,d(t,A))}divide(t){return k(this,d(t,A))}};b=A=x([T],b);let _t=class extends w{static{lt=this}static{this.type="uvec2"}constructor(t,e){super(),this.type="uvec2",this.children=[t,e].filter(r=>r!=null)}clone(){const t=new lt(o(this.children[0]),o(this.children[1]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",h)}get 1(){return m(this,"[1]",h)}get 2(){throw new D}get 3(){throw new D}multiply(t){return _(this,typeof t=="number"?d(t,b):t)}divide(t){return k(this,typeof t=="number"?d(t,b):t)}add(t){return M(this,typeof t=="number"?d(t,b):t)}subtract(t){return S(this,typeof t=="number"?d(t,b):t)}};_t=lt=x([T],_t);let $t=class extends w{static{ft=this}static{this.type="uvec3"}constructor(t,e,r){super(),this.type="uvec3",this.children=[t,e,r].filter(n=>n!=null)}clone(){const t=new ft(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",b)}get 1(){return m(this,"[1]",b)}get 2(){return m(this,"[2]",b)}get 3(){throw new D}multiply(t){return _(this,typeof t=="number"?d(t,b):t)}divide(t){return k(this,typeof t=="number"?d(t,b):t)}add(t){return M(this,typeof t=="number"?d(t,b):t)}subtract(t){return S(this,typeof t=="number"?d(t,b):t)}};$t=ft=x([T],$t);let It=class extends w{static{yt=this}static{this.type="uvec4"}constructor(t,e,r,n){super(),this.type="uvec4",this.children=[t,e,r,n].filter(i=>i!=null)}clone(){const t=new yt(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",b)}get 1(){return m(this,"[1]",b)}get 2(){return m(this,"[2]",b)}get 3(){return m(this,"[3]",b)}multiply(t){return _(this,typeof t=="number"?d(t,b):t)}divide(t){return k(this,typeof t=="number"?d(t,b):t)}add(t){return M(this,typeof t=="number"?d(t,b):t)}subtract(t){return S(this,typeof t=="number"?d(t,b):t)}};It=yt=x([T],It);class N extends w{static{this.type="bool"}constructor(e){super(),this.type="bool",this.children=[e]}and(e){return Ht(this,e)}or(e){return Rt(this,e)}xor(e){return Gt(this,e)}clone(){const e=new N(o(this.children[0]));return super.cloneInto(e),e}}let Nt=class extends w{static{mt=this}static{this.type="bvec2"}constructor(t,e){super(),this.type="bvec2",this.children=[t,e].filter(r=>r!=null)}all(){return Ct(this)}any(){return Ft(this)}clone(){const t=new mt(o(this.children[0]),o(this.children[1]));return super.cloneInto(t),t}};Nt=mt=x([T],Nt);let Tt=class extends w{static{gt=this}static{this.type="bvec3"}constructor(t,e,r){super(),this.type="bvec3",this.children=[t,e,r].filter(n=>n!=null)}all(){return Ct(this)}any(){return Ft(this)}clone(){const t=new gt(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(t),t}};function d(t,e){return typeof t=="number"?new e(t):t}Tt=gt=x([T],Tt);let Mt=class extends w{static{bt=this}static{this.type="bvec4"}constructor(t,e,r,n){super(),this.type="bvec4",this.children=[t,e,r,n].filter(i=>i!=null)}all(){return Ct(this)}any(){return Ft(this)}clone(){const t=new bt(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(t),t}};Mt=bt=x([T],Mt);class h extends w{static{this.type="int"}constructor(e){super(),this.type="int",this.children=[e]}multiply(e){return _(this,d(e,h))}add(e){return M(this,d(e,h))}subtract(e){return S(this,d(e,h))}divide(e){return k(this,d(e,h))}clone(){const e=new h(o(this.children[0]));return super.cloneInto(e),e}}let nt=class extends w{static{wt=this}static{this.type="ivec2"}constructor(t,e){super(),this.type="ivec2",this.children=[t,e].filter(r=>r!=null)}clone(){const t=new wt(o(this.children[0]),o(this.children[1]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",h)}get 1(){return m(this,"[1]",h)}get 2(){throw new D}get 3(){throw new D}multiply(t){return _(this,typeof t=="number"?d(t,h):t)}divide(t){return k(this,typeof t=="number"?d(t,h):t)}add(t){return M(this,typeof t=="number"?d(t,h):t)}subtract(t){return S(this,typeof t=="number"?d(t,h):t)}};nt=wt=x([T],nt);let kt=class extends w{static{vt=this}static{this.type="ivec3"}constructor(t,e,r){super(),this.type="ivec3",this.children=[t,e,r].filter(n=>n!=null)}clone(){const t=new vt(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",h)}get 1(){return m(this,"[1]",h)}get 2(){return m(this,"[2]",h)}get 3(){throw new D}multiply(t){return _(this,typeof t=="number"?d(t,h):t)}divide(t){return k(this,typeof t=="number"?d(t,h):t)}add(t){return M(this,typeof t=="number"?d(t,h):t)}subtract(t){return S(this,typeof t=="number"?d(t,h):t)}};kt=vt=x([T],kt);let St=class extends w{static{xt=this}static{this.type="ivec4"}constructor(t,e,r,n){super(),this.type="ivec4",this.children=[t,e,r,n].filter(i=>i!=null)}clone(){const t=new xt(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",h)}get 1(){return m(this,"[1]",h)}get 2(){return m(this,"[2]",h)}get 3(){return m(this,"[3]",h)}multiply(t){return _(this,typeof t=="number"?d(t,h):t)}divide(t){return k(this,typeof t=="number"?d(t,h):t)}add(t){return M(this,typeof t=="number"?d(t,h):t)}subtract(t){return S(this,typeof t=="number"?d(t,h):t)}};St=xt=x([T],St);class jt extends w{static{this.type="mat2"}constructor(e,r,n,i){super(),this.type="mat2",this.children=[e,r,n,i]}clone(){const e=new jt(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(e),e}get(e,r){return it(this,new h(e),new h(r),y)}multiply(e){return _(this,e)}}class R extends w{static{this.type="mat3"}static identity(){return new R(1,0,0,0,1,0,0,0,1)}static fromRotation(e){const r=Xt(e),n=Yt(e);return new R(n,r,0,Lt(r),n,0,0,0,1)}constructor(e,r,n,i,s,u,c,a,p){super(),this.type="mat3",this.children=[e,r,n,i,s,u,c,a,p]}add(e){return M(this,e)}multiply(e){return _(this,e)}get(e,r){return it(this,new h(e),new h(r),y)}clone(){const e=new R(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]),o(this.children[4]),o(this.children[5]),o(this.children[6]),o(this.children[7]),o(this.children[8]));return super.cloneInto(e),e}}class et extends w{static{this.type="mat4"}static identity(){return new et(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}constructor(e,r,n,i,s,u,c,a,p,l,f,I,j,P,E,K){super(),this.type="mat4",this.children=[e,r,n,i,s,u,c,a,p,l,f,I,j,P,E,K]}static fromColumns(e,r,n,i){return new et(e.x,e.y,e.z,e.w,r.x,r.y,r.z,r.w,n.x,n.y,n.z,n.w,i.x,i.y,i.z,i.w)}multiply(e){return _(this,e)}get(e,r){return it(this,new h(e),new h(r),y)}clone(){const e=new et(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]),o(this.children[4]),o(this.children[5]),o(this.children[6]),o(this.children[7]),o(this.children[8]),o(this.children[9]),o(this.children[10]),o(this.children[11]),o(this.children[12]),o(this.children[13]),o(this.children[14]),o(this.children[15]));return super.cloneInto(e),e}}const _e={float:y,vec2:z,vec3:Q,vec4:O,int:h,ivec2:nt,ivec3:kt,ivec4:St,uint:b,uvec2:_t,uvec3:$t,uvec4:It,bool:N,bvec2:Nt,bvec3:Tt,bvec4:Mt},$e=(...t)=>new h(...t),zt=(...t)=>new y(...t),Ie=(...t)=>new z(...t),Ne=(...t)=>new Q(...t),Te=(...t)=>new O(...t),Me=(...t)=>new R(...t);function m(t,e,r){const n=new r(new Kt(e,t,r));return n.isImplicit=!0,n}function it(t,e,r,n){const i=new n(new me(e,r,t,n));return i.isImplicit=!0,i}function v(t,e,r,n=null){if(n){const s=new n,u=new n(new B(t,[e,r],!0,!1,s));return u.isImplicit=!0,u}if(e.type==="float"||e.type==="int"){const s=new r.constructor(new B(t,[e,r],!0,!1,r.constructor));return s.isImplicit=!0,s}if((e.type==="mat2"||e.type==="mat3"||e.type==="mat4")&&r.type!=="float"){const s=new r.constructor(new B(t,[e,r],!0,!1,r.constructor));return s.isImplicit=!0,s}const i=new e.constructor(new B(t,[e,r],!0,!1,e.constructor));return i.isImplicit=!0,i}function g(t,e,r=e.constructor){const n=new r(new B(t,[e],!1,!1,r));return n.isImplicit=!0,n}function U(t,e,r,n=e.constructor){const i=new n(new B(t,[e,r],!1,!1,n));return i.isImplicit=!0,i}function st(t,e,r,n,i=e.constructor){const s=new i(new B(t,[e,r,n],!1,!1,i));return s.isImplicit=!0,s}function Lt(t){return _(t,zt(-1))}function ot(t,e,r,n){return new e(new ge(t,e,r,n))}function ke(t,e,r=0,n=t.size){const i=new h(r).setMutable().setDebugName("FindIndexIterator"),s=e(t.get(i)).setDebugName("FindIndexPredicate");return ot({iter:i},h,s,({out:u,iter:c,subgraph:a})=>`
${u} = -1;

for (; ${c} < ${n}; ${c}++) {

${a.body}

  if (${a.varName}) {
    ${u} = ${c};
    break;
  }

}
`).setDebugName("FindIndexBlock")}function Se(t,e,r=0,n=t.size){return ot({array:t},h,null,({out:i,array:s})=>`
${i} = -1;
for (int i = ${r}; i < ${n}; i++) {
  bool condition;
  ${e({array:s,i:"i",out:"condition"})}
  if (condition) {
    ${i} = i;
    break;
  }
}
`).setDebugName("GlslFindIndexBlock")}function qt(t,e,r){const n=typeof e=="function"?e():e,i=typeof r=="function"?r():r,s=new n.constructor(new Dt(t,n,i));return s.isImplicit=!0,s}function Ce(...t){const e=t.map(([c,a])=>typeof a=="function"?[c,a()]:[c,a]),r=e[0][1].constructor,n=e.findIndex(c=>c[0]===!0);if(n===-1)throw new Error("A cond must have a fallthrough case with `true`/; ");const i=e.slice(0,n),s=e[n][1],u=new r(i.reduceRight((c,a)=>qt(a[0],a[1],c),s));return u.isImplicit=!0,u}function _(t,e){return v("*",t,e)}function k(t,e){return v("/",t,e)}function M(t,e){return v("+",t,e)}function S(t,e){return v("-",t,e)}function Fe(t,e){return v("%",t,e)}function Pe(t,e){return v("<<",t,e)}function Ee(t,e){return v(">>",t,e)}function Ke(t,e){return v("&",t,e)}function De(t,e){return v("|",t,e)}function Ue(t,e){return v("^",t,e)}function je(t){return g("~",t)}function Oe(t,e){return v("==",t,e,N)}function Ve(t,e){return v("!=",t,e,N)}function Be(t,e){return v("<",t,e,N)}function Ae(t,e){return v("<=",t,e,N)}function ze(t,e){return v(">",t,e,N)}function Le(t,e){return v(">=",t,e,N)}function Rt(...t){return t.length<=1?t[0]:t.slice(1).reduce((e,r)=>qe(e,r),t[0])}function qe(t,e){return v("||",t,e,N)}function Gt(...t){return t.length<=1?t[0]:t.slice(1).reduce((e,r)=>Re(e,r),t[0])}function Re(t,e){return v("^^",t,e,N)}function Ht(...t){return t.length<=1?t[0]:t.slice(1).reduce((e,r)=>Ge(e,r),t[0])}function Ge(t,e){return v("&&",t,e,N)}function He(t){return g("abs",t)}function Ye(t){return g("acos",t)}function Xe(t){return g("acosh",t)}function Ct(t){return g("all",t,N)}function Ft(t){return g("any",t,N)}function Je(t){return g("asin",t)}function Qe(t){return g("asinh",t)}function Ze(t,e){return e==null?g("atan",t):U("atan",t,e,t.constructor)}function We(t){return g("atanh",t)}function tr(t){return g("ceil",t)}function er(t,e,r){return st("clamp",t,e,r,t.constructor)}function Yt(t){return g("cos",t)}function rr(t){return g("cosh",t)}function nr(t,e){return U("distance",t,e,y)}function ir(t,e){return U("dot",t,e,y)}function sr(t){return g("exp",t)}function or(t){return g("floor",t)}function ar(t){return g("fract",t)}function cr(t){return g("length",t,y)}function ur(t){return g("log",t)}function hr(t){return g("log2",t)}function dr(t,e){return U("max",t,e)}function pr(t,e){return U("min",t,e)}function lr(t,e,r){return st("mix",t,e,r)}function fr(t,e){return U("mod",t,e)}function yr(t){return g("normalize",t)}function mr(t){return t.type==="bool"?g("!",t):g("not",t)}function gr(t,e){return U("pow",t,e)}function br(t){return g("round",t)}function wr(t){return g("sign",t)}function Xt(t){return g("sin",t)}function vr(t){return g("sinh",t)}function xr(t,e,r){return st("smoothstep",t,e,r)}function _r(t){return g("sqrt",t)}function $r(t,e){return U("step",t,e,e.constructor)}function Ir(t){return g("tan",t)}function Nr(t){return g("tanh",t)}function Tr(t,e,r){return st("texelFetch",t,e,r,O)}function Mr(t,e){return U("texture",t,e,O)}function kr(t,e){const{initialValue:r,xRange:n,yRange:i,callback:s}=e,[u,c]=n,[a,p]=i,l=new h(0).setMutable().setDebugName("iterX"),f=new h(0).setMutable().setDebugName("iterY"),I=r.setMutable().setDebugName("accumulator"),j=s(I,t.get(l,f),l,f).setDebugName("callback");return ot({iterX:l,iterY:f,accumulator:I},r.constructor,j,({out:P,iterX:E,iterY:K,accumulator:G,subgraph:H})=>`
for (${K} = ${a}; ${K} < ${p}; ${K}++) {
  for (${E} = ${u}; ${E} < ${c}; ${E}++) {

  ${H.body}

  ${G} = ${H.varName};
  }
}
${P} = ${G};
`).setDebugName("reduce2DBody")}const Z=5;function $(t,e,r){const n=e.split(`
`);for(const i of n)if(i.trim().length){{let s="";r!=null&&(s+=`/*id:${r??"000"}*/   `),t.body+=s.padEnd(14)}t.body+=" ".repeat(t.indent)+i+`
`}}let Jt=class{write(t){for(const e of t.rootOutputNodes())t.shouldPruneOutputNode(e)||(e.variableName=this._write(t,e.node));return t}_createVarName(t,e){let r="";return typeof e!="boolean"&&typeof e!="number"&&e.debugInfo.name&&(r=`${e.debugInfo.name}_`),`${r}v${t.varCount++}`}_write(t,e,r=!1){if(typeof e=="number"||typeof e=="boolean")return e.toString();let n=t.getEmit(e);if(n)return n;switch(e.shaderType){case"scope-node":n=this._writeScopeNode(t,e);break;case"primitive-node":n=this._writePrimitiveNode(t,e,r);break;case"function-node":n=this._writeFunctionNode(t,e);break;case"property-access-node":n=this._writePropertyAccessNode(t,e);break;case"property-access-2d-node":n=this._writePropertyAccess2DNode(t,e);break;case"text-node":n=e.text;break;case"block-node":n=this._writeBlockNode(t,e);break;case"condition-node":n=this._writeConditionNode(t,e)}return t.setEmit(e,n),n}_writeScopeNode(t,e){const r=new e.child.constructor;r.setDebugName(e.debugInfo.name);const n=this._write(t,r,!0);return $(t,`{ /*ScopeStart: ${e.uid} ${e.debugInfo.name}*/`),t.indent+=2,$(t,`${n} = ${this._write(t,e.child)};`),t.indent-=2,$(t,`} /*ScopeEnd: ${e.uid} ${e.debugInfo.name}*/`),n}_writeConditionNode(t,e){const r=new e.ifTrue.constructor,n=this._write(t,r,!0);$(t,`if (${this._write(t,e.condition)}) {`),t.indent+=2;const i=t.createSubgraphContext(),s=this._write(i,e.ifTrue);if(t.body+=i.body,s&&$(t,`${n} = ${s};`),t.indent-=2,$(t,"}"),e.ifFalse){$(t,"else {"),t.indent+=2;const u=t.createSubgraphContext(),c=this._write(u,e.ifFalse);t.body+=u.body,c&&$(t,`${n} = ${c};`),t.indent-=2,$(t,"}")}return n}_writeBlockNode(t,e){const{captureList:r,generator:n,returnType:i}=e,s={};for(const p in r){if(!r[p])continue;const l=this._write(t,r[p]);s[p]=l}const u=new i,c=this._write(t,u,!0);if(s.out=c,e.subgraph){const p=t.createSubgraphContext(),l=this._write(p,e.subgraph.child),f=p.body;s.subgraph={varName:l,body:f}}const a=n(s);return $(t,`{
`),t.indent+=2,$(t,a),t.indent-=2,$(t,`}
`),c}_writePropertyAccessNode(t,e){const r=this._write(t,e.target);return typeof e.property=="string"&&e.property.includes("[")?`${r}${e.property}`:typeof e.property!="string"?`${r}[${this._write(t,e.property)}]`:`${r}.${e.property}`}_writePropertyAccess2DNode(t,e){return`${this._write(t,e.target)}[${this._write(t,e.x)}][${this._write(t,e.y)}]`}_writeFunctionNode(t,e){const r=e.returnType.type;if(e.isInfix){const[s,u]=e.children.map(a=>this._write(t,a)),c=this._createVarName(t,e);return $(t,`${r.padEnd(Z)} ${c} = ${s} ${e.token} ${u};`,e.uid),c}const n=e.children.map(s=>this._write(t,s)).join(", "),i=this._createVarName(t,e);return $(t,`${r.padEnd(Z)} ${i} = ${e.token}(${n});`,e.uid),i}_writePrimitiveNode(t,e,r=!1){const n=t.getInput(e);if(n)return n.isUsed=!0,n.variableName;const i=e.children.length===1&&e.children[0]?.type===e.type;if(!e.isMutable&&(e.isImplicit||i))return this._write(t,e.children[0]);const s=this._createVarName(t,e);if(r)return $(t,`${e.type.padEnd(Z)} ${s};`,e.uid),s;const u=!e.debugInfo.name&&!e.isMutable;if(u&&e.type==="float"&&typeof e.children[0]=="number")return Number.isInteger(e.children[0])?e.children[0].toFixed(1):e.children[0].toString();if(u&&e.type==="int"&&typeof e.children[0]=="number"&&Number.isInteger(e.children[0]))return e.children[0].toString();const c=e.children.map(a=>this._write(t,a)).join(", ");return e.type==="array"?($(t,`${e.type.padEnd(Z)} ${s} = [${c}];`,e.uid),s):u?`${e.type}(${c})`:($(t,`${e.type.padEnd(Z)} ${s} = ${e.type}(${c});`,e.uid),s)}};class V{constructor(e,r,n,i=[]){this.variableName=e,this.variableInputType=r,this.node=n,this.qualifiers=i,this.type="shader-input",this.isUsed=!1}clone(){return new V(this.variableName,this.variableInputType,o(this.node),[...this.qualifiers])}}let C=class ie{constructor(e,r,n,i=[]){this.outVariableName=e,this.outVariableType=r,this.node=n,this.qualifiers=i,this.type="shader-output"}clone(){const e=new ie(this.outVariableName,this.outVariableType,o(this.node),[...this.qualifiers]);return e.variableName=this.variableName,e}},Qt=class ct{static createVertex(e,r,n,i,s,u){const c=[];for(const p in e){const l=e[p],f=n.get(p);f?c.push(new V(f,"builtin",l)):c.push(new V("a_"+p,"in",l))}for(const p of i){const l=p.uniformHydrated;c.push(new V(p.uniformName,"uniform",l))}const a=[];for(const p in r){const l=r[p];if(p==="glPosition")a.push(new C("gl_Position","builtin",l));else if(p==="glPointSize")a.push(new C("gl_PointSize","builtin",l));else{const f=Sr(l),I=[];f&&I.push(f),a.push(new C("v_"+p,"out",l,I))}}return new ct(c,a,s,u)}static createFragment(e,r,n,i,s,u){const c=[],a=Array.from(s.rootOutputNodes());for(const l in e){const f=e[l],I=n.get(l);if(I){c.push(new V(I,"builtin",f));continue}const j=a.find(P=>P.node===f);j&&c.push(new V(j.outVariableName,"in",f))}for(const l of i){const f=l.uniformHydrated;c.push(new V(l.uniformName,"uniform",f))}const p=[];for(const l in r){const f=r[l],I=n.get(l);switch(l){case"discard":p.push(new C(null,"discard",f));break;case"fragData0":p.push(new C("fragData0","fragData0",f));break;case"fragData1":p.push(new C("fragData1","fragData1",f));break;case"fragData2":p.push(new C("fragData2","fragData2",f));break;case"fragData3":p.push(new C("fragData3","fragData3",f));break;default:I?p.push(new C(I,"builtin",f)):p.push(new C(l,"out",f))}}return new ct(c,p,u)}constructor(e,r,n,i){this.type="shader-graph-context",this.indent=0,this.body="",this.varCount=0,this._inputShaderTypesByNodeUid=new Map,this._nodeEmitMap=new Map;for(const s of e)this._inputShaderTypesByNodeUid.set(s.node.uid,s);this._outputShaderTypes=r,this._transformFeedbackBindings=n,this._transformFeedbackNames=new Set(n.map(s=>"v_"+s.propertyKey)),this._usedInFragmentShader=i}shouldPruneOutputNode(e){return!!this._usedInFragmentShader&&e.outVariableType!=="builtin"&&!this._transformFeedbackNames.has(e.outVariableName)&&!this._usedInFragmentShader.has(e.node.uid)}setEmit(e,r){this._nodeEmitMap.set(e.uid,r)}getEmit(e){return this._nodeEmitMap.get(e.uid)}inputs(){return this._inputShaderTypesByNodeUid.values()}getInput(e){return this._inputShaderTypesByNodeUid.get(e.uid)}*rootOutputNodes(){for(const e of this._outputShaderTypes)yield e}*nodes(){const e=[];for(const r of this._outputShaderTypes.values())e.push(r.node);for(;e.length;){const r=e.pop();typeof r!="number"&&typeof r!="boolean"&&e.push(...r.children.filter(Boolean)),yield r}}*nodesOfTypeOrFunction(){for(const e of this.nodes())typeof e!="number"&&typeof e!="boolean"&&(yield e)}createSubgraphContext(){const e=this.clone();return e.body="",e.indent=this.indent+2,e._nodeEmitMap=new Map(this._nodeEmitMap),e}clone(){const e=new ct([],this._outputShaderTypes,this._transformFeedbackBindings,this._usedInFragmentShader);return e._inputShaderTypesByNodeUid=this._inputShaderTypesByNodeUid,e.indent=this.indent,e.body=this.body,e.varCount=this.varCount,e._nodeEmitMap=this._nodeEmitMap,e}insertVertexShader(e){e.vertex.code.add(""),this._insertInputs(e,"vertex"),e.vertex.code.add(""),e.vertex.code.add("// OUTPUTS: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const r of this.rootOutputNodes()){const n=r.outVariableType==="builtin";if(!this.shouldPruneOutputNode(r))if(n)e.vertex.code.add(`// ${r.outVariableType.padEnd(7)} ${r.node.type.padEnd(9)} ${r.outVariableName};`);else{const i=[...r.qualifiers,r.outVariableType].join(" ");e.vertex.code.add(`${i.padEnd(10)} ${r.node.type.padEnd(9)} ${r.outVariableName};`)}}e.vertex.code.add(""),e.vertex.code.add("void main() {"),e.vertex.code.add("  "+this.body.split(`
`).join(`
  `));for(const r of this.rootOutputNodes())this.shouldPruneOutputNode(r)||e.vertex.code.add(`  ${r.outVariableName} = ${r.variableName};`);e.vertex.code.add("}")}insertFragmentShader(e){this._insertInputs(e,"fragment"),e.fragment.code.add(""),e.fragment.code.add("// OUTPUTS: "),e.fragment.code.add("// --------------------------------------------------------- ");let r=0;for(const n of this.rootOutputNodes())n.outVariableType==="builtin"?e.fragment.code.add(`// ${n.outVariableType.padEnd(7)} ${n.node.type.padEnd(9)} ${n.outVariableName};`):e.outputs.add(n.outVariableName,n.node.type,r++);e.fragment.code.add(""),e.fragment.code.add("void main() {"),e.fragment.code.add("  "+this.body.split(`
`).join(`
  `));for(const n of this.rootOutputNodes())n.outVariableType==="discard"?(e.fragment.code.add("  // TODO: Should ensure codegen for discard appears first in fragment shader"),e.fragment.code.add(`  if (${n.variableName}) {`),e.fragment.code.add("    discard;"),e.fragment.code.add("  }"),e.fragment.code.add("  ")):e.fragment.code.add(`  ${n.outVariableName} = ${n.variableName};`);e.fragment.code.add("}")}_insertInputs(e,r){e[r].code.add("// INPUTS: "),e[r].code.add("// --------------------------------------------------------- ");for(const n of this.inputs())if(n.isUsed&&n.variableInputType!=="builtin")if(n.node.type==="array")e[r].code.add(`${n.variableInputType.padEnd(10)} ${n.node.elementType.type.padEnd(9)} ${n.variableName}[${n.node.size}];`);else if(n.node.type==="array-2d")e[r].code.add(`${n.variableInputType.padEnd(10)} ${n.node.elementType.type.padEnd(9)} ${n.variableName}[${n.node.size}]; // Emulated 2D Array. Not supported by ES3.0`);else{const i=[...n.qualifiers,n.variableInputType].join(" ");e[r].code.add(` ${i.padEnd(10)} ${n.node.type.padEnd(9)} ${n.variableName};`)}}};function Sr(t){switch(t.type){case"float":case"vec2":case"vec3":case"vec4":return null;case"int":case"ivec2":case"ivec3":case"ivec4":case"uint":case"uvec2":case"uvec3":case"uvec4":case"bool":case"bvec2":case"bvec3":case"bvec4":return"flat";case"mat2":case"mat3":case"mat4":case"array":case"sampler2D":case"array-2d":throw new Error(`InternalError: ${t.type} is not a valid output type`)}}function Cr(t,e,r){const n=new ue(e.width,e.height);return n.dataType=e.dataType,e.depth&&(n.depth=e.depth),e.flipped&&(n.flipped=e.flipped),e.hasMipmap&&(n.hasMipmap=e.hasMipmap),n.internalFormat=e.internalFormat,e.isImmutable&&(n.isImmutable=e.isImmutable),e.isOpaque&&(n.isOpaque=e.isOpaque),e.maxAnisotropy&&(n.maxAnisotropy=e.maxAnisotropy),n.pixelFormat=e.pixelFormat,e.preMultiplyAlpha&&(n.preMultiplyAlpha=e.preMultiplyAlpha),e.samplingMode&&(n.samplingMode=e.samplingMode),e.target&&(n.target=e.target),n.uniform=e.uniform,e.unpackAlignment&&(n.unpackAlignment=e.unpackAlignment),e.wrapMode&&(n.wrapMode=e.wrapMode),new he(t,n,r)}const Fr=()=>Bt.getLogger("esri.views.2d.engine.webgl.shaderGraph.typed.TypedShaderProgram");function W(t,e,r){const n=e.length;if(n!==r){const i=new ae("Invalid Uniform",`Invalid length, expected ${r} but got ${n}`,{uniformName:t,values:e});Fr().errorOnce(i)}}let Pt=class{constructor(t,e,r,n,i){this.vertexShader=t,this.fragmentShader=e,this._locations=r,this._uniformBindings=n,this._transformFeedbackBindings=i,this._vao=null,this._temporaryTextures=[]}destroy(){this._program=se(this._program),this.cleanupTemporaryTextures()}setUniforms(t){this._uniforms=t}cleanupTemporaryTextures(){for(const t of this._temporaryTextures)t.dispose();this._temporaryTextures=[]}bind(t){const e=this._uniforms;if(!this._program){const n=[];for(const i of this._transformFeedbackBindings??[]){const{index:s,propertyKey:u}=i;n[s]=`v_${u}`}this._program=new ce(t,this.vertexShader,this.fragmentShader,this._locations,new Map,n)}const r=this._program;t.useProgram(r);for(const n of this._uniformBindings){const{shaderModulePath:i,uniformName:s,uniformType:u,uniformArrayLength:c}=n,a=oe(i,e);if(a==null){if(u==="sampler2D")continue;throw new Error(`Failed to find uniform value for ${i}`)}switch(u==="array"||u==="array-2d"?n.uniformArrayElementType:u){case"sampler2D":{const{unit:p,texture:l}=a;if(r.setUniform1i(s,p),"type"in l)t.bindTexture(l,p);else{const f=Cr(t,l.descriptor,l.data);t.bindTexture(f,p)}break}case"int":if(!c){r.setUniform1i(s,a);break}W(n.uniformName,a,c),r.setUniform1iv(s,a);break;case"float":if(!c){r.setUniform1f(s,a);break}W(n.uniformName,a,c),r.setUniform1fv(s,a);break;case"vec2":if(!c){r.setUniform2f(s,a[0],a[1]);break}W(n.uniformName,a,c),r.setUniform2fv(s,a.flat());break;case"vec3":if(!c){r.setUniform3f(s,a[0],a[1],a[2]);break}W(n.uniformName,a,c),r.setUniform3fv(s,a.flat());break;case"vec4":if(!c){r.setUniform4f(s,a[0],a[1],a[2],a[3]);break}W(n.uniformName,a,c),r.setUniform4fv(s,a.flat());break;case"mat3":r.setUniformMatrix3fv(s,a);break;case"mat4":r.setUniformMatrix4fv(s,a);break;default:throw new Error(`Unable to set uniform for type ${u}`)}}}};function tt(t){return new t}function L(t,e,r){const n=t.constructor[e]??[];t.constructor.hasOwnProperty(e)||Object.defineProperty(t.constructor,e,{value:n.slice()}),t.constructor[e].push(r)}function Pr(t,e){return(r,n)=>{L(r,"locations",{typeCtor:e,propertyKey:n,parameterIndex:null,index:t})}}const Er=t=>(e,r)=>{L(e,"builtins",{builtin:t,propertyKey:r})},Kr=t=>(e,r,n)=>{L(e,"inputs",{inputCtor:t,propertyKey:r,parameterIndex:n})},Dr=t=>(e,r)=>{L(e,"uniforms",{typeCtor:t,propertyKey:r})},Ur=t=>(e,r)=>{L(e,"options",{typeCtor:t,propertyKey:r})},jr=(t,e)=>{L(t,"defines",{propertyKey:e})},Et=(t,e)=>(r,n)=>{r.constructor.builtins.push({builtin:t,propertyKey:n,typeCtor:e})};class Zt{static{this.builtins=[]}}x([Et("gl_VertexID",h)],Zt.prototype,"glVertexID",void 0);class Or{}class at{static{this.builtins=[]}}x([Et("gl_FragCoord",O)],at.prototype,"glFragCoord",void 0),x([Et("gl_PointCoord",z)],at.prototype,"glPointCoord",void 0);let Wt=class{};x([Er("gl_FragDepth")],Wt.prototype,"glFragDepth",void 0);let Vr=class{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}},Br=class{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const t=this._shaderModuleClass.inputs.findLast(e=>e.propertyKey==="vertex"&&e.parameterIndex===0);if(!t)throw new Error("Unable to find vertex input parameter");return t}get computeInput(){return this._shaderModuleClass.inputs.findLast(t=>t.propertyKey==="vertex"&&t.parameterIndex===1)}get fragmentInput(){const t=this._shaderModuleClass.inputs.findLast(e=>e.propertyKey==="fragment");if(!t)throw new Error("Unable to find fragment input parameter");return t}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){return[...this.vertexInput.inputCtor.locations,...this.computeInput?.inputCtor.locations??[]]}get locationsMap(){const t=new Map,e=new Set;for(const r of this.locations)e.has(r.index)?Bt.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${r.propertyKey} to ${r.index}. Index already in use`,{locationsMap:t}):(t.set(r.propertyKey,r.index),e.add(r.index));return t}get locationInfo(){if(!this._locationInfo){const t=this.locationsMap,e=Array.from(t.entries()).map(([n,i])=>`${n}.${i}`).join("."),r=this.computeAttributes;this._locationInfo={stringHash:e,locations:t,computeAttributeMap:r}}return this._locationInfo}get renamedLocationsMap(){const t=new Map;for(const e of this.locations)t.set("a_"+e.propertyKey,e.index);return t}get optionPropertyKeys(){if(!this._optionPropertyKeys){const t=new Set;for(const e of this._options)t.add(e.propertyKey);this._optionPropertyKeys=t}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram(t,e,r,n){try{const{vertex:i,fragment:s,uniformBindings:u}=this._generateShaders(t,e,r,n);return new Pt(i,s,this.renamedLocationsMap,u,this.transformFeedbackBindings)}catch{return new Pt("","",this.renamedLocationsMap,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo(t){const e=this._options.find(n=>n.propertyKey===t);if(e)return{type:"option",className:e.typeCtor};const r=this._uniforms.find(n=>n.propertyKey===t);if(!r)throw new Error(`Unable to find uniform class type for property: ${t}`);return{type:"required",className:r.typeCtor}}getShaderKey(t,e,r,n){const i=Object.keys(t).map(a=>`${a}.${t[a]}`).join("."),s=Object.keys(r).map(a=>`${a}.${r[a]}`).join("."),u=Object.keys(n).map(a=>`${a}.${n[a]}`).join("."),c=Object.keys(e).filter(a=>this.optionPropertyKeys.has(a)&&e[a]).join(".");return`${this.type}.${i}.${s}.${u}.${c}`}_generateShaders(t,e,r,n){const i=[];this._setDefines(r),this._setOptionalUniforms(i,e),this._setRequiredUniforms(i);const s=this._hydrateVertexInput(n),u=this._injectPackPrecisionFactor(s,t),c=this._hydrateComputeInput(),a=c&&this._injectComputePackPrecisionFactor(c,t),p=this.vertex(u,a),l=this._hydrateFragmentInput(p),f=this.fragment(l),I=new Set;for(const Y in f){const X=f[Y];fe(I,X)}const j=this._getVertexInputBuiltins(),P={};for(const[Y,X]of Object.entries(s))P[Y]=X;if(c!=null)for(const[Y,X]of Object.entries(c))P[Y]=X;const E=Qt.createVertex(P,p,j,i,this.transformFeedbackBindings,I);new Jt().write(E);const K=this._getFragmentInputBuiltins(f);K.set("glPointCoord","gl_PointCoord"),K.set("glFragCoord","gl_FragCoord");const G=Qt.createFragment(l,f,K,i,E,this.transformFeedbackBindings);new Jt().write(G);const H=this._createShaderBuilder(E,G),Ot=H.generate("vertex"),Vt=H.generate("fragment");return this.logShader&&(console.log(Ot),console.log(Vt)),{vertex:Ot,fragment:Vt,uniformBindings:i}}_setDefines(t){for(const e in t)this[e]=t[e]}_setOptionalUniforms(t,e){for(const r of this._options)e[r.propertyKey]?this[r.propertyKey]=this._hydrateUniformGroup(t,r):this[r.propertyKey]=null}_setRequiredUniforms(t){for(const e of this._uniforms)this[e.propertyKey]=this._hydrateUniformGroup(t,e)}_hydrateUniformGroup(t,e){const r=new e.typeCtor;for(const n of r._uniforms??[]){const i=tt(n.typeCtor),s=`u_${e.propertyKey}_${n.propertyKey}`,u=i.type,c=[e.propertyKey,n.propertyKey].join(".");if("type"in n.typeCtor&&n.typeCtor.type==="array"){const a=i;t.push({shaderModulePath:c,uniformName:s,uniformType:u,uniformArrayLength:a.size,uniformArrayElementType:a.elementType.type,uniformHydrated:i})}else if("type"in n.typeCtor&&n.typeCtor.type==="array-2d"){const a=i;t.push({shaderModulePath:c,uniformName:s,uniformType:u,uniformArrayLength:a.size,uniformArrayElementType:a.elementType.type,uniformHydrated:i})}else t.push({shaderModulePath:c,uniformName:s,uniformType:u,uniformHydrated:i});r[n.propertyKey]=i}return r}_hydrateVertexInput(t){const e=this.vertexInput.inputCtor,r=e.locations.reduce((n,i)=>t[i.propertyKey]===!1?n:{...n,[i.propertyKey]:tt(i.typeCtor)},{});for(const{propertyKey:n,typeCtor:i}of e.builtins){const s=tt(i);r[n]=s}return r}_hydrateComputeInput(){return this.computeInput==null?null:this.computeInput.inputCtor.locations.reduce((t,e)=>({...t,[e.propertyKey]:tt(e.typeCtor)}),{})}_injectPackPrecisionFactor(t,e){const r={};for(const n in t){const i=t[n],s=e[n];if(s){if(i.type!=="float"&&i.type!=="vec2"&&i.type!=="vec3"&&i.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${i.type}`);r[n]=i.divide(new y(s))}else r[n]=i}return r}_injectComputePackPrecisionFactor(t,e){const r={},n=new Map;for(const i in this.computeAttributes)for(const s of this.computeAttributes[i]??[])n.set(s,i);for(const i in t){const s=t[i],u=n.get(i);if(!u)continue;const c=e[u];if(c){if(s.type!=="float"&&s.type!=="vec2"&&s.type!=="vec3"&&s.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${s.type}`);r[i]=s.divide(new y(c))}else r[i]=s}return r}_hydrateFragmentInput(t){const e={};for(const r in t)e[r]=t[r];for(const{propertyKey:r,typeCtor:n}of at.builtins){const i=tt(n);e[r]=i}return e}_getVertexInputBuiltins(){const t=this.vertexInput.inputCtor,e=new Map;for(const{builtin:r,propertyKey:n}of t.builtins)e.set(n,r);return e}_getFragmentInputBuiltins(t){const e=t.constructor,r=new Map;for(const n of e.builtins??[])r.set(n.propertyKey,n.builtin);return r}_createShaderBuilder(t,e){const r=new de;return this._insertDebugInfo(r),t.insertVertexShader(r),e.insertFragmentShader(r),r}_insertDebugInfo(t){t.vertex.code.add("// DEFINES: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this._defines)this[e.propertyKey]?t.vertex.code.add(`//   ${e.propertyKey}: true`):t.vertex.code.add(`//   ${e.propertyKey}: false`);t.vertex.code.add(""),t.vertex.code.add("// OPTIONS: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this._options)this[e.propertyKey]?t.vertex.code.add(`//   ${e.propertyKey}: true`):t.vertex.code.add(`//   ${e.propertyKey}: false`)}};export{N as $,_r as A,Ae as B,y as C,Be as D,xr as E,rt as F,ze as G,sr as H,at as I,et as J,Ze as K,cr as L,Yt as M,h as N,br as O,Br as P,He as Q,_ as R,Fe as S,ar as T,Ut as U,Tr as V,gr as W,dr as X,Q as Y,nt as Z,O as _,fr as a,$e as a0,wr as a1,Ur as a2,Lt as a3,Ve as a4,Le as a5,Gt as a6,Rt as a7,Ht as a8,Ue as a9,Pt as aA,je as aa,Ee as ab,Pe as ac,De as ad,Ke as ae,Nr as af,Ir as ag,vr as ah,rr as ai,We as aj,Qe as ak,Je as al,Xe as am,Ye as an,tr as ao,hr as ap,ur as aq,kr as ar,ut as as,ot as at,Or as au,jt as av,nr as aw,mr as ax,yr as ay,Me as az,Oe as b,z as c,Mr as d,lr as e,Pr as f,Kr as g,Ne as h,Zt as i,Vr as j,pe as k,Te as l,Dr as m,jr as n,Ie as o,qt as p,er as q,R as r,zt as s,pr as t,Xt as u,Wt as v,ir as w,$r as x,Ce as y,or as z};
