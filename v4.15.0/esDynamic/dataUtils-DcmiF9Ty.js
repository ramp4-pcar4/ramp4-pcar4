import{al as $,i as et,a9 as nt,ce as C,cf as E,cg as rt,ch as ot,ci as it}from"./main-pOgmbpmS.js";const T=()=>et.getLogger("esri.views.2d.engine.flow.dataUtils"),lt=10;async function st(d,t,r,h){const w=performance.now(),s=W(t,r),e=performance.now(),y=G(t,s,r.width,r.height),n=performance.now(),l=ft(y),a=performance.now(),A=d==="Streamlines"?ht(l,lt):ut(l),p=performance.now();return $("esri-2d-profiler")&&(T().info("I.1","_createFlowFieldFromData (ms)",Math.round(e-w)),T().info("I.2","_getStreamlines (ms)",Math.round(n-e)),T().info("I.3","createAnimatedLinesData (ms)",Math.round(a-n)),T().info("I.4","create{Streamlines|Particles}Mesh (ms)",Math.round(p-a)),T().info("I.5","createFlowMesh (ms)",Math.round(p-w)),T().info("I.6","Mesh size (bytes)",A.vertexData.buffer.byteLength+A.indexData.buffer.byteLength)),await Promise.resolve(),nt(h),A}function W(d,t){const r=ct(t.data,t.width,t.height,d.smoothing);return d.interpolate?(h,w)=>{const s=Math.floor(h),e=Math.floor(w);if(s<0||s>=t.width)return[0,0];if(e<0||e>=t.height)return[0,0];const y=h-s,n=w-e,l=s,a=e,A=s<t.width-1?s+1:s,p=e<t.height-1?e+1:e,c=r[2*(a*t.width+l)],f=r[2*(a*t.width+A)],g=r[2*(p*t.width+l)],m=r[2*(p*t.width+A)],x=r[2*(a*t.width+l)+1],u=r[2*(a*t.width+A)+1];return[(c*(1-n)+g*n)*(1-y)+(f*(1-n)+m*n)*y,(x*(1-n)+r[2*(p*t.width+l)+1]*n)*(1-y)+(u*(1-n)+r[2*(p*t.width+A)+1]*n)*y]}:(h,w)=>{const s=Math.round(h),e=Math.round(w);return s<0||s>=t.width||e<0||e>=t.height?[0,0]:[r[2*(e*t.width+s)],r[2*(e*t.width+s)+1]]}}function z(d,t,r,h,w,s,e,y){const n=[],{raster:l,width:a,height:A,resolutionFactor:p}=y;let c=h,f=w,g=0,[m,x]=r(c,f);m*=t.velocityScale,x*=t.velocityScale;const u=Math.sqrt(m*m+x*x);let M,i;n.push({x:c,y:f,t:g,speed:u});for(let o=0;o<t.verticesPerLine;o++){let[v,U]=r(c,f);v*=t.velocityScale,U*=t.velocityScale;const O=Math.sqrt(v*v+U*U);if(O<t.minSpeedThreshold)return n;const B=d*v/O,P=d*U/O;if(c+=B*t.segmentLength,f+=P*t.segmentLength,t.wrapAround&&(c=E(c,s[0])),g+=d*t.segmentLength/O,Math.acos(B*M+P*i)>t.maxTurnAngle)return n;if(t.collisions){let D=Math.round(c*p);const F=Math.round(f*p);if(t.wrapAround&&(D=E(D,a)),D<0||D>a-1||F<0||F>A-1)return n;const V=l[F*a+D];if(V!==-1&&V!==e)return n;l[F*a+D]=e}n.push({x:c,y:f,t:g,speed:O}),M=B,i=P}return n}function at(d,t,r,h,w,s,e,y){const n=Math.round((.2+.6*e.getFloat())*d.verticesPerLine),l=d.verticesPerLine-n,a=z(-1,{...d,verticesPerLine:l},t,r,h,w,s,y),A=z(1,{...d,verticesPerLine:n},t,r,h,w,s,y),p=a.reverse();return p.splice(-1,1),p.concat(A)}function G(d,t,r,h,w={positions:[]}){if(d.density<=0)return[];const{positions:s}=w,e=[],y=new C,n=1/Math.max(d.lineCollisionWidth,1),l=Math.round(r*n),a=Math.round(h*n),A=new Int32Array(l*a);for(let u=0;u<A.length;u++)A[u]=-1;const p={raster:A,width:l,height:a,resolutionFactor:n},c={},f=d.lineSpacing/Math.sqrt(d.density),g=Math.floor(h/f),m=Math.floor(r/f);for(let u=0;u<g;u++){const M=u*f;for(let i=0;i<m;i++){const o=i*f;c[`${i}-${u}`]={x:o,y:M,positions:[]}}}for(const{x:u,y:M}of s){const i=c[`${Math.floor(u/f)}-${Math.floor(M/f)}`];i&&i.positions.push([u,M])}const x=[];for(const u in c){const M=c[u];if(M.positions.length===0)x.push({x:M.x+f/2,y:M.y+f/2,sort:.66+.33*y.getFloat(),stage:0});else{const[i]=M.positions.splice(0,1);x.push({x:i[0],y:i[1],sort:.33*y.getFloat(),stage:1});for(const[o,v]of M.positions)x.push({x:o,y:v,sort:.33+.33*y.getFloat(),stage:2})}}x.sort((u,M)=>u.sort-M.sort);for(const{x:u,y:M,stage:i}of x){const o=d.onlyForwardTracing?z(1,d,t,u,M,[r,h],e.length,p):at(d,t,u,M,[r,h],e.length,y,p);o.length<2||e.push({stage:i,vertices:o})}return e}function ct(d,t,r,h){if(h===0)return d;const w=Math.round(3*h),s=new Array(2*w+1);let e=0;for(let l=-w;l<=w;l++){const a=Math.exp(-l*l/(h*h));s[l+w]=a,e+=a}for(let l=-w;l<=w;l++)s[l+w]/=e;const y=new Float32Array(d.length);for(let l=0;l<r;l++)for(let a=0;a<t;a++){let A=0,p=0;for(let c=-w;c<=w;c++){if(a+c<0||a+c>=t)continue;const f=s[c+w];A+=f*d[2*(l*t+(a+c))],p+=f*d[2*(l*t+(a+c))+1]}y[2*(l*t+a)]=A,y[2*(l*t+a)+1]=p}const n=new Float32Array(d.length);for(let l=0;l<t;l++)for(let a=0;a<r;a++){let A=0,p=0;for(let c=-w;c<=w;c++){if(a+c<0||a+c>=r)continue;const f=s[c+w];A+=f*y[2*((a+c)*t+l)],p+=f*y[2*((a+c)*t+l)+1]}n[2*(a*t+l)]=A,n[2*(a*t+l)+1]=p}return n}function ft(d,t){const r=new C,h=d.reduce((n,l)=>n+l.vertices.length,0),w=new Float32Array(4*h),s=new Array(d.length);let e=0,y=0;for(const{vertices:n}of d){const l=e;for(const a of n)w[4*e]=a.x,w[4*e+1]=a.y,w[4*e+2]=a.t,w[4*e+3]=a.speed,e++;s[y++]={startVertex:l,numberOfVertices:n.length,totalTime:n[n.length-1].t,timeSeed:r.getFloat()}}return{lineVertices:w,lineDescriptors:s}}function ht(d,t){const{lineVertices:r,lineDescriptors:h}=d;let w=0,s=0;for(const p of h)w+=2*p.numberOfVertices,s+=6*(p.numberOfVertices-1);const e=new Float32Array(w*9),y=new Uint32Array(s);let n=0,l=0;function a(){y[l++]=n-2,y[l++]=n,y[l++]=n-1,y[l++]=n,y[l++]=n+1,y[l++]=n-1}function A(p,c,f,g,m,x,u,M){const i=n*9;let o=0;e[i+o++]=p,e[i+o++]=c,e[i+o++]=1,e[i+o++]=f,e[i+o++]=x,e[i+o++]=u,e[i+o++]=g/2,e[i+o++]=m/2,e[i+o++]=M,n++,e[i+o++]=p,e[i+o++]=c,e[i+o++]=-1,e[i+o++]=f,e[i+o++]=x,e[i+o++]=u,e[i+o++]=-g/2,e[i+o++]=-m/2,e[i+o++]=M,n++}for(const p of h){const{totalTime:c,timeSeed:f}=p;let g=null,m=null,x=null,u=null,M=null,i=null;for(let o=0;o<p.numberOfVertices;o++){const v=r[4*(p.startVertex+o)],U=r[4*(p.startVertex+o)+1],O=r[4*(p.startVertex+o)+2],B=r[4*(p.startVertex+o)+3];let P=null,D=null,F=null,V=null;if(o>0){P=v-g,D=U-m;const b=Math.sqrt(P*P+D*D);if(P/=b,D/=b,o>1){let I=P+M,q=D+i;const R=Math.sqrt(I*I+q*q);I/=R,q/=R;const S=Math.min(1/(I*P+q*D),t);I*=S,q*=S,F=-q,V=I}else F=-D,V=P;F!==null&&V!==null&&(A(g,m,x,F,V,c,f,B),a())}g=v,m=U,x=O,M=P,i=D,u=B}A(g,m,x,-i,M,c,f,u)}return{vertexData:e,indexData:y}}function ut(d){const{lineVertices:t,lineDescriptors:r}=d;let h=0,w=0;for(const F of r){const V=F.numberOfVertices-1;h+=4*V*2,w+=6*V*2}const s=new Float32Array(h*16),e=new Uint32Array(w);let y,n,l,a,A,p,c,f,g,m,x,u,M,i,o=0,v=0;function U(){e[v++]=o-8,e[v++]=o-7,e[v++]=o-6,e[v++]=o-7,e[v++]=o-5,e[v++]=o-6,e[v++]=o-4,e[v++]=o-3,e[v++]=o-2,e[v++]=o-3,e[v++]=o-1,e[v++]=o-2}function O(F,V,b,I,q,R,S,_,j,N,K,Q,X,Y){const k=o*16;let L=0;for(const Z of[1,2])for(const tt of[1,2,3,4])s[k+L++]=F,s[k+L++]=V,s[k+L++]=b,s[k+L++]=I,s[k+L++]=S,s[k+L++]=_,s[k+L++]=j,s[k+L++]=N,s[k+L++]=Z,s[k+L++]=tt,s[k+L++]=X,s[k+L++]=Y,s[k+L++]=q/2,s[k+L++]=R/2,s[k+L++]=K/2,s[k+L++]=Q/2,o++}function B(F,V){let b=g+x,I=m+u;const q=Math.sqrt(b*b+I*I);b/=q,I/=q;const R=g*b+m*I;b/=R,I/=R;let S=x+M,_=u+i;const j=Math.sqrt(S*S+_*_);S/=j,_/=j;const N=x*S+u*_;S/=N,_/=N,O(y,n,l,a,-I,b,A,p,c,f,-_,S,F,V),U()}function P(F,V,b,I,q,R){if(g=x,m=u,x=M,u=i,g==null&&m==null&&(g=x,m=u),A!=null&&p!=null){M=F-A,i=V-p;const S=Math.sqrt(M*M+i*i);M/=S,i/=S}g!=null&&m!=null&&B(q,R),y=A,n=p,l=c,a=f,A=F,p=V,c=b,f=I}function D(F,V){g=x,m=u,x=M,u=i,g==null&&m==null&&(g=x,m=u),g!=null&&m!=null&&B(F,V)}for(const F of r){y=null,n=null,l=null,a=null,A=null,p=null,c=null,f=null,g=null,m=null,x=null,u=null,M=null,i=null;const{totalTime:V,timeSeed:b}=F;for(let I=0;I<F.numberOfVertices;I++)P(t[4*(F.startVertex+I)],t[4*(F.startVertex+I)+1],t[4*(F.startVertex+I)+2],t[4*(F.startVertex+I)+3],V,b);D(V,b)}return{vertexData:s,indexData:e}}function H(d,t,r=t.width,h=t.height,w=0,s=0){const e=t.pixels,y=r*h,n=2,l=new Float32Array(y*n),a=t.width,A=(f,g)=>f+w+(g+s)*a,p=(f,g)=>f+g*r;let c;if(t.mask!=null)if(r!==t.width||h!==t.height||w!==0||s!==0){c=new Uint8Array(y*n);const f=t.mask;for(let g=0;g<h;++g)for(let m=0;m<r;++m){const x=A(m,g),u=p(m,g);c[n*u]=f[n*x],c[n*u+1]=f[n*x+1]}}else c=t.mask;else c=new Uint8Array(y*n),c.fill(255);if(d==="vector-uv")for(let f=0;f<h;++f)for(let g=0;g<r;++g){const m=A(g,f),x=p(g,f);l[n*x]=e[0][m],l[n*x+1]=-e[1][m]}else if(d==="vector-magdir"){const{cos:f,sin:g}=Math;for(let m=0;m<h;++m)for(let x=0;x<r;++x){const u=A(x,m),M=p(x,m),i=e[0][u],o=it(e[1][u]),v=f(o-Math.PI/2),U=g(o-Math.PI/2);l[n*M]=v*i,l[n*M+1]=U*i}}return{data:l,mask:c,width:r,height:h}}async function dt(d,t,r,h,w,s){const e=performance.now(),y=rt(t.spatialReference);if(!y){const i=await J(d,t,r,h,w,s);return $("esri-2d-profiler")&&T().info("I.7","loadImagery, early exit (ms)",Math.round(performance.now()-e)),$("esri-2d-profiler")&&T().info("I.9","Number of parts",1),i}const[n,l]=y.valid,a=l-n,A=Math.ceil(t.width/a),p=t.width/A,c=Math.round(r/A);let f=t.xmin;const g=[],m=performance.now();for(let i=0;i<A;i++){const o=new ot({xmin:f,xmax:f+p,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference});g.push(J(d,o,c,h,w,s)),f+=p}const x=await Promise.all(g);if($("esri-2d-profiler")&&T().info("I.8","All calls to _fetchPart (ms)",Math.round(performance.now()-m)),$("esri-2d-profiler")&&T().info("I.9","Number of parts",x.length),x.length===1)return $("esri-2d-profiler")&&T().info("I.10","loadImagery, general exit without stitching back (ms)",Math.round(performance.now()-e)),x[0];const u={data:new Float32Array(r*h*2),mask:new Uint8Array(r*h),width:r,height:h};let M=0;for(const i of x){for(let o=0;o<i.height;o++)for(let v=0;v<i.width;v++)M+v>=r||(u.data[2*(o*r+M+v)]=i.data[2*(o*i.width+v)],u.data[2*(o*r+M+v)+1]=i.data[2*(o*i.width+v)+1],u.mask[o*r+M+v]=i.mask[o*i.width+v]);M+=i.width}return $("esri-2d-profiler")&&T().info("I.10","loadImagery, general exit (ms)",Math.round(performance.now()-e)),u}async function J(d,t,r,h,w,s){const e={requestProjectedLocalDirections:!0,signal:s};if(w!=null&&(e.timeExtent=w),d.type==="imagery"){await d.load({signal:s});const n=await d.internalFetchImage(t,r,h,e);return n?.pixelData?.pixelBlock==null?{data:new Float32Array(r*h*2),mask:new Uint8Array(r*h),width:r,height:h}:H(d.rasterInfo.dataType,n.pixelData.pixelBlock)}await d.load({signal:s});const y=await d.fetchPixels(t,r,h,e);return y?.pixelBlock==null?{data:new Float32Array(r*h*2),mask:new Uint8Array(r*h),width:r,height:h}:H(d.serviceRasterInfo.dataType,y.pixelBlock)}export{st as c,G as d,W as f,dt as x};
