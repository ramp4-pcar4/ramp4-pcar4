import{h0 as _,i1 as y,g$ as M,_ as z,Y as E}from"./main-pOgmbpmS.js";import{f as x,d as T}from"./dataUtils-DcmiF9Ty.js";import{n as b}from"./Cyclical-DzzhhXF6.js";function k(e,s,t){const{extent:i,valid:u}=e,[n,a,o,r]=i;return!(t<a||t>r)&&(u!=null&&n>o?s>=o||s<=n:s>=n&&s<=o)}function j(e,s,t,i){const{extent:u,modelSize:n,valid:a}=e,[o,r,c]=u,f=A(o,c,a);let l=s/n[0]*f+o;return a!=null&&i&&(l=new b(a[0],a[1]).normalize(l)),[l,(n[1]-t)/n[1]*_(u)+r]}function A(e,s,t){if(t!=null&&e>s){const[i,u]=t;return u-e+(s-i)}return s-e}function F(e){return e?4:3}function I(e,s,t){const[i,u]=t.modelSize;let n=null;const a=new Map;s.forEach(r=>{a.set(r.lij,x(e,r))});const o=(r,c,f)=>y(r.extent,c,f);return(r,c)=>{const f=Math.round(r),l=Math.round(c);if(!e.wrapAround&&(f<0||f>=i||l<0||l>=u))return[0,0];const[d,h]=j(t,r,c,!0);if(!k(t,d,h))return[0,0];if(n==null||!o(n,d,h)){n=null;for(const[P,D]of s)if(o(D,d,h)){n=D;break}}if(n?.data==null)return[0,0];const g=a.get(n.lij);if(g==null)return[0,0];const{width:v,height:w,extent:m}=n;return g((d-m[0])/M(m)*v,w-(h-m[1])/_(m)*w)}}let p=class{constructor(){this._tileData=new Map}async generateStreamlines(e){const{flowData:s,flowExtentInfo:t,needsMagnitude:i,simulationSettings:u,startPositions:n}=e,a=S(x(u,s),u,t.modelSize,i,n);return{result:{streamlines:a},transferList:a?.map(o=>o.vertices.buffer)}}async generateTiledStreamlines(e){const{flowDataTiles:s,flowExtentInfo:t,needsMagnitude:i,reset:u,simulationSettings:n,startPositions:a}=e;this._updateTileData(s,u);const o=S(I(n,this._tileData,t),n,t.modelSize,i,a);return{result:{streamlines:o},transferList:o?.map(r=>r.vertices.buffer)??[]}}_updateTileData(e,s){s&&this._tileData.forEach((t,i)=>{e.get(i)==null&&this._tileData.delete(i)}),e.forEach((t,i)=>{t.type==="delete"?this._tileData.delete(i):t.type!=="on-worker"&&t.type!=="waiting"&&this._tileData.set(i,t.data)})}};p=z([E("esri.views.3d.support.flow.FlowWorker")],p);const L=p;function S(e,s,t,i,u){if(e==null)return;const n=T(s,e,t[0],t[1],{positions:u}),a=[],o=F(i);for(const{vertices:r,stage:c}of n){const f=new Float32Array(r.length*o);for(let l=0;l<r.length;l++)f[l*o]=r[l].x,f[l*o+1]=r[l].y,f[l*o+2]=r[l].t,i&&(f[l*o+3]=r[l].speed);a.push({vertices:f,stage:c,hasMagnitude:i})}return a}export{L as default};
