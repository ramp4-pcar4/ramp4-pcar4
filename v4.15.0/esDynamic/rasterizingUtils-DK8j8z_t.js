import{aJ as z,h_ as L,i as $}from"./main-pOgmbpmS.js";import{o as p}from"./defaultCIMValues-BWu-APou.js";import{a as R}from"./definitions-DVO21zOC.js";const P=15.5,M=4,b=64,q=1024,E={outlineWidth:.75,referenceWidth:.75,cap:p.CIMSolidStroke.capstyle,join:p.CIMSolidStroke.joinstyle,miterLimit:p.CIMSolidStroke.miterlimit};function x(t,l,a=0){const e=z(t,0,j);for(let n=0;n<4;n++)l[a+n]=Math.floor(256*B(e*G[n]))}function N(t,l=0){let a=0;for(let e=0;e<4;e++)a+=t[l+e]*W[e];return a}const G=[1,256,65536,16777216],W=[1/256,1/65536,1/16777216,1/4294967296],j=N(new Uint8ClampedArray([255,255,255,255]));N(new Uint8ClampedArray([255,255,255,0]));function B(t){return t-Math.floor(t)}const k=()=>$.getLogger("esri.symbols.cim.rasterizingUtils"),H=32,V=t=>t==="vertical"||t==="horizontal"||t==="cross"||t==="esriSFSCross"||t==="esriSFSVertical"||t==="esriSFSHorizontal";function J(t,l,a){const e=l.style,n=L(Math.ceil(a)),o=V(e)?8*n:16*n,r=2*n;t.width=o,t.height=o;const i=t.getContext("2d");i.strokeStyle="#ffffff",i.lineWidth=n,i.beginPath(),e!=="vertical"&&e!=="cross"&&e!=="esriSFSCross"&&e!=="esriSFSVertical"||(i.moveTo(o/2,-r),i.lineTo(o/2,o+r)),e!=="horizontal"&&e!=="cross"&&e!=="esriSFSCross"&&e!=="esriSFSHorizontal"||(i.moveTo(-r,o/2),i.lineTo(o+r,o/2)),e!=="backward-diagonal"&&e!=="diagonal-cross"&&e!=="esriSFSDiagonalCross"&&e!=="esriSFSBackwardDiagonal"||(i.moveTo(-r,-r),i.lineTo(o+r,o+r),i.moveTo(o-r,-r),i.lineTo(o+r,r),i.moveTo(-r,o-r),i.lineTo(r,o+r)),e!=="forward-diagonal"&&e!=="diagonal-cross"&&e!=="esriSFSForwardDiagonal"&&e!=="esriSFSDiagonalCross"||(i.moveTo(o+r,-r),i.lineTo(-r,o+r),i.moveTo(r,-r),i.lineTo(-r,r),i.moveTo(o+r,o-r),i.lineTo(o-r,o+r)),i.stroke();const h=i.getImageData(0,0,t.width,t.height),s=new Uint8Array(h.data);let f;for(let c=0;c<s.length;c+=4)f=s[c+3]/255,s[c]=s[c]*f,s[c+1]=s[c+1]*f,s[c+2]=s[c+2]*f;return[s,t.width,t.height,n]}function O(t){t.length%2==1&&(t=[...t,...t]);const l=t.reduce((c,m)=>c+m,0),a=Math.round(l*M),e=1,n=new Float32Array(a*e);let o=0,r=0,i=.5,h=!0;for(const c of t){for(o=r,r+=c*M;i<=r;){const m=i-.5,u=Math.min(Math.abs(i-o),Math.abs(i-r));n[m]=h?-u:u,i++}h=!h}const s=n.length,f=new Uint8Array(4*s);for(let c=0;c<s;++c){const m=n[c]/M;x(m/b*.5+.5,f,4*c)}return[f,a,e]}function Q(t,l){t==null&&(t=[]);const a=l==="Butt",e=l==="Square",n=!a&&!e;t.length%2==1&&(t=[...t,...t]);const o=P,r=2*o;let i=0;for(const d of t)i+=d;const h=Math.round(i*o),s=new Float32Array(h*r),f=.5*o;let c=0,m=0,u=.5,S=!0;for(const d of t){for(c=m,m+=d*o;u<=m;){let C=.5;for(;C<r;){const U=(C-.5)*h+u-.5,g=n?(C-o)*(C-o):Math.abs(C-o);s[U]=S?a?Math.max(Math.max(c+f-u,g),Math.max(u-m+f,g)):g:n?Math.min((u-c)*(u-c)+g,(u-m)*(u-m)+g):e?Math.min(Math.max(u-c,g),Math.max(m-u,g)):Math.min(Math.max(u-c+f,g),Math.max(m+f-u,g)),C++}u++}S=!S}const v=s.length,I=new Uint8Array(4*v);for(let d=0;d<v;++d){const C=(n?Math.sqrt(s[d]):s[d])/o;x(C,I,4*d)}return[I,h,r]}function X(t,l){const{colorRamp:a,gradientType:e}=l,n=a.type==="CIMFixedColorRamp",o=l.interval||p.CIMGradientFill.interval;let r=F(a);return n&&(r=A(r,o)),e==="Discrete"||n?_(t,r,o):Z(t,r)}let w;function Y(t,l){const{colorRamp:a,gradientType:e}=l,n=F(a),o=a.type==="CIMFixedColorRamp";if(e==="Continuous"&&!o)return y(t,n);const r=l.interval??p.CIMGradientFill.interval;if(o)return y(t,A(n,r));const i=[];w??=document.createElement("canvas"),T(w,n,r,1,0);const h=w.getContext("2d").getImageData(0,0,r,1).data;for(let s=0,f=0;s<r;s++,f=4*s){const c=[h[f+0],h[f+1],h[f+2],h[f+3]];i.push({offset:s/r,color:c}),i.push({offset:(s+1)/r,color:c})}return y(t,i)}function F(t){const l=[];switch(t.type){case"CIMPolarContinuousColorRamp":case"CIMLinearContinuousColorRamp":{t.type==="CIMPolarContinuousColorRamp"&&k().warnOnce("CIMPolarContinuousColorRamp is currently unsupported. Falling back to CIMLinearContinuousColorRamp.");const a=t;l.push({offset:0,color:[a.fromColor[0],a.fromColor[1],a.fromColor[2],a.fromColor[3]/255]}),l.push({offset:1,color:[a.toColor[0],a.toColor[1],a.toColor[2],a.toColor[3]/255]});break}case"CIMFixedColorRamp":{const a=t,e=1/(a.colors.length-1);let n=0;for(const o of a.colors)l.push({offset:n,color:[o[0],o[1],o[2],o[3]/255]}),n+=e;break}case"CIMMultipartColorRamp":{const a=t,e=a.weights.reduce((o,r)=>o+r,0);let n=0;for(let o=0;o<a.colorRamps.length;o++){const r=a.colorRamps[o],i=a.weights[o],h=F(r);for(const s of h)l.push({offset:(n+s.offset*i)/e,color:s.color});n+=i}break}default:k().error(`Color ramp "${t.type}" currently unsupported.`)}return l}function A(t,l){const a=[],e=(t.length-1)/(l-1);for(let n=0;n<l;n++){const o=t[Math.round(n*e)].color;a.push({offset:n/l,color:o}),a.push({offset:(n+1)/l,color:o})}return a}function Z(t,l){return T(t,l,H,1,R),D(t)}function _(t,l,a){return T(t,l,a,1,R),D(t)}function y(t,l,a=0){for(const{offset:e,color:n}of l)t.addColorStop(Math.min(Math.max(e,a),1-a),`rgba(${n[0]}, ${n[1]}, ${n[2]}, ${n[3]})`)}function T(t,l,a,e,n){const o=a+2*n;t.width=o,t.height=e;const r=(n+1)/o,i=t.getContext("2d",{willReadFrequently:!0});if(l.length>0){const h=i.createLinearGradient(0,0,o,e);y(h,l,r),i.fillStyle=h}else i.fillStyle="rgba(128, 128, 128, 1)";i.fillRect(0,0,o,e)}function D(t){const{width:l,height:a}=t,e=t.getContext("2d").getImageData(0,0,l,a),n=new Uint8Array(e.data);for(let o=0;o<n.length;o+=4){const r=n[o+3]/255;n[o]*=r,n[o+1]*=r,n[o+2]*=r}return[n,l,a]}function K(t){const l=t[0]?.[0]?.[0]??0,a=t[0]?.[0]?.[1]??0,e={ymin:a,xmin:l,ymax:a,xmax:l,width:0,height:0};for(let n=0;n<t.length;n++){const o=t[n];for(let r=0;r<o.length;r++){const i=o[r][0],h=o[r][1];i<e.xmin&&(e.xmin=i),i>e.xmax&&(e.xmax=i),h<e.ymin&&(e.ymin=h),h>e.ymax&&(e.ymax=h)}}return e.width=Math.abs(e.xmax-e.xmin),e.height=Math.abs(e.ymax-e.ymin),e}function tt(t,l){const a=K(t),e=a.width===0?1:a.width,n=a.height===0?1:a.height,o=[];for(let r=0;r<t.length;r++){const i=t[r],h=[];for(let s=0;s<i.length;s++){let f=Math.round(i[s][0]-a.xmin),c=Math.round(i[s][1]-a.ymin);if(f=l.xmin+f*l.width/e,c=l.ymin+c*l.height/n,isNaN(f)||isNaN(c))throw new Error("Scaled shape has NaN values");h.push([f,c])}o.push(h)}return o}function ot(t,l,a){const e=[];for(let n=0;n<t.length;n++){const o=t[n],r=[];for(let i=0;i<o.length;i++){const h=o[i][0]+l,s=o[i][1]+a;if(isNaN(h)||isNaN(s))throw new Error("Scaled shape has NaN values");r.push([h,s])}e.push(r)}return e}export{ot as R,tt as T,b as a,J as f,X as g,M as i,E as l,O as m,x as o,Y as p,q as r,Q as u};
