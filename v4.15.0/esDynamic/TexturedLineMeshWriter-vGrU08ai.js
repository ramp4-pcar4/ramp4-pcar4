import{bA as Ct,i as ct,s as Rt,gB as Yt,ca as g,al as Bt,ci as Ut}from"./main-pOgmbpmS.js";import{b as ut,l as Vt}from"./GeometryUtils-DG_UC3Yu.js";import{C as Wt,w as lt,B as pt,L as Zt,J as N,K as ht,D as qt,E as Ht}from"./constants-CWFGCPkc.js";import{R as p}from"./enums-DDJfd4_p.js";import{e as z}from"./defaultCIMValues-BWu-APou.js";import{o as G,s as xt,T as Xt,t as b,a as C}from"./definitions-DVO21zOC.js";import{b as W,e as ft,c as Z}from"./UpdateTracking2D-dW6Ft3us.js";import{a as k}from"./labelPoint-CDs0zrBw.js";import{a as jt,_ as Jt,i as Kt}from"./TurboLine-zl0lHYyK.js";import{t as $t,s as Qt,b as te,c as dt}from"./Utils-Dn4BkPzh.js";import{e as ee}from"./OptimizedGeometry-B85ROtfy.js";import{X as mt,R as yt,g as _t,l as re}from"./CIMSymbolHelper-iXuDnu-M.js";const se=()=>ct.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.meshWriterUtils"),ne=0,ie=100;function q(t,e){return[!!t?.minScale&&e.scaleToZoom(t.minScale)||ne,!!t?.maxScale&&e.scaleToZoom(t.maxScale)||ie]}function H(t){return 1<<t}function T(t){let e=0;for(const[r,n]of t)n&&(e|=1<<r);return e}function A(t){let e;if(!t)return[0,0,0,0];if(typeof t=="string"){const a=Ct.fromString(t);if(!a)return se().errorOnce(new Rt("mapview:mesh-processing","Unable to parse string into color",{color:t})),[0,0,0,0];e=a.toArray()}else e=t;const[r,n,s,i]=e;return[r*(i/255),n*(i/255),s*(i/255),i]}function gt(t){switch(t){case"butt":case"Butt":return 0;case"round":case"Round":return 1;case"square":case"Square":return 2}}function vt(t){switch(t){case"bevel":case"Bevel":return 0;case"miter":case"Miter":return 2;case"round":case"Round":return 1}}function ae(t,e){return Math.round(Math.min(Math.sqrt(t*e),255))}function R(t,e){return Math.round(t*e)/e}const oe=96/72;let bt=class{static executeEffects(t,e,r,n){const s=oe,i=mt(t);let a=new _t(e);for(const o of t){const c=yt(o);c&&(a=c.execute(a,o,s,r,i,n))}return a}static applyEffects(t,e){if(!t)return e;const r=mt(t);let n,s=new _t(k.fromJSONCIM(e));for(const o of t){const c=yt(o);c&&(s=c.execute(s,o,1,null,r,!1))}const i=[];let a=null;for(;n=s.next();)i.push(...Yt(n)),a=n.geometryType;return i.length===0||a===null?null:a==="esriGeometryPolygon"?{rings:i}:{paths:i}}};function kt(t){switch(t){case p.BYTE:case p.UNSIGNED_BYTE:return 1;case p.SHORT:case p.UNSIGNED_SHORT:case p.HALF_FLOAT:return 2;case p.FLOAT:case p.INT:case p.UNSIGNED_INT:return 4}}function ce(t){const e=[],r=[],n=[];for(const s of t){const i=kt(s.type)*s.count;switch(i%2||i%4||4){case 4:e.push(s);continue;case 2:r.push(s);continue;case 1:n.push(s);continue;default:throw new Error("Found unexpected dataType byte count")}}return e.push(...r),e.push(...n),e}let ue=class zt{static fromVertexSpec(e,r){const{attributes:n,optionalAttributes:s}=e;let i,a,o;const c=[];for(const m in n){if(n[m].otherSource)continue;const y=n[m];y.pack==="position"?i={...y,name:m,offset:0}:y.pack==="id"?a={...y,name:m,offset:4}:m==="bitset"?o={...y,name:m,offset:7}:c.push({...y,name:m})}for(const m in s)if(r[m]===!0){const y=s[m];c.push({...y,name:m})}const u=ce(c),l=[];let h=8,d=1;for(const m of u)l.push({...m,offset:h}),h+=kt(m.type)*m.count,m.packAlternating&&(d=Math.max(m.packAlternating.count,d));const x=Uint32Array.BYTES_PER_ELEMENT,f=h%x;return new zt(i,a,o,l,h+(f?x-f:0),d)}constructor(e,r,n,s,i,a){this.position=e,this.id=r,this.bitset=n,this.standardAttributes=s,this.stride=i,this.packVertexCount=a,s.push(n),this._attributes=[e,r,n,...s]}get attributeLayout(){if(!this._attributeLayout){const e=$t(this._attributes),r=this._attributes.map(n=>({name:n.name,count:n.count,offset:n.offset,type:n.type,packPrecisionFactor:n.packPrecisionFactor,normalized:n.normalized??!1}));this._attributeLayout={attributes:r,hash:e,stride:this.stride}}return this._attributeLayout}},le=class Gt{static fromVertexSpec(e,r){const n=ue.fromVertexSpec(e,r);return new Gt(n)}constructor(e){this._spec=e,this._packed=new Uint8Array(this._spec.stride*this._spec.packVertexCount),this._packedU32View=new Uint32Array(this._packed.buffer),this._dataView=new DataView(this._packed.buffer)}get attributeLayout(){return this._spec.attributeLayout}get stride(){return this._spec.stride}writeVertex(e,r,n,s,i,a){for(let o=0;o<this._spec.packVertexCount;o++){const c=o*this._spec.stride;this._packPosition(n,s,c),this._packId(r,c);const u=this._spec.bitset;if(a){if(u.packTessellation){const l=u.packTessellation(a,i,n,s);this._pack(l,u,c)}for(const l of this._spec.standardAttributes)if(l.packTessellation!=null){const h=l.packTessellation(a,i,n,s);this._pack(h,l,c)}else if(l.packAlternating?.packTessellation){const h=l.packAlternating.packTessellation(a,i,n,s);for(let d=0;d<this._spec.packVertexCount;d++){const x=h[d];this._pack(x,l,d*this._spec.stride)}}}}e.vertexWriteRegion(this._packedU32View)}pack(e,r){for(const n of this._spec.standardAttributes)if(n.pack&&typeof n.pack!="string"){const s=n.pack(e,r);for(let i=0;i<this._spec.packVertexCount;i++)this._pack(s,n,i*this._spec.stride)}else if(n.packAlternating?.pack){const s=n.packAlternating.pack(e,r);for(let i=0;i<this._spec.packVertexCount;i++){const a=s[i];this._pack(a,n,i*this._spec.stride)}}}_packPosition(e,r,n){const{offset:s}=this._spec.position,i=this._spec.position.packPrecisionFactor??1,a=Qt(e*i,r*i);this._dataView.setUint32(n+s,a,!0)}_packId(e,r){const n=e*(this._spec.id.packPrecisionFactor??1),s=4278190080&this._dataView.getUint32(r+this._spec.id.offset,!0);this._dataView.setUint32(r+this._spec.id.offset,n|s,!0)}_pack(e,r,n){te(this._dataView,e,r,n)}},X=class{constructor(t,e,r,n){this._instanceId=t,this._evaluator=e,this._enabledOptionalAttributes=r,this._viewParams=n,this._evaluator.evaluator=s=>this.vertexSpec.createComputedParams(s)}get _vertexPack(){if(!this._cachedVertexPack){const t=le.fromVertexSpec(this.vertexSpec,this._enabledOptionalAttributes);this._evaluator.hasDynamicProperties||t.pack(this._evaluator.evaluatedMeshParams,this._viewParams),this._cachedVertexPack=t}return this._cachedVertexPack}get evaluatedMeshParams(){return this._evaluator.evaluatedMeshParams}get hasEffects(){return!!this.evaluatedMeshParams.effects}get effectInfos(){return this._evaluator.inputMeshParams.effects?.effectInfos}get instanceId(){return this._instanceId}get attributeLayout(){return this._vertexPack.attributeLayout}get _preventEffectClipping(){return!1}setReferences(t){this._references=t}getBoundsInfo(){return null}getTileInfo(){return this._viewParams.tileInfo}async loadDependencies(){for(const{effect:t}of this.effectInfos||[])await re(t)}enqueueRequest(t,e,r){this._evaluator.hasDynamicProperties&&this._evaluator.enqueueRequest(t,e,r)}write(t,e,r,n,s){this.ensurePacked(e,r,n);const i=this.evaluatedMeshParams.effects;if(!i||i.length===0)return void this._write(t,r,void 0,s);const a=this.getEffectCursor(t,r,i);if(!a)return;let o;for(;o=a.next();)o.invertY(),this._write(t,r,o,s)}ensurePacked(t,e,r){if(!this._evaluator.hasDynamicProperties)return;const n=this._evaluator.evaluateMeshParams(t,e,r);this._vertexPack.pack(n,this._viewParams)}hasArcadeDependency(t){return this._evaluator.hasArcadeDependency(t)}_writeVertex(t,e,r,n,s){const i=this.evaluatedMeshParams;this._vertexPack.writeVertex(t,e,r,n,i,s)}getEffectCursor(t,e,r){const n=e.readGeometryForDisplay()?.clone();if(!n)return;const s=k.fromOptimizedCIM(n,e.geometryType);s.invertY();const i=t.id||"";return bt.executeEffects(r,s,i,this._preventEffectClipping)}};function pe(t,e,r,n,s,i,a){K=0;const o=(n-r)*i,c=s&&s.length,u=c?(s[0]-r)*i:o;let l,h,d,x,f,m=wt(e,r,n,0,u,i,!0);if(m&&m.next!==m.prev){if(c&&(m=de(e,r,n,s,m,i)),o>80*i){l=d=e[0+r*i],h=x=e[1+r*i];for(let y=i;y<u;y+=i){const at=e[y+r*i],ot=e[y+1+r*i];l=Math.min(l,at),h=Math.min(h,ot),d=Math.max(d,at),x=Math.max(x,ot)}f=Math.max(d-l,x-h),f=f!==0?1/f:0}F(m,t,i,l,h,f,a,0)}}function wt(t,e,r,n,s,i,a){let o;if(a===ve(t,e,r,n,s,i)>0)for(let c=n;c<s;c+=i)o=St(c+e*i,t[c+e*i],t[c+1+e*i],o);else for(let c=s-i;c>=n;c-=i)o=St(c+e*i,t[c+e*i],t[c+1+e*i],o);return o&&w(o,o.next)&&(O(o),o=o.next),o}function L(t,e=t){if(!t)return t;let r,n=t;do if(r=!1,n.steiner||!w(n,n.next)&&_(n.prev,n,n.next)!==0)n=n.next;else{if(O(n),n=e=n.prev,n===n.next)break;r=!0}while(r||n!==e);return e}function F(t,e,r,n,s,i,a,o){if(!t)return;!o&&i&&(t=Pt(t,n,s,i));let c=t;for(;t.prev!==t.next;){const u=t.prev,l=t.next;if(i?xe(t,n,s,i):he(t))e.push(u.index/r+a),e.push(t.index/r+a),e.push(l.index/r+a),O(t),t=l.next,c=l.next;else if((t=l)===c){o?o===1?F(t=ke(t,e,r,a),e,r,n,s,i,a,2):o===2&&we(t,e,r,n,s,i,a):F(L(t),e,r,n,s,i,a,1);break}}}function he(t){const e=t.prev,r=t,n=t.next;if(_(e,r,n)>=0)return!1;let s=t.next.next;const i=s;let a=0;for(;s!==t.prev&&(a===0||s!==i);){if(a++,E(e.x,e.y,r.x,r.y,n.x,n.y,s.x,s.y)&&_(s.prev,s,s.next)>=0)return!1;s=s.next}return!0}function xe(t,e,r,n){const s=t.prev,i=t,a=t.next;if(_(s,i,a)>=0)return!1;const o=s.x<i.x?s.x<a.x?s.x:a.x:i.x<a.x?i.x:a.x,c=s.y<i.y?s.y<a.y?s.y:a.y:i.y<a.y?i.y:a.y,u=s.x>i.x?s.x>a.x?s.x:a.x:i.x>a.x?i.x:a.x,l=s.y>i.y?s.y>a.y?s.y:a.y:i.y>a.y?i.y:a.y,h=j(o,c,e,r,n),d=j(u,l,e,r,n);let x=t.prevZ,f=t.nextZ;for(;x&&x.z>=h&&f&&f.z<=d;){if(x!==t.prev&&x!==t.next&&E(s.x,s.y,i.x,i.y,a.x,a.y,x.x,x.y)&&_(x.prev,x,x.next)>=0||(x=x.prevZ,f!==t.prev&&f!==t.next&&E(s.x,s.y,i.x,i.y,a.x,a.y,f.x,f.y)&&_(f.prev,f,f.next)>=0))return!1;f=f.nextZ}for(;x&&x.z>=h;){if(x!==t.prev&&x!==t.next&&E(s.x,s.y,i.x,i.y,a.x,a.y,x.x,x.y)&&_(x.prev,x,x.next)>=0)return!1;x=x.prevZ}for(;f&&f.z<=d;){if(f!==t.prev&&f!==t.next&&E(s.x,s.y,i.x,i.y,a.x,a.y,f.x,f.y)&&_(f.prev,f,f.next)>=0)return!1;f=f.nextZ}return!0}function St(t,e,r,n){const s=M.create(t,e,r);return n?(s.next=n.next,s.prev=n,n.next.prev=s,n.next=s):(s.prev=s,s.next=s),s}function O(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function fe(t){let e=t,r=t;do(e.x<r.x||e.x===r.x&&e.y<r.y)&&(r=e),e=e.next;while(e!==t);return r}function de(t,e,r,n,s,i){const a=new Array;for(let o=0,c=n.length;o<c;o++){const u=wt(t,e,r,n[o]*i,o<c-1?n[o+1]*i:r*i,i,!1);u===u.next&&(u.steiner=!0),a.push(fe(u))}a.sort(be);for(const o of a)s=me(o,s);return s}function me(t,e){const r=ye(t,e);if(!r)return e;const n=Et(r,t);return L(n,n.next),L(r,r.next)}function ye(t,e){let r=e;const n=t.x,s=t.y;let i,a=-1/0;do{if(s<=r.y&&s>=r.next.y&&r.next.y!==r.y){const d=r.x+(s-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(d<=n&&d>a){if(a=d,d===n){if(s===r.y)return r;if(s===r.next.y)return r.next}i=r.x<r.next.x?r:r.next}}r=r.next}while(r!==e);if(!i)return null;if(n===a)return i.prev;const o=i,c=i.x,u=i.y;let l,h=1/0;for(r=i.next;r!==o;)n>=r.x&&r.x>=c&&n!==r.x&&E(s<u?n:a,s,c,u,s<u?a:n,s,r.x,r.y)&&(l=Math.abs(s-r.y)/(n-r.x),(l<h||l===h&&r.x>i.x)&&D(r,t)&&(i=r,h=l)),r=r.next;return i}function Pt(t,e,r,n){let s;for(;s!==t;s=s.next){if(s=s||t,s.z===null&&(s.z=j(s.x,s.y,e,r,n)),s.prev.next!==s||s.next.prev!==s)return s.prev.next=s,s.next.prev=s,Pt(t,e,r,n);s.prevZ=s.prev,s.nextZ=s.next}return t.prevZ.nextZ=null,t.prevZ=null,_e(t)}function _e(t){let e,r=1;for(;;){let n,s=t;t=null,e=null;let i=0;for(;s;){i++,n=s;let a=0;for(;a<r&&n;a++)n=n.nextZ;let o=r;for(;a>0||o>0&&n;){let c;a===0?(c=n,n=n.nextZ,o--):o!==0&&n?s.z<=n.z?(c=s,s=s.nextZ,a--):(c=n,n=n.nextZ,o--):(c=s,s=s.nextZ,a--),e?e.nextZ=c:t=c,c.prevZ=e,e=c}s=n}if(e.nextZ=null,r*=2,i<2)return t}}function _(t,e,r){return(e.y-t.y)*(r.x-e.x)-(e.x-t.x)*(r.y-e.y)}function Tt(t,e,r,n){return!!(w(t,e)&&w(r,n)||w(t,n)&&w(r,e))||_(t,e,r)>0!=_(t,e,n)>0&&_(r,n,t)>0!=_(r,n,e)>0}function ge(t,e){let r=t;do{if(r.index!==t.index&&r.next.index!==t.index&&r.index!==e.index&&r.next.index!==e.index&&Tt(r,r.next,t,e))return!0;r=r.next}while(r!==t);return!1}function ve(t,e,r,n,s,i){let a=0;for(let o=n,c=s-i;o<s;o+=i)a+=(t[c+e*i]-t[o+e*i])*(t[o+1+e*i]+t[c+1+e*i]),c=o;return a}function E(t,e,r,n,s,i,a,o){return(s-a)*(e-o)-(t-a)*(i-o)>=0&&(t-a)*(n-o)-(r-a)*(e-o)>=0&&(r-a)*(i-o)-(s-a)*(n-o)>=0}function D(t,e){return _(t.prev,t,t.next)<0?_(t,e,t.next)>=0&&_(t,t.prev,e)>=0:_(t,e,t.prev)<0||_(t,t.next,e)<0}function j(t,e,r,n,s){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-r)*s)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-n)*s)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function w(t,e){return t.x===e.x&&t.y===e.y}function be(t,e){return t.x-e.x}function ke(t,e,r,n){let s=t;do{const i=s.prev,a=s.next.next;!w(i,a)&&Tt(i,s,s.next,a)&&D(i,a)&&D(a,i)&&(e.push(i.index/r+n),e.push(s.index/r+n),e.push(a.index/r+n),O(s),O(s.next),s=t=a),s=s.next}while(s!==t);return s}function we(t,e,r,n,s,i,a){let o=t;do{let c=o.next.next;for(;c!==o.prev;){if(o.index!==c.index&&Se(o,c)){let u=Et(o,c);return o=L(o,o.next),u=L(u,u.next),F(o,e,r,n,s,i,a,0),void F(u,e,r,n,s,i,a,0)}c=c.next}o=o.next}while(o!==t)}function Se(t,e){return t.next.index!==e.index&&t.prev.index!==e.index&&!ge(t,e)&&D(t,e)&&D(e,t)&&Pe(t,e)}function Pe(t,e){let r=t,n=!1;const s=(t.x+e.x)/2,i=(t.y+e.y)/2;do r.y>i!=r.next.y>i&&r.next.y!==r.y&&s<(r.next.x-r.x)*(i-r.y)/(r.next.y-r.y)+r.x&&(n=!n),r=r.next;while(r!==t);return n}function Et(t,e){const r=M.create(t.index,t.x,t.y),n=M.create(e.index,e.x,e.y),s=t.next,i=e.prev;return t.next=e,e.prev=t,r.next=s,s.prev=r,n.next=r,r.prev=n,i.next=n,n.prev=i,n}class M{constructor(){this.index=0,this.x=0,this.y=0,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}static create(e,r,n){const s=K<J.length?J[K++]:new M;return s.index=e,s.x=r,s.y=n,s.prev=null,s.next=null,s.z=null,s.prevZ=null,s.nextZ=null,s.steiner=!1,s}}const J=[],Te=8096;let K=0;for(let t=0;t<Te;t++)J.push(new M);const Ee=1e-5,S=new ut(0,0,0,1,0),$=new ut(0,0,0,1,0);function Mt(t,e,r){let n=0;for(let s=1;s<r;s++){const i=t[2*(e+s-1)],a=t[2*(e+s-1)+1];n+=(t[2*(e+s)]-i)*(t[2*(e+s)+1]+a)}return n}function Me(t,e,r,n,s){let i=0;const a=2;for(let o=r;o<n;o+=3){const c=(t[o]-s)*a,u=(t[o+1]-s)*a,l=(t[o+2]-s)*a;i+=Math.abs((e[c]-e[l])*(e[u+1]-e[c+1])-(e[c]-e[u])*(e[l+1]-e[c+1]))}return i}function At(t,e){const{coords:r,lengths:n}=e,s=0,i=t;let a=0;for(let o=0;o<n.length;){let c=o,u=n[o],l=Mt(r,a,u);const h=[];for(;++c<n.length;){const m=n[c],y=Mt(r,a+u,m);if(!(y>0))break;l+=y,h.push(a+u),u+=m}const d=i.length;pe(i,r,a,a+u,h,2,s);const x=Me(i,r,d,i.length,s),f=Math.abs(l);if(Math.abs((x-f)/Math.max(1e-7,f))>Ee)return i.length=0,!1;o=c,a+=u}return!0}function Ae(t){const{coords:e,lengths:r}=t,{buffer:n}=jt(e,r);return n}function Le(t,e,r){let n=0;for(let s=0;s<t.lengths.length;s++){const i=t.lengths[s];for(let a=0;a<i;a++){const o=t.coords[2*(a+n)],c=t.coords[2*(a+n)+1];if(o<e||o>r||c<e||c>r)return!0}n+=i}return!1}function Q(t,e){if(t==null)return null;if(!Le(t,-128,G+128))return t;S.setPixelMargin(e),S.reset(3);let r=0;for(let a=0;a<t.lengths.length;a++){const o=t.lengths[a];let c=t.coords[2*(0+r)],u=t.coords[2*(0+r)+1];S.moveTo(c,u);for(let l=1;l<o;l++)c=t.coords[2*(l+r)],u=t.coords[2*(l+r)+1],S.lineTo(c,u);S.close(),r+=o}const n=S.result(!1);if(!n)return null;const s=[],i=[];for(const a of n){let o=0;for(const c of a)i.push(c.x),i.push(c.y),o++;s.push(o)}return new ee(s,i)}function Lt(t,e){$.setPixelMargin(e);const r=$,n=-e,s=G+e;let i=[],a=!1;if(!t.nextPath())return null;let o=t.pathLength(),c=!0;for(;c;){t.seekPathStart();const u=[];if(!t.pathSize)return null;r.reset(2),t.nextPoint();let l=t.x,h=t.y;if(a)r.moveTo(l,h);else{if(l<n||l>s||h<n||h>s){a=!0;continue}u.push({x:l,y:h})}let d=!1;for(;t.nextPoint();)if(l=t.x,h=t.y,a)r.lineTo(l,h);else{if(l<n||l>s||h<n||h>s){d=!0;break}u.push({x:l,y:h})}if(d)a=!0;else{if(a){const x=r.resultWithStarts();if(x)for(const f of x)i.push({...f,pathLength:o})}else i.push({line:u,start:0,pathLength:o});c=t.nextPath(),o=c?t.pathLength():0,a=!1}}return i=i.filter(u=>u.line.length>1),i.length===0?null:i}S.setExtent(G),$.setExtent(G);let Ft=class{constructor(){this.extrusionOffsetX=0,this.extrusionOffsetY=0,this.normalX=0,this.normalY=0,this.directionX=0,this.directionY=0,this.distance=0,this.pathLength=0,this.distanceOffset=0,this.lineLength=0}};const v={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:p.SHORT,count:2,packPrecisionFactor:xt,pack:({scaleInfo:t},{tileInfo:e})=>q(t,e)}},attributes:{id:{type:p.UNSIGNED_BYTE,count:3,pack:"id"},pos:{type:p.SHORT,count:2,pack:"position",packPrecisionFactor:10},bitset:{type:p.UNSIGNED_BYTE,count:1},color:{type:p.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>A(t)},offset:{type:p.BYTE,count:2,packPrecisionFactor:16,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e})=>[R(t,16),R(e,16)]},normal:{type:p.BYTE,count:2,packPrecisionFactor:16,packTessellation:({normalX:t,normalY:e})=>[R(t,16),R(e,16)]},halfWidth:{type:p.HALF_FLOAT,count:1,pack:({width:t})=>g(.5*t)},referenceHalfWidth:{type:p.HALF_FLOAT,count:1,pack:({referenceWidth:t})=>g(.5*t)}}};class Fe{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0,this.distanceOffset=0}}const Y=65535;class B extends X{constructor(e,r,n,s){super(e,r,n,s),this.vertexSpec=v,this._currentWrite=new Fe,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:Y,textured:!1},this._tessParams=new Ft,this._initializeTessellator()}writeLineVertices(e,r,n){const s=this._getLines(r);s!=null&&this._writeVertices(e,n,s)}_initializeTessellator(){this._lineTessellator=new Jt(this._writeTesselatedVertex.bind(this),this._writeTriangle.bind(this),!0)}_write(e,r,n){const s=n??k.fromFeatureSetReaderCIM(r);s&&this._writeGeometry(e,r,s)}_writeGeometry(e,r,n,s){e.recordStart(this.instanceId,this.attributeLayout,s),this.writeLineVertices(e,n,r),e.recordEnd()}_getLines(e){return Lt(e,dt(this.evaluatedMeshParams))}_writeVertices(e,r,n){const{_currentWrite:s,_tessellationOptions:i,evaluatedMeshParams:a}=this,{width:o,capType:c,joinType:u,miterLimit:l,hasSizeVV:h}=a,d=g(.5*o);i.halfWidth=d,i.capType=gt(c),i.joinType=vt(u),i.miterLimit=l;const x=!h;s.out=e,s.id=r.getDisplayId(),s.vertexCount=0,s.indexCount=0,s.vertexFrom=e.vertexCount(),s.vertexBounds=x&&d<Xt?0:1;for(const{line:f,start:m,pathLength:y}of n)i.initialDistance=m%Y,s.pathLength=y,s.distanceOffset=Math.floor(m/Y)*Y,this._lineTessellator.tessellate(f,i,x)}_writeTesselatedVertex(e,r,n,s,i,a,o,c,u,l,h){const{out:d,id:x,vertexBounds:f,pathLength:m,distanceOffset:y}=this._currentWrite;return this.hasEffects&&d.recordBounds(e,r,f,f),this._tessParams.extrusionOffsetX=o,this._tessParams.extrusionOffsetY=c,this._tessParams.normalX=u,this._tessParams.normalY=l,this._tessParams.directionX=i,this._tessParams.directionY=a,this._tessParams.distance=h,this._tessParams.pathLength=m,this._tessParams.distanceOffset=y,this._writeVertex(d,x,e,r,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(e,r,n){const{out:s}=this._currentWrite;s.indexEnsureSize(3),s.indexWrite(e),s.indexWrite(r),s.indexWrite(n),this._currentWrite.indexCount+=3}}const Oe=100,De=Bt("featurelayer-fast-triangulation-enabled");let tt=class extends X{async loadDependencies(){await Promise.all([super.loadDependencies(),Kt()])}_write(t,e,r){const n=r?.asOptimized()??e.readGeometryForDisplay(),s=this._clip(n);s&&(t.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(t,e,s),t.recordEnd())}_clip(t){if(!t)return null;const e=this.hasEffects;return Q(t,e?256:8)}_writeGeometry(t,e,r){const n=r.maxLength>Oe,s=[],i=this.createTesselationParams(e);if(!n&&De&&At(s,r))return void(s.length&&this._writeVertices(t,e,r.coords,i,s));const a=Ae(r);this._writeVertices(t,e,a,i)}_writeVertices(t,e,r,n,s){const i=e.getDisplayId(),a=t.vertexCount(),o=this.hasEffects;let c=0;if(s)for(const u of s){const l=r[2*u],h=r[2*u+1];o&&t.recordBounds(l,h,0,0),this._writeVertex(t,i,l,h,n),c++}else for(let u=0;u<r.length;u+=2){const l=Math.round(r[u]),h=Math.round(r[u+1]);o&&t.recordBounds(l,h,0,0),this._writeVertex(t,i,l,h,n),c++}t.indexEnsureSize(c);for(let u=0;u<c;u++)t.indexWrite(u+a)}};const I={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:p.SHORT,count:2,packPrecisionFactor:xt,pack:({scaleInfo:t},{tileInfo:e})=>q(t,e)}},attributes:{id:{type:p.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:p.UNSIGNED_BYTE,count:1},pos:{type:p.SHORT,count:2,pack:"position",packPrecisionFactor:10},color:{type:p.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>A(t)}}};let et=class extends tt{constructor(){super(...arguments),this.vertexSpec=I}createTesselationParams(t){return null}};const P={createComputedParams:t=>t,optionalAttributes:I.optionalAttributes,attributes:{...I.attributes,tlbr:{count:4,type:p.UNSIGNED_SHORT,pack:({sprite:t})=>{const{rect:e,width:r,height:n}=t,s=e.x+b,i=e.y+b;return[s,i,s+r,i+n]}},inverseRasterizationScale:{count:1,type:p.BYTE,packPrecisionFactor:16,pack:({sprite:t})=>1/t.rasterizationScale}}};let Ot=class extends et{constructor(){super(...arguments),this.vertexSpec=P}_write(t,e,r){const n=r?.asOptimized()??e.readGeometryForDisplay(),s=this._clip(n);if(!s)return;const i=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,i),this._writeGeometry(t,e,s),t.recordEnd()}};function U(t){const{sprite:e,aspectRatio:r,scaleProportionally:n}=t,s=g(t.height),i=s>0?s:e.height;let a=s*r;return a<=0?a=e.width:n&&(a*=e.width/e.height),{width:a,height:i}}function Dt(t){const{applyRandomOffset:e,sampleAlphaOnly:r}=t;return T([[Wt,e],[lt,r]])}const It={createComputedParams:t=>t,optionalAttributes:P.optionalAttributes,attributes:{...P.attributes,bitset:{count:1,type:p.UNSIGNED_BYTE,pack:Dt},width:{count:1,type:p.HALF_FLOAT,pack:t=>U(t).width},height:{count:1,type:p.HALF_FLOAT,pack:t=>U(t).height},offset:{count:2,type:p.HALF_FLOAT,pack:({offsetX:t,offsetY:e})=>[g(t),-g(e)]},scale:{count:2,type:p.UNSIGNED_BYTE,packPrecisionFactor:16,pack:({scaleX:t,scaleY:e})=>[t,e]},angle:{count:1,type:p.UNSIGNED_BYTE,pack:({angle:t})=>Vt(t)}}};let Ie=class extends Ot{constructor(){super(...arguments),this.vertexSpec=It}};const Nt={createComputedParams:t=>t,optionalAttributes:v.optionalAttributes,attributes:{...v.attributes,bitset:{type:p.UNSIGNED_BYTE,count:1,pack:t=>0},color:{type:p.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>A(t)}}},rt={createComputedParams:t=>t,optionalAttributes:v.optionalAttributes,attributes:{...v.attributes,bitset:{type:p.UNSIGNED_BYTE,count:1,pack:t=>T([[pt,!0],[Zt,t.outlineUsesColorVV]])},color:{type:p.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>A(t)}}};let st=class extends B{constructor(){super(...arguments),this.vertexSpec=rt}},nt=class extends et{constructor(t,e,r,n){super(t,e,r,n),this.vertexSpec=Nt,this._lineMeshWriter=this._createOutlineWriter(t,e,r,n)}_createOutlineWriter(t,e,r,n){return new st(t,e,r,n)}_write(t,e){const r=this.evaluatedMeshParams.effects,n=this.evaluatedMeshParams.outlineEffects;if(r?.length||n?.length){if(r?.length){const s=this.getEffectCursor(t,e,r);if(s){let i;for(;i=s?.next();)i.invertY(),this._writeFill(t,e,i)}}else this._writeFill(t,e);if(n?.length){const s=this.getEffectCursor(t,e,n);if(s){let i;for(;i=s?.next();)i.invertY(),this._writeOutline(t,e,i)}}else this._writeOutline(t,e)}else this._writeSimpleOutlineFill(t,e)}_writeSimpleOutlineFill(t,e){const r=e.readGeometryForDisplay(),n=this._clip(r);n&&(this._writeGeometry(t,e,n),this._lineMeshWriter.writeLineVertices(t,k.fromOptimizedCIM(n,"esriGeometryPolyline"),e))}_writeFill(t,e,r){const n=r?.asOptimized()??e.readGeometryForDisplay(),s=this._clip(n);s&&this._writeGeometry(t,e,s)}_writeOutline(t,e,r){const n=r?.asOptimized()??e.readGeometryForDisplay(),s=this._clip(n);s&&this._lineMeshWriter.writeLineVertices(t,k.fromOptimizedCIM(s,"esriGeometryPolyline"),e)}_clip(t){return t?Q(t,dt(this.evaluatedMeshParams)):null}get effectInfos(){return[...this._evaluator.inputMeshParams.effects?.effectInfos??[],...this._evaluator.inputMeshParams.outlineEffects?.effectInfos??[]]}write(t,e,r,n,s){this.ensurePacked(e,r,n),t.recordStart(this.instanceId,this.attributeLayout),this._write(t,r),t.recordEnd()}ensurePacked(t,e,r){super.ensurePacked(t,e,r),this._lineMeshWriter.ensurePacked(t,e,r)}enqueueRequest(t,e,r){super.enqueueRequest(t,e,r),this._lineMeshWriter.enqueueRequest(t,e,r)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}get hasEffects(){return!!this.evaluatedMeshParams.outlineEffects}};const V=It,Ne=rt,ze={createComputedParams:t=>t,optionalAttributes:V.optionalAttributes,attributes:{...V.attributes,bitset:{type:p.UNSIGNED_BYTE,count:1,pack:t=>Dt(t)},aux1:{count:1,type:p.HALF_FLOAT,pack:t=>U(t).width},aux2:{count:1,type:p.HALF_FLOAT,pack:t=>U(t).height},aux3:{count:2,type:p.HALF_FLOAT,pack:({offsetX:t,offsetY:e})=>[g(t),g(e)]},aux4:{count:2,type:p.UNSIGNED_BYTE,pack:({scaleX:t,scaleY:e})=>[t*N,e*N]}}},Ge={createComputedParams:t=>t,optionalAttributes:V.optionalAttributes,attributes:{...V.attributes,color:Ne.attributes.color,bitset:{type:p.UNSIGNED_BYTE,count:1,pack:t=>T([[pt,!0]])},aux1:{count:1,type:p.HALF_FLOAT,pack:t=>g(.5*t.width)},aux2:{count:1,type:p.HALF_FLOAT,pack:t=>g(.5*t.referenceWidth)},aux3:{count:2,type:p.HALF_FLOAT,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e})=>[t,e]},aux4:{count:2,type:p.UNSIGNED_BYTE,packTessellation:({normalX:t,normalY:e})=>[t*N+ht,e*N+ht]}}};class Ce extends st{constructor(){super(...arguments),this.vertexSpec=Ge}}class Re extends nt{constructor(){super(...arguments),this.vertexSpec=ze}_createOutlineWriter(e,r,n,s){return new Ce(e,r,n,s)}write(e,r,n,s,i){this.ensurePacked(r,n,s);const a=this.evaluatedMeshParams.sprite?.textureBinding;e.recordStart(this.instanceId,this.attributeLayout,a),this._write(e,n),e.recordEnd()}ensurePacked(e,r,n){super.ensurePacked(e,r,n),this._lineMeshWriter.ensurePacked(e,r,n)}enqueueRequest(e,r,n){super.enqueueRequest(e,r,n),this._lineMeshWriter.enqueueRequest(e,r,n)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const Ye=()=>ct.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.fill.GradientSizeHelper");let Be=class{constructor(t,e){this._size=t,this._sizeUnits=e,this._relativeSize=null}get relativeSize(){return this._relativeSize??=this.calculateRelativeSize(),this._relativeSize}calculateRelativeSize(){if(this._sizeUnits===z.Relative){const t=Math.min(this._size/100,1);return[t,t]}return this.calculateRelativeSizeFromAbsolute()}};class it extends Be{constructor(e,r,n,s){super(r,n),this.rotationMatrix00=1,this.rotationMatrix01=0,this.rotationMatrix10=0,this.rotationMatrix11=1,this.bounds={xmin:1/0,ymin:1/0,xmax:-1/0,ymax:-1/0},this.rotationMatrix00=Math.cos(s),this.rotationMatrix01=-Math.sin(s),this.rotationMatrix10=-this.rotationMatrix01,this.rotationMatrix11=this.rotationMatrix00;const{bounds:i,rotationMatrix00:a,rotationMatrix01:o,rotationMatrix10:c,rotationMatrix11:u}=this;e.forEachVertex((l,h)=>{const d=l*a+h*o,x=l*c+h*u;i.xmin=Math.min(i.xmin,d),i.ymin=Math.min(i.ymin,x),i.xmax=Math.max(i.xmax,d),i.ymax=Math.max(i.ymax,x)}),this.center=[(i.xmin+i.xmax)/2,(i.ymin+i.ymax)/2]}}let Ue=class extends it{constructor(t,e,r,n){super(t,e,r,n),this.method="linear"}getRelativePosition(t,e){const{rotationMatrix00:r,rotationMatrix01:n,bounds:s}=this,{xmin:i,xmax:a}=s;return[(t*r+e*n-i)/(a-i),0]}calculateRelativeSizeFromAbsolute(){const{_size:t,bounds:e}=this,{xmin:r,xmax:n}=e;return[g(t)/(n-r),0]}};class Ve extends it{constructor(e,r,n,s){super(e,r,n,s),this.method="rectangular"}getRelativePosition(e,r){const{bounds:n,center:s,rotationMatrix00:i,rotationMatrix01:a,rotationMatrix10:o,rotationMatrix11:c}=this,u=e*o+r*c,l=e*i+r*a-s[0],h=u-s[1];return[l*(2/(n.xmax-n.xmin)),-h*(2/(n.ymax-n.ymin))]}calculateRelativeSizeFromAbsolute(){const{_size:e,bounds:r}=this,{xmin:n,ymin:s,xmax:i,ymax:a}=r;return[g(2*e)/(i-n),g(2*e)/(a-s)]}}class We extends it{constructor(e,r,n){super(e,r,n,0),this.method="circular";const{xmin:s,xmax:i,ymin:a,ymax:o}=this.bounds,c=i-s,u=o-a;this.radius=Math.sqrt(c*c+u*u)/2}getRelativePosition(e,r){const{center:n,radius:s}=this;return[(e-n[0])/s,-((r-n[1])/s)]}calculateRelativeSizeFromAbsolute(){const{_size:e}=this;return[g(e)/this.radius,0]}}function Ze(t,e){if(t==null)return null;const r=Ut(e.angle),n=e.gradientSize,s=e.gradientSizeUnits;switch(e.gradientMethod.toLowerCase()){case"linear":return new Ue(t,n,s,r);case"rectangular":return new Ve(t,n,s,r);case"circular":return new We(t,n,s);default:return Ye().errorOnce(`Gradient fill method "${e.gradientMethod}" currently unsupported.`),null}}const qe={createComputedParams:t=>t,optionalAttributes:I.optionalAttributes,attributes:{...I.attributes,bitset:{type:p.UNSIGNED_BYTE,count:1,pack:({gradientSizeUnits:t,gradientType:e})=>{let r=0;return t===z.Absolute&&(r|=H(ft.isAbsolute)),e.toLowerCase()==="discrete"&&(r|=H(ft.isDiscrete)),r}},tlbr:{count:4,type:p.UNSIGNED_SHORT,pack:({sprite:t})=>{const{rect:e,width:r,height:n}=t,s=e.x+b+C,i=e.y+b;return[s,i,s+r-2*C,i+n]}},relativePosition:{count:2,type:p.HALF_FLOAT,packTessellation:({gradientStats:t},e,r,n)=>t?.getRelativePosition(r,n)??[0,0]},relativeGradientSize:{count:2,type:p.HALF_FLOAT,packTessellation:({gradientStats:t})=>t?.relativeSize??[1,1]},gradientMethod:{count:1,type:p.UNSIGNED_BYTE,pack:({gradientMethod:t})=>{switch(t.toLowerCase()){case"rectangular":return W.rectangular;case"circular":return W.circular;default:return W.linear}}}}};let He=class extends tt{constructor(){super(...arguments),this.vertexSpec=qe}get _preventEffectClipping(){return!0}createTesselationParams(t){return{gradientStats:Ze(this._unclippedGeometry,this.evaluatedMeshParams)}}_write(t,e,r){const n=r?.asOptimized()??e.readGeometryForDisplay();this._unclippedGeometry=n;const s=this._clip(n);if(!s)return void(this._unclippedGeometry=null);const i=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,i),this._writeGeometry(t,e,s),this._unclippedGeometry=null,t.recordEnd()}};const Xe={optionalAttributes:P.optionalAttributes,createComputedParams:t=>t,attributes:{...P.attributes,...Nt.attributes}},je={optionalAttributes:P.optionalAttributes,createComputedParams:t=>t,attributes:{...P.attributes,...rt.attributes}};class Je extends st{constructor(){super(...arguments),this.vertexSpec=je}}class Ke extends nt{constructor(){super(...arguments),this.vertexSpec=Xe}_createOutlineWriter(e,r,n,s){return new Je(e,r,n,s)}write(e,r,n,s,i){this.ensurePacked(r,n,s);const a=this.evaluatedMeshParams.sprite?.textureBinding;e.recordStart(this.instanceId,this.attributeLayout,a),this._write(e,n),e.recordEnd()}ensurePacked(e,r,n){super.ensurePacked(e,r,n),this._lineMeshWriter.ensurePacked(e,r,n)}enqueueRequest(e,r,n){super.enqueueRequest(e,r,n),this._lineMeshWriter.enqueueRequest(e,r,n)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const $e={createComputedParams:t=>t,optionalAttributes:v.optionalAttributes,attributes:{...v.attributes,bitset:{type:p.UNSIGNED_BYTE,count:1,pack:({gradientMethod:t,gradientSizeUnits:e,gradientType:r})=>T([[Z.isAlongLine,t.toLowerCase()==="alongline"],[Z.isAbsoluteSize,e===z.Absolute],[Z.isDiscrete,r.toLowerCase()==="discrete"]])},tlbr:{type:p.UNSIGNED_SHORT,count:4,pack:({sprite:t})=>{const{rect:e,width:r,height:n}=t,s=e.x+b+C,i=e.y+b;return[s,i,s+r-2*C,i+n]}},accumulatedDistance:{type:p.HALF_FLOAT,count:1,packTessellation:({distance:t,pathLength:e,distanceOffset:r})=>(r+t)/e},gradientSize:{type:p.HALF_FLOAT,count:1,pack:({gradientSize:t,gradientSizeUnits:e})=>e===z.Relative?t/100:g(t)},totalLength:{type:p.HALF_FLOAT,count:1,packTessellation:({pathLength:t})=>t},segmentDirection:{type:p.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:t,directionY:e})=>[t,e]}}};let Qe=class extends B{get _preventEffectClipping(){return!0}constructor(t,e,r,n){super(t,e,r,n),this.vertexSpec=$e,this._tessellationOptions.textured=!0}_write(t,e,r){const n=r??k.fromFeatureSetReaderCIM(e);if(!n)return;const{sprite:s}=this.evaluatedMeshParams;this._writeGeometry(t,e,n,s?.textureBinding)}};const tr={createComputedParams:t=>t,optionalAttributes:v.optionalAttributes,attributes:{...v.attributes,bitset:{type:p.UNSIGNED_BYTE,count:1,pack:({shouldSampleAlphaOnly:t,shouldScaleDash:e,isSDF:r})=>T([[lt,t],[qt,e],[Ht,r]])},tlbr:{type:p.UNSIGNED_SHORT,count:4,pack:({sprite:t})=>{const{rect:e,width:r,height:n}=t,s=e.x+b,i=e.y+b;return[s,i,s+r,i+n]}},accumulatedDistance:{type:p.UNSIGNED_SHORT,count:1,packTessellation:({distance:t})=>t},segmentDirection:{type:p.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:t,directionY:e})=>[t,e]},offsetAlongLine:{type:p.HALF_FLOAT,count:1,pack:({offsetAlongLine:t})=>g(t)},capType:{type:p.UNSIGNED_BYTE,count:1,pack:({capType:t})=>{switch(t){case"Butt":case"butt":default:return 0;case"Square":case"square":return 1;case"Round":case"round":return 2}}}}};class er extends B{constructor(e,r,n,s){super(e,r,n,s),this.vertexSpec=tr,this._tessellationOptions.textured=!0}_write(e,r,n){const s=n??k.fromFeatureSetReaderCIM(r);if(!s)return;const{sprite:i}=this.evaluatedMeshParams;this._writeGeometry(e,r,s,i?.textureBinding)}}export{B as T,X as a,tt as b,A as c,Ft as d,Qe as e,gt as f,Q as g,At as h,H as i,er as j,Re as k,ae as l,vt as m,nt as n,Ke as o,Lt as p,He as q,Ot as r,q as s,Ie as t,T as u,et as v,bt as w};
