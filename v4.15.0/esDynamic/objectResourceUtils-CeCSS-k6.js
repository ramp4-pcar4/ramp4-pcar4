import{ep as D,cR as z,hW as W,cX as H,H as me,j as N,i as fe,gy as Q,j4 as j,s as de,cY as pe,az as q,dY as he,jj as G,gn as ge,go as Y,gp as xe}from"./main-pOgmbpmS.js";import{a as ye}from"./devEnvironmentUtils-CxrVv3RG.js";import{h as be}from"./mat4-BBA0NsiW.js";import{a as Te}from"./vec2f64-CkowXrDb.js";import{E as K,c as we,i as X,r as ve,A as Me,I as Re}from"./vec32-DlcWpOx5.js";import{m as J,n as _}from"./OutputColorHighlightOID.glsl-CzaQ5Ix1.js";import{o as Z,T as ee,g as Ae,M as Be,O as Se,V as Pe}from"./BufferView-BSD7Eom9.js";import{r as Ie,n as Ee,d as te,l as re}from"./vec3-BP44X_jx.js";import{o as Oe,d as se}from"./vec4-BoN5zIAV.js";import{l as Ce,o as Fe,n as Ue}from"./indexUtils-iGy7hXls.js";import{t as k}from"./resourceUtils-CNMochq7.js";import{a as je,i as _e}from"./vec2f32-hTAvipMV.js";import{_ as oe}from"./asyncUtils-CwlZsPSF.js";import{u as ke}from"./memoryEstimations-BqgYRRhe.js";import{t as Le}from"./NestedMap-BCg8I1M1.js";import{r as ne}from"./Version-Cp5Iylik.js";import{A as Ve}from"./Indices-Bo2M9TZR.js";import{t as $e}from"./requestImageUtils-DRw8o-h_.js";import{t as E}from"./orientedBoundingBox-BLuzKGdA.js";import{M as ae}from"./Texture-DmBlAZkh.js";import{P as L,n as De,o as qe,s as Ge,t as ze}from"./DefaultMaterial-DK0peuQK.js";function O(r){if(r==null)return null;const t=r.offset!=null?r.offset:je,o=r.rotation!=null?r.rotation:0,s=r.scale!=null?r.scale:_e,u=D(1,0,0,0,1,0,t[0],t[1],1),i=D(Math.cos(o),-Math.sin(o),0,Math.sin(o),Math.cos(o),0,0,0,1),n=D(s[0],0,0,0,s[1],0,0,0,1),a=z();return W(a,i,n),W(a,u,a),a}class We{constructor(){this.geometries=new Array,this.materials=new Array,this.textures=new Array}}class He{constructor(t,o,s){this.name=t,this.lodThreshold=o,this.pivotOffset=s,this.stageResources=new We,this.numberOfVertices=0}}const B=()=>fe.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");class Ne{constructor(t,o,s){this.resource=t,this.textures=o,this.usedMemory=s}}async function Qe(r,t){const o=await Ye(r,t),s=await et(o.textureDefinitions??{},t);let u=0;for(const i in s)if(s.hasOwnProperty(i)){const n=s[i];u+=n?.image?n.image.width*n.image.height*4:0}return new Ne(o,s,u+ke(o))}async function Ye(r,t){const o=t?.streamDataRequester;if(o)return Ke(r,o,t);const s=await oe(me(r,t));if(s.ok===!0)return s.value.data;N(s.error),ie(s.error)}async function Ke(r,t,o){const s=await oe(t.request(r,0,o));if(s.ok===!0)return s.value;N(s.error),ie(s.error.details.url)}function ie(r){throw new de("",`Request for object resource failed: ${r}`)}function Xe(r){const t=r.params,o=t.topology;let s=!0;switch(t.vertexAttributes||(B().warn("Geometry must specify vertex attributes"),s=!1),t.topology){case"PerAttributeArray":break;case"Indexed":case null:case void 0:{const i=t.faces;if(i){if(t.vertexAttributes)for(const n in t.vertexAttributes){const a=i[n];a?.values?(a.valueType!=null&&a.valueType!=="UInt32"&&(B().warn(`Unsupported indexed geometry indices type '${a.valueType}', only UInt32 is currently supported`),s=!1),a.valuesPerElement!=null&&a.valuesPerElement!==1&&(B().warn(`Unsupported indexed geometry values per element '${a.valuesPerElement}', only 1 is currently supported`),s=!1)):(B().warn(`Indexed geometry does not specify face indices for '${n}' attribute`),s=!1)}}else B().warn("Indexed geometries must specify faces"),s=!1;break}default:B().warn(`Unsupported topology '${o}'`),s=!1}r.params.material||(B().warn("Geometry requires material"),s=!1);const u=r.params.vertexAttributes;for(const i in u)u[i].values||(B().warn("Geometries with externally defined attributes are not yet supported"),s=!1);return s}function Je(r,t){const o=new Array,s=new Array,u=new Array,i=new Le,n=r.resource,a=ne.parse(n.version||"1.0","wosr");rt.validate(a);const m=n.model.name,e=n.model.geometries,l=n.materialDefinitions??{},c=r.textures;let g=0;const d=new Map;for(let x=0;x<e.length;x++){const f=e[x];if(!Xe(f))continue;const w=tt(f),b=f.params.vertexAttributes,v=[],y=p=>{if(f.params.topology==="PerAttributeArray")return null;const T=f.params.faces;for(const h in T)if(h===p)return T[h].values;return null},M=b.position,U=M.values.length/M.valuesPerElement;for(const p in b){const T=b[p],h=T.values,$=y(p)??Ve(U);v.push([p,new E(h,$,T.valuesPerElement,!0)])}const R=w.texture,S=c&&c[R];if(S&&!d.has(R)){const{image:p,parameters:T}=S,h=new ae(p,T);s.push(h),d.set(R,h)}const F=d.get(R),P=F?F.id:void 0,I=w.material;let A=i.get(I,R);if(A==null){const p=l[I.slice(I.lastIndexOf("/")+1)].params;p.transparency===1&&(p.transparency=0);const T=S?le(S.alphaChannelUsage):void 0,h={ambient:H(p.diffuse),diffuse:H(p.diffuse),opacity:1-(p.transparency||0),textureAlphaMode:T,textureAlphaCutoff:.33,textureId:P,doubleSided:!0,cullFace:0,colorMixMode:p.externalColorMixMode||"tint",textureAlphaPremultiplied:S?.parameters.preMultiplyAlpha??!1};t?.materialParameters&&Object.assign(h,t.materialParameters),A=new L(h,t),i.set(I,R,A)}u.push(A);const V=new J(A,v);g+=v.find(p=>p[0]==="position")?.[1]?.indices.length??0,o.push(V)}return{engineResources:[{name:m,stageResources:{textures:s,materials:u,geometries:o},pivotOffset:n.model.pivotOffset,numberOfVertices:g,lodThreshold:null}],referenceBoundingBox:Ze(o)}}function Ze(r){const t=Q();return r.forEach(o=>{const s=o.boundingInfo;s!=null&&(j(t,s.bbMin),j(t,s.bbMax))}),t}async function et(r,t){const o=new Array;for(const i in r){const n=r[i],a=n.images[0].data;if(!a){B().warn("Externally referenced texture data is not yet supported");continue}const m=n.encoding+";base64,"+a,e="/textureDefinitions/"+i,l=n.channels==="rgba"?n.alphaChannelUsage||"transparency":"none",c={noUnpackFlip:!0,wrap:{s:10497,t:10497},preMultiplyAlpha:le(l)!==1},g=t?.disableTextures?Promise.resolve(null):$e(m,t);o.push(g.then(d=>({refId:e,image:d,parameters:c,alphaChannelUsage:l})))}const s=await Promise.all(o),u={};for(const i of s)u[i.refId]=i;return u}function le(r){switch(r){case"mask":return 2;case"maskAndTransparency":return 3;case"none":return 1;default:return 0}}function tt(r){const t=r.params;return{id:1,material:t.material,texture:t.texture,region:t.texture}}const rt=new ne(1,2,"wosr");async function ue(r,t){const o=ce(ye(r));if(o.fileType==="wosr"){const c=await(t.cache?t.cache.loadWOSR(o.url,t):Qe(o.url,t)),{engineResources:g,referenceBoundingBox:d}=Je(c,t);return{lods:g,referenceBoundingBox:d,isEsriSymbolResource:!1,isWosr:!0}}let s;if(t.cache)s=await t.cache.loadGLTF(o.url,t,!!t.usePBR);else{const{loadGLTF:c}=await import("./loader-BkseZnE7.js");s=await c(new Ce(t.streamDataRequester),o.url,t,t.usePBR)}const u=s.model.meta?.ESRI_proxyEllipsoid,i=s.meta.isEsriSymbolResource&&u!=null&&s.meta.ESRI_webstyle==="EsriRealisticTreesStyle";i&&!s.customMeta.esriTreeRendering&&(s.customMeta.esriTreeRendering=!0,it(s,u));const n=!!t.usePBR,a=s.meta.isEsriSymbolResource?{usePBR:n,isSchematic:!1,treeRendering:i,mrrFactors:Ge}:{usePBR:n,isSchematic:!1,treeRendering:!1,mrrFactors:ze},m={...t.materialParameters,treeRendering:i},{engineResources:e,referenceBoundingBox:l}=st(s,a,m,t,o.specifiedLodIndex,i);return{lods:e,referenceBoundingBox:l,isEsriSymbolResource:s.meta.isEsriSymbolResource,isWosr:!1}}function ce(r){const t=r.match(/(.*\.(gltf|glb))(\?lod=([0-9]+))?$/);return t?{fileType:"gltf",url:t[1],specifiedLodIndex:t[4]!=null?Number(t[4]):null}:r.match(/(.*\.(json|json\.gz))$/)?{fileType:"wosr",url:r,specifiedLodIndex:null}:{fileType:"unknown",url:r,specifiedLodIndex:null}}function st(r,t,o,s,u,i){const n=r.model,a=new Array,m=new Map,e=new Map,l=n.lods.length,c=Q();return n.lods.forEach((g,d)=>{const x=s.skipHighLods===!0&&(l>1&&d===0||l>3&&d===1)||s.skipHighLods===!1&&u!=null&&d!==u;if(x&&d!==0)return;const f=new He(g.name,g.lodThreshold,[0,0,0]);g.parts.forEach(w=>{const b=x?new L({},s):ot(n,w,f,t,o,m,e,s,i),{geometry:v,vertexCount:y}=nt(w,b??new L({},s)),M=v.boundingInfo;M!=null&&d===0&&(j(c,M.bbMin),j(c,M.bbMax)),b!=null&&(f.stageResources.geometries.push(v),f.numberOfVertices+=y)}),x||a.push(f)}),{engineResources:a,referenceBoundingBox:c}}function ot(r,t,o,s,u,i,n,a,m){const e=r.materials.get(t.material);if(e==null)return null;const{normal:l,color:c,texCoord0:g,tangent:d}=t.attributes,x=t.material+(l?"_normal":"")+(c?"_color":"")+(g?"_texCoord0":"")+(d?"_tangent":""),f=t.attributes.texCoord0!=null,w=t.attributes.normal!=null,b=at(e.alphaMode);if(!i.has(x)){if(f){const P=(A,V=!1,p=!1)=>{if(A!=null&&!n.has(A)){const T=r.textures.get(A);if(T){const h=T.data,$=V&&!k(h)?a.compressionOptions:void 0;n.set(A,new ae(k(h)?h.data:h,{...T.parameters,preMultiplyAlpha:!k(h)&&p,encoding:k(h)?h.encoding:void 0,compressionOptions:$}))}}},I=b!==1&&!m;P(e.colorTexture,I,b!==1),P(e.normalTexture),P(e.occlusionTexture,!0),P(e.emissiveTexture),P(e.metallicRoughnessTexture,!0)}const y=G(e.color[0]),M=G(e.color[1]),U=G(e.color[2]),R=e.colorTexture!=null&&f?n.get(e.colorTexture):null,S=De(e),F=e.normalTextureTransform?.scale!=null?e.normalTextureTransform?.scale:Te;i.set(x,new L({...s,customDepthTest:1,textureAlphaMode:b,textureAlphaCutoff:e.alphaCutoff,diffuse:[y,M,U],ambient:[y,M,U],opacity:e.alphaMode==="OPAQUE"?1:e.opacity,doubleSided:e.doubleSided,doubleSidedType:"winding-order",cullFace:e.doubleSided?0:2,hasVertexColors:!!t.attributes.color,hasVertexTangents:!!t.attributes.tangent,normalType:w?0:2,castShadows:!0,receiveShadows:e.receiveShadows,receiveAmbientOcclusion:e.receiveAmbientOcclusion,textureId:R?.id,colorMixMode:e.colorMixMode,normalTextureId:e.normalTexture!=null&&f?n.get(e.normalTexture).id:void 0,textureAlphaPremultiplied:R!=null&&!!R.parameters.preMultiplyAlpha,occlusionTextureId:e.occlusionTexture!=null&&f?n.get(e.occlusionTexture).id:void 0,emissiveTextureId:e.emissiveTexture!=null&&f?n.get(e.emissiveTexture).id:void 0,metallicRoughnessTextureId:e.metallicRoughnessTexture!=null&&f?n.get(e.metallicRoughnessTexture).id:void 0,emissiveBaseColor:[e.emissiveFactor[0],e.emissiveFactor[1],e.emissiveFactor[2]],mrrFactors:S?qe:[e.metallicFactor,e.roughnessFactor,s.mrrFactors[2]],isSchematic:S,colorTextureTransformMatrix:O(e.colorTextureTransform),normalTextureTransformMatrix:O(e.normalTextureTransform),scale:[F[0],F[1]],occlusionTextureTransformMatrix:O(e.occlusionTextureTransform),emissiveTextureTransformMatrix:O(e.emissiveTextureTransform),metallicRoughnessTextureTransformMatrix:O(e.metallicRoughnessTextureTransform),...u},a))}const v=i.get(x);if(o.stageResources.materials.push(v),f){const y=M=>{M!=null&&o.stageResources.textures.push(n.get(M))};y(e.colorTexture),y(e.normalTexture),y(e.occlusionTexture),y(e.emissiveTexture),y(e.metallicRoughnessTexture)}return v}function nt(r,t){const o=r.attributes.position.count,s=Fe(r.indices||o,r.primitiveType),u=_(3*o),{typedBuffer:i,typedBufferStride:n}=r.attributes.position;Ie(u,i,r.transform,3,n);const a=[["position",new E(u,s,3,!0)]];if(r.attributes.normal!=null){const e=_(3*o),{typedBuffer:l,typedBufferStride:c}=r.attributes.normal;ge(C,r.transform),Ee(e,l,C,3,c),Y(C)&&te(e,e),a.push(["normal",new E(e,s,3,!0)])}if(r.attributes.tangent!=null){const e=_(4*o),{typedBuffer:l,typedBufferStride:c}=r.attributes.tangent;xe(C,r.transform),Oe(e,l,C,4,c),Y(C)&&te(e,e,4),a.push(["tangent",new E(e,s,4,!0)])}if(r.attributes.texCoord0!=null){const e=_(2*o),{typedBuffer:l,typedBufferStride:c}=r.attributes.texCoord0;Ue(e,l,2,c),a.push(["uv0",new E(e,s,2,!0)])}const m=r.attributes.color;if(m!=null){const e=new Uint8Array(4*o);m.elementCount===4?m instanceof ee?se(e,m,1,255):(m instanceof Ae||m instanceof Be)&&se(e,m,1/255,255):(e.fill(255),m instanceof Z?re(e,m.typedBuffer,1,255,4,m.typedBufferStride):(r.attributes.color instanceof Se||r.attributes.color instanceof Pe)&&re(e,m.typedBuffer,1/255,255,4,r.attributes.color.typedBufferStride)),a.push(["color",new E(e,s,4,!0)])}return{geometry:new J(t,a),vertexCount:o}}const C=z();function at(r){switch(r){case"BLEND":return 0;case"MASK":return 2;case"OPAQUE":case null:case void 0:return 1}}function it(r,t){for(let o=0;o<r.model.lods.length;++o){const s=r.model.lods[o];for(const u of s.parts){const i=u.attributes.normal;if(i==null)return;const n=u.attributes.position,a=n.count,m=q(),e=q(),l=q(),c=new Float32Array(4*a),g=new Float32Array(3*a),d=be(pe(),u.transform);let x=0,f=0;for(let w=0;w<a;w++){n.getVec(w,e),i.getVec(w,m),K(e,e,u.transform),we(l,e,t.center),X(l,l,t.radius);const b=l[2],v=ve(l),y=Math.min(.45+.55*v*v,1)**he;X(l,l,t.radius),d!==null&&K(l,l,d),Me(l,l),o+1!==r.model.lods.length&&r.model.lods.length>1&&Re(l,l,m,b>-1?.2:Math.min(-4*b-3.8,1)),g[x]=l[0],g[x+1]=l[1],g[x+2]=l[2],x+=3,c[f]=y,c[f+1]=y,c[f+2]=y,c[f+3]=1,f+=4}u.attributes.normal=new Z(g.buffer),u.attributes.color=new ee(c.buffer)}}}const lt=Object.freeze(Object.defineProperty({__proto__:null,fetch:ue,parseUrl:ce},Symbol.toStringTag,{value:"Module"}));export{lt as o,O as s,ue as z};
