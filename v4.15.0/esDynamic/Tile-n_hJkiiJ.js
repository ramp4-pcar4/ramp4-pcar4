import{cg as Y,bz as Q,l as K,a as $,c as G,$ as H,d as X,A as U,C as ee,_ as k,X as b,Y as te,N as se,a8 as ie,ba as oe,lb as re,ku as le,gN as W,ak as L,kt as ne,h2 as he,lc as ae}from"./main-pOgmbpmS.js";import{e as P}from"./TileKey-CKc2_PQR.js";import{s as ce}from"./Queue-E6NLvEri.js";import{s as V}from"./ReactiveMap-DGQ0boBX.js";import{r as ue}from"./signal-DcZ6PPH8.js";import{m as fe}from"./Query-D10S0CI1.js";import{e as de}from"./arcadeUtils-BkvNBhzm.js";function M(s,e){return[s,e]}function z(s,e,t){return s[0]=e,s[1]=t,s}function _e(s,e,t,i,o){return s[0]=e,s[1]=t,s[2]=i,s[3]=o,s}const w=new P("0/0/0/0");let ge=class J{static create(e,t,i=null){const o=Y(e.spatialReference),r=t.origin||M(e.origin.x,e.origin.y),n=M(e.size[0]*t.resolution,e.size[1]*t.resolution),l=M(-1/0,-1/0),c=M(1/0,1/0),h=M(1/0,1/0);i!=null&&(z(l,Math.max(0,Math.floor((i.xmin-r[0])/n[0])),Math.max(0,Math.floor((r[1]-i.ymax)/n[1]))),z(c,Math.max(0,Math.floor((i.xmax-r[0])/n[0])),Math.max(0,Math.floor((r[1]-i.ymin)/n[1]))),z(h,c[0]-l[0]+1,c[1]-l[1]+1));const{cols:u,rows:f}=t;let g,m,p,y;return!i&&u&&f&&(z(l,u[0],f[0]),z(c,u[1],f[1]),z(h,u[1]-u[0]+1,f[1]-f[0]+1)),e.isWrappable?(g=M(Math.ceil(Math.round((o.valid[1]-o.valid[0])/t.resolution)/e.size[0]),h[1]),m=!0,p=o.origin,y=o.valid):(g=h,m=!1),new J(t.level,t.resolution,t.scale,r,l,c,h,n,g,m,p,y)}constructor(e,t,i,o,r,n,l,c,h,u,f,g){this.level=e,this.resolution=t,this.scale=i,this.origin=o,this.first=r,this.last=n,this.size=l,this.norm=c,this.worldSize=h,this.wrap=u,this._spatialReferenceOrigin=f,this._spatialReferenceValid=g}normalizeCol(e){if(!this.wrap)return e;const t=this.worldSize[0];return e<0?t-1-Math.abs((e+1)%t):e%t}normalizeKey(e){if(!this.wrap)return;const t=this.worldSize[0],i=e.col;i<0?(e.col=i+t,e.world-=1):i>=t&&(e.col=i-t,e.world+=1)}denormalizeCol(e,t){return this.wrap?this.worldSize[0]*t+e:e}getWorldForColumn(e){return this.wrap?Math.floor(e/this.worldSize[0]):0}getFirstColumnForWorld(e){return e*this.worldSize[0]+this.first[0]}getLastColumnForWorld(e){return e*this.worldSize[0]+this.first[0]+this.size[0]-1}getColumnForX(e){return(e-this.origin[0])/this.norm[0]}getXForColumn(e){const t=this.origin[0]+e*this.norm[0],i=this._spatialReferenceOrigin,o=this._spatialReferenceValid;return this.wrap&&i&&o?t===i[0]?o[0]:this.origin[0]===i[0]&&e===this.worldSize[0]?o[1]:t:t}getRowForY(e){return(this.origin[1]-e)/this.norm[1]}getYForRow(e){return this.origin[1]-e*this.norm[1]}getTileBounds(e,t,i=!1){w.set(t);const o=i?w.col:this.denormalizeCol(w.col,w.world),r=w.row;return _e(e,this.getXForColumn(o),this.getYForRow(r+1),this.getXForColumn(o+1),this.getYForRow(r)),e}getTileCoords(e,t,i=!1){w.set(t);const o=i?w.col:this.denormalizeCol(w.col,w.world);return Array.isArray(e)?z(e,this.getXForColumn(o),this.getYForRow(w.row)):(e.x=this.getXForColumn(o),e.y=this.getYForRow(w.row)),e}};class B{constructor(){this.spans=[]}static{this.pool=new Q(()=>new B)}acquire(e){this.lodInfo=e}release(){this.lodInfo=null,this.spans.length=0}*keys(){const e=this.lodInfo;for(const{row:t,colFrom:i,colTo:o}of this.spans)for(let r=i;r<=o;r++){const n=e.getWorldForColumn(r);yield new P(e.level,t,e.normalizeCol(r),n)}}forEach(e,t){const{spans:i,lodInfo:o}=this,{level:r}=o;if(i.length!==0)for(const{row:n,colFrom:l,colTo:c}of i)for(let h=l;h<=c;h++)e.call(t,r,n,o.normalizeCol(h),o.getWorldForColumn(h))}}let A=class{constructor(s,e,t){this.row=s,this.colFrom=e,this.colTo=t}};const _=new P("0/0/0/0");class O{static create(e,t){e[1]>t[1]&&([e,t]=[t,e]);const[i,o]=e,[r,n]=t,l=r-i,c=n-o,h=c!==0?l/c:0,u=(Math.ceil(o)-o)*h,f=(Math.floor(o)-o)*h;return new O(i,Math.floor(o),Math.ceil(n),h,l<0?u:f,l<0?f:u,l<0?r:i,l<0?i:r)}constructor(e,t,i,o,r,n,l,c){this.x=e,this.ymin=t,this.ymax=i,this.invM=o,this.leftAdjust=r,this.rightAdjust=n,this.leftBound=l,this.rightBound=c}incrRow(){this.x+=this.invM}getLeftCol(){return Math.max(this.x+this.leftAdjust,this.leftBound)}getRightCol(){return Math.min(this.x+this.rightAdjust,this.rightBound)}}const v=[[0,0],[0,0],[0,0],[0,0]],pe=1e-6;let me=class{constructor(s,e=null,t=s.lods[0].level,i=s.lods[s.lods.length-1].level){this.tileInfo=s,this.fullExtent=e,this.scales=[],this._infoByScale={},this._infoByLevel={};const o=s.lods.filter(n=>n.level>=t&&n.level<=i);this.minScale=o[0].scale,this.maxScale=o[o.length-1].scale;const r=this._lodInfos=o.map(n=>ge.create(s,n,e));o.forEach((n,l)=>{this._infoByLevel[n.level]=r[l],this._infoByScale[n.scale]=r[l],this.scales[l]=n.scale},this),this._wrap=s.isWrappable}get spatialReference(){return this.tileInfo.spatialReference}getLODInfoAt(s){return this._infoByLevel[typeof s=="number"?s:s.level]}getTileBounds(s,e,t=!1){_.set(e);const i=this._infoByLevel[_.level];return i?i.getTileBounds(s,_,t):s}getTileCoords(s,e,t=!1){_.set(e);const i=this._infoByLevel[_.level];return i?i.getTileCoords(s,_,t):s}getTileCoverage(s,e=192,t=!0,i="closest"){if(!t&&(s.scale>this.minScale||s.scale<this.maxScale))return null;const o=i==="closest"?this.getClosestInfoForScale(s.scale):this.getSmallestInfoForScale(s.scale),r=B.pool.acquire(o),n=this._wrap;let l,c,h,u=1/0,f=-1/0;const g=r.spans;v[0][0]=v[0][1]=v[1][1]=v[3][0]=-e,v[1][0]=v[2][0]=s.size[0]+e,v[2][1]=v[3][1]=s.size[1]+e;for(const a of v)s.toMap(a,a),a[0]=o.getColumnForX(a[0]),a[1]=o.getRowForY(a[1]);const m=[];let p=3;for(let a=0;a<4;a++){if(v[a][1]===v[p][1]){p=a;continue}const d=O.create(v[a],v[p]);u=Math.min(d.ymin,u),f=Math.max(d.ymax,f),m[d.ymin]===void 0&&(m[d.ymin]=[]),m[d.ymin].push(d),p=a}if(u==null||f==null||f-u>100)return null;let y=[];for(l=u;l<f;){m[l]!=null&&(y=y.concat(m[l])),c=1/0,h=-1/0;for(let a=y.length-1;a>=0;a--){const d=y[a];c=Math.min(c,d.getLeftCol()),h=Math.max(h,d.getRightCol())}if(c=Math.floor(c),h=Math.floor(h),l>=o.first[1]&&l<=o.last[1])if(n)if(o.size[0]<o.worldSize[0]){const a=Math.floor(h/o.worldSize[0]);for(let d=Math.floor(c/o.worldSize[0]);d<=a;d++)g.push(new A(l,Math.max(o.getFirstColumnForWorld(d),c),Math.min(o.getLastColumnForWorld(d),h)))}else g.push(new A(l,c,h));else c>o.last[0]||h<o.first[0]||(c=Math.max(c,o.first[0]),h=Math.min(h,o.last[0]),g.push(new A(l,c,h)));l+=1;for(let a=y.length-1;a>=0;a--){const d=y[a];d.ymax>=l?d.incrRow():y.splice(a,1)}}return r}getTileParentId(s){_.set(s);const e=this._infoByLevel[_.level],t=this._lodInfos.indexOf(e)-1;return t<0?null:(this._getTileIdAtLOD(_,this._lodInfos[t],_),_.id)}getTileResolution(s){const e=this._infoByLevel[typeof s=="object"?s.level:s];return e?e.resolution:-1}getTileScale(s){const e=this._infoByLevel[s.level];return e?e.scale:-1}intersects(s,e){_.set(e);const t=this._infoByLevel[_.level],i=s.lodInfo;if(i.resolution>t.resolution){this._getTileIdAtLOD(_,i,_);const r=i.denormalizeCol(_.col,_.world);for(const n of s.spans)if(n.row===_.row&&n.colFrom<=r&&n.colTo>=r)return!0}if(i.resolution<t.resolution){const[r,n,l,c]=s.spans.reduce((p,y)=>(p[0]=Math.min(p[0],y.row),p[1]=Math.max(p[1],y.row),p[2]=Math.min(p[2],y.colFrom),p[3]=Math.max(p[3],y.colTo),p),[1/0,-1/0,1/0,-1/0]),h=t.denormalizeCol(_.col,_.world),u=i.getColumnForX(t.getXForColumn(h)),f=i.getRowForY(t.getYForRow(_.row)),g=i.getColumnForX(t.getXForColumn(h+1))-1,m=i.getRowForY(t.getYForRow(_.row+1))-1;return!(u>c||g<l||f>n||m<r)}const o=i.denormalizeCol(_.col,_.world);return s.spans.some(r=>r.row===_.row&&r.colFrom<=o&&r.colTo>=o)}normalizeBounds(s,e,t){if(s[0]=e[0],s[1]=e[1],s[2]=e[2],s[3]=e[3],this._wrap){const i=Y(this.tileInfo.spatialReference),o=-t*(i.valid[1]-i.valid[0]);s[0]+=o,s[2]+=o}return s}getSmallestInfoForScale(s){const e=this.scales;if(this._infoByScale[s])return this._infoByScale[s];if(s>e[0])return this._infoByScale[e[0]];for(let t=1;t<e.length-1;t++)if(s>e[t]+pe)return this._infoByScale[e[t-1]];return this._infoByScale[e[e.length-1]]}getClosestInfoForScale(s){const e=this.scales;return this._infoByScale[s]||(s=e.reduce((t,i)=>Math.abs(i-s)<Math.abs(t-s)?i:t,e[0])),this._infoByScale[s]}scaleToLevel(s){const e=this.scales;if(this._infoByScale[s])return this._infoByScale[s].level;for(let t=e.length-1;t>=0;t--)if(s<e[t])return t===e.length-1?this._infoByScale[e[e.length-1]].level:this._infoByScale[e[t]].level+(e[t]-s)/(e[t]-e[t+1]);return this._infoByScale[e[0]].level}scaleToZoom(s){return this.tileInfo.scaleToZoom(s)}zoomToScale(s){return this.tileInfo.zoomToScale(s)}_getTileIdAtLOD(s,e,t){const i=this._infoByLevel[t.level];return s.set(t),e.resolution<i.resolution?null:(e.resolution===i.resolution||(s.level=e.level,s.col=Math.floor(t.col*i.resolution/e.resolution+.01),s.row=Math.floor(t.row*i.resolution/e.resolution+.01)),s)}};class ye{constructor(e,t){this.item=e,this.controller=t,this.promise=null}}class j{constructor(e){this._schedule=null,this._task=null,this._deferreds=new V,this._controllers=new V,this._processingItems=new V,this._pausedSignal=ue(!1),this.concurrency=1,e.concurrency&&(this.concurrency=e.concurrency),this._queue=new ce(e.peeker),this.process=e.process;const t=e.scheduler;e.priority&&t&&(this._task=t.registerTask(e.priority,this))}destroy(){this.clear(),this._schedule=K(this._schedule),this._task=K(this._task)}get updating(){return!!this._task?.updating||this.readyToRun}get length(){return this._processingItems.size+this._queue.length}abort(e){const t=this._controllers.get(e);t&&t.abort()}clear(){this._queue.clear();const e=[];this._controllers.forEach(t=>e.push(t)),this._controllers.clear(),e.forEach(t=>t.abort()),this._processingItems.clear(),this._cancelNext()}forEach(e){this._deferreds.forEach((t,i)=>e(i))}get(e){const t=this._deferreds.get(e);return t?t.promise:void 0}isOngoing(e){return this._processingItems.has(e)}has(e){return this._deferreds.has(e)}pause(){this._pausedSignal.value||(this._pausedSignal.value=!0,this._cancelNext())}push(e,t){const i=this.get(e);if(i)return i;const o=new AbortController;let r=null;t&&(r=$(t,()=>o.abort()));const n=()=>{const u=this._processingItems.get(e);u&&u.controller.abort(),l(),h.reject(X())},l=()=>{c.remove(),r?.remove(),this._removeItem(e),this._queue.remove(e),this._scheduleNext()},c=G(o.signal,n),h=H();return this._deferreds.set(e,h),this._controllers.set(e,o),h.promise.then(l,l),this._queue.push(e),this._scheduleNext(),h.promise}last(){return this._queue.last()}lastPromise(){const e=this.last();return e?this.get(e):null}peek(){return this._queue.peek()}popLast(){const e=this._queue.popLast();return e&&(this._deferreds.get(e)?.reject(X()),this._removeItem(e)),e}reset(){const e=Array.from(this._processingItems.values());this._processingItems.clear();for(const t of e)this._queue.push(t.item),t.controller.abort();this._scheduleNext()}resume(){this._pausedSignal.value&&(this._pausedSignal.value=!1,this._scheduleNext())}takeAll(){const e=[];for(;this._queue.length;)e.push(this._queue.pop());return this.clear(),e}get readyToRun(){return!this._pausedSignal.value&&this._queue.length>0&&this._processingItems.size<this.concurrency}runTask(e){for(;!e.done&&this._queue.length>0&&this._processingItems.size<this.concurrency;)this._process(this._queue.pop()),e.madeProgress()}_removeItem(e){this._deferreds.delete(e),this._controllers.delete(e),this._processingItems.delete(e)}_scheduleNext(){this._task||this._pausedSignal.value||this._schedule||(this._schedule=U(()=>{this._schedule=null,this._next()}))}_next(){for(;this._queue.length>0&&this._processingItems.size<this.concurrency;)this._process(this._queue.pop())}_cancelNext(){this._schedule&&(this._schedule.remove(),this._schedule=null)}_processResult(e,t){this._canProcessFulfillment(e)&&(this._scheduleNext(),this._deferreds.get(e.item).resolve(t))}_processError(e,t){this._canProcessFulfillment(e)&&(this._scheduleNext(),this._deferreds.get(e.item).reject(t))}_canProcessFulfillment(e){return!!this._deferreds.get(e.item)&&this._processingItems.get(e.item)===e}_process(e){if(e==null)return;let t;const i=new AbortController,o=new ye(e,i);this._processingItems.set(e,o);try{t=this.process(e,i.signal)}catch(r){this._processError(o,r)}ee(t)?(o.promise=t,t.then(r=>this._processResult(o,r),r=>this._processError(o,r))):this._processResult(o,t)}get test(){}}const D=[0,0];let T=class extends se{constructor(s){super(s),this._keyToItem=new Map,this._tilesByScale=new Map,this.concurrency=6}initialize(){const{concurrency:s,process:e,scheduler:t,priority:i}=this;this._queue=new j({concurrency:s,scheduler:t,priority:i,process:(o,r)=>{const n=this._keyToItem.get(o);return e(n,{signal:r})},peeker:o=>this._peek(o)})}destroy(){this.clear(),this._queue=ie(this._queue)}get length(){return this._queue?this._queue.length:0}abort(s){const e=typeof s=="string"?s:s.id;this._queue.abort(e)}clear(){this._queue.clear(),this._keyToItem.clear(),this._tilesByScale.clear()}has(s){return typeof s=="string"?this._keyToItem.has(s):this._keyToItem.has(s.id)}pause(){this._queue.pause()}push(s){const e=s.key.id;if(this._queue.has(e))return this._queue.get(e);const t=this._queue.push(e),i=this.tileInfoView.getTileScale(s.key),o=oe(this._tilesByScale,i,()=>new Set),r=()=>{o.delete(s.key),o.size===0&&this._tilesByScale.delete(i),this._keyToItem.delete(e)};return o.add(s.key),this._keyToItem.set(e,s),t.then(r,r),t}reset(){this._queue.reset()}resume(){this._queue.resume()}_peek(s){if(!this.state)return s.values().next().value;const e=new Set;for(const r of s)e.add(this._keyToItem.get(r).key);const t=this.state.scale;let i,o=Number.POSITIVE_INFINITY;for(const[r,n]of this._tilesByScale)if(re(n,l=>e.has(l))){const l=Math.abs(r-t);l<o&&(i=n,o=l)}return this._getClosestTileKey(i,s).id}_getClosestTileKey(s,e){const t=this.tileInfoView,i=this.state.center;let o,r=Number.POSITIVE_INFINITY;for(const n of s)if(e.has(n.id)){t.getTileCoords(D,n);const l=le(D,i);l<r&&(r=l,o=n)}return o}};k([b({constructOnly:!0})],T.prototype,"concurrency",void 0),k([b({constructOnly:!0})],T.prototype,"priority",void 0),k([b({constructOnly:!0})],T.prototype,"process",void 0),k([b({constructOnly:!0})],T.prototype,"scheduler",void 0),k([b()],T.prototype,"state",void 0),k([b({constructOnly:!0})],T.prototype,"tileInfoView",void 0),T=k([te("esri.views.2d.tiling.TileQueue")],T);const ve=T;class we{constructor(e,t,i){this.maxSize=e,this._tileInfoView=t,this._removedFunc=i,this._tilePerId=new Map,this._tileKeysPerLevel=[]}clear(){this._tilePerId.clear(),this._tileKeysPerLevel=[]}has(e){return this._tilePerId.has(e)}get(e){return this._tilePerId.get(e)}pop(e){const t=this._tilePerId.get(e);if(!t)return;const i=t.key.level,o=this._tileKeysPerLevel[i];Z(this._tilePerId,e);for(let r=0;r<o.length;r++)if(o[r].id===e){o.splice(r,1);break}return t.visible=!0,t}add(e){e.visible=!1;const t=e.key,i=t.id;if(this._tilePerId.has(i))return;this._tilePerId.set(i,e);const o=t.level;this._tileKeysPerLevel[o]||(this._tileKeysPerLevel[o]=[]),this._tileKeysPerLevel[o].push(t)}prune(e,t,i){let o=this._tilePerId.size;if(o<=this.maxSize)return;let r=this._tileKeysPerLevel.length-1;for(;o>this.maxSize&&r>=0;)r!==e&&(o=this._pruneAroundCenterTile(o,t,i,r)),r--;o>this.maxSize&&(o=this._pruneAroundCenterTile(o,t,i,e))}_pruneAroundCenterTile(e,t,i,o){const r=this._tileKeysPerLevel[o];if(!r||r.length===0)return e;const{size:n,origin:l}=this._tileInfoView.tileInfo,c=i*n[0],h=i*n[1],u=[0,0],f=[0,0];for(r.sort((g,m)=>(u[0]=l.x+c*(g.col+.5),u[1]=l.y-h*(g.row+.5),f[0]=l.x+c*(m.col+.5),f[1]=l.y-h*(m.row+.5),W(u,t)-W(f,t)));r.length>0;){const g=r.pop();if(this._removeTile(g.id),--e===this.maxSize)break}return e}_removeTile(e){const t=this._tilePerId.get(e);this._removedFunc&&t&&this._removedFunc(t),Z(this._tilePerId,e)}}function Z(s,e){s.delete(e)}const F=new P(0,0,0,0),x=new Map,R=[],N=[];let Ie=class{constructor(s){this._previousScale=Number.POSITIVE_INFINITY,this.cachePolicy="keep",this.coveragePolicy="closest",this.resampling=!0,this.tileIndex=new Map,this.tiles=[],this.buffer=192,this.acquireTile=s.acquireTile,this.releaseTile=s.releaseTile,this.tileInfoView=s.tileInfoView,s.resampling!=null&&(this.resampling=s.resampling),s.cachePolicy&&(this.cachePolicy=s.cachePolicy),s.coveragePolicy&&(this.coveragePolicy=s.coveragePolicy),s.buffer!=null&&(this.buffer=s.buffer),s.cacheSize&&(this._tileCache=new we(s.cacheSize,this.tileInfoView,e=>{this.releaseTile(e)}))}destroy(){this.tileIndex.clear()}update(s){const{resampling:e,tileIndex:t}=this,{scale:i,center:o,resolution:r}=s.state,{minScale:n,maxScale:l}=this.tileInfoView,c=!s.stationary&&i>this._previousScale;if(this._previousScale=i,!e&&(i>n||i<l))return this.tiles.length=0,void this.clear();const h=this.tileInfoView.getTileCoverage(s.state,this.buffer,this.resampling,this.coveragePolicy);if(!h)return this.tiles.length=0,void this.clear();const{spans:u,lodInfo:f}=h,{level:g}=f;this.tiles.length=0,t.forEach(a=>a.visible=!0);let m=0,p=0;if(u.length>0)for(const{row:a,colFrom:d,colTo:q}of u)for(let C=d;C<=q;C++){m++;const I=F.set(g,a,f.normalizeCol(C),f.getWorldForColumn(C)).id;let S=t.get(I);if(S)S.isReady?(x.set(I,S),p++):c||this._addParentTile(I,x);else{if(this._tileCache?.has(I)){if(S=this._tileCache.pop(I),this.tileIndex.set(I,S),S.isReady){x.set(I,S),p++;continue}}else S=this.acquireTile(F),this.tileIndex.set(I,S);c||this._addParentTile(I,x)}}const y=p===m;for(const[a,d]of t){if(x.has(a))continue;F.set(a);const q=this.tileInfoView.intersects(h,F),C=this.cachePolicy==="purge"?F.level!==g:F.level>g;!q||!c&&y?!C&&q||R.push(d):d.isReady?C&&this.cachePolicy==="purge"&&this._hasReadyAncestor(F,g)?R.push(d):N.push(d):C&&R.push(d)}for(const a of N)a.isReady&&x.set(a.key.id,a);for(const a of R)this._tileCache?this._tileCache.add(a):this.releaseTile(a),t.delete(a.key.id);for(const a of x.values())this.tiles.push(a);for(const a of t.values())x.has(a.key.id)||(a.visible=!1);this._tileCache?.prune(g,o,r),B.pool.release(h),N.length=0,R.length=0,x.clear()}clear(){const{tileIndex:s}=this;for(const e of s.values())this.releaseTile(e);s.clear()}refresh(s){for(const e of this.tileIndex.values())s(e);this._tileCache?.clear()}updateCacheSize(s){this._tileCache&&(this._tileCache.maxSize=s)}_addParentTile(s,e){let t=s,i=null;for(;t=this.tileInfoView.getTileParentId(t),t;)if(this.tileIndex.has(t)){if(i=this.tileIndex.get(t),i?.isReady){e.has(i.key.id)||e.set(i.key.id,i);break}}else if(this._tileCache?.has(t)&&(i=this._tileCache.pop(t),this.tileIndex.set(t,i),i?.isReady)){e.has(i.key.id)||e.set(i.key.id,i);break}}_hasReadyAncestor(s,e){const t=L();this.tileInfoView.getTileBounds(t,s,!0);for(const i of this.tileIndex.values())if(i.isReady&&i.key.level>=e&&i.key.level<s.level){const o=L();if(this.tileInfoView.getTileBounds(o,i.key,!0),ne(o,t))return!0}return!1}};class E{constructor(e,t){this.key=new P(0,0,0,0),this.bounds=L(),this.objectIds=new Set,this.key.set(t);const i=e.getLODInfoAt(this.key);this.tileInfoView=e,this.tileInfoView.getTileBounds(this.bounds,this.key,!0),this.resolution=i.resolution,this.level=i.level,this.scale=i.scale,this.minScale=e.zoomToScale(i.level-1),this.maxScale=e.zoomToScale(i.level+1)}get lod(){return this.tileInfoView.getLODInfoAt(this.key)}get id(){return this.key.id}get extent(){return he(this.bounds,this.tileInfoView.tileInfo.spatialReference)}get transform(){return{originPosition:"upperLeft",scale:[this.resolution,this.resolution],translate:[this.bounds[0],this.bounds[3]]}}createArcadeEvaluationOptions(e){return de(this.scale,e)}createChildTiles(){const e=this.key.getChildKeys(),t=ae.acquire();for(let i=0;i<e.length;i++)t[i]=new E(this.tileInfoView,e[i]);return t}getQuantizationParameters(){return fe.fromJSON({mode:"view",originPosition:"upperLeft",tolerance:this.resolution,extent:{xmin:this.bounds[0],ymin:this.bounds[1],xmax:this.bounds[2],ymax:this.bounds[3],spatialReference:this.tileInfoView.tileInfo.spatialReference}})}}export{j as _,E as a,me as h,ve as p,Ie as r,B as s};
