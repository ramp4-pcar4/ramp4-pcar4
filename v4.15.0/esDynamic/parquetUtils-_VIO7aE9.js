import{bH as b,Z as F,_ as n,X as a,Y as d,aQ as h,s as m,z as g}from"./main-pOgmbpmS.js";import{m as k}from"./Field-ByxjJxHZ.js";import{n as P}from"./locationUtils-D5qCy2q5.js";import{d as q,w as v,g as z}from"./parquet-BK5FriVr.js";let p=class extends b(F){constructor(e){super(e),this.type=null}};n([a({type:["wkb","location"],nonNullable:!0,readOnly:!0,json:{read:!1,write:{isRequired:!0}}})],p.prototype,"type",void 0),p=n([d("esri.layers.support.ParquetEncodingBase")],p);let l=class extends p{constructor(e){super(e),this.type="location",this.latitudeFieldName=null,this.longitudeFieldName=null}};n([a({type:["location"]})],l.prototype,"type",void 0),n([a({type:String,json:{name:"yField",write:{isRequired:!0}}})],l.prototype,"latitudeFieldName",void 0),n([a({type:String,json:{name:"xField",write:{isRequired:!0}}})],l.prototype,"longitudeFieldName",void 0),l=n([d("esri.layers.support.ParquetEncodingLocation")],l);let u=class extends p{constructor(e){super(e),this.type="wkb",this.primaryFieldName=null}};n([a({type:["wkb"]})],u.prototype,"type",void 0),n([a({type:["counter-clockwise"],json:{write:!0}})],u.prototype,"orientation",void 0),n([a({type:String,json:{name:"field",write:{isRequired:!0}}})],u.prototype,"primaryFieldName",void 0),u=n([d("esri.layers.support.ParquetEncodingWkb")],u);const y=new h({esriGeometryPoint:"point",esriGeometryPolygon:"polygon",esriGeometryPolyline:"polyline",esriGeometryMultipoint:"multipoint"});function x(e){return y.toJSON(e)}function R(e){return y.fromJSON(e)}async function S(e,r={}){if(e.urls.length<1)throw new m("parquet:bad-input","At least one url must be specified",e);if(e.geometryType&&e.spatialReference&&e.encoding&&e.fields)return e;const i=await q(e.urls.getItemAt(0),{getCustomParameters:()=>r.customParameters}),o=v(i),t={...e,file:i};t.fields==null&&(t.fields=i.fields().map(s=>k.fromJSON({name:s.name,alias:s.name,type:s.type}))),t.encoding==null&&(t.encoding=O(o,t.fields));const c=z(i);if(c)switch(c.mode){case"z":t.displayOptimization={mode:"z"};break;case"xz":{const s=c.multiscale;if(!s)throw new m("parquet:bad-format","XZ display optimization requires multiscale geometries");t.displayOptimization={mode:"xz",multiscale:s};break}}if(!t.encoding)return t;switch(t.encoding.type){case"location":t.spatialReference==null&&(t.spatialReference=g.WGS84),t.geometryType==null&&(t.geometryType="point");break;case"wkb":{if(!o)return t;const s=o.primary_column,f=o.columns[s];if(t.geometryType||(t.geometryType=T(f)),t.spatialReference||(t.spatialReference=G(f)),t.fields)for(const w of Object.keys(o.columns))t.fields=t.fields.filter(N=>N.name!==w)}}return t}function O(e,r){if(e!=null){const o=e.primary_column,t=e.columns[o];return new u({primaryFieldName:o,orientation:t.orientation==="counterclockwise"?"counter-clockwise":null})}const i=P(r.map(o=>o.name));return i.latitudeFieldName&&i.longitudeFieldName?new l({latitudeFieldName:i.latitudeFieldName,longitudeFieldName:i.longitudeFieldName}):null}function j(e){switch(e){case"Point":return"point";case"Polygon":case"MultiPolygon":return"polygon";case"LineString":return"polyline";case"MultiPoint":return"multipoint";default:return null}}function T(e){const{geometry_types:r}=e,i=new Set;for(const o of r){const t=j(o);t&&i.add(t)}if(i.size>1)throw new m("parquet:unsupported","Parquet mixed geometry types are not supported",{geometryTypes:i});return i.size===1?i.values().next().value:void 0}function G(e){const r=e.crs?.id?.code;return r&&typeof r=="number"?new g({wkid:r}):void 0}export{p as a,y as c,R as f,l as i,x as p,u as s,S as y};
