import{Envelope2D as F}from"./Envelope2D-N58wWtPO.js";import{n as b,a as T,m as y,x as z,P as H,z as ft,r as ut,J as An,b as O,Y as j,D as ne,Q as aa,R as wo,C as Yt,S as Do,d as $,H as yt,F as Rd,q as Ie,T as dn,V as we,X as ze,y as We,f as he,O as R,$ as te,i as lt,e as Ce,Z as Fr,s as J,U as Nt,_ as To,a0 as kd,l as xn,v as Bc,a1 as Ld,a2 as ei,a3 as tr,t as Hc,a4 as Qt,a5 as ha,a6 as L,a7 as Vs,a8 as fe,a9 as ue,aa as ch,ab as Qn,ac as Ct,ad as xt,ae as Bd,W as dt,af as Hd,ag as qt,ah as er,ai as qn,aj as us,ak as cs,al as jt,am as Vt,h as kt,an as ee,ao as se,ap as zd,aq as Ud,ar as Os,as as Ee,at as Ci,au as Mr,av as zc,aw as Od,L as ma,ax as Wd,ay as Cs,az as Es,aA as $d,aB as Uc,aC as Se,aD as bs,aE as pl,aF as Oc,aG as fl,aH as No,aI as jd,aJ as Zd,aK as xl,aL as yl,aM as Qd,aN as Kd,aO as gh,j as ni,B as ri,aP as sr,N as ir,aQ as le,aR as la,aS as Pm,aT as Jd,aU as Be,aV as Kn,aW as tp,aX as Ao,aY as Hi,o as ep,aZ as sp,a_ as Wc,a$ as _h,b0 as dh,b1 as ip,b2 as qs,b3 as np,w as Pl,k as $c,b4 as rp,b5 as jc,b6 as nn,c as Cl,b7 as El,b8 as op,b9 as ap,ba as hp,bb as Hr,G as mp,bc as lp,bd as up,K as zr}from"./Point2D-yI-uny1B.js";import{x as pt}from"./Transformation2D-CZuEM6rU.js";import{t as mi,s as oi}from"./SimpleGeometryCursor-B92kdZ15.js";import{dV as Te,dW as li}from"./main-6eEsl9OJ.js";import{NonSimpleResult as Tt}from"./OperatorDefinitions-DP7_WWTp.js";const Sl=[0,0,Number.NaN,0,0,0,0,0,-1,-1,0,0,0,0],cp=[2,1,1,1,3,1,2,3,2,4,1,1,2,1],gp=[1,1,1,0,2,1,1,1,0,0,0,0,0,1],_p=[1,1,1,2,0,0,0,0,2,2,4,2,2,1],dp=[4,8,4,8,1],Cm=25;function Hs(){return j(Cm,Number.NaN)}let Mt=class Qs{getAttributeCount(){return this.m_attributeCount}getSemantics(t){return this.m_indexToSemantics[t]}getSemanticsBitArray(){return this.m_semanticsBitArray}getAttributeIndex(t){return this.m_semanticsToIndexMap[t]}static getInterpolation(t){return gp[t]}static getPersistence(t){return _p[t]}static getPersistenceSize(t){return dp[t]}static getPersistenceSizeFromSemantics(t){return Qs.getPersistenceSize(Qs.getPersistence(t))*Qs.getComponentCount(t)}static getComponentCount(t){return cp[t]}static maxComponentCount(){return 4}static isInteger(t){return t===2||t===3||t===4}static isIntegerSemantics(t){return Qs.isInteger(Qs.getPersistence(t))}static isTexture(t){return t===5||t===6||t===7}hasAttribute(t){return!!(this.m_semanticsBitArray&1<<t)}hasAttributesFrom(t){return(this.m_semanticsBitArray&t.m_semanticsBitArray)===t.m_semanticsBitArray}hasZ(){return this.hasAttribute(1)}hasM(){return this.hasAttribute(2)}hasID(){return this.hasAttribute(3)}getTotalComponentCount(){return this.m_totalComponentCount}static getDefaultValue(t){return Sl[t]}static isDefaultValue(t,e){return ze(Sl[t],e)}equals(t){return this===t}getDefaultPointAttributes(){return this.m_defaultPointAttributes}getPointAttributeOffset(t){return this.m_pointAttributeOffsets[t]}constructor(t){this.m_semanticsBitArray=t,this.m_attributeCount=0,this.m_totalComponentCount=0,this.m_semanticsToIndexMap=new Int32Array(14),this.m_indexToSemantics=new Int32Array(14),this.m_pointAttributeOffsets=new Int32Array(14),this.m_defaultPointAttributes=j(Cm,Number.NaN),this.m_semanticsToIndexMap.fill(-1),this.m_indexToSemantics.fill(-1);let e=0,s=1,i=14;for(;e<i;e++)t&s&&(this.m_semanticsToIndexMap[e]=this.m_attributeCount,this.m_indexToSemantics[this.m_attributeCount]=e,this.m_attributeCount++,this.m_totalComponentCount+=Qs.getComponentCount(e)),s<<=1;let n=0;for(e=0,i=this.getAttributeCount();e<i;e++){const o=this.getSemantics(e),a=Qs.getComponentCount(o),h=Qs.getDefaultValue(o);this.m_pointAttributeOffsets[e]=n;for(let m=0;m<a;m++)this.m_defaultPointAttributes[n]=h,n++}}};var Xa=Mt;function ua(){return j(14,0)}class zi{static getInstance(){return zi.s_thisInstance}constructor(){this.m_map=new Map,this.m_vd2D=new Xa(1),this.m_map.set(1,this.m_vd2D),this.m_vd3D=new Xa(3),this.m_map.set(3,this.m_vd2D)}GetVD2D(){return this.m_vd2D}GetVD3D(){return this.m_vd3D}FindOrAdd(t){if(t===1)return this.GetVD2D();if(t===3)return this.GetVD3D();const e=this.m_map.get(t);if(e)return e;const s=new Xa(t);return this.m_map.set(t,s),s}}function Em(r){return zi.getInstance().FindOrAdd(r)}function Fn(r,t){if(!r||!t)return t||r;const e=r.getSemanticsBitArray()|t.getSemanticsBitArray();return(e&r.getSemanticsBitArray())===e?r:(e&t.getSemanticsBitArray())===e?t:Em(e)}function Gr(r,t){const e=r.getSemanticsBitArray()|1<<t;return(e&r.getSemanticsBitArray())===e?r:Em(e)}function Vr(r,t){const e=(r.getSemanticsBitArray()|1<<t)-(1<<t);return e===r.getSemanticsBitArray()?r:Em(e)}function _e(){return zi.getInstance().GetVD2D()}function nr(){return zi.getInstance().GetVD3D()}function ca(r,t,e){if(e.fill(-1),r!==null&&t!==null)for(let s=0,i=r.getAttributeCount();s<i;s++)e[s]=t.getAttributeIndex(r.getSemantics(s))}zi.s_thisInstance=new zi;let mt=class ke{static construct(t,e,s){return new ke(t,e,s)}constructor(t,e,s){t!==void 0?(this.x=t,this.y=e,this.z=s):this.x=this.y=this.z=Number.NaN}get 0(){return this.x}get 1(){return this.y}get 2(){return this.z}set 0(t){this.x=t}set 1(t){this.y=t}set 2(t){this.z=t}clone(){return new ke(this.x,this.y,this.z)}assign(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}setCoords(t,e,s){return this.x=t,this.y=e,this.z=s,this}setCoordsPoint2DZ(t,e){return this.setCoords(t.x,t.y,e)}setCoordsPoint3D(t){this.x=t.x,this.y=t.y,this.z=t.z}setZero(){this.x=0,this.y=0,this.z=0}setNormalized(t){this.assign(t),this.normalizeThis()}normalizeThis(){const t=this.length();return t?(this.x/=t,this.y/=t,this.z/=t):(this.x=1,this.y=0,this.z=0),this}getUnitVector(){const t=new ke;return t.setNormalized(this),t}sqrLength(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}lengthXY(){return b(0),0}static sqrDistance(t,e){return yt(t.x-e.x)+yt(t.y-e.y)+yt(t.z-e.z)}static sqrDistanceCoords(t,e,s,i,n,o){return yt(t-i)+yt(e-n)+yt(s-o)}static distance(t,e){return Math.sqrt(ke.sqrDistance(t,e))}isEqual(t,e){return e===void 0&&(e=0),Math.abs(this.x-t.x)<=e&&Math.abs(this.y-t.y)<=e&&An(this.z,t.z,e)}static compareByLength(t,e,s,i){return b(0),0}isEqualCoords(t,e,s,i){return b(0),this.x===t&&this.y===e&&this.z===s}isEqualsTols(t,e,s){return b(0),!1}isEqualCoordsTols(t,e,s,i,n){return b(0),!1}static st_isEqual(t,e,s,i){return b(0),!1}equals(t,e){return this.isEqual(t,e)}equalsTols(t,e,s){return b(0),!1}divThis(t){return this.x/=t,this.y/=t,this.z/=t,this}subThis(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}setSub(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}sub(t){return ke.construct(this.x-t.x,this.y-t.y,this.z-t.z)}addThis(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}add(t){return this.clone().addThis(t)}setAdd(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}mul(t){return ke.construct(this.x*t,this.y*t,this.z*t)}dotProduct(t){return this.x*t.x+this.y*t.y+this.z*t.z}crossProductVector(t){const e=this.y*t.z-t.y*this.z,s=t.x*this.z-this.x*t.z,i=this.x*t.y-t.x*this.y;return new ke(e,s,i)}setCrossProductVector(t,e){const s=t.y*e.z-e.y*t.z,i=e.x*t.z-t.x*e.z,n=t.x*e.y-e.x*t.y;return this.x=s,this.y=i,this.z=n,this}setScaled(t,e){return this.x=t*e.x,this.y=t*e.y,this.z=t*e.z,this}scaleThis(t){return this.x*=t,this.y*=t,this.z*=t,this}scaleZThis(t){return this.z*=t,this}setNAN(){return b(0),this}isNAN(){return Number.isNaN(this.x)||Number.isNaN(this.y)||Number.isNaN(this.z)}static getNAN(){return ke.construct(Number.NaN,Number.NaN,Number.NaN)}isFinite(){return b(0),!1}isZero(){return this.x===0&&this.y===0&&this.z===0}norm(t){return b(0),0}sqrDistanceFromCenterToSpheroidSurface(t,e){return b(0),0}distanceFromCenterToSpheroidSurface(t,e){return Math.sqrt(this.sqrDistanceFromCenterToSpheroidSurface(t,e))}static getClosestCoordinate(t,e,s,i=!1){return b(0),0}compare(t){return this.y<t.y?-1:this.y>t.y?1:this.x<t.x?-1:this.x>t.x?1:this.z<t.z?-1:this.z>t.z?1:0}compareXYZ(t){return b(0),0}negateThis(){this.x=-this.x,this.y=-this.y,this.z=-this.z}static averageFast(t,e){return b(0),{}}static average(t,e){return b(0),{}}static size(){return ke.dimensions}static lerp(t,e,s){const i=new ke;return Rd(t,e,s,i),i}static slerp(t,e,s){return b(0),{}}static compareVectors(t,e){return b(0),0}static selectRightHandedBasisFromNormal(t,e,s){const i=t.getUnitVector(),n=i.createAPerpendicular(),o=new ke;o.setCrossProductVector(i,n),o.normalizeThis(),e.setCoordsPoint3D(n),s.setCoordsPoint3D(o)}createAPerpendicular(){const t=[this.crossProductVector(new ke(0,0,1)),this.crossProductVector(new ke(1,0,0)),this.crossProductVector(new ke(0,1,0))],e=[t[0].sqrLength(),t[1].sqrLength(),t[2].sqrLength()],s=t[e.reduce((i,n,o)=>e[i]>e[o]?i:o,0)];return s.normalizeThis(),s}calculateAngle(t){return b(0),0}static crossDotSign(t,e,s){return b(0),0}static isBisectorRobust(t,e,s){return b(0),0}static compareZOrder(t,e){return b(0),!1}};mt.dimensions=3;class ps{static constructEmpty(){return new ps(Number.NaN,Number.NaN,Number.NaN,Number.NaN,Number.NaN,Number.NaN)}constructor(t,e,s,i,n,o){this.m_EnvelopeType=3,this.xmin=t,this.ymin=e,this.zmin=s,this.xmax=i,this.ymax=n,this.zmax=o,this.normalize()}inflate(t){this.inflateCoords(t,t,t)}inflateCoords(t,e,s){b(0)}getEnvelope2D(){return new F(this.xmin,this.ymin,this.xmax,this.ymax)}getEnvelopeZs(){return new z(this.zmin,this.zmax)}setEmptyZ(){this.zmin=Number.NaN,this.zmax=Number.NaN}normalize(){let t=!1;this.xmin<=this.xmax||(this.xmax=O(this.xmin,this.xmin=this.xmax),t=!0),this.ymin<=this.ymax||(this.ymax=O(this.ymin,this.ymin=this.ymax),t=!0),!t||this.xmin<=this.xmax&&this.ymin<=this.ymax?this.zmin<=this.zmax||(this.zmax=O(this.zmin,this.zmin=this.zmax),this.zmin<=this.zmax||this.setEmptyZ()):this.setEmpty()}isEmpty(){return Number.isNaN(this.xmin)||Number.isNaN(this.ymin)||Number.isNaN(this.xmax)||Number.isNaN(this.ymax)}isEmptyZ(){return Number.isNaN(this.zmin)||Number.isNaN(this.zmax)}setEmpty(){this.xmin=Number.NaN,this.ymin=Number.NaN,this.zmin=Number.NaN,this.xmax=Number.NaN,this.ymax=Number.NaN,this.zmax=Number.NaN}mergeEnv3D(t){t.isEmpty()||(this.mergeCoords(t.xmin,t.ymin,t.zmin),this.mergeCoords(t.xmax,t.ymax,t.zmax))}mergeNe(t){this.mergeNeCoords(t.x,t.y,t.z)}mergeNeCoords(t,e,s){this.xmin>t?this.xmin=t:this.xmax<t&&(this.xmax=t),this.ymin>e?this.ymin=e:this.ymax<e&&(this.ymax=e),this.zmin>s?this.zmin=s:this.zmax<s&&(this.zmax=s)}mergeCoords(t,e,s){this.isEmpty()?(this.xmin=t,this.xmax=t,this.ymin=e,this.ymax=e,this.zmin=s,this.zmax=s):(this.isEmptyZ()&&(this.zmin=s,this.zmax=s),this.mergeNeCoords(t,e,s))}setCoords(t,e,s,i,n,o){this.xmin=t,this.ymin=e,this.zmin=s,this.xmax=i,this.ymax=n,this.zmax=o,this.normalize()}sqrDistanceEnvelope3DAndPoints(t,e,s,i=1){return b(0),0}sqrMaxDistance(t,e=1){return b(0),0}}const un=-559038737;var xi=Mt;function Zc(r,t,e){switch(r){case 0:return new qo(t,e);case 1:return new Ei(t,e);case 2:return new Xt(t,e);case 3:throw new Error("64 bit int attribute stream not implemented");case 4:return new yn(t,e);default:H("")}}function Qc(r,t){const e=xi.getComponentCount(r);return Zc(xi.getPersistence(r),t*e,xi.getDefaultValue(r))}function _o(r,t){const e=xi.getComponentCount(r);return Zc(xi.getPersistence(r),t*e)}function be(r,t){return new Xt(r,t)}function _i(r,t){return new yn(r,t)}function Gi(r,t){return new Ei(r,t)}class ai{size(){return this.m_size}checkResize(t,e){t>this.m_size&&this.resize(t,e)}resize(t,e){if((t=Math.trunc(t))===this.m_size)return;const s=!!e||Number.isNaN(e);if(t<this.m_a.length)this.m_a.length>ai.s_resizeMin&&1.25*t<this.m_a.length&&(this.m_a=this.m_a.slice(0,t)),s&&t>this.m_size&&this.m_a.fill(e,this.m_size,t);else if(t>=this.m_a.length){const i=1.25*t,n=new this.m_a.constructor(i);n.set(this.m_a),this.m_a=n,s&&this.m_a.fill(e,this.m_size,t)}this.m_size=t}resizeRounded(t,e){return this.resize(t,e)}reserve(t){}read(t){return this.m_a[t]}readAsDbl(t){return this.read(t)}write(t,e){this.m_a[t]=e}writeAsDbl(t,e){this.write(t,e)}setRange(t,e,s){(e<0||s<0||s+e>this.size())&&H(),this.m_a.fill(t,e,e+s)}add(t){this.resize(this.m_size+1),this.m_a[this.m_size-1]=t}addArray(t,e){const s=this.m_size;e===void 0?(this.resize(this.m_size+t.length),this.m_a.set(t,s)):(this.resize(this.m_size+e),this.m_a.set(t.slice(0,e),s))}equals(t,e,s,i){return this.getPersistence()!==t.getPersistence()?!1:pp(this,t,e,s,i)}insertRange(t,e,s,i){const n=this.m_size;this.checkResize(Math.max(0,i)+s),this.m_a.copyWithin(t+s,t,i>=0?i:n),this.m_a.fill(e,t,t+s)}readRange(t,e){return this.m_a.slice(t,t+e)}insertRangeFromStream(t,e,s,i,n,o,a){b(this.getPersistence()===e.getPersistence());const h=e,m=this.m_size;i&&this.checkResize(Math.max(0,a)+i),this.m_a.copyWithin(t+i,t,a>=0?a:m),this.m_a.set(h.readRange(s,i),t),n||this.reverseRange(t,i,o)}writeRange(t,e,s,i,n,o){b(this.getPersistence()===s.getPersistence());const a=s;if((t<0||e<0||i<0)&&H(),a.size()<i+e&&H(),e===0)return;this.size()<e+t&&this.resize(e+t);const h=a.m_a.subarray(i,i+e);fp(this.m_a,t,e,h)}insertAttributes(t,e,s,i){const n=xi.getComponentCount(s);this.m_a.copyWithin(t+n,t,i>=0?i:this.m_size);for(let o=0;o<n;o++)this.m_a[t+o]=e.getAttributeAsDbl(s,o)}insertAttributesFromPoints(t,e,s,i,n){b(xi.getPersistence(i)===this.getPersistence());const o=xi.getComponentCount(i),a=this.m_size;if(this.checkResize(Math.max(0,n)+o*s),this.m_a.copyWithin(t+o*s,t,n>=0?n:a),i===0){const h=new y;for(let m=t,l=0;l<s;l++,m+=2)e[l].queryXY(h),this.m_a[m]=h.x,this.m_a[m+1]=h.y}else if(o===1)for(let h=t,m=0;m<s;m++,h++)this.m_a[h]=e[m].getAttributeAsDbl(i,0);else for(let h=t,m=0;m<s;m++,h+=o)for(let l=0;l<o;l++)this.m_a[h+l]=e[m].getAttributeAsDbl(i,l)}eraseRange(t,e,s){this.m_size<t+e&&H(),this.m_a.copyWithin(t,t+e),this.m_size-=e}reverseRange(t,e,s){if((s<1||e%s!==0)&&H(),this.m_a.subarray(t,t+e).reverse(),s>1)for(let i=t,n=t+e;i<n;i+=s){let o=i,a=i+s-1;for(;o<a;){const h=this.m_a[o];this.m_a[o]=this.m_a[a],this.m_a[a]=h,o++,a--}}}rotate(t,e,s){(e<t||e>s||t>s)&&ut("rotate"),e!==t&&e!==s&&(this.reverseRange(t,e-t,1),this.reverseRange(e,s-e,1),this.reverseRange(t,s-t,1))}sort(t,e,s){this.m_a.subarray(t,e).sort(s)}constructor(t){if(t.move)this.m_a=t.move.m_a,this.m_size=t.move.m_size,t.move.m_a=t.move.m_a.slice(0,0),t.move.m_size=0;else if(t.copy)this.m_size=t.copy.m_size,t.maxSize&&(this.m_size=Math.min(t.maxSize,this.m_size)),this.m_a=t.copy.m_a.slice(0,this.m_size);else{const e=Math.max(t.size,ai.s_constructMin);this.m_a=new t.ctor(e),(t.defaultValue||Number.isNaN(t.defaultValue))&&this.m_a.fill(t.defaultValue),this.m_size=t.size}}}ai.s_constructMin=2,ai.s_resizeMin=30;class yn extends ai{setBits(t,e){this.m_a[t]|=e}clearBits(t,e){this.m_a[t]&=~e}getPersistence(){return 4}clone(){return new yn({ctor:Int8Array,copy:this})}restrictedClone(t){return new yn({ctor:Int8Array,copy:this,maxSize:t})}constructor(t,e){super(typeof t=="number"?{ctor:Int8Array,size:t,defaultValue:e}:t)}}class Xt extends ai{getPersistence(){return 2}clone(){return new Xt({ctor:Int32Array,copy:this})}restrictedClone(t){return new Xt({ctor:Int32Array,copy:this,maxSize:t})}write(t,e){b(e<=Ie()),super.write(t,e)}constructor(t,e){super(typeof t=="number"?{ctor:Int32Array,size:t,defaultValue:e}:t)}}class qo extends ai{getPersistence(){return 0}clone(){return new qo({ctor:Float32Array,copy:this})}restrictedClone(t){return new qo({ctor:Float32Array,copy:this,maxSize:t})}constructor(t,e){super(typeof t=="number"?{ctor:Float32Array,size:t,defaultValue:e}:t)}}class Ei extends ai{getPersistence(){return 1}getArray(){return this.m_a}applyTransformation(t,e,s){(1&e||e+2*s>this.size())&&H();const i=e===0?this.m_a:this.m_a.subarray(e);t.transformInterleavedPoints(i,s,i)}readPoint2D(t){const e=this.m_a[t],s=this.m_a[t+1];return new y(e,s)}queryPoint2D(t,e){return e.x=this.m_a[t],e.y=this.m_a[t+1],e}writePoint2D(t,e){this.write(t,e.x),this.write(t+1,e.y)}insert(t,e,s){this.checkResize(s+2),this.m_a.copyWithin(t+2,t,s),this.m_a[t]=e.x,this.m_a[t+1]=e.y}insertRangeFromPoints(t,e,s,i,n,o){const a=this.m_size;if(this.checkResize(Math.max(o,0)+2*i),this.m_a.copyWithin(t+2*i,t,o>=0?o:a),n)for(let h=s,m=t,l=0;l<i;++l,++h){const u=e[h];this.m_a[m++]=u.x,this.m_a[m++]=u.y}else for(let h=s+i-1,m=t,l=0;l<i;++l,--h){const u=e[h];this.m_a[m++]=u.x,this.m_a[m++]=u.y}}queryRange(t,e,s,i,n){if((t<0||e<0)&&H(),!i&&(n<=0||e%n!==0)&&H(),e===0)return;if(e===1)return void(s[0]=this.m_a[t]);const o=this.m_a.subarray(t,t+e);s.set(o)}writeRangeFromArray(t,e,s,i,n){if((t<0||e<0)&&H(),e===0)return;if(e===1)return void(this.m_a[t]=s[0]);let o=s;e<s.length&&(o=s.subarray(0,e)),this.m_a.set(o,t)}clone(){return new Ei({ctor:Float64Array,copy:this})}restrictedClone(t){return new Ei({ctor:Float64Array,copy:this,maxSize:t})}constructor(t,e){super(typeof t=="number"?{ctor:Float64Array,size:t,defaultValue:e}:t)}}function pp(r,t,e,s,i){if(r.getPersistence()!==t.getPersistence())return!1;const n=r.getPersistence()<=1,o=r.size(),a=t.size();if(s>o||s>a)return!1;if(i)if(n){for(let h=e;h<s;h++)if(!An(r.read(h),t.read(h),i))return!1}else for(let h=e;h<s;h++){let m=r.read(h)-t.read(h);if(m<0&&(m=-m),m>i)return!1}else for(let h=e;h<s;h++){const m=r.read(h),l=t.read(h);if(m!==l){if(n&&Number.isNaN(m)&&Number.isNaN(l))continue;return!1}}return!0}function fp(r,t,e,s,i,n){if((t<0||e<0)&&H(),e===0)return;if(e===1)return void(r[t]=s[0]);let o=s;e<s.length&&(o=s.subarray(0,e)),r.set(o,t)}class Ys{constructor(){this.m_minValue=-1,this.m_maxValue=-1,this.m_dy=Number.NaN,this.m_buckets=new Xt(0),this.m_bucketedIndices=new Xt(0)}static sortEx(t,e,s,i,n=32){if(s-e<=n)return void i.userSort(e,s,t);new Ys().sort(t,e,s,i,n)}sort(t,e,s,i,n=32){if(s-e<=n)return void i.userSort(e,s,t);let o=!0,a=Number.POSITIVE_INFINITY,h=Number.NEGATIVE_INFINITY;for(let l=e;l<s;l++){const u=i.getValue(t.read(l));u<a&&(a=u),u>h&&(h=u)}if(this.reset(s-e,a,h,s-e)){for(let u=e;u<s;u++){const c=t.read(u),g=i.getValue(c),_=this.getBucket(g);this.m_buckets.write(_,this.m_buckets.read(_)+1),this.m_bucketedIndices.write(u-e,c)}let l=this.m_buckets.read(0);this.m_buckets.write(0,0);for(let u=1,c=this.m_buckets.size();u<c;u++){const g=this.m_buckets.read(u);this.m_buckets.write(u,l),l+=g}for(let u=e;u<s;u++){const c=this.m_bucketedIndices.read(u-e),g=i.getValue(c),_=this.getBucket(g),d=this.m_buckets.read(_);t.write(d+e,c),this.m_buckets.write(_,d+1)}o=!1}if(o)return void i.userSort(e,s,t);let m=0;for(let l=0,u=this.m_buckets.size();l<u;l++){const c=m;m=this.m_buckets.read(l),m>c&&i.userSort(e+c,e+m,t)}this.m_buckets.size()>100&&(this.m_buckets.resize(0),this.m_bucketedIndices.resize(0))}reset(t,e,s,i){if(t<2||s===e)return!1;const n=Math.min(Ys.c_maxBuckets,t);return this.m_buckets.resize(n),this.m_buckets.setRange(0,0,this.m_buckets.size()),this.m_minValue=e,this.m_maxValue=s,this.m_bucketedIndices.resize(i),this.m_dy=(s-e)/(n-1),!0}getBucket(t){return Math.trunc((t-this.m_minValue)/this.m_dy)}getBucketCount(){return this.m_buckets.size()}}Ys.c_maxBuckets=65536;class At{capacity(){return this.capacity_}constructor(t){this.m_buffer=new Int32Array(0),this.m_firstFree=-1,this.m_last=0,this.size_=0,this.capacity_=0,this.stride=t}size(){return this.size_}deleteElement(t){t<this.m_last?(this.m_buffer[t*this.stride]=this.m_firstFree,this.m_firstFree=t):this.m_last--,this.size_--}getField(t,e){return this.m_buffer[t*this.stride+e]}setField(t,e,s){this.m_buffer[t*this.stride+e]=s}elementToIndex(t){return t}newElement(){let t=this.m_firstFree;if(t===-1){if(this.m_last===this.capacity_){let e=this.capacity_!==0?Math.trunc(3*(this.capacity_+1)/2):1;if(e>Number.MAX_SAFE_INTEGER&&(e=Number.MAX_SAFE_INTEGER),e===this.capacity_)throw new Error("index out of bounds");this.grow_(e)}t=this.m_last,this.m_last++}else this.m_firstFree=this.m_buffer[t*this.stride];this.size_++;for(let e=t*this.stride;e<t*this.stride+this.stride;e++)this.m_buffer[e]=-1;return t}newElementPset(t){let e=this.m_firstFree;if(e===-1){if(this.m_last===this.capacity_){let i=this.capacity_!==0?Math.trunc(3*(this.capacity_+1)/2):1;if(i>Number.MAX_SAFE_INTEGER&&(i=Number.MAX_SAFE_INTEGER),i===this.capacity_)throw new Error("index out of bounds");this.grow_(i)}e=this.m_last,this.m_last++}else this.m_firstFree=this.m_buffer[e*this.stride];this.size_++;const s=e*this.stride;for(let i=0;i<t.length;i++)this.m_buffer[s+i]=t[i];return e}deleteAll(t){this.m_firstFree=-1,this.m_last=0,this.size_=0,t&&(this.m_buffer=new Int32Array(0),this.capacity_=0)}setCapacity(t){t>this.capacity_&&this.grow_(t)}swap(t,e){const s=t*this.stride,i=e*this.stride;for(let n=0;n<this.stride;n++){const o=this.m_buffer[i+n];this.m_buffer[i+n]=this.m_buffer[s+n],this.m_buffer[s+n]=o}}swapField(t,e,s){const i=this.m_buffer[this.stride*e+s];this.m_buffer[this.stride*e+s]=this.m_buffer[this.stride*t+s],this.m_buffer[this.stride*t+s]=i}static impossibleIndex2(){return-2}static impossibleIndex3(){return-3}static isValidElement(t){return t>=0}grow_(t){this.m_buffer==null&&(this.m_buffer=new Int32Array(0));const e=this.stride*t,s=new Int32Array(e);s.set(this.m_buffer,0),this.m_buffer=s,this.capacity_=t}}function xp(r,t){return{element:r,box:t.clone()}}class Pe{constructor(t,e,s){this.m_extent=new F,this.m_dataExtent=new F,this.m_childExtents=[new F,new F,new F,new F],this.m_elementNodes=new At(4),this.m_data=[],this.m_freeData=[],this.m_root=-1,this.m_height=8,s===void 0&&(s=!1),this.m_quadTreeNodes=new At(s?11:10),this.m_bStoreDuplicates=s,this.reset_(t,e)}reset(t,e){this.m_quadTreeNodes.deleteAll(!1),this.m_elementNodes.deleteAll(!1),this.m_data.length=0,this.m_freeData.length=0,this.reset_(t,e)}insert(t,e){if(this.m_root===-1&&this.createRoot_(),this.m_bStoreDuplicates){const i=this.insertDuplicates_(t,e,0,this.m_extent,this.m_root,!1,-1);return i!==-1&&(this.m_dataExtent.isEmpty()?this.m_dataExtent.setCoords({env2D:e}):this.m_dataExtent.mergeEnvelope2D(e)),i}const s=this.insert_(t,e,0,this.m_extent,this.m_root,!1,-1);return s!==-1&&(this.m_dataExtent.isEmpty()?this.m_dataExtent.setCoords({env2D:e}):this.m_dataExtent.mergeEnvelope2D(e)),s}insertEx(t,e,s){if(this.m_root===-1&&this.createRoot_(),this.m_bStoreDuplicates){const h=this.insertDuplicates_(t,e,0,this.m_extent,this.m_root,!1,-1);return h!==-1&&(this.m_dataExtent.isEmpty()?this.m_dataExtent.setCoords({env2D:e}):this.m_dataExtent.mergeEnvelope2D(e)),h}let i;i=s===-1?this.m_root:this.getQuad_(s);const n=this.getHeight(i),o=this.getExtent(i),a=this.insert_(t,e,n,o,i,!1,-1);return a!==-1&&(this.m_dataExtent.isEmpty()?this.m_dataExtent.setCoords({env2D:e}):this.m_dataExtent.mergeEnvelope2D(e)),a}removeElement(t){b(0)}getElement(t){return this.getElementValue_(this.getData_(t))}getElementAtIndex(t){return b(0),0}getElementExtent(t){const e=this.getData_(t);return this.getBoundingBoxValue_(e).clone()}getElementExtentAtIndex(t){return b(0),{}}getDataExtent(){return this.m_dataExtent.clone()}getQuadTreeExtent(){return b(0),{}}getHeight(t){return this.m_quadTreeNodes.getField(t,6)>>Pe.m_heightBitShift}getMaxHeight(){return this.m_height}getExtent(t){const e=new F;if(e.setCoords({env2D:this.m_extent}),t===this.m_root)return e;const s=[];let i=t;do s.push(this.getQuadrant_(i)),i=this.getParent_(i);while(i!==this.m_root);const n=s.length;for(let o=0;o<n;o++){const a=s.at(-1);s.pop(),a===0?(e.xmin=.5*(e.xmin+e.xmax),e.ymin=.5*(e.ymin+e.ymax)):a===1?(e.xmax=.5*(e.xmin+e.xmax),e.ymin=.5*(e.ymin+e.ymax)):a===2?(e.xmax=.5*(e.xmin+e.xmax),e.ymax=.5*(e.ymin+e.ymax)):(e.xmin=.5*(e.xmin+e.xmax),e.ymax=.5*(e.ymin+e.ymax))}return e}getQuad(t){return this.getQuad_(t)}getElementCount(){return this.m_root===-1?0:this.getSubTreeElementCount_(this.m_root)}getSubTreeElementCount(t){return this.getSubTreeElementCount_(t)}getContainedSubTreeElementCount(t){return this.m_bStoreDuplicates?this.getContainedSubTreeElementCount_(t):this.getSubTreeElementCount_(t)}getIntersectionCount(t,e,s){if(this.m_root===-1)return 0;const i=new F;i.setCoords({env2D:t}),i.inflateCoords(e,e);const n=[],o=[];n.push(this.m_root),o.push(this.m_extent.clone());const a=R(F,4);let h=0;for(;n.length>0;){let m=!1;const l=n.at(-1),u=o.at(-1);if(n.pop(),o.pop(),i.containsEnvelope(u)){if(h+=this.getSubTreeElementCount(l),s>0&&h>=s)return s}else if(i.isIntersecting(u)){for(let c=this.getFirstElement_(l);c!==-1;c=this.getNextElement_(c)){const g=this.getData_(c);if(this.getBoundingBoxValue_(g).isIntersecting(i)&&(h++,s>0&&h>=s))return s}m=this.getHeight(l)+1<=this.m_height}if(m){Pe.setChildExtents_(u,a);for(let c=0;c<4;c++){const g=this.getChild_(l,c);g!==-1&&this.getSubTreeElementCount_(g)>0&&i.isIntersecting(a[c])&&(n.push(g),o.push(a[c].clone()))}}}return h}hasData(t,e){return this.getIntersectionCount(t,e,1)>=1}getIterator(t,e){return new vl(this,t,e)}getIteratorForQT(){return new vl(this)}getSortedIterator(t,e){return new bl(this.getIterator(t,e))}getSortedIteratorForQT(){return new bl(this.getIteratorForQT())}visitLeavesNearest(t,e,s,i){b(0)}reset_(t,e){(e<0||e>127)&&H("invalid height"),this.m_height=e,this.m_extent.setCoords({env2D:t}),this.m_dataExtent.setEmpty(),this.m_root=-1}insert_(t,e,s,i,n,o,a){if(!i.containsEnvelope(e))return s===0?-1:this.insert_(t,e,0,this.m_extent,this.m_root,o,a);if(!o)for(let u=n;u!==-1;u=this.getParent_(u))this.setSubTreeElementCount_(u,this.getSubTreeElementCount_(u)+1);const h=new F;h.setCoords({env2D:i});let m,l=n;for(m=s;m<this.m_height&&this.canPushDown_(l);m++){Pe.setChildExtents_(h,this.m_childExtents);let u=!1;for(let c=0;c<4;c++)if(this.m_childExtents[c].containsEnvelope(e)){u=!0;let g=this.getChild_(l,c);g===-1&&(g=this.createChild_(l,c)),this.setSubTreeElementCount_(g,this.getSubTreeElementCount_(g)+1),l=g,h.setCoords({env2D:this.m_childExtents[c]});break}if(!u)break}return this.insertAtQuad_(t,e,m,h,l,o,n,a,-1)}insertDuplicates_(t,e,s,i,n,o,a){if(!o){if(!i.containsEnvelope(e))return-1;this.setSubTreeElementCount_(n,this.getSubTreeElementCount_(n)+1),this.setContainedSubTreeElementCount_(n,this.getContainedSubTreeElementCount_(n)+1)}const h=Math.max(e.width(),e.height());let m=-1;const l=[],u=[],c=[];l.push(n),u.push(i.clone()),c.push(s);const g=R(F,4);for(;l.length>0;){let _=!1;const d=l.at(-1),p=u.at(-1),f=c.at(-1);if(l.pop(),u.pop(),c.pop(),f+1<this.m_height&&this.canPushDown_(d)&&h<=Math.max(p.width(),p.height())/2&&(_=!0),_){Pe.setChildExtents_(p,g);let x=!1;for(let E=0;E<4;E++)if(x=g[E].containsEnvelope(e),x){let P=this.getChild_(d,E);P===-1&&(P=this.createChild_(d,E)),l.push(P),u.push(g[E].clone()),c.push(f+1),this.setSubTreeElementCount_(P,this.getSubTreeElementCount_(P)+1),this.setContainedSubTreeElementCount_(P,this.getContainedSubTreeElementCount_(P)+1);break}if(!x){for(let E=0;E<4;E++)if(g[E].isIntersecting(e)){let P=this.getChild_(d,E);P===-1&&(P=this.createChild_(d,E)),l.push(P),u.push(g[E].clone()),c.push(f+1),this.setSubTreeElementCount_(P,this.getSubTreeElementCount_(P)+1)}}}else m=this.insertAtQuad_(t,e,f,p,d,o,n,a,m),o=!1}return 0}insertAtQuad_(t,e,s,i,n,o,a,h,m){this.getFirstElement_(n);const l=this.getLastElement_(n);let u=-1;if(o){if(n===a)return h;this.disconnectElementHandle_(h),u=h}else m===-1?(u=this.createElement_(),this.setDataValues_(this.getData_(u),t,e)):u=this.createElementFromDuplicate_(m);return this.setQuad_(u,n),l!==-1?(this.setPrevElement_(u,l),this.setNextElement_(l,u)):this.setFirstElement_(n,u),this.setLastElement_(n,u),this.setLocalElementCount_(n,this.getLocalElementCount_(n)+1),this.canFlush_(n)&&this.flush_(s,i,n),u}static setChildExtents_(t,e){const s=.5*(t.xmin+t.xmax),i=.5*(t.ymin+t.ymax);e[0].setCoords({xmin:s,ymin:i,xmax:t.xmax,ymax:t.ymax}),e[1].setCoords({xmin:t.xmin,ymin:i,xmax:s,ymax:t.ymax}),e[2].setCoords({xmin:t.xmin,ymin:t.ymin,xmax:s,ymax:i}),e[3].setCoords({xmin:s,ymin:t.ymin,xmax:t.xmax,ymax:i})}disconnectElementHandle_(t){const e=this.getQuad_(t),s=this.getFirstElement_(e),i=this.getLastElement_(e),n=this.getPrevElement_(t),o=this.getNextElement_(t);s===t?(o!==-1?this.setPrevElement_(o,-1):this.setLastElement_(e,-1),this.setFirstElement_(e,o)):i===t?(this.setNextElement_(n,-1),this.setLastElement_(e,n)):(this.setPrevElement_(o,n),this.setNextElement_(n,o)),this.setPrevElement_(t,-1),this.setNextElement_(t,-1),this.setLocalElementCount_(e,this.getLocalElementCount_(e)-1)}canFlush_(t){return this.getLocalElementCount_(t)===Pe.m_flushingCount&&!this.hasChildren_(t)}flush_(t,e,s){let i;const n=new F;let o=this.getFirstElement_(s),a=-1,h=-1;do h=this.getData_(o),i=this.getElementValue_(h),n.setCoords({env2D:this.getBoundingBoxValue_(h)}),a=this.getNextElement_(o),this.m_bStoreDuplicates?this.insertDuplicates_(i,n,t,e,s,!0,o):this.insert_(i,n,t,e,s,!0,o),o=a;while(o!==-1)}canPushDown_(t){return this.getLocalElementCount_(t)>=Pe.m_flushingCount||this.hasChildren_(t)}hasChildren_(t){return this.getChild_(t,0)!==-1||this.getChild_(t,1)!==-1||this.getChild_(t,2)!==-1||this.getChild_(t,3)!==-1}createChild_(t,e){const s=this.m_quadTreeNodes.newElement();return this.setChild_(t,e,s),this.setSubTreeElementCount_(s,0),this.setLocalElementCount_(s,0),this.setParent_(s,t),this.setHeightAndQuadrant_(s,this.getHeight_(t)+1,e),this.m_bStoreDuplicates&&this.setContainedSubTreeElementCount_(s,0),s}createRoot_(){this.m_root=this.m_quadTreeNodes.newElement(),this.setSubTreeElementCount_(this.m_root,0),this.setLocalElementCount_(this.m_root,0),this.setHeightAndQuadrant_(this.m_root,0,0),this.m_bStoreDuplicates&&this.setContainedSubTreeElementCount_(this.m_root,0)}createElement_(){const t=this.m_elementNodes.newElement();let e;return this.m_freeData.length>0?(e=this.m_freeData.at(-1),this.m_freeData.pop()):(e=this.m_data.length,this.m_data.length=e+1),this.setData_(t,e),t}createElementFromDuplicate_(t){const e=this.m_elementNodes.newElement(),s=this.getData_(t);return this.setData_(e,s),e}freeElementAndBoxNode_(t){b(0)}getChild_(t,e){return this.m_quadTreeNodes.getField(t,e)}setChild_(t,e,s){this.m_quadTreeNodes.setField(t,e,s)}getFirstElement_(t){return this.m_quadTreeNodes.getField(t,4)}setFirstElement_(t,e){this.m_quadTreeNodes.setField(t,4,e)}getLastElement_(t){return this.m_quadTreeNodes.getField(t,5)}setLastElement_(t,e){this.m_quadTreeNodes.setField(t,5,e)}getQuadrant_(t){return this.m_quadTreeNodes.getField(t,6)&Pe.m_quadrantMask}getHeight_(t){return this.m_quadTreeNodes.getField(t,6)>>Pe.m_heightBitShift}setHeightAndQuadrant_(t,e,s){const i=e<<Pe.m_heightBitShift|s;this.m_quadTreeNodes.setField(t,6,i)}getLocalElementCount_(t){return this.m_quadTreeNodes.getField(t,7)}setLocalElementCount_(t,e){this.m_quadTreeNodes.setField(t,7,e)}getSubTreeElementCount_(t){return this.m_quadTreeNodes.getField(t,8)}setSubTreeElementCount_(t,e){this.m_quadTreeNodes.setField(t,8,e)}getParent_(t){return this.m_quadTreeNodes.getField(t,9)}setParent_(t,e){this.m_quadTreeNodes.setField(t,9,e)}getContainedSubTreeElementCount_(t){return this.m_quadTreeNodes.getField(t,10)}setContainedSubTreeElementCount_(t,e){this.m_quadTreeNodes.setField(t,10,e)}getData_(t){return this.m_elementNodes.getField(t,0)}setData_(t,e){this.m_elementNodes.setField(t,0,e)}getPrevElement_(t){return this.m_elementNodes.getField(t,1)}getNextElement_(t){return this.m_elementNodes.getField(t,2)}setPrevElement_(t,e){this.m_elementNodes.setField(t,1,e)}setNextElement_(t,e){this.m_elementNodes.setField(t,2,e)}getQuad_(t){return this.m_elementNodes.getField(t,3)}setQuad_(t,e){this.m_elementNodes.setField(t,3,e)}getElementValue_(t){return this.m_data[t].element}getBoundingBoxValue_(t){return this.m_data[t].box}setDataValues_(t,e,s){this.m_data[t]=xp(e,s)}}Pe.m_quadrantMask=3,Pe.m_heightBitShift=2,Pe.m_flushingCount=5;class vl{constructor(t,e,s){this.m_bLinear=!1,this.m_queryStart=new y,this.m_queryEnd=new y,this.m_queryBox=new F,this.m_tolerance=0,this.m_currentElementHandle=-1,this.m_nextElementHandle=-1,this.m_quadsStack=[],this.m_extentsStack=[],this.m_childExtents=[new F,new F,new F,new F],this.m_quadTree=t,e&&this.resetIterator(e,s)}resetIterator(t,e){if(e===void 0&&(e=0),t instanceof F)return this.m_quadsStack.length=0,this.m_extentsStack.length=0,this.m_currentElementHandle=-1,this.m_queryBox.setCoords({env2D:t}),this.m_queryBox.inflateCoords(e,e),this.m_tolerance=Number.NaN,void(this.m_quadTree.m_root!==-1&&this.m_queryBox.isIntersecting(this.m_quadTree.m_extent)?(this.m_quadsStack.push(this.m_quadTree.m_root),this.m_extentsStack.push(this.m_quadTree.m_extent.clone()),this.m_nextElementHandle=this.m_quadTree.getFirstElement_(this.m_quadTree.m_root),this.m_bLinear=!1):this.m_nextElementHandle=-1);if(this.m_quadsStack.length=0,this.m_extentsStack.length=0,this.m_currentElementHandle=-1,t.queryLooseEnvelope(this.m_queryBox),this.m_queryBox.inflateCoords(e,e),this.m_quadTree.m_root!==-1&&this.m_queryBox.isIntersecting(this.m_quadTree.m_extent)){const s=t.getGeometryType();if(this.m_bLinear=s===T.enumLine,this.m_bLinear){const i=t;this.m_queryStart.assign(i.getStartXY()),this.m_queryEnd.assign(i.getEndXY()),this.m_tolerance=e}else this.m_tolerance=Number.NaN;this.m_quadsStack.push(this.m_quadTree.m_root),this.m_extentsStack.push(this.m_quadTree.m_extent.clone()),this.m_nextElementHandle=this.m_quadTree.getFirstElement_(this.m_quadTree.m_root)}else this.m_nextElementHandle=-1}next(){if(this.m_quadsStack.length===0)return-1;this.m_currentElementHandle=this.m_nextElementHandle;const t=new y,e=new y,s=new F;let i=!1;for(;!i;){for(;this.m_currentElementHandle!==-1;){const n=this.m_quadTree.getData_(this.m_currentElementHandle);if(s.setCoords({env2D:this.m_quadTree.getBoundingBoxValue_(n)}),s.isIntersecting(this.m_queryBox)){if(!this.m_bLinear){i=!0;break}if(t.setCoordsPoint2D(this.m_queryStart),e.setCoordsPoint2D(this.m_queryEnd),s.inflateCoords(this.m_tolerance,this.m_tolerance),s.clipLine(t,e)>0){i=!0;break}}this.m_currentElementHandle=this.m_quadTree.getNextElement_(this.m_currentElementHandle)}if(this.m_currentElementHandle===-1){const n=this.m_quadsStack.at(-1),o=this.m_extentsStack.at(-1);Pe.setChildExtents_(o,this.m_childExtents),this.m_quadsStack.pop(),this.m_extentsStack.pop();for(let a=0;a<4;a++){const h=this.m_quadTree.getChild_(n,a);if(h!==-1&&this.m_quadTree.getSubTreeElementCount(h)>0&&this.m_childExtents[a].isIntersecting(this.m_queryBox))if(this.m_bLinear){t.setCoordsPoint2D(this.m_queryStart),e.setCoordsPoint2D(this.m_queryEnd);const m=new F;m.setCoords({env2D:this.m_childExtents[a]}),m.inflateCoords(this.m_tolerance,this.m_tolerance),m.clipLine(t,e)>0&&(this.m_quadsStack.push(h),this.m_extentsStack.push(this.m_childExtents[a].clone()))}else this.m_quadsStack.push(h),this.m_extentsStack.push(this.m_childExtents[a].clone())}if(this.m_quadsStack.length===0)return-1;this.m_currentElementHandle=this.m_quadTree.getFirstElement_(this.m_quadsStack.at(-1))}}return this.m_nextElementHandle=this.m_quadTree.getNextElement_(this.m_currentElementHandle),this.m_currentElementHandle}clone(){return b(0),{}}}class bl{constructor(t){this.m_bucketSort=new Ys,this.m_sortedHandles=new Xt(0),this.m_index=-1,this.m_quadTreeIteratorImpl=t}resetIterator(t,e){this.m_quadTreeIteratorImpl.resetIterator(t,e),this.m_sortedHandles.resize(0),this.m_index=-1}next(){if(this.m_index===-1){let t=-1;for(;(t=this.m_quadTreeIteratorImpl.next())!==-1;)this.m_sortedHandles.add(t);const e=this,s={userSort(i,n,o){o.sort(i,n,(a,h)=>e.m_quadTreeIteratorImpl.m_quadTree.getElement(a)-e.m_quadTreeIteratorImpl.m_quadTree.getElement(h))},getValue:i=>e.m_quadTreeIteratorImpl.m_quadTree.getElement(i)};this.m_bucketSort.sort(this.m_sortedHandles,0,this.m_sortedHandles.size(),s)}return this.m_index===this.m_sortedHandles.size()-1?-1:(this.m_index++,this.m_sortedHandles.read(this.m_index))}clone(){return b(0),{}}}class tn{constructor(t=!1){this.m_bNotifyOnActions=t}onDelete(t){}onSet(t){}onEndSearch(t){}onAddUniqueElementFailed(t){}onDeleteImpl(t,e){this.m_bNotifyOnActions&&this.onDelete(t.getElement(e))}onSetImpl(t,e){this.m_bNotifyOnActions&&this.onSet(t.getElement(e))}onAddUniqueElementFailedImpl(t){this.m_bNotifyOnActions&&this.onAddUniqueElementFailed(t)}onEndSearchImpl(t){this.m_bNotifyOnActions&&this.onEndSearch(t)}}class tt{static st_nullNode(){return-1}constructor(){this.m_defaultTreap=-1,this.m_random=124234251,this.m_comparator=null,this.m_treapData=new At(7),this.m_treapCount=0,this.m_maxDepthEver=0,this.m_bBalancing=!0}setComparator(t){this.m_comparator=t}getComparator(){return this.m_comparator}disableBalancing(){this.m_bBalancing=!1}enableBalancing(){this.m_bBalancing||(b(this.m_treapCount<=1),this.rebalance(-1),this.m_bBalancing=!0)}isAutoBalancing(){return this.m_bBalancing}rebalance(t){if(this.m_bBalancing||(t===-1&&(t=this.m_defaultTreap),this.size(t)===0))return;const e=[];for(let s=this.getFirst(t);s!==-1;s=this.getNext(s))e.push(s),this.setParent_(s,-1),this.setRight_(s,-1),this.setLeft_(s,-1);this.setRoot_(-1,t),this.setFirst_(-1,t),this.setLast_(-1,t),this.setSize_(0,t),this.m_bBalancing=!0;for(const s of e)this.addBiggestElement_(s,t);this.m_bBalancing=!1}setCapacity(t){this.m_treapData.setCapacity(t)}createTreap(t){const e=this.m_treapData.newElement();return this.setSize_(0,e),this.setTreapData_(t,e),this.m_treapCount++,e}deleteTreap(t){this.m_treapData.deleteElement(t),this.m_treapCount--}addElement(t,e=-1){return e===-1&&(this.m_defaultTreap===tt.st_nullNode()&&(this.m_defaultTreap=this.createTreap(-1)),e=this.m_defaultTreap),this.addElement_(t,0,e)}addUniqueElement(t,e=-1){return e===-1&&(this.m_defaultTreap===tt.st_nullNode()&&(this.m_defaultTreap=this.createTreap(-1)),e=this.m_defaultTreap),this.addElement_(t,1,e)}addBiggestElement(t,e=-1){e===-1&&(this.m_defaultTreap===tt.st_nullNode()&&(this.m_defaultTreap=this.createTreap(-1)),e=this.m_defaultTreap);const s=this.newNode_(t);return this.addBiggestElement_(s,e),s}addElementAtPosition(t,e,s,i,n,o=-1){if(o===-1&&(this.m_defaultTreap===tt.st_nullNode()&&(this.m_defaultTreap=this.createTreap(-1)),o=this.m_defaultTreap),this.getRoot_(o)===tt.st_nullNode()){const d=this.newNode_(s);return this.setRoot_(d,o),this.addToList_(-1,d,o),d}let a,h,m,l,u;if(n?(a=e!==tt.st_nullNode()?this.m_comparator.compare(this,s,e):-1,h=t!==tt.st_nullNode()?this.m_comparator.compare(this,s,t):1):(a=-1,h=1),i&&(a===0||h===0)){this.m_comparator.onAddUniqueElementFailedImpl(s);const d=a===0?e:t;return this.setDuplicateElement_(d,o),-1}u=e!==tt.st_nullNode()&&t!==tt.st_nullNode()?this.m_random>dn(this.m_random)>>1:e!==tt.st_nullNode(),u?(l=a,m=e):(l=h,m=t);let c=-1,g=-1,_=!0;for(;;){if(l<0){const d=this.getLeft(m);if(d===tt.st_nullNode()){g=m,c=this.newNode_(s),this.setLeft_(m,c),this.setParent_(c,m);break}m=d}else{const d=this.getRight(m);if(d===tt.st_nullNode()){g=this.getNext(m),c=this.newNode_(s),this.setRight_(m,c),this.setParent_(c,m);break}m=d}_&&(l*=-1,_=!1)}return this.bubbleUp_(c),this.getParent(c)===tt.st_nullNode()&&this.setRoot_(c,o),this.addToList_(g,c,o),c}replaceElementAtPosition(t,e,s,i,n=-1){if(i){const o=this.getNext(t);let a=-1;o!==tt.st_nullNode()&&(a=this.m_comparator.compare(this,e,o));const h=this.getPrev(t);let m=-1;if(h!==tt.st_nullNode()&&(m=this.m_comparator.compare(this,e,h)),s&&(a===0||m===0)){this.m_comparator.onAddUniqueElementFailedImpl(e);const l=a===0?o:h;return n===tt.st_nullNode()&&(this.m_defaultTreap===tt.st_nullNode()&&(this.m_defaultTreap=this.createTreap(-1)),n=this.m_defaultTreap),this.setDuplicateElement_(l,n),-1}}return this.setElement_(t,e),t}getDuplicateElement(t=-1){return t===-1?this.getDuplicateElement_(this.m_defaultTreap):this.getDuplicateElement_(t)}deleteNode(t,e=-1){this.m_comparator&&this.m_comparator.onDeleteImpl(this,t),e===-1&&(e=this.m_defaultTreap),this.m_bBalancing?this.deleteNode_(t,e):this.unbalancedDelete_(t,e)}search(t,e=-1){let s=this.getRoot(e);for(;s!==tt.st_nullNode();){const i=this.m_comparator.compare(this,t,s);if(!i)return s;s=i<0?this.getLeft(s):this.getRight(s)}return this.m_comparator.onEndSearchImpl(t),tt.st_nullNode()}searchLowerBound(t,e=-1){let s=this.getRoot(e),i=-1;for(;s!==tt.st_nullNode();){const n=t.compare(this,s);if(!n)return s;n<0?s=this.getLeft(s):(i=s,s=this.getRight(s))}return i}searchUpperBound(t,e=-1){let s=this.getRoot(e),i=-1;for(;s!==tt.st_nullNode();){const n=t.compare(this,s);if(!n)return s;n<0?(i=s,s=this.getLeft(s)):s=this.getRight(s)}return i}getElement(t){return this.m_treapData.getField(t,3)}getLeft(t){return this.m_treapData.getField(t,0)}getRight(t){return this.m_treapData.getField(t,1)}getParent(t){return this.m_treapData.getField(t,2)}getNext(t){return this.m_treapData.getField(t,6)}getPrev(t){return this.m_treapData.getField(t,5)}getFirst(t=-1){return t===-1?this.getFirst_(this.m_defaultTreap):this.getFirst_(t)}getLast(t=-1){return t===-1?this.getLast_(this.m_defaultTreap):this.getLast_(t)}getTreapData(t=-1){return t===-1?this.getTreapData_(this.m_defaultTreap):this.getTreapData_(t)}setElement(t,e){this.m_comparator!==null&&this.m_comparator.onSetImpl(this,t),this.setElement_(t,e)}getRoot(t=-1){return t===-1?this.getRoot_(this.m_defaultTreap):this.getRoot_(t)}clear(){this.m_treapData.deleteAll(!1),this.m_defaultTreap=tt.st_nullNode(),this.m_treapCount=0,this.m_maxDepthEver=0}addToList_(t,e,s){let i;t!==-1?(i=this.getPrev(t),this.setPrev_(t,e)):i=this.getLast_(s),this.setPrev_(e,i),i!==-1&&this.setNext_(i,e),this.setNext_(e,t),t===this.getFirst_(s)&&this.setFirst_(e,s),t===-1&&this.setLast_(e,s),this.setSize_(this.getSize_(s)+1,s)}size(t=-1){return t===-1?this.getSize_(this.m_defaultTreap):this.getSize_(t)}getMaxDepth(t=-1){return this.getMaxDepthHelper_(this.getRoot(t))}getMaxDepthEver(){return this.m_maxDepthEver}static st_isValidNode(t){return At.isValidElement(t)}dbgCheck_(t){}getPriority_(t){return this.m_treapData.getField(t,4)}bubbleDown_(t){let e=this.getLeft(t),s=this.getRight(t);const i=this.getPriority_(t);for(;e!==tt.st_nullNode()||s!==tt.st_nullNode();){const n=e!==tt.st_nullNode()?this.getPriority_(e):we(),o=s!==tt.st_nullNode()?this.getPriority_(s):we();if(i<=Math.min(n,o))return;n<=o?this.rotateRight_(e):this.rotateLeft_(t),e=this.getLeft(t),s=this.getRight(t)}}bubbleUp_(t){if(!this.m_bBalancing)return;const e=this.getPriority_(t);let s=this.getParent(t);for(;s!==tt.st_nullNode()&&this.getPriority_(s)>e;)this.getLeft(s)===t?this.rotateRight_(t):this.rotateLeft_(s),s=this.getParent(t)}rotateLeft_(t){const e=t,s=this.getRight(t);let i;this.setParent_(s,this.getParent(e)),this.setParent_(e,s),i=this.getLeft(s),this.setRight_(e,i),i!==tt.st_nullNode()&&this.setParent_(i,e),this.setLeft_(s,e),i=this.getParent(s),i!==tt.st_nullNode()&&(this.getLeft(i)===e?this.setLeft_(i,s):this.setRight_(i,s))}rotateRight_(t){const e=this.getParent(t),s=t;let i;this.setParent_(s,this.getParent(e)),this.setParent_(e,s),i=this.getRight(s),this.setLeft_(e,i),i!==tt.st_nullNode()&&this.setParent_(i,e),this.setRight_(s,e),i=this.getParent(s),i!==tt.st_nullNode()&&(this.getLeft(i)===e?this.setLeft_(i,s):this.setRight_(i,s))}setParent_(t,e){this.m_treapData.setField(t,2,e)}setLeft_(t,e){this.m_treapData.setField(t,0,e)}setRight_(t,e){this.m_treapData.setField(t,1,e)}setPriority_(t,e){this.m_treapData.setField(t,4,e)}setPrev_(t,e){this.m_treapData.setField(t,5,e)}setNext_(t,e){this.m_treapData.setField(t,6,e)}setRoot_(t,e){this.m_treapData.setField(e,0,t)}setFirst_(t,e){this.m_treapData.setField(e,1,t)}setLast_(t,e){this.m_treapData.setField(e,2,t)}setDuplicateElement_(t,e){this.m_treapData.setField(e,3,t)}setSize_(t,e){this.m_treapData.setField(e,4,t)}setTreapData_(t,e){this.m_treapData.setField(e,5,t)}getRoot_(t){return t===-1?tt.st_nullNode():this.m_treapData.getField(t,0)}getFirst_(t){return t===-1?tt.st_nullNode():this.m_treapData.getField(t,1)}getLast_(t){return t===-1?tt.st_nullNode():this.m_treapData.getField(t,2)}getDuplicateElement_(t){return t===-1?tt.st_nullNode():this.m_treapData.getField(t,3)}getSize_(t){return t===-1?0:this.m_treapData.getField(t,4)}getTreapData_(t){return this.m_treapData.getField(t,5)}newNode_(t){const e=this.m_treapData.newElement();return this.setPriority_(e,this.generatePriority_()),this.setElement_(e,t),e}freeNode_(t,e){t!==tt.st_nullNode()&&this.m_treapData.deleteElement(t)}generatePriority_(){return this.m_random=dn(this.m_random),this.m_random&we()>>1}maxPriority(){return b(0),0}getMaxDepthHelper_(t){return t===tt.st_nullNode()?0:1+Math.max(this.getMaxDepthHelper_(this.getLeft(t)),this.getMaxDepthHelper_(this.getRight(t)))}addElement_(t,e,s){if(this.getRoot(s)===tt.st_nullNode()){const h=this.newNode_(t);return this.setRoot_(h,s),this.addToList_(-1,h,s),this.m_maxDepthEver=Math.max(this.m_maxDepthEver,1),h}let i=this.getRoot_(s),n=-1,o=-1,a=1;for(;;){const h=e===-1?1:this.m_comparator.compare(this,t,i);if(h<0){const m=this.getLeft(i);if(m===tt.st_nullNode()){o=i,n=this.newNode_(t),this.setLeft_(i,n),this.setParent_(n,i);break}i=m}else{if(e===1&&h===0)return this.m_comparator.onAddUniqueElementFailedImpl(t),this.setDuplicateElement_(i,s),-1;const m=this.getRight(i);if(m===tt.st_nullNode()){o=this.getNext(i),n=this.newNode_(t),this.setRight_(i,n),this.setParent_(n,i);break}i=m}a++}return this.bubbleUp_(n),this.getParent(n)===tt.st_nullNode()&&this.setRoot_(n,s),this.addToList_(o,n,s),this.m_maxDepthEver=Math.max(a,this.m_maxDepthEver),n}removeFromList_(t,e){const s=this.getPrev(t),i=this.getNext(t);s!==-1?this.setNext_(s,i):this.setFirst_(i,e),i!==-1?this.setPrev_(i,s):this.setLast_(s,e),this.setSize_(this.getSize_(e)-1,e)}unbalancedDelete_(t,e){this.removeFromList_(t,e);let s=this.getLeft(t),i=this.getRight(t),n=this.getParent(t),o=t;if(s!==-1&&i!==-1){let h;this.m_random=dn(this.m_random),h=this.m_random>we()>>1?this.getNext(t):this.getPrev(t);const m=this.getParent(h)===t;this.m_treapData.swapField(t,h,0),this.m_treapData.swapField(t,h,1),this.m_treapData.swapField(t,h,2),n!==-1?this.getLeft(n)===t?this.setLeft_(n,h):this.setRight_(n,h):this.setRoot_(h,e),m?(s===h?(this.setLeft_(h,t),this.setParent_(i,h)):i===h&&(this.setRight_(h,t),this.setParent_(s,h)),this.setParent_(t,h),n=h):(this.setParent_(s,h),this.setParent_(i,h),n=this.getParent(t),o=h),s=this.getLeft(t),i=this.getRight(t),s!==-1&&this.setParent_(s,t),i!==-1&&this.setParent_(i,t)}const a=s!==-1?s:i;n===-1?this.setRoot_(a,e):this.getLeft(n)===o?this.setLeft_(n,a):this.setRight_(n,a),a!==-1&&this.setParent_(a,n),this.freeNode_(t,e)}deleteNode_(t,e){this.setPriority_(t,we());let s=tt.st_nullNode(),i=tt.st_nullNode();const n=this.getRoot_(e),o=n===t;if(o&&(s=this.getLeft(n),i=this.getRight(n),s===tt.st_nullNode()&&i===tt.st_nullNode()))return this.removeFromList_(n,e),this.freeNode_(n,e),void this.setRoot_(tt.st_nullNode(),e);this.bubbleDown_(t);const a=this.getParent(t);a!==tt.st_nullNode()&&(this.getLeft(a)===t?this.setLeft_(a,tt.st_nullNode()):this.setRight_(a,tt.st_nullNode())),this.removeFromList_(t,e),this.freeNode_(t,e),o&&this.setRoot_(s===tt.st_nullNode()||this.getParent(s)!==tt.st_nullNode()?i:s,e)}setElement_(t,e){this.m_treapData.setField(t,3,e)}addBiggestElement_(t,e){if(this.getRoot_(e)===tt.st_nullNode())return this.setRoot_(t,e),void this.addToList_(-1,t,e);const s=this.getLast_(e);this.setRight_(s,t),this.setParent_(t,s),this.bubbleUp_(t),this.getParent(t)===tt.st_nullNode()&&this.setRoot_(t,e),this.addToList_(-1,t,e)}}class ge{constructor(t){this.m_lists=new At(6),this.m_listOfLists=ge.st_nullNode(),t===void 0?(this.m_listNodes=new At(3),this.m_bStoreListIndexWithNode=!1):(this.m_listNodes=new At(t?4:3),this.m_bStoreListIndexWithNode=t)}freeNode_(t){this.m_listNodes.deleteElement(t)}newNode_(){return this.m_listNodes.newElement()}freeList_(t){b(0)}newList_(){return this.m_lists.newElement()}setPrev_(t,e){this.m_listNodes.setField(t,1,e)}setNext_(t,e){this.m_listNodes.setField(t,2,e)}setData_(t,e){b(0)}setList_(t,e){return this.m_listNodes.setField(t,3,e)}setListSize_(t,e){this.m_lists.setField(t,4,e)}setNextList_(t,e){b(0)}setPrevList_(t,e){this.m_lists.setField(t,2,e)}createList(t){const e=this.newList_();return this.m_lists.setField(e,3,this.m_listOfLists),this.m_lists.setField(e,4,0),this.m_lists.setField(e,5,t),this.m_listOfLists!==ge.st_nullNode()&&this.setPrevList_(this.m_listOfLists,e),this.m_listOfLists=e,e}deleteList(t){this.clear(t);const e=this.m_lists.getField(t,2),s=this.m_lists.getField(t,3);return e!==ge.st_nullNode()?this.setNextList_(e,s):this.m_listOfLists=s,s!==ge.st_nullNode()&&this.setPrevList_(s,e),this.freeList_(t),s}reserveLists(t){b(0)}getListData(t){return this.m_lists.getField(t,5)}getList(t){return b(0),0}setListData(t,e){this.m_lists.setField(t,5,e)}addElement(t,e){return this.insertElement(t,-1,e)}insertElement(t,e,s){const i=this.newNode_();let n=-1;if(e!==ge.st_nullNode()&&(n=this.getPrev(e),this.setPrev_(e,i)),this.setNext_(i,e),n!==ge.st_nullNode()&&this.setNext_(n,i),e===this.m_lists.getField(t,0)&&this.m_lists.setField(t,0,i),e===ge.st_nullNode()){const o=this.m_lists.getField(t,1);this.setPrev_(i,o),o!==-1&&this.setNext_(o,i),this.m_lists.setField(t,1,i)}return this.setData(i,s),this.setListSize_(t,this.getListSize(t)+1),this.m_bStoreListIndexWithNode&&this.setList_(i,t),i}deleteElement(t,e){const s=this.getPrev(e),i=this.getNext(e);return s!==ge.st_nullNode()?this.setNext_(s,i):this.m_lists.setField(t,0,i),i!==ge.st_nullNode()?this.setPrev_(i,s):this.m_lists.setField(t,1,s),this.freeNode_(e),this.setListSize_(t,this.getListSize(t)-1),i}reserveNodes(t){this.m_listNodes.setCapacity(t)}getData(t){return this.m_listNodes.getField(t,0)}getElement(t){return this.getData(t)}setData(t,e){this.m_listNodes.setField(t,0,e)}getNext(t){return this.m_listNodes.getField(t,2)}getPrev(t){return this.m_listNodes.getField(t,1)}getFirst(t){return this.m_lists.getField(t,0)}getLast(t){return this.m_lists.getField(t,1)}static st_nullNode(){return-1}clear(t){if(t!==void 0){let e=this.getLast(t);for(;e!==ge.st_nullNode();){const s=e;e=this.getPrev(s),this.freeNode_(s)}return this.m_lists.setField(t,0,-1),this.m_lists.setField(t,1,-1),void this.setListSize_(t,0)}for(let e=this.getFirstList();e!==-1;)e=this.deleteList(e)}isEmpty(t){return b(0),!1}getNodeCount(){return this.m_listNodes.size()}getListCount(){return this.m_lists.size()}getListSize(t){return this.m_lists.getField(t,4)}getFirstList(){return this.m_listOfLists}getNextList(t){return this.m_lists.getField(t,3)}}class yp extends tn{constructor(t){super(),this.m_intervalTree=t}compare(t,e,s){const i=t.getElement(s),n=this.m_intervalTree.getValue_(e),o=this.m_intervalTree.getValue_(i);return n<o?-1:n===o?De.isLeft_(e)&&De.isRight_(i)?-1:De.isLeft_(i)&&De.isRight_(e)?1:0:1}}class De{constructor(t){this.m_bEnvelopesRef=!1,this.m_intervals=[],this.m_envelopesRef=null,this.m_intervalNodes=new At(3),this.m_intervalHandles=[],this.m_endIndicesUnique=[],this.m_cCount=-1,this.m_root=-1,this.m_bSortIntervals=!1,this.m_bConstructing=!1,this.m_bConstructionEnded=!1,this.m_bOfflineDynamic=t,this.m_tertiaryNodes=new At(this.m_bOfflineDynamic?5:4),this.m_secondaryTreaps=new tt,this.m_secondaryTreaps.setComparator(new yp(this)),this.m_secondaryLists=new ge}addEnvelopesRef(t){this.reset_(!0,!0),this.m_bEnvelopesRef=!0,this.m_envelopesRef=t,this.m_bConstructing=!1,this.m_bConstructionEnded=!0,this.m_bOfflineDynamic||(this.insertIntervalsStatic_(),this.m_cCount=this.m_envelopesRef.length)}startConstruction(){this.reset_(!0,!1)}addInterval(t){this.m_bConstructing||Yt(""),this.m_intervals.push(t.clone())}addIntervalCoords(t,e){b(0)}endConstruction(){this.m_bConstructing||Yt(""),this.m_bConstructing=!1,this.m_bConstructionEnded=!0,this.m_bOfflineDynamic||(this.insertIntervalsStatic_(),this.m_cCount=this.m_intervals.length)}insert(t){if(this.m_bOfflineDynamic&&this.m_bConstructionEnded||Yt(""),this.m_root===-1){const n=this.m_bEnvelopesRef?this.m_envelopesRef.length:this.m_intervals.length;if(this.m_bSortIntervals){const o=new Xt(0);this.querySortedEndPointIndices_(o),this.m_endIndicesUnique.length=0,this.querySortedDuplicatesRemoved_(o),this.m_intervalHandles.length=n,this.m_intervalHandles.fill(-1),this.m_bSortIntervals=!1}else this.m_intervalHandles.fill(-1,0,n);this.m_root=this.createRoot_()}const e=this.insertIntervalEnd_(t<<1,this.m_root),s=this.getSecondaryFromInterval_(e),i=this.m_secondaryTreaps.addElement(1+(t<<1),s);this.setRightEnd_(e,i),this.m_intervalHandles[t]=e,this.m_cCount++}remove(t){this.m_bOfflineDynamic&&this.m_bConstructionEnded||Yt("");const e=this.m_intervalHandles[t];let s;e===-1&&H("the interval does not exist in the interval tree"),this.m_intervalHandles[t]=-1,this.m_cCount--;let i=this.getSecondaryFromInterval_(e),n=-1;n=this.m_secondaryTreaps.getTreapData(i),this.m_secondaryTreaps.deleteNode(this.getLeftEnd_(e),i),this.m_secondaryTreaps.deleteNode(this.getRightEnd_(e),i),s=this.m_secondaryTreaps.size(i),s===0&&(this.m_secondaryTreaps.deleteTreap(i),this.setSecondaryToTertiary_(n,-1)),this.m_intervalNodes.deleteElement(e);let o=this.getPptr_(n),a=this.getLptr_(n),h=this.getRptr_(n);for(;!(s>0||n===this.m_root||a!==-1&&h!==-1);)n===this.getLptr_(o)?a!==-1?(this.setLptr_(o,a),this.setPptr_(a,o),this.setLptr_(n,-1),this.setPptr_(n,-1)):h!==-1?(this.setLptr_(o,h),this.setPptr_(h,o),this.setRptr_(n,-1),this.setPptr_(n,-1)):(this.setLptr_(o,-1),this.setPptr_(n,-1)):a!==-1?(this.setRptr_(o,a),this.setPptr_(a,o),this.setLptr_(n,-1),this.setPptr_(n,-1)):h!==-1?(this.setRptr_(o,h),this.setPptr_(h,o),this.setRptr_(n,-1),this.setPptr_(n,-1)):(this.setRptr_(o,-1),this.setPptr_(n,-1)),this.m_tertiaryNodes.deleteElement(n),n=o,i=this.getSecondaryFromTertiary_(n),s=i!==-1?this.m_secondaryTreaps.size(i):0,a=this.getLptr_(n),h=this.getRptr_(n),o=this.getPptr_(n)}size(){return this.m_cCount}getIteratorQuery(t,e){return t instanceof z?new Il(this,t,e):(b(0),{})}getIterator(){return new Il(this)}querySortedEndPointIndices_(t){const e=this.m_bEnvelopesRef?this.m_envelopesRef.length:this.m_intervals.length;for(let s=0;s<2*e;s++)t.add(s);this.sortEndIndices_(t,0,2*e)}querySortedDuplicatesRemoved_(t){let e=Number.NaN;for(let s=0;s<t.size();s++){const i=t.read(s),n=this.getValue_(i);n!==e&&(this.m_endIndicesUnique.push(i),e=n)}}insertIntervalsStatic_(){const t=this.m_bEnvelopesRef?this.m_envelopesRef.length:this.m_intervals.length,e=new Xt(0);this.querySortedEndPointIndices_(e),this.m_endIndicesUnique.length=0,this.querySortedDuplicatesRemoved_(e),this.m_intervalNodes.setCapacity(t),this.m_secondaryLists.reserveNodes(2*t);const s=j(t,-1);this.m_root=this.createRoot_();for(let i=0;i<e.size();i++){const n=e.read(i);let o=s[n>>1];if(o!==-1){const a=this.getSecondaryFromInterval_(o);this.setRightEnd_(o,this.m_secondaryLists.addElement(a,n))}else o=this.insertIntervalEnd_(n,this.m_root),s[n>>1]=o}}createRoot_(){const t=this.calculateDiscriminantIndex1_(0,this.m_endIndicesUnique.length-1);return this.createTertiaryNode_(t)}insertIntervalEnd_(t,e){let s=-1,i=e,n=-1,o=-1,a=0,h=this.m_endIndicesUnique.length-1,m=0;const l=t>>1;let u=Number.NaN,c=Number.NaN,g=!0;const _=this.getMin_(l),d=this.getMax_(l);let p=-1;for(;g;){m=a+(h-a>>1),p=this.calculateDiscriminantIndex1_(a,h);const f=this.getDiscriminantFromIndex1_(p);if(d<f){if(i!==-1){if(p===this.getDiscriminantIndex1_(i))s=i,u=f,i=this.getLptr_(i),c=i!==-1?this.getDiscriminant_(i):Number.NaN;else if(c>f){const P=this.createTertiaryNode_(p);f<u?this.setLptr_(s,P):this.setRptr_(s,P),this.setRptr_(P,i),this.m_bOfflineDynamic&&(this.setPptr_(P,s),this.setPptr_(i,P)),s=P,u=f,i=-1,c=Number.NaN}}h=m;continue}if(_>f){if(i!==-1){if(p===this.getDiscriminantIndex1_(i))s=i,u=f,i=this.getRptr_(i),c=i!==-1?this.getDiscriminant_(i):Number.NaN;else if(c<f){const P=this.createTertiaryNode_(p);f<u?this.setLptr_(s,P):this.setRptr_(s,P),this.setLptr_(P,i),this.m_bOfflineDynamic&&(this.setPptr_(P,s),this.setPptr_(i,P)),s=P,u=f,i=-1,c=Number.NaN}}a=m+1;continue}let x=-1;x=i===-1||p!==this.getDiscriminantIndex1_(i)?this.createTertiaryNode_(p):i,n=this.getSecondaryFromTertiary_(x),n===-1&&(n=this.createSecondary_(x),this.setSecondaryToTertiary_(x,n));const E=this.addEndIndex_(n,t);o=this.createIntervalNode_(),this.setSecondaryToInterval_(o,n),this.setLeftEnd_(o,E),i!==-1&&p===this.getDiscriminantIndex1_(i)||(f<u?this.setLptr_(s,x):this.setRptr_(s,x),this.m_bOfflineDynamic&&this.setPptr_(x,s),i!==-1&&(c<f?this.setLptr_(x,i):this.setRptr_(x,i),this.m_bOfflineDynamic&&this.setPptr_(i,x))),g=!1;break}return o}createTertiaryNode_(t){const e=this.m_tertiaryNodes.newElement();return this.setDiscriminantIndex1_(e,t),e}createSecondary_(t){return this.m_bOfflineDynamic?this.m_secondaryTreaps.createTreap(t):this.m_secondaryLists.createList(t)}createIntervalNode_(){return this.m_intervalNodes.newElement()}reset(){this.m_bOfflineDynamic&&this.m_bConstructionEnded||Yt(""),this.reset_(!1,this.m_bEnvelopesRef)}reset_(t,e){t?(this.m_bEnvelopesRef=!1,this.m_envelopesRef=null,this.m_bSortIntervals=!0,this.m_bConstructing=!0,this.m_bConstructionEnded=!1,this.m_endIndicesUnique.length=0,e?(this.m_intervals.length=0,this.m_bEnvelopesRef=!0):this.m_intervals.length=0):this.m_bSortIntervals=!1,this.m_bOfflineDynamic?this.m_secondaryTreaps.clear():this.m_secondaryLists.clear(),this.m_intervalNodes.deleteAll(!1),this.m_tertiaryNodes.deleteAll(!1),this.m_root=-1,this.m_cCount=0}getDiscriminant_(t){const e=this.getDiscriminantIndex1_(t);return this.getDiscriminantFromIndex1_(e)}getDiscriminantFromIndex1_(t){if(t===-1)return Number.NaN;if(t>0){const i=t-2,n=this.m_endIndicesUnique[i],o=this.m_endIndicesUnique[i+1];return .5*(this.getValue_(n)+this.getValue_(o))}const e=-t-2,s=this.m_endIndicesUnique[e];return this.getValue_(s)}calculateDiscriminantIndex1_(t,e){let s;return t<e?s=t+(e-t>>1)+2:s=-(t+2),s}setDiscriminantIndex1_(t,e){this.m_tertiaryNodes.setField(t,0,e)}setSecondaryToTertiary_(t,e){this.m_tertiaryNodes.setField(t,1,e)}setLptr_(t,e){this.m_tertiaryNodes.setField(t,2,e)}setRptr_(t,e){this.m_tertiaryNodes.setField(t,3,e)}setPptr_(t,e){this.m_tertiaryNodes.setField(t,4,e)}setSecondaryToInterval_(t,e){this.m_intervalNodes.setField(t,0,e)}addEndIndex_(t,e){let s=-1;return s=this.m_bOfflineDynamic?this.m_secondaryTreaps.addElement(e,t):this.m_secondaryLists.addElement(t,e),s}setLeftEnd_(t,e){this.m_intervalNodes.setField(t,1,e)}setRightEnd_(t,e){this.m_intervalNodes.setField(t,2,e)}getFirst_(t){return this.m_bOfflineDynamic?this.m_secondaryTreaps.getFirst(t):this.m_secondaryLists.getFirst(t)}getLast_(t){return this.m_bOfflineDynamic?this.m_secondaryTreaps.getLast(t):this.m_secondaryLists.getLast(t)}static isLeft_(t){return!(1&t)}static isRight_(t){return!(1&~t)}getDiscriminantIndex1_(t){return this.m_tertiaryNodes.getField(t,0)}getSecondaryFromTertiary_(t){return this.m_tertiaryNodes.getField(t,1)}getLptr_(t){return this.m_tertiaryNodes.getField(t,2)}getRptr_(t){return this.m_tertiaryNodes.getField(t,3)}getPptr_(t){return this.m_tertiaryNodes.getField(t,4)}getSecondaryFromInterval_(t){return this.m_intervalNodes.getField(t,0)}getLeftEnd_(t){return this.m_intervalNodes.getField(t,1)}getRightEnd_(t){return this.m_intervalNodes.getField(t,2)}getMin_(t){return this.m_bEnvelopesRef?this.m_envelopesRef[t].xmin:this.m_intervals[t].vmin}getMax_(t){return this.m_bEnvelopesRef?this.m_envelopesRef[t].xmax:this.m_intervals[t].vmax}sortEndIndices_(t,e,s){const i=this,n={userSort(o,a,h){i.sortEndIndicesHelper_(h,o,a)},getValue:o=>i.getValue_(o)};new Ys().sort(t,e,s,n)}sortEndIndicesHelper_(t,e,s){t.sort(e,s,(i,n)=>{const o=this.getValue_(i),a=this.getValue_(n);return o<a||o===a&&De.isLeft_(i)&&De.isRight_(n)?-1:1})}getValue_(t){if(!this.m_bEnvelopesRef){const s=this.m_intervals[t>>1];return De.isLeft_(t)?s.vmin:s.vmax}const e=this.m_envelopesRef[t>>1];return De.isLeft_(t)?e.xmin:e.xmax}}class Il{constructor(t,e,s){this.m_query=z.constructEmpty(),this.m_tertiaryHandle=-1,this.m_nextTertiaryHandle=-1,this.m_forkedHandle=-1,this.m_currentEndHandle=-1,this.m_nextEndHandle=-1,this.m_tertiaryStack=[],this.m_functionIndex=0,this.m_intervalTree=t,this.m_functionStack=new Array(2),this.m_functionStack[0]=this.nullFunc_,this.m_functionStack[1]=this.nullFunc_,e!==void 0&&this.resetIterator(e,s)}nullFunc_(){return $("should not be called"),!1}resetIterator(t,e){if(typeof t=="number"){const s=new z;s.setCoords(t,t),this.resetIterator(s,e)}else e===void 0&&(e=0),this.m_query.vmin=t.vmin-e,this.m_query.vmax=t.vmax+e,this.m_tertiaryStack.length=0,this.m_functionIndex=0,this.m_functionStack[0]=this.initialize_}next(){if(this.m_intervalTree.m_bConstructionEnded||Yt(""),this.m_functionIndex<0)return-1;for(;this.m_fi=this.m_functionStack[this.m_functionIndex],this.m_fi(););return this.m_currentEndHandle!==-1?this.getCurrentEndIndex_()>>1:-1}initialize_(){return this.m_tertiaryHandle=-1,this.m_nextTertiaryHandle=-1,this.m_forkedHandle=-1,this.m_currentEndHandle=-1,this.m_intervalTree.m_tertiaryNodes.size()>0?(this.m_functionStack[0]=this.pIn_,this.m_nextTertiaryHandle=this.m_intervalTree.m_root,!0):(this.m_functionIndex=-1,!1)}pIn_(){if(this.m_tertiaryHandle=this.m_nextTertiaryHandle,this.m_tertiaryHandle===-1)return this.m_functionIndex=-1,this.m_currentEndHandle=-1,!1;const t=this.m_intervalTree.getDiscriminant_(this.m_tertiaryHandle);if(this.m_query.vmax<t){const s=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);return this.m_nextTertiaryHandle=this.m_intervalTree.getLptr_(this.m_tertiaryHandle),s!==-1&&(this.m_nextEndHandle=this.m_intervalTree.getFirst_(s),this.m_functionStack[++this.m_functionIndex]=this.left_),!0}if(t<this.m_query.vmin){const s=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);return this.m_nextTertiaryHandle=this.m_intervalTree.getRptr_(this.m_tertiaryHandle),s!==-1&&(this.m_nextEndHandle=this.m_intervalTree.getLast_(s),this.m_functionStack[++this.m_functionIndex]=this.right_),!0}this.m_functionStack[this.m_functionIndex]=this.pL_,this.m_forkedHandle=this.m_tertiaryHandle;const e=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);return this.m_nextTertiaryHandle=this.m_intervalTree.getLptr_(this.m_tertiaryHandle),e!==-1&&(this.m_nextEndHandle=this.m_intervalTree.getFirst_(e),this.m_functionStack[++this.m_functionIndex]=this.all_),!0}pL_(){if(this.m_tertiaryHandle=this.m_nextTertiaryHandle,this.m_tertiaryHandle===-1)return this.m_functionStack[this.m_functionIndex]=this.pR_,this.m_nextTertiaryHandle=this.m_intervalTree.getRptr_(this.m_forkedHandle),!0;if(this.m_intervalTree.getDiscriminant_(this.m_tertiaryHandle)<this.m_query.vmin){const s=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);return this.m_nextTertiaryHandle=this.m_intervalTree.getRptr_(this.m_tertiaryHandle),s!==-1&&(this.m_nextEndHandle=this.m_intervalTree.getLast_(s),this.m_functionStack[++this.m_functionIndex]=this.right_),!0}const t=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);this.m_nextTertiaryHandle=this.m_intervalTree.getLptr_(this.m_tertiaryHandle),t!==-1&&(this.m_nextEndHandle=this.m_intervalTree.getFirst_(t),this.m_functionStack[++this.m_functionIndex]=this.all_);const e=this.m_intervalTree.getRptr_(this.m_tertiaryHandle);return e!==-1&&this.m_tertiaryStack.push(e),!0}pR_(){if(this.m_tertiaryHandle=this.m_nextTertiaryHandle,this.m_tertiaryHandle===-1)return this.m_functionStack[this.m_functionIndex]=this.pT_,!0;const t=this.m_intervalTree.getDiscriminant_(this.m_tertiaryHandle);if(this.m_query.vmax<t){const i=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);return this.m_nextTertiaryHandle=this.m_intervalTree.getLptr_(this.m_tertiaryHandle),i!==-1&&(this.m_nextEndHandle=this.m_intervalTree.getFirst_(i),this.m_functionStack[++this.m_functionIndex]=this.left_),!0}const e=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);this.m_nextTertiaryHandle=this.m_intervalTree.getRptr_(this.m_tertiaryHandle),e!==-1&&(this.m_nextEndHandle=this.m_intervalTree.getFirst_(e),this.m_functionStack[++this.m_functionIndex]=this.all_);const s=this.m_intervalTree.getLptr_(this.m_tertiaryHandle);return s!==-1&&this.m_tertiaryStack.push(s),!0}pT_(){if(this.m_tertiaryStack.length===0)return this.m_functionIndex=-1,this.m_currentEndHandle=-1,!1;this.m_tertiaryHandle=this.m_tertiaryStack.at(-1),this.m_tertiaryStack.pop();const t=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);return t!==-1&&(this.m_nextEndHandle=this.m_intervalTree.getFirst_(t),this.m_functionStack[++this.m_functionIndex]=this.all_),this.m_intervalTree.getLptr_(this.m_tertiaryHandle)!==-1&&this.m_tertiaryStack.push(this.m_intervalTree.getLptr_(this.m_tertiaryHandle)),this.m_intervalTree.getRptr_(this.m_tertiaryHandle)!==-1&&this.m_tertiaryStack.push(this.m_intervalTree.getRptr_(this.m_tertiaryHandle)),!0}left_(){return this.m_currentEndHandle=this.m_nextEndHandle,this.m_currentEndHandle!==-1&&De.isLeft_(this.getCurrentEndIndex_())&&this.m_intervalTree.getValue_(this.getCurrentEndIndex_())<=this.m_query.vmax?(this.m_nextEndHandle=this.getNext_(),!1):(this.m_functionIndex--,!0)}right_(){return this.m_currentEndHandle=this.m_nextEndHandle,this.m_currentEndHandle!==-1&&De.isRight_(this.getCurrentEndIndex_())&&this.m_intervalTree.getValue_(this.getCurrentEndIndex_())>=this.m_query.vmin?(this.m_nextEndHandle=this.getPrev_(),!1):(this.m_functionIndex--,!0)}all_(){return this.m_currentEndHandle=this.m_nextEndHandle,this.m_currentEndHandle!==-1&&De.isLeft_(this.getCurrentEndIndex_())?(this.m_nextEndHandle=this.getNext_(),!1):(this.m_functionIndex--,!0)}getNext_(){return this.m_intervalTree.m_bOfflineDynamic?this.m_intervalTree.m_secondaryTreaps.getNext(this.m_currentEndHandle):this.m_intervalTree.m_secondaryLists.getNext(this.m_currentEndHandle)}getPrev_(){return this.m_intervalTree.m_bOfflineDynamic?this.m_intervalTree.m_secondaryTreaps.getPrev(this.m_currentEndHandle):this.m_intervalTree.m_secondaryLists.getPrev(this.m_currentEndHandle)}getCurrentEndIndex_(){return this.m_intervalTree.m_bOfflineDynamic?this.m_intervalTree.m_secondaryTreaps.getElement(this.m_currentEndHandle):this.m_intervalTree.m_secondaryLists.getData(this.m_currentEndHandle)}}class Yr{constructor(){this.m_tolerance=0,this.m_sweepIndexRed=-1,this.m_sweepIndexBlue=-1,this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_intervalTreeRed=null,this.m_intervalTreeBlue=null,this.m_iteratorRed=null,this.m_iteratorBlue=null,this.m_envelopesRed=[],this.m_envelopesBlue=[],this.m_elementsRed=[],this.m_elementsBlue=[],this.m_sortedEndIndicesRed=new Xt(0),this.m_sortedEndIndicesBlue=new Xt(0),this.m_queuedListRed=-1,this.m_queuedListBlue=-1,this.m_queuedEnvelopes=new ge,this.m_queuedIndicesRed=[],this.m_queuedIndicesBlue=[],this.m_bAddRed=!1,this.m_bAddBlue=!1,this.m_bAddRedRed=!1,this.m_bDone=!0,this.m_function=this.nullFunc_,this.reset_()}startConstruction(){this.reset_(),this.m_bAddRedRed=!0,this.m_elementsRed.length=0,this.m_envelopesRed.length=0}addEnvelope(t,e){this.m_bAddRedRed||Yt(""),this.m_elementsRed.push(t),this.m_envelopesRed.push(new F(e))}endConstruction(){this.m_bAddRedRed||Yt(""),this.m_bAddRedRed=!1,this.m_envelopesRed.length>0&&(this.m_function=this.initialize_,this.m_bDone=!1)}startRedConstruction(){this.reset_(),this.m_bAddRed=!0,this.m_elementsRed.length=0,this.m_envelopesRed.length=0}addRedEnvelope(t,e){this.m_bAddRed||Yt(""),this.m_elementsRed.push(t),this.m_envelopesRed.push(e.clone())}endRedConstruction(){this.m_bAddRed||Yt(""),this.m_bAddRed=!1,this.m_envelopesRed.length>0&&this.m_envelopesBlue.length>0&&(this.m_function===this.nullFunc_||this.m_function===this.initializeBlue_?this.m_function=this.initializeRedBlue_:this.m_function!==this.initializeRedBlue_&&(this.m_function=this.initializeRed_),this.m_bDone=!1)}startBlueConstruction(){this.reset_(),this.m_bAddBlue=!0,this.m_elementsBlue.length=0,this.m_envelopesBlue.length=0}addBlueEnvelope(t,e){this.m_bAddBlue||Yt(""),this.m_elementsBlue.push(t),this.m_envelopesBlue.push(e.clone())}endBlueConstruction(){this.m_bAddBlue||Yt(""),this.m_bAddBlue=!1,this.m_envelopesRed.length>0&&this.m_envelopesBlue.length>0&&(this.m_function===this.nullFunc_||this.m_function===this.initializeRed_?this.m_function=this.initializeRedBlue_:this.m_function!==this.initializeRedBlue_&&(this.m_function=this.initializeBlue_),this.m_bDone=!1)}next(){if(this.m_bDone)return!1;for(;this.m_function(););return!this.m_bDone}getHandleA(){return this.m_envelopeHandleA}getHandleB(){return this.m_envelopeHandleB}setTolerance(t){this.m_tolerance=t}getElement(t){return this.m_elementsRed[t]}getRedEnvelope(t){return this.m_envelopesRed[t]}getBlueEnvelope(t){return this.m_envelopesBlue[t]}getRedElement(t){return this.m_elementsRed[t]}getBlueElement(t){return this.m_elementsBlue[t]}isTop_(t){return!(1&~t)}isBottom_(t){return!(1&t)}reset_(){this.m_bAddRed=!1,this.m_bAddBlue=!1,this.m_bAddRedRed=!1,this.m_sweepIndexRed=-1,this.m_sweepIndexBlue=-1,this.m_queuedListRed=-1,this.m_queuedListBlue=-1,this.m_bDone=!0}initialize_(){if(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_envelopesRed.length<10)return this.m_sweepIndexRed=this.m_envelopesRed.length,this.m_function=this.sweepBruteForce_,!0;this.m_intervalTreeRed||(this.m_intervalTreeRed=new De(!0)),this.m_intervalTreeRed.addEnvelopesRef(this.m_envelopesRed),this.m_iteratorRed===null&&(this.m_iteratorRed=this.m_intervalTreeRed.getIterator()),this.m_sortedEndIndicesRed.resize(0);for(let t=0;t<2*this.m_envelopesRed.length;t++)this.m_sortedEndIndicesRed.add(t);return this.sortYEndIndices_(this.m_sortedEndIndicesRed,0,2*this.m_envelopesRed.length,!0),this.m_sweepIndexRed=2*this.m_envelopesRed.length,this.m_function=this.sweep_,!0}initializeRed_(){if(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_envelopesRed.length<10||this.m_envelopesBlue.length<10)return this.m_sweepIndexRed=this.m_envelopesRed.length,this.m_function=this.sweepRedBlueBruteForce_,!0;this.m_intervalTreeRed||(this.m_intervalTreeRed=new De(!0)),this.m_intervalTreeRed.addEnvelopesRef(this.m_envelopesRed),this.m_iteratorRed===null&&(this.m_iteratorRed=this.m_intervalTreeRed.getIterator()),this.m_sortedEndIndicesRed.resize(0);for(let t=0;t<2*this.m_envelopesRed.length;t++)this.m_sortedEndIndicesRed.add(t);return this.sortYEndIndices_(this.m_sortedEndIndicesRed,0,this.m_sortedEndIndicesRed.size(),!0),this.m_sweepIndexRed=this.m_sortedEndIndicesRed.size(),this.m_queuedListRed!==-1&&(this.m_queuedEnvelopes.deleteList(this.m_queuedListRed),this.m_queuedIndicesRed.length=0,this.m_queuedListRed=-1),this.m_function=this.sweepRedBlue_,this.resetBlue_()}initializeBlue_(){if(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_envelopesRed.length<10||this.m_envelopesBlue.length<10)return this.m_sweepIndexRed=this.m_envelopesRed.length,this.m_function=this.sweepRedBlueBruteForce_,!0;this.m_intervalTreeBlue||(this.m_intervalTreeBlue=new De(!0)),this.m_intervalTreeBlue.addEnvelopesRef(this.m_envelopesBlue),this.m_iteratorBlue==null&&(this.m_iteratorBlue=this.m_intervalTreeBlue.getIterator()),this.m_sortedEndIndicesBlue.resize(0);for(let t=0;t<2*this.m_envelopesBlue.length;t++)this.m_sortedEndIndicesBlue.add(t);return this.sortYEndIndices_(this.m_sortedEndIndicesBlue,0,this.m_sortedEndIndicesBlue.size(),!1),this.m_sweepIndexBlue=this.m_sortedEndIndicesBlue.size(),this.m_queuedListBlue!==-1&&(this.m_queuedEnvelopes.deleteList(this.m_queuedListBlue),this.m_queuedIndicesBlue.length=0,this.m_queuedListBlue=-1),this.m_function=this.sweepRedBlue_,this.resetRed_()}initializeRedBlue_(){if(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_envelopesRed.length<10||this.m_envelopesBlue.length<10)return this.m_sweepIndexRed=this.m_envelopesRed.length,this.m_function=this.sweepRedBlueBruteForce_,!0;this.m_intervalTreeRed||(this.m_intervalTreeRed=new De(!0)),this.m_intervalTreeBlue||(this.m_intervalTreeBlue=new De(!0)),this.m_intervalTreeRed.addEnvelopesRef(this.m_envelopesRed),this.m_intervalTreeBlue.addEnvelopesRef(this.m_envelopesBlue),this.m_iteratorRed===null&&(this.m_iteratorRed=this.m_intervalTreeRed.getIterator()),this.m_iteratorBlue===null&&(this.m_iteratorBlue=this.m_intervalTreeBlue.getIterator()),this.m_sortedEndIndicesRed.resize(0),this.m_sortedEndIndicesBlue.resize(0);for(let t=0;t<2*this.m_envelopesRed.length;t++)this.m_sortedEndIndicesRed.add(t);for(let t=0;t<2*this.m_envelopesBlue.length;t++)this.m_sortedEndIndicesBlue.add(t);return this.sortYEndIndices_(this.m_sortedEndIndicesRed,0,this.m_sortedEndIndicesRed.size(),!0),this.sortYEndIndices_(this.m_sortedEndIndicesBlue,0,this.m_sortedEndIndicesBlue.size(),!1),this.m_sweepIndexRed=this.m_sortedEndIndicesRed.size(),this.m_sweepIndexBlue=this.m_sortedEndIndicesBlue.size(),this.m_queuedListRed!==-1&&(this.m_queuedEnvelopes.deleteList(this.m_queuedListRed),this.m_queuedIndicesRed.length=0,this.m_queuedListRed=-1),this.m_queuedListBlue!==-1&&(this.m_queuedEnvelopes.deleteList(this.m_queuedListBlue),this.m_queuedIndicesBlue.length=0,this.m_queuedListBlue=-1),this.m_function=this.sweepRedBlue_,!0}sweep_(){const t=this.m_sortedEndIndicesRed.read(--this.m_sweepIndexRed),e=t>>1;if(this.isBottom_(t))return this.m_intervalTreeRed.remove(e),this.m_sweepIndexRed!==0||(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_bDone=!0,!1);const s=z.construct(this.m_envelopesRed[e].xmin,this.m_envelopesRed[e].xmax);return this.m_iteratorRed.resetIterator(s,this.m_tolerance),this.m_envelopeHandleA=e,this.m_function=this.iterate_,!0}sweepBruteForce_(){return--this.m_sweepIndexRed===-1?(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_bDone=!0,!1):(this.m_envelopeHandleA=this.m_sweepIndexRed,this.m_sweepIndexBlue=this.m_sweepIndexRed,this.m_function=this.iterateBruteForce_,!0)}sweepRedBlueBruteForce_(){return--this.m_sweepIndexRed===-1?(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_bDone=!0,!1):(this.m_envelopeHandleA=this.m_sweepIndexRed,this.m_sweepIndexBlue=this.m_envelopesBlue.length,this.m_function=this.iterateRedBlueBruteForce_,!0)}sweepRedBlue_(){const t=this.m_sortedEndIndicesRed.read(this.m_sweepIndexRed-1),e=this.m_sortedEndIndicesBlue.read(this.m_sweepIndexBlue-1),s=this.getAdjustedValue_(t,!0),i=this.getAdjustedValue_(e,!1);return s>i?this.sweepRed_():s<i?this.sweepBlue_():this.isTop_(t)?this.sweepRed_():this.isTop_(e)?this.sweepBlue_():this.sweepRed_()}sweepRed_(){const t=this.m_sortedEndIndicesRed.read(--this.m_sweepIndexRed),e=t>>1;if(this.isBottom_(t))return this.m_queuedListRed!==-1&&this.m_queuedIndicesRed[e]!==-1?(this.m_queuedEnvelopes.deleteElement(this.m_queuedListRed,this.m_queuedIndicesRed[e]),this.m_queuedIndicesRed[e]=-1):this.m_intervalTreeRed.remove(e),this.m_sweepIndexRed!==0||(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_bDone=!0,!1);if(this.m_queuedListBlue!==-1&&this.m_queuedEnvelopes.getListSize(this.m_queuedListBlue)>0){let s=this.m_queuedEnvelopes.getFirst(this.m_queuedListBlue);for(;s!==-1;){const i=this.m_queuedEnvelopes.getData(s);this.m_intervalTreeBlue.insert(i),this.m_queuedIndicesBlue[i]=-1;const n=this.m_queuedEnvelopes.getNext(s);this.m_queuedEnvelopes.deleteElement(this.m_queuedListBlue,s),s=n}}if(this.m_intervalTreeBlue.size()>0){const s=z.construct(this.m_envelopesRed[e].xmin,this.m_envelopesRed[e].xmax);this.m_iteratorBlue.resetIterator(s,this.m_tolerance),this.m_envelopeHandleA=e,this.m_function=this.iterateBlue_}else this.m_queuedListRed===-1&&(Do(this.m_queuedIndicesRed,this.m_envelopesRed.length,-1),this.m_queuedListRed=this.m_queuedEnvelopes.createList(1)),this.m_queuedIndicesRed[e]=this.m_queuedEnvelopes.addElement(this.m_queuedListRed,e),this.m_function=this.sweepRedBlue_;return!0}sweepBlue_(){const t=this.m_sortedEndIndicesBlue.read(--this.m_sweepIndexBlue),e=t>>1;if(this.isBottom_(t))return this.m_queuedListBlue!==-1&&this.m_queuedIndicesBlue[e]!==-1?(this.m_queuedEnvelopes.deleteElement(this.m_queuedListBlue,this.m_queuedIndicesBlue[e]),this.m_queuedIndicesBlue[e]=-1):this.m_intervalTreeBlue.remove(e),this.m_sweepIndexBlue!==0||(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_bDone=!0,!1);if(this.m_queuedListRed!==-1&&this.m_queuedEnvelopes.getListSize(this.m_queuedListRed)>0){let s=this.m_queuedEnvelopes.getFirst(this.m_queuedListRed);for(;s!==-1;){const i=this.m_queuedEnvelopes.getData(s);this.m_intervalTreeRed.insert(i),this.m_queuedIndicesRed[i]=-1;const n=this.m_queuedEnvelopes.getNext(s);this.m_queuedEnvelopes.deleteElement(this.m_queuedListRed,s),s=n}}if(this.m_intervalTreeRed.size()>0){const s=z.construct(this.m_envelopesBlue[e].xmin,this.m_envelopesBlue[e].xmax);this.m_iteratorRed.resetIterator(s,this.m_tolerance),this.m_envelopeHandleB=e,this.m_function=this.iterateRed_}else this.m_queuedListBlue===-1&&(Do(this.m_queuedIndicesBlue,this.m_envelopesBlue.length,-1),this.m_queuedListBlue=this.m_queuedEnvelopes.createList(0)),this.m_queuedIndicesBlue[e]=this.m_queuedEnvelopes.addElement(this.m_queuedListBlue,e),this.m_function=this.sweepRedBlue_;return!0}iterate_(){if(this.m_envelopeHandleB=this.m_iteratorRed.next(),this.m_envelopeHandleB!==-1)return!1;const t=this.m_sortedEndIndicesRed.read(this.m_sweepIndexRed)>>1;return this.m_intervalTreeRed.insert(t),this.m_function=this.sweep_,!0}iterateRed_(){if(this.m_envelopeHandleA=this.m_iteratorRed.next(),this.m_envelopeHandleA!==-1)return!1;this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1;const t=this.m_sortedEndIndicesBlue.read(this.m_sweepIndexBlue)>>1;return this.m_intervalTreeBlue.insert(t),this.m_function=this.sweepRedBlue_,!0}iterateBlue_(){if(this.m_envelopeHandleB=this.m_iteratorBlue.next(),this.m_envelopeHandleB!==-1)return!1;const t=this.m_sortedEndIndicesRed.read(this.m_sweepIndexRed)>>1;return this.m_intervalTreeRed.insert(t),this.m_function=this.sweepRedBlue_,!0}iterateBruteForce_(){if(--this.m_sweepIndexBlue===-1)return this.m_function=this.sweepBruteForce_,!0;const t=this.m_envelopesRed[this.m_sweepIndexRed].clone(),e=this.m_envelopesRed[this.m_sweepIndexBlue];return t.inflateCoords(this.m_tolerance,this.m_tolerance),!t.isIntersecting(e)||(this.m_envelopeHandleB=this.m_sweepIndexBlue,!1)}iterateRedBlueBruteForce_(){if(--this.m_sweepIndexBlue===-1)return this.m_function=this.sweepRedBlueBruteForce_,!0;const t=this.m_envelopesRed[this.m_sweepIndexRed].clone(),e=this.m_envelopesBlue[this.m_sweepIndexBlue];return t.inflateCoords(this.m_tolerance,this.m_tolerance),!t.isIntersecting(e)||(this.m_envelopeHandleB=this.m_sweepIndexBlue,!1)}resetRed_(){return this.m_sweepIndexRed=this.m_sortedEndIndicesRed.size(),this.m_intervalTreeRed.size()>0&&this.m_intervalTreeRed.reset(),this.m_queuedListRed!==-1&&(this.m_queuedEnvelopes.deleteList(this.m_queuedListRed),this.m_queuedIndicesRed.length=0,this.m_queuedListRed=-1),this.m_bDone=!1,!0}resetBlue_(){return this.m_sweepIndexBlue=this.m_sortedEndIndicesBlue.size(),this.m_intervalTreeBlue.size()>0&&this.m_intervalTreeBlue.reset(),this.m_queuedListBlue!==-1&&(this.m_queuedEnvelopes.deleteList(this.m_queuedListBlue),this.m_queuedIndicesBlue.length=0,this.m_queuedListBlue=-1),this.m_bDone=!1,!0}nullFunc_(){return $("should not be called"),!1}sortYEndIndices_(t,e,s,i){const n=this,o={userSort(a,h,m){n.sortYEndIndicesHelper_(m,a,h,i)},getValue:a=>n.getAdjustedValue_(a,i)};new Ys().sort(t,e,s,o)}sortYEndIndicesHelper_(t,e,s,i){t.sort(e,s,(n,o)=>{const a=this.getAdjustedValue_(n,i),h=this.getAdjustedValue_(o,i);return a<h||a===h&&this.isBottom_(n)&&this.isTop_(o)?-1:1})}getAdjustedValue_(t,e){const s=.5*this.m_tolerance;if(e){const n=this.m_envelopesRed[t>>1];return this.isBottom_(t)?n.ymin-s:n.ymax+s}const i=this.m_envelopesBlue[t>>1];return this.isBottom_(t)?i.ymin-s:i.ymax+s}}var wl=Mt;class Ve{constructor(t,e){this.tolerance=t!==void 0?t:Number.NaN,this.resolution=e!==void 0?e:Number.NaN}add(t){return new Ve(this.tolerance+t,this.resolution)}scale(t){return new Ve(this.tolerance*t,this.resolution*t)}total(){return this.tolerance+this.resolution}}function Pp(r,t,e,s,i){const n=s*s,o=r.sub(t),a=e.sub(t),h=o.sqrLength(),m=a.sqrLength();if(h<=n||m<=n)return!0;const l=yt(o.crossProduct(a));return l<=n*h||l<=n*m?o.dotProduct(a)>=0:!1}function Kc(r,t,e){return s=>e===0?(s+r)*t:1*(s-r*t)/t}function Sm(r,t){const e=new F;return r.queryLooseEnvelope(e),e.mergeEnvelope2D(t),e}function Ur(r,t){const e=F.constructEmpty();r.queryLooseEnvelope(e);const s=F.constructEmpty();return t.queryLooseEnvelope(s),e.mergeEnvelope2D(s),e}function FS(r,t){return(Number.isFinite(r)||Number.isNaN(r))&&(Number.isFinite(t)||Number.isNaN(t))}function MS(r,t){return Number.isFinite(r)&&Number.isFinite(t)}function Jc(r,t,e){const s=F.constructEmpty();return s.setFromPoints(r,t),ga(0,null,s.calculateToleranceFromEnvelope(),e,!1)}function re(r,t,e){return ga(0,r,t.calculateToleranceFromEnvelope(),e,!1)}function rr(r,t,e){return ga(1,r,t.calculateToleranceFromEnvelope(),e,!1)}function Dl(r,t,e){return rr(r,t.queryInterval(1,0),e)}function Oe(r,t,e){const s=F.constructEmpty();return t.queryEnvelope(s),re(r,s,e)}function Di(r,t,e=!1){return ga(0,r,t.calculateToleranceFromEnvelope(),e,!0).total()}function or(r,t,e){const s=F.constructEmpty();return t.queryEnvelope(s),Di(r,s,e)}function ga(r,t,e,s,i){const n=new Ve(0,0);if(t!==null&&(n.tolerance=t.getTolerance(r),(!i||s)&&t!==null)){const o=t.getResolution(r);n.resolution=o,s&&(n.resolution*=2)}return s&&(e*=4,n.tolerance*=1.01,n.resolution*=1.01),n.total()<e?new Ve(e,0):n}function ss(r){return Math.sqrt(2)*(2*r.tolerance+r.resolution)}function vm(r){return Math.sqrt(2)*(r.tolerance+r.resolution)}function Ws(r){return r>=3}function Cp(r,t){const e=[0];return r.getImpl().getIsSimple(t,e)>=3}function GS(r,t){r.getImpl().setIsSimple(3,t)}function Ep(r,t,e,s){if(yt(t.x-r.x)+yt(t.y-r.y)<=e*e){const i=r.z,n=t.z;return An(i,n,s)}return!1}function yi(r){return r>=4}function Sp(r,t){return r===T.enumPolygon?Ws(t):t>=1}function vp(r,t,e){const s=F.constructEmpty(),i=F.constructEmpty();r.queryLooseEnvelope(s),t.queryLooseEnvelope(i),s.inflateCoords(e,e),i.inflateCoords(e,e);const n=F.constructEmpty();n.setCoords({env2D:s}),n.intersect(i);const o=r.querySegmentIterator(),a=t.querySegmentIterator(),h=F.constructEmpty(),m=F.constructEmpty(),l=new Yr;l.setTolerance(e);let u=!1;for(l.startRedConstruction();o.nextPath();)for(;o.hasNextSegment();)o.nextSegment().queryLooseEnvelope(h),h.isIntersecting(n)&&(u=!0,l.addRedEnvelope(o.getStartPointIndex(),h));if(l.endRedConstruction(),!u)return null;let c=!1;for(l.startBlueConstruction();a.nextPath();)for(;a.hasNextSegment();)a.nextSegment().queryLooseEnvelope(m),m.isIntersecting(n)&&(c=!0,l.addBlueEnvelope(a.getStartPointIndex(),m));return l.endBlueConstruction(),c?l:null}function bp(r,t,e,s,i){r.getGeometryType(),t.getGeometryType();const n=F.constructEmpty(),o=F.constructEmpty();r.queryLooseEnvelope(n),t.queryLooseEnvelope(o),n.inflateCoords(e,e),o.inflateCoords(e,e);const a=F.constructEmpty();a.setCoords({env2D:n}),a.intersect(o);const h=new Yr;h.setTolerance(e);let m=!1;h.startRedConstruction();for(let u=0,c=r.getPathCount();u<c;u++)r.queryLoosePathEnvelope(u,n),n.isIntersecting(a)&&(m=!0,h.addRedEnvelope(u,n));if(h.endRedConstruction(),!m)return null;let l=!1;h.startBlueConstruction();for(let u=0,c=t.getPathCount();u<c;u++)t.queryLoosePathEnvelope(u,o),o.isIntersecting(a)&&(l=!0,h.addBlueEnvelope(u,o));return h.endBlueConstruction(),l?h:null}function Tl(r,t,e){const s=F.constructEmpty(),i=F.constructEmpty();r.queryLooseEnvelope(s),t.queryEnvelope(i),s.inflateCoords(e,e),i.inflateCoords(e,e);const n=F.constructEmpty();n.setCoords({env2D:s}),n.intersect(i);const o=r.querySegmentIterator(),a=new Yr;a.setTolerance(e);let h=!1;for(a.startRedConstruction();o.nextPath();)for(;o.hasNextSegment();)o.nextSegment().queryLooseEnvelope(s),s.isIntersecting(n)&&(h=!0,a.addRedEnvelope(o.getStartPointIndex(),s));if(a.endRedConstruction(),!h)return null;let m=!1;a.startBlueConstruction();for(let l=0,u=t.getPointCount();l<u;l++){const c=t.getXY(l);n.contains(c)&&(m=!0,a.addBlueEnvelope(l,F.construct(c.x,c.y,c.x,c.y)))}return a.endBlueConstruction(),m?a:null}function Ip(r,t,e){const s=F.constructEmpty(),i=F.constructEmpty();r.queryEnvelope(s),t.queryEnvelope(i),s.inflateCoords(e,e),i.inflateCoords(e,e);const n=F.constructEmpty();n.setCoords({env2D:s}),n.intersect(i);const o=new Yr;o.setTolerance(e);let a=!1;o.startRedConstruction();const h=new y;for(let u=0,c=r.getPointCount();u<c;u++)r.queryXY(u,h),n.contains(h)&&(a=!0,o.addRedEnvelope(u,F.construct(h.x,h.y,h.x,h.y)));if(o.endRedConstruction(),!a)return null;let m=!1;o.startBlueConstruction();const l=new y;for(let u=0,c=t.getPointCount();u<c;u++)t.queryXY(u,l),n.contains(l)&&(m=!0,o.addBlueEnvelope(u,F.construct(l.x,l.y,l.x,l.y)));return o.endBlueConstruction(),m?o:null}function wp(r){const t=new F;return r.queryLooseEnvelope(t),t.inflateCoords(1,1),Dp(r,t)}function Dp(r,t,e){const s=new F;if(r.queryLooseEnvelope(s),s.isEmpty())return null;r.getGeometryType();const i=new Pe(s,8);let n=-1;const o=new F;let a=!1;do for(let h=0,m=r.getPathCount();h<m;h++)if(r.queryLoosePathEnvelope(h,o),o.isIntersecting(t)){if(n=i.insertEx(h,o,n),n===-1){a&&$("build_quad_tree_for_paths"),s.assign(r.calculateEnvelope2D(!1)),a=!0,i.reset(s,8);break}a=!1}while(a);return i}function Pn(r,t){if(!t){const h=new F;r.queryLooseEnvelope(h);const m=new Pe(h,8);let l=-1;const u=new F,c=r.querySegmentIterator();let g=!1;for(;c.nextPath();)for(;c.hasNextSegment();){const _=c.nextSegment(),d=c.getStartPointIndex();if(_.queryLooseEnvelope(u),l=m.insertEx(d,u,l),l===-1){g&&$(""),h.assign(r.calculateEnvelope2D(!1)),g=!0,m.reset(h,8),c.resetToFirstPath();break}}return m}const e=new F;r.queryLooseEnvelope(e);const s=new Pe(e,8);let i=-1;const n=new F,o=r.querySegmentIterator();let a=!1;for(;o.nextPath();)for(;o.hasNextSegment();){const h=o.nextSegment(),m=o.getStartPointIndex();if(h.queryLooseEnvelope(n),n.isIntersecting(t)&&(i=s.insertEx(m,n,i),i===-1)){a&&$(""),e.assign(r.calculateEnvelope2D(!1)),a=!0,s.reset(e,8),o.resetToFirstPath();break}}return s}function Nl(r,t){if(t){const e=new Pe(t,8),s=new y,i=new F;let n=!1;for(let o=0;o<r.getPointCount();o++)s.setCoordsPoint2D(r.getXY(o)),t.contains(s)&&(i.setCoords({pt:s}),e.insert(o,i)!==-1||(n&&$(""),n=!0,e.reset(r.calculateEnvelope2D(),8),o=-1));return e}return ft("no-extent version not yet impl"),null}function Al(r,t,e,s,i){let n=!1;const o=i.vmin,a=i.vmax;for(let h=e;h<t;h+=s){const m=r.read(h);m<o?(n=!0,r.write(h,o)):m>a&&(n=!0,r.write(h,a))}return n}function ph(r,t,e,s){if(!r.hasAttribute(e))return!1;const i=r.getGeometryType();if(i===T.enumGeometryCollection){const n=r,o=n.getGeometryCount();let a=0;for(let h=0;h<o;++h)a|=ph(n.getGeometry(h),t,e,s)?1:0;return!!a}if(We(i)){const n=r,o=wl.getPersistence(e),a=wl.getComponentCount(e),h=n.getPointCount();if(o===1){const m=Al(n.getAttributeStreamRef(e),h*a,s,a,t);return m&&n.notifyModified(),m}if(o===2){const m=Al(n.getAttributeStreamRef(e),h*a,s,a,t);return m&&n.notifyModified(),m}$("snap_coordinate not implemented")}if(i===T.enumEnvelope){const n=r,o=n.queryInterval(e,s);let a=!1;return o.vmin<t.vmin&&(a=!0,o.vmin=t.vmin),o.vmax>t.vmax&&(a=!0,o.vmax=t.vmax),a&&n.setIntervalEnvelope(e,s,o),a}if(i===T.enumPoint){const n=r;let o=n.getAttributeAsDbl(e,s),a=!1;return o<t.vmin&&(a=!0,o=t.vmin),o>t.vmax&&(a=!0,o=t.vmax),a&&n.setAttributeBasic(e,s,o),a}if(he(i)){const n=r;let o=n.getStartAttributeAsDbl(e,s),a=!1;return o<t.vmin&&(a=!0,o=t.vmin),o>t.vmax&&(a=!0,o=t.vmax),a&&n.setStartAttribute(e,s,o),o=n.getEndAttributeAsDbl(e,s),o<t.vmin&&(a=!0,o=t.vmin),o>t.vmax&&(a=!0,o=t.vmax),a&&n.setEndAttribute(e,s,o),a}$("snap_coordinate not implemented")}var ys=Mt;class st{constructor(t){if(this.m_description=null,this.x=Number.NaN,this.y=Number.NaN,this.m_attribs=null,t){if(!t.copy)return t.move?(this.m_description=t.move.m_description,t.move.m_description=null,this.m_attribs=t.move.m_attribs,t.move.m_attribs=null,this.x=t.move.x,void(this.y=t.move.y)):t.vd?(this.m_description=t.vd,void(t.attribBuffer?(this.m_attribs=t.attribBuffer,t.initDefaultValues&&this.setDefaultAttributeValues()):this.ensureAttributes())):t.pt?(this.m_description=_e(),void this.setXY(t.pt)):void("x"in t&&("z"in t?(this.m_description=nr(),this.ensureAttributes(),this.setXYZ(new mt(t.x,t.y,t.z))):(this.m_description=_e(),this.setXYCoords(t.x,t.y))));t.copy.copyTo(this)}else this.m_description=_e()}assignCopy(t){return this.m_attribs=null,t.copyTo(this),this}assignMove(t){return this.m_attribs=null,t.copyTo(this),t.setEmpty(),this}getXY(){return new y(this.x,this.y)}queryXY(t){t.x=this.x,t.y=this.y}setXY(t){this.x=t.x,this.y=t.y}setXYCoords(t,e){this.x=t,this.y=e}getXYZ(){const t=new mt;return t.x=this.x,t.y=this.y,t.z=this.getZ(),t}setXYZ(t){this.addAttribute(1),this.x=t.x,this.y=t.y,this.m_attribs[0]=t.z}getX(){return this.x}setX(t){this.x=t}getY(){return this.y}setY(t){this.y=t}getZ(){return this.m_description.hasZ()?this.m_attribs[0]:ys.getDefaultValue(1)}setZ(t){this.addAttribute(1),this.m_attribs[0]=t}getM(){return this.getAttributeAsDbl(2,0)}setM(t){this.addAttribute(2),this.m_description.hasZ()?this.m_attribs[1]=t:this.m_attribs[0]=t}getID(){return this.getAttributeAsInt(3,0)}setID(t){this.setAttributeBasic(3,0,t)}isEqualXY(t,e){return e===void 0&&(e=0),Math.abs(t.x-this.x)<=e&&Math.abs(t.y-this.y)<=e}isEqualXYCoords(t,e,s){return s===void 0&&(s=0),Math.abs(t-this.x)<=s&&Math.abs(e-this.y)<=s}getAttributeAsDbl(t,e){if(t===0){if(e===0)return this.x;if(e===1)return this.y;ut("")}const s=ys.getComponentCount(t);(e<0||e>=s)&&ut("");const i=this.m_description.getAttributeIndex(t);return i>=0?this.m_attribs[this.m_description.getPointAttributeOffset(i)-2+e]:ys.getDefaultValue(t)}getAttributeAsInt(t,e){return Math.trunc(this.getAttributeAsDbl(t,e))}setAttributeBasic(t,e,s){if(t===0)return void(e===0?this.x=s:e===1?this.y=s:ut(""));const i=ys.getComponentCount(t);(e<0||e>=i)&&ut("");let n=this.m_description.getAttributeIndex(t);n<0&&(this.addAttribute(t),n=this.m_description.getAttributeIndex(t)),this.m_attribs[this.m_description.getPointAttributeOffset(n)-2+e]=s}copyAttributesFrom(t,e){if(this===t)return;const s=t.getDescription();for(let i=e&&s.hasZ()?2:1,n=s.getAttributeCount();i<n;++i){const o=s.getSemantics(i),a=ys.getComponentCount(o);for(let h=0;h<a;++h){const m=t.getAttributeAsDbl(o,h);this.setAttributeBasic(o,h,m)}}}getAttributeArray(){return this.m_attribs}getDescription(){return this.m_description}assignVertexDescription(t){this.m_description!==t&&this.assignVertexDescriptionImpl(t)}mergeVertexDescription(t){this.m_description!==t&&(this.m_description.hasAttributesFrom(t)||this.mergeVertexDescriptionImpl(t))}hasAttribute(t){return this.m_description.hasAttribute(t)}addAttribute(t){if(this.m_description.hasAttribute(t))return;const e=Gr(this.m_description,t);this.assignVertexDescription(e)}dropAttribute(t){if(!this.m_description.hasAttribute(t))return;const e=Vr(this.m_description,t);this.assignVertexDescription(e)}dropAllAttributes(){const t=_e();t!==this.m_description&&this.assignVertexDescription(t)}getGeometryType(){return T.enumPoint}getDimension(){return 0}queryEnvelope(t){if(t instanceof Ne)return t.setEmpty(),t.assignVertexDescription(this.m_description),void t.merge(this);if(t instanceof ps){if(this.isEmpty())return void t.setEmpty();const e=this.getXYZ();return t.xmin=e.x,t.ymin=e.y,t.zmin=e.z,t.xmax=e.x,t.ymax=e.y,void(t.zmax=e.z)}this.isEmpty()?t.setEmpty():(t.xmin=this.x,t.ymin=this.y,t.xmax=this.x,t.ymax=this.y)}queryLooseEnvelope(t){this.queryEnvelope(t)}queryInterval(t,e){const s=new z;if(this.isEmpty())return s.setEmpty(),s;const i=this.getAttributeAsDbl(t,e);return s.vmin=i,s.vmax=i,s}applyTransformation(t){if(!this.isEmpty()){if(t.m_TransformationType===1){const e=this.getXY();return t.transformInPlace(e),void this.setXY(e)}ft("3d not impl")}}transformAttribute(t,e,s,i,n){if(this.isEmpty())return;this.addAttribute(t);const o=this.getAttributeAsDbl(t,e),a=Kc(s,i,n);this.setAttributeBasic(t,e,a(o))}createInstance(){return new st({vd:this.m_description})}copyTo(t){if(this===t)return;t.getGeometryType()!==T.enumPoint&&H();const e=t;e.x=this.x,e.y=this.y,this.m_attribs?(e.assignVertexDescription(this.m_description),e.m_attribs=this.m_attribs.slice()):(e.releaseAttributes(),e.assignVertexDescription(this.m_description))}isEmpty(){return Number.isNaN(this.x)||Number.isNaN(this.y)}setEmpty(){this.m_description||(this.m_description=_e(),this.releaseAttributes()),this.x=Number.NaN,this.y=Number.NaN,this.m_attribs&&ne(this.m_attribs,this.m_description.getDefaultPointAttributes(),0,2,this.m_description.getTotalComponentCount()-2)}calculateArea2D(){return 0}calculateLength2D(){return 0}calculateLength3D(t){return 0}equals(t,e){if(t===this)return!0;if(t.getGeometryType()!==T.enumPoint)return!1;const s=t;if(this.m_description!==s.m_description||this.isEmpty()!==s.isEmpty())return!1;if(this.isEmpty())return!0;if(e===void 0&&(e=0),Math.abs(this.x-s.x)>e||Math.abs(this.y-s.y)>e)return!1;for(let i=0,n=this.m_description.getTotalComponentCount()-2;i<n;i++)if(!An(this.m_attribs[i],s.m_attribs[i],e))return!1;return!0}getBoundary(){return null}clone(){const t=new st({vd:this.m_description});return this.copyTo(t),t}swap(t){if(this===t)return;t.getGeometryType()!==T.enumPoint&&H("wrong geometry type");const e=t;e.m_description=O(this.m_description,this.m_description=e.m_description),e.x=O(this.x,this.x=e.x),e.y=O(this.y,this.y=e.y),e.m_attribs=O(this.m_attribs,this.m_attribs=e.m_attribs)}replaceNaNs(t,e){if(this.addAttribute(t),this.isEmpty())return;const s=ys.getComponentCount(t);for(let i=0;i<s;i++){const n=this.getAttributeAsDbl(t,i);Number.isNaN(n)&&this.setAttributeBasic(t,i,e)}}lerp(t,e,s){if(t.getDescription()!==e.getDescription()&&H("Point.lerp"),this.assignVertexDescription(t.getDescription()),t.isEmpty()||e.isEmpty())return this.setEmpty(),this;this.ensureAttributes();const i=Hs();t.queryValues(i,i.length);const n=Hs();e.queryValues(n,n.length);const o=Hs();let a=i,h=n;const m=o;let l=0;for(let u=0,c=this.m_description.getAttributeCount();u<c;u++){const g=this.m_description.getSemantics(u),_=ys.getInterpolation(g),d=ys.getComponentCount(g),p=ys.getDefaultValue(g);wo(_,a,h,m,l,d,s,p),a=a.slice(d),h=h.slice(d),l+=d}return this.setValues(o,l),this}static lerp(t,e,s,i){i.lerp(t,e,s)}setDefaultAttributeValues(){const t=this.m_description.getTotalComponentCount()-2;t>0&&(this.m_attribs?ne(this.m_attribs,this.m_description.getDefaultPointAttributes(),0,2,t):this.m_attribs=this.m_description.getDefaultPointAttributes().slice(2))}static sqrDistance2D(t,e){return y.sqrDistanceCoords(t.x,t.y,e.x,e.y)}getImpl(){return this}mergeVertexDescriptionImpl(t){const e=Fn(this.getDescription(),t);this.assignVertexDescription(e)}releaseAttributes(){this.m_attribs=null}assignVertexDescriptionImpl(t){this.m_description||(this.m_description=_e());const e=ua();ca(t,this.m_description,e);let s=null;t.getTotalComponentCount()-2>0&&(s=t.getDefaultPointAttributes().slice(2));for(let i=1,n=t.getAttributeCount();i<n;i++){const o=e[i];if(o!==-1){const a=this.m_description.getPointAttributeOffset(o)-2,h=t.getPointAttributeOffset(i)-2,m=ys.getComponentCount(t.getSemantics(i));for(let l=0;l<m;l++)s[h+l]=this.m_attribs[a+l]}}this.m_attribs=s,this.m_description=t}ensureAttributes(){this.m_description.getTotalComponentCount()-2>0&&this.m_attribs===null&&(this.m_attribs=this.m_description.getDefaultPointAttributes().slice(2))}queryValues(t,e){const s=this.m_description.getTotalComponentCount();b(s<=e),t[0]=this.x,t[1]=this.y,ne(t,this.m_attribs,2,0,s-2)}copyCommonAttributesTo(t){t.x=this.x,t.y=this.y;const e=t.getDescription();if(e===this.m_description)this.m_attribs&&ne(t.m_attribs,this.m_attribs,0,0,this.m_description.getTotalComponentCount()-2);else{let s=0;for(let i=1,n=e.getAttributeCount();i<n;i++){const o=e.getSemantics(i);let a=ys.getComponentCount(o);if(this.m_description.hasAttribute(o)){let h=this.m_description.getPointAttributeOffset(this.m_description.getAttributeIndex(o))-2;for(;a!==0;)t.m_attribs[s++]=this.m_attribs[h++],a--}else{const h=ys.getDefaultValue(o);for(;a!==0;)t.m_attribs[s++]=h,a--}}}}setValues(t,e){const s=this.m_description.getTotalComponentCount();b(s<=e),this.x=t[0],this.y=t[1],ne(this.m_attribs,t,0,2,s-2)}dbgDefaultAttribs(){}}st.type=T.enumPoint;var hs=Mt;function Fo(r,t){return t*(r.getTotalComponentCount()-2)}class ls{constructor(t){if(this.m_attributes=null,t)if(t.xmin!==void 0)this.m_envelope2D=new F(t.xmin,t.ymin,t.xmax,t.ymax);else if(t.env2D!==void 0)this.m_envelope2D=new F(t.env2D);else if(t.move)this.m_envelope2D=new F(t.move.m_envelope2D),this.m_attributes=t.move.m_attributes,t.move.m_attributes=null;else{if(!t.moveEnv)throw new Error("unrecognized EnvelopeData constructor options");{const e=t.moveEnv.accessEnvelopeData();this.m_envelope2D=new F(e.m_envelope2D),this.m_attributes=e.m_attributes,e.m_attributes=null}}else this.m_envelope2D=F.constructEmpty()}ensureAttributes(t){const e=t.getTotalComponentCount()-2;!this.m_attributes&&e&&(this.m_attributes=j(2*e,Number.NaN),this.m_attributes.fill(Number.NaN))}copyTo(t,e){const s=e,i=t.getTotalComponentCount()-2;if(s.m_description!==t&&(s.releaseAttributes_(),s.m_description=t,i&&(s.m_data.m_attributes=j(2*i,Number.NaN))),i){b(this.m_attributes&&s.m_data.m_attributes);const n=2*i;ne(s.m_data.m_attributes,this.m_attributes,0,0,n)}s.m_data.m_envelope2D=new F(this.m_envelope2D)}copyToIfNotNull(t,e){e.m_envelope2D=new F(this.m_envelope2D),e.releaseAttributes(),t.getTotalComponentCount()-2&&this.m_attributes&&(e.m_attributes=this.m_attributes.slice())}releaseAttributes(){this.m_attributes=null}isEmpty(){return this.m_envelope2D.isEmpty()}transformAttribute(t,e,s,i,n){b(0)}queryInterval(t,e,s,i){if(this.isEmpty())return void i.setEmpty();if(e===0)return void(s===0?this.m_envelope2D.queryIntervalX(i):s===1?this.m_envelope2D.queryIntervalY(i):ut(""));const n=hs.getComponentCount(e);(s<0||s>=n)&&ut("");const o=t.getAttributeIndex(e);if(o>=0)return i.vmin=this.m_attributes[Fo(t,0)+t.getPointAttributeOffset(o)-2+s],void(i.vmax=this.m_attributes[Fo(t,1)+t.getPointAttributeOffset(o)-2+s]);{const a=hs.getDefaultValue(e);return void i.setCoords(a,a)}}queryEnvelope3D(t,e){const s=new z;this.queryInterval(t,1,0,s),e.setCoords(this.m_envelope2D.xmin,this.m_envelope2D.ymin,s.vmin,this.m_envelope2D.xmax,this.m_envelope2D.ymax,s.vmax)}setEmpty(t){this.m_envelope2D.setEmpty();const e=t.getTotalComponentCount()-2;e&&(this.m_attributes?this.dbgAssertSize(e):this.m_attributes=j(2*e,Number.NaN),this.m_attributes.fill(Number.NaN))}dbgAssertSize(t){}}let Ne=class po{constructor(t){if(this.m_EnvelopeType=4,this.m_description=_e(),t===void 0)this.m_data=new ls;else if(t.vd!==void 0)this.m_description=t.vd,this.m_data=new ls,this.ensureAttributes_();else if(t?.env2D)this.m_data=new ls({env2D:t.env2D});else if(t.xmin!==void 0)this.m_data=new ls({xmin:t.xmin,ymin:t.ymin,xmax:t.xmax,ymax:t.ymax});else if(t.copy)this.m_data=new ls,t.copy.copyTo(this);else if(t.move)this.m_description=t.move.m_description,t.move.m_description=null,this.m_data=new ls({move:t.move.m_data});else{if(!t.centerPoint)throw new Error("unrecognized Envelope constructor options");this.m_description=t.centerPoint.getDescription(),this.m_data=new ls,this.ensureAttributes_(),this.setFromPoint(t.centerPoint,t.width,t.height)}}accessEnvelopeData(){return this.m_description=null,this.m_data}assignMove(t){return this===t||(this.m_description=t.m_description,t.m_description=null,this.m_data=new ls({move:t.m_data})),this}assignCopy(t){return this===t||t.copyTo(this),this}transformAttribute(t,e,s,i,n){b(0)}setAttributeBasic(t,e,s){if(this.addAttribute(t),this.m_data.isEmpty())return;const i=this.queryInterval(t,e);i.vmin=s,i.vmax=s,this.setIntervalEnvelope(t,e,i)}mergeVertexDescriptionImpl(t){const e=Fn(this.getDescription(),t);this.assignVertexDescription(e)}asEnvelope2D(){return new F(this.m_data.m_envelope2D)}assignVertexDescription(t){this.m_description!==t&&this.assignVertexDescriptionImpl(t)}getGeometryType(){return T.enumEnvelope}getDimension(){return 2}getXMin(){return this.m_data.m_envelope2D.xmin}getYMin(){return this.m_data.m_envelope2D.ymin}getXMax(){return this.m_data.m_envelope2D.xmax}getYMax(){return this.m_data.m_envelope2D.ymax}width(){return this.m_data.isEmpty()?Number.NaN:this.m_data.m_envelope2D.width()}height(){return this.m_data.isEmpty()?Number.NaN:this.m_data.m_envelope2D.height()}getCenterXY(){return this.m_data.isEmpty()?new y:this.m_data.m_envelope2D.getCenter()}getCenter(t){if(t.assignVertexDescription(this.m_description),this.m_data.isEmpty())return void t.setEmpty();const e=this.m_description.getAttributeCount();for(let s=1;s<e;s++){const i=this.m_description.getSemantics(s),n=hs.getComponentCount(i);for(let o=0;o<n;o++){const a=.5*(this.getAttributeAsDblImpl(0,i,o)+this.getAttributeAsDblImpl(1,i,o));t.setAttributeBasic(i,o,a)}}t.setXY(this.m_data.m_envelope2D.getCenter())}setCoords(t,e,s,i){this.m_data.m_envelope2D.setCoords({xmin:t,ymin:e,xmax:s,ymax:i})}setEnvelope(t){if(t instanceof F)this.m_data.m_envelope2D=new F(t),this.m_data.m_envelope2D.normalize();else{this.addAttribute(1),this.m_data.m_envelope2D=t.getEnvelope2D(),this.m_data.m_envelope2D.normalize();const e=z.constructEmpty();e.setCoords(t.zmin,t.zmax),this.setInterval(1,0,e.vmin,e.vmax)}}merge(t){if(t instanceof F)return t.isValid()||H(""),void this.m_data.m_envelope2D.mergeEnvelope2D(t);if(t instanceof po){if(t.m_data.isEmpty())return;const e=t.getDescription();this.mergeVertexDescription(e),this.m_data.m_envelope2D.mergeEnvelope2D(t.m_data.m_envelope2D);for(let s=1,i=e.getAttributeCount();s<i;s++){const n=e.getSemantics(s),o=hs.getComponentCount(n);for(let a=0;a<o;a++){const h=t.queryInterval(n,a),m=this.queryInterval(n,a);m.merge(h),this.setIntervalEnvelope(n,a,m)}}}else if(t instanceof st){const e=t;if(e.isEmpty())return;const s=e.getDescription();if(this.mergeVertexDescription(s),this.m_data.isEmpty())return void this.setFromPoint(e);this.m_data.m_envelope2D.merge(e.getXY());for(let i=1,n=s.getAttributeCount();i<n;i++){const o=s.getSemantics(i),a=hs.getComponentCount(o);for(let h=0;h<a;h++){const m=e.getAttributeAsDbl(o,h),l=this.queryInterval(o,h);l.mergeCoordinate(m),this.setIntervalEnvelope(o,h,l)}}}else ft("unrecognized type for envelope.merge")}intersect(t){if(!this.m_data.m_envelope2D.intersect(t.m_data.m_envelope2D))return this.setEmpty(),!1;const e=t.getDescription();this.mergeVertexDescription(e);for(let s=1,i=this.m_description.getAttributeCount();s<i;s++){const n=this.m_description.getSemantics(s),o=hs.getComponentCount(n);for(let a=0;a<o;a++){const h=t.queryInterval(n,a),m=this.queryInterval(n,a);m.intersect(h),this.setIntervalEnvelope(n,a,m)}}return!0}intersectCommonAttributes(t){if(!this.m_data.m_envelope2D.intersect(t.m_data.m_envelope2D))return this.setEmpty(),!1;const e=t.getDescription();for(let s=1,i=this.m_description.getAttributeCount();s<i;s++){const n=this.m_description.getSemantics(s);if(!e.hasAttribute(n))continue;const o=hs.getComponentCount(n);for(let a=0;a<o;a++){const h=t.queryInterval(n,a),m=this.queryInterval(n,a);m.intersect(h),this.setIntervalEnvelope(n,a,m)}}return!0}move(t,e){this.m_data.m_envelope2D.move(t,e)}centerAt(t,e){this.m_data.m_envelope2D.centerAtCoords(t,e)}centerAtPoint(t){this.m_data.m_envelope2D.centerAt(t)}reaspect(t,e){this.m_data.m_envelope2D.reaspect(t,e)}inflateCoords(t,e){this.m_data.m_envelope2D.inflateCoords(t,e)}containsCoords(t,e){return this.m_data.m_envelope2D.containsCoords(t,e)}contains(t){return this.m_data.m_envelope2D.contains(t)}containsPoint(t){return!t.isEmpty()&&this.m_data.m_envelope2D.contains(t.getXY())}containsEnvelope(t){return this.m_data.m_envelope2D.containsEnvelope(t.m_data.m_envelope2D)}setIntervalEnvelope(t,e,s){if(this.addAttribute(t),this.m_data.isEmpty())return;const i=new z(s);if(i.normalize(),t===0){if(i.isEmpty())return void this.setEmpty();e===0?(this.m_data.m_envelope2D.xmin=i.vmin,this.m_data.m_envelope2D.xmax=i.vmax):e===1?(this.m_data.m_envelope2D.ymin=i.vmin,this.m_data.m_envelope2D.ymax=i.vmax):ut("")}else this.setAttributeAsDblImpl(0,t,e,i.vmin),this.setAttributeAsDblImpl(1,t,e,i.vmax)}setInterval(t,e,s,i){this.setIntervalEnvelope(t,e,new z(s,i))}queryInterval(t,e){const s=new z;return this.m_data.queryInterval(this.m_description,t,e,s),s}queryEnvelope(t){t.m_EnvelopeType!==2?t.m_EnvelopeType!==3?t.m_EnvelopeType!==4?ft("unrecognized type for queryEnveloper"):this.copyTo(t):this.m_data.queryEnvelope3D(this.m_description,t):t.setCoords({env2D:this.m_data.m_envelope2D})}applyTransformation(t){t.m_TransformationType!==1?b(0):t.transformEnvInPlace(this.m_data.m_envelope2D)}createInstance(){return new po({vd:this.m_description})}copyTo(t){t!==this&&this.m_data.copyTo(this.m_description,t)}isEmpty(){return this.m_data.isEmpty()}setEmpty(){this.m_description||(this.m_description=_e()),this.m_data.setEmpty(this.m_description)}calculateArea2D(){return this.m_data.m_envelope2D.getArea()}calculateLength2D(){return this.m_data.m_envelope2D.getLength()}calculateLength3D(t){return b(0),0}equals(t,e){if(t===this)return!0;const s=t;if(this.m_description!==s.m_description||this.m_data.isEmpty()!==s.m_data.isEmpty())return!1;if(this.m_data.isEmpty())return!0;if(e===void 0&&(e=0),Math.abs(this.m_data.m_envelope2D.xmin-s.m_data.m_envelope2D.xmin)>e||Math.abs(this.m_data.m_envelope2D.ymin-s.m_data.m_envelope2D.ymin)>e||Math.abs(this.m_data.m_envelope2D.xmax-s.m_data.m_envelope2D.xmax)>e||Math.abs(this.m_data.m_envelope2D.ymax-s.m_data.m_envelope2D.ymax)>e)return!1;for(let i=0,n=2*(this.m_description.getTotalComponentCount()-2);i<n;i++)if(!An(this.m_data.m_attributes[i],s.m_data.m_attributes[i],e))return!1;return!0}getBoundary(){return ft("getBoundary not available in this context. Use the boundary operator with an envelope parameter"),null}clone(){return new po({copy:this})}swap(t){if(this===t)return;t.getGeometryType()!==T.enumEnvelope&&H("wrong geometry type");const e=t;e.m_description=O(this.m_description,this.m_description=e.m_description),e.m_data.m_envelope2D=O(this.m_data.m_envelope2D,this.m_data.m_envelope2D=e.m_data.m_envelope2D),e.m_data.m_attributes=O(this.m_data.m_attributes,this.m_data.m_attributes=e.m_data.m_attributes)}queryCoordinates(t){this.m_data.isEmpty()&&H(""),this.m_data.m_envelope2D.queryCorners(t)}queryCornerByVal(t,e){(t<0||t>3)&&ut(""),e.assignVertexDescription(this.m_description);const s=this.getDescription().getAttributeCount();for(let i=1;i<s;i++){const n=this.m_description.getSemantics(i),o=hs.getComponentCount(n);for(let a=0;a<o;a++)e.setAttributeBasic(n,a,this.getAttributeAsDblImpl(t%2,n,a))}e.setXY(this.m_data.m_envelope2D.queryCorner(t))}queryCorner(t,e){e.assign(this.m_data.m_envelope2D.queryCorner(t))}getDescription(){return this.m_description}mergeVertexDescription(t){this.m_description!==t&&(this.m_description&&this.m_description.hasAttributesFrom(t)||this.mergeVertexDescriptionImpl(t))}hasAttribute(t){return this.m_description.hasAttribute(t)}addAttribute(t){if(this.m_description.hasAttribute(t))return;const e=Gr(this.m_description,t);this.assignVertexDescription(e)}dropAttribute(t){if(!this.m_description.hasAttribute(t))return;const e=Vr(this.m_description,t);this.assignVertexDescription(e)}dropAllAttributes(){const t=_e();t!==this.m_description&&this.assignVertexDescription(t)}queryLooseEnvelope(t){this.queryEnvelope(t)}replaceNaNs(t,e){if(this.addAttribute(t),this.m_data.isEmpty())return;const s=hs.getComponentCount(t);for(let i=0;i<s;i++){const n=this.queryInterval(t,i);n.isEmpty()&&(n.vmin=e,n.vmax=e,this.setIntervalEnvelope(t,i,n))}}getImpl(){return this}setFromPoint(t,e,s){this.m_data.m_envelope2D.setCoords({center:t.getXY(),width:e??0,height:s??0});const i=t.getDescription();for(let n=1,o=i.getAttributeCount();n<o;n++){const a=i.getSemantics(n),h=hs.getComponentCount(a);for(let m=0;m<h;m++){const l=t.getAttributeAsDbl(a,m);this.setInterval(a,m,l,l)}}}assignVertexDescriptionImpl(t){const e=ua();ca(t,this.m_description,e);let s=null;const i=t.getTotalComponentCount()-2,n=this.m_description?this.m_description.getTotalComponentCount()-2:0;i>0&&(s=j(2*i,Number.NaN));for(let o=1;o<t.getAttributeCount();o++){const a=e[o];if(a!==-1){const h=t.getPointAttributeOffset(o)-2,m=hs.getComponentCount(t.getSemantics(o)),l=this.m_description.getPointAttributeOffset(a)-2;ne(s,this.m_data.m_attributes,h,l,m),ne(s,this.m_data.m_attributes,i+h,n+l,m)}}this.releaseAttributes_(),this.m_data.m_attributes=s,this.m_description=t}getAttributeAsDblImpl(t,e,s){if(this.m_data.isEmpty()&&aa(""),e===0)return t?s?this.m_data.m_envelope2D.ymax:this.m_data.m_envelope2D.xmax:s?this.m_data.m_envelope2D.ymin:this.m_data.m_envelope2D.xmin;s>=hs.getComponentCount(e)&&ut("");const i=this.m_description.getAttributeIndex(e);return i>=0?this.m_data.m_attributes[Fo(this.m_description,t)+this.m_description.getPointAttributeOffset(i)-2+s]:Mt.getDefaultValue(e)}setAttributeAsDblImpl(t,e,s,i){e===0&&(t?s===1?this.m_data.m_envelope2D.ymax=i:s===0?this.m_data.m_envelope2D.xmax=i:ut(""):s===1?this.m_data.m_envelope2D.ymin=i:s===0?this.m_data.m_envelope2D.xmin=i:ut(""));const n=hs.getComponentCount(e);(s<0||s>=n)&&ut(""),this.addAttribute(e);const o=this.m_description.getAttributeIndex(e);this.m_data.m_attributes[Fo(this.m_description,t)+this.m_description.getPointAttributeOffset(o)-2+s]=i}releaseAttributes_(){this.m_data.releaseAttributes()}ensureAttributes_(){this.m_data.ensureAttributes(this.m_description)}};Ne.type=T.enumEnvelope;Object.freeze(Object.defineProperty({__proto__:null,Envelope:Ne,EnvelopeData:ls},Symbol.toStringTag,{value:"Module"}));class Or{constructor(){this.posStream=null,this.streams=null}get(t){return t>0?this.streams[t-1]:this.posStream}set(t,e){t>0?this.streams[t-1]=e:this.posStream=e}destroyAndSetSize(t){if(this.streams=null,t>1){this.streams=new Array(t-1);for(let e=0;e<t-1;++e)this.streams[e]=null}this.posStream=null}swap(t){[this.streams,t.streams]=[t.streams,this.streams],[this.posStream,t.posStream]=[t.posStream,this.posStream]}empty(){return this.posStream===null&&this.streams===null}}function Tp(r,t,e,s,i){(t<0||e<0||s<1||t+s*(e-1)+1>r.size())&&H("Index out of bound");for(let n=t,o=t+s*(e-1)+1;n<o;n+=s)r.writeAsDbl(n,i(r.readAsDbl(n)))}function Np(r,t,e){if(r)for(let s=t.length-1;s>=0;--s)e(t[s]);else t.forEach(e)}function Ap(r,t){let e=dn(r);const s=t.length/Ie();for(let i=0;i<t.length;++i){const n=Math.trunc(e*s);e=dn(e);const o=Math.trunc(e*s),a=t[n];t[n]=t[o],t[o]=a}}function qp(r,t,e){const s=r.getDescription().getTotalComponentCount();r.setX(t[0]),r.setY(t[1]),ne(r.getAttributeArray(),t,0,2,s-2)}var Kt=Mt;const fh="can not assign an empty point to a vertex";class tg{constructor(t){if(this.m_accelerators=null,t!==void 0&&t.move)this.m_description=t.move.m_description,t.move.m_description=_e(),this.m_vertexAttributes=t.move.m_vertexAttributes,t.move.m_vertexAttributes=new Or,this.m_envelopeData=t.move.m_envelopeData,t.move.m_envelopeData=new ls,this.m_pointCount=t.move.m_pointCount,this.m_reservedPointCount=t.move.m_reservedPointCount,this.m_flags=t.move.m_flags,this.m_bFillRule=t.move.m_bFillRule,this.m_bPathStarted=t.move.m_bPathStarted,this.m_bPolygon=t.move.m_bPolygon,this.m_simpleTolerance=t.move.m_simpleTolerance;else{const e=t!==void 0&&t.vd?t.vd:_e();this.m_description=e,this.m_vertexAttributes=new Or,this.m_envelopeData=new ls,this.m_pointCount=0,this.m_reservedPointCount=-1,this.m_flags=4063,this.m_bFillRule=this.m_bPathStarted=this.m_bPolygon=!1,this.m_simpleTolerance=0,t!==void 0&&t.copy&&t.copy.copyTo(this)}}equalsBase(t,e){if(!We(t.getGeometryType()))return!1;const s=t;if(this===s)return!0;if(!this.m_description.equals(s.getDescription())||this.isEmptyImpl()!==s.isEmptyImpl())return!1;if(this.isEmptyImpl())return!0;const i=this.getPointCount();if(i!==s.getPointCount())return!1;for(let n=0;n<this.m_description.getAttributeCount();n++){const o=this.m_description.getSemantics(n),a=this.getAttributeStreamRef(o),h=s.getAttributeStreamRef(o),m=Kt.getComponentCount(o);if(!a.equals(h,0,i*m,e))return!1}if(e){if(!this.equalsImplTol(t,e))return!1}else if(!this.equalsImpl(t))return!1;return!0}transformAttribute(t,e,s,i,n){if(this.addAttribute(t),!this.isEmpty()&&(s!==0||i!==1)){if(t===0){const o=new pt;return n===0?e===0?(o.setShiftCoords(s,0),o.scale(i,1)):e===1?(o.setShiftCoords(0,s),o.scale(1,i)):H(""):e===0?(o.setScaleCoords(1/i,1),o.shiftCoords(-s,0)):e===1?(o.setScaleCoords(1,1/i),o.shiftCoords(0,-s)):H(""),void this.applyTransformation(o)}Tp(this.getAttributeStreamRef(t),e,this.getPointCount(),Kt.getComponentCount(t),Kc(s,i,n)),this.notifyModified()}}getDescription(){return this.m_description}assignVertexDescription(t){this.m_description!==t&&this.assignVertexDescriptionImpl(t)}mergeVertexDescriptionImpl(t){const e=this.getDescription(),s=Fn(e,t);this.assignVertexDescription(s)}mergeVertexDescription(t){this.m_description!==t&&(this.m_description.hasAttributesFrom(t)||this.mergeVertexDescriptionImpl(t))}hasAttribute(t){return this.m_description.hasAttribute(t)}addAttribute(t){if(this.m_description.hasAttribute(t))return;const e=Gr(this.m_description,t);this.assignVertexDescription(e)}dropAttribute(t){if(!this.m_description.hasAttribute(t))return;const e=Vr(this.m_description,t);this.assignVertexDescription(e)}dropAllAttributes(){const t=_e();t!==this.m_description&&this.assignVertexDescription(t)}getAttributeStreamRef(t){this.throwIfEmpty(),this.m_description.hasAttribute(t)||H("AttributeStream : Geometry does not have the attribute");const e=this.m_description.getAttributeIndex(t);return this.m_vertexAttributes.get(e)}setAttributeStreamRef(t,e){e||H("stream"),e&&Kt.getPersistence(t)!==e.getPersistence()&&H(""),this.addAttribute(t);const s=this.m_description.getAttributeIndex(t);this.m_vertexAttributes.empty()&&this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()),this.m_vertexAttributes.set(s,e),this.notifyModifiedFlags(2001)}notifyModifiedFlags(t){t===65535&&(this.m_reservedPointCount=-1,this.notifyModifiedAllImpl()),this.setDirtyFlagProtected(t,!0),this.clearAccelerators(),32&t&&this.verifyAllStreamsAfterSizeChange()}notifyModified(){this.notifyModifiedFlags(2001)}getPointCount(){return this.m_pointCount}getPointByVal(t,e){const s=e;s.assignVertexDescription(this.m_description);for(let i=0;i<this.m_description.getAttributeCount();i++){const n=this.m_description.getSemantics(i);for(let o=0,a=Kt.getComponentCount(n);o<a;o++){const h=this.m_vertexAttributes.get(i).readAsDbl(a*t+o);s.setAttributeBasic(n,o,h)}}}setPointByValNoCurves(t,e){const s=e;s.isEmpty()&&H(fh);const i=s.getDescription();i!==this.m_description&&this.mergeVertexDescription(i);const n=this.m_vertexAttributes.get(0);n.write(2*t,s.getX()),n.write(2*t+1,s.getY());for(let o=1,a=this.m_description.getAttributeCount();o<a;o++){const h=this.m_description.getSemantics(o),m=Kt.getComponentCount(h);for(let l=0;l<m;l++){const u=s.getAttributeAsDbl(h,l);this.m_vertexAttributes.get(o).writeAsDbl(t*m+l,u)}}this.notifyModifiedFlags(2001)}setPointByValFromArrayNoCurves(t,e,s,i){b(0)}getPointByValAsArray(t,e,s,i){b(0)}isEmpty(){return this.isEmptyImpl()}isEmptyImpl(){return this.m_pointCount===0}getAttributeAsDbl(t,e,s){const i=Kt.getComponentCount(t);s>=i&&ut("");const n=this.m_description.getAttributeIndex(t);return n>=0?this.m_vertexAttributes.get(n).readAsDbl(e*i+s):Kt.getDefaultValue(t)}queryAttributeAsDbl(t,e,s,i){const n=Kt.getComponentCount(t);i<n&&ut("");const o=this.m_description.getAttributeIndex(t);if(o>=0){const a=e*n,h=this.m_vertexAttributes.get(o);for(let m=0;m<n;m++)s[m]=h.readAsDbl(a+m)}else{const a=Kt.getDefaultValue(t);for(let h=0;h<n;h++)s[h]=a}}getAttributeAsInt(t,e,s){return Math.trunc(this.getAttributeAsDbl(t,e,s))}queryAttributeAsInt(t,e,s,i){b(0)}setAttributeNoCurves(t,e,s,i){const n=Kt.getComponentCount(t);s>=n&&ut(""),this.addAttribute(t);const o=this.m_description.getAttributeIndex(t);this.notifyModifiedFlags(2001),this.m_vertexAttributes.get(o).writeAsDbl(e*n+s,i)}setAttributeFromArrayNoCurves(t,e,s,i){(e<0||e>=this.m_pointCount)&&ut("");const n=Kt.getComponentCount(t);i<n&&ut(""),this.addAttribute(t);const o=this.m_description.getAttributeIndex(t);this.notifyModifiedFlags(2001);const a=this.m_vertexAttributes.get(o);for(let h=0;h<n;++h)a.writeAsDbl(e*n+h,s[h])}getXY(t){return this.m_vertexAttributes.get(0).readPoint2D(2*t)}queryXY(t,e){return this.m_vertexAttributes.get(0).queryPoint2D(2*t,e)}setXYNoCurves(t,e){this.m_vertexAttributes.get(0).writePoint2D(2*t,e),this.notifyModifiedFlags(2001)}setXYCoordsNoCurves(t,e,s){const i=this.m_vertexAttributes.get(0);i.write(2*t,e),i.write(2*t+1,s),this.notifyModifiedFlags(2001)}getXYZ(t){const e=this.m_vertexAttributes.get(0),s=mt.getNAN();return s.x=e.read(2*t),s.y=e.read(2*t+1),this.m_description.hasAttribute(1)?s.z=this.m_vertexAttributes.get(1).read(t):s.z=Kt.getDefaultValue(1),s}setXYZNoCurves(t,e){this.addAttribute(1),this.notifyModifiedFlags(2001);const s=this.m_vertexAttributes.get(0);s.write(2*t,e.x),s.write(2*t+1,e.y),this.m_vertexAttributes.get(1).write(t,e.z)}queryEnvelope(t){t instanceof F||t instanceof ps?this.updateEnvelope(t):(this.updateAllDirtyIntervals(!0),this.m_envelopeData.copyTo(this.m_description,t))}queryLooseEnvelope(t){this.updateLooseEnvelope(t)}queryInterval(t,e){const s=z.constructEmpty();return this.isEmptyImpl()||(this.updateAllDirtyIntervals(!0),this.m_envelopeData.queryInterval(this.m_description,t,e,s)),s}setAttributeBasic(t,e,s){this.setAttributeImpl(t,e,s)}setAttributeImpl(t,e,s){if(this.addAttribute(t),this.isEmpty())return;let i=!1;const n=Kt.getComponentCount(t),o=this.getAttributeStreamRef(t),a=Number.isNaN(s);if(o.getPersistence()===1){const h=o;for(let m=e,l=this.m_pointCount*n;m<l;m+=n){const u=h.read(m);(a||u===s)&&Number.isNaN(u)||(h.write(m,s),i=!0)}}else for(let h=e,m=this.m_pointCount*n;h<m;h+=n)o.readAsDbl(h)!==s&&(o.writeAsDbl(h,s),i=!0);i&&this.notifyModifiedFlags(2001)}replaceNaNs(t,e){if(this.addAttribute(t),this.isEmpty())return;let s=!1;const i=Kt.getComponentCount(t),n=this.getAttributeStreamRef(t);for(let o=0;o<i;o++)if(n.getPersistence()===1){const a=n;for(let h=0,m=this.m_pointCount*i;h<m;h++){const l=a.read(h);Number.isNaN(l)&&(a.write(h,e),s=!0)}}else for(let a=0,h=this.m_pointCount*i;a<h;a++){const m=n.readAsDbl(a);Number.isNaN(m)&&(n.writeAsDbl(a,e),s=!0)}s&&this.notifyModifiedFlags(2001)}calculateLength3D(t){return b(0),0}setEnvelopeForImport(t){this.m_description.equals(t.getDescription())||H(""),this.m_envelopeData=new ls({moveEnv:t}),this.setDirtyFlagProtected(192,!1)}copyTo(t){t.getGeometryType()!==this.getGeometryType()&&H(""),this!==t&&this.copyToUnchecked(t,!1)}queryCoordinates(t,e,s,i){let n=i<0?this.m_pointCount:i;if(n=Math.min(n,s+e),(s<0||n<s||this.m_pointCount>0&&s>=this.m_pointCount)&&H(""),this.m_pointCount===0)return n;const o=this.getAttributeStreamRef(0);for(let a=2*s,h=2*n,m=0;a<h;a+=2,m++)o.queryPoint2D(a,t[m]);return n}queryCoordinates3D(t,e,s,i){let n=i<0?this.m_pointCount:i;if(n=Math.min(n,s+e),(s<0||n<s||this.m_pointCount>0&&s>=this.m_pointCount)&&H(""),this.m_pointCount===0)return n;const o=this.getAttributeStreamRef(0);let a=null;const h=Kt.getDefaultValue(1),m=this.m_description.hasAttribute(1);m&&(a=this.getAttributeStreamRef(1));let l=0;for(let u=s;u<n;u++,l++)t[l].x=o.read(2*u),t[l].y=o.read(2*u+1),t[l].z=m?a.read(u):h;return n}clearAndSetDirtyFlagProtected(t,e){let s=0;const i=t&~e,n=e|i;s=this.m_flags,(s&n)!==e&&(this.m_flags=s&~i|e)}getIsSimple(t,e){e[0]=0;let s=-1;const i=this.m_flags,n=this.m_simpleTolerance;return 1&i||(s=(14&i)>>1,e[0]=n,n<t&&(s=-1)),s}setIsSimple(t,e,s=!1){if(t===2?b(this.getGeometryType()===T.enumPolyline):t===1?b(this.getGeometryType()===T.enumMultiPoint||this.getGeometryType()===T.enumPolyline):t===3&&b(this.getGeometryType()===T.enumPolygon),t===-1)this.setDirtyFlagProtected(17,!0);else{let i=t<<1;s||(i|=16),this.clearAndSetDirtyFlagProtected(31,i),this.m_simpleTolerance!==e&&(this.m_simpleTolerance=e)}}attributeStreamIsAllocated(t){this.throwIfEmpty();const e=this.m_description.getAttributeIndex(t);return e>=0&&this.m_vertexAttributes.get(e)!==null}capacity(){return this.m_reservedPointCount===-1&&this.m_pointCount===0?0:this.m_reservedPointCount}getDescriptionImpl(){return this.m_description}copyToUnchecked(t,e=!1){e&&this.hasDirtyFlag(32)&&kd("Cannot do shallow clone on unprepared geometry");const s=t,i=this.getGeometryType(),n=s.getGeometryType();b(i===n||i===T.enumPolygon&&n===T.enumPolyline,"failure in copyToUnchcked"),s.clearAccelerators(),s.m_description=this.m_description,s.m_vertexAttributes.destroyAndSetSize(0),s.m_envelopeData.releaseAttributes();const o=this.m_description.getAttributeCount(),a=new Or;if(!this.m_vertexAttributes.empty()){a.destroyAndSetSize(o);for(let h=0;h<o;h++)if(this.m_vertexAttributes.get(h))if(e)a.set(h,this.m_vertexAttributes.get(h));else{const m=Kt.getComponentCount(this.m_description.getSemantics(h));a.set(h,this.m_vertexAttributes.get(h).restrictedClone(this.getPointCount()*m))}}if(this.m_envelopeData.copyToIfNotNull(this.m_description,s.m_envelopeData),s.m_flags=this.m_flags,s.m_simpleTolerance=this.m_simpleTolerance,i!==n){const h=[Number.NaN];s.getIsSimple(0,h)>=3?s.setIsSimple(1,h[0]):s.setIsSimple(-1,0)}s.m_vertexAttributes.swap(a),a.destroyAndSetSize(0),s.m_pointCount=this.m_pointCount,s.hasDirtyFlag(32)||s.m_vertexAttributes.empty()?(b(!e||s.m_pointCount===0),s.m_reservedPointCount=-1):s.m_reservedPointCount=s.m_pointCount;try{this.copyToImpl(s,e)}catch(h){throw s.setEmpty(),h}s.verifyAllStreamsAfterSizeChange()}buildRasterizedGeometryAccelerator(t,e){return!1}getAccelerators(){return this.m_accelerators}clearAccelerators(){this.m_accelerators&&this.m_accelerators.release(),this.m_accelerators=null}ensureUniqueAccelerators(){if(this.m_accelerators&&!this.m_accelerators.uniqueUse()){const t=this.m_accelerators.clone();this.m_accelerators.release(),this.m_accelerators=t}}interpolateTwoVertices(t,e,s,i){(t<0||t>=this.m_pointCount)&&ut(""),(e<0||e>=this.m_pointCount)&&ut(""),i.assignVertexDescription(this.m_description);const n=j(Kt.maxComponentCount(),Number.NaN),o=j(Kt.maxComponentCount(),Number.NaN),a=Hs();let h=0;for(let m=0;m<this.m_description.getAttributeCount();m++){const l=this.m_description.getSemantics(m),u=Kt.getInterpolation(l),c=Kt.getComponentCount(l),g=Kt.getDefaultValue(l);this.queryAttributeAsDbl(l,t,n,c),this.queryAttributeAsDbl(l,e,o,c),b(h+c<=Cm),wo(u,n,o,a,h,c,s,g),h+=c}qp(i,a)}getShortestDistance(t,e){return y.distance(this.getXY(t),this.getXY(e))}getShortestSqrDistance(t,e){return y.sqrDistance(this.getXY(t),this.getXY(e))}resizeImpl(t){if(t<0&&H(),(t=Math.ceil(t))===this.m_pointCount)return;this.m_pointCount=t;const e=this.m_pointCount<=this.m_reservedPointCount?2001:4095;this.notifyModifiedFlags(e)}assignVertexDescriptionImpl(t){if(!this.m_vertexAttributes.empty()){const e=ua();ca(t,this.m_description,e);const s=new Or;s.destroyAndSetSize(t.getAttributeCount());for(let i=0;i<t.getAttributeCount();i++){const n=e[i];n!==-1?s.set(i,this.m_vertexAttributes.get(n)):this.m_reservedPointCount=-1}s.swap(this.m_vertexAttributes)}this.m_description=t,this.m_envelopeData.releaseAttributes(),this.notifyModifiedFlags(4095)}hasDirtyFlag(t){return(this.m_flags&t)!==0}setDirtyFlagProtected(t,e){e?this.m_flags|=t:this.m_flags&=~t}notifyModifiedAllImpl(){}verifyAllStreamsAfterSizeChange(){this.hasDirtyFlag(32)&&this.verifyAllStreamsAfterSizeChangeImpl()}verifyAllStreamsAfterSizeChangeImpl(){if(this.hasDirtyFlag(32)){if(this.m_reservedPointCount<this.m_pointCount){this.m_vertexAttributes.empty()&&this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()),this.m_reservedPointCount=-1;let t=Number.MAX_SAFE_INTEGER,e=0;e=this.m_pointCount<4?3:this.m_pointCount<=128?2*this.m_pointCount:Math.trunc((4*this.m_pointCount+2)/3);for(let s=0;s<this.m_description.getAttributeCount();s++){const i=this.m_description.getSemantics(s);let n=0;if(this.m_vertexAttributes.get(s)!==null){const o=Kt.getComponentCount(i);n=this.m_vertexAttributes.get(s).size()/o,n<this.m_pointCount&&(this.m_vertexAttributes.get(s).resize(e*o,Kt.getDefaultValue(i)),n=e)}else this.m_vertexAttributes.set(s,Qc(i,e)),n=e;n<t&&(t=n)}this.m_reservedPointCount=t}this.verifyStreamsAfterSizeChangeExtraImpl(),this.setDirtyFlagProtected(32,!1)}}verifyStreamsAfterSizeChangeExtraImpl(){}updateAllDirtyIntervals(t){if(t?this.hasDirtyFlag(192):this.hasDirtyFlag(128)){if(this.isEmpty())return this.hasDirtyFlag(192)&&this.m_envelopeData.setEmpty(this.m_description),void this.setDirtyFlagProtected(192,!1);const e=this.updateXYImpl(t),s=new Ne({vd:this.m_description});s.setEnvelope(e);for(let i=1;i<this.m_description.getAttributeCount();i++){const n=this.m_description.getSemantics(i),o=Kt.getComponentCount(n),a=this.m_vertexAttributes.get(i);for(let h=0;h<o;h++){const m=new z;m.setEmpty();for(let l=0;l<this.m_pointCount;l++){const u=a.readAsDbl(l*o+h);m.mergeCoordinate(u)}s.setIntervalEnvelope(n,h,m)}}(t?this.hasDirtyFlag(192):this.hasDirtyFlag(128))&&(this.m_envelopeData=new ls({moveEnv:s}),this.clearDirtyIntervalsFlag(t))}}updateXYImpl(t){const e=F.constructEmpty(),s=this.m_vertexAttributes.get(0);return e.mergePointsInterleaved(s,0,this.m_pointCount),e}updateEnvelope3D(t){b(0)}updateLooseEnvelope(t){this.updateAllDirtyIntervals(!1),t instanceof F?t.assign(this.m_envelopeData.m_envelope2D):this.m_envelopeData.queryEnvelope3D(this.m_description,t)}updateEnvelope(t){this.updateAllDirtyIntervals(!0),t.assign(this.m_envelopeData.m_envelope2D)}setEmptyImpl(){this.m_pointCount=0,this.m_reservedPointCount=-1,this.m_vertexAttributes.destroyAndSetSize(0),this.notifyModifiedFlags(4095)}clearDirtyIntervalsFlag(t){this.setDirtyFlagProtected(192,!1)}reserveImpl(t,e){if(t<0&&H(""),t===0)return;let s=t=Math.ceil(t);if(this.m_reservedPointCount<s){this.m_vertexAttributes.empty()&&this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()),e?(this.m_vertexAttributes.get(0)===null&&this.m_vertexAttributes.set(0,_o(0,0)),this.m_vertexAttributes.get(0).resizeRounded(2*s),s=this.m_vertexAttributes.get(0).size()>>1):this.m_vertexAttributes.get(0)===null?this.m_vertexAttributes.set(0,_o(0,s)):this.m_vertexAttributes.get(0).resize(2*s);for(let i=1;i<this.m_description.getAttributeCount();i++){const n=this.m_description.getSemantics(i),o=Kt.getComponentCount(n);this.m_vertexAttributes.get(i)!==null?this.m_vertexAttributes.get(i).resize(s*o):this.m_vertexAttributes.set(i,_o(n,s))}this.reserveImplImpl(s,e),this.m_reservedPointCount=s}}reserveRounded(t){t<0&&H(),t=Math.ceil(t),this.reserveImpl(t,!0)}reserveImplImpl(t,e){}throwIfEmpty(){this.isEmptyImpl()&&aa("")}}class Zt extends tg{constructor(t){super(t),t&&(t.points?this.addPoints2D(t.points,t.pointsSize,0,-1):t.point&&this.add(t.point))}assignCopy(t){return t.copyTo(this),this}assignMove(t){return t.copyTo(this),t.setEmpty(),this}insertPoint2D(t,e){t>this.getPointCount()&&H("invalid point index"),t<0&&(t=this.getPointCount());const s=this.m_pointCount;this.resizeNoInit(this.m_pointCount+1);for(let i=0,n=this.m_description.getAttributeCount();i<n;i++){const o=this.m_description.getSemantics(i),a=Mt.getComponentCount(o);if(o===0)this.m_vertexAttributes.get(i).insert(a*t,e,a*s);else{const h=Mt.getDefaultValue(o);this.m_vertexAttributes.get(i).insertRange(a*t,h,a,a*s)}}this.notifyModifiedFlags(2001)}insertPoint(t,e){e.isEmpty()&&H(fh),t<0&&(t=this.getPointCount()),this.mergeVertexDescription(e.getDescription());const s=this.m_pointCount;this.resizeNoInit(this.m_pointCount+1);for(let i=0,n=this.m_description.getAttributeCount();i<n;i++){const o=this.m_description.getSemantics(i),a=Mt.getComponentCount(o);if(e.hasAttribute(o))this.m_vertexAttributes.get(i).insertAttributes(a*t,e,o,a*s);else{const h=Mt.getDefaultValue(o);this.m_vertexAttributes.get(i).insertRange(a*t,h,a,a*s)}}this.notifyModifiedFlags(2001)}insertPoints(t,e,s){if((t>this.getPointCount()||s<0)&&ut(""),t<0&&(t=this.getPointCount()),s===0)return;const i=e[0].getDescription();this.mergeVertexDescription(i);const n=this.m_pointCount;this.resizeNoInit(this.m_pointCount+s);for(let o=0,a=this.m_description.getAttributeCount();o<a;o++){const h=this.m_description.getSemantics(o),m=Mt.getComponentCount(h);if(this.m_vertexAttributes.get(o))if(i.hasAttribute(h))this.m_vertexAttributes.get(o).insertAttributesFromPoints(t*m,e,s,h,n*m);else{const l=Mt.getDefaultValue(h);this.m_vertexAttributes.get(o).insertRange(m*t,l,m*s,m*n)}}this.notifyModifiedFlags(2001)}insertPoints2D(t,e,s){if((t>this.getPointCount()||s<0)&&H("invalid point index"),t<0&&(t=this.getPointCount()),s===0)return;const i=this.m_pointCount;this.resizeNoInit(this.m_pointCount+s);for(let n=0,o=this.m_description.getAttributeCount();n<o;n++){const a=this.m_description.getSemantics(n),h=Mt.getComponentCount(a);if(this.m_vertexAttributes.get(n))if(a===0)this.m_vertexAttributes.get(n).insertRangeFromPoints(h*t,e,0,s,!0,h*i);else{const m=Mt.getDefaultValue(a);this.m_vertexAttributes.get(n).insertRange(h*t,m,h,h*i)}}this.notifyModifiedFlags(2001)}removePoints(t,e){if((t<0||e<0||t+e>this.getPointCount())&&ut("remove_points"),e!==0){for(let s=0,i=this.m_description.getAttributeCount();s<i;s++)if(this.m_vertexAttributes.get(s)){const n=this.m_description.getSemantics(s),o=Mt.getComponentCount(n);this.m_vertexAttributes.get(s).eraseRange(o*t,o*e,o*this.m_pointCount)}this.m_pointCount-=e,this.m_reservedPointCount>0&&(this.m_reservedPointCount-=e),this.notifyModifiedFlags(2001)}}removePoint(t){for(let e=0,s=this.m_description.getAttributeCount();e<s;e++)if(this.m_vertexAttributes.get(e)){const i=this.m_description.getSemantics(e),n=Mt.getComponentCount(i);this.m_vertexAttributes.get(e).eraseRange(n*t,n,n*this.m_pointCount)}this.m_pointCount--,this.m_reservedPointCount>0&&this.m_reservedPointCount--,this.notifyModifiedFlags(2001)}calculateEnvelope2D(){return this.updateXYImpl(!0)}resizeNoInit(t){this.resizeImpl(t)}resizeAndInitNonPositionAttributes(t){const e=this.m_pointCount;if(this.resizeImpl(t),this.m_pointCount>e)for(let s=1,i=this.m_description.getAttributeCount();s<i;s++){const n=this.m_description.getSemantics(s),o=Mt.getDefaultValue(n),a=Mt.getComponentCount(n);this.m_vertexAttributes.get(s).insertRange(a*e,o,a*(this.m_pointCount-e),a*e)}}queryCoordinates3D(t,e,s,i){let n=i<0?this.m_pointCount:i;if(n=Math.min(n,s+e),(s<0||n<s||this.m_pointCount>0&&s>=this.m_pointCount)&&H(""),this.m_pointCount===0)return n;const o=this.getAttributeStreamRef(0);let a=null;const h=Mt.getDefaultValue(1),m=this.m_description.hasAttribute(1);m&&(a=this.getAttributeStreamRef(1));let l=0;for(let u=s;u<n;u++,l++)t[l].x=o.read(2*u),t[l].y=o.read(2*u+1),t[l].z=m?a.read(u):h;return n}queryAttributeAsInt(t,e,s,i){b(0)}add(t){t.isEmpty()&&H(fh),this.resizeAndInitNonPositionAttributes(this.m_pointCount+1),this.setPointByValNoCurves(this.m_pointCount-1,t)}addXY(t,e){this.resizeAndInitNonPositionAttributes(this.m_pointCount+1);const s=new y(t,e);this.setXYNoCurves(this.m_pointCount-1,s)}addXYZ(t,e,s){this.resizeAndInitNonPositionAttributes(this.m_pointCount+1);const i=new mt;i.setCoords(t,e,s),this.setXYZNoCurves(this.m_pointCount-1,i)}addPoint2D(t){this.addXY(t.x,t.y)}addPoint3D(t){this.addXYZ(t.x,t.y,t.z)}addPoints(t,e,s){this===t&&H("Multi_point_impl.add");const i=s<0?t.getPointCount():s;if((e<0||e>t.getPointCount()||i<e)&&H(""),e===i)return;const n=t.getDescription();this.mergeVertexDescription(n);const o=i-e,a=this.m_pointCount;this.resizeNoInit(this.m_pointCount+o);for(let h=0,m=this.m_description.getAttributeCount();h<m;h++){const l=this.m_description.getSemantics(h),u=Mt.getComponentCount(l),c=this.getAttributeStreamRef(l);if(n.hasAttribute(l)){const g=t.getAttributeStreamRef(l);c.insertRangeFromStream(a*u,g,e*u,o*u,!0,1,a*u)}else{const g=Mt.getDefaultValue(l);c.insertRange(a*u,g,o*u,a*u)}}}addPoints2D(t,e,s,i){let n=e;const o=i<0?n:i;if((n<0||s<0||s>n||o<s)&&H(""),s===o)return;n=o-s;const a=this.m_pointCount;this.resizeAndInitNonPositionAttributes(this.m_pointCount+n);const h=this.getAttributeStreamRef(0);for(let m=0;m<n;++m)h.writePoint2D(2*(a+m),t[s+m]);this.notifyModifiedFlags(2001)}addPoints3D(t,e,s,i){let n=e;const o=i<0?n:i;if((n<0||s<0||s>n||o<s)&&H(""),this.addAttribute(1),s===o)return;n=o-s;const a=this.m_pointCount;this.resizeAndInitNonPositionAttributes(this.m_pointCount+n);const h=this.getAttributeStreamRef(0),m=new y;for(let u=0;u<n;u++)m.x=t[s+u].x,m.y=t[s+u].y,h.writePoint2D(2*(a+u),m);const l=this.getAttributeStreamRef(1);for(let u=0;u<n;u++)l.write(a+u,t[s+u].z);this.notifyModifiedFlags(2001)}setPointByVal(t,e){this.setPointByValNoCurves(t,e)}setXY(t,e){this.setXYNoCurves(t,e)}setXYCoords(t,e,s){this.setXYCoordsNoCurves(t,e,s)}setXYZ(t,e){this.setXYZNoCurves(t,e)}setAttribute(t,e,s,i){this.setAttributeNoCurves(t,e,s,i)}getGeometryType(){return T.enumMultiPoint}getDimension(){return 0}createInstance(){return new Zt({vd:this.getDescription()})}setEmpty(){this.setEmptyImpl()}applyTransformation(t){if(this.isEmpty()||t.isIdentity())return;const e=this.m_vertexAttributes.get(0);t.m_TransformationType===1?e.applyTransformation(t,0,this.m_pointCount):ft("3d xform not impl"),this.notifyModifiedFlags(2001)}calculateArea2D(){return 0}calculateLength2D(){return 0}calculateLength3D(t){return 0}equals(t,e){return t.getGeometryType()===T.enumMultiPoint&&this.equalsBase(t,e)}queryEnvelope(t){t.m_EnvelopeType===4?(this.updateAllDirtyIntervals(!0),this.m_envelopeData.copyTo(this.m_description,t)):t.m_EnvelopeType===2?this.updateEnvelope(t):ft("")}getImpl(){return this}getBoundary(){return null}reserve(t){this.reserveImpl(t)}clone(){const t=this.createInstance();return this.copyTo(t),t}swap(t){b(0)}buildQuadTreeAccelerator(t){return!1}getHashCodeImpl(){return b(0),0}equalsImpl(t){return!0}equalsImplTol(t,e){return!0}copyToImpl(t,e){}}Zt.type=T.enumMultiPoint;class ce{constructor(){this.m_EnvelopeType=5,this.envAabb=F.constructEmpty(),this.envRot=F.constructEmpty()}static constructEmpty(){return new ce}width(){return this.envAabb.width()}height(){return this.envAabb.height()}maxDim(){return Math.max(this.width(),this.height())}setEmpty(){this.envAabb.setEmpty(),this.envRot.setEmpty()}setCoords(t){this.envAabb.setCoords(t),this.envRot.setCoords({x:mn(t),y:ln(t)})}setFromPoints(t,e){this.setEmpty(),this.mergePoints(t,e)}mergeNe(t){this.envAabb.mergeNe(t),this.envRot.mergeNeCoords(mn(t),ln(t))}mergePoints(t,e){this.envAabb.mergePoints(t,e);for(let s=0;s<e;){if(!this.envRot.isEmpty()){for(let i=s;i<e;i++){const n=mn(t[i]),o=ln(t[i]);this.envRot.mergeNeCoords(n,o)}break}{const i=mn(t[s]),n=ln(t[s]);this.envRot.setCoords({x:i,y:n}),s++}}}isIntersectingPoint2D(t){return!(!this.envAabb.contains(t)||!this.envRot.containsCoords(mn(t),ln(t)))}isIntersectingW(t){return this.envAabb.isIntersecting(t.envAabb)&&this.envRot.isIntersecting(t.envRot)}containsW(t){return!(!this.envAabb.containsEnvelope(t.envAabb)||!this.envRot.containsEnvelope(t.envRot))}containsPoint2D(t){return this.isIntersectingPoint2D(t)}intersectW(t){const e=this.envAabb.intersect(t.envAabb),s=this.envRot.intersect(t.envRot);return e&&!s&&this.envAabb.setEmpty(),s&&!e&&this.envRot.setEmpty(),e&&s}inflate(t){this.envAabb.inflateCoords(t,t);const e=t*jd();this.envRot.inflateCoords(e,e),e<0&&ce.st_reduceEmpty(this)}static st_reduceEmpty(t){const e=t.envAabb.isEmpty(),s=t.envRot.isEmpty();e&&!s?t.envRot.setEmpty():s&&!e&&t.envAabb.setEmpty()}sqrMaxMinDistance(t){const e=this.envAabb.sqrMaxMinDistance(t),s=this.envRot.sqrMaxMinDistance(Ra(t))/2;return Math.max(e,s)}sqrMinDistance(t){const e=this.envAabb.sqrMinDistance(t),s=this.envRot.sqrMinDistance(Ra(t))/2;return Math.max(e,s)}sqrMaxDistance(t){const e=this.envAabb.sqrMaxDistance(t),s=this.envRot.sqrMaxDistance(Ra(t))/2;return Math.max(e,s)}getEnvelope2D(){return this.envAabb}getRotatedEnvelope2D(){return this.envRot}xyRot(t,e){const s=Fp(t.x,t.y),i=Mp(t.x,t.y);e.setCoords(s,i)}}function Fp(r,t){return r-t}function Mp(r,t){return r+t}function mn(r){return r.x-r.y}function ln(r){return r.x+r.y}function Ra(r){return new y(mn(r),ln(r))}class K{constructor(){this.x=L.getNAN(),this.y=L.getNAN()}static getNAN(){return new K}static constructPoint2D(t){const e=new K;return e.x.set(t.x),e.y.set(t.y),e}static constructCoords(t,e){const s=new K;return s.x.set(t),s.y.set(e),s}static constructCoordsE(t,e){const s=new K;return s.setCoordsE(t,e),s}get 0(){return this.x.clone()}set 0(t){this.x.setE(t)}get 1(){return this.y.clone()}set 1(t){this.y.setE(t)}clone(){return new K().setE(this)}scaleThis(t){return this.x.mulThisE(t),this.y.mulThisE(t),this}setCoords(t,e){return this.x.set(t),this.y.set(e),this}setCoordsE(t,e){return this.x.setE(t),this.y.setE(e),this}set(t){return this.x.set(t.x),this.y.set(t.y),this}setE(t){return this.x.setE(t.x),this.y.setE(t.y),this}setWithEps(t,e){return this.x.setWithEps(t.x,e),this.y.setWithEps(t.y,e),this}getUnitVector(){const t=this.clone();return t.normalize(),t}sqrLength(){return this.x.sqr().addE(this.y.sqr())}length(){return this.sqrLength().sqrt()}mulE(t){const e=new K;return e.setCoordsE(this.x.mulE(t),this.y.mulE(t)),e}mul(t){const e=new K;return e.setCoordsE(this.x.mul(t),this.y.mul(t)),e}mulThis(t){return this.x.mulThis(t),this.y.mulThis(t),this}mulThisE(t){return this.x.mulThisE(t),this.y.mulThisE(t),this}divE(t){return this.clone().divThisE(t)}divThisE(t){return this.x.divThisE(t),this.y.divThisE(t),this}normalize(){const t=this.length();t.value()===0?(this.x=er.clone(),this.y=qn.clone()):(this.x.divThisE(t),this.y.divThisE(t))}addE(t){return this.clone().addThisE(t)}addThisE(t){return this.x.addThisE(t.x),this.y.addThisE(t.y),this}subE(t){return this.clone().subThisE(t)}subThisE(t){return this.x.subThisE(t.x),this.y.subThisE(t.y),this}static distance(t,e){return t.subE(e).length()}negateThis(){return this.x.negateThis(),this.y.negateThis(),this}eq(t){return this.x.eq(t.x)&&this.y.eq(t.y)}isZero(){return this.x.isZero()&&this.y.isZero()}isTrueZero(){return!this.x.value()&&!this.y.value()}rotateDirect(t,e){const s=this.x.mulE(t).subThisE(this.y.mulE(e)),i=this.x.mulE(e).addThisE(this.y.mulE(t));return this.x.setE(s),this.y.setE(i),this}rotateReverse(t,e){const s=this.x.mulE(t).addThisE(this.y.mulE(e)),i=this.x.negate().mulThisE(e).addThisE(this.y.mulE(t));return this.x.setE(s),this.y.setE(i),this}dotProduct(t){return this.x.mulE(t.x).addE(this.y.mulE(t.y))}crossProduct(t){return this.x.mulE(t.y).subE(this.y.mulE(t.x))}value(){return y.construct(this.x.value(),this.y.value())}}class ar{constructor(){this.a11=new L(1),this.a12=new L(0),this.a21=new L(0),this.a22=new L(1)}clone(){const t=new ar;return t.a11.setE(this.a11),t.a12.setE(this.a12),t.a21.setE(this.a21),t.a22.setE(this.a22),t}assign(t){return this.a11.setE(t.a11),this.a12.setE(t.a12),this.a21.setE(t.a21),this.a22.setE(t.a22),this}mulThis(t){const e=this.a11.mulE(t.a11).addThisE(this.a12.mulE(t.a21)),s=this.a11.mulE(t.a12).addThisE(this.a12.mulE(t.a22)),i=this.a21.mulE(t.a11).addThisE(this.a22.mulE(t.a21)),n=this.a21.mulE(t.a12).addThisE(this.a22.mulE(t.a22));return this.a11=e,this.a12=s,this.a21=i,this.a22=n,this}mulLeftThis(t){const e=t.clone();return this.assign(e.mulThis(this)),this}det(){return this.a11.mulE(this.a22).subThisE(this.a12.mulE(this.a21))}invertThis(){const t=this.det();if(t.value()!==0){const e=this.a22.divE(t),s=this.a12.negate().divThisE(t),i=this.a21.negate().divThisE(t),n=this.a11.divE(t);this.a11=e,this.a12=s,this.a21=i,this.a22=n}else this.setZero();return!t.isZero()}transposeThis(){return this.a21=O(this.a12,this.a12=this.a21),this}eigenSymmetric(t,e){const s=this.a12.clone();s.addThisE(this.a21),s.mulThisByPower2(.5);let i=new L(1),n=new L(0);if(s.isZero())t[0].setE(this.a11),t[1].setE(this.a22);else{const o=new L(1);if(this.a11.ne(this.a22)){const a=this.a11.subE(this.a22).divE(s);a.mulThisByPower2(.5);const h=a.sqr();o.setE(a),o.absThis(),o.subThisE(h.add(1).sqrtThis()),a.gt(qn)&&o.negateThis();const m=o.sqr().addThis(1).sqrtThis().invThis();n=o.mulE(m),i.setE(m);const l=o.mulE(s);t[0]=this.a11.addE(l),t[1]=this.a22.subE(l)}else i=new L(1/Math.sqrt(2)),n=i.clone(),t[0]=this.a11.addE(s),t[1]=this.a22.subE(s)}e[0].x=i.toDouble(),e[0].y=n.toDouble(),e[1].x=n.negate().toDouble(),e[1].y=i.toDouble(),Math.abs(t[0].toDouble())>Math.abs(t[1].toDouble())&&(t[1]=O(t[0],t[0]=t[1]),e[1]=O(e[0],e[0]=e[1]))}setZero(){this.a11.set(0),this.a21.set(0),this.a12.set(0),this.a22.set(0)}}class Et{static constructPoint2D(t){return new Et(J.constructDouble(t.x),J.constructDouble(t.y))}constructor(t,e){if(t===void 0)return this.x=new J().setNAN(),void(this.y=new J().setNAN());this.x=t.clone(),this.y=e.clone()}assignPoint2D(t){return this.x.setDouble(t.x),this.y.setDouble(t.y),this}setCoords(t,e){return this.x.setThis(t),this.y.setThis(e),this}asPoint2D(){return new y(this.x.value(),this.y.value())}crossProduct(t){return this.x.mul(t.y).sub(this.y.mul(t.x))}leftPerpendicularThis(){const t=this.x.clone();this.x=this.y.clone().negate(),this.y=t}clone(){return new Et(this.x,this.y)}dotProduct(t){return this.x.mul(t.x).add(this.y.mul(t.y))}add(t){return new Et(this.x.add(t.x),this.y.add(t.y))}sub(t){return new Et(this.x.sub(t.x),this.y.sub(t.y))}sqrLength(){return this.x.sqr().addThis(this.y.sqr())}mulThis(t){return this.x.mulThis(t),this.y.mulThis(t),this}mul(t){return this.clone().mulThis(t)}subThis(t){return this.x.subThis(t.x),this.y.subThis(t.y),this}addThis(t){return this.x.addThis(t.x),this.y.addThis(t.y),this}}var Si=Mt;function eg(r){let t=!1;for(let e=0;e<2;e++){const s=Vt(r[0][e],r[3][e]);s>0?(Vt(r[0][e],r[1][e])<0&&(r[1][e]=r[0][e],t=!0),Vt(r[1][e],r[3][e])<0&&(r[1][e]=r[3][e],t=!0),Vt(r[0][e],r[2][e])<0&&(r[2][e]=r[0][e],t=!0),Vt(r[2][e],r[3][e])<0&&(r[2][e]=r[3][e],t=!0),Vt(r[1][e],r[2][e])<0&&(r[2][e]=r[1][e],t=!0)):s<0?(Vt(r[0][e],r[1][e])>0&&(r[1][e]=r[0][e],t=!0),Vt(r[1][e],r[3][e])>0&&(r[1][e]=r[3][e],t=!0),Vt(r[0][e],r[2][e])>0&&(r[2][e]=r[0][e],t=!0),Vt(r[2][e],r[3][e])>0&&(r[2][e]=r[3][e],t=!0),Vt(r[1][e],r[2][e])>0&&(r[2][e]=r[1][e],t=!0)):r[1][e]===r[0][e]&&r[2][e]===r[0][e]||(r[1][e]=r[0][e],r[2][e]=r[0][e],t=!0)}return t}function Gp(r){const t=Vt(r[0].y,r[1].y),e=Vt(r[1].y,r[2].y),s=Vt(r[2].y,r[3].y);if(t>=0&&e>=0&&s>=0||t<=0&&e<=0&&s<=0){const i=Vt(r[0].x,r[1].x),n=Vt(r[1].x,r[2].x),o=Vt(r[2].x,r[3].x);if(i>=0&&n>=0&&o>=0||i<=0&&n<=0&&o<=0)return!0}return!1}function is(r,t){const e=r.getStartXY();if(e.equals(t.getStartXY())||e.equals(t.getEndXY()))return!0;const s=r.getEndXY();return!!s.equals(t.getStartXY())||!!s.equals(t.getEndXY())}function _a(r,t){let e=r.calculateLowerLength2D();return!(e>t)&&(!!r.isLine()||(e=r.calculateUpperLength2D(),e<=t||t!==0&&r.calculateLength2D()<=t))}function sg(r,t,e){const s=R(y,4);let i=r.queryControlPointsHelper(s);const n=R(y,4);let o=t.queryControlPointsHelper(n);s[0].equals(n[0])||To("");const a=r.getGeometryType();if(a===t.getGeometryType()&&s.map((m,l)=>n[l].equals(m)).reduce((m,l)=>m&&l)){if(a!==T.enumRationalBezier2)return 0;{const m=t,l=[0,0,0],u=[0,0,0];if(r.queryWeights(l),m.queryWeights(u),l.map((c,g)=>u[g]===c).reduce((c,g)=>c&&g))return 0}}for(;i>2&&s[1].equals(s[0]);)s.splice(1,1),i--;for(;o>2&&n[1].equals(n[0]);)n.splice(1,1),o--;(s[1].equals(s[0])||n[1].equals(s[0]))&&To("");const h=y.compareVectorsOrigin(s[0],s[1],n[1]);if(h===0){const m=Et.constructPoint2D(s[0]),l=new Et;r.queryCoord2DMP(1e-16,l),l.sub(m);const u=new Et;return t.queryCoord2DMP(1e-16,u),u.sub(m),u.crossProduct(l).sign()}return h}function ig(r,t,e,s,i,n,o,a){let h=r.calculateUpperLength2D(),m=t.calculateUpperLength2D(),l=r,u=t,c=!1;h>m&&(u=O(l,l=u),s=O(e,e=s),m=O(h,h=m),c=!0);const g=e===0;{o[0]=g?1:0;const S=l.getCoord2D(o[0]);a[0]=u.getClosestCoordinate(S,!1);const I=u.getCoord2D(a[0]);if(y.distance(S,I)<=i){const w=[.5,.75,.25,.1,.9];let D=!0;for(let N=0;N<w.length;N++)if(S.assign(l.getCoord2D(w[N])),!u.isCloserThanDistance(S,new z(0,1),i)){D=!1;break}if(D)return c&&(a[0]=O(o[0],o[0]=a[0])),1}}if(h<=3*i)return 0;let _=Nt(Math.max(i/h,.1),0,.5),d=.01*i,p=0,f=0,x=_,E=-1,P=0,C=1/32;for(let S=0;;S++){b(S<4095);const I=g?_:1-_,w=l.getCoord2D(I),D=u.getClosestCoordinate(w,!1);if(D===s)return P;const N=u.getCoord2D(D),A=y.distance(w,N);if(S===0&&(E=A),A<=d?(C=.5,f=A,p=_):(x=_,E=A),Math.abs(f-E)>.1*d&&x-p>1e-16)_=Ct(p,x,C);else{if(o[P]=I,a[P]=D,c&&(a[P]=O(o[P],o[P]=a[P])),n===1||P===1)return P===1&&o[0]>o[1]&&(o[1]=O(o[0],o[0]=o[1]),a[1]=O(a[0],a[0]=a[1])),P+1;P++,p=x,f=E,x=.8,E=-1,_=.8,C=1/32,d=10*i,S=0}}}function Un(r,t,e,s,i,n,o,a,h){if(qt(e,0,1)&&qt(s,0,1)&&y.distance(r.getCoord2D(e),t.getCoord2D(s))===0){const l=new K,u=jt();if(r.queryDerivative(new L(e,u),l),l.isTrueZero()){const p=e===1?-1e-12:1e-12;r.queryDerivative(new L(e,u).add(p),l)}e===1&&l.negateThis();const c=new K;if(t.queryDerivative(new L(s,u),c),c.isTrueZero()){const p=e===1?-1e-12:1e-12;t.queryDerivative(new L(s,u).add(p),c)}s===1&&c.negateThis(),l.isZero()||l.normalize(),c.isZero()||c.normalize();const g=l.dotProduct(c),_=l.crossProduct(c);_.scaleError(3);const d=()=>{{const p=r.calculateUpperLength2D(),f=t.calculateUpperLength2D();return Math.min(.01*i/Math.min(p,f),1e-10)}};if(g.ge(qn)&&(_.isZero()||Math.abs(_.value())<d()))return ig(r,t,e,s,i,n,o,a)}return 0}function Vp(r,t,e){return b(r.isCurve()||t.isCurve()),!!(r.getStartXY().equals(t.getStartXY())&&Un(r,t,0,0,e,2,[0,0],[0,0])||r.getEndXY().equals(t.getEndXY())&&Un(r,t,1,1,e,2,[0,0],[0,0])||r.getStartXY().equals(t.getEndXY())&&Un(r,t,0,1,e,2,[0,0],[0,0])||r.getEndXY().equals(t.getStartXY())&&Un(r,t,1,0,e,2,[0,0],[0,0]))}function bm(r,t){r.m_XStart=t.x,r.m_YStart=t.y}function ql(r,t,e){r.m_XStart=t,r.m_YStart=e}function Im(r,t){r.m_XEnd=t.x,r.m_YEnd=t.y}function Fl(r,t,e){r.m_XEnd=t,r.m_YEnd=e}function Yp(r,t,e){t?r.m_XEnd===e.x&&r.m_YEnd===e.y||(r.m_XEnd=e.x,r.m_YEnd=e.y,r.endPointModified()):r.m_XStart===e.x&&r.m_YStart===e.y||(r.m_XStart=e.x,r.m_YStart=e.y,r.endPointModified())}function Ml(r,t){const e=new mt;return t?(e.x=r.m_XEnd,e.y=r.m_YEnd):(e.x=r.m_XStart,e.y=r.m_YStart),e.z=Xp(r,t),e}function Xp(r,t){return r.m_description.hasZ()?r.m_attributes[t*(r.m_description.getTotalComponentCount()-2)]:Si.getDefaultValue(1)}function Wr(r,t,e){r.m_description.hasZ()||r.addAttribute(1),t?r.m_XEnd===e.x&&r.m_YEnd===e.y||(r.m_XEnd=e.x,r.m_YEnd=e.y,r.endPointModified()):r.m_XStart===e.x&&r.m_YStart===e.y||(r.m_XStart=e.x,r.m_YStart=e.y,r.endPointModified()),r.m_attributes[(r.m_description.getTotalComponentCount()-2)*t]=e.z}function Gl(r,t,e){e.assignVertexDescription(r.m_description);const s=t===0?r.m_XStart:r.m_XEnd,i=t===0?r.m_YStart:r.m_YEnd;e.setXYCoords(s,i);for(let n=1;n<r.m_description.getAttributeCount();n++){const o=r.m_description.getSemantics(n);for(let a=0,h=Si.getComponentCount(o);a<h;a++){const m=As(r,t,o,a);e.setAttributeBasic(o,a,m)}}}function Vl(r,t,e){e.isEmpty()&&aa(""),Yp(r,t,e.getXY());const s=e.getDescription();s!==r.m_description&&r.mergeVertexDescription(s);for(let i=1,n=s.getAttributeCount();i<n;i++){const o=s.getSemantics(i),a=Si.getComponentCount(o);for(let h=0;h<a;h++)Js(r,t,o,h,e.getAttributeAsDbl(o,h))}}function As(r,t,e,s){if((t<0||t>1)&&ut(""),e===0)return(s<0||s>=2)&&ut(""),t===0?s===0?r.m_XStart:r.m_YStart:s===0?r.m_XEnd:r.m_YEnd;const i=Si.getComponentCount(e);(s<0||s>=i)&&ut("");const n=r.m_description.getAttributeIndex(e);return n>=0?r.m_attributes[t*(r.m_description.getTotalComponentCount()-2)+r.m_description.getPointAttributeOffset(n)-2+s]:Si.getDefaultValue(e)}function Js(r,t,e,s,i){if((t<0||t>1)&&ut(""),e===0)return t===0?s===0?r.m_XStart=i:s===1?r.m_YStart=i:ut(""):t===1?s===0?r.m_XEnd=i:s===1?r.m_YEnd=i:ut(""):ut(""),void r.endPointModified();const n=Si.getComponentCount(e);(s<0||s>=n)&&ut("");let o=r.m_description.getAttributeIndex(e);o<0&&(r.addAttribute(e),o=r.m_description.getAttributeIndex(e)),r.m_attributes[t*(r.m_description.getTotalComponentCount()-2)+r.m_description.getPointAttributeOffset(o)-2+s]=i}function ng(r,t){if(r===t)return;t.isEmpty()&&aa("");const e=t.getDescription();e!==r.m_description&&r.mergeVertexDescription(e);for(let s=1,i=e.getAttributeCount();s<i;s++){const n=e.getSemantics(s),o=Si.getComponentCount(n);for(let a=0;a<o;a++){let h=As(t,0,n,a);Js(r,0,n,a,h),h=As(t,1,n,a),Js(r,1,n,a,h)}}}function Rp(r,t){const e=ua();ca(t,r.m_description,e);let s=null;const i=t.getTotalComponentCount()-2,n=r.m_description?r.m_description.getTotalComponentCount()-2:0;if(i>0&&(s=j(2*i,Number.NaN),ne(s,t.getDefaultPointAttributes(),0,2,i),ne(s,t.getDefaultPointAttributes(),i,2,i),r.m_description!==null))for(let o=1;o<t.getAttributeCount();o++){const a=e[o];if(a!==-1){const h=r.m_description.getPointAttributeOffset(a)-2,m=t.getPointAttributeOffset(o)-2,l=Si.getComponentCount(t.getSemantics(o));for(let u=0;u<l;++u)s[m]=r.m_attributes[h],s[i+m]=r.m_attributes[n+h]}}r.m_attributes=s,r.m_description=t}function si(r){return r.absNorm()*ma()}function Xe(r,t){return Math.max(r.absNorm(),t.absNorm())*ma()}function ns(r,t,e){const s=new ce;r.queryEnvelopeW(z.unit(),s);const i=new ce;return t.queryEnvelopeW(z.unit(),i),i.inflate(e),!s.isIntersectingW(i)}function wm(r,t,e){const s=No(r,e),i=No(t,e);s.sort((n,o)=>n.compare(o)),i.sort((n,o)=>n.compare(o));for(let n=0;n<3;n++){if(s[n].compare(i[n])<0)return-1;if(s[n].compare(i[n])!==0)return 1}return 0}var rn=Mt;let Xr=class{constructor(t){if(t.copy)this.m_XStart=t.copy.m_XStart,this.m_YStart=t.copy.m_YStart,this.m_XEnd=t.copy.m_XEnd,this.m_YEnd=t.copy.m_YEnd,this.m_description=t.copy.m_description,this.m_attributes=null,this.m_description&&this.m_description.getTotalComponentCount()-2&&(this.m_attributes=t.copy.m_attributes.slice());else{if(t.move)return this.m_description=t.move.m_description,t.move.m_description=null,this.m_attributes=t.move.m_attributes,t.move.m_attributes=null,this.m_XStart=t.move.m_XStart,this.m_YStart=t.move.m_YStart,this.m_XEnd=t.move.m_XEnd,void(this.m_YEnd=t.move.m_YEnd);if(t.XStart!==void 0)return this.m_XStart=t.XStart,this.m_YStart=t.YStart,this.m_XEnd=t.XEnd,this.m_YEnd=t.YEnd,this.m_attributes=null,this.m_description=t.vd?t.vd:_e(),void(t.vd&&this.setDefaultAttributeValues());if(t.ZStart!==void 0)return this.m_XStart=t.XStart,this.m_YStart=t.YStart,this.m_XEnd=t.XEnd,this.m_YEnd=t.YEnd,this.m_description=t.vd?t.vd:nr(),void(t.vd?(this.setDefaultAttributeValues(),this.addAttribute(1),this.m_attributes[0]=t.ZStart,this.m_attributes[this.m_description.getTotalComponentCount()-2]=t.ZEnd):this.m_attributes=[t.ZStart,t.ZEnd]);if(t.start)return this.m_XStart=t.start.x,this.m_YStart=t.start.y,this.m_XEnd=t.end.x,this.m_YEnd=t.end.y,this.m_attributes=null,void(this.m_description=_e());if(t.start3D)return this.m_XStart=t.start3D.x,this.m_YStart=t.start3D.y,this.m_XEnd=t.end3D.x,this.m_YEnd=t.end3D.y,this.m_description=t.vd?t.vd:nr(),void(t.vd?(this.setDefaultAttributeValues(),this.addAttribute(1),this.m_attributes[0]=t.start3D.z,this.m_attributes[this.m_description.getTotalComponentCount()-2]=t.end3D.z):this.m_attributes=[t.start3D.z,t.end3D.z]);$("bad constructor params"),this.m_XStart=this.m_YStart=this.m_XEnd=this.m_YEnd=Number.NaN}}setDefaultAttributeValues(){const t=this.m_description.getTotalComponentCount()-2;t>0&&(this.m_attributes===null&&(this.m_attributes=j(2*t,Number.NaN)),ne(this.m_attributes,this.m_description.getDefaultPointAttributes(),0,2,t),ne(this.m_attributes,this.m_description.getDefaultPointAttributes(),t,2,t))}absNormXYZ(t){return ft("not implemented"),0}queryWeights(t){}snapControlPoints3D(){return ft("not implemented"),!1}setCoordsForIntersector3D(t,e,s){ft("not implemented")}transformAttribute(t,e,s,i,n){ft("")}mergeVertexDescriptionImpl(t){const e=this.getDescription(),s=Fn(e,t);this.assignVertexDescription(s)}changeEndPoints(t,e){const s=t.getXY(),i=e.getXY();this.changeEndPoints2D(s,i);let n=t.getDescription();n!==this.getDescription()&&this.mergeVertexDescription(n),n=e.getDescription(),n!==this.getDescription()&&this.mergeVertexDescription(n);for(let o=1,a=n.getAttributeCount();o<a;o++){const h=n.getSemantics(o),m=rn.getComponentCount(h);for(let l=0;l<m;l++)Js(this,0,h,l,t.getAttributeAsDbl(h,l)),Js(this,1,h,l,e.getAttributeAsDbl(h,l))}}getStartXY(){return new y(this.m_XStart,this.m_YStart)}setStartXY(t){this.m_XStart=t.x,this.m_YStart=t.y,this.endPointModified()}setStartXYCoords(t,e){this.m_XStart=t,this.m_YStart=e,this.endPointModified()}getStartXYZ(){return Ml(this,0)}setStartXYZ(t){Wr(this,0,t)}setStartXYZCoords(t,e,s){Wr(this,0,mt.construct(t,e,s))}queryStart(t){Gl(this,0,t)}setStart(t){Vl(this,0,t)}setStart2D(t){this.setStartXY(t)}getStartAttributeAsDbl(t,e){return As(this,0,t,e)}getStartAttributeAsInt(t,e){return b(0),0}setStartAttribute(t,e,s){Js(this,0,t,e,s)}setStartAttributesFromPoint(t,e){const s=t.getDescription();for(let i=e&&s.hasZ()?2:1,n=s.getAttributeCount();i<n;++i){const o=s.getSemantics(i),a=rn.getComponentCount(o);for(let h=0;h<a;++h){const m=t.getAttributeAsDbl(o,h);this.setStartAttribute(o,h,m)}}}setEndAttributesFromPoint(t,e){const s=t.getDescription();for(let i=e&&s.hasZ()?2:1,n=s.getAttributeCount();i<n;++i){const o=s.getSemantics(i),a=rn.getComponentCount(o);for(let h=0;h<a;++h){const m=t.getAttributeAsDbl(o,h);this.setEndAttribute(o,h,m)}}}getStartX(){return this.m_XStart}getStartY(){return this.m_YStart}getStartZ(){return b(0),0}getEndX(){return this.m_XEnd}getEndY(){return this.m_YEnd}getEndZ(){return b(0),0}getEndXY(){return new y(this.m_XEnd,this.m_YEnd)}setEndXY(t){this.m_XEnd=t.x,this.m_YEnd=t.y,this.endPointModified()}setEndXYCoords(t,e){this.m_XEnd=t,this.m_YEnd=e,this.endPointModified()}getEndXYZ(){return Ml(this,1)}setEndXYZ(t){Wr(this,1,t)}setEndXYZCoords(t,e,s){Wr(this,1,mt.construct(t,e,s))}queryEnd(t){Gl(this,1,t)}setEnd(t){Vl(this,1,t)}setEnd2D(t){this.setEndXY(t)}getEndAttributeAsDbl(t,e){return As(this,1,t,e)}getEndAttributeAsInt(t,e){return b(0),Math.trunc(0)}setEndAttribute(t,e,s){Js(this,1,t,e,s)}getDimension(){return 1}copyTo(t){if(this===t)return;t.getGeometryType()!==this.getGeometryType()&&H("");const e=t;e.assignVertexDescription(this.m_description),e.m_attributes&&ne(e.m_attributes,this.m_attributes,0,0,2*(this.m_description.getTotalComponentCount()-2)),e.m_XStart=this.m_XStart,e.m_YStart=this.m_YStart,e.m_XEnd=this.m_XEnd,e.m_YEnd=this.m_YEnd,this.copyToImpl(e)}isEmpty(){return this.isEmptyImpl()}isClosed(){return this.m_XStart===this.m_XEnd&&this.m_YStart===this.m_YEnd}setEmpty(){}calculateArea2D(){return 0}queryInterval(t,e){const s=z.constructEmpty();return s.vmin=As(this,0,t,e),s.vmax=s.vmin,s.mergeNeCoordinate(As(this,1,t,e)),s}calculateLength3D(t){return b(0),0}getCoord3D(t){return b(0),{}}getCoord2D(t){const e=y.getNAN();return this.queryCoord2D(t,e),e}queryCoord3D(t,e){b(0)}getCoordZ(t){return b(0),0}queryCoord(t,e){e.assignVertexDescription(this.m_description),e.setXY(this.getCoord2D(t));for(let s=1,i=this.m_description.getAttributeCount();s<i;s++){const n=this.m_description.getSemantics(s),o=rn.getComponentCount(n);for(let a=0;a<o;a++){const h=this.getAttributeAsDbl(t,n,a);e.setAttributeBasic(n,a,h)}}}isCloserThanDistance(t,e,s){const i=F.constructEmpty();if(this.queryLooseEnvelopeOnInterval(e,i),i.distance(t)>s)return!1;const n=this.getClosestCoordinateOnInterval(t,e,s);return!Number.isNaN(n)&&y.distance(t,this.getCoord2D(n))<=s}isMonotoneQuickAndDirty(){return!1}isTrue3D(){return!1}getReversed(){const t=this.clone();return t.reverse(),t}reverse(){this.m_XEnd=O(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=O(this.m_YStart,this.m_YStart=this.m_YEnd),this.reverseImpl();for(let t=1,e=this.m_description.getAttributeCount();t<e;t++){const s=this.m_description.getSemantics(t);for(let i=0,n=rn.getComponentCount(s);i<n;i++){const o=As(this,0,s,i);Js(this,0,s,i,As(this,1,s,i)),Js(this,1,s,i,o)}}return this.afterCompletedModification(),this}isEmptyImpl(){return!1}isCircular(){return!1}distance(t,e,s,i){if(!e&&this.isIntersecting(t,0,!1)){if(s!==null||i!==null){const m=j(9,Number.NaN),l=j(9,Number.NaN),u=this.intersect(t,null,m,l,0);b(u<=9),u===0&&$(""),s!==null&&(s[0]=m[0]),i!==null&&(i[0]=l[0])}return 0}let n,o=Number.MAX_VALUE,a=-1,h=o;return n=this.getStartXY(),a=t.getClosestCoordinate(n,!1),n.subThis(t.getCoord2D(a)),h=n.length(),h<o&&(o=h,i!==null&&(i[0]=a),s!==null&&(s[0]=0)),n=this.getEndXY(),a=t.getClosestCoordinate(n,!1),n.subThis(t.getCoord2D(a)),h=n.length(),h<o&&(o=h,i!==null&&(i[0]=a),s!==null&&(s[0]=1)),n=t.getStartXY(),a=this.getClosestCoordinate(n,!1),n.subThis(this.getCoord2D(a)),h=n.length(),h<o&&(o=h,s!==null&&(s[0]=a),i!==null&&(i[0]=0)),n=t.getEndXY(),a=this.getClosestCoordinate(n,!1),n.subThis(this.getCoord2D(a)),h=n.length(),h<o&&(o=h,s!==null&&(s[0]=a),i!==null&&(i[0]=1)),o}calculateSubLengthFromStart(t){return this.tToLength(t)}calculateSubLength(t,e){return e===t?0:this.tToLength(e)-this.tToLength(t)}static recalculateParentT(t,e,s){return Ct(t,e,s)}moveTo(t){const e=this.isClosed(),s=new pt;s.setShift(t.sub(this.getStartXY())),this.applyTransformation(s),e?this.changeEndPoints2D(t,t):this.changeEndPoints2D(t,this.getEndXY())}moveTo3D(t){b(0)}getDescription(){return this.m_description}assignVertexDescription(t){Rp(this,t)}mergeVertexDescription(t){this.m_description!==t&&(this.m_description.hasAttributesFrom(t)||this.mergeVertexDescriptionImpl(t))}hasAttribute(t){return this.m_description.hasAttribute(t)}addAttribute(t){if(this.m_description.hasAttribute(t))return;const e=Gr(this.m_description,t);this.assignVertexDescription(e)}dropAttribute(t){if(!this.m_description.hasAttribute(t))return;const e=Vr(this.m_description,t);this.assignVertexDescription(e)}dropAllAttributes(){const t=_e();t!==this.m_description&&this.assignVertexDescription(t)}swap(t){if(this===t)return;t.getGeometryType()!==this.getGeometryType()&&H("wrong geometry type");const e=t;e.m_description=O(this.m_description,this.m_description=e.m_description),e.m_XStart=O(this.m_XStart,this.m_XStart=e.m_XStart),e.m_YStart=O(this.m_YStart,this.m_YStart=e.m_YStart),e.m_XEnd=O(this.m_XEnd,this.m_XEnd=e.m_XEnd),e.m_YEnd=O(this.m_YEnd,this.m_YEnd=e.m_YEnd),e.m_attributes=O(this.m_attributes,this.m_attributes=e.m_attributes),this.swapImpl(e)}equals(t,e){if(this.getGeometryType()!==t.getGeometryType())return!1;const s=e===void 0;s&&(e=0);const i=t;if(this===i)return!0;if(this.m_description!==i.m_description||Math.abs(this.m_XStart-i.m_XStart)>e||Math.abs(this.m_XEnd-i.m_XEnd)>e||Math.abs(this.m_YStart-i.m_YStart)>e||Math.abs(this.m_YEnd-i.m_YEnd)>e)return!1;for(let n=0,o=2*(this.m_description.getTotalComponentCount()-2);n<o;n++)if(!An(this.m_attributes[n],i.m_attributes[n],e))return!1;return s?this.equalsImpl(i):this.equalsImplTol(i,e)}getImpl(){return this}setAttributeBasic(t,e,s){if(this.addAttribute(t),t===0&&this.isCurve()){(e<0||e>1)&&H("");const i=new pt,n=e===0?s:0,o=e===1?s:0;i.setShiftCoords(n,o),e===0?i.xx=0:i.yy=0,this.applyTransformation(i)}else this.setStartAttribute(t,e,s),this.setEndAttribute(t,e,s)}replaceNaNs(t,e){if(this.addAttribute(t),this.isEmpty())return;const s=rn.getComponentCount(t);for(let i=0;i<s;i++){const n=this.getStartAttributeAsDbl(t,i);Number.isNaN(n)&&this.setStartAttribute(t,i,e);const o=this.getEndAttributeAsDbl(t,i);Number.isNaN(o)&&this.setEndAttribute(t,i,e)}}};Xr.s_maxMonotonicPartParams=8;let kp=class extends mi{constructor(t,e){super(),this.m_index=-1,this.gc=t,this.dim=e}next(){for(;;){if(this.m_index>=this.gc.getGeometryCount()||(this.m_index++,this.m_index===this.gc.getGeometryCount()))return null;const t=this.gc.getGeometry(this.m_index);if(this.dim===-1||1<<t.getDimension()&this.dim)return t}return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}},rg=class xh{constructor(t){this.m_geoms=[],this.m_description=_e(),t&&(t.vd?this.m_description=t.vd:t.copy?t.copy.copyTo(this):H("constructor argument not recognized"))}getGeometryCount(){return this.m_geoms.length}reserve(t){}addGeometry(t){if(t.getGeometryType()===T.enumGeometryCollection){const e=t;for(let s=0,i=e.getGeometryCount();s<i;s++)this.addGeometry(e.getGeometry(s))}else this.m_geoms.push(t.clone()),this.mergeVertexDescription(t.getDescription())}addCursor(t){for(let e=t.next();e!==null;e=t.next())this.addGeometry(e)}getGeometry(t){return(t<0||t>=this.m_geoms.length)&&H("Geometry_collection.get_geometry"),this.m_geoms[t]}modifiedElementIndex(t){this.mergeVertexDescription(this.getGeometry(t).getDescription())}modifiedElement(t){this.mergeVertexDescription(t.getDescription())}getGeometryType(){return T.enumGeometryCollection}getDimension(){let t=0;for(const e of this.m_geoms)t=Math.max(t,e.getDimension());return t}getDescription(){return this.m_description}assignVertexDescription(t){this.m_description!==t&&this.assignVertexDescriptionImpl(t)}assignVertexDescriptionImpl(t){for(const e of this.m_geoms)e.assignVertexDescription(t);this.m_description=t}mergeVertexDescription(t){this.m_description!==t&&(this.m_description.hasAttributesFrom(t)||this.mergeVertexDescriptionImpl(t))}hasAttribute(t){return this.m_description.hasAttribute(t)}addAttribute(t){if(this.m_description.hasAttribute(t))return;const e=Gr(this.m_description,t);this.assignVertexDescription(e)}dropAttribute(t){if(!this.m_description.hasAttribute(t))return;const e=Vr(this.m_description,t);this.assignVertexDescription(e)}dropAllAttributes(){const t=_e();t!==this.m_description&&this.assignVertexDescription(t)}queryInterval(t,e){let s=new z;const i=new z;i.setEmpty();for(const n of this.m_geoms)s=n.queryInterval(t,e),i.merge(s);return i}queryEnvelope(t){if(t.m_EnvelopeType===4){const e=new Ne;t.setEmpty(),t.assignVertexDescription(this.m_description);for(const s of this.m_geoms)s.queryEnvelope(e),t.merge(e)}else if(t.m_EnvelopeType===2){const e=new F;t.setEmpty();for(const s of this.m_geoms)s.queryEnvelope(e),t.mergeEnvelope2D(e)}ft("3d envelope case not implemented")}queryLooseEnvelope(t){if(t.m_EnvelopeType===2){const e=new F;t.setEmpty();for(const s of this.m_geoms)s.queryLooseEnvelope(e),t.mergeEnvelope2D(e)}ft("3d not impl")}isEmpty(){return this.m_geoms.length===0}setEmpty(){this.m_geoms.length=0}applyTransformation(t){if(t.m_TransformationType===1)for(const e of this.m_geoms)e.applyTransformation(t);ft("3d xform not impl")}transformAttribute(t,e,s,i,n){for(const o of this.m_geoms)o.transformAttribute(t,e,s,i,n)}createInstance(){return new xh({vd:this.getDescription()})}copyTo(t){t.getGeometryType()!==T.enumGeometryCollection&&H("");const e=t;if(e!==this){e.m_geoms.length=0,e.assignVertexDescription(this.m_description);for(const s of this.m_geoms)e.m_geoms.push(s.clone())}}calculateArea2D(){const t=new Ce(0);for(const e of this.m_geoms)t.pe(e.calculateArea2D());return t.getResult()}calculateLength2D(){const t=new Ce(0);for(const e of this.m_geoms)t.pe(e.calculateLength2D());return t.getResult()}calculateLength3D(t){return b(0),0}getBoundary(){const t=this.createInstance(),e=t;for(const s of this.m_geoms){const i=s.getBoundary();i&&e.m_geoms.push(i)}return t}clone(){return new xh({copy:this})}equals(t,e){if(t===this)return!0;if(t.getGeometryType()!==T.enumGeometryCollection)return!1;const s=t;if(this.m_description!==s.m_description||this.m_geoms.length!==s.m_geoms.length)return!1;for(let i=0;i<this.m_geoms.length;++i)if(!this.m_geoms[i].equals(s.m_geoms[i],e))return!1;return!0}swap(t){t.getGeometryType()!==T.enumGeometryCollection&&H("");const e=t;e!==this&&(this.m_geoms=O(e.m_geoms,e.m_geoms=this.m_geoms))}setAttributeBasic(t,e,s){for(const i of this.m_geoms)i.setAttributeBasic(t,e,s)}replaceNaNs(t,e){for(const s of this.m_geoms)s.replaceNaNs(t,e)}getImpl(){return this}mergeVertexDescriptionImpl(t){const e=this.getDescription(),s=Fn(e,t);this.assignVertexDescription(s)}};function Lp(r,t=-1){return new kp(r,t)}rg.type=T.enumGeometryCollection;let Rr=class extends Xr{constructor(t){super(t)}},Bp=class extends Rr{isTrue3D(){return!0}constructor(t){super(t)}};function Ue(r,t,e){Dm(t,r.getStartXY(),r.getEndXY(),e)}function Dm(r,t,e,s){Qt(t,e,r,s)}function $r(r,t){return Ct(r.m_XStart,r.m_XEnd,t)}function ka(r,t){return Ct(r.m_YStart,r.m_YEnd,t)}function Hp(r,t){const e=r.getStartZ(),s=r.getEndZ();return Ct(e,s,t)}function zp(r,t,e){const s=K.constructPoint2D(r.getStartXY()),i=K.constructPoint2D(r.getEndXY());e.setCoordsE(i.x.subE(s.x),i.y.subE(s.y))}function og(r,t,e){t.value()<=.5?us(2,K.constructPoint2D(r.getStartXY()),K.constructPoint2D(r.getEndXY()),t,e):cs(2,K.constructPoint2D(r.getStartXY()),K.constructPoint2D(r.getEndXY()),t,e)}function Yl(r,t,e){r.m_XStart=t.x,r.m_YStart=t.y,r.m_XEnd=e.x,r.m_YEnd=e.y,r.afterCompletedModification()}function Up(r,t){const e=r.getStartXYZ();e.z*=t;const s=r.getEndXYZ();return s.z*=t,e.norm(1)+s.norm(1)}function ag(r){if(r.m_YEnd<r.m_YStart||r.m_YEnd===r.m_YStart&&r.m_XEnd<r.m_XStart){r.m_XEnd=O(r.m_XStart,r.m_XStart=r.m_XEnd),r.m_YEnd=O(r.m_YStart,r.m_YStart=r.m_YEnd);for(let t=0,e=r.m_description.getTotalComponentCount()-2;t<e;t++)r.m_attributes[t+e]=O(r.m_attributes[t],r.m_attributes[t]=r.m_attributes[t+e])}}function yh(r,t,e,s){let i=0;if((r.m_XStart===t.m_XStart&&r.m_YStart===t.m_YStart||r.m_XStart===t.m_XEnd&&r.m_YStart===t.m_YEnd)&&(i++,!s))return 1;if(r.m_XEnd===t.m_XStart&&r.m_YEnd===t.m_YStart||r.m_XEnd===t.m_XEnd&&r.m_YEnd===t.m_YEnd){if(i++,i===2)return 2;if(!s)return 1}return t.isIntersectingPoint(r.getStartXY(),e,!0)||t.isIntersectingPoint(r.getEndXY(),e,!0)||r.isIntersectingPoint(t.getStartXY(),e,!0)||r.isIntersectingPoint(t.getEndXY(),e,!0)?4:s&&i?0:Wp(r,t)?4:0}function da(r,t,e,s,i,n,o,a){s!==null&&Do(s,2,Number.NaN),i!==null&&Do(i,2,Number.NaN),e!==null&&Wd(e,y,2);const h=Op(r,t,2,e,s,i,n,o,a);return s&&(s.length=h),i&&(i.length=h),e&&(e.length=h),h}function Op(r,t,e,s,i,n,o,a,h){const m=cn(r,t.getStartXY(),o,!1),l=cn(r,t.getEndXY(),o,!1),u=cn(t,r.getStartXY(),o,!1),c=cn(t,r.getEndXY(),o,!1);let g=0,_=0;if(!Number.isNaN(m)){let p=!1;a&&qt(m,0,1)&&r.getCoord2D(m).isEqualPoint2D(t.getStartXY())&&(g++,p=!0),p||(i&&(i[_]=m),n&&(n[_]=0),s&&s[_].setCoords(t.m_XStart,t.m_YStart),_++)}if(!Number.isNaN(l)){let p=!1;a&&qt(l,0,1)&&r.getCoord2D(l).isEqualPoint2D(t.getEndXY())&&(g++,p=!0),p||(e>_&&(i&&(i[_]=l),n&&(n[_]=1),s&&s[_].setCoords(t.m_XEnd,t.m_YEnd)),_++)}if(_!==2&&!Number.isNaN(u)&&!(m===0&&u===0||l===0&&u===1)){let p=!1;a&&qt(u,0,1)&&t.getCoord2D(u).isEqualPoint2D(r.getStartXY())&&(g++,p=!0),p||(e>_&&(i&&(i[_]=0),n&&(n[_]=u),s&&s[_].setCoords(r.m_XStart,r.m_YStart)),_++)}if(_!==2&&!Number.isNaN(c)&&!(m===1&&c===0||l===1&&c===1)){let p=!1;a&&qt(c,0,1)&&t.getCoord2D(c).isEqualPoint2D(r.getEndXY())&&(g++,p=!0),p||(e>_&&(i&&(i[_]=1),n&&(n[_]=c),s&&s[_].setCoords(t.m_XEnd,t.m_YEnd)),_++)}if(_>0)return h&&(n=O(i,i=n)),_===2&&e>=2&&i&&i[0]>i[1]&&(i[1]=O(i[0],i[0]=i[1]),n&&(n[1]=O(n[0],n[0]=n[1])),s&&(s[1]=O(s[0],s[0]=s[1]))),_;if(g>0)return 0;const d=$p(r,t,o);return Number.isNaN(d.x)?0:(s&&(s[0]=r.getCoord2D(d.x)),i&&(i[0]=d.x),n&&(n[0]=d.y),1)}function Wp(r,t){const e=jr(r,t.m_XStart,t.m_YStart),s=jr(r,t.m_XEnd,t.m_YEnd);if(e<0&&s<0||e>0&&s>0)return!1;const i=jr(t,r.m_XStart,r.m_YStart),n=jr(t,r.m_XEnd,r.m_YEnd);return i<0&&n<0||i>0&&n>0?!1:Ph(r)>Ph(t)?Rl(r,t):Rl(t,r)}function cn(r,t,e,s){const i=y.getNAN(),n=y.getNAN();let o=!1;r.m_YEnd<r.m_YStart||r.m_YEnd===r.m_YStart&&r.m_XEnd<r.m_XStart?(i.setCoords(r.m_XEnd,r.m_YEnd),n.setCoords(r.m_XStart,r.m_YStart),o=!0):(i.setCoords(r.m_XStart,r.m_YStart),n.setCoords(r.m_XEnd,r.m_YEnd));const a=o?1:0,h=o?0:1,m=y.getNAN();m.setSub(t,i);let l=m.length(),u=3*l*jt();if(l<=Math.max(e,u))return s&&l===0?Number.NaN:a;if(m.setSub(t,n),l=m.length(),u=3*l*jt(),l<=Math.max(e,u))return s&&l===0?Number.NaN:h;m.setCoords(n.x-i.x,n.y-i.y);const c=m.length();if(c>0){const g=1/c;m.scale(g);const _=y.getNAN();_.setSub(t,i);const d=_.dotProduct(m),p=8*_.dotProductAbs(m)*jt();m.leftPerpendicularThis();const f=_.dotProduct(m),x=8*_.dotProductAbs(m)*jt(),E=Math.max(e,p);if(d<-E||d>c+E)return Number.NaN;const P=Math.max(e,x);if(Math.abs(f)<=P){let C=d*g;C=Nt(C,0,1);const S=y.getNAN();if(Dm(C,i,n,S),y.distance(S,t)<=e){if(C<.5){if(y.distance(S,i)<=e&&y.distance(t,i)<=e)return a}else if(y.distance(S,n)<=e&&y.distance(t,n)<=e)return h;return o?1-C:C}}}return Number.NaN}function jr(r,t,e){const s=y.getNAN();s.setCoords(t,e),s.subThis(r.getStartXY());const i=y.getNAN();i.setSub(r.getEndXY(),r.getStartXY());const n=i.crossProduct(s),o=4*jt()*(Math.abs(i.x*s.y)+Math.abs(i.y*s.x));return n>o?-1:n<-o?1:0}function Xl(r,t,e,s){const i=s?r.m_XStart:r.m_XEnd,n=s?r.m_YStart:r.m_YEnd,o=y.getNAN();return o.x=t.getEndX()-i,o.y=t.getEndY()-n,e.dotProduct(o)>3*jt()*e.dotProductAbs(o)?(o.x=t.getStartX()-i,o.y=t.getStartY()-n,e.dotProduct(o)<=3*jt()*e.dotProductAbs(o)):!0}function Rl(r,t){const e=y.getNAN();return e.x=r.m_XEnd-r.m_XStart,e.y=r.m_YEnd-r.m_YStart,!!Xl(r,t,e,!1)&&(e.negateThis(),!!Xl(r,t,e,!0))}function Ph(r){const t=r.m_XStart-r.m_XEnd,e=r.m_YStart-r.m_YEnd;return t*t+e*e}function $p(r,t,e){const s=r.m_XEnd-r.m_XStart,i=r.m_YEnd-r.m_YStart,n=t.m_XEnd-t.m_XStart,o=t.m_YEnd-t.m_YStart,a=n*i-s*o;if(a===0)return y.getNAN();const h=4*jt()*(Math.abs(n*i)+Math.abs(s*o)),m=t.m_XStart-r.m_XStart,l=t.m_YStart-r.m_YStart,u=n*l-m*o,c=4*jt()*(Math.abs(n*l)+Math.abs(m*o)),g=u/a,_=Math.abs(a),d=(c*_+h*Math.abs(u))/(a*a)+jt()*Math.abs(g);if(g<-d||g>1+d)return y.getNAN();const p=s*l-m*i,f=p/a,x=(4*jt()*(Math.abs(s*l)+Math.abs(m*i))*_+h*Math.abs(p))/(a*a)+jt()*Math.abs(f);if(f<-x||f>1+x)return y.getNAN();let E=Nt(g,0,1),P=Nt(f,0,1);const C=y.getNAN();Ue(r,E,C);const S=y.getNAN();if(Ue(t,P,S),!e||y.distance(C,S)>e){const I=y.getNAN();Qt(C,S,.5,I),E=r.getClosestCoordinate(I,!1),P=t.getClosestCoordinate(I,!1);const w=y.getNAN();Ue(r,E,w);const D=y.getNAN();Ue(t,P,D),w.subThis(D);const N=w.length(),A=(r.absNorm()+t.absNorm())*ma();if(N>Math.max(e,A))return y.getNAN()}return new y(E,P)}let La=class{constructor(t){if(this.m_segFlagStream=null,this.m_xyStream=null,this.m_bCirculator=!1,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0,this.m_nextPathIndex=0,this.m_currentPathIndex=-1,this.m_parent=t.parent,this.m_buffer=new this.m_parent.m_segmentBufferCTor,this.m_description=t.parent.getDescription(),this.m_segmentCount=this.getSegmentCount(this.m_nextPathIndex),t.pointIndex!==void 0){(t.pointIndex<0||t.pointIndex>=t.parent.getPointCount())&&ut("");const e=t.parent.getPathIndexFromPointIndex(t.pointIndex);this.m_currentPathIndex=e,this.m_nextPathIndex=e+1,this.m_nextSegmentIndex=t.pointIndex-t.parent.getPathStart(e),this.m_segmentCount=this.getSegmentCount(this.m_currentPathIndex)}else if(t.pathIndex!==void 0){(t.pathIndex<0||t.pathIndex>=t.parent.getPathCount()||t.segmentIndex<0)&&ut("");const e=t.parent.isClosedPath(t.pathIndex)?0:1;t.segmentIndex>=t.parent.getPathSize(t.pathIndex)-e&&ut(""),this.m_nextSegmentIndex=t.segmentIndex,this.m_currentPathIndex=t.pathIndex,this.m_nextPathIndex=this.m_nextSegmentIndex+1,this.m_segmentCount=this.getSegmentCount(this.m_nextPathIndex)}this.prepare(),this.m_pathBegin=-1,this.m_bCurrentPathClosed=!1,this.m_bStripAttributes=!1,this.m_prevPathIndex=-1,this.m_prevSegmentIndex=-1,this.m_bNeedsUpdate=!1,this.m_currentPathIndex>-1&&(this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex))}stripAttributes(){this.m_bStripAttributes=!0}prepare(){this.m_bCirculator=!1,this.m_parent.isEmptyImpl()?(this.m_segFlagStream=null,this.m_xyStream=null):(this.m_segFlagStream=this.m_parent.getSegmentFlagsStreamRef(),this.m_xyStream=this.m_parent.getAttributeStreamRef(0))}nextPath(){return this.m_currentPathIndex=this.m_nextPathIndex,!(this.m_currentPathIndex>=this.m_parent.getPathCount())&&(this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0,this.m_segmentCount=this.getSegmentCount(this.m_currentPathIndex),this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex),this.m_nextPathIndex++,!0)}previousPath(){return this.m_nextPathIndex!==0&&(this.m_nextPathIndex--,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0,this.m_segmentCount=this.getSegmentCount(this.m_nextPathIndex),this.m_currentPathIndex=this.m_nextPathIndex,this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex),this.resetToLastSegment(),!0)}getSegmentCount(t){return this.m_parent.isEmptyImpl()?0:this.m_parent.getSegmentCountPath(t)}resetToFirstPath(){this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=-1,this.m_segmentCount=-1,this.m_nextPathIndex=0,this.m_currentPathIndex=-1,this.m_pathBegin=-1,this.m_bCurrentPathClosed=!1}resetToLastPath(){this.m_nextPathIndex=this.m_parent.getPathCount(),this.m_currentPathIndex=-1,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=-1,this.m_segmentCount=-1,this.m_pathBegin=-1}resetToPath(t){(t<0||t>this.m_parent.getPathCount())&&ut(""),this.m_nextPathIndex=t,this.m_currentPathIndex=-1,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=-1,this.m_segmentCount=-1,this.m_pathBegin=-1,this.m_bCurrentPathClosed=!1}isLastPath(){return this.m_currentPathIndex===this.m_parent.getPathCount()-1}isFirstSegmentInPath(){return this.m_currentSegmentIndex===0}isLastSegmentInPath(){return this.m_currentSegmentIndex===this.m_segmentCount-1}resetToFirstSegment(){this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0}resetToLastSegment(){this.m_nextSegmentIndex=this.m_segmentCount,this.m_currentSegmentIndex=-1}resetTo(t){this.m_parent!==t.m_parent&&Yt(""),this.m_currentSegmentIndex=t.m_currentSegmentIndex,this.m_nextSegmentIndex=t.m_nextSegmentIndex,this.m_currentPathIndex=t.m_currentPathIndex,this.m_nextPathIndex=t.m_nextPathIndex,this.m_segmentCount=t.m_segmentCount,this.m_bCirculator=t.m_bCirculator,this.m_pathBegin=t.m_pathBegin,this.m_bCurrentPathClosed=t.m_bCurrentPathClosed,this.m_bStripAttributes=t.m_bStripAttributes,this.m_description=t.m_description}resetToVertex(t,e){if(this.m_currentPathIndex>=0&&this.m_currentPathIndex<this.m_parent.getPathCount()){const i=this.getPathBegin();if(t>=i&&t<this.m_parent.getPathEnd(this.m_currentPathIndex))return this.m_currentSegmentIndex=-1,void(this.m_nextSegmentIndex=t-i)}let s;s=e>=0&&e<this.m_parent.getPathCount()&&t>=this.m_parent.getPathStart(e)&&t<this.m_parent.getPathEnd(e)?e:this.m_parent.getPathIndexFromPointIndex(t),this.m_nextPathIndex=s+1,this.m_currentPathIndex=s,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=t-this.m_parent.getPathStart(s),this.m_segmentCount=this.getSegmentCount(s),this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex)}hasNextSegment(){return this.m_nextSegmentIndex<this.m_segmentCount}hasPreviousSegment(){return this.m_nextSegmentIndex>0}nextSegment(){return this.m_currentSegmentIndex!==this.m_nextSegmentIndex&&this.updateSegment(),this.m_bCirculator?this.m_nextSegmentIndex=(this.m_nextSegmentIndex+1)%this.m_segmentCount:(this.m_nextSegmentIndex===this.m_segmentCount&&ut("Segment_iterator_impl::next_segment"),this.m_nextSegmentIndex++),this.m_buffer.get()}previousSegment(){return this.m_bCirculator?this.m_nextSegmentIndex=(this.m_segmentCount+this.m_nextSegmentIndex-1)%this.m_segmentCount:(this.m_nextSegmentIndex===0&&ut(""),this.m_nextSegmentIndex--),this.m_nextSegmentIndex!==this.m_currentSegmentIndex&&this.updateSegment(),this.m_buffer.get()}nextCurve(){if(!this.m_parent.hasNonLinearSegments())return this.resetToLastSegment(),null;let t=0;for(;;){if(this.m_nextSegmentIndex===this.m_segmentCount||t===this.m_segmentCount)return null;const e=this.getPathBegin()+this.m_nextSegmentIndex;if((31&this.m_segFlagStream.read(e))!==1){this.updateSegment();break}this.m_bCirculator?this.m_nextSegmentIndex=(this.m_nextSegmentIndex+1)%this.m_segmentCount:this.m_nextSegmentIndex++,t++}return this.m_currentSegmentIndex!==this.m_nextSegmentIndex&&this.updateSegment(),this.m_bCirculator?this.m_nextSegmentIndex=(this.m_nextSegmentIndex+1)%this.m_segmentCount:(this.m_nextSegmentIndex===this.m_segmentCount&&ut(""),this.m_nextSegmentIndex++),this.m_buffer.get()}getPathBegin(){return this.m_pathBegin}getPathIndex(){return this.m_currentPathIndex}getStartPointIndex(){return this.getPathBegin()+this.m_currentSegmentIndex}getEndPointIndex(){return this.isClosingSegment()?this.getPathBegin():this.getStartPointIndex()+1}updateSegment(){(this.m_nextSegmentIndex<0||this.m_nextSegmentIndex>=this.m_segmentCount||this.m_currentPathIndex<0)&&ut(""),this.m_currentSegmentIndex=this.m_nextSegmentIndex,this.m_parent.getSegmentFromPath(this.m_currentPathIndex,this.m_currentSegmentIndex,this.m_buffer,this.m_bStripAttributes)}isClosingSegment(){return this.m_bCurrentPathClosed&&this.m_currentSegmentIndex===this.m_segmentCount-1}isCurve(){return this.m_segFlagStream!==null?(31&this.m_segFlagStream.read(this.m_currentSegmentIndex))!==1:!1}isPathClosed(){return this.m_bCurrentPathClosed}setCirculator(t){this.m_bCirculator=t}getImpl(){return this}},kl=class hg{constructor(t){this.m_rasterizedGeometry=null,this.m_quadTree=null,this.m_quadTreeForPaths=null,this.m_refCount=1,t&&t.copyTo(this)}getRasterizedGeometry(){return this.m_rasterizedGeometry}copyTo(t){t!==this&&(b(t.uniqueUse()),t.m_quadTree=this.m_quadTree,t.m_quadTreeForPaths=this.m_quadTreeForPaths,t.m_rasterizedGeometry=this.m_rasterizedGeometry)}clone(){const t=new hg;return this.copyTo(t),t}uniqueUse(){return this.m_refCount===1}addRef(){++this.m_refCount}release(){--this.m_refCount===0&&(this.m_rasterizedGeometry=null,this.m_quadTree=null,this.m_quadTreeForPaths=null)}setRasterizedGeometry(t){b(this.uniqueUse())}setQuadTree(t){b(this.uniqueUse()),this.m_quadTree=t}setQuadTreeForPaths(t){b(this.uniqueUse()),this.m_quadTreeForPaths=t}getQuadTree(){return this.m_quadTree}getQuadTreeForPaths(){return this.m_quadTreeForPaths}};function Mo(r){return!(r.isEmpty()||r.getGeometryType()!==T.enumPolyline&&r.getGeometryType()!==T.enumPolygon)&&!(r.getPointCount()<20)}function mg(r){return!(r.isEmpty()||r.getGeometryType()!==T.enumPolyline&&r.getGeometryType()!==T.enumPolygon)&&!(r.getPointCount()<20)}function jp(r,t){return r.readPoint2D(t+4)}function Ba(r){const t=r.getGeometryType();return t===T.enumEllipticArc?10:t===T.enumBezier?4:t===T.enumRationalBezier2?5:t===T.enumBezier2?2:void $("")}function Ps(r){const t=31&r;return t===4?10:t===2?4:t===8?5:t===16?2:0}function Ll(r,t,e,s){const i=r.getPathStart(t),n=r.getPathEnd(t);if(n-i<3)return;const o=2*i,a=y.getNAN();e.queryPoint2D(o,a);const h=a.x,m=a.y,l=y.getNAN();e.queryPoint2D(o+2,l);const u=y.getNAN();for(let c=o+4,g=2*n;c<g;c+=2)e.queryPoint2D(c,u),s.pe((u.x-a.x)*(l.y-m)),a.setCoordsPoint2D(l),l.setCoordsPoint2D(u);s.pe((h-a.x)*(l.y-m))}function Zp(r,t,e){for(;t.hasNextSegment();){const s=t.nextCurve();if(s===null)break;e.pe(2*s.calculateArea2DHelper())}}var St=Mt;let Zs=class{static toSegType(t){let e=0;switch(t){case T.enumLine:e=1;break;case T.enumBezier:e=2;break;case T.enumEllipticArc:e=4;break;case T.enumRationalBezier2:e=8;break;case T.enumBezier2:e=16;break;default:$("")}return e}constructor(){this.m_segmentFlags=null,this.m_segmentParamIndex=null,this.m_segmentParams=null,this.m_curveCount=0,this.m_bezierCount=0,this.m_arcCount=0,this.m_rbezier2Count=0,this.m_bezier2Count=0,this.m_curveParamWritePoint=0}assignCopy(t){return this.m_segmentFlags=t.m_segmentFlags,this.m_segmentParamIndex=t.m_segmentParamIndex,this.m_segmentParams=t.m_segmentParams,this.m_curveCount=t.m_curveCount,this.m_bezierCount=t.m_bezierCount,this.m_arcCount=t.m_arcCount,this.m_rbezier2Count=t.m_rbezier2Count,this.m_bezier2Count=t.m_bezier2Count,this.m_curveParamWritePoint=t.m_curveParamWritePoint,this}},Tm=class Le extends tg{constructor(t){super(t),this.m_cachedRingAreas2D=null,this.m_paths=null,this.m_pathFlags=null,this.m_curveData=null,t.move?(this.m_bPolygon=t.move.m_bPolygon,this.m_cachedLength2D=t.move.m_cachedLength2D,this.m_cachedArea2D=t.move.m_cachedArea2D,this.m_currentPathIndex=t.move.m_currentPathIndex,this.m_cachedRingAreas2D=t.move.m_cachedRingAreas2D,this.m_paths=t.move.m_paths,this.m_pathFlags=t.move.m_pathFlags,this.m_curveData=t.move.m_curveData,t.move.m_curveData=null,t.move.setEmpty()):(this.m_bPolygon=t.bPolygon,this.m_cachedLength2D=0,this.m_cachedArea2D=0,this.m_currentPathIndex=0)}getGeometryType(){return this.m_bPolygon?T.enumPolygon:T.enumPolyline}getDimension(){return this.m_bPolygon?2:1}changeRingStartPoint(t){b(this.m_bPolygon);const e=this.getPathIndexFromPointIndex(t),s=this.getPathStart(e);if(s===t)return;const i=this.getPathEnd(e);(t>=i||t<s)&&H("change_ring_start_point");for(let n=0,o=this.m_description.getAttributeCount();n<o;n++){const a=this.m_description.getSemantics(n),h=St.getComponentCount(a);this.m_vertexAttributes.get(n).rotate(s*h,t*h,i*h)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.rotate(s,t,i),this.m_curveData.m_segmentParamIndex.rotate(s,t,i))}setFillRule(t){this.m_bFillRule=t===1}getFillRule(){return this.m_bFillRule?1:0}isExteriorRingOGC(t){return!!this.m_bPolygon&&(this.updateOGCFlagsProtected(),!!(8&this.m_pathFlags.read(t)))}isExteriorRing(t){return this.calculateRingArea2D(t)>0}calculateRingArea2D(t){return this.m_bPolygon?(this.updateRingAreas2DProtected(),this.m_cachedRingAreas2D.read(t)):0}updateRingAreas2DProtected(){if(!this.hasDirtyFlag(1024))return;const t=this.getPathCount();if(t===0)return this.hasDirtyFlag(1024)&&(this.m_cachedArea2D=0),void this.setDirtyFlagProtected(1024,!1);const e=new Ei(t),s=new Ce(0),i=new Ce(0);if(this.m_pointCount!==0){const n=this.getAttributeStreamRef(0);if(this.hasNonLinearSegments()){const o=new La({parent:this});for(o.stripAttributes();o.nextPath();){i.reset();const a=o.getPathIndex();Ll(this,a,n,i),Zp(this,o,i);const h=.5*i.getResult();s.add(h),e.write(a,h)}}else for(let o=0;o<t;o++){i.reset(),Ll(this,o,n,i);const a=.5*i.getResult();s.add(a),e.write(o,a)}}this.hasDirtyFlag(1024)&&(this.m_cachedArea2D=s.getResult(),this.m_cachedRingAreas2D=e,this.setDirtyFlagProtected(1024,!1))}getOGCPolygonCount(){if(!this.m_bPolygon)return 0;this.updateOGCFlagsProtected();let t=0;const e=this.getPathCount();for(let s=0;s<e;s++)8&this.m_pathFlags.read(s)&&t++;return t}getHashCodeImpl(){return b(0),0}equalsImpl(t){const e=t,s=this.getPathCount();if(s!==e.getPathCount())return!1;const i=this.hasNonLinearSegments();if(i!==e.hasNonLinearSegments()||i&&(this.m_curveData.m_curveCount!==e.m_curveData.m_curveCount||this.m_curveData.m_bezierCount!==e.m_curveData.m_bezierCount)||this.m_paths&&!this.m_paths.equals(e.m_paths,0,s+1)||this.m_bFillRule!==e.m_bFillRule||!this.m_bPolygon&&this.m_pathFlags&&!this.m_pathFlags.equals(e.m_pathFlags,0,s))return!1;if(this.hasNonLinearSegments()){if(!this.m_curveData.m_segmentFlags.equals(e.m_curveData.m_segmentFlags,0,this.getPointCount()))return!1;for(let n=0,o=this.getPointCount();n<o;n++){const a=this.m_curveData.m_segmentFlags.read(n);if(!Le.isNonLinearSegmentFlag(a))continue;const h=this.m_curveData.m_segmentParamIndex.read(n),m=e.m_curveData.m_segmentParamIndex.read(n),l=Ps(a);for(let u=0;u<l;u++){const c=this.m_curveData.m_segmentParams.read(h+u),g=e.m_curveData.m_segmentParams.read(m+u);if(!ze(c,g))return!1}}}return!0}equalsImplTol(t,e){const s=t,i=this.getPathCount();if(i!==s.getPathCount())return!1;const n=this.hasNonLinearSegments();if(n!==s.hasNonLinearSegments()||n&&(this.m_curveData.m_curveCount!==s.m_curveData.m_curveCount||this.m_curveData.m_bezierCount!==s.m_curveData.m_bezierCount)||this.m_paths&&!this.m_paths.equals(s.m_paths,0,i+1)||this.m_bFillRule!==s.m_bFillRule||!this.m_bPolygon&&this.m_pathFlags&&!this.m_pathFlags.equals(s.m_pathFlags,0,i))return!1;if(!n)return!0;if(!this.m_curveData.m_segmentFlags.equals(s.m_curveData.m_segmentFlags,0,this.getPointCount()))return!1;const o=this.querySegmentIterator(),a=s.querySegmentIterator();for(;o.nextPath();){if(!a.nextPath())return!1;for(;o.hasNextSegment();){const h=o.nextCurve(),m=a.nextCurve();if(!(h&&m&&h.equals(m,e))){if(!h&&!m)break;return!1}}}return!0}reserveImplImpl(t,e){this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.resize(t,1),this.m_curveData.m_segmentParamIndex.resize(t,-1),this.checkCompactSegmentParams())}verifyStreamsAfterSizeChangeExtraImpl(){this.m_paths||(this.m_paths=be(1,0),this.m_pathFlags=_i(1,0)),this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.resize(this.m_reservedPointCount,1),this.m_curveData.m_segmentParamIndex.resize(this.m_reservedPointCount,-1),this.checkCompactSegmentParams())}copyToImpl(t,e){const s=t;s.m_bPathStarted=!1,s.m_bFillRule=this.m_bFillRule,this.m_paths?s.m_paths=e?this.m_paths:this.m_paths.clone():s.m_paths=null,this.m_pathFlags?s.m_pathFlags=e?this.m_pathFlags:this.m_pathFlags.clone():s.m_pathFlags=null,this.m_curveData&&(s.m_curveData||(s.m_curveData=new Zs),s.m_curveData.assignCopy(this.m_curveData),s.m_curveData.m_curveCount=0,s.updateCurveCounter(this.m_curveData.m_curveCount),e||(this.m_curveData.m_segmentParamIndex?s.m_curveData.m_segmentParamIndex=this.m_curveData.m_segmentParamIndex.clone():s.m_curveData.m_segmentParamIndex=null,this.m_curveData.m_segmentFlags?s.m_curveData.m_segmentFlags=this.m_curveData.m_segmentFlags.clone():s.m_curveData.m_segmentFlags=null,this.m_curveData.m_segmentParams?s.m_curveData.m_segmentParams=this.m_curveData.m_segmentParams.clone():s.m_curveData.m_segmentParams=null)),s.hasDirtyFlag(512)||(s.m_cachedLength2D=this.m_cachedLength2D),s.m_cachedRingAreas2D=null,s.hasDirtyFlag(1024)||(s.m_cachedArea2D=this.m_cachedArea2D,this.m_cachedRingAreas2D!==null&&(s.m_cachedRingAreas2D=e?this.m_cachedRingAreas2D:this.m_cachedRingAreas2D.clone()))}calculateArea2D(){return this.m_bPolygon?(this.updateRingAreas2DProtected(),this.m_cachedArea2D):0}calculateLength2D(){if(!this.hasDirtyFlag(512))return this.m_cachedLength2D;const t=this.querySegmentIterator(),e=new Ce(0);for(;t.nextPath();)for(;t.hasNextSegment();)e.add(t.nextSegment().calculateLength2D());return this.hasDirtyFlag(512)&&(this.m_cachedLength2D=e.getResult()),this.setDirtyFlagProtected(512,!1),e.getResult()}calculatePathLength2D(t){const e=this.querySegmentIteratorAtVertex(this.getPathStart(t)),s=new Ce(0);for(;e.hasNextSegment();)s.add(e.nextSegment().calculateLength2D());return s.getResult()}calculateLength3D(t){return b(0),0}calculatePathLength3D(t,e){return b(0),0}copyTo(t){lt(t.getGeometryType())||H(""),this!==t&&super.copyTo(t)}swap(t){b(0)}setPointByVal(t,e){this.setPointByValWithCurves(t,e)}setPointByValWithCurves(t,e){if(this.hasNonLinearSegments()){const s=e.getXY();if(this.setXYCoordsWithCurves(t,s.x,s.y),this.m_description.getAttributeCount()===1)return}this.setPointByValNoCurves(t,e)}setXYCoordsWithCurves(t,e,s){if(this.hasNonLinearSegments()){const i=Le.getPathIndexFromPointIndexImpl(this.m_paths,this.getPathCount(),t,this.m_currentPathIndex);this.m_currentPathIndex=i;const n=this.getPrevSegmentTypeFromPath(i,t),o=this.getNextSegmentType(t);if(n!==1||o!==1){let a=t-1;const h=new it;n!==1&&(this.isClosedPath(i)&&t===this.getPathStart(i)&&(a=this.getPathEnd(i)-1),this.getSegmentBuffer(a,h,!0));const m=new it;o!==1&&this.getSegmentBuffer(t,m,!0);const l=t+1;this.setXYCoordsNoCurves(t,e,s);const u=new y(e,s);return n!==1&&(h.get().changeEndPoints2D(h.get().getStartXY(),u),this.replaceSegmentImpl(a,t,h.get(),!0)),void(o!==1&&(m.get().changeEndPoints2D(u,m.get().getEndXY()),this.replaceSegmentImpl(t,l,m.get(),!0)))}}this.setXYCoordsNoCurves(t,e,s)}setXYZWithCurves(t,e){this.hasNonLinearSegments()?(this.setXYCoordsWithCurves(t,e.x,e.y),this.setAttributeNoCurves(1,t,0,e.z)):this.setXYZNoCurves(t,e)}setAttributeWithCurves(t,e,s,i){if(t===0&&this.hasNonLinearSegments()){const n=this.getXY(e);s===0?n.x=i:n.y=i,this.setXYCoordsWithCurves(e,n.x,n.y)}else this.setAttributeNoCurves(t,e,s,i)}setXY(t,e){this.setXYCoordsWithCurves(t,e.x,e.y)}setXYCoords(t,e,s){this.setXYCoordsWithCurves(t,e,s)}setXYZ(t,e){this.setXYZWithCurves(t,e)}setAttribute(t,e,s,i){this.setAttributeWithCurves(t,e,s,i)}setAttributeWithCurvesFromArray(t,e,s,i){if(t===0&&this.hasNonLinearSegments()){i<2&&ut("");const n=this.getXY(e);n.x=s[0],n.y=s[1],this.setXYCoordsWithCurves(e,n.x,n.y)}else this.setAttributeFromArrayNoCurves(t,e,s,i)}setAttributeFromArray(t,e,s,i){this.setAttributeWithCurvesFromArray(t,e,s,i)}hasNonLinearSegments(){return this.getCurveCount()!==0}getSegmentCount(){let t=this.getPointCount();if(!this.m_bPolygon){t-=this.getPathCount();for(let e=0,s=this.getPathCount();e<s;e++)this.isClosedPath(e)&&t++}return t}getSegmentCountPath(t){let e=this.getPathSize(t);return!this.isClosedPath(t)&&e>0&&e--,e}add(t,e){this===t&&H("Multi_path_impl::add");for(let s=0,i=t.getPathCount();s<i;s++)this.addPath(t,s,!e)}addPath(t,e,s){this.insertPath(-1,t,e,s)}addPathPoint2D(t,e,s){this.insertPath2D(-1,t,0,e,s)}addPathMultiPoint(t,e,s,i){s<0&&(s=t.getPointCount()-e),this.insertPointsFromMultipoint(-1,0,t,e,s,i)}addSegmentsFromPath(t,e,s,i,n){if(this===t&&H("Multi_path_impl.add_segments_from_path"),n||this.getPathCount()!==0||(n=!0),e<0&&(e=t.getPathCount()-1),(e>=t.getPathCount()||s<0||i<0||s+i>t.getSegmentCountPath(e))&&ut("add_segments_from_path"),i===0)return;const o=t.getPathStart(e),a=t.isClosedPath(e)&&s+i===t.getSegmentCountPath(e);this.m_bPathStarted=!1,this.mergeVertexDescription(t.getDescription());let h=i;const m=o+s;let l=m+1;n&&(h++,l--),!n&&t.hasNonLinearSegments()&&t.m_curveData.m_segmentFlags.read(m)!==1&&(t.getXY(m).equals(this.getXY(this.m_pointCount-1))||H("add_segments_from_path: start point mismatch"));const u=this.m_pointCount;if(this.resizeImpl(this.m_pointCount+h),this.verifyAllStreamsAfterSizeChange(),n){if(h===0)return;this.m_paths.add(this.m_pointCount);let g=t.m_pathFlags.read(e);this.m_bPolygon&&(g|=1),this.m_pathFlags.write(this.m_pathFlags.size()-1,g),this.m_pathFlags.add(0)}else this.m_paths.write(this.m_pathFlags.size()-1,this.m_pointCount);const c=a?h-1:h;for(let g=0,_=this.m_description.getAttributeCount();g<_;g++){const d=this.m_description.getSemantics(g),p=St.getComponentCount(d),f=t.m_description.getAttributeIndex(d);if(c>0){if(f<0||!t.m_vertexAttributes.get(f)){const x=St.getDefaultValue(d);this.m_vertexAttributes.get(g).insertRange(p*u,x,c*p,p*u),a&&this.m_vertexAttributes.get(g).insertRange(p*u+c*p,x,p,p*u);continue}this.m_vertexAttributes.get(g).insertRangeFromStream(p*u,t.m_vertexAttributes.get(f),p*l,c*p,!0,p,p*u)}a&&this.m_vertexAttributes.get(g).insertRangeFromStream(p*(u+c),t.m_vertexAttributes.get(f),p*o,p,!0,p,p*(u+c))}if(this.hasNonLinearSegments()&&this.initSegmentData(0),t.hasNonLinearSegments()){let g=0;for(let _=0,d=m;_<i;_++)g+=Ps(t.m_curveData.m_segmentFlags.read(d)),d++;if(g>0){this.initSegmentData(g);let _=m,d=u-(n?0:1),p=0;for(let f=0;f<i;f++){const x=t.m_curveData.m_segmentFlags.read(_);if(this.m_curveData.m_segmentFlags.write(d,x),Le.isNonLinearSegmentFlag(x)){p++;let E=t.m_curveData.m_segmentParamIndex.read(_);const P=Ps(x);this.m_curveData.m_segmentParamIndex.write(d,this.m_curveData.m_curveParamWritePoint);for(let C=0;C<P;C++){const S=t.m_curveData.m_segmentParams.read(E);this.m_curveData.m_segmentParams.write(this.m_curveData.m_curveParamWritePoint,S),this.m_curveData.m_curveParamWritePoint++,E++}this.incCurveType(x,1)}else this.m_curveData.m_segmentParamIndex.write(d,-1);d++,_++}this.modifyCurveCounter(p)}}if(a){const g=this.getPathCount()-1,_=this.getPathStart(g),d=this.getPathEnd(g)-1,p=this.getXY(_),f=this.getXY(d);p.isEqualPoint2D(f)&&(--this.m_pointCount,this.m_paths.write(g+1,this.m_pointCount))}this.notifyModifiedFlags(2001)}reverseAllPaths(){for(let t=0,e=this.getPathCount();t<e;t++)this.reversePath(t)}reversePath(t){t>=this.getPathCount()&&H("");const e=this.getPathSize(t);if(e===0)return;const s=this.getPathStart(t),i=this.isClosedPath(t);if(this.hasNonLinearSegments()){let a=s;const h=new this.m_segmentBufferCTor;let m=!1;for(let l=0;l<e;l++,a++){const u=this.m_curveData.m_segmentFlags.read(a);if(!Le.isNonLinearSegmentFlag(u))continue;m=!0,this.querySegment(a,h,!0),h.get().reverse();const c=this.m_curveData.m_segmentParamIndex.read(a);h.get().writeInBufferStream(this.m_curveData.m_segmentParams,c)}if(m){const l=i?0:1;this.m_curveData.m_segmentFlags.reverseRange(s,e-l,1),this.m_curveData.m_segmentParamIndex.reverseRange(s,e-l,1)}}const n=i?1:0;for(let a=0,h=this.m_description.getAttributeCount();a<h;a++)if(this.m_vertexAttributes.get(a)){const m=this.m_description.getSemantics(a),l=St.getComponentCount(m);this.m_vertexAttributes.get(a).reverseRange(l*(s+n),l*(e-n),l)}const o=6&this.m_pathFlags.read(t);if(o){let a=0;4&o&&(a|=2),2&o&&(a|=4),this.m_pathFlags.clearBits(t,6),this.m_pathFlags.setBits(t,a)}this.notifyModifiedFlags(1233)}removePath(t){const e=this.getPathCount();t<0&&(t=e-1),t>=e&&H("");const s=this.getPathStart(t),i=this.getPathSize(t);for(let n=0,o=this.m_description.getAttributeCount();n<o;n++)if(this.m_vertexAttributes.get(n)){const a=this.m_description.getSemantics(n),h=St.getComponentCount(a);this.m_vertexAttributes.get(n).eraseRange(h*s,h*i,h*this.m_pointCount)}if(this.hasNonLinearSegments()){let n=0;for(let o=s,a=s+i;o<a;o++){const h=this.m_curveData.m_segmentFlags.read(o);Le.isNonLinearSegmentFlag(h)&&(this.incCurveType(h,-1),n++)}this.modifyCurveCounter(-n),this.m_curveData.m_segmentFlags.eraseRange(s,i,this.m_pointCount),this.m_curveData.m_segmentParamIndex.eraseRange(s,i,this.m_pointCount)}for(let n=t+1;n<=e;n++){const o=this.m_paths.read(n);this.m_paths.write(n-1,o-i)}if(this.m_pathFlags)for(let n=t+1;n<=e;n++){const o=this.m_pathFlags.read(n);this.m_pathFlags.write(n-1,o)}this.m_paths.resize(e),this.m_pathFlags.resize(e),this.m_pointCount-=i,this.m_reservedPointCount-=i,t===e-1&&(this.m_bPathStarted=!1),this.notifyModifiedFlags(2001),this.checkCompactSegmentParams(),this.dbgVerifyCurves()}dbgVerifyCurves(){}insertPath(t,e,s,i){this===e&&H("Multi_path_impl::insert_path");const n=this.getPathCount();if(!i&&e.hasNonLinearSegmentsPath(s))return t=this.insertPath(t,e,s,!0),this.reversePath(t),t;s>=e.getPathCount()&&H(""),t>n&&H(""),t<0&&(t=n),s<0&&(s=e.getPathCount()-1),this.m_bPathStarted=!1,this.mergeVertexDescription(e.getDescription());const o=e.getPathStart(s),a=e.getPathSize(s);if(a===0)return this.insertPath2D(t,null,0,0,!0);const h=this.m_pointCount,m=e.isClosedPath(s)&&!i?1:0;this.resizeImpl(this.m_pointCount+a),this.verifyAllStreamsAfterSizeChange();const l=t<n?this.getPathStart(t):h;for(let g=0,_=this.m_description.getAttributeCount();g<_;g++){const d=this.m_description.getSemantics(g),p=e.getDescription().getAttributeIndex(d),f=St.getComponentCount(d);if(p>=0&&e.m_vertexAttributes.get(p))m!==0&&this.m_vertexAttributes.get(g).insertRangeFromStream(l*f,e.m_vertexAttributes.get(p),f*o,f,!0,f,f*h),this.m_vertexAttributes.get(g).insertRangeFromStream((l+m)*f,e.m_vertexAttributes.get(p),f*(o+m),f*(a-m),i,f,f*(h+m));else{const x=St.getDefaultValue(d);this.m_vertexAttributes.get(g).insertRange(l*f,x,f*a,f*h)}}const u=h+a;this.m_paths.add(u);for(let g=n;g>=t+1;g--){const _=this.m_paths.read(g-1);this.m_paths.write(g,_+a)}this.m_pathFlags.add(0);for(let g=n-1;g>=t+1;g--){let _=this.m_pathFlags.read(g);_&=-9,this.m_pathFlags.write(g+1,_)}let c=e.getPathFlagsStreamRef().read(s);if(c&=-9,this.m_bPolygon&&(c|=1),this.m_pathFlags.write(t,c),e.hasNonLinearSegments()){this.initSegmentData(0);let g=o,_=0;for(let d=0;d<a;d++)_+=Ps(e.m_curveData.m_segmentFlags.read(g)),g++;if(_>0){this.m_curveData.m_segmentFlags===null?(this.m_curveData.m_segmentFlags=_i(this.m_pointCount,1),this.m_curveData.m_segmentParamIndex=be(this.m_pointCount,-1)):(this.m_curveData.m_segmentFlags.insertRange(l,1,a,h),this.m_curveData.m_segmentParamIndex.insertRange(l,-1,a,h)),this.m_curveData.m_segmentParams?this.m_curveData.m_segmentParams.resize(this.m_curveData.m_curveParamWritePoint+_):this.m_curveData.m_segmentParams=Gi(_),g=o;let d=l,p=0;for(let f=0;f<a;f++){const x=e.m_curveData.m_segmentFlags.read(g);if(Le.isNonLinearSegmentFlag(x)){this.m_curveData.m_segmentFlags.write(d,x),this.m_curveData.m_segmentParamIndex.write(d,this.m_curveData.m_curveParamWritePoint);const E=Ps(x);let P=e.m_curveData.m_segmentParamIndex.read(g);for(let C=0;C<E;C++){const S=e.m_curveData.m_segmentParams.read(P);this.m_curveData.m_segmentParams.write(this.m_curveData.m_curveParamWritePoint,S),this.m_curveData.m_curveParamWritePoint++,P++}p++,this.incCurveType(x,1)}g++,d++}this.modifyCurveCounter(p)}}return this.notifyModifiedFlags(2001),t}insertPath2D(t,e,s,i,n){const o=this.getPathCount();(t>o||s<0)&&H(""),t<0&&(t=o),this.m_bPathStarted=!1;const a=this.m_pointCount;this.resizeImpl(this.m_pointCount+i),i===0&&this.notifyModifiedFlags(32),this.verifyAllStreamsAfterSizeChange();const h=t<o?this.getPathStart(t):a;if(e)this.m_vertexAttributes.get(0).insertRangeFromPoints(2*h,e,s,i,n,2*a);else{const m=St.getDefaultValue(0);this.m_vertexAttributes.get(0).insertRange(2*h,m,2*i,2*a)}for(let m=1,l=this.m_description.getAttributeCount();m<l;m++){const u=this.m_description.getSemantics(m),c=St.getComponentCount(u),g=St.getDefaultValue(u);this.m_vertexAttributes.get(m).insertRange(h*c,g,c*i,c*a)}this.m_paths.add(this.m_pointCount);for(let m=o;m>=t+1;m--){const l=this.m_paths.read(m-1);this.m_paths.write(m,l+i)}this.m_pathFlags.add(0);for(let m=o-1;m>=t+1;m--){let l=this.m_pathFlags.read(m);l&=-9,this.m_pathFlags.write(m+1,l)}return this.m_bPolygon&&this.m_pathFlags.write(t,1),this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(h,1,i,a),this.m_curveData.m_segmentParamIndex.insertRange(h,-1,i,a)),this.notifyModifiedFlags(2001),t}insertPathFromMultipoint(t,e,s,i,n){const o=e.getImpl(),a=this.getPathCount();(t>a||s<0)&&H("");const h=i<0?o.getPointCount()-s:i;if(h>o.getPointCount()&&H(""),s>=o.getPointCount()&&H("pointsOffset"),t<0&&(t=a),this.m_bPathStarted=!1,this.mergeVertexDescription(o.getDescription()),h===0)return void this.insertPath2D(t,null,0,0,!0);const m=this.m_pointCount,l=s;this.resizeImpl(this.m_pointCount+h),this.verifyAllStreamsAfterSizeChange();const u=t<a?this.getPathStart(t):m;for(let _=0,d=this.m_description.getAttributeCount();_<d;_++){const p=this.m_description.getSemantics(_),f=o.getDescription().getAttributeIndex(p),x=St.getComponentCount(p);if(f>=0){const E=o.getAttributeStreamRef(p);this.m_vertexAttributes.get(_).insertRangeFromStream(u*x,E,x*l,x*h,n,x,x*m)}else{const E=St.getDefaultValue(p);this.m_vertexAttributes.get(_).insertRange(u*x,E,x*h,x*m)}}const c=m+h;this.m_paths.add(c);for(let _=a;_>=t+1;_--){const d=this.m_paths.read(_-1);this.m_paths.write(_,d+h)}this.m_pathFlags.add(0);for(let _=a-1;_>=t+1;_--){let d=this.m_pathFlags.read(_);d&=-9,this.m_pathFlags.write(_+1,d)}let g=0;this.m_bPolygon&&(g|=1),this.m_pathFlags.write(t,g),this.notifyModifiedFlags(2001)}insertPoints(t,e,s,i,n,o,a){if(this===s&&H("Multi_path_impl.insert_points"),t<0&&(t=this.getPathCount()),i<0&&(i=s.getPathCount()-1),(t>this.getPathCount()||e>=0&&e>this.getPathSize(t)||i>=s.getPathCount()||o>s.getPathSize(i))&&ut(""),!o)return;if(this.mergeVertexDescription(s.m_description),t===this.getPathCount()){this.m_paths.add(this.m_pointCount);let g=s.m_pathFlags.read(i);g&=-9,this.m_bPolygon?this.m_pathFlags.add(1|g):this.m_pathFlags.add(g)}e<0&&(e=this.getPathSize(t));const h=this.m_pointCount;this.resizeImpl(this.m_pointCount+o),this.verifyAllStreamsAfterSizeChange();const m=this.getPathStart(t),l=m+e;o<0&&(o=s.getPathSize(i));const u=s.getPathStart(i),c=u+o;for(let g=0,_=this.m_description.getAttributeCount();g<_;g++){const d=this.m_description.getSemantics(g),p=St.getComponentCount(d),f=s.m_description.getAttributeIndex(d);if(f<0||!s.m_vertexAttributes.get(f)){const x=St.getDefaultValue(d);this.m_vertexAttributes.get(g).insertRange(p*l,x,c*p,p*h)}else this.m_vertexAttributes.get(g)?.insertRangeFromStream(p*(m+e),s.m_vertexAttributes.get(f),p*(u+n),o*p,a,p,p*h)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(m+e,1,o,h),this.m_curveData.m_segmentParamIndex.insertRange(m+e,-1,o,h),e>0&&this.isNonLinearSegment(m+e-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(m+e-1),-1),this.m_curveData.m_segmentFlags.write(m+e-1,1),this.m_curveData.m_segmentParamIndex.write(m+e-1,-1),this.modifyCurveCounter(-1)));for(let g=t+1,_=this.getPathCount();g<=_;g++){const d=this.m_paths.read(g);this.m_paths.write(g,d+o)}this.notifyModifiedFlags(2001)}insertPointsFromPoints(t,e,s,i,n,o){if(t<0&&(t=this.getPathCount()),(t>this.getPathCount()||e>this.getPathSize(t)||i<0)&&ut(""),!n)return;t===this.getPathCount()&&(this.m_paths.add(this.m_pointCount),this.m_bPolygon?this.m_pathFlags.add(1):this.m_pathFlags.add(0)),e<0&&(e=this.getPathSize(t));const a=this.m_pointCount;this.resizeImpl(this.m_pointCount+n),this.verifyAllStreamsAfterSizeChange();const h=this.getPathStart(t);this.m_vertexAttributes.get(0).insertRangeFromPoints(2*(h+e),s,i,n,o,2*a);for(let m=1,l=this.m_description.getAttributeCount();m<l;m++){const u=this.m_description.getSemantics(m),c=St.getComponentCount(u),g=St.getDefaultValue(u);this.m_vertexAttributes.get(m).insertRange((h+e)*c,g,c*n,c*a)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(h+e,1,n,a),this.m_curveData.m_segmentParamIndex.insertRange(h+e,-1,n,a),e>0&&this.isNonLinearSegment(h+e-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(h+e-1),-1),this.m_curveData.m_segmentFlags.write(h+e-1,1),this.m_curveData.m_segmentParamIndex.write(h+e-1,-1),this.modifyCurveCounter(-1)));for(let m=t+1,l=this.getPathCount();m<=l;m++)this.m_paths.write(m,this.m_paths.read(m)+n);this.notifyModifiedFlags(2001)}insertPointsFromMultipoint(t,e,s,i,n,o){const a=s.getImpl(),h=this.getPathCount();t<0&&(t=this.getPathCount());const m=a.getPointCount();if((i<0||i>m)&&ut(""),(n<0||i+n>m)&&(n=m-i),e<0&&(e=t<h?this.getPathSize(t):0),(t>h||t<h&&e>this.getPathSize(t)||t===h&&e>0||n<0)&&ut(""),!n)return;if(this.mergeVertexDescription(a.getDescription()),t===h){this.m_paths.add(this.m_pointCount);const d=0;this.m_bPolygon?this.m_pathFlags.add(1|d):this.m_pathFlags.add(d)}e<0&&(e=this.getPathSize(t));const l=this.m_pointCount;this.resizeImpl(this.m_pointCount+n),this.verifyAllStreamsAfterSizeChange();const u=this.getPathStart(t),c=u+e,g=0,_=g+n;for(let d=0,p=this.m_description.getAttributeCount();d<p;d++){const f=this.m_description.getSemantics(d),x=St.getComponentCount(f);if(a.getDescription().getAttributeIndex(f)<0){const P=St.getDefaultValue(f);this.m_vertexAttributes.get(d).insertRange(x*c,P,_*x,x*l);continue}const E=a.getAttributeStreamRef(f);this.m_vertexAttributes.get(d).insertRangeFromStream(x*(u+e),E,x*(g+i),n*x,o,x,x*l)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(u+e,1,n,l),this.m_curveData.m_segmentParamIndex.insertRange(u+e,-1,n,l),e>0&&this.isNonLinearSegment(u+e-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(u+e-1),-1),this.m_curveData.m_segmentFlags.write(u+e-1,1),this.m_curveData.m_segmentParamIndex.write(u+e-1,-1),this.modifyCurveCounter(-1)));for(let d=t+1,p=this.getPathCount();d<=p;d++){const f=this.m_paths.read(d);this.m_paths.write(d,f+n)}this.notifyModifiedFlags(2001)}insertPoint2D(t,e,s){const i=this.getPathCount();t<0&&(t=i),(t>i||t<i&&e>this.getPathSize(t))&&ut(""),t===i&&this.addPathPoint2D(null,0,!0);const n=this.m_pointCount;this.resizeImpl(this.m_pointCount+1),this.verifyAllStreamsAfterSizeChange();const o=this.getPathStart(t),a=e<0?this.getPathSize(t)+o:e+o,h=this.m_vertexAttributes.get(0);if(a===n)this.m_paths.write(t+1,n+1),h.writePoint2D(2*a,s);else{h.insert(2*a,s,2*n);for(let m=1,l=this.m_description.getAttributeCount();m<l;m++){const u=this.m_description.getSemantics(m),c=St.getComponentCount(u),g=St.getDefaultValue(u);this.m_vertexAttributes.get(m).insertRange(c*a,g,c,c*n)}this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.insertRange(a,1,1,n),this.m_curveData.m_segmentParamIndex.insertRange(a,-1,1,n));for(let m=t+1,l=i;m<=l;m++)this.m_paths.write(m,this.m_paths.read(m)+1)}this.m_curveData&&this.m_curveData.m_segmentFlags&&a>o&&this.isNonLinearSegment(a-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(a-1),-1),this.modifyCurveCounter(-1),this.m_curveData.m_segmentFlags.write(a-1,1),this.m_curveData.m_segmentParamIndex.write(a-1,-1)),this.notifyModifiedFlags(2001)}insertPoint(t,e,s){const i=this.getPathCount();t<0&&(t=i),(t>i||t<i&&e>this.getPathSize(t))&&ut(""),t===i&&this.addPathPoint2D(null,0,!0);const n=this.m_pointCount;this.resizeImpl(this.m_pointCount+1),this.verifyAllStreamsAfterSizeChange();const o=this.getPathStart(t),a=e<0?this.getPathSize(t)+o:e+o;if(a===n)this.m_paths.write(t+1,n+1),this.setPointByValNoCurves(a,s);else{const h=s.getDescription();this.m_description!==h&&this.mergeVertexDescription(h);for(let m=0,l=this.m_description.getAttributeCount();m<l;m++){const u=this.m_description.getSemantics(m),c=St.getComponentCount(u);if(h.hasAttribute(u))this.m_vertexAttributes.get(m).insertAttributes(c*a,s,u,c*n);else{const g=St.getDefaultValue(u);this.m_vertexAttributes.get(m).insertRange(c*a,g,c,c*n)}}this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.insertRange(a,1,1,n),this.m_curveData.m_segmentParamIndex.insertRange(a,-1,1,n));for(let m=t+1,l=i;m<=l;m++)this.m_paths.write(m,this.m_paths.read(m)+1)}this.m_curveData&&this.m_curveData.m_segmentFlags&&a>o&&this.isNonLinearSegment(a-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(a-1),-1),this.modifyCurveCounter(-1),this.m_curveData.m_segmentFlags.write(a-1,1),this.m_curveData.m_segmentParamIndex.write(a-1,-1)),this.notifyModifiedFlags(2001)}removePointFromPath(t,e){const s=this.getPathCount();t<0&&(t=s-1),(t>=s||e>=this.getPathSize(t))&&ut("Multi_path.remove_point");const i=this.getPathStart(t),n=this.isClosedPath(t);e<0&&(e=this.getPathSize(t)-1),e<0&&ut("Multi_path.remove_point");const o=i+e;for(let a=0,h=this.m_description.getAttributeCount();a<h;a++)if(this.m_vertexAttributes.get(a)){const m=this.m_description.getSemantics(a),l=St.getComponentCount(m);this.m_vertexAttributes.get(a).eraseRange(l*o,l,l*this.m_pointCount)}if(this.m_curveData&&this.m_curveData.m_segmentFlags){this.checkCompactSegmentParams();let a=0;if(o>i&&this.isNonLinearSegment(o-1))a+=1,this.incCurveType(this.m_curveData.m_segmentFlags.read(o-1),-1),this.m_curveData.m_segmentFlags.write(o-1,1),this.m_curveData.m_segmentParamIndex.write(o-1,-1);else{const h=this.getPathEnd(t);n&&i+1<h&&this.isNonLinearSegment(h-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(h-1),-1),this.m_curveData.m_segmentFlags.write(h-1,1),this.m_curveData.m_segmentParamIndex.write(h-1,-1),a+=1)}this.isNonLinearSegment(o)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(o),-1),a+=1),a>0&&this.modifyCurveCounter(-a),this.m_curveData.m_segmentFlags.eraseRange(o,1,this.m_pointCount),this.m_curveData.m_segmentParamIndex.eraseRange(o,1,this.m_pointCount)}for(let a=s;a>=t+1;a--){const h=this.m_paths.read(a);this.m_paths.write(a,h-1)}this.m_pointCount--,this.m_reservedPointCount--,this.notifyModifiedFlags(2001)}removePoint(t){let e;e=t<0?this.getPathCount()-1:this.getPathIndexFromPointIndex(t),this.removePointFromPath(e,t-this.getPathStart(e))}getNextSegmentType(t){return this.hasNonLinearSegments()?this.m_curveData.m_segmentFlags.read(t):1}getPrevSegmentTypeFromPath(t,e){if(!this.hasNonLinearSegments())return 1;const s=this.getPathStart(t);if(e>s)return this.m_curveData.m_segmentFlags.read(e-1);if(e===s){if(this.isClosedPath(t)){const i=this.getPathEnd(t);return this.m_curveData.m_segmentFlags.read(i-1)}return 1}$("")}getNumberOfCurves(t){if(!this.hasNonLinearSegments())return 0;let e=0;for(let s=this.getPathStart(t),i=this.getPathEnd(t);s<i;s++)Le.isNonLinearSegmentFlag(this.m_curveData.m_segmentFlags.read(s))&&++e;return e}getPathCount(){return this.m_paths?this.m_paths.size()-1:0}getPathSize(t){return this.m_paths.read(t+1)-this.m_paths.read(t)}getPathStart(t){return this.m_paths.read(t)}getPathEnd(t){return this.m_paths.read(t+1)}getPathIndexFromPointIndex(t,e=-1){e===-1&&(e=this.m_currentPathIndex);const s=this.getPathCount(),i=Le.getPathIndexFromPointIndexImpl(this.m_paths,s,t,e);return this.m_currentPathIndex=i,i}startPathCoords(t,e){this.startPathPoint(new st({x:t,y:e}))}startPath(t){this.startPathPoint(new st({pt:t}))}startPath3D(t){this.startPathPoint(new st({x:t.x,y:t.y,z:t.z}))}startPath3DCoords(t,e,s){this.startPathPoint(new st({x:t,y:e,z:s}))}startPathPoint(t){t.isEmpty()&&H("");const e=t.getDescription();let s;if(this.m_description!==e){this.mergeVertexDescription(e);const i=new st({vd:this.m_description});t.copyCommonAttributesTo(i),s=i}else s=t;this.m_bPathStarted?this.setPointByValNoCurves(this.m_pointCount-1,s):(this.insertPoint(-1,-1,s),this.m_bPathStarted=!0)}beforeNewSegmentHelper2(){this.m_paths=be(2),this.m_paths.write(0,0),this.m_pathFlags=_i(2,0),this.m_bPolygon&&this.m_pathFlags.write(0,1)}beforeNewSegmentHelper1(){this.m_paths!==null?(this.m_paths.add(0),this.m_pathFlags.add(0),this.m_bPolygon&&this.m_pathFlags.write(this.m_pathFlags.size()-2,1)):this.beforeNewSegmentHelper2()}beforeNewSegment(t){this.m_pointCount!==0||this.m_bPathStarted||this.startPathCoords(0,0);const e=this.m_pointCount,s=this.m_paths.size()-1,i=e+t;this.m_paths.write(s,i),this.resizeImpl(i),this.m_bPathStarted&&(this.m_bPathStarted=!1)}finishLineTo(){if(this.hasNonLinearSegments()){const t=this.m_curveData.m_segmentFlags.read(this.m_pointCount-1);t!==1&&(this.m_curveData.m_segmentFlags.write(this.m_pointCount-1,1),this.m_curveData.m_segmentParamIndex.write(this.m_pointCount-1,-1),this.modifyCurveCounter(-1),this.incCurveType(t,-1))}}lineToCoords(t,e){if(this.beforeNewSegment(1),this.m_description.getAttributeCount()===1)this.setXYCoordsNoCurves(this.m_pointCount-1,t,e);else{const s=Hs(),i=new st({vd:this.m_description,attribBuffer:s,initDefaultValues:!0});i.setXYCoords(t,e),this.setPointByValNoCurves(this.m_pointCount-1,i)}this.finishLineTo()}lineTo(t){this.lineToCoords(t.x,t.y)}lineTo3D(t){this.beforeNewSegment(1);const e=Fn(this.m_description,nr()),s=Hs(),i=new st({vd:e,attribBuffer:s,initDefaultValues:!0});i.setXYZ(t),this.setPointByValNoCurves(this.m_pointCount-1,i),this.finishLineTo()}lineTo3DCoords(t,e,s){this.lineTo3D(new mt(t,e,s))}lineToPoint(t){if(this.beforeNewSegment(1),this.m_description===t.getDescription())this.setPointByValNoCurves(this.m_pointCount-1,t);else{this.mergeVertexDescription(t.getDescription());const e=Hs(),s=new st({vd:this.m_description,attribBuffer:e,initDefaultValues:!1});t.copyCommonAttributesTo(s),this.setPointByValNoCurves(this.m_pointCount-1,s)}this.finishLineTo()}openPathAndDuplicateStartVertex(t){this.m_bPolygon&&$("");const e=this.getPathCount();if(t>e&&H(""),!this.isClosedPath(t))return;this.m_pathFlags||$("");const s=this.m_pointCount,i=this.getPathStart(t),n=this.getPathEnd(t);if(n-i!==0){this.resizeImpl(this.m_pointCount+1),this.verifyAllStreamsAfterSizeChange();for(let o=0,a=this.m_description.getAttributeCount();o<a;o++)if(this.m_vertexAttributes.get(o)){const h=this.m_description.getSemantics(o),m=St.getComponentCount(h);this.m_vertexAttributes.get(o).insertRangeFromStream(m*n,this.m_vertexAttributes.get(o),m*i,m,!0,1,m*s)}for(let o=e;o>t;o--){const a=this.m_paths.read(o);this.m_paths.write(o,a+1)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(n,1,1,s),this.m_curveData.m_segmentParamIndex.insertRange(n,-1,1,s)),this.m_pathFlags.clearBits(t,1)}}openPath(t){this.m_bPolygon&&$(""),t>this.getPathCount()&&H(""),this.m_pathFlags||$(""),this.m_pathFlags.clearBits(t,1)}isStrongPathStart(t){return!!(2&this.m_pathFlags.read(t))}setStrongPathStart(t,e){e?this.m_pathFlags.setBits(t,2):this.m_pathFlags.clearBits(t,2)}isStrongPathEnd(t){return!!(4&this.m_pathFlags.read(t))}setStrongPathEnd(t,e){e?this.m_pathFlags.setBits(t,4):this.m_pathFlags.clearBits(t,4)}clearStrongPathEnds(){for(let t=0,e=this.getPathCount();t<e;++t)this.m_pathFlags.clearBits(t,6)}openAllPathsAndDuplicateStartVertex(){if(this.m_bPolygon&&$(""),this.isEmpty())return;this.m_pathFlags||$("");let t=0;const e=this.getPathCount();for(let l=0;l<e;l++)this.isClosedPath(l)&&(this.getPathSize(l)>0?t++:this.m_pathFlags.clearBits(l,1));if(t===0)return;const s=this.hasNonLinearSegments();let i=0;const n=this.getPathCount(),o=this.m_description.getAttributeCount(),a=new Array(o);let h=null,m=null;for(let l=0;l<n;++l){const u=this.getPathStart(l),c=this.getPathSize(l),g=this.isClosedPath(l);if(c>0){const _=u+i;for(let d=0;d<o;d++)if(this.m_vertexAttributes.get(d)){const p=this.m_description.getSemantics(d),f=St.getComponentCount(p);if(!a[d]){const x=f*(this.m_pointCount+t),E=_o(p,x);a[d]=E}a[d].writeRange(_*f,c*f,this.m_vertexAttributes.get(d),u*f,!0,1),g&&a[d].writeRange((_+c)*f,f,this.m_vertexAttributes.get(d),u*f,!0,1)}if(s){if(h===null){const d=this.m_pointCount+t;h=_i(d),m=be(d)}h.writeRange(_,c,this.m_curveData.m_segmentFlags,u,!0,1),m.writeRange(_,c,this.m_curveData.m_segmentParamIndex,u,!0,1),g&&(h.write(_+c,1),m.write(_+c,-1))}}this.m_paths.write(l,u+i),g&&(this.m_pathFlags.clearBits(l,1),++i)}this.m_paths.write(n,this.m_pointCount+t),this.m_pathFlags.clearBits(n,1);for(let l=0;l<o;l++)this.m_vertexAttributes.get(l)&&this.m_vertexAttributes.set(l,a[l]);s&&(this.m_curveData.m_segmentFlags=h,this.m_curveData.m_segmentParamIndex=m),this.m_pointCount+=t,this.m_reservedPointCount>0&&(this.m_reservedPointCount=this.m_pointCount)}closePathWithLine(t){t===void 0&&(t=this.getPathCount()-1),this.throwIfEmpty(),(t<0||t>=this.getPathCount())&&H("close_path_with_line"),t===this.getPathCount()-1&&(this.m_bPathStarted=!1);const e=this.m_pathFlags.read(t);if(1&e||this.m_pathFlags.write(t,1|e),this.m_curveData&&this.m_curveData.m_segmentFlags){const s=this.getPathEnd(t)-1,i=this.m_curveData.m_segmentFlags.read(s);i!==1&&(this.m_curveData.m_segmentFlags.write(s,1),this.m_curveData.m_segmentParamIndex.write(s,-1),this.incCurveType(i,-1),this.modifyCurveCounter(-1))}this.notifyModifiedFlags(2001)}closeLastPathWithSegment(t){this.closePathWithSegment(this.getPathCount()-1,t)}closePathWithSegment(t,e){if(this.throwIfEmpty(),(t<0||t>=this.getPathCount())&&H("close_path_with_line"),e.getEndXY().equals(this.getXY(this.getPathStart(t)))||H("close_path_with_segment: end point mismatch"),t===this.getPathCount()-1)this.m_bPathStarted=!1,this.addSegment(e,!1),--this.m_pointCount,this.m_paths.write(t+1,this.m_pointCount);else{this.mergeVertexDescription(e.getDescription());const i=e.getStartXY(),n=this.getPathEnd(t)-1;i.equals(this.getXY(n))||H("close_path_with_segment: start point mismatch");const o=e.getGeometryType();if(o===T.enumLine)return void this.closePathWithLine(t);{const a=Ba(e);this.initSegmentData(a);const h=Zs.toSegType(o),m=this.m_curveData.m_segmentFlags.read(n);if(m!==h)this.m_curveData.m_segmentParamIndex.write(n,this.m_curveData.m_curveParamWritePoint),e.writeInBufferStream(this.m_curveData.m_segmentParams,this.m_curveData.m_curveParamWritePoint),this.m_curveData.m_curveParamWritePoint+=a,this.incCurveType(h,1),m!==1?this.incCurveType(m,-1):this.modifyCurveCounter(1);else{const l=this.m_curveData.m_segmentParamIndex.read(n);e.writeInBufferStream(this.m_curveData.m_segmentParams,l)}this.m_curveData.m_segmentFlags.write(n,h)}}const s=this.m_pathFlags.read(t);1&s||this.m_pathFlags.write(t,1|s),this.notifyModifiedFlags(2001)}closeAllPaths(){if(this.m_bPolygon||this.isEmptyImpl())return;this.m_bPathStarted=!1;let t=!1;for(let e=0,s=this.m_paths.size()-1;e<s;e++){if(this.isClosedPath(e))continue;const i=this.m_pathFlags.read(e);this.m_pathFlags.write(e,1|i),t=!0}t&&this.notifyModifiedFlags(512)}isClosedPath(t){return!!(1&this.m_pathFlags.read(t))}isClosedPathInXYPlane(t){if(this.isClosedPath(t))return!0;const e=this.getPathStart(t),s=this.getPathEnd(t)-1;if(e>s)return!1;const i=this.getXY(e),n=this.getXY(s);return i.isEqualPoint2D(n)}isClosedPathIn3D(t){return b(0),!1}hasNonLinearSegmentsPath(t){if(!this.hasNonLinearSegments())return!1;for(let e=this.getPathStart(t),s=this.getPathEnd(t);e<s;e++)if(Le.isNonLinearSegmentFlag(this.m_curveData.m_segmentFlags.read(e)))return!0;return!1}isNonLinearSegment(t){return!(1&this.getSegmentFlags(t))}addEnvelope(t,e){if(t.isEmpty())return;const s=this.m_pointCount===0;if(t instanceof F)this.startPathCoords(t.xmin,t.ymin),e?(this.lineToCoords(t.xmax,t.ymin),this.lineToCoords(t.xmax,t.ymax),this.lineToCoords(t.xmin,t.ymax)):(this.lineToCoords(t.xmin,t.ymax),this.lineToCoords(t.xmax,t.ymax),this.lineToCoords(t.xmax,t.ymin));else{const i=t.getDescription(),n=Hs(),o=new st({vd:i,attribBuffer:n,initDefaultValues:!1});for(let a=0,h=4;a<h;a++){const m=e?h-a-1:a;t.queryCornerByVal(m,o),a===0?this.startPathPoint(o):this.lineToPoint(o)}}this.closePathWithLine(),this.m_bPathStarted=!1,s&&!e&&(this.setDirtyFlagProtected(256,!1),this.m_bPolygon&&Math.min(t.width(),t.height())>0&&this.setIsSimple(3,0))}addPathFromClosedSegment(t,e){if(t.isClosed()||H("add_path_from_closedSegment: segment must be closed"),e){const s=t.getReversed(),i=new st;s.queryStart(i),this.startPathPoint(i),this.closeLastPathWithSegment(s)}else{const s=new st;t.queryStart(s),this.startPathPoint(s),this.closeLastPathWithSegment(t)}}addSegment_(t,e){const s=t.getDescription();this.mergeVertexDescription(s);const i=Hs(),n=new st({vd:s,attribBuffer:i,initDefaultValues:!1}),o=t.getGeometryType();if(o===T.enumLine)(e||this.isEmptyImpl())&&(t.queryStart(n),this.startPathPoint(n)),t.queryEnd(n),this.lineToPoint(n);else{let a=!1;if((e||this.isEmptyImpl())&&(a=!0),!a&&(t.getStartXY().equals(this.getXY(this.m_pointCount-1))||H("add_segment: start point mismatch")),a&&(t.queryStart(n),this.startPathPoint(n)),this.beforeNewSegment(1),t.queryEnd(n),n.getDescription()===this.m_description)this.setPointByVal(this.m_pointCount-1,n);else{const l=Hs(),u=new st({vd:this.m_description,attribBuffer:l,initDefaultValues:!1});n.copyCommonAttributesTo(u),this.setPointByVal(this.m_pointCount-1,u)}const h=Ba(t);this.initSegmentData(h),this.m_curveData.m_segmentParamIndex.write(this.m_pointCount-2,this.m_curveData.m_curveParamWritePoint),t.writeInBufferStream(this.m_curveData.m_segmentParams,this.m_curveData.m_curveParamWritePoint),this.m_curveData.m_curveParamWritePoint+=h;const m=Zs.toSegType(o);this.incCurveType(m,1),this.modifyCurveCounter(1),this.m_curveData.m_segmentFlags.write(this.m_pointCount-2,m)}}addSegment(t,e,s){s?e?this.addPathFromClosedSegment(t,!1):this.closeLastPathWithSegment(t):this.addSegment_(t,e)}interpolateAttributesRange(t,e,s,i){for(let a=t;a<s-1;a++)this.isClosedPath(a)&&H("cannot interpolate across closed paths");const n=this.m_description.getAttributeCount();if(n===1)return;const o=this.calculateSubLength2D(t,e,s,i);if(o!==0)for(let a=1;a<n;a++){const h=this.m_description.getSemantics(a);this.interpolateAttributesSemanticsImpl(h,t,e,s,i,o)}}interpolateAttributesSemantics(t,e,s,i,n){if(t===0)return;this.hasAttribute(t)||H("does not have the given attribute"),St.getInterpolation(t)===2&&H("angular interpolation");for(let a=e;a<i-1;a++)this.isClosedPath(a)&&H("cannot interpolate across closed paths");const o=this.calculateSubLength2D(e,s,i,n);o!==0&&this.interpolateAttributesSemanticsImpl(t,e,s,i,n,o)}interpolateAttributesPath(t,e,s){const i=this.m_description.getAttributeCount();if(i===1||e===s)return;const n=this.calculatePathSubLength2D(t,e,s);for(let o=1;o<i;o++){const a=this.m_description.getSemantics(o);this.interpolateAttributesSemanticsPathImpl(a,t,e,s,n)}}interpolateAttributesSemanticsPath(t,e,s,i){if(t===0)return;this.hasAttribute(t)||H("does not have the given attribute"),St.getInterpolation(t)===2&&H("angular interpolation");const n=this.calculatePathSubLength2D(e,s,i);n!==0&&this.interpolateAttributesSemanticsPathImpl(t,e,s,i,n)}interpolateAttributesSemanticsImpl(t,e,s,i,n,o){const a=this.querySegmentIterator(),h=this.getPathStart(e)+s,m=this.getPathStart(i)+n,l=St.getComponentCount(t),u=j(St.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(t,h,u,l);const c=j(St.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(t,m,c,l);const g=j(St.maxComponentCount(),Number.NaN);ne(g,u,0,0,l);let _=0;const d=St.getDefaultValue(t),p=St.getInterpolation(t);a.resetToVertex(h,e);do if(a.hasNextSegment()){if(a.nextSegment(),a.getStartPointIndex()===m)return;this.setAttributeFromArray(t,a.getStartPointIndex(),g,l),a.previousSegment();do{const f=a.nextSegment();if(a.getEndPointIndex()===m)return;_+=f.calculateLength2D(),wo(p,u,c,g,0,l,_/o,d),a.isClosingSegment()||this.setAttributeFromArray(t,a.getEndPointIndex(),g,l)}while(a.hasNextSegment())}while(a.nextPath())}interpolateAttributesSemanticsPathImpl(t,e,s,i,n){b(t!==0);const o=this.querySegmentIterator(),a=St.getInterpolation(t),h=this.getPathStart(e)+s,m=this.getPathStart(e)+i;if(m===h)return;const l=St.getComponentCount(t),u=j(St.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(t,h,u,l);const c=j(St.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(t,m,c,l);const g=new Ce(0);o.resetToVertex(h,e),o.setCirculator(this.isClosedPath(e));const _=St.getDefaultValue(t),d=j(St.maxComponentCount(),Number.NaN);ne(d,u,0,0,l);const p=n===0;let f=.5;do{const x=o.nextSegment();if(this.setAttributeFromArrayNoCurves(t,o.getStartPointIndex(),d,l),!p){const E=x.calculateLength2D();g.pe(E),f=g.getResult()/n}wo(a,u,c,d,0,l,f,_)}while(o.getEndPointIndex()!==m)}querySegment(t,e,s){const i=this.getPathIndexFromPointIndex(t),n=t-this.getPathStart(i);n>=this.getSegmentCountPath(i)&&H("get_segment"),this.getSegmentFromPath(i,n,e,s)}getSegment(t,e){const s=new this.m_segmentBufferCTor;return this.getSegmentBuffer(t,s,e),s.releaseSegment()}getSegmentType(t){const e=this.getPathIndexFromPointIndex(t),s=t-this.getPathStart(e);return s>=this.getSegmentCountPath(e)&&H("get_segment"),this.getSegmentTypeFromPath(e,s)}getSegmentFromPath(t,e,s,i){const n=this.getPathStart(t)+e,o=this.getSegmentFlagsStreamRef();let a=1;switch(o&&(a=31&o.read(n)),a){case 1:s.createLine();break;case 2:s.createCubicBezier();break;case 4:s.createEllipticArc();break;case 8:s.createQuadraticRationalBezier();break;case 16:s.createQuadraticBezier();break;default:$("")}const h=s.get();let m,l=null;if(i?(l=_e(),h.assignVertexDescription(l)):h.assignVertexDescription(this.m_description),m=n===this.getPathEnd(t)-1&&this.isClosedPath(t)?this.getPathStart(t):n+1,bm(h,this.getXY(n)),Im(h,this.getXY(m)),!i)for(let u=1,c=this.m_description.getAttributeCount();u<c;u++){const g=this.m_description.getSemantics(u),_=St.getComponentCount(g);for(let d=0;d<_;d++){const p=this.getAttributeAsDbl(g,n,d);h.setStartAttribute(g,d,p);const f=this.getAttributeAsDbl(g,m,d);h.setEndAttribute(g,d,f)}}if(Le.isNonLinearSegmentFlag(a)){const u=this.m_curveData.m_segmentParamIndex.read(n);h.readFromBufferStream(this.m_curveData.m_segmentParams,u)}}replaceLinearEllipticalArcsWithTrueLines(){if(!this.hasNonLinearSegments()||this.m_curveData.m_arcCount===0)return!1;let t=!1;for(let e=0,s=this.getPointCount();e<s;e++)if(this.m_curveData.m_segmentFlags.read(e)===4){const i=this.m_curveData.m_segmentParamIndex.read(e);jp(this.m_curveData.m_segmentParams,i).isNAN()&&(this.m_curveData.m_segmentFlags.write(e,1),this.m_curveData.m_segmentParamIndex.write(e,-1),this.incCurveType(4,-1),this.modifyCurveCounter(-1),t=!0)}return t&&this.checkCompactSegmentParams(),t}queryPointAlongPath(t,e,s,i=!1){const n={iSegment:-1},o=i?n:{tSegment:0};if(s.setEmpty(),this.isEmpty()||((t<0||t>=this.getPathCount())&&H("query_point_along_path"),e<0))return n;const a=this.getPathSize(t);if(a===0)return n;if(a===1)return this.getPointByVal(this.getPathStart(t),s),o.tSegment=0,n.iSegment=this.getPathStart(t),n;const h=this.querySegmentIteratorAtVertex(this.getPathStart(t)),m=new Ce(0);for(;h.hasNextSegment();){const l=h.nextSegment(),u=l.calculateLength2D(),c=m.getResult();if(m.add(u),m.getResult()>=e){let g=e-c;g>u&&(g=u);const _=l.lengthToT(g);return l.queryCoord(_,s),o.tSegment=_,n.iSegment=h.getStartPointIndex(),n}}if(this.isClosedPath(t)){const l=this.getPathStart(t);return this.getPointByVal(l,s),o.tSegment=1,n.iSegment=this.getPathEnd(t)-1,n}{const l=this.getPathEnd(t)-1;return this.getPointByVal(l,s),this.getPathSize(t)>1?(o.tSegment=1,n.iSegment=this.getPathEnd(t)-2,n):(o.tSegment=0,n.iSegment=this.getPathStart(t),n)}}queryPointsAlongPath(t,e,s,i,n,o){{let _=0;for(let d=0;d<e;++d)i&&i[d].setEmpty(),n&&(n[d]=-1),o&&(o[d]=0),_>s[d]&&H("query_points_along"),_=s[d]}const a=this.getPathSize(t);if(e===0||a===0)return 0;if(a===1){const _=this.getPathStart(t);return i&&this.getPointByVal(_,i[0]),o&&(o[0]=0),n&&(n[0]=_),1}const h=this.getPathStart(t),m=new Ce(0),l=this.querySegmentIteratorAtVertex(h);let u=0,c=0,g=s[u];for(;l.hasNextSegment();){const _=l.nextSegment(),d=_.calculateLength2D(),p=m.getResult();for(m.add(d);m.getResult()>=g;){let f=g-p;f>d&&(f=d);const x=_.lengthToT(f);if(i&&_.queryCoord(x,i[c]),o&&(o[c]=x),n&&(n[c]=l.getStartPointIndex()),c++,u++,g=s[u],u===e)return c}}if(this.isClosedPath(t)){const _=this.getPathStart(t),d=0;i&&this.getPointByVal(_,i[c]),o&&(o[c]=d),n&&(n[c]=_),c++}else if(this.getPathSize(t)>1){const _=this.getPathEnd(t)-2,d=1;i&&this.getPointByVal(_+1,i[c]),o&&(o[c]=d),n&&(n[c]=_),c++}return c}queryPointsAlong(t,e,s,i,n){{let c=0;for(let g=0;g<t;++g)s&&s[g].setEmpty(),i&&(i[g]=-1),n&&(n[g]=0),c>e[g]&&H("query_points_along"),c=e[g]}if(t===0)return 0;const o=new Ce(0),a=this.querySegmentIterator();let h=-1,m=0,l=0,u=e[m];for(;a.nextPath();)for(;a.hasNextSegment();){h=a.getPathIndex();const c=a.nextSegment(),g=c.calculateLength2D(),_=o.getResult();for(o.add(g);o.getResult()>=u;){let d=u-_;d>g&&(d=g);const p=c.lengthToT(d);if(s&&c.queryCoord(p,s[l]),n&&(n[l]=p),i&&(i[l]=a.getStartPointIndex()),l++,m++,u=e[m],m===t)return l}}if(h<0)return 0;if(this.isClosedPath(h)){const c=this.getPathStart(h),g=0;s&&this.getPointByVal(c,s[l]),n&&(n[l]=g),i&&(i[l]=c),l++}else if(this.getPathSize(h)>1){const c=this.getPathEnd(h)-2,g=1;s&&this.getPointByVal(c+1,s[l]),n&&(n[l]=g),i&&(i[l]=c),l++}return l}querySegmentIterator(){return new La({parent:this})}querySegmentIteratorAtVertex(t){return new La({parent:this,pointIndex:t})}queryPathEnvelope(t,e){this.queryPathEnvelopeImpl(t,e,!0)}queryLoosePathEnvelope(t,e){this.queryPathEnvelopeImpl(t,e,!1)}queryPathEnvelopeImpl(t,e,s){if(e instanceof Ne&&b(0,"not implemented for Envelope"),e instanceof ps&&b(0,"not implemented for Envelope3D"),(t>=this.getPathCount()||t<0)&&H(""),this.isEmpty())return void e.setEmpty();const i=this.getAttributeStreamRef(0),n=F.constructEmpty();n.setEmpty();for(let o=2*this.getPathStart(t),a=2*this.getPathEnd(t);o<a;){const h=a-o;b(!(1&h)),n.mergePointsInterleaved(i,o/2,h/2),o+=h}if(e.setCoords({env2D:n}),this.hasNonLinearSegmentsPath(t)){const o=this.querySegmentIterator();if(o.resetToPath(t),o.nextPath())for(;o.hasNextSegment();){const a=o.nextCurve();if(!a)break;{const h=F.constructEmpty();s?a.queryEnvelope(h):a.queryLooseEnvelope(h),e.mergeEnvelope2D(h)}}else b(0)}}checkCompactSegmentParams(){if(!this.m_curveData||this.m_curveData.m_segmentParams===null||this.m_curveData.m_segmentParams.size()<=this.m_vertexAttributes.get(0).size())return!1;const t=10,e=Ps(4)*this.m_curveData.m_arcCount+Ps(2)*this.m_curveData.m_bezierCount+Ps(8)*this.m_curveData.m_rbezier2Count+Ps(16)*this.m_curveData.m_bezier2Count;return this.m_curveData.m_segmentParams.size()>Math.max(3*e>>1,t)?(this.forceCompactSegmentParams(),!0):(this.m_pointCount===0&&(this.m_curveData.m_curveParamWritePoint=0),!1)}forceCompactSegmentParams(){let t=0;for(let i=0,n=this.getPointCount();i<n;i++){const o=this.m_curveData.m_segmentFlags.read(i);Le.isNonLinearSegmentFlag(o)&&(t+=Ps(o))}const e=Gi(t);let s=0;for(let i=0,n=this.getPointCount();i<n;i++){const o=this.m_curveData.m_segmentFlags.read(i);if(Le.isNonLinearSegmentFlag(o)){let a=this.m_curveData.m_segmentParamIndex.read(i);this.m_curveData.m_segmentParamIndex.write(i,s);const h=Ps(o);for(let m=0;m<h;m++)e.write(s,this.m_curveData.m_segmentParams.read(a)),s++,a++}}this.m_curveData.m_segmentParams=e,this.m_curveData.m_curveParamWritePoint=s}setEmpty(){this.m_curveData&&(this.removeAllCurvesFromGlobalCounter(),this.m_curveData=null),this.m_bPathStarted=!1,this.m_paths=null,this.m_pathFlags=null,this.setEmptyImpl()}applyTransformation(t){this.applyTransformationToPath(t,-1)}applyTransformation3D(t){b(0)}getImpl(){return this}reserve(t){this.reserveImpl(t),t>0&&!this.m_paths&&(this.m_paths=be(0),this.m_pathFlags=_i(0),this.m_paths.reserve(2),this.m_pathFlags.reserve(2),this.m_paths.resize(1,0),this.m_pathFlags.resize(1,this.m_bPolygon?1:0))}reserveParts(t,e){this.reserveImpl(t),e>0&&(this.m_paths?(this.m_paths.reserve(e+1),this.m_pathFlags.reserve(e+1)):(this.m_paths=be(0),this.m_pathFlags=_i(0),this.m_paths.reserve(e+1),this.m_pathFlags.reserve(e+1),this.m_paths.resize(1,0),this.m_pathFlags.resize(1,this.m_bPolygon?1:0)))}clone(){const t=this.createInstance();return this.copyTo(t),t}queryLimitedSegmentIterator(t){return new Qp(this,t)}getPathStreamRef(){return this.throwIfEmpty(),this.m_paths}setPathStreamRef(t){this.m_paths=t}getSegmentFlagsStreamRef(){return this.throwIfEmpty(),this.m_curveData!=null?this.m_curveData.m_segmentFlags:null}getPathFlagsStreamRef(){return this.throwIfEmpty(),this.m_pathFlags}setPathFlagsStreamRef(t){this.m_pathFlags=t}getSegmentIndexStreamRef(){return this.throwIfEmpty(),this.m_curveData!==null?this.m_curveData.m_segmentParamIndex:null}getSegmentDataStreamRef(){return this.throwIfEmpty(),this.m_curveData!==null?this.m_curveData.m_segmentParams:null}setSegmentData(t,e,s,i){this.m_curveData||(this.m_curveData=new Zs),this.m_curveData.m_segmentFlags=s,this.m_curveData.m_segmentParams=e,this.m_curveData.m_segmentParamIndex=t,this.m_curveData.m_curveParamWritePoint=i}static getPathIndexFromPointIndexImpl(t,e,s,i){if(i>=0&&i<e){if(s>=t.read(i)){if(s<t.read(i+1))return i;i++}else i--;if(i>=0&&i<e&&s>=t.read(i)&&s<t.read(i+1))return i}if(e<5){for(let a=0;a<e;a++)if(s<t.read(a+1))return a;Bc("")}let n=0,o=e-1;for(;o>n;){const a=n+(o-n>>1);if(s<t.read(a))o=a-1;else{if(!(s>=t.read(a+1)))return a;n=a+1}}return n}getHighestPointIndex(t){b(t>=0&&t<this.getPathCount());const e=this.getAttributeStreamRef(0),s=this.getPathEnd(t),i=this.getPathStart(t);let n=-1;const o=new y;o.y=Number.NEGATIVE_INFINITY,o.x=Number.NEGATIVE_INFINITY;for(let a=i+0;a<s;a++){const h=e.readPoint2D(2*a);o.compare(h)===-1&&(n=a,o.setCoordsPoint2D(h))}return n}applyTransformationToPath(t,e){if(e>=this.getPathCount()&&H("apply_transformation"),this.isEmpty()||t.isIdentity())return;const s=this.m_vertexAttributes.get(0);if(!(e<0?this.hasNonLinearSegments():this.hasNonLinearSegmentsPath(e))){let a,h;return e<0?(a=0,h=this.m_pointCount):(a=this.getPathStart(e),h=this.getPathEnd(e)),s.applyTransformation(t,2*a,h-a),void this.notifyModifiedFlags(2001)}const i=new this.m_segmentBufferCTor,n=this.getPathCount();let o=e<0?0:e;do{const a=this.getPathStart(o),h=this.getPathEnd(o),m=this.isClosedPath(o),l=s.readPoint2D(2*a);if(!this.hasNonLinearSegmentsPath(o)){s.applyTransformation(t,2*a,h-a);continue}const u=y.getNAN();for(let c=a;c<h;++c){if((31&this.m_curveData.m_segmentFlags.read(c))!==1){const _=m&&c+1===h;_&&s.writePoint2D(2*a,l),this.getSegmentBuffer(c,i,!0),i.get().applyTransformation(t);const d=this.m_curveData.m_segmentParamIndex.read(c);i.get().writeInBufferStream(this.m_curveData.m_segmentParams,d),s.writePoint2D(2*c,i.get().getStartXY()),_&&s.writePoint2D(2*a,i.get().getEndXY());continue}const g=2*c;s.queryPoint2D(g,u),t.transformInPlace(u),s.writePoint2D(g,u)}if(o===e)break}while(++o<n);this.notifyModifiedFlags(2001)}calculateSubLength2D(t,e,s,i){const n=this.getPathStart(t)+e,o=this.getPathStart(s)+i;(o<n||n<0||o>this.getPointCount()-1)&&Yt("");const a=this.querySegmentIterator();let h=0;a.resetToVertex(n,t);do{for(;a.hasNextSegment();){const m=a.nextSegment();if(a.getStartPointIndex()===o)break;h+=m.calculateLength2D()}if(a.getStartPointIndex()===o)break}while(a.nextPath());return h}calculatePathSubLength2D(t,e,s){const i=this.getPathStart(t)+e,n=this.getPathStart(t)+s;(i<0||n>this.getPointCount()-1)&&Yt("");const o=this.querySegmentIterator();if(i>n&&(this.isClosedPath(t)||H("cannot iterate across an open path"),o.setCirculator(!0)),i===n)return 0;let a=0,h=0;o.resetToVertex(i,t);do h+=a,a=o.nextSegment().calculateLength2D();while(o.getStartPointIndex()!==n);return h}calculateEnvelope2D(t){return this.updateXYImpl(t)}updateXYImpl(t){const e=super.updateXYImpl(t);if(this.hasNonLinearSegments()){const s=F.constructEmpty(),i=this.querySegmentIterator();for(;i.nextPath();)for(;i.hasNextSegment();){const n=i.nextCurve();if(!n)break;t?n.queryEnvelope(s):n.queryLooseEnvelope(s),e.mergeEnvelope2D(s)}}return e}notifyModifiedAllImpl(){this.m_paths!==null&&this.m_paths.size()?this.m_pointCount=this.m_paths.read(this.m_paths.size()-1):this.m_pointCount=0}setDirtyOGCFlags(t){this.setDirtyFlagProtected(16,t)}hasDirtyOGCStartFlags(){return this.hasDirtyFlag(16)}setDirtyRingAreas2D(t){this.setDirtyFlagProtected(1024,t)}hasDirtyRingAreas2D(){return this.hasDirtyFlag(1024)}static isNonLinearSegmentFlag(t){return!(1&t)}addAndExplicitlyOpenAllPaths(t,e){this===t&&H("Multi_path_impl::add");let s=this.getPathCount();for(let i=0,n=t.getPathCount();i<n;i++)this.addPath(t,i,!e),this.openPathAndDuplicateStartVertex(s),s++}getSegmentFlags(t){return this.m_curveData!==null&&this.m_curveData.m_segmentFlags!==null?this.m_curveData.m_segmentFlags.read(t):1}getSegmentBuffer(t,e,s){const i=this.getPathIndexFromPointIndex(t),n=t-this.getPathStart(i);n>=this.getSegmentCountPath(i)&&H("getSegmentBuffer"),this.getSegmentFromPath(i,n,e,s)}getSegmentTypeFromPath(t,e){const s=this.getPathStart(t)+e,i=this.getSegmentFlagsStreamRef();let n=1;switch(i&&(n=31&i.read(s)),n){case 1:return T.enumLine;case 2:return T.enumBezier;case 4:return T.enumEllipticArc;case 8:return T.enumRationalBezier2;case 16:return T.enumBezier2;default:$("")}}ensureXYMonotoneSegments(){if(!this.m_curveData)return!1;let t=!1;for(let e=0,s=this.getPathCount();e<s;e++){const i=this.getPathStart(e),n=this.getPathEnd(e),o=n-i;for(let a=i;a<n;a++){const h=31&this.m_curveData.m_segmentFlags.read(a);if(h===1)continue;h!==2&&ft("ensure_xy_monotone_segments");const m=(a-i+1)%o+i,l=this.m_curveData.m_segmentParamIndex.read(a),u=R(y,4);u[0]=this.getXY(a),u[3]=this.getXY(m),u[1].x=this.m_curveData.m_segmentParams.read(l),u[1].y=this.m_curveData.m_segmentParams.read(l+1),u[2].x=this.m_curveData.m_segmentParams.read(l+2),u[2].y=this.m_curveData.m_segmentParams.read(l+3),eg(u)&&(t=!0,this.m_curveData.m_segmentParams.write(l,u[1].x),this.m_curveData.m_segmentParams.write(l+1,u[1].y),this.m_curveData.m_segmentParams.write(l+2,u[2].x),this.m_curveData.m_segmentParams.write(l+3,u[2].y))}}return t&&this.notifyModifiedFlags(2001),t}buildRasterizedGeometryAccelerator(t,e){return!1}buildQuadTreeAccelerator(t){if(this.m_accelerators||(this.m_accelerators=new kl),this.m_accelerators.getQuadTree()!==null)return!0;this.ensureUniqueAccelerators(),this.m_accelerators.setQuadTree(null);const e=Pn(this);return this.m_accelerators.setQuadTree(e),!0}buildQuadTreeForPathsAccelerator(t){if(this.m_accelerators||(this.m_accelerators=new kl),this.m_accelerators.getQuadTreeForPaths()!==null)return!0;this.ensureUniqueAccelerators(),this.m_accelerators.setQuadTreeForPaths(null);const e=wp(this);return this.m_accelerators.setQuadTreeForPaths(e),!0}updateCurveCounter(t){this.modifyCurveCounter(t-this.getCurveCount())}removeAllCurvesFromGlobalCounter(){this.m_curveData&&(Le.st_totalCurveCount-=this.m_curveData.m_curveCount,this.m_curveData.m_curveCount=0,this.m_curveData.m_bezierCount=0,this.m_curveData.m_arcCount=0,this.m_curveData.m_bezier2Count=0,this.m_curveData.m_rbezier2Count=0,this.m_curveData.m_curveParamWritePoint=0)}modifyCurveCounter(t){t&&(this.m_curveData||(this.m_curveData=new Zs),Le.st_totalCurveCount+=t,this.m_curveData.m_curveCount+=t)}getCurveCount(){return this.m_curveData?this.m_curveData.m_curveCount:0}incCurveType(t,e){this.m_curveData||(this.m_curveData=new Zs),2&t?this.m_curveData.m_bezierCount+=e:4&t?this.m_curveData.m_arcCount+=e:8&t?this.m_curveData.m_rbezier2Count+=e:16&t&&(this.m_curveData.m_bezier2Count+=e)}getCurveWritePoint(){return this.m_curveData!==null?this.m_curveData.m_curveParamWritePoint:0}initSegmentData(t){this.m_curveData===null&&(this.m_curveData=new Zs);const e=this.m_reservedPointCount>0?this.m_reservedPointCount:this.m_pointCount;this.m_curveData.m_segmentParamIndex===null&&(this.m_curveData.m_segmentFlags=_i(e,1),this.m_curveData.m_segmentParamIndex=be(e,-1));const s=this.m_curveData.m_curveParamWritePoint+t;this.m_curveData.m_segmentParams===null?this.m_curveData.m_segmentParams=Gi(s):s!==this.m_curveData.m_segmentParams.size()&&this.m_curveData.m_segmentParams.resize(s,0),this.m_curveData.m_segmentFlags.size()<e&&(this.m_curveData.m_segmentFlags.resize(e,1),this.m_curveData.m_segmentParamIndex.resize(e,-1))}updateCurveWritePoint(t){this.m_curveData===null&&(this.m_curveData=new Zs),this.m_curveData.m_curveParamWritePoint=t}updateOGCFlagsHelper(){const t=this.getPathCount();if(t===0)return;const e=this.m_pathFlags;let s=0;for(let i=0;i<t;i++){const n=this.m_cachedRingAreas2D.read(i);s===0&&(s=kt(n)),n*s>0||s===0?e.setBits(i,8):e.clearBits(i,8)}}updateOGCFlagsProtected(){this.hasDirtyFlag(16)&&(this.updateRingAreas2DProtected(),this.updateOGCFlagsHelper(),this.setDirtyFlagProtected(16,!1))}replaceSegment(t,e,s){(t<0||t>=this.getPointCount())&&H("Multi_path_impl.replace_segment"),b(e.isCurve());const i=this.getPathIndexFromPointIndex(t),n=this.getPathStart(i),o=(t-n+1)%this.getPathSize(i)+n;{const a=this.getXY(t),h=this.getXY(o),m=!a.isEqualPoint2D(e.getStartXY())||!h.isEqualPoint2D(e.getEndXY());b(!m)}this.replaceSegmentImpl(t,o,e,s)}replaceSegmentImpl(t,e,s,i){const n=s.getDescription();this.mergeVertexDescription(n);const o=j(32,Number.NaN),a=new st({vd:n,attribBuffer:o,initDefaultValues:!1}),h=this.m_curveData===null?1:31&this.m_curveData.m_segmentFlags.read(t),m=Ps(h),l=Ba(s);let u,c=!1;m>=l?(b(this.m_curveData!==null),c=!0,u=this.m_curveData.m_segmentParamIndex.read(t)):(this.initSegmentData(l),c=!1,u=this.m_curveData.m_curveParamWritePoint);const g=s.getGeometryType(),_=Zs.toSegType(g);i||(s.queryStart(a),this.setPointByValNoCurves(t,a),s.queryEnd(a),this.setPointByValNoCurves(e,a)),this.m_curveData.m_segmentParamIndex.write(t,_!==1?u:-1),this.m_curveData.m_segmentFlags.write(t,_),_!==1&&s.writeInBufferStream(this.m_curveData.m_segmentParams,u),c||(this.m_curveData.m_curveParamWritePoint+=l),h!==_&&(this.incCurveType(h,-1),this.incCurveType(_,1),this.modifyCurveCounter(h===1?1:-1))}setAttributeImpl(t,e,s){if(this.addAttribute(t),!this.isEmpty())if(this.hasNonLinearSegments()&&t===0){(e<0||e>1)&&H("");const i=new pt,n=e===0?s:0,o=e===0?0:1;i.setShiftCoords(n,o),e===0?i.xx=0:i.yy=0,this.applyTransformation(i)}else super.setAttributeImpl(t,e,s)}};Tm.st_totalCurveCount=0;let Qp=class{constructor(t,e){this.m_segIter=null,this.m_quadTree=null,this.m_qtIter=null,this.m_extentOfInterest=new F(e),this.m_bfirst=!0,this.m_prevIndex=-100,this.m_parent=t}nextSegment(){return this.m_bfirst&&this.prepare_(),this.m_quadTree?this.nextSegmentQt():this.nextSegmentNoQt()}getPathIndex(){return this.m_segIter.getPathIndex()}getStartPointIndex(){return this.m_segIter.getStartPointIndex()}getEndPointIndex(){return this.m_segIter.getEndPointIndex()}isClosingSegment(){return this.m_segIter.isClosingSegment()}isPathClosed(){return this.m_segIter.isPathClosed()}prepare_(){const t=this.m_parent.getAccelerators();t&&(this.m_quadTree=t.getQuadTree(),this.m_quadTree&&(this.m_qtIter=this.m_quadTree.getSortedIterator(this.m_extentOfInterest,0))),this.m_segIter=this.m_parent.querySegmentIterator()}nextSegmentQt(){this.m_bfirst=!1;const t=this.m_qtIter.next();if(t===-1)return null;const e=this.m_quadTree.getElement(t);return(e!==this.m_prevIndex+1||this.m_segIter.isLastSegmentInPath())&&(this.m_segIter.resetToVertex(e,this.m_segIter.getPathIndex()),this.m_prevIndex=e),this.m_segIter.nextSegment()}nextSegmentNoQt(){for(;;){if(!this.m_bfirst&&this.m_segIter.hasNextSegment()){const t=this.m_segIter.nextSegment(),e=F.constructEmpty();if(t.queryLooseEnvelope(e),!e.isIntersecting(this.m_extentOfInterest))continue;return t}if(this.m_bfirst=!1,!this.m_segIter.nextPath())return null}}},Pt=class Ch extends Tm{constructor(t){t?t.vd?(super({vd:t.vd,bPolygon:!1}),this.m_segmentBufferCTor=it):t.copy?(super({vd:t.copy.getDescription(),bPolygon:!1}),this.m_segmentBufferCTor=it,t.copy.copyTo(this)):t.move?(super({move:t.move}),this.m_segmentBufferCTor=it):t.start?(super({vd:t.start.getDescription(),bPolygon:!1}),this.m_segmentBufferCTor=it,this.startPathPoint(t.start),this.lineToPoint(t.end)):t.path?(super({bPolygon:!1}),this.m_segmentBufferCTor=it,this.addPathPoint2D(t.path,t.pointCount,t.bForward)):$("bad constructor arg"):(super({bPolygon:!1}),this.m_segmentBufferCTor=it)}getBoundary(){return Gs(this)}assignCopy(t){return this!==t&&t.copyTo(this),this}assignMove(t){return t.copyTo(this),this}getGeometryType(){return Ch.type}getDimension(){return 1}createInstance(){return new Ch({vd:this.getDescription()})}equals(t,e){return this.equalsBase(t,e)}};Pt.type=T.enumPolyline;var pi=T;function Ai(r,t){if(r.isEmpty())return!1;const e=r.getGeometryType();if(e===pi.enumPolygon)return r.calculateArea2D()!==0;if(e===pi.enumPolyline)return lg(r.getImpl(),t,!0).bNotEmpty;if(e===pi.enumEnvelope)return!0;if(he(e))return!!r.isClosed();if(xn(e))return!1;if(e===pi.enumGeometryCollection){const s=r;for(let i=0,n=s.getGeometryCount();i<n;i++)if(Ai(s.getGeometry(i),t))return!0;return!1}ft("")}function Gs(r,t){const e=r.getGeometryType();if(e===pi.enumPolygon){const s=new Pt({vd:r.getDescription()});return r.isEmpty()||r.copyToUnchecked(s),s}if(e===pi.enumPolyline)return lg(r.getImpl(),t,!1).boundary;if(e===pi.enumEnvelope){const s=new Pt({vd:r.getDescription()});return r.isEmpty()||s.addEnvelope(r,!1),s}if(he(e)){const s=new Zt({vd:r.getDescription()});if(!r.isEmpty()&&!r.isClosed()){const i=new st;s.reserve(2),r.queryStart(i),s.add(i),r.queryEnd(i),s.add(i)}return s}if(e===pi.enumGeometryCollection){const s=r;let i=null;for(let n=0,o=s.getGeometryCount();n<o;n++){const a=Gs(s.getGeometry(n),t);if(a!==null){i===null&&(i=r.createInstance());const h=a;i.addGeometry(h)}}return i}if(xn(e))return new st({vd:r.getDescription()});ft("")}function lg(r,t,e){const i=r;let n=null;if(e||(n=new Zt({vd:i.getDescription()})),!i.isEmpty()){const o=new Xt(0);for(let a=0,h=i.getPathCount();a<h;a++)if(i.getPathSize(a)>0&&!i.isClosedPathInXYPlane(a)){const m=i.getPathStart(a);o.add(m);const l=i.getPathEnd(a)-1;o.add(l)}if(o.size()>0){const a=new Ys,h=i.getAttributeStreamRef(0),m={userSort(_,d,p){const f=y.getNAN(),x=y.getNAN();p.sort(_,d,(E,P)=>(h.queryPoint2D(2*E,f),h.queryPoint2D(2*P,x),f.compare(x)))},getValue:_=>h.read(2*_+1)};a.sort(o,0,o.size(),m);let l=h.readPoint2D(2*o.read(0)),u=0,c=1;const g=new st;for(let _=1,d=o.size();_<d;_++){const p=h.readPoint2D(2*o.read(_));if(p.isEqualPoint2D(l))o.read(u)>o.read(_)?(o.write(u,we()),u=_):o.write(_,we()),c++;else{if(1&c){if(e)return{bNotEmpty:!0,boundary:new Zt({})}}else o.write(u,we());l=p,u=_,c=1}}if(1&c){if(e)return{bNotEmpty:!0,boundary:new Zt({})}}else o.write(u,we());if(!e){o.sort(0,o.size());for(let _=0,d=o.size();_<d&&o.read(_)!==we();_++)i.getPointByVal(o.read(_),g),n.add(g)}}}return e?{bNotEmpty:!1,boundary:new Zt({})}:{bNotEmpty:!1,boundary:n}}function Ti(r,t,e,s){const i=4*jt()*(Math.abs(t.vmin)+Math.abs(t.vmax)),n=jt();if(r.getMaxDerivative()===1){b(e>0);const l=Hl(r,0,t,jt(),i);return s[0]=l.root,l.cRoots}let o,a=[];const h=new z(t.vmin-i,t.vmax+i);a.push(new y(h.vmin,h.vmax));let m=0;for(let l=r.getMaxDerivative()-1;l>=0;l--){o=a,a=[];for(let u=0,c=o.length;u<c;u++){if(o[u][0]<o[u][1]){let g,_,d;if(l===r.getMaxDerivative()-1?{root:g,funcAtRoot:_,cRoots:d}=Hl(r,l,z.construct(o[u][0],o[u][1]),n,.5*i):{root:g,funcAtRoot:_,cRoots:d}=ef(r,l,z.construct(o[u][0],o[u][1]),n,.5*i),d===1){if(l===0)m<e&&(o[u][0]<=t.vmin&&o[u][1]>=t.vmin&&g!==t.vmin&&r.getValue(0,t.vmin)===0&&(g=t.vmin),o[u][0]<=t.vmax&&o[u][1]>=t.vmax&&g!==t.vmax&&r.getValue(0,t.vmax)===0&&(g=t.vmax),s[m]=t.snapClip(g),m>0?s[m]-s[m-1]>i&&m++:m++);else{const p=y.getNAN();p[0]=o[u][0],p[1]=g,a.push(p);const f=y.getNAN();f[0]=g,f[1]=o[u][1],a.push(f)}continue}}a.push(o[u])}}return m}function Kp(r,t,e,s){const i=new L,n=hr(new L(r),new L(t),e,i);return s[0]=i.value(),n}function Ui(r,t,e,s,i,n){const o=R(L,2),a=$e(new L(r),new L(t),new L(e),s,i,o);return n[0]=o[0].value(),n[1]=o[1].value(),a}function ug(r,t,e,s,i,n,o){const a=R(L,3),h=Go(new L(r),new L(t),new L(e),new L(s),i,n,a);return o[0]=a[0].value(),o[1]=a[1].value(),o[2]=a[2].value(),h}function Bl(r,t,e,s,i,n,o,a){return tf(r,t,e,s,i,n,o,a)}function Jp(r,t,e,s,i,n){return sf(r,t,e,s,i,n)}function tf(r,t,e,s,i,n,o,a){const h=j(e*e,Number.NaN);h.fill(0),ne(a,s,0,0,e);const m=j(e,Number.NaN),l=j(e,Number.NaN),u=j(e,Number.NaN);let c=r(a,e,t);const g=100;let _=0;for(_=0;_<g;_++){const d=c;for(let E=0;E<e;++E)l[E]=a[E];if(_%e===0){h.fill(0);for(let E=0;E<e;E++)h[E*e+E]=1}let p=0,f=0;for(let E=0;E<e;++E){for(let S=0;S<e;++S)m[S]=h[E*e+S];const P=c;c=zl(r,t,a,m,i,n,e);const C=P-c;C>p&&(f=E,p=C)}for(let E=0;E<e;E++)m[E]=a[E]-l[E],u[E]=a[E]+(a[E]-l[E]);const x=r(u,e,t);if(x<d&&2*(d-2*c+x)*yt(d-c-p)<yt(d-x)*p){c=zl(r,t,a,m,i,n,e);for(let E=0;E<e;++E)h[f*e+E]=h[(e-1)*e+E],h[(e-1)*e+E]=m[E]}if(d<=c)return r(a,e,t)}return c}function Hl(r,t,e,s,i){const n={root:0,funcAtRoot:0,cRoots:0};let o=e.vmin,a=e.vmax,h=0,m=Number.MAX_VALUE,l=r.getValue(t,o),u=r.getValue(t,a),c=0,g=0,_=0;if(l>=0&&u>=0||l<=0&&u<=0)return Math.abs(l)<Math.abs(u)?(n.funcAtRoot=l,n.root=o,n.cRoots=l===0?1:0,n):(n.funcAtRoot=u,n.root=a,n.cRoots=u===0?1:0,n);Math.abs(l)<Math.abs(u)&&(a=O(o,o=a),u=O(l,l=u)),h=o,c=l;let d=!0,p=0;for(;u!==0&&Math.abs(o-a)>s*Math.abs(a)+i;p++){let f=p>64;if(!f){g=l!==c&&u!==c?o*u*c/((l-u)*(l-c))+a*l*c/((u-l)*(u-c))+h*l*u/((c-l)*(c-u)):a-u*(a-o)/(u-l);const x=(3*o+a)/4;if(f=!(g>x&&g<a||g>a&&g<x),!f){const E=s*Math.abs(a)+i;if(d){const P=Math.abs(a-h);f=Math.abs(g-a)>=.5*P||P<E}else{const P=Math.abs(h-m);f=Math.abs(g-a)>=.5*P||P<E}}}if(f?(g=(o+a)/2,d=!0):d=!1,_=r.getValue(t,g),_===0)return n.root=g,n.funcAtRoot=_,n.cRoots=1,n;if(!f){const x=o-g,E=g-a;if(Math.abs(x)>10*Math.abs(E)){let P=a+3*E;for(let C=0;C<2;C++){const S=r.getValue(t,P);kt(l)*kt(S)>0?(o=P,l=S):P=Ct(o,a,.75)}}else if(Math.abs(E)>10*Math.abs(x)){let P=o-3*x;for(let C=0;C<2;++C){const S=r.getValue(t,P);kt(u)*kt(S)>0?(a=P,u=S):P=Ct(o,a,.25)}}}m=h,h=a,c=u,kt(l)*kt(_)<0?(a=g,u=_):(o=g,l=_),Math.abs(l)<Math.abs(u)&&(a=O(o,o=a),u=O(l,l=u)),p===128&&$("Root_finder iterations exceeded")}return n.root=a,n.funcAtRoot=u,n.cRoots=1,n}function ef(r,t,e,s,i){const n={root:0,funcAtRoot:0,cRoots:0};let o=e.vmin,a=r.getValue(t,o),h=e.vmax,m=r.getValue(t,h);if(a>=0&&m>=0||a<=0&&m<=0)return Math.abs(a)<Math.abs(m)?(n.funcAtRoot=a,n.root=o,n.cRoots=a===0?1:0,n):(n.funcAtRoot=m,n.root=h,n.cRoots=m===0?1:0,n);m<0&&(m=O(a,a=m),h=O(o,o=h));let l=.5*(o+h),u=Math.abs(h-o),c=u,g=r.getValue(t,l),_=r.getValue(t+1,l);const d=1,p=4;let f=p;const x=2;let E=1,P=0,C=0,S=d;const I=32;let w=0;for(;++w<100;){let D;w>I||_===0||S===x&&P>1||S===d&&f<p?(S=d,E>1&&E--):(S=x,C>1&&Math.abs(2*g)>Math.abs(u*_)&&E++),u=c;let N=!1;if(S===d)do{if(C>2){const G=16*Math.abs(u);if(.5*Math.abs(o-h)>G){const q=Math.min(o,h),V=Math.max(o,h);if(l===q){D=l,l=q+G,c=l-D;break}if(l===V){D=l,l=V-G,c=l-D;break}}}c=.5*(h-o),D=l,l=o+c,N=o===l||h===l}while(!1);else for(;;){c=E*g/_,D=l,l-=c,N=l===D;const G=Math.min(o,h),q=Math.max(o,h);if(l<G){if(E>1){l=D,E--;continue}c=D-G,l=G}else if(l>q){if(E>1){l=D,E--;continue}c=D-q,l=q}break}if(N||Math.abs(c)<i){D!==l&&(g=r.getValue(t,l));break}g=r.getValue(t,l),_=r.getValue(t+1,l);const A=o,M=h;g<0?(a=g,o=l):(m=g,h=l),S===x&&(o===A&&h===M||C>1&&Math.abs(c)>=.5001*Math.abs(u))?P++:P=0,S===d?(f++,C=0):(f=0,C++)}return w===100&&$("Root_finder iterations exceeded"),n.root=l,n.funcAtRoot=g,n.cRoots=1,n}function zl(r,t,e,s,i,n,o){const a=s.slice(0,o);let h=0;for(let f=0;f<o;f++)h+=s[f]*s[f];if(h=Math.sqrt(h),h>0)for(let f=0;f<o;f++)a[f]/=h;let m=Number.NEGATIVE_INFINITY,l=Number.POSITIVE_INFINITY;{const f=j(o,0);for(let x=0;x<o;x++)f[x]=x;f.sort((x,E)=>{const P=Math.abs(a[x]),C=Math.abs(a[E]);return P<C?-1:P>C?1:0});for(let x=0;x<o;x++){const E=f[x];if(a[E]===0)continue;let P=(i[E]-e[E])/a[E],C=(n[E]-e[E])/a[E];C<P&&(C=O(P,P=C)),P>m&&(m=P),C<l&&(l=C)}}let u=0;const c=(Math.abs(m)+Math.abs(l))*jt()*100,g=j(o,Number.NaN),_=a.slice();function d(f,x){for(let E=0,P=o;E<P;E++)g[E]=e[E]+f*_[E];return r(g,o,t)}c>0&&(u=Jp(d,null,m,0,l,c));const p=d(u);for(let f=0,x=o;f<x;f++)e[f]=Nt(g[f],i[f],n[f]);return p}function sf(r,t,e,s,i,n){const o=gh();let a=s,h=r(a,t),m=e,l=i,u=r(m,t),c=r(l,t);h>u&&(h=u,a=m),h>c&&(h=c,a=l);let g=m,_=l,d=u,p=c;d>p&&(d=O(p,p=d),_=O(g,g=_));let f=a-g,x=g-_;const E=.5*Math.min(n,l-m),P=2*E,C=100;let S,I=0;for(S=0;S<C&&!(l-m<=P);++S){const w=m+.5*(l-m);let D=I>0;if(!D&&Math.abs(x)<=E&&(D=!0,I=3),!D){const M=a-g,G=a-_,q=M*(h-p);let V=G*(h-d),k=G*V-M*q;V=2*(V-q),V>0&&(k=-k),V=Math.abs(V),V===0||Math.abs(k)>=Math.abs(V*x/2)||k<=V*(m-a)||k>=V*(l-a)?(D=!0,I=3):(x=f,f=k/V)}D&&(x=a>=w?m-a:l-a,f=o*x,I--);let N=a+f;N<m+E?N=m+E:N>l-E&&(N=l-E);const A=r(N,t);A<h?(N>=a?(m=a,u=h):(l=a,c=h),_=g,g=a,a=N,p=d,d=h,h=A):(N<a?(m=N,u=A):(l=N,c=A),A<=d||g===a?(_=g,g=N,p=d,d=A):(A<=p||_===a||_===g)&&(_=N,p=A))}return a}function hr(r,t,e,s){return r.isZero()?t.isZero()?-1:0:(s.setE(t.clone().negateThis().divThisE(r)),e.containsCoordinate(s.value())?1:0)}function $e(r,t,e,s,i,n){if(r.value()===0)return i?(n[0].set(1),s.containsCoordinate(n[0].value())?1:0):hr(t,e,s,n[0]);if(i){let g=2;return n[0].set(1),n[1].setE(e).divThisE(r),n[1].eq(n[0])&&(n[1].set(1),g=1),s.containsCoordinate(n[1].value())||(g=1),s.containsCoordinate(n[0].value())||(g--,n[0].setE(n[1])),g===2&&n[0].value()>n[1].value()&&(n[1]=O(n[0],n[0]=n[1])),g}const o=t.clone().sqrThis().subThisE(r.clone().mulThisE(e).mulThisE(zd));if(o.lt(qn))return 0;const a=new L(t.value()>=0?1:-1),h=o.clone().sqrtThis(),m=new L(-.5).mulThisE(t.clone().addThisE(a.clone().mulThisE(h)));let l=0;n[0].setE(m.divE(r));const u=new L(n[0].value()),c=new L(r.value()).mulE(u).addE(new L(t.value()).mulE(u).addE(new L(e.value())));return c.isZero()||Ul(n[0],r,t,e,n[0]),s.containsCoordinate(n[0].value())&&l++,h.value()!==0&&m.value()!==0&&(n[l].assign(e.divE(m)),u.set(n[l].value()),c.assign(new L(r.value()).mulE(u).addE(new L(t.value()).mulE(u).addE(new L(e.value())))),c.isZero()||Ul(n[l],r,t,e,n[l]),s.containsCoordinate(n[l].value())&&l++,l===2&&n[0].value()>n[1].value()&&(n[1]=O(n[0],n[0]=n[1]))),l}function Go(r,t,e,s,i,n,o){if(r.value()===0)return $e(t,e,s,i,n,o);if(n){let a=1;o[0].set(1);const h=o.slice(a),m=$e(r,t.addE(r),s.negate(),i,!1,h);if(m>0){a+=m;for(let u=1;u<a;u++)o[u].eq(er)&&(o[a-1]=O(o[u],o[u]=o[a-1]),a--)}const l=o.slice(0,a);l.sort((u,c)=>u.value()<c.value()?-1:u.value()>c.value()?1:0);for(let u=0;u<a;++u)o[u]=l[u];return a}return af(r,t,e,s,i,o)}function cg(r,t,e,s,i,n){return(n<t||t<0)&&H("nth_degree_real_roots"),hf(r,t,e,s,i)}function Eh(r,t,e,s){return{coef0:r.clone(),coef1:t.clone(),coef2:e.clone(),coef3:s.clone(),calcF(i){return this.coef0.clone().mulThis(i).addThisE(this.coef1).mulThis(i).addThisE(this.coef2).mulThis(i).addThisE(this.coef3)},calcDF(i){return this.coef0.clone().mulThis(3).mulThis(i).addThisE(this.coef1.clone().mulThisByPower2(2)).mulThis(i).addThisE(this.coef2)},estimateError(i){const n=Math.abs(i),o=((this.coef0.eps()*n+this.coef1.eps())*n+this.coef2.eps())*n+this.coef3.eps()+this.calcF(i).eps(),a=this.coef0.clone().mulThis(i).mulThis(3).addThisE(this.coef1.clone().mulThis(2)).mulThis(i).addThisE(this.coef2);if(a.isZero()){const h=this.coef0.clone().mulThis(i).mulThis(6).addThisE(this.coef1.clone().mulThis(2));if(h.isZero()){const m=this.coef0.clone().mulThis(6);return Math.pow(6*o/Math.abs(m.value()),1/3)}return Math.sqrt(2*o/Math.abs(h.value()))}return o/Math.abs(a.value())}}}let nf=class{updateCoefs(t){if(this.lastDeriv1===t)return this.curCoefs=this.derivCoefs1,void(this.lastUsed=1);if(this.lastDeriv2===t)return this.curCoefs=this.derivCoefs2,void(this.lastUsed=2);let e;this.lastUsed===1?(e=this.derivCoefs2,this.lastDeriv2=t,this.lastUsed=2):(e=this.derivCoefs1,this.lastDeriv1=t,this.lastUsed=1),e.length=0;for(let s=0,i=this.truePower-t;s<=i;++s){e.push(this.coefs[s+t].clone());let n=s+t,o=n--;for(let a=1;a<t;a++)o*=n--;e[s].mulThis(o)}this.curCoefs=e}constructor(t,e,s,i){this.derivCoefs1=[],this.derivCoefs2=[],this.lastDeriv1=-1,this.lastDeriv2=-1,this.lastUsed=-1,this.curCoefs=null,this.coefs=t,this.power=e,this.truePower=0;for(let n=e;n>=1;n--)if(this.coefs[n].value()!==0){this.truePower=n;break}}getMaxDerivative(){return this.truePower+1}getValue(t,e){let s=this.coefs;t===0?s=this.coefs:(this.updateCoefs(t),s=this.curCoefs);const i=new Ce(0);let n=1;for(let o=0,a=this.truePower-t;o<=a;++o)i.pe(n*s[o].value()),n*=e;return i.getResult()}getError(t){const e=Math.abs(t),s=new Ce(0),i=new L(1),n=new L(0);for(let a=0,h=this.power;a<=h;++a)n.addThisE(this.coefs[a].mulE(i)),s.pe(i.value()*this.coefs[a].eps()),i.mulThis(e);s.pe(n.eps());let o=1;for(let a=1;a<=this.truePower;++a){o*=a,this.updateCoefs(a);const h=new L(1),m=new L(0);for(let l=0,u=this.truePower-a;l<=u;++l)m.addThisE(this.curCoefs[l].mulE(h)),h.mulThis(t);if(!m.isZero())return Math.pow(o*s.getResult()/Math.abs(m.value()),1/a)}return 0}};function gg(r,t,e,s,i,n){let o=r,a=t,h=a-o;if(!n){let g=s.calcF(r).value(),_=s.calcF(t).value();if((g>0||g>_)&&(a=O(o,o=a),_=O(g,g=_)),g>=0||_<=0)return!1}let m,l=!1,u=e,c=0;for(;c<100;c++){const g=s.calcF(u);if(m=s.calcDF(u),m.isZero())return!1;if(!g.value()||c>3&&g.isZero()){l=!0;break}n||(g.value()<0?o=u:a=u);const _=g.value()/m.value(),d=u-_;n||(d>=o&&d<=a||d>=a&&d<=o)&&Math.abs(_)<=.5*h?(u=d,h=Math.abs(_)):(h=Math.abs(.5*(a-o)),u=.5*(o+a))}return!!l&&(i.set(u,s.estimateError(u)),!0)}function rf(r,t,e,s,i,n,o,a){return gg(r,t,e.value(),Eh(s,i,n,o),a,!1)}let of=class{constructor(t,e,s){this.coefs=R(L,3),this.coefs[0].setE(t),this.coefs[1].setE(e),this.coefs[2].setE(s)}calcF(t){const e=new L(t);return this.coefs[0].mulE(e).addE(this.coefs[1]).mulE(e).addE(this.coefs[2])}calcDF(t){const e=new L(t);return L.st_mulByPower2(this.coefs[0],2).mulE(e).addE(this.coefs[1])}estimateError(t){const e=Math.abs(t),s=(this.coefs[0].eps()*e+this.coefs[1].eps())*e+this.coefs[2].eps()+this.calcF(t).eps(),i=new L(2).mulE(this.coefs[0]).mul(t).addE(this.coefs[1]);if(i.isZero()){const n=this.coefs[0].value();return Math.sqrt(s/Math.abs(n))}return s/Math.abs(i.value())}};function Ul(r,t,e,s,i){return gg(0,0,r.value(),new of(t,e,s),i,!0)}function af(r,t,e,s,i,n){const o=R(L,3);let a=0;const h=t.negate().divThisE(r.clone().mulThis(3));i.containsCoordinate(h.value())&&(o[0].setE(h),a=1);const m=R(L,2),l=$e(r.mul(3),t.mul(2),e,i,!1,m);if(l<0)return s.isZero()?-1:0;for(let d=0;d<l;d++)i.containsCoordinate(m[d].value())&&o[a++].setE(m[d]);Vs(o,0,a,(d,p)=>d.value()<p.value()?-1:d.value()>p.value()?1:0);const u=R(L,5);u[0].set(i.vmin);for(let d=0;d<a;d++)u[1+d].setE(o[d]);u[1+a].set(i.vmax);const c=a+2;let g=1,_=0;{const d=u[0].clone();if(r.clone().mulThisE(d).addThisE(t).mulThisE(d).addThisE(e).mulThisE(d).addThisE(s).isZero()){const p=Eh(r,t,e,s);d.setError(p.estimateError(d.value())),n[_]=d,_++,g++}}for(let d=g;d<c;d++){const p=u[d].clone(),f=r.clone().mulThisE(p).addThisE(t).mulThisE(p).addThisE(e).mulThisE(p).addThisE(s).isZero();if(f||!u[d].eq(u[d-1])){if(f||rf(u[d-1].value(),u[d].value(),u[d-1].clone().addThisE(u[d]).divThisByPower2(2),r,t,e,s,p)){if(_>0&&p.eq(n[_-1]))continue;if(_>=3&&$("cubic_polynomial_solver_too_many_roots"),f){const x=Eh(r,t,e,s);p.setError(x.estimateError(p.value()))}n[_]=p,_++}if(u[d].value()===i.vmax)break;f&&d++}}return _}function hf(r,t,e,s,i,n){const o=new nf(r,t,e,jt());let a=0;if(o.truePower===2)a=$e(r[2],r[1],r[0],e,s,i);else if(o.truePower===1)a=hr(r[1],r[0],e,i[0]);else{if(o.truePower===0)return r[0].value()?0:-1;{const h=[];h.length=t,a=Ti(o,e,t,h);for(let m=0;m<a;m++)i[m].set(h[m])}}for(let h=0;h<a;h++)i[h].setError(o.getError(i[h].value()));return a}var Zr=Mt;let Ge=class _g extends Rr{constructor(t){return t===void 0||ha(t,"vd")?(super({vd:t?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_cp=new y(0,0),void(this.m_weights=[1,0,1])):(t.fromPoint&&t.weight?t={fromPoint:t.fromPoint,controlPoint1:t.controlPoint1,toPoint:t.toPoint,weight0:1,weight1:t.weight,weight2:1}:t.points&&t.weight?t={fromPoint:t.points[0],controlPoint1:t.points[1],toPoint:t.points[2],weight0:1,weight1:t.weight,weight2:1}:t.points&&t.weights&&(t={fromPoint:t.points[0],controlPoint1:t.points[1],toPoint:t.points[2],weight0:t.weights[0],weight1:t.weights[1],weight2:t.weights[2]}),t.fromPoint&&t.weight0?(super({start:t.fromPoint,end:t.toPoint}),(t.weight0<=0||t.weight1<0||t.weight2<=0)&&H("weights"),this.m_cp=t.controlPoint1.clone(),void(this.m_weights=[t.weight0,t.weight1,t.weight2])):t.copy?(super(t),this.m_cp=t.copy.m_cp.clone(),void(this.m_weights=t.copy.m_weights.slice())):t.move?(super(t),this.m_cp=t.move.m_cp.clone(),void(this.m_weights=t.move.m_weights.slice())):void ft("unexpected constructor param"))}getBoundary(){return Gs(this)}assignMove(t){return this}assignCopy(t){return t.copyTo(this),this}construct(t,e,s,i){this.dropAllAttributes(),this.setCpsAndWeights(t,e,s,1,i,1),Bn(this)}constructWeights(t,e,s,i,n,o){this.dropAllAttributes(),this.setCpsAndWeights(t,e,s,i,n,o),Bn(this)}constructArray(t,e){this.construct(t[0],t[1],t[2],e)}constructArrayWeights(t,e){this.dropAllAttributes(),this.setCpsAndWeightsArray(t,e),Bn(this)}convertToStandardForm(){}getStandardFormWeight(){return this.m_weights[1]/Math.sqrt(this.m_weights[0]*this.m_weights[2])}getGeometryType(){return T.enumRationalBezier2}queryEnvelope(t){if(t instanceof F){if(t.setCoords(this.getStartXY()),t.mergeNe(this.getEndXY()),t.contains(this.m_cp))return;const e=fu(this);if(e!==null){const s=new y;for(const i of e.specialPoints)this.queryCoord2D(i,s),t.mergeNe(s)}else{const s=[],i=R(y,3);this.queryControlPoints(i),Hg(i,this.m_weights,s);const n=new y;for(const o of s)this.queryCoord2D(o,n),t.mergeNe(n)}}}applyTransformation(t){if(t instanceof pt){const e=R(y,3);return this.queryControlPoints(e),t.transformPoints2D(e,3,e),this.setStartXY(e[0]),this.m_cp.assign(e[1]),this.setEndXY(e[2]),void this.afterCompletedModification()}}createInstance(){return new _g({vd:this.m_description})}calculateLength2D(){return xr(this,1,!1)}calculateLowerLength2D(){return y.distance(this.getStartXY(),this.getEndXY())}calculateUpperLength2D(){return this.calculateUpperLength2D_()}calculateUpperLength2D_(){return this.m_weights[1]>0?y.distance(this.getStartXY(),this.m_cp)+y.distance(this.getEndXY(),this.m_cp):y.distance(this.getStartXY(),this.getEndXY())}queryCoord2D(t,e){return this.queryCoord2DExtension(t,e,!0)}queryCoord2DE(t,e){e1(this,t,e)}queryCoord2DExtension(t,e,s){if(s){if(t<0)return void Ue(new ht({start:this.getStartXY(),end:this.getStartXY().add(this.getTangent(0).getUnitVector())}),t,e);if(t>1)return void Ue(new ht({start:this.getEndXY(),end:this.getEndXY().add(this.getTangent(1).getUnitVector())}),t-1,e)}const i=R(y,3);this.queryControlPoints(i),Ut(i,this.m_weights,t,e)}getCoordX(t){const e=new y;return this.queryCoord2DExtension(t,e,!0),e.x}getCoordY(t){const e=new y;return this.queryCoord2DExtension(t,e,!0),e.y}cut(t,e,s){const i=new it;return this.queryCut(t,e,i,s),i.releaseSegment()}queryCut(t,e,s,i){const n=s.createQuadraticRationalBezier();if(this.cutBezierIgnoreAttributes(t,e,n),i)return;n.assignVertexDescription(this.m_description);const o=this.m_description.getAttributeCount();if(o>1){for(let a=1;a<o;a++){const h=this.m_description.getSemantics(a),m=Zr.getComponentCount(h);for(let l=0;l<m;l++){const u=this.getAttributeAsDbl(t,h,l);n.setStartAttribute(h,l,u)}}for(let a=1;a<o;a++){const h=this.m_description.getSemantics(a),m=Zr.getComponentCount(h);for(let l=0;l<m;l++){const u=this.getAttributeAsDbl(e,h,l);n.setEndAttribute(h,l,u)}}}}queryDerivative(t,e){R0(this,t,e)}cutBezierIgnoreAttributes(t,e,s){(t<0||e>1||t>e)&&H("Quadratic_rational_bezier.cut_bezier_ignore_attributes");const i=R(y,3);this.queryControlPoints(i);const n=[0,0,0];bi(i,this.m_weights,t,e,i,n),s.setControlPointsAndWeights(i,n)}splitBezierIgnoreAttributes(t,e,s){}getAttributeAsDbl(t,e,s){if(e===0)return s===0?this.getCoordX(t):this.getCoordY(t);const i=this.calculateLength2D(),n=i>0?this.tToLength(t)/i:0,o=Zr.getInterpolation(e),a=this.getStartAttributeAsDbl(e,s),h=this.getEndAttributeAsDbl(e,s);return Fr(o,a,h,n,Zr.getDefaultValue(e))}getClosestCoordinate(t,e){return Ho(this,t,z.unit(),e,-1)}getClosestCoordinateOnInterval(t,e,s=-1){return Ho(this,t,e,!1,s)}getYMonotonicParts(t,e){return this.getMonotonicParts(t,e)}getMonotonicParts(t,e){t.length<2&&H("");const s=fr(this);let i=0;if(s.specialPointsCount()===2)return 0;b(t.length>=s.specialPointsCount()-1);for(let n=1,o=s.specialPointsCount();n<o;++n)this.queryCut(s.specialPoints[n-1],s.specialPoints[n],t[i],e),i++;for(let n=0;n<i;++n)Hh(t[n].get());return i}intersectionWithAxis2D(t,e,s,i){s&&(s.length=9),i&&(i.length=9);const n=new Array(3),o=R(L,2),a=new z(0,1);let h=0;const m=R(y,3);if(this.queryControlPoints(m),t){if(n[0]=new L(m[0].y).sub(e).mul(this.m_weights[0]),n[1]=new L(m[1].y).sub(e).mul(this.m_weights[1]),n[2]=n[0].subE(n[1].mul(2)).addE(new L(m[2].y).sub(e).mul(this.m_weights[2])),n[1]=n[1].subE(n[0]).mulThisByPower2(2),h=$e(n[2],n[1],n[0],a,!1,o),s)for(let l=0;l<h;l++)s[l]=this.getCoordX(o[l].value())}else if(n[0]=new L(m[0].x).sub(e).mul(this.m_weights[0]),n[1]=new L(m[1].x).sub(e).mul(this.m_weights[1]),n[2]=n[0].subE(n[1].mul(2)).addE(new L(m[2].x).sub(e).mul(this.m_weights[2])),n[1]=n[1].subE(n[0]).mulThisByPower2(2),h=$e(n[2],n[1],n[0],a,!1,o),s)for(let l=0;l<h;l++)s[l]=this.getCoordY(o[l].value());if(i)for(let l=0;l<h;l++)i[l]=o[l].value();else s&&Vs(s,0,h,Os);return h}intersectionOfYMonotonicWithAxisX(t,e){if(this.m_YStart===this.m_YEnd)return t===this.m_YStart?e:Number.NaN;if(t===this.m_YStart)return this.m_XStart;if(t===this.m_YEnd)return this.m_XEnd;const s=[Number.NaN,Number.NaN],i=this.intersectionWithAxis2D(!0,t,s,null);return b(i!==2),i===-1?e:s[0]}isCurve(){return!0}isDegenerate(t){return _a(this,t)}isDegenerate3D(t,e){return!1}queryLooseEnvelope(t){if(t instanceof F)return t.setCoords({pt:this.getStartXY()}),t.mergeNe(this.m_cp),void t.mergeNe(this.getEndXY())}clone(t){const e=this.createInstance();return this.copyTo(e),e}queryInterval(t,e){if(t===0){const s=F.constructEmpty();this.queryEnvelope(s);const i=z.constructEmpty();return e===0?s.queryIntervalX(i):s.queryIntervalY(i),i}return super.queryInterval(t,e)}queryLooseEnvelopeOnInterval(t,e){const s=R(y,3);this.queryControlPoints(s);const i=[0,0,0];bi(s,this.m_weights,t.vmin,t.vmax,s,i),e.setFromPoints(s,3)}changeEndPoints2D(t,e){if(t.isEqual(this.m_XStart,this.m_YStart)&&e.isEqual(this.m_XEnd,this.m_YEnd))return;const s=this.m_cp.isEqual(this.m_XStart,this.m_YStart),i=this.m_cp.isEqual(this.m_XEnd,this.m_YEnd);this.setStartXY(t),this.setEndXY(e),s?this.m_cp.setCoordsPoint2D(t):i&&this.m_cp.setCoordsPoint2D(e),this.normalizeAfterEndpointChange()}tToLength(t){return xr(this,t,!0)}lengthToT(t){return B0(this,t)}calculateWeightedAreaCentroid2D(t){const e=U0(this),s=pu(this);return e.x+=(this.getStartX()-t.x)*s,e.y+=(this.getStartY()-t.y)*s,e}calculateWeightedCentroid2D(){const t=new y;return this.isDegenerate(0)?(t.setCoords(0,0),t):W0(this)?(t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t):(t.assign(Z0(this,1)),t)}getControlPoint1(){return this.m_cp.clone()}setControlPoint1(t){this.m_cp.setCoordsPoint2D(t),this.afterCompletedModification()}queryWeights(t){for(let e=0;e<3;++e)t[e]=this.m_weights[e]}queryCoord2DMP(t,e){const s=R(y,3);return this.queryControlPoints(s),i1(s.map(i=>Et.constructPoint2D(i)),this.m_weights.map(i=>J.constructDouble(i)),J.constructDouble(t),e)}setWeights(t){}queryControlPoints(t){t[0].assign(this.getStartXY()),t[1].assign(this.m_cp),t[2].assign(this.getEndXY())}queryControlPointsHelper(t){return this.queryControlPoints(t),3}setControlPointsAndWeights(t,e){this.setCpsAndWeightsArray(t,e),this.afterCompletedModification()}getTangent(t){const e=R(y,3);return this.queryControlPoints(e),Bh(e,this.m_weights,t)}getDerivative(t){const e=Nt(t,0,1),s=R(y,4);return Bo(this,1,e,s),s[1]}getCurvature(t){const e=R(y,4);Bo(this,2,t,e);const s=e[1].sqrLength();return s===0?Number.NaN:(e[1].divThis(Math.sqrt(s)),e[1].crossProduct(e[2])/s)}isIntersecting(t,e,s){return!1}isIntersectingPoint(t,e,s){return!1}isIntersectingPoint3D(t,e,s,i,n=1){return!1}isMonotoneQuickAndDirty(){const t=R(y,3);return this.queryControlPoints(t),fa(t)}getMonotonicPartParams(t,e){const s=fr(this),i=s.specialPointsCount();if(!e)return s.specialPointsCount();t<i&&H("");for(let n=0;n<i;n++)e[n]=s.specialPoints[n];return i}normalizeAfterEndpointChange(){return!1}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){this.m_XEnd=O(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=O(this.m_YStart,this.m_YStart=this.m_YEnd),this.m_weights[2]=O(this.m_weights[0],this.m_weights[0]=this.m_weights[2]);for(let t=0,e=this.m_description.getTotalComponentCount()-2;t<e;t++)this.m_attributes[t+e]=O(this.m_attributes[t],this.m_attributes[t]=this.m_attributes[t+e]);this.m_cachedValues=null}}isLine(){return!1}isDegenerateToLineHelper(t){const e=R(y,3);this.queryControlPoints(e);const s=e[2].sub(e[0]),i=s.length();if(y.distance(e[0],e[1])+y.distance(e[2],e[1])-i>t)return!1;const n=t,o=e[1].clone();return o.subThis(e[0]),!(Math.abs(o.crossProduct(s))/i>n)}copyIgnoreAttributes(t){const e=R(y,3);this.queryControlPoints(e);const s=[0,0,0];this.queryWeights(s),t.setControlPointsAndWeights(e,s)}calculateArea2DHelper(){return pu(this)}absNorm(){return this.getStartXY().norm(1)+this.getEndXY().norm(1)+this.m_cp.norm(1)}absNormXYZ(t){return b(0),0}queryEnvelopeW(t,e){Og(this,t,e)}setSegmentFromCoordsForStitcher(t,e){const s=[0,0,0];this.queryWeights(s),this.constructWeights(t[0],this.getControlPoint1(),t[e-1],s[0],s[1],s[2])}writeInBufferStream(t,e){const s=new Float64Array(5);return s[0]=this.m_cp.x,s[1]=this.m_cp.y,s[2]=this.m_weights[0],s[3]=this.m_weights[1],s[4]=this.m_weights[2],t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}readFromBufferStream(t,e){const s=new Float64Array(5);t.queryRange(e,s.length,s,!0,1),this.m_cp.x=s[0],this.m_cp.y=s[1],this.m_weights[0]=s[2],this.m_weights[1]=s[3],this.m_weights[2]=s[4],this.m_cachedValues=null}snapControlPoints(t){const e=R(y,3);this.queryControlPoints(e);const s=y.sqrDistance(e[1],e[0]),i=y.sqrDistance(e[1],e[2]);let n=e[0].clone(),o=s;s>i&&(n=e[2].clone(),o=i);let a=!1;return o<=t&&o!==0&&(a=!0,this.setControlPoint1(n)),a}needsSnapControlPoints(t){if(!t)return!1;const e=R(y,3);this.queryControlPoints(e);const s=y.sqrDistance(e[1],e[0]),i=y.sqrDistance(e[1],e[2]);e[0].clone();let n=s;return s>i&&(e[2].clone(),n=i),n<=t&&n!==0}calculateSpecialPointsForCracking(t,e){return 0}ensureXYMonotone(){return Hh(this)}setCoordsForIntersector(t,e,s){K0(this,t,e,s)}copyToImpl(t){const e=t;e.m_cp.setCoordsPoint2D(this.m_cp),e.m_weights[0]=this.m_weights[0],e.m_weights[1]=this.m_weights[1],e.m_weights[2]=this.m_weights[2],Ug(e,fu(this))}reverseImpl(){this.m_weights[2]=O(this.m_weights[0],this.m_weights[0]=this.m_weights[2])}equalsImpl(t){const e=t;if(!this.m_cp.equals(e.m_cp))return!1;for(let s=0;s<3;s++)if(this.m_weights[s]!==e.m_weights[s])return!1;return!0}equalsImplTol(t,e){const s=t;if(!this.m_cp.isEqualPoint2D(s.m_cp,e))return!1;const i=R(y,3);this.queryControlPoints(i);const n=R(y,3);s.queryControlPoints(n);const o=[s.m_weights[0],s.m_weights[1],s.m_weights[2]];for(let a=0;a<3;a++){const h=new mt;h.setCoordsPoint2DZ(i[a].mul(this.m_weights[a]),this.m_weights[a]);const m=new mt;if(m.setCoordsPoint2DZ(n[a].mul(o[a]),o[a]),!h.isEqual(m,e))return!1}return!0}swapImpl(t){const e=t;e.m_cp=O(this.m_cp,this.m_cp=e.m_cp),e.m_weights=O(this.m_weights,this.m_weights=e.m_weights),M0(this,e)}afterCompletedModification(){Bn(this)}intersect(t,e,s,i,n){return en(!1,this,t,e,s,i,n)}intersectPoint(t,e,s){return j0(this,t,e,s)}endPointModified(){Bn(this)}clearEndPointModified(){}setCpsAndWeights(t,e,s,i,n,o){(i<=0||o<=0||n<0)&&H("weights"),(t.isNAN()||e.isNAN()||s.isNAN())&&H("NAN control points in bezier are not supported"),this.setStartXY(t),this.m_cp.assign(e),this.m_weights[0]=i,this.m_weights[1]=n,this.m_weights[2]=o,this.setEndXY(s)}setCpsAndWeightsArray(t,e){this.setCpsAndWeights(t[0],t[1],t[2],e[0],e[1],e[2])}};Ge.type=T.enumRationalBezier2;var Qr=Mt;let Oi=class dg extends Rr{constructor(t){t===void 0||ha(t,"vd")?(super({vd:t?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_cp=new y(0,0)):t.from?(super({XStart:t.from.x,YStart:t.from.y,XEnd:t.to.x,YEnd:t.to.y,...t.vd}),this.m_cp=t.cp.clone()):t.points?(super({XStart:t.points[0].x,YStart:t.points[0].y,XEnd:t.points[2].x,YEnd:t.points[2].y,...t.vd}),this.m_cp=t.points[1].clone()):t.copy?(super(t),this.m_cp=t.copy.m_cp.clone()):$("unexpected constructor args")}getBoundary(){return Gs(this)}assignCopy(t){return this!==t&&t.copyTo(this),this}construct(t,e,s){this.setStartXY(t),this.m_cp.assign(e),this.setEndXY(s),Kr(this)}constructPoints(t){this.setStartXY(t[0]),this.m_cp.assign(t[1]),this.setEndXY(t[2]),Kr(this)}getGeometryType(){return T.enumBezier2}queryEnvelope(t){if(t.m_EnvelopeType!==2)ft("env type not impl");else{if(t.setCoords(this.getStartXY()),t.mergeNe(this.getEndXY()),t.contains(this.m_cp))return;const e=jl(this);if(e!==null){const s=new y;for(const i of e.specialPoints)this.queryCoord2D(i,s),t.mergeNe(s)}else{const s=[];vg(this,s);const i=new y;for(const n of s)this.queryCoord2D(n,i),t.mergeNe(i)}}}applyTransformation(t){if(t.m_TransformationType===1){const e=R(y,3);return this.queryControlPoints(e),t.transformPoints2D(e,3,e),this.setStartXY(e[0]),this.m_cp.assign(e[1]),this.setEndXY(e[2]),void this.afterCompletedModification()}b(0)}createInstance(){return new dg({vd:this.m_description})}calculateLength2D(){return Vo(this,1,!1)}calculateLowerLength2D(){return y.distance(this.getStartXY(),this.getEndXY())}calculateUpperLength2D(){return this.calculateUpperLength2D_()}calculateUpperLength2D_(){return y.distance(this.getStartXY(),this.m_cp)+y.distance(this.getEndXY(),this.m_cp)}queryCoord2D(t,e){this.queryCoord2DExtended(t,e,!1)}queryCoord2DExtended(t,e,s){const i=R(y,3);this.queryControlPoints(i),Is(i,t,e,s)}queryCoord2DE(t,e){Mf(this,t,e)}queryCoord2DMP(t,e){b(!1,"bernstein polynomials not ported")}getCoordX(t){if(t<0||t>1){const e=new y;return this.queryCoord2DExtended(t,e,!0),e.x}if(t<=.5){const e=fe(this.getStartX(),this.m_cp.x,t),s=fe(this.m_cp.x,this.getEndX(),t);return fe(e,s,t)}{const e=ue(this.getStartX(),this.m_cp.x,t),s=ue(this.m_cp.x,this.getEndX(),t);return ue(e,s,t)}}getCoordY(t){if(t<0||t>1){const e=new y;return this.queryCoord2DExtended(t,e,!0),e.y}if(t<=.5){const e=fe(this.getStartX(),this.m_cp.x,t),s=fe(this.m_cp.x,this.getEndX(),t);return fe(e,s,t)}{const e=ue(this.getStartY(),this.m_cp.y,t),s=ue(this.m_cp.y,this.getEndY(),t);return ue(e,s,t)}}cut(t,e,s){const i=new it;return this.queryCut(t,e,i,s),i.releaseSegment()}queryCut(t,e,s,i){const n=s.createQuadraticBezier();if(this.cutBezierIgnoreAttributes(t,e,n),i)return;n.assignVertexDescription(this.m_description);const o=this.m_description.getAttributeCount();if(o>1){for(let a=1;a<o;a++){const h=this.m_description.getSemantics(a),m=Qr.getComponentCount(h);for(let l=0;l<m;l++){const u=this.getAttributeAsDbl(t,h,l);n.setStartAttribute(h,l,u)}}for(let a=1;a<o;a++){const h=this.m_description.getSemantics(a),m=Qr.getComponentCount(h);for(let l=0;l<m;l++){const u=this.getAttributeAsDbl(e,h,l);n.setEndAttribute(h,l,u)}}}}queryDerivative(t,e){Vf(this,t,e)}cutBezierIgnoreAttributes(t,e,s){if((t<0||e>1||t>e)&&H("Quadratic_bezier.cut_bezier_ignore_attributes"),t===0&&e===1)return s.setStartXY(this.getStartXY()),s.m_cp.assign(this.m_cp),void s.setEndXY(this.getEndXY());const i=R(y,3);this.queryControlPoints(i),ur(i,t,e,i),s.constructPoints(i)}splitBezierIgnoreAttributes(t,e,s){b(0)}getAttributeAsDbl(t,e,s){if(e===0)return s===0?this.getCoordX(t):this.getCoordY(t);const i=this.calculateLength2D(),n=i>0?this.tToLength(t)/i:0,o=Qr.getInterpolation(e),a=this.getStartAttributeAsDbl(e,s),h=this.getEndAttributeAsDbl(e,s);return Fr(o,a,h,n,Qr.getDefaultValue(e))}getClosestCoordinate(t,e){return Yo(this,t,z.unit(),e)}getClosestCoordinateOnInterval(t,e,s=-1){return Yo(this,t,e,!1)}getYMonotonicParts(t,e){return this.getMonotonicParts(t,e)}getMonotonicParts(t,e){t.length<2&&H("");const s=Ih(this);let i=0;if(s.specialPointsCount()===2)return 0;b(t.length>=s.specialPointsCount()-1);for(let n=1,o=s.specialPointsCount();n<o;++n)this.queryCut(s.specialPoints[n-1],s.specialPoints[n],t[i],e),i++;for(let n=0;n<i;++n)wh(t[n].get());return i}intersectionWithAxis2D(t,e,s,i){const n=R(L,3),o=R(L,2),a=new z(0,1);let h=0;if(t){if(n[0]=new L(this.getStartY()).sub(e),n[1]=new L(this.m_cp.y).subE(new L(this.getStartY())).mulThisByPower2(2),n[2]=new L(this.getStartY()).add(this.getEndY()).subE(new L(this.m_cp.y).mulThisByPower2(2)),h=$e(n[2],n[1],n[0],a,!1,o),s)for(let m=0;m<h;m++)s[m]=this.getCoordX(o[m].value())}else if(n[0]=new L(this.getStartX()).sub(e),n[1]=new L(this.m_cp.x).subE(new L(this.getStartX())).mulThisByPower2(2),n[2]=new L(this.getStartX()).add(this.getEndX()).subE(new L(this.m_cp.x).mulThisByPower2(2)),h=$e(n[2],n[1],n[0],a,!1,o),s)for(let m=0;m<h;m++)s[m]=this.getCoordY(o[m].value());if(i)for(let m=0;m<h;m++)i[m]=o[m].value();else s&&ch(s,h);return h}intersectionOfYMonotonicWithAxisX(t,e){if(this.m_YStart===this.m_YEnd)return t===this.m_YStart?e:Number.NaN;if(t===this.m_YStart)return this.m_XStart;if(t===this.m_YEnd)return this.m_XEnd;const s=[0,0],i=this.intersectionWithAxis2D(!0,t,s,null);return b(i!==2),i===-1?e:s[0]}isCurve(){return!0}isLine(){return!1}isDegenerate(t){return _a(this,t)}isDegenerate3D(t,e){return b(0),!1}queryLooseEnvelope(t){if(t.m_EnvelopeType===2)return t.setCoords(this.getStartXY()),t.mergeNe(this.m_cp),void t.mergeNe(this.getEndXY());b(0)}clone(t){const e=this.createInstance();return this.copyTo(e),e}queryInterval(t,e){if(t===0){const s=new F;this.queryEnvelope(s);const i=new z;return e===0?s.queryIntervalX(i):s.queryIntervalY(i),i}return super.queryInterval(t,e)}queryLooseEnvelopeOnInterval(t,e){const s=R(y,4);this.queryControlPoints(s),ur(s,t.vmin,t.vmax,s),e.setFromPoints(s,4)}changeEndPoints2D(t,e){if(t.isEqual(this.m_XStart,this.m_YStart)&&e.isEqual(this.m_XEnd,this.m_YEnd))return;const s=this.m_cp.isEqual(this.m_XStart,this.m_YStart),i=this.m_cp.isEqual(this.m_XEnd,this.m_YEnd);this.setStartXY(t),this.setEndXY(e),s?this.m_cp.setCoordsPoint2D(t):i&&this.m_cp.setCoordsPoint2D(e),this.normalizeAfterEndpointChange()}tToLength(t){return Vo(this,t,!0)}lengthToT(t){return Sf(this,t)}calculateWeightedAreaCentroid2D(t){const e=R(y,3);Af(this,e);const s=e[2],i=e[1],n=new y,o=s.y*i.x-s.x*i.y;n.x=-(4*s.x+5*i.x)*o/60,n.y=-(4*s.y+5*i.y)*o/60;const a=$l(this);return n.x+=(e[0].x-t.x)*a,n.y+=(e[0].y-t.y)*a,n}calculateWeightedCentroid2D(){const t=new y;return this.isDegenerate(0)?(t.setCoords(0,0),t):vf(this)?(t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t):(t.assign(wf(this,1)),t)}getControlPoint1(){return this.m_cp.clone()}setControlPoint1(t){this.m_cp.setCoordsPoint2D(t),this.afterCompletedModification()}queryControlPoints(t){t[0].assign(this.getStartXY()),t[1].assign(this.m_cp),t[2].assign(this.getEndXY())}queryControlPointsHelper(t){return this.queryControlPoints(t),3}setControlPoints(t){for(let e=0;e<3;e++)t[e].isNAN()&&H("NaN control points in bezier are not supported");this.m_XStart=t[0].x,this.m_YStart=t[0].y,this.m_cp.setCoordsPoint2D(t[1]),this.m_XEnd=t[2].x,this.m_YEnd=t[2].y,this.afterCompletedModification()}getTangent(t){const e=Nt(t,0,1);let s=Ln(this,1,e);return s.isZero()&&(s=Ln(this,2,e),e===1&&s.negateThis()),s}getDerivative(t){return Ln(this,1,Nt(t,0,1))}getCurvature(t){const e=Ln(this,1,t),s=Ln(this,2,t),i=e.sqrLength();return i===0?Number.NaN:(e.divThis(Math.sqrt(i)),e.crossProduct(s)/i)}isIntersecting(t,e,s){return Gn(!1,this,t,e,s)!==0}isIntersectingPoint(t,e,s){if(s&&(t.isEqualPoint2D(this.getStartXY())||t.isEqualPoint2D(this.getEndXY())))return!1;const i=new F;if(this.queryLooseEnvelope(i),i.inflateCoords(e,e),!i.contains(t))return!1;const n=this.getClosestCoordinate(t,!1),o=new y;return this.queryCoord2D(n,o),y.distance(o,t)<=e}isIntersectingPoint3D(t,e,s,i,n=1){return b(0),!1}isMonotoneQuickAndDirty(){return!1}getMonotonicPartParams(t,e){const s=Ih(this),i=s.specialPointsCount();if(!e)return s.specialPointsCount();t<i&&H("");for(let n=0;n<i;n++)e[n]=s.specialPoints[n];return i}normalizeAfterEndpointChange(){return!1}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){O(this.m_XStart,this.m_XStart=this.m_XEnd),O(this.m_YStart,this.m_YStart=this.m_YEnd);for(let t=0,e=this.m_description.getTotalComponentCount()-2;t<e;t++)this.m_attributes[t+e]=O(this.m_attributes[t],this.m_attributes[t]=this.m_attributes[t+e]);this.m_cachedValues=null}}isDegenerateToLineHelper(t){const e=R(y,3);this.queryControlPoints(e);const s=e[2].sub(e[0]),i=s.length();if(y.distance(e[0],e[1])+y.distance(e[2],e[1])-i>t)return!1;const n=t,o=e[1].clone();return o.subThis(e[0]),!(Math.abs(o.crossProduct(s))/i>n)}copyIgnoreAttributes(t){const e=R(y,3);this.queryControlPoints(e),t.setControlPoints(e)}calculateArea2DHelper(){return $l(this)}absNorm(){return Tf(this)}queryEnvelopeW(t,e){const s=R(y,3);this.queryControlPoints(s),lr(s,t,e)}setSegmentFromCoordsForStitcher(t,e){this.construct(t[0],this.getControlPoint1(),t[e-1])}snapControlPoints(t){return Rf(this,t)}writeInBufferStream(t,e){const s=new Float64Array(2);return s[0]=this.m_cp.x,s[1]=this.m_cp.y,t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}readFromBufferStream(t,e){const s=new Float64Array(2);t.queryRange(e,s.length,s,!0,1),this.m_cp.x=s[0],this.m_cp.y=s[1],this.m_cachedValues=null}needsSnapControlPoints(t){return kf(this,t)}calculateSpecialPointsForCracking(t,e){return 0}ensureXYMonotone(){return wh(this)}setCoordsForIntersector(t,e,s){Df(this,t,e,s)}copyToImpl(t){const e=t;e.m_cp.setCoordsPoint2D(this.m_cp),wg(e,jl(this))}reverseImpl(){}equalsImplTol(t,e){const s=t;return!!this.m_cp.isEqualPoint2D(s.m_cp,e)}equalsImpl(t){const e=t;return!!this.m_cp.equals(e.m_cp)}swapImpl(t){const e=t;e.m_cp=O(this.m_cp,this.m_cp=e.m_cp),Cf(this,e)}afterCompletedModification(){Kr(this)}intersect(t,e,s,i,n){return en(!1,this,t,e,s,i,n)}intersectPoint(t,e,s){return bf(this,t,e.length,e,s)}endPointModified(){Kr(this)}clearEndPointModified(){}};Oi.type=T.enumBezier2;let pg=class{constructor(t){return t.coefsT?(this.m_zeroCtor=t.zeroCtor,this.m_elements=t.coefsT.map(e=>e.clone()),b(this.m_elements.length===t.power+1),void this.updatePower()):t.coef0?(this.m_zeroCtor=t.zeroCtor,void(this.m_elements=[t.coef0.clone()])):t.copy?(this.m_zeroCtor=t.copy.m_zeroCtor,void(this.m_elements=t.copy.m_elements.map(e=>e.clone()))):(this.m_zeroCtor=t.zeroCtor,void(this.m_elements=[new this.m_zeroCtor]))}construct(t,e){return this.m_elements=t.map(s=>s.clone()),this.updatePower(),this}construct0(t){return this.m_elements.length=0,this.m_elements.push(t.clone()),this.updatePower(),this}assignCopy(t){return this.m_elements=t.m_elements.map(e=>e.clone()),this.updatePower(),this}assignMove(t){return this.m_elements=t.m_elements,t.m_elements=[],this.updatePower(),this}power(){return this.m_elements.length-1}addElement(t){this.m_elements.push(t.clone())}scaleRangeToUnitInterval(t,e){const s=e;s.subThis(t);const i=this.power();for(let n=0;n<=i;n++){const o=new this.m_zeroCtor;for(let h=n;h<=i;h++){const m=this.m_elements[h];m.mulDoubleThis(Qd(h,n));const l=t.pow(h-n);m.mulThis(l),o.addThis(m)}const a=s.pow(n);o.mulThis(a),this.m_elements[n]=o}}fmSubThis(t,e){return b(0),this}addThis(t){const e=Math.min(this.power(),t.power());for(let i=0;i<=e;++i)this.m_elements[i].addThis(t.m_elements[i]);const s=t.power();this.m_elements.length=Math.max(this.power(),t.power())+1;for(let i=e+1;i<=s;++i)this.m_elements[i]=t.m_elements[i];return this.updatePower(),this}add0(t){return this.m_elements[0].addThis(t),this.updatePower(),this}addNumber0(t){return b(0),this}sub(t){const e=Math.min(this.power(),t.power());for(let i=0;i<=e;++i)this.m_elements[i].subThis(t.m_elements[i]);const s=t.power();this.m_elements.length=Math.max(this.power(),t.power())+1;for(let i=e+1;i<=s;++i)this.m_elements[i]=t.m_elements[i].clone(),this.m_elements[i].negateThis();return this.updatePower(),this}sub0(t){return b(0),this}subNumber0(t){return b(0),this}subShifted(t,e){const s=this.power(),i=t.power()+e,n=Math.min(this.power(),i);let o=0;for(let a=e;a<=n;++a)this.m_elements[a].subThis(t.m_elements[o]),o++;if(i<=s)return this.updatePower(),this;this.m_elements.length=i+1;for(let a=s+1;a<this.m_elements.length;++a)this.m_elements[a]=new this.m_zeroCtor;for(let a=n+1;a<=i;++a)this.m_elements[a].subThis(t.m_elements[o++]);return this.updatePower(),this}subShiftedWithCoef(t,e,s){const i=this.power(),n=t.power()+s,o=Math.min(this.power(),n);let a=0;for(let h=s;h<=o;++h)this.m_elements[h].fmSubThis(t.m_elements[a],e),a++;if(n<=i)return this.updatePower(),this;this.m_elements.length=n+1;for(let h=i+1;h<this.m_elements.length;++h)this.m_elements[h]=new this.m_zeroCtor;for(let h=o+1;h<=n;++h)this.m_elements[h].fmSubThis(t.m_elements[a++],e);return this.updatePower(),this}mulThis(t){if(this.constructor===t.constructor){const e=t,s=[];for(let i=0,n=this.power();i<=n;i++)for(let o=0,a=e.power();o<=a;o++){const h=this.m_elements[i].clone();h.mulThis(e.m_elements[o]),i+o<s.length?s[i+o].addThis(h):s.push(h)}this.m_elements=s}else for(let e=0,s=this.power();e<=s;e++)this.m_elements[e].mulThis(t);return this.updatePower(),this}mulElementThis(t){for(let e=0,s=this.power();e<=s;e++)this.m_elements[e].mulThis(t);return this.updatePower(),this}mulDoubleThis(t){for(let e=0,s=this.power();e<=s;e++)this.m_elements[e].mulDoubleThis(t);return this.updatePower(),this}mulNumber0(t){return b(0),this}mulBigint0(t){return b(0),this}mulBigIntThis(t){return b(0),this}mulInt320(t){return b(0),this}div0(t){return b(0),this}absThis(){return b(0),this}div(t,e,s){if(this.power()<t.power())return s.assignCopy(this),void e.setZero();s.setZero(),e.setZero();const i=t.getElement(t.power()),n=this.clone();let o=n.power();const a=n.power()-t.power();let h=a;for(e.m_elements=R(e.m_zeroCtor,a+1);;){if(o<t.power()){s.assignMove(n);break}if(o===n.power()){const m=n.getElement(n.power());m.divThis(i),n.subShiftedWithCoef(t,m,n.power()-t.power()),e.m_elements[h]=m.clone()}h--,o--}s.updatePower(),e.updatePower()}divThis(t){return b(0),this}subThis(t){const e=Math.min(this.power(),t.power());for(let i=0;i<=e;++i)this.m_elements[i].subThis(t.m_elements[i]);const s=t.power();this.m_elements.length=Math.max(this.power(),t.power())+1;for(let i=e+1;i<=s;++i)this.m_elements[i]=t.m_elements[i].clone(),this.m_elements[i].negateThis();return this.updatePower(),this}sub0This(t){return this.m_elements[0].subThis(t),this.updatePower(),this}subFrom(t,e){b(0)}isZero(){return this.power()===0&&this.m_elements[0].isZero()}negateThis(){for(let t=this.m_elements.length-1;t>=0;t--)this.m_elements[t].negateThis();return this}getElement(t){return this.m_elements[t].clone()}setElement(t,e){return this.m_elements[t]=e.clone(),this}evaluate(t){const e=this.power(),s=this.m_elements[e].clone();for(let i=e-1;i>=0;--i)s.mulThis(t),s.addThis(this.m_elements[i]);return s}equals(t){if(this===t)return!0;if(this.power()!==t.power())return!1;for(let e=this.m_elements.length-1;e>=0;e--)if(!this.m_elements[e].equals(t.m_elements[e]))return!1;return!0}updatePower(){for(let t=this.m_elements.length-1;t>0&&this.m_elements[t].isZero();t--)this.m_elements.pop();return this}setZero(){return this.m_elements.length=1,this.m_elements[0]=new this.m_zeroCtor,this.updatePower(),this}derivative(t){if(this.power()<t)return this.clone().setZero();if(t===0)return this.clone();const e=new this.constructor({coefsT:this.m_elements.slice(t),power:this.power()-t});for(let s=t,i=this.power();s<=i;s++){let n=BigInt(s);for(let o=s-1,a=s-t;o>a;--o)n*=BigInt(o);e.m_elements[s-t].mulBigIntThis(n)}return e.updatePower(),e}derivative1This(){if(this.m_elements.length>1){this.m_elements=this.m_elements.slice(1);for(let t=1,e=this.power();t<=e;t++)this.m_elements[t].mulThis(J.constructInt32(t+1))}else this.m_elements.length=0,this.m_elements.push(new this.m_zeroCtor);return this}limitPrecisionThis(t){for(let e=this.power();e>=0;--e)this.m_elements[e].limitPrecisionThis(t);return this.updatePower(),this}hiBitIndex(){return this.m_elements.reduce((t,e)=>{const s=e.hiBitIndex();return t<s?s:t},0)}shiftRight(t){return this.m_elements.splice(0,t),this.updatePower(),this}evaluateDerivative(t){const e=this.power(),s=this.m_elements[e];s.mulDoubleThis(e);for(let i=e-1;i>=1;--i){s.mulThis(t);const n=this.m_elements[i];n.mulDoubleThis(i),s.addThis(n)}return s}static evaluateCoefs(t,e,s){const i=t.power();s.construct0(t.getElement(0).evaluate(e));for(let n=1;n<=i;++n)s.addElement(t.getElement(n).evaluate(e));s.updatePower()}},_t=class fg extends pg{constructor(t){super(t===void 0?{zeroCtor:J}:{...t,zeroCtor:J})}clone(){return new fg({copy:this})}absEvaluate(t){const e=this.power(),s=this.m_elements[e].clone();s.absThis();const i=t.clone();i.absThis();for(let n=e-1;n>=0;--n)s.mulThis(i),s.addThis(this.m_elements[n].abs());return s}},Fe=class xg extends pg{constructor(t){super(t===void 0?{zeroCtor:_t}:{...t,zeroCtor:_t})}clone(){return new xg({copy:this})}constructFromMPValues(t,e){this.m_elements.length=0;for(let s=0;s<=e;++s)this.m_elements.push(new _t({coef0:t[s]}));return this.updatePower(),this}};function mf(){return{polypoly1:new Fe,polypoly2:new Fe,polyX2:new _t,polyY2:new _t,polyX2Deriv:new _t,polyY2Deriv:new _t,polypolyX1:new Fe,polypolyY1:new Fe,polypolyX1Deriv:new Fe,polypolyY1Deriv:new Fe,lazyPolypolyD1:new Fe,lazyPolypolyD1Deriv:new Fe,lazyPolyD2:new _t,lazyPolyD2Deriv:null,polypoly11:new Fe,polypoly12:new Fe,tempPp:new Fe,tempPp1:new Fe,tempPp2:new Fe,tempP:new _t,tempP1:new _t,tempP2:new _t}}function Mn(r,t,e,s,i,n,o,a,h,m,l,u,c,g,_,d,p,f,x,E=!1){const P=mf();P.polyX2.construct(o,a),P.polyY2.construct(h,m),P.polypolyX1.constructFromMPValues(r,t),P.polypolyY1.constructFromMPValues(e,s),P.polypoly11.assignCopy(P.polypolyX1),P.polypoly12.assignCopy(P.polypolyY1),l&&(P.lazyPolyD2.construct(l,u),P.polypoly11.mulElementThis(P.lazyPolyD2),P.polypoly12.mulElementThis(P.lazyPolyD2)),i?(P.lazyPolypolyD1.constructFromMPValues(i,n),P.lazyPolypolyD1Deriv=new Fe({copy:P.lazyPolypolyD1}),P.lazyPolypolyD1Deriv.derivative1This(),P.tempPp.assignCopy(P.lazyPolypolyD1),P.tempPp.mulElementThis(P.polyX2),P.polypoly11.subThis(P.tempPp),P.tempPp.assignCopy(P.lazyPolypolyD1),P.tempPp.mulElementThis(P.polyY2),P.polypoly12.subThis(P.tempPp)):(P.polypoly11.sub0This(P.polyX2),P.polypoly12.sub0This(P.polyY2)),P.polypolyX1Deriv.assignCopy(P.polypolyX1),P.polypolyX1Deriv.derivative1This(),P.polypolyY1Deriv.assignCopy(P.polypolyY1),P.polypolyY1Deriv.derivative1This(),i&&(P.polypolyX1Deriv.mulThis(P.lazyPolypolyD1),P.tempPp2.assignCopy(P.lazyPolypolyD1Deriv),P.tempPp2.mulThis(P.polypolyX1),P.polypolyX1Deriv.subThis(P.tempPp2),P.polypolyY1Deriv.mulThis(P.lazyPolypolyD1),P.tempPp2.assignCopy(P.lazyPolypolyD1Deriv),P.tempPp2.mulThis(P.polypolyY1),P.polypolyY1Deriv.subThis(P.tempPp2)),P.polyX2Deriv.assignCopy(P.polyX2),P.polyX2Deriv.derivative1This(),P.polyY2Deriv.assignCopy(P.polyY2),P.polyY2Deriv.derivative1This(),l&&(b(P.lazyPolyD2Deriv===null),P.lazyPolyD2Deriv=new _t({copy:P.lazyPolyD2}),P.lazyPolyD2Deriv.derivative1This(),P.polyX2Deriv.mulThis(P.lazyPolyD2),P.tempP1.assignCopy(P.lazyPolyD2Deriv),P.tempP1.mulThis(P.polyX2),P.polyX2Deriv.subThis(P.tempP1),P.polyY2Deriv.mulThis(P.lazyPolyD2),P.tempP1.assignCopy(P.lazyPolyD2Deriv),P.tempP1.mulThis(P.polyY2),P.polyY2Deriv.subThis(P.tempP1)),P.polypoly1.assignCopy(P.polypoly11),P.polypoly1.mulElementThis(P.polyX2Deriv),P.tempPp.assignCopy(P.polypoly12),P.tempPp.mulElementThis(P.polyY2Deriv),P.polypoly1.addThis(P.tempPp),P.polypoly2.assignCopy(P.polypolyX1Deriv),P.polypoly2.mulElementThis(P.polyY2Deriv),P.tempPp.assignCopy(P.polypolyY1Deriv),P.tempPp.mulElementThis(P.polyX2Deriv),P.polypoly2.subThis(P.tempPp);let C=[];const S=[];p||(p=[]),d||(d=[]),vh(P.polypoly11,P.polypoly12,P.tempP);const I=64,w=bs.ldexp(-59).toDouble(),D=[];let N=qi(P.tempP,c,_,w,I,D,f,f);if(N<0)return-1;for(let q=0;q<N;q++){const V=P.tempP1,k=P.tempP2;_t.evaluateCoefs(P.polypoly11,D[q],V);const Y=pl(V.m_elements,V.power()+1);Y.sort((ot,Gt)=>ot.compare(Gt)),_t.evaluateCoefs(P.polypoly12,D[q],k);const U=pl(k.m_elements,k.power()+1);U.sort((ot,Gt)=>ot.compare(Gt));const X=Y[0],B=Y.at(-1),W=U[0],Z=U.at(-1);B.subThis(X),Z.subThis(W);const gt=B.subThis(Z).GEZ(),at=58,Q=bs.ldexp(-59).toDouble(),rt=[];let nt;if(nt=qi(gt?V:k,c,g,Q,at,rt,f,f),nt<0&&$("mp_curve_proximity"),nt>0){const ot=gt?k:V;for(let Gt=0;Gt<nt;Gt++){let Ot;if(gt){const Jt=P.tempP;_t.evaluateCoefs(P.polypoly12,D[q].addDouble(Number.EPSILON),Jt),Ot=Jt.evaluate(rt[Gt])}else{const Jt=P.tempP;_t.evaluateCoefs(P.polypoly11,D[q].addDouble(Number.EPSILON),Jt),Ot=Jt.evaluate(rt[Gt])}const Ht=ot.evaluateDerivative(rt[Gt]).abs().mulDoubleThis(Number.EPSILON),It=ot.evaluate(rt[Gt]);Ht.addThis(Ot.sub(It).absThis()),Ht.ldexpThis(3),It.absThis(),It.lt(Ht)?S.push(te(rt[Gt].toDouble(),D[q].toDouble())):b(It.gte(Ht))}}}N=S.length,vh(P.polypoly1,P.polypoly2,P.tempP);const A=[];let M=qi(P.tempP,c,_,w,I,A);M<0&&(M=0);for(let q=0;q<M;q++){_t.evaluateCoefs(P.polypoly1,A[q],P.tempP1);const V=[];let k=qi(P.tempP1,c,g,w,I,V);if(k!==0)if(_t.evaluateCoefs(P.polypoly2,A[q],P.tempP2),k<0){if(k=qi(P.tempP2,c,g,w,I,V),k<0)continue;for(let Y=0;Y<k;Y++)C.push(te(V[Y].toDouble(),A[q].toDouble()))}else{const Y=P.tempP2.absEvaluate(bs);Y.mulThis(J.constructDouble(1e-12));for(let U=0;U<k;U++){const X=P.tempP2.evaluate(V[U]);X.absThis(),X.lt(Y)&&C.push(te(V[U].toDouble(),A[q].toDouble()))}}}if(M=C.length,N===0&&M===0)return 0;C=C.concat(S),C.sort((q,V)=>E?Os(q.second,V.second):Os(q.first,V.first));const G=Oc(C,(q,V)=>q.first===V.first&&q.second===V.second);C=C.slice(0,G),d.length=0,p.length=0;for(const q of C)d.push(q.first),p.push(q.second);return b(d.length===p.length),p.length}function lf(r,t,e,s,i,n,o){if(r.power()===0)return r.isZero()?-1:0;const a=r.evaluate(J.constructInt32(1)).isZero();if(r.power()===1){const h=yg(r.getElement(1),r.getElement(0),t,n.at(0));return n[0].limitPrecisionThis(s),h!==1?0:(n[0].limitPrecisionThis(s),1)}return r.power()===2?On(r.getElement(2),r.getElement(1),r.getElement(0),s,t,a,n):r.power()===3?Wn(r.getElement(3),r.getElement(2),r.getElement(1),r.getElement(0),s,t,a,n):r.power()===4?Pg(r.getElement(4),r.getElement(3),r.getElement(2),r.getElement(1),r.getElement(0),s,t,a,n):Eg(r,t,e,s,a,i,n,o)}function uf(){return{polyIntersect:new _t,polyX1:new _t,polyY1:new _t,polyX1Deriv:new _t,polyY1Deriv:new _t,lazyPolyD1:new _t,lazyPolyD1Deriv:new _t,tempP:new _t,tempP1:new _t,tempP2:new _t,polypoly1Proximity:new Fe,polypoly2Proximity:new Fe}}function Nm(r,t,e,s,i,n,o,a,h,m,l,u,c){const g=uf();g.polyX1.construct(r,t),g.polyY1.construct(e,s),g.polyX1Deriv.assignCopy(g.polyX1),g.polyX1Deriv.derivative1This(),g.polyY1Deriv.assignCopy(g.polyY1),g.polyY1Deriv.derivative1This(),g.polyIntersect.assignCopy(g.polyX1),g.polyIntersect.mulThis(g.polyX1),g.polyIntersect.mulElementThis(o[0]),g.tempP.assignCopy(g.polyY1),g.tempP.mulThis(g.polyY1),g.tempP.mulElementThis(o[1]),g.polyIntersect.addThis(g.tempP),i?(g.lazyPolyD1.construct(i,n),g.tempP.assignCopy(g.lazyPolyD1),g.tempP.mulThis(g.lazyPolyD1),g.tempP.mulElementThis(o[2]),g.polyIntersect.addThis(g.tempP)):g.polyIntersect.add0(o[2]);{const I=o[0].clone(),w=I.clone();w.sqrThis();const D=o[1].clone(),N=D.clone();N.sqrThis();const A=o[2].clone(),M=I.clone();M.subThis(D),g.polyX1.construct(r,t),g.polyX1Deriv.assignCopy(g.polyX1),g.polyX1Deriv.derivative1This(),g.polyY1.construct(e,s),g.polyY1Deriv.assignCopy(g.polyY1),g.polyY1Deriv.derivative1This(),g.tempP.assignCopy(g.polyX1),g.tempP.mulThis(g.polyX1),g.tempP.mulElementThis(N),g.tempP.mulElementThis(A),g.polypoly1Proximity.construct0(g.tempP),g.tempP.assignCopy(g.polyX1),g.tempP.mulThis(D.mul(M).mul(A).ldexpThis(1)),g.polypoly1Proximity.addElement(g.tempP),g.tempP.assignCopy(g.polyX1),g.tempP.mulThis(g.polyX1),g.tempP.mulElementThis(I.mul(N)),g.tempP1.assignCopy(g.polyY1),g.tempP1.mulThis(g.polyY1),g.tempP1.mulElementThis(w.mul(D)),g.tempP.addThis(g.tempP1),g.tempP.add0(M.mul(M).mul(A)),g.polypoly1Proximity.addElement(g.tempP),g.tempP.assignCopy(g.polyX1),g.tempP.mulElementThis(M.mul(I).mul(D).ldexpThis(1)),g.polypoly1Proximity.addElement(g.tempP),g.tempP.construct0(I.mul(M).mul(M)),g.polypoly1Proximity.addElement(g.tempP),g.polypoly1Proximity.updatePower(),g.tempP.construct0(Se),g.polypoly2Proximity.construct0(g.tempP),g.tempP.assignCopy(g.polyX1),g.tempP.mulThis(g.polyX1Deriv),g.tempP1.assignCopy(g.polyY1),g.tempP1.mulThis(g.polyY1Deriv),g.tempP.addThis(g.tempP1),g.tempP.mulElementThis(I.mul(D)),g.polypoly2Proximity.addElement(g.tempP),g.tempP.assignCopy(g.polyX1Deriv),g.tempP.mulElementThis(M.mul(I)),g.polypoly2Proximity.addElement(g.tempP),g.polypoly2Proximity.updatePower()}const _=[],d=[];l===null&&(l=[]);let p=2*g.polyIntersect.power()+58;const f=.5*Number.EPSILON,x=[],E=qi(g.polyIntersect,a,h,f,p,x,u,u);if(E<0)return-1;for(const I of x)d.push(I.toDouble());vh(g.polypoly1Proximity,g.polypoly2Proximity,g.tempP),p=2*g.tempP.power()+58,x.length=0;let P=qi(g.tempP,a,h,f,p,x);if(P<0&&(P=0),E===0&&P===0)return 0;for(const I of x)_.push(I.toDouble());const C=_.concat(d);l.length=C.length,ne(l,C,0,0,C.length),Mr(l);const S=Oc(l,(I,w)=>Os(I,w)===0);return l.length=S,l.length}function yg(r,t,e,s){return r.isZero()?t.isZero()?-1:0:(s.setThis(t),s.negateThis(),s.divThis(r),e.isEmpty()||e.containsCoordinate(s.value())?1:0)}function On(r,t,e,s,i,n,o){if(r.isZero())return n?(o[0].setInt32(1),i.containsCoordinate(1)?1:0):yg(t,e,i,o[0]);if(n){let g=2;return o[0].setInt32(1),e.equals(r)?(o[1].setInt32(1),g=1):o[1].setThis(e.div(r)),i.containsCoordinate(o[1].value())||(g=1),i.containsCoordinate(o[0].value())||(g--,o[0].setThis(o[1])),g===2&&o[0].value()>o[1].value()&&(o[1]=O(o[0],o[0]=o[1])),g}const a=t.clone();a.sqrThis();const h=r.clone();if(h.mulThis(e).ldexpThis(2).negateThis().addThis(a),h.LZ())return 0;const m=s+2,l=J.sqrt(h,m),u=l.clone();t.LZ()&&u.negateThis(),u.addThis(t).limitPrecisionThis(m).ldexpThis(-1).negateThis();let c=0;return o[0].setThis(u).divThis(J.constructAssign(r,m)).limitPrecisionThis(s),(i.isEmpty()||i.containsCoordinate(o[0].value()))&&c++,l.isZero()||u.isZero()||(o[c].setThis(e).divThis(u).limitPrecisionThis(s),(i.isEmpty()||i.containsCoordinate(o[c].value()))&&c++,c===2&&o[0].gt(o[1])&&(o[1]=O(o[0],o[0]=o[1]))),c}function Wn(r,t,e,s,i,n,o,a){if(r.isZero())return On(t,e,s,i,n,o,a);const h=(A,M)=>{if(A>0){let G=M+A;for(let q=1;q<G;q++)a[q].equals(a[0])&&(a[G-1]=O(a[q],a[q]=a[G-1]),G--);M=G}return Vs(a,0,M,(G,q)=>G.compare(q)),M};if(s.isZero()){let A=0;return n.containsCoordinate(0)&&(a[0].setInt32(0),A=1),h(On(r,t,e,i,n,o,a.slice(1)),A)}if(o){let A=0;n.containsCoordinate(1)&&(a[0].setInt32(1),A=1);const M=t.add(r),G=s.negate(),q=r.add(M).add(G).isZero();return h(On(r,M,G,i,n,q,a.slice(A)),A)}const m=new J,l=new J,u=new J,c=t.clone();if(c.isZero())l.setThis(e),l.divThis(r),u.setThis(s),u.divThis(r);else{c.divThis(r).divDoubleThis(3).negateThis();const A=t.clone();A.sqrThis();const M=r.clone();M.sqrThis(),l.setThis(r),l.mulThis(e).mulDoubleThis(3).subThis(A).divThis(M).divDoubleThis(3),u.setThis(A),u.mulThis(t),u.ldexpThis(1),m.setThis(r),m.mulThis(t).mulThis(e).mulDoubleThis(9),u.subThis(m),m.setThis(M),m.mulThis(s).mulDoubleThis(27),u.addThis(m),u.divThis(M).divThis(r).divDoubleThis(27)}if(l.isZero()){const A=u.clone();return A.negateThis(),A.isZero()?(a[0].setThis(c),kn(n,i,a,1)):(a[0].setThis(J.cubicRoot(A,i).add(c)),kn(n,i,a,1))}const g=u.clone();if(g.sqrThis().ldexpThis(-2),m.setThis(l.clone()),m.sqrThis().mulThis(l).divDoubleThis(27),g.addThis(m),g.isZero())return a[0].setThis(u),a[0].mulDoubleThis(3).divThis(l),a[1].setThis(a[0]),a[1].negateThis(),a[1].ldexpThis(-1),a[0].addThis(c),a[1].addThis(c),kn(n,i,a,2);if(g.GZ())return g.setThis(J.sqrt(g,i+8)),m.setThis(u),m.ldexpThis(-1).negateThis(),m.addThis(g),a[0].setThis(J.cubicRoot(m,i+8)),m.setThis(u),m.ldexpThis(-1).negateThis(),m.subThis(g),a[0].addThis(J.cubicRoot(m,i+8)),a[0].addThis(c),kn(n,i,a,1);m.setThis(l),m.divDoubleThis(3).negateThis(),b(m.GEZ());const _=J.sqrt(m,i+8),d=_.clone();d.negateThis(),d.addThis(c),_.addThis(c);const p=J.constructDouble(n.isEmpty()?-Number.MAX_VALUE:n.vmin),f=J.constructDouble(n.isEmpty()?Number.MAX_VALUE:n.vmax),x=new _t({zeroCtor:J});x.construct0(s),x.addElement(e),x.addElement(t),x.addElement(r);const E=new _t({copy:x});E.derivative1This();let P=0;const C=R(J,4);C[P++].setThis(p),d.gt(p)&&d.lt(f)&&C[P++].setThis(d),_.gt(p)&&_.lt(f)&&C[P++].setThis(_),C[P++].setThis(f);const S=3*i;let I=52,w=Number.EPSILON;for(;I<S;)2*I<=S?(w*=w,I*=2):(w*=Number.EPSILON,I+=52);I+=2;let D=0,N=!1;for(let A=1;A<P;A++)if(bh(x,E,C[A-1],C[A],w,I,a[0])){D=1,N=A+1<P;break}if(!D)return 0;if(N){const A=new _t({zeroCtor:J,coef0:a[0]});A.negateThis(),A.addElement(bs);const M=new _t({zeroCtor:J}),G=new _t({zeroCtor:J});x.div(A,M,G),b(M.power()===2),b(G.power()===0);const q=On(M.getElement(2),M.getElement(1),M.getElement(0),i,n,!1,a.slice(1));b(q>=0&&q<=2),D+=q}return kn(n,i,a,D)}function Pg(r,t,e,s,i,n,o,a,h){if(r.isZero())return Wn(t,e,s,i,n,o,a,h);const m=(d,p)=>{if(d>0){let f=p+d;for(let x=1;x<f;x++)h[x].equals(h[0])&&(h[f-1]=O(h[x],h[x]=h[f-1]),f--);p=f}return Vs(h,0,p,(f,x)=>f.compare(x)),p};if(i.isZero()){let d=0;return o.containsCoordinate(0)&&(h[0].setInt32(0),d=1),m(Wn(r,t,e,s,n,o,a,h.slice(d)),d)}const l=new _t({zeroCtor:J,coef0:i});if(l.addElement(s),l.addElement(e),l.addElement(t),l.addElement(r),a){let d=0;o.containsCoordinate(1)&&(h[0].setInt32(1),d=1);const p=new _t({zeroCtor:J,coef0:J.constructInt32(-1)});p.addElement(J.constructInt32(1));const f=new _t({zeroCtor:J}),x=new _t({zeroCtor:J});return l.div(p,f,x),m(Wn(f.power()===3?f.getElement(3):Se.clone(),f.power()>=2?f.getElement(2):Se.clone(),f.power()>=1?f.getElement(1):Se.clone(),f.getElement(0),n,o,f.evaluate(bs).isZero(),h.slice(d)),d)}if(l.getElement(0).isZero()){let d=0;for(o.containsCoordinate(0)&&(d=1,h[0].setDouble(0));l.getElement(0).isZero()&&l.power()>0;)l.shiftRight(1);const p=Wn(l.power()===3?l.getElement(3):Se.clone(),l.power()>=2?l.getElement(2):Se.clone(),l.power()>=1?l.getElement(1):Se.clone(),l.getElement(0),n,o,!1,h.slice(d));return p>0&&(d+=p),Vs(h,0,d,(f,x)=>f.compare(x)),d}let u=52,c=Number.EPSILON;for(;u<n;)2*u<=n?(c*=c,u*=2):(c*=Number.EPSILON,u+=52);u+=2;const g=Sg(l),_=J.constructDouble(Math.max(Math.abs(o.vmax),Math.abs(o.vmin)));return c=(g.lt(_)?g:_).mul(J.constructDouble(c)).toDouble(),Eg(l,o,c,u,a,!1,h,4)}function cf(r,t){let e=r,s=t;s.power()>e.power()&&(s=O(e,e=s));const i=e.power()-s.power(),n=new _t({copy:e.getElement(e.power())});e.mulThis(s.getElement(s.power()));for(let o=0,a=e.power();o<a;o++)if(o>=i){const h=new _t({copy:s.getElement(o-i)});h.mulThis(n);const m=e.getElement(o).sub(h);e.setElement(o,m)}e.setElement(e.power(),e.getElement(e.power()).setZero()),e.updatePower(),Sh(e)}function Sh(r){let t=0;for(;t<r.power()&&r.getElement(t).isZero();)t++;return t>0&&(r.shiftRight(t),!0)}function vh(r,t,e){const s=r.clone(),i=t.clone();for(Sh(s),Sh(i);s.power()!==0||i.power()!==0;)cf(s,i);e.assignMove(s.getElement(0))}function qi(r,t,e,s,i,n,o=!1,a=!1){n.length=0;const h=r.power(),m=R(J,2*h+4),l=lf(r,e||z.unit(),s,i,!1,m,m.length);if(l>0){n.length=0;for(let u=0;u<l;u++){const c=m[u];u>0&&c.lte(n.at(-1))||n.push(c.clone())}return n.length}return l}function Cg(r,t,e){if(b(e>=1),r.power()===0)return r.isZero()?-1:0;const s=r.getElement(0);return s.negateThis(),s.divThis(r.getElement(1)),t[0].setThis(s),1}function gf(r,t,e,s){if(r.power()<2)return Cg(r,e,s);b(s>=1);let i=r.getElement(1);i.mulThis(r.getElement(1));const n=r.getElement(0);if(n.mulThis(r.getElement(2)),n.ldexpThis(2),i.subThis(n),i.LZ())return 0;if(i.isZero()){const m=r.getElement(1);return m.negateThis(),m.divThis(r.getElement(2)),m.ldexpThis(-1),m.limitPrecisionThis(t),e[0].setThis(m),1}b(s>=2),i=J.sqrt(i,t+8);const o=r.getElement(1);o.negateThis();const a=o.clone();a.subThis(i),a.divThis(r.getElement(2)),a.ldexpThis(-1),a.limitPrecisionThis(t);const h=o.clone();return h.addThis(i),h.divThis(r.getElement(2)),h.ldexpThis(-1),h.limitPrecisionThis(t),a.lt(h)?(e[0].setThis(a),e[1].setThis(h)):(e[1].setThis(a),e[0].setThis(h)),2}function bh(r,t,e,s,i,n,o){let a=e.clone(),h=s.clone();a.limitPrecisionThis(n),h.limitPrecisionThis(n);let m=r.evaluate(a);m.limitPrecisionThis(n+2);let l=r.evaluate(h);if(l.limitPrecisionThis(n+2),m.GEZ()&&l.GEZ()||m.LEZ()&&l.LEZ())return m.absLessAbs(l)?(o=a,m.isZero()):(o=h,l.isZero());const u=l.LZ();u&&(l=O(m,m=l),h=O(a,a=h));const c=u?h:a,g=u?a:h,_=a.add(h).ldexpThis(-1);_.limitPrecisionThis(n);const d=h.sub(a);d.limitPrecisionThis(n),d.absThis();const p=d.clone();let f=r.evaluate(_),x=t.evaluate(_);const E=new _t({copy:r}),P=new _t({copy:t});{const U=Math.max(r.hiBitIndex(),t.hiBitIndex()),X=bs.clone();X.ldexpThis(-(n+2));for(let B=64;B<U;){E.limitPrecisionThis(B),P.limitPrecisionThis(B);const W=E.evaluate(_),Z=P.evaluate(_),gt=W.sub(f),at=Z.sub(x);if(gt.divThis(f).absThis().lt(X)&&(x.isZero()||at.divThis(x).absThis().lt(X)))break;E.assignCopy(r),P.assignCopy(t),B=Math.min(B+64,U)}f.limitPrecisionThis(n+2),x.limitPrecisionThis(n+2)}const C=1,S=4;let I=S;const w=2;let D=1,N=0,A=0,M=C;const G=32,q=J.constructDouble(.25*i),V=J.constructDouble(.5001);let k=0;const Y=300;for(;++k<Y;){if(k>G&&N>0||x.isZero()||M===w&&N>1||M===C&&I<S)M=C,D>1&&D--;else if(M=w,A>1){const Z=d.mul(x);Z.absThis(),Z.ldexpThis(-3),Z.absLessAbs(f)&&D++}d.setThis(p);const U=new J;let X=!1;if(M===C)do{if(A>2){const Z=d.clone();if(Z.absThis(),Z.ldexpThis(4),g.sub(c).ldexpThis(-1).gt(Z)){if(_.equals(c)){U.setThis(_),_.setThis(c.add(Z)),_.limitPrecisionThis(n),p.setThis(_.sub(U));break}if(_.equals(g)){U.setThis(_),_.setThis(g.sub(Z)),_.limitPrecisionThis(n),p.setThis(_.sub(U));break}}}p.setThis(h.sub(a)),p.ldexpThis(-1),p.limitPrecisionThis(n),U.setThis(_),_.setThis(a.add(p)),_.limitPrecisionThis(n),_.lt(c)?_.setThis(c):_.gt(g)&&_.setThis(g),X=a.equals(_)||h.equals(_)}while(!1);else for(;;){if(p.setThis(f.div(x)),p.limitPrecisionThis(n),D!==1&&p.mulDoubleThis(D),U.setThis(_),_.subThis(p),_.limitPrecisionThis(n),X=_.equals(U),_.lt(c)){if(D>1){_.setThis(U),D--;continue}p.setThis(U.sub(c)),_.setThis(c)}else if(_.gt(g)){if(D>1){_.setThis(U),D--;continue}p.setThis(U.sub(g)),_.setThis(g)}break}if(X||p.absLessAbs(q)){U.equals(_)||(f=E.evaluate(_),f.limitPrecisionThis(n+2));break}f=E.evaluate(_),f.limitPrecisionThis(n+2),x=P.evaluate(_),x.limitPrecisionThis(n+2);const B=a.clone(),W=h.clone();f.LZ()?(m.setThis(f),a.setThis(_)):(l.setThis(f),h.setThis(_)),M===w&&(a.equals(B)&&h.equals(W)||A>1&&!p.absLessAbs(V.mul(d)))?N++:N=0,M===C?(I++,A=0):(I=0,A++)}return k>=Y&&$("Root_finder iterations exceeded"),o.setThis(_),!0}function _f(r,t,e,s,i){const n=r.evaluate(e);if(n.isZero())return!0;const o=J.constructDouble(.5*s),a=e.clone();a.subThis(o);const h=r.evaluate(a),m=e.clone();m.addThis(o);const l=r.evaluate(m);if(h.LZ()&&l.GZ()||h.GZ()&&l.LZ()||(n.GZ()?h.LEZ()||l.LEZ():h.GEZ()||l.GEZ()))return!0;const u=h.LEZ()&&l.LEZ(),c=h.GEZ()&&l.GEZ();let g=!1;return u?n.gt(h)&&n.gt(l)&&(g=!0):c&&n.lt(h)&&n.lt(l)&&(g=!0),!!g&&n.absThis().lt(J.constructDouble(1e-17))}function Eg(r,t,e,s,i,n,o,a){b(e>0),b(a>=r.power());const h=o,m=[];let l=[];const u=new _t({zeroCtor:r.m_zeroCtor}),c=new _t({zeroCtor:r.m_zeroCtor}),g=new _t({zeroCtor:r.m_zeroCtor}),_=J.constructDouble(e),d=J.constructDouble(t.vmin),p=J.constructDouble(t.vmax),f=d.sub(_),x=p.add(_),E=Sg(r),P=E.clone();if(P.negateThis(),f.lt(P))f.setThis(P.sub(_));else if(f.gt(E))return 0;if(x.gt(E))x.setThis(E.add(_));else if(x.lt(P))return 0;let C=r,S=null;if(i){const V=new _t({coef0:J.constructInt32(-1)});V.addElement(bs),S=new _t,C=S;const k=new _t,Y=new _t;for(r.div(V,k,Y),S.assignCopy(k);C.evaluate(bs).isZero();)C.div(V,k,Y),S.assignCopy(k)}let I=!1;if(C.power()>0&&C.getElement(0).isZero())for(I=!0,S||(S=new _t({copy:C}),C=S);C.getElement(0).isZero();)S.shiftRight(1);let w=s+2*C.power()+2,D=e/Math.pow(2,C.power()+2),N=w;if(Se.gt(f)&&Se.lt(x)){for(let V=0,k=C.power();V<k;V++)if(C.getElement(V).isZero()){m.push(Se.clone());break}}for(let V=C.power()-1;V>0;V--)if(D*=2,w-=2,N-=2,C.power()-V!==1)if(C.power()-V!==2){c.assignMove(g),g.assignMove(C.derivative(V-1));let k=[];for(let Y=0,U=l.length;Y<U;++Y)if(l[Y].first.lte(l[Y].second)){const X=new J;if(bh(c,u,l[Y].first,l[Y].second,D,w,X)){m.push(X);let B=X.sub(_);B.limitPrecisionThis(N),k.push(te(l[Y].first,B)),B=X.add(_),B.limitPrecisionThis(N),k.push(te(B,l[Y].second))}else k.push(l[Y])}l=k,k=[],u.assignMove(c)}else{c.assignMove(C.derivative(V));const k=gf(c,w,h,a);b(k>=0&&k<=2);for(let Y=0;Y<k;Y++)h[Y].gt(f)&&h[Y].lt(x)&&!h[Y].isZero()&&m.push(h[Y].clone());if(m.length>1&&m.sort((Y,U)=>Y.compare(U)),m.length>0){let Y=m[0].sub(_);Y.limitPrecisionThis(N),l.push(te(f.clone(),Y));let U=m.length===1?x.clone():m[1].sub(_);Y=m[0].add(_),Y.limitPrecisionThis(N),U.limitPrecisionThis(N),l.push(te(Y,U)),m.length>1&&(U=m.length===2?x.clone():m[2].sub(_),U.limitPrecisionThis(N),Y=m[1].add(_),Y.limitPrecisionThis(N),l.push(te(Y,U)),m.length>2&&(Y=m[2].add(_),Y.limitPrecisionThis(N),l.push(te(Y,x.clone()))))}else l.push(te(f.clone(),x.clone()));u.assignCopy(c),g.assignMove(C.derivative(V-1))}else c.assignMove(C.derivative(V)),Cg(c,h,a)===1&&(h[0].gt(f)&&h[0].lt(x)&&!h[0].isZero()&&m.push(h[0].clone()),u.assignMove(c),g.assignMove(C.derivative(V-1)));m.sort((V,k)=>V.compare(k)),l.length===0&&(u.assignMove(C.derivative(C.power())),u.isZero()||l.push(te(f.clone(),x.clone())));let A=0,M=0,G=0;const q=new J;for(;;){if(M<l.length){if(l[M].first.gt(l[M].second)){M++;continue}let V=!1;if(G<m.length&&m[G].lt(l[M].first)&&(V=!0),!V){bh(C,u,l[M].first,l[M].second,e,s,q)&&(q.lt(d)?h[A++].setThis(d):q.gt(p)?h[A++].setThis(p):h[A++].setThis(q)),M++;continue}}if(!(G<m.length))break;G!==0&&m[G-1].equals(m[G])||_f(C,u,m[G],e)&&(q.setThis(m[G]),q.lt(d)?q.setThis(d):q.gt(p)&&q.setThis(p),A!==0&&h[A].equals(q)||h[A++].setThis(q)),G++}return I&&Se.gt(f)&&Se.lt(x)&&(h[A++].setThis(Se),Vs(h,0,A,(V,k)=>V.compare(k))),i&&bs.gt(f)&&bs.lt(x)&&(h[A++].setThis(bs),Vs(h,0,A,(V,k)=>V.compare(k))),A}function Sg(r){const t=r.getElement(r.power());t.limitPrecisionThis(53),t.absThis();const e=Se.clone();for(let s=0,i=r.power();s<i;s++){const n=r.getElement(s);n.limitPrecisionThis(53),n.gt(e)&&e.setThis(n)}return e.divThis(t),e.addThis(bs),e.mulThis(J.constructDouble(1+100*Number.EPSILON)),e}function kn(r,t,e,s){let i=s;if(!r.isEmpty()){i=0;for(let n=0;n<s;++n)r.containsCoordinate(e[n].value())&&(i!==n&&e[i].setThis(e[n]),i++)}i>1&&(e[0].gt(e[1])&&(e[1]=O(e[0],e[0]=e[1])),i>2&&(e[0].gt(e[2])&&(e[2]=O(e[0],e[0]=e[2])),e[1].gt(e[2])&&(e[2]=O(e[1],e[1]=e[2]))));for(let n=0;n<i;++n)e[n].limitPrecisionThis(t);return i}function Cn(r,t,e,s,i,n){return ff(r,t,e,n,s,i)}function df(r,t,e,s,i,n){let o=i;if(s)return n[0]=1,o=.5*(t-r)*(e(r)+e(t)),o;const a=n[0],h=(t-r)/a,m=r,l=new Ce(0);for(let u=1;u<=n[0];++u){const c=(u-.5)*h;l.add(e(m+c))}return o=.5*(o+(t-r)*l.getResult()/a),n[0]*=2,o}function pf(r,t,e,s,i,n,o){let a=0,h=Math.abs(i-e[r]);const m=j(t,Number.NaN),l=j(t,Number.NaN);for(let _=0;_<t;++_){const d=Math.abs(i-e[r+_]);d<h&&(a=_,h=d),m[_]=s[r+_],l[_]=s[r+_]}let u=0,c=0,g=0;n[0]=s[r+a],a--;for(let _=1;_<t;_++){for(let d=0;d<t-_;d++){if(c=e[r+d]-i,g=e[r+d+_]-i,u=c-g,u===0)return!1;const p=(m[d+1]-l[d])/u;m[d]=c*p,l[d]=g*p}if(2*(a+1)<t-_){const d=a+1;o[0]=m[d]}else{const d=a;o[0]=l[d],a--}n[0]+=o[0]}return!0}function ff(r,t,e,s,i,n){if(e<t&&H("xTo < xFrom"),e===t)return 0;const o=[0];let a=Number.MAX_VALUE;const h=[Number.MAX_VALUE];let m=0;const l=32,u=j(l+1,Number.NaN),c=j(l+1,Number.NaN),g=[0];u[0]=1;let _=0,d=0;for(let p=0;p<l;p++){if(m=df(t,e,s,p===0,m,g),c[p]=m,p+1>=r){pf(p+1-r,r,u,c,0,o,h)||$("polynomial_interpolation");const f=i*Math.abs(o[0])+n,x=Math.abs(a-o[0]);if(x<=f&&Math.abs(h[0])<=f){if(_++,_>1&&(x<=.1*d||d===0||_>2))return o[0]}else _=0;d=x,a=o[0]}c[p+1]=c[p],u[p+1]=.25*u[p]}return o[0]}let xf=class{constructor(){this.area=Number.NaN,this.centroid_x=Number.NaN,this.centroid_y=0,this.specialPoints=[],this.specialPointsLength=[]}specialPointsCount(){return this.specialPoints.length}},yf=class{constructor(t,e){this.b=t,this.len=e}getMaxDerivative(){return 1}getValue(t,e){return t===0?this.len-Vo(this.b,e,!1):0}getError(t){return b(0),0}};function Pf(r,t,e,s,i){let n=!0;const o=R(y,3);r.queryControlPoints(o);let a=n?0:1,h=o[1][a]-o[0][a],m=o[2][a]-o[0][a];const l=Cn(5,t,e,s,i,c=>{let g;if(c<=.5){const _=fe(0,h,c),d=fe(h,m,c);g=fe(_,d,c)}else{const _=ue(0,h,c),d=ue(h,m,c);g=ue(_,d,c)}return g*mr(o,1,c).length()});n=!1,a=n?0:1,h=o[1][a]-o[0][a],m=o[2][a]-o[0][a];const u=Cn(5,t,e,s,i,c=>{let g;if(c<=.5){const _=fe(0,h,c),d=fe(h,m,c);g=fe(_,d,c)}else{const _=ue(0,h,c),d=ue(h,m,c);g=ue(_,d,c)}return g*mr(o,1,c).length()});return new y(l,u)}function Kr(r){r.m_cachedValues=null}function Cf(r,t){t.m_cachedValues=O(r.m_cachedValues,r.m_cachedValues=t.m_cachedValues)}function Ih(r){if(r.m_cachedValues)return r.m_cachedValues;const t=new xf;return vg(r,t.specialPoints),wg(r,t),t}function vg(r,t){const e=R(y,3);r.queryControlPoints(e);const s=R(L,8);s[0].set(0);let i=1;{const n=R(L,3);qf(e,n,!1);const o=R(L,2),a=new z(0,1);let h=hr(n[2].mul(2),n[1],a,o[0]);h<0&&(h=0);for(let m=0;m<h;m++)qt(o[m].value(),0,1)||(s[i]=o[m],i++)}{const n=R(L,3);Ff(e,n,!1);const o=R(L,2),a=new z(0,1);let h=hr(n[2].mul(2),n[1],a,o[0]);h<0&&(h=0);for(let m=0;m<h;m++)qt(o[m].value(),0,1)||(s[i]=o[m],i++)}if(s[i].set(1),i++,i>2){Vs(s,0,i,(h,m)=>h.value()-m.value());let n=0,o=s[0].value(),a=1;for(let h=1;h<i;h++)s[h].eq(s[h-1])?(o+=s[h].value(),a++):(a>1&&(o/=a,s[n].set(o)),n++,s[n]=s[h],o=s[h].value(),a=1);n++,i=n}s[0].set(0),s[i-1].set(1),t.length=i;for(let n=0;n<i;n++)t[n]=s[n].value()}function Vo(r,t,e){const s=R(y,3);return r.queryControlPoints(s),bg(s,t,e)}function bg(r,t,e){if(e){if(t<0)return t;if(t>1)return t-1+bg(r,1,!1)}if(t===1)return Ol(r);const s=R(y,3);return Dh(r,t,s,null),Ol(s)}function Ol(r){if(r[0].equals(r[1]))return y.distance(r[2],r[0]);if(r[1].equals(r[2]))return y.distance(r[0],r[2]);const t=y.distance(r[0],r[1])+y.distance(r[2],r[1]),e=y.distance(r[0],r[2]);if(t-e<=t*Number.EPSILON)return e;const s=1,i=R(y,3);qm(r,i,!0);const n=4*(yt(i[2].x)+yt(i[2].y)),o=2*(i[2].x*i[1].x+i[2].y*i[1].y),a=yt(i[1].x)+yt(i[1].y);if(1e-14*(Math.abs(o)+Math.abs(a))>=Math.abs(n))return 1e-14*Math.abs(a)>=Math.abs(o)?Math.sqrt(a)*s:2/(3*o)*(Math.pow(o*s+a,1.5)-Math.pow(a,1.5));const h=o/n,m=a/n,l=m-h*h,u=s+h;if(l===0)return h>=0&&u>=0||h<=0&&u<=0?Math.abs(.5*Math.sqrt(n)*(u*u-h*h)):.5*Math.sqrt(n)*(u*u+h*h);const c=Math.sqrt(l+u*u),g=Math.sqrt(m);return .5*Math.sqrt(n)*(u*c-h*g+l*Math.log(Math.abs((u+c)/(h+g))))}function Wl(r,t){const e=Nt(t,0,1);let s=mr(r,1,e);return s.isZero()&&(s=mr(r,2,e)),s}function Ln(r,t,e){const s=R(y,3);return r.queryControlPoints(s),mr(s,t,e)}function mr(r,t,e){if(t===1){const s=r[1].sub(r[0]).mul(1-e).add(r[2].sub(r[1]).mul(e));return s.mulThis(2),s}return t===2?r[2].sub(r[1]).sub(r[1].sub(r[0]).mul(2)):y.construct(0,0)}function Ef(r,t,e){{const s=K.constructPoint2D(r[1]).subE(K.constructPoint2D(r[0])),i=new L(1).subE(e),n=K.constructPoint2D(r[2]).subE(K.constructPoint2D(r[1])),o=s.mulE(i).addE(n.mulE(e));return o.mulThisE(new L(2)),o}}function Sf(r,t,e){const s=Vo(r,1,!1);if(t<=0)return t;if(t>=s)return t-s+1;const i=[0];return Ti(new yf(r,t),z.unit(),1,i)!==1&&$(""),i[0]}function $l(r){const t=R(y,3);return r.queryControlPoints(t),Ig(t)}function Ig(r){return-r[1].sub(r[0]).crossProduct(r[2].sub(r[0]))/3}function vf(r){const t=y.distance(r.getStartXY(),r.getEndXY()),e=r.calculateUpperLength2D();return e-t<=8*Number.EPSILON*e}function jl(r){return r.m_cachedValues}function wg(r,t){r.m_cachedValues=t}function Yo(r,t,e,s,i){tr(z.unit().contains(e),"QuadraticBezierHelper::getClosestCoordinateSegment");const n=R(y,3);r.queryControlPoints(n);let o=Number.MAX_VALUE;const a=[0],h=pa(n,t,a);if(e.containsCoordinate(a[0]))o=y.distance(t,h);else{a[0]=e.vmin,Is(n,a[0],h),o=y.distance(h,t);const m=new y;Is(n,e.vmax,m);const l=y.distance(m,t);o>l&&(h.setCoordsPoint2D(m),a[0]=e.vmax,o=l)}if(!s)return a[0];if(e.vmin<=0){const m=new y;r.queryCoord2DExtended(-1,m,!0);const l=new y;r.queryCoord2D(e.vmin,l);const u=new ht({start:m,end:l}),c=u.getClosestCoordinate(t,!0);if(c<1){const g=u.getCoord2D(c),_=y.distance(g,t);_<o&&(o=_,a[0]=c-1,h.assign(g))}}if(e.vmin>=1){const m=new y;r.queryCoord2DExtended(2,m,!0);const l=new y;r.queryCoord2D(e.vmax,l);const u=new ht({start:l,end:m}),c=u.getClosestCoordinate(t,!0);if(c>0){const g=u.getCoord2D(c),_=y.distance(g,t);_<o&&(o=_,a[0]=1+c,h.assign(g))}}return a[0]}function pa(r,t,e){const s=r[2].sub(r[1]).sub(r[1].sub(r[0])),i=r[1].sub(r[0]),n=r[0].sub(t),o=n.dotProduct(i),a=n.dotProduct(s)+2*i.dotProduct(i),h=3*i.dotProduct(s),m=s.dotProduct(s),l=j(3,Number.NaN),u=ug(m,h,a,o,z.unit(),!1,l),c=r[0].clone();let g=0,_=y.sqrDistance(r[0],t),d=y.sqrDistance(r[2],t);d<_&&(g=1,c.assign(r[2]),_=d);for(let p=0;p<u;p++){const f=new y;Is(r,l[p],f),d=y.sqrDistance(f,t),d<_&&(_=d,c.assign(f),g=l[p])}return e&&(e[0]=g),c}function bf(r,t,e,s,i,n){const o=new ce;if(If(r,z.unit(),o),o.inflate(i),!o.isIntersectingPoint2D(t))return 0;const a=new y,h=Yo(r,t,z.unit(),!1);return r.queryCoord2D(h,a),y.distance(a,t)<=i?(s&&(s[0]=h),1):0}function If(r,t,e){const s=R(y,3);r.queryControlPoints(s),lr(s,t,e)}function lr(r,t,e){if(t.equalsRange(0,1))return void e.setFromPoints(r,3);const s=R(y,3);ur(r,t.vmin,t.vmax,s),e.setFromPoints(s,3)}function Zl(r,t,e){e.setEmpty();const s=[];s.push(new z(0,1));const i=.5*Math.max(t.width(),t.height());for(;s.length;){const n=s.at(-1);s.pop();const o=new ce;if(lr(r,n,o),o.isIntersectingW(t)){const a=Math.max(o.width(),o.height());if(t.containsW(o)||a<=i||n.width()<1e-12)e.merge(n);else{const h=n.getCenter();s.push(z.construct(n.vmin,h)),s.push(z.construct(h,n.vmax))}}}}function wh(r){const t=R(y,3);r.queryControlPoints(t);const e=Dg(t);return e&&(r.m_cp.setCoordsPoint2D(t[1]),r.afterCompletedModification()),e}function Dg(r){let t=!1;for(let e=0;e<2;e++){const s=Vt(r[0][e],r[2][e]);s>0?(Vt(r[0][e],r[1][e])<0&&(r[1][e]=r[0][e],t=!0),Vt(r[1][e],r[2][e])<0&&(r[1][e]=r[2][e],t=!0)):s<0?(Vt(r[0][e],r[1][e])>0&&(r[1][e]=r[0][e],t=!0),Vt(r[1][e],r[2][e])>0&&(r[1][e]=r[2][e],t=!0)):r[1][e]!==r[0][e]&&(r[1][e]=r[0][e],t=!0)}return t}function wf(r,t,e){e===void 0&&(e=t,t=0);const s=new y;if(t<0||e>1)return s.setNAN(),s;if(t>e&&H("calculate_sub_weighted_centroid"),t===e||r.isDegenerate(0))return s.setCoords(0,0),s;const i=Ih(r),n=si(r),o=Math.min(n/r.calculateUpperLength2D(),1e-7);let a=t,h=0;for(let m=1,l=i.specialPointsCount();m<l;m++)if(t<i.specialPoints[m]){h=m-1;break}s.setCoords(0,0);for(let m=h+1,l=i.specialPointsCount();m<l;m++){const u=Math.min(i.specialPoints[m],e),c=Pf(r,a,u,o,n);if(s.addThis(c),a=u,e<=i.specialPoints[m])break}return s.add(r.getStartXY().mul(r.calculateLength2D()))}function Dh(r,t,e,s){new y().setCoordsPoint2D(r[0]),new y().setCoordsPoint2D(r[1]),new y().setCoordsPoint2D(r[2]);const i=new y,n=new y,o=new y;if(Qt(r[0],r[1],t,i),Qt(r[1],r[2],t,n),Qt(i,n,t,o),e&&(e[0].assign(r[0]),e[1].assign(i),e[2].assign(o)),s){const a=r[2];s[0].assign(o),s[1].assign(n),s[2].assign(a)}}function ur(r,t,e,s){if(t===e){const n=new y;return Is(r,t,n),s[0]=n,s[1]=n,void(s[2]=n)}const i=R(y,3);Dh(r,e,i,null),Dh(i,t/e,null,i),Is(r,t,i[0]),Is(r,e,i[2]),s[0].setCoordsPoint2D(i[0]),s[1].setCoordsPoint2D(i[1]),s[2].setCoordsPoint2D(i[2])}function Df(r,t,e,s){if(t.isEqual(r.m_XStart,r.m_YStart)&&e.isEqual(r.m_XEnd,r.m_YEnd))return;const i=!!s&&r.isMonotoneQuickAndDirty(),n=new pt,o=R(y,3);o[0].setCoords(r.m_XStart,r.m_YStart),o[2].setCoords(r.m_XEnd,r.m_YEnd);const a=new y;a.setSub(o[2],o[0]),a.leftPerpendicularThis(),o[1].setAdd(o[0],a);const h=R(y,3);h[0].setCoordsPoint2D(t),h[2].setCoordsPoint2D(e),a.setSub(h[2],h[0]),a.leftPerpendicularThis(),h[1].setAdd(h[0],a),n.setFromTwoTriangles(o,h)?n.transformInPlace(r.m_cp):Qt(t,e,.5,r.m_cp),r.changeEndPoints2D(t,e),i&&wh(r)}function Tf(r){return r.getStartXY().norm(1)+r.getEndXY().norm(1)+r.m_cp.norm(1)}function Ql(r,t,e,s,i){if(i){if(Qe(t,e)!==0)return r?4:2}else if(is(t,e))return 1;return cr(r,t,e,null,null,null,s,i??!1,!0,!1)!==0?4:0}function Kl(r,t,e,s,i){if(i){if(Qe(t,e)!==0)return r?4:2}else if(is(t,e))return 1;return Th(r,t,e,null,null,null,s,i??!1,!0,!1)!==0?4:0}function Nf(r,t,e,s,i){if(i){if(Qe(t,e)!==0)return 2}else if(is(t,e))return 1;return Am(r,t,e,null,null,null,s,i??!1,!0,!1)!==0?4:0}function cr(r,t,e,s,i,n,o,a,h,m){if(i!=null&&(i.length=0),n!==null&&(n.length=0),s!==null&&(s.length=0),e.isDegenerate(0)){const N=[0,0],A=t.intersectPoint(e.getStartXY(),N,o);if(A>0){if(i!==null)for(let M=0;M<A;M++)i.push(N[M]);if(n!==null)for(let M=0;M<A;M++)n.push(0);if(s!==null)for(let M=0;M<A;M++){const G=new y;t.queryCoord2D(N[M],G),s.push(G)}}return A}const l=Xe(t,e);if(o=Math.max(o,l),t.isDegenerateToLineHelper(l)){const N=new ht({start:t.getStartXY(),end:t.getEndXY()}),A=da(N,e,s,i,n,o,a,m);if(i)for(let M=0;M<A;++M){const G=N.getCoord2D(i[M]);i[M]=t.getClosestCoordinate(G,!1)}return A}if(ns(t,e,o))return 0;const u=Et.constructPoint2D(e.getStartXY()),c=Et.constructPoint2D(e.getEndXY()).sub(u),g=c.clone();g.leftPerpendicularThis();const _=Et.constructPoint2D(t.m_cp).sub(Et.constructPoint2D(t.getStartXY())),d=Et.constructPoint2D(t.getEndXY()).sub(Et.constructPoint2D(t.m_cp));let p=_.dotProduct(g).toDouble(),f=d.sub(_).dotProduct(g).toDouble();const x=j(12,Number.NaN),E=j(12,Number.NaN);let P=Kp(f,p,z.unit(),x);P<0&&(x[0]=0,x[1]=1,P=2);let C,S=0;for(let N=0,A=S;N<P;++N){const M=t.getCoord2D(x[N+A]);E[S]=e.getClosestCoordinate(M,!1),y.distance(M,e.getCoord2D(E[S]))<=o&&(x[S]=x[N+A],S++)}const I=R(y,3);t.queryControlPoints(I);{const N=R(Et,3);if(En(I,N,!1),N[0]=N[0].sub(u),c.x.abs().gte(c.y.abs())){const A=c.y.div(c.x);f=N[2].y.sub(N[2].x.mul(A)).toDouble(),p=N[1].y.sub(N[1].x.mul(A)).toDouble(),C=N[0].y.sub(N[0].x.mul(A)).toDouble()}else{const A=c.x.div(c.y);f=N[2].x.sub(N[2].y.mul(A)).toDouble(),p=N[1].x.sub(N[1].y.mul(A)).toDouble(),C=N[0].x.sub(N[0].y.mul(A)).toDouble()}}const w=t.getEndXY().equals(e.getStartXY())||t.getEndXY().equals(e.getEndXY()),D=[0,0];P=Ui(f,p,C,z.unit(),w,D);for(let N=0,A=S;N<P;++N){x[N+A]=D[N];const M=t.getCoord2D(x[N+A]);E[S]=e.getClosestCoordinate(M,!1),y.distance(M,e.getCoord2D(E[S]))<=o&&(x[S]=x[N+A],S++)}b(S<x.length+4),P=t.intersectPoint(e.getStartXY(),D,o);for(let N=0;N<P;N++)x[S]=D[N],E[S++]=0;P=t.intersectPoint(e.getEndXY(),D,o);for(let N=0;N<P;N++)x[S]=D[N],E[S++]=1;P=e.intersectPoint(t.getStartXY(),D,o);for(let N=0;N<P;N++)E[S]=D[N],x[S++]=0;P=e.intersectPoint(t.getEndXY(),D,o);for(let N=0;N<P;N++)E[S]=D[N],x[S++]=0;return S===0?0:rs(r,t,e,x,E,S,s,i,n,o,a,h,m)}function Th(r,t,e,s,i,n,o,a,h,m){if(Ft(e))return cr(r,t,new ht({start:e.getStartXY(),end:e.getEndXY()}),s,i,n,o,a,h,m);const l=Xe(t,e);if(ns(t,e,o=Math.max(o,l)))return 0;const u=[],c=[],g=R(y,3);{t.queryControlPoints(g);const d=R(y,3),p=new pt;e.canonicToWorldTransformation(p);const f=new pt;f.setInvert(p),f.transformPoints2D(g,3,d);const x=R(Et,3);En(d,x);const E=[x[0].x,x[1].x,x[2].x],P=[x[0].y,x[1].y,x[2].y],C=R(J,3);C[0].setDouble(e.getSemiMinorAxis()),C[0].sqrThis(),C[1].setDouble(e.getSemiMajorAxis()),C[1].sqrThis(),C[2]=C[0],C[2].mul(C[1]),C[2].negate();const S=Nm(E,2,P,2,null,0,C,!0,z.unit(),z.unit(),u,a);if(S>0){let I=0;for(let w=0;w<S;w++){const D=new y;t.queryCoord2D(u[w],D);const N=e.getClosestCoordinate(D,!1),A=new y;e.queryCoord2D(N,A),y.distance(D,A)<=o&&(u[I]=u[w],c.push(N),I++)}u.length=I}}const _=[0,1];for(let d=0;d<2;d++){const p=d===0?e.getStartXY():e.getEndXY(),f=[0];pa(g,p,f);const x=new y;Is(g,f[0],x),y.distance(p,x)<=o&&(u.push(f[0]),c.push(_[d]))}for(let d=0;d<2;d++){const p=[0,2];{const f=e.getClosestCoordinate(g[p[d]],!1),x=new y;e.queryCoord2D(f,x),y.distance(g[p[d]],x)<=o&&(u.push(_[d]),c.push(f))}}return rs(r,t,e,u,c,u.length,s,i,n,o,a,h,m)}function Am(r,t,e,s,i,n,o,a,h,m){const l=R(y,3);t.queryControlPoints(l);const u=R(y,3);if(e.queryControlPoints(u),wm(l,u,3)<0)return Am(r,e,t,s,n,i,o,a,h,!m);const c=Xe(t,e);if(ns(t,e,o=Math.max(o,c)))return 0;if(Lf(t,e,s,i,n,o,a,h,m))return 2;const g=new z(0,1),_=new z(0,1);{const x=new ce;lr(l,z.unit(),x);const E=new ce;lr(u,z.unit(),E);const P=Math.max(x.maxDim(),E.maxDim());if(x.inflate(3*o),E.inflate(3*o),!x.intersectW(E))return 0;if(x.maxDim()<.1*P){if(Zl(l,x,g),Zl(u,x,_),g.isEmpty()||_.isEmpty())return 0;ur(l,g.vmin,g.vmax,l),ur(u,_.vmin,_.vmax,u)}}const d=Vn(l,2,u,2,o);if(d===0)return 0;const p=[],f=[];if(d===-1){const x=R(Et,3);En(l,x);const E=[x[0].x,x[1].x,x[2].x],P=[x[0].y,x[1].y,x[2].y],C=R(Et,3);En(u,C);const S=Mn(E,2,P,2,null,0,[C[0].x,C[1].x,C[2].x],2,[C[0].y,C[1].y,C[2].y],2,null,0,!0,z.unit(),z.unit(),p,f,m,a,m);if(S>0){let I=0;for(let w=0;w<S;w++){const D=new y,N=new y;Is(u,f[w],N),Is(l,p[w],D),y.distance(D,N)<=o&&(p[I]=p[w],f[I]=f[w],I++)}p.length=I,f.length=I}}for(let x=0;x<2;x++){const E=x===0?l:u,P=x===0?u:l;for(let C=0;C<2;C++){const S=C===0?0:2,I=[0];pa(P,E[S],I);const w=new y;Is(P,I[0],w),y.distance(E[S],w)<=o&&(x===0?(p.push(S===0?0:1),f.push(I[0])):(f.push(S===0?0:1),p.push(I[0])))}}if(p.length===0)return 0;if(!g.equalsRange(0,1))for(let x=0;x<p.length;++x)p[x]=Oi.recalculateParentT(g.vmin,g.vmax,p[x]);if(!_.equalsRange(0,1))for(let x=0;x<f.length;++x)f[x]=Oi.recalculateParentT(_.vmin,_.vmax,f[x]);return rs(r,t,e,p,f,p.length,s,i,n,o,a,h,m)}function qm(r,t,e=!1){const s=r[1].sub(r[0]);t[1].assign(s.mul(2)),t[2].assign(r[2].sub(r[1]).sub(s)),e?t[0].setCoords(0,0):t[0].assign(r[0])}function Af(r,t,e=!1){const s=R(y,3);r.queryControlPoints(s),qm(s,t,e)}function qf(r,t,e=!1){const i=new L(r[1][0]).subE(new L(r[0][0]));t[1]=i.mul(2),t[2]=new L(r[2][0]).subE(new L(r[1][0])).subE(i),e?t[0].set(0):t[0].set(r[0][0])}function Ff(r,t,e=!1){const i=new L(r[1][1]).subE(new L(r[0][1]));t[1]=i.mul(2),t[2]=new L(r[2][1]).subE(new L(r[1][1])).subE(i),e?t[0].set(0):t[0].set(r[0][1])}function En(r,t,e=!1){const s=Et.constructPoint2D(r[1]),i=s.sub(Et.constructPoint2D(r[0]));t[1]=i.mul(J.constructInt32(2)),t[2]=Et.constructPoint2D(r[2]).sub(s).sub(i),t[0]=e?new Et(Se,Se):Et.constructPoint2D(r[0])}function Is(r,t,e,s){if(s){if(t<0)return void Ue(new ht({start:r[0],end:r[0].add(Wl(r,0).getUnitVector())}),t,e);if(t>1)return void Ue(new ht({start:r[2],end:r[2].add(Wl(r,1).getUnitVector())}),t-1,e)}if(t<=.5){const i=r[1].clone(),n=new y;ee(2,r[0],i,t,n);const o=new y;ee(2,i,r[2],t,o);const a=new y;ee(2,n,o,t,a),e.assign(a)}else{const i=r[1].clone(),n=new y;se(2,r[0],i,t,n);const o=new y;se(2,i,r[2],t,o);const a=new y;se(2,n,o,t,a),e.assign(a)}}function Mf(r,t,e){const s=R(y,3);r.queryControlPoints(s),Gf(s,t,e)}function Gf(r,t,e){if(t.value()<=.5){const s=K.constructPoint2D(r[1]),i=new K;us(2,K.constructPoint2D(r[0]),s,t,i);const n=new K;us(2,s,K.constructPoint2D(r[2]),t,n);const o=new K;us(2,i,n,t,o),e.setE(o)}else{const s=K.constructPoint2D(r[1]),i=new K;cs(2,K.constructPoint2D(r[0]),s,t,i);const n=new K;cs(2,s,K.constructPoint2D(r[2]),t,n);const o=new K;cs(2,i,n,t,o),e.setE(o)}}function Vf(r,t,e){const s=R(y,4);r.queryControlPoints(s),Yf(s,t,e)}function Yf(r,t,e){t.value()<0&&t.set(0,t.eps()),t.value()>1&&t.set(1,t.eps()),e.setE(Ef(r,1,t))}function Xf(r,t){t[0].assign(r[0]),t[3].assign(r[2]),Qt(r[0],r[1],2/3,t[1]),Qt(r[1],r[2],1/3,t[2])}function Rf(r,t){const e=R(y,3);r.queryControlPoints(e);const s=y.sqrDistance(e[1],e[0]),i=y.sqrDistance(e[1],e[2]);let n=e[0].clone(),o=s;s>i&&(n=e[2].clone(),o=i);let a=!1;return o<=t&&o!==0&&(a=!0,r.setControlPoint1(n)),a}function kf(r,t){if(!t)return!1;const e=R(y,3);r.queryControlPoints(e);const s=y.sqrDistance(e[1],e[0]),i=y.sqrDistance(e[1],e[2]);e[0].clone();let n=s;return s>i&&(e[2].clone(),n=i),n<=t&&n!==0}function Lf(r,t,e,s,i,n,o,a,h){const m=R(y,3);r.queryControlPoints(m);const l=R(y,3);if(t.queryControlPoints(l),m[0].equals(l[0])){if(m[1].equals(l[1])&&m[2].equals(l[2]))return e&&(e.length=0,e.push(m[0]),e.push(m[2])),s&&(s.length=0,s.push(0),s.push(1)),i&&(i.length=0,i.push(0),i.push(1)),!0;if(!m[0].equals(l[2]))return!1}return!!(m[0].equals(l[2])&&m[1].equals(l[1])&&m[2].equals(l[0]))&&(s&&(s.length=0,s.push(0),s.push(1),h&&(s[1]=O(s[0],s[0]=s[1]))),i&&(i.length=0,i.push(1),i.push(0),h&&(i[1]=O(i[0],i[0]=i[1]))),e&&(e.length=0,e.push(m[0]),e.push(m[2]),h&&(e[1]=O(e[0],e[0]=e[1]))),!0)}const Jl=[[.33998104358485626,.6521451548625461],[.8611363115940526,.34785484513745385]],tu=[[.1834346424956498,.362683783378362],[.525532409916329,.31370664587788727],[.7966664774136267,.22238103445337448],[.9602898564975363,.10122853629037626]],eu=[[.09501250983763744,.1894506104550685],[.2816035507792589,.18260341504492358],[.45801677765722737,.16915651939500254],[.6178762444026438,.14959598881657674],[.755404408355003,.12462897125553388],[.8656312023878318,.09515851168249279],[.9445750230732326,.062253523938647894],[.9894009349916499,.027152459411754096]],su=[[.04830766568773832,.0965400885147278],[.1444719615827965,.09563872007927486],[.23928736225213706,.09384439908080457],[.33186860228212767,.09117387869576389],[.42135127613063533,.08765209300440381],[.5068999089322294,.08331192422694675],[.5877157572407623,.07819389578707031],[.6630442669302152,.0723457941088485],[.7321821187402897,.06582222277636185],[.7944837959679424,.058684093478535544],[.84936761373257,.050998059262376175],[.8963211557660521,.04283589802222668],[.9349060759377397,.03427386291302143],[.9647622555875064,.02539206530926206],[.9856115115452684,.01627439473090567],[.9972638618494816,.007018610009470096]],iu=[[.024350292663424433,.048690957009139724],[.07299312178779904,.04857546744150343],[.12146281929612056,.048344762234802954],[.16964442042399283,.04799938859645831],[.21742364374000708,.04754016571483031],[.2646871622087674,.04696818281621002],[.31132287199021097,.046284796581314416],[.3572201583376681,.04549162792741814],[.4022701579639916,.044590558163756566],[.4463660172534641,.04358372452932345],[.48940314570705296,.04247351512365359],[.5312794640198946,.04126256324262353],[.571895646202634,.03995374113272034],[.6111553551723933,.038550153178615626],[.6489654712546573,.03705512854024005],[.6852363130542333,.035472213256882386],[.7198818501716109,.033805161837141606],[.7528199072605319,.03205792835485155],[.7839723589433414,.030234657072402478],[.8132653151227975,.028339672614259483],[.8406292962525803,.02637746971505466],[.8659993981540928,.024352702568710874],[.8893154459951141,.022270173808383253],[.9105221370785028,.02013482315353021],[.9295691721319396,.017951715775697343],[.9464113748584028,.015726030476024718],[.9610087996520538,.013463047896718643],[.973326827789911,.011168139460131128],[.983336253884626,.008846759826363947],[.9910133714767443,.006504457968978363],[.9963401167719553,.004147033260562468],[.9993050417357722,.001783280721696433]],nu=[[.012223698960615764,.024446180196262518],[.03666379096873349,.024431569097850044],[.06108196960413957,.02440235563384958],[.08546364050451549,.024358557264690626],[.10979423112764375,.024300200167971867],[.13405919946118777,.02422731922281525],[.15824404271422493,.024139957989019287],[.18233430598533718,.024038168681024052],[.2063155909020792,.023922012136703457],[.23017356422666,.023791557781003402],[.2538939664226943,.023646883584447616],[.2774626201779044,.02348807601653591],[.3008654388776772,.02331522999406276],[.32408843502441337,.023128448824387027],[.3471177285976355,.022927844143686846],[.369939555349859,.02271353585023646],[.39254027503326744,.022485652032744968],[.414906379552275,.022244328893799764],[.43702450103710416,.02198971066846049],[.4588814198335522,.021721949538052076],[.48046407240417205,.02144120553920846],[.5017595591361445,.02114764646822135],[.5227551520511755,.02084144778075115],[.5434383024128103,.02052279248696007],[.5637966482266181,.020191871042130043],[.5838180216287631,.01984888123283086],[.6034904561585486,.019494028058706602],[.6228021939105849,.019127523609950944],[.6417416925623075,.01874958694054471],[.660297632272646,.01836044393733134],[.6784589224477192,.017960327185008687],[.6962147083695144,.017549475827117706],[.7135543776835874,.01712813542311138],[.7304675667419088,.016696557801589205],[.746944166797062,.016255000909785187],[.7629743300440948,.015803728659399347],[.7785484755064119,.015343010768865144],[.7936572947621933,.014873122602147314],[.8082917575079137,.014394345004166847],[.8224431169556439,.013906964132951985],[.8361029150609068,.013411271288616333],[.8492629875779689,.012907562739267348],[.8619154689395485,.012396139543950923],[.8740527969580318,.01187730737274028],[.8856677173453972,.011351376324080417],[.8967532880491582,.010818660739503076],[.9073028834017568,.010279479015832158],[.9173101980809605,.009734153415006806],[.9267692508789478,.009183009871660874],[.9356743882779164,.00862637779861675],[.9440202878302202,.008064589890486059],[.9518019613412644,.0074979819256347285],[.9590147578536999,.006926892566898814],[.9656543664319652,.006351663161707189],[.9717168187471366,.005772637542865698],[.9771984914639074,.00519016183267633],[.9820961084357185,.004604584256702955],[.9864067427245862,.004016254983738642],[.9901278184917344,.0034255260409102157],[.9932571129002129,.0028327514714579912],[.9957927585349812,.0022382884309626186],[.997733248625514,.0016425030186690294],[.9990774599773758,.0010458126793403489],[.9998248879471319,.00044938096029209035]];function zs(r,t,e,s){const i=.5*(s-e),n=e+i,o=new Ce(0);for(let a=0,h=Math.trunc(r/2);a<h;++a){let m,l;switch(r){case 4:m=Jl[a][0],l=Jl[a][1];break;case 8:m=tu[a][0],l=tu[a][1];break;case 16:m=eu[a][0],l=eu[a][1];break;case 32:m=su[a][0],l=su[a][1];break;case 64:m=iu[a][0],l=iu[a][1];break;case 128:m=nu[a][0],l=nu[a][1];break;default:throw new Error("Quadrature_integral: invalid n")}const u=xl(-.5,m,n),c=xl(i,m,n);o.pe(t(u)*l),o.pe(t(c)*l)}return o.getResult()*i}let ct=class Nh extends Tm{constructor(t){t?t.vd?(super({vd:t.vd,bPolygon:!0}),this.m_segmentBufferCTor=it):t.copy?(super({vd:t.copy.getDescription(),bPolygon:!0}),this.m_segmentBufferCTor=it,t.copy.copyTo(this)):t.move?(super({move:t.move}),this.m_segmentBufferCTor=it):t.envelope?ft("envelope constructor not impl"):$("bad arg to polygon constructor"):(super({bPolygon:!0}),this.m_segmentBufferCTor=it)}assignMove(t){return t.copyTo(this),this}assignCopy(t){return t.copyTo(this),this}getBoundary(){return Gs(this)}getExteriorRingCount(){return this.getOGCPolygonCount()}getGeometryType(){return Nh.type}getDimension(){return 2}createInstance(){return new Nh({vd:this.getDescription()})}equals(t,e){return this.equalsBase(t,e)}};function Bf(r,t){let e,s=t,i=null;switch(s||(i=Hc(r)?nr():_e(),s=i),r){case T.enumPoint:e=new st({vd:s});break;case T.enumLine:e=new ht({vd:s});break;case T.enumBezier:e=new ws({vd:s});break;case T.enumEllipticArc:e=new Xs({vd:s});break;case T.enumRationalBezier2:e=new Ge({vd:s});break;case T.enumBezier2:e=new Oi({vd:s});break;case T.enumEnvelope:e=new Ne({vd:s});break;case T.enumMultiPoint:e=new Zt({vd:s});break;case T.enumPolyline:e=new Pt({vd:s});break;case T.enumPolygon:e=new ct({vd:s});break;case T.enumMultipatch:ft("multipatch not impl");break;case T.enumGeometryCollection:e=new rg({vd:s});break;default:H("Geometry.create")}return e}ct.type=T.enumPolygon;var ru=Mt;const v=-1,Bt=1;let Hf=class{constructor(t){this.m_shape=t}userSort(t,e,s){this.m_shape.sortVerticesSimpleByYHelper(s,t,e)}getValue(t){return this.m_shape.getY(t)}};function zf(r){return r.parent!==void 0}let Ah=class Tg{constructor(t){zf(t)?(this.m_parent=t.parent,this.m_geometry=t.geometry,this.m_path=t.path,this.m_vertex=t.vertex,this.m_firstVertex=t.firstVertex,this.m_index=t.selection?0:t.index,this.m_bSkipMultiPoints=t.bSkipMultiPoints,this.m_selection=t.selection,this.m_bOneGeom=t.bOneGeom,this.m_bFirst=!0):(this.m_parent=t.copy.m_parent,this.m_geometry=t.copy.m_geometry,this.m_path=t.copy.m_path,this.m_vertex=t.copy.m_vertex,this.m_index=t.copy.m_index,this.m_bSkipMultiPoints=t.copy.m_bSkipMultiPoints,this.m_firstVertex=t.copy.m_firstVertex,this.m_bFirst=!0,this.m_selection=t.copy.m_selection,this.m_bOneGeom=t.copy.m_bOneGeom)}moveToNextHelper(){for(this.m_path=this.m_parent.getNextPath(this.m_path),this.m_index=0;this.m_geometry!==v;){for(;this.m_path!==v;this.m_path=this.m_parent.getNextPath(this.m_path))if(this.m_vertex=this.m_parent.getFirstVertex(this.m_path),this.m_firstVertex=this.m_vertex,this.m_vertex!==v)return this.m_vertex;if(this.m_bOneGeom)return v;if(this.m_geometry=this.m_parent.getNextGeometry(this.m_geometry),this.m_geometry===v)break;this.m_bSkipMultiPoints&&!lt(this.m_parent.getGeometryType(this.m_geometry))||(this.m_path=this.m_parent.getFirstPath(this.m_geometry))}return v}nextSelection(){for(;this.m_index<this.m_parent.m_selectedVertices.length;){const t=this.m_parent.m_selectedVertices[this.m_index++];if(t!==v&&(this.m_path=this.m_parent.getPathFromVertex(t),!this.m_bOneGeom||this.m_geometry===this.m_parent.getGeometryFromPath(this.m_path)))return this.m_geometry=this.m_parent.getGeometryFromPath(this.m_path),t}return v}next(){return this.m_selection?this.nextSelection():this.m_bFirst?(this.m_bFirst=!1,this.m_vertex):this.m_vertex!==v?(this.m_vertex=this.m_parent.getNextVertex(this.m_vertex),this.m_index++,this.m_vertex!==v&&this.m_vertex!==this.m_firstVertex?this.m_vertex:this.moveToNextHelper()):v}currentGeometry(){return this.m_geometry}currentPath(){return this.m_path}static create_(t,e,s,i,n,o,a,h,m){return new Tg({parent:t,geometry:e,path:s,vertex:i,firstVertex:n,index:o,bSkipMultiPoints:a,selection:h,bOneGeom:m})}},qh=class{constructor(t){this.parentage=t}equals(t){return this.parentage===t.parentage}},Lt=class Fh{setPrevPath(t,e){this.m_pathIndexList.setField(t,1,e)}setNextPath(t,e){this.m_pathIndexList.setField(t,2,e)}setPathFlags(t,e){this.m_pathIndexList.setField(t,6,e)}getPathFlags(t){return this.m_pathIndexList.getField(t,6)}setPathGeometry(t,e){this.m_pathIndexList.setField(t,7,e)}getPathIndex(t){return this.m_pathIndexList.getField(t,0)}setNextGeometry(t,e){this.m_geometryIndexList.setField(t,1,e)}setPrevGeometry(t,e){this.m_geometryIndexList.setField(t,0,e)}getGeometryIndex(t){return this.m_geometryIndexList.getField(t,7)}setFirstPath(t,e){this.m_geometryIndexList.setField(t,3,e)}setLastPath(t,e){this.m_geometryIndexList.setField(t,4,e)}newGeometry(t){const e=this.m_geometryIndexList.newElement();return this.m_geometryIndexList.setField(e,2,t),this.m_geometryIndexList.setField(e,5,0),this.m_geometryIndexList.setField(e,6,0),this.m_geometryIndexList.setField(e,7,this.m_geometryIndexList.elementToIndex(e)),e}freeGeometry(t){this.m_geometryIndexList.deleteElement(t)}newPath(t){const e=this.m_pathIndexList.newElement(),s=this.m_pathIndexList.elementToIndex(e);if(this.m_pathIndexList.setField(e,0,s),this.m_pathIndexList.setField(e,3,0),this.m_pathIndexList.setField(e,6,0),this.setPathGeometry(e,t),s>=this.m_pathAreas.length){const i=Math.trunc(s<16?16:3*s/2);this.m_pathAreas.length=i,this.m_pathLengths.length=i}return this.m_pathAreas[s]=0,this.m_pathLengths[s]=0,this.m_pathCount++,e}freePath(t){this.m_pathIndexList.deleteElement(t),this.m_pathCount--}newVertex(t){const e=this.m_vertexIndexList.newElement(),s=t>=0?t:this.m_vertexIndexList.elementToIndex(e);if(this.m_vertexIndexList.setField(e,0,s),t<0){if(s>=this.m_vertices.getPointCount()){const i=Math.trunc(s<16?16:3*s/2);this.m_vertices.reserveRounded(i),this.m_vertices.resizeNoInit(i),this.m_segments!==null&&(this.m_segments.length=i),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0)}this.m_segments&&(this.m_segments[s]=null)}return this.m_pointCount++,e}freeVertex(t){this.unselect(t);const e=this.getVertexIndex(t);this.m_vertexIndexList.deleteElement(t),this.m_pointCount--;for(let s=0,i=this.m_indices.length;s<i;s++){if(s===this.m_selectionIndex)continue;const n=this.m_indices[s];n!==null&&n.size()>e&&n.write(e,-1)}this.m_weights&&this.m_weights.size()>e&&this.m_weights.write(e,1),this.m_ranks&&this.m_ranks.size()>e&&this.m_ranks.write(e,Bt),this.m_segmentWeights&&this.m_segmentWeights.size()>e&&this.m_segmentWeights.write(e,1),this.m_segmentRanks&&this.m_segmentRanks.size()>e&&this.m_segmentRanks.write(e,Bt),this.m_segments&&this.setSegmentToIndex(e,null)}insertVertex_(t,e,s,i){this.m_hasForceSetEnvelope=0;const n=e!==v?this.getPrevVertex(e):this.getLastVertex(t),o=n!==v?this.getNextVertex(n):v,a=this.newVertex(s===null?this.m_pointCount:-1),h=this.getVertexIndex(a);s!==null&&this.m_vertices.setPointByValNoCurves(h,s),this.setPathToVertex(a,t),this.setNextVertex(a,o),this.setPrevVertex(a,n),o!==v&&this.setPrevVertex(o,a),n!==v&&this.setNextVertex(n,a);const m=this.isClosedPath(t),l=this.getFirstVertex(t);e===v&&this.setLastVertex(t,a),e===l&&(m&&i&&l!==v||this.setFirstVertex(t,a)),m&&o===v&&(this.setNextVertex(a,a),this.setPrevVertex(a,a)),this.setPathSize(t,this.getPathSize(t)+1);const u=this.getGeometryFromPath(t);return this.setGeometryVertexCount(u,this.getPointCount(u)+1),a}getHelperPoint(){return this.m_helperPoint||(this.m_helperPoint=new st({vd:this.m_vertices.getDescription()}),this.m_helperPoint.setXYCoords(0,0)),this.m_helperPoint}addMultiPoint(t,e){const s=this.createGeometry(t.getGeometryType(),t.getDescription());return this.appendMultiPoint(s,t,e),s}addPoint_(t,e){const s=this.createGeometry(T.enumMultiPoint,t.getDescription());return this.appendPoint(s,t,e),s}appendMultiPath_(t,e){if(e.isEmpty())return;const s=e.getImpl();this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+s.getPointCount()),this.m_verticesMp.addPoints(e,0,s.getPointCount()),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0);const i=this.m_segments!==null||s.getSegmentFlagsStreamRef()!==null;this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+s.getPointCount()),this.m_pathIndexList.setCapacity(this.m_pathIndexList.size()+s.getPathCount());for(let n=0,o=s.getPathCount();n<o;n++){if(s.getPathSize(n)===0)continue;const a=this.insertPath(t,v);this.setClosedPath(a,s.isClosedPath(n));for(let h=s.getPathStart(n),m=s.getPathEnd(n);h<m;h++){const l=this.insertVertex_(a,v,null,!1);if(i){const u=this.getVertexIndex(l);if(1&s.getSegmentFlags(h))this.setSegmentToIndex(u,null);else{const c=new it;s.querySegment(h,c,!0),this.setSegmentToIndex(u,c.releaseSegment())}}}s.isStrongPathStart(n)&&this.setStrongPathStart(a,!0),s.isStrongPathEnd(n)&&this.setStrongPathEnd(a,!0)}}addMultiPath(t,e){const s=this.createGeometry(t.getGeometryType(),t.getDescription());return t.getGeometryType()===T.enumPolygon&&this.setFillRule(s,t.getFillRule()),this.appendMultiPath(s,t,e),s}appendMultiPathPolyline(t,e,s){const i=e.getImpl(),n=this.m_segments!==null||i.getSegmentFlagsStreamRef()!==null,o=new F;e.queryEnvelope(o);{const a=s.clone();let h=i.getPointCount();const m=i.getAccelerators();if(m&&m.getQuadTree()&&(h=m.getQuadTree().getIntersectionCount(a,0,i.getPointCount()+1)),h<e.getPointCount()){if(h===0)return;const l=i.queryLimitedSegmentIterator(a);let u=-1,c=-100,g=-1,_=0,d=-1,p=v,f=!1,x=l.nextSegment();if(x!==null)for(;;x=l.nextSegment()){let E=x===null;const P=x!==null?l.getPathIndex():u,C=x!==null?l.getStartPointIndex():c;if(E||(u===P&&c+1===C?_++:E=!0),E){if(d!==-1){let S=-1,I=-1;if(_===g){this.setClosedPath(p,f);const w=i.getPathEnd(u);this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+w-d),this.m_verticesMp.addPoints(e,d,w),I=i.getPathSize(u),S=w-1}else if(!f||c+1<i.getPathEnd(u))this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+c+2-d),this.m_verticesMp.addPoints(e,d,c+2),I=c-d+2,S=c;else{this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+c+2-d),this.m_verticesMp?.addPoints(e,d,c+1),S=c,I=c-d+1;const w=i.getPathStart(u);this.m_verticesMp.addPoints(e,w,w+1),I+=1}this.m_xyStream=this.m_vertices.getAttributeStreamRef(0);for(let w=0,D=d;w<I;w++,D++){const N=this.insertVertex_(p,v,null,!1);if(n){const A=this.getVertexIndex(N);if(1&i.getSegmentFlags(D)||D>S)this.setSegmentToIndex(A,null);else{const M=new it;i.getSegmentBuffer(D,M,!0),this.setSegmentToIndex(A,M.releaseSegment())}}}}if(x===null)break;_=1,d=C,u!==P?(p=this.insertPath(t,v),this.setClosedPath(p,!1),g=i.getSegmentCountPath(P),f=i.isClosedPath(P),u=P):p=this.insertPath(t,v)}c=C}return}}this.appendMultiPath_(t,e)}appendMultiPathPolygon(t,e,s){const i=e.getImpl(),n=this.m_segments!==null||i.getSegmentFlagsStreamRef()!==null,o=F.constructEmpty();e.queryEnvelope(o),b(s.isIntersecting(o)&&!s.containsEnvelope(o));let a=F.construct(Number.NEGATIVE_INFINITY,s.ymin,Number.POSITIVE_INFINITY,s.ymax),h=F.construct(s.xmin,Number.NEGATIVE_INFINITY,s.xmax,Number.POSITIVE_INFINITY);const m=i.getAccelerators();if(m&&m.getQuadTree()){const C=m.getQuadTree(),S=C.getIntersectionCount(a,0,0);S>C.getIntersectionCount(h,0,S+1)&&(h=O(a,a=h))}else a.height()>h.width()&&(h=O(a,a=h));const l=[],u=i.queryLimitedSegmentIterator(a);let c=-1,g=-100,_=-1,d=0,p=-1,f=-1,x=v,E=!0,P=u.nextSegment();if(P!==null)for(;;P=u.nextSegment()){let C=P===null;const S=P!==null?u.getPathIndex():c,I=P!==null?u.getStartPointIndex():g;if(C||(S===c?g+1===I?d++:C=!0:(C=c>=0,c<0&&(c=S,_=i.getSegmentCountPath(c),p=I,x=v,d=1))),C){if(!(l.length===0&&_===d)){l.length!==0&&l[0].first===p||(this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+1),this.m_verticesMp.addPoints(e,p,p+1),f===-1&&(f=p),x===v&&(x=this.insertPath(t,v),this.setClosedPath(x,!0)),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.insertVertex_(x,v,null,!1));for(const{first:w,second:D}of l){f===-1&&(f=w);let N=-1,A=-1;const M=w+D-1;if(D===_){const G=M+1;A=G-w,this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+A),this.m_verticesMp.addPoints(e,w,G),N=M,b(l.length===1)}else if(M+1<i.getPathEnd(c)){const G=M+2;A=G-w,this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+A),this.m_verticesMp.addPoints(e,w,G),N=M}else{const G=i.getPathStart(c),q=G!==f?1:0,V=M+1;A=V-w+q,this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+(V-w)+q),this.m_verticesMp.addPoints(e,w,V),N=M,q>0&&this.m_verticesMp?.addPoints(e,G,G+1)}this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),x===v&&(x=this.insertPath(t,v),this.setClosedPath(x,!0));for(let G=0,q=w;G<A;G++,q++){const V=this.insertVertex_(x,v,null,!1);if(n){const k=this.getVertexIndex(V);if(1&i.getSegmentFlags(q)||q>N)this.setSegmentToIndex(k,null);else{const Y=new it;i.getSegmentBuffer(q,Y,!0),this.setSegmentToIndex(k,Y.releaseSegment())}}}}if(l.length===0||l.at(-1).first+l.at(-1).second!==p+d){let w=p+d;w===e.getPathEnd(c)&&(w=e.getPathStart(c)),f!==w&&(this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+1),this.m_verticesMp.addPoints(e,w,w+1),this.insertVertex_(x,v,null,!1))}}l.length=0,E=!0,S!==c&&(c=S,_=i.getSegmentCountPath(c),x=v,f=-1),p=I,d=1}if(!P)break;{const w=F.constructEmpty();P.queryLooseEnvelope(w),h.isIntersecting(w)?(E?l.push(te(I,1)):l.at(-1).second++,E=!1):E=!0}g=I}}appendMultiPath(t,e,s){if(s===void 0)return void this.appendMultiPath_(t,e);if(e.isEmpty())return;const i=e.getGeometryType()===T.enumPolygon,n=F.constructEmpty();e.queryEnvelope(n),s.isIntersecting(n)&&(!s.containsEnvelope(n)&&e.getPointCount()>10?i?this.appendMultiPathPolygon(t,e,s):this.appendMultiPathPolyline(t,e,s):this.appendMultiPath_(t,e))}appendPoint(t,e,s){if(e.isEmpty()||s!==void 0&&!s.contains(e.getXY()))return;this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+1),this.m_verticesMp.add(e),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+1);const i=this.insertPath(t,v);this.insertVertex_(i,v,null,!1)}appendMultiPoint_(t,e){this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+e.getPointCount()),this.m_verticesMp.addPoints(e,0,e.getPointCount()),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+e.getPointCount());const s=this.insertPath(t,v);for(let i=0,n=e.getPointCount();i<n;i++)this.insertVertex_(s,v,null,!1)}appendMultiPoint(t,e,s){if(s===void 0)return void this.appendMultiPoint_(t,e);const i=e.getAttributeStreamRef(0);let n=0;for(let l=0,u=e.getPointCount();l<u;l++){const c=i.readPoint2D(2*l);s.contains(c)&&n++}this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+n);let o=-1,a=-1,h=0;for(let l=0,u=e.getPointCount();l<u;l++){const c=i.readPoint2D(2*l);s.contains(c)?(o===-1&&(o=l,a=l),a++):o>=0&&(this.m_verticesMp.addPoints(e,o,a-o),o=-1,h++)}if(o>0&&(this.m_verticesMp.addPoints(e,o,a-o),h++),!h)return;this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+n);const m=this.insertPath(t,v);for(let l=0,u=e.getPointCount();l<u;l++){const c=i.readPoint2D(2*l);s.contains(c)&&this.insertVertex_(m,v,null,!1)}}splitSegmentForward(t,e,s,i,n){const o=this.getNextVertex(t);o===v&&H("Edit_shape.split_segment_forward_");const a=this.getHelperPoint(),h=this.getPathFromVertex(t);let m=t;const l=this.hasSegmentParentage();for(let u=0,c=e.getResultSegmentCount(s);u<c;u++){const g=this.getVertexIndex(m),_=this.getNextVertex(m),d=e.getResultSegment(s,u);let p=null;if(d.getGeometryType()!==T.enumLine&&(p=d.clone(),p.dropAllAttributes()),u===0&&(d.queryStart(a),this.setSegmentToIndex(g,null),this.setPointEx(m,a,e.getResultSegmentStartPointRank(s,u),e.getResultSegmentStartPointWeight(s,u),n)),this.setSegmentRank(m,e.getResultSegmentInteriorRank(s,u)),this.setSegmentWeight(m,e.getResultSegmentInteriorWeight(s,u)),l){const f=e.getResultSegmentSegmentParentage(s,u),x=e.getResultSegmentStartPointIsBreak(s,u);this.setSegmentParentageAndBreak(m,f,x)}if(d.queryEnd(a),u<c-1){this.setSegmentToIndex(g,p);const f=this.insertVertex(h,_,a);this.setWeight(f,e.getResultSegmentEndPointWeight(s,u)),this.setRank(f,e.getResultSegmentEndPointRank(s,u)),this.select(f),m=f}else{this.setPointEx(o,a,e.getResultSegmentEndPointRank(s,u),e.getResultSegmentEndPointWeight(s,u),n);const f=e.getResultSegmentEndPointIsBreak(s,u);this.setSegmentParentageBreakVertex(o,f),this.setSegmentToIndex(g,p)}}}splitSegmentBackward(t,e,s,i,n){const o=this.getNextVertex(t);o===v&&H("Edit_shape.split_segment_backward_");const a=this.getHelperPoint(),h=this.getPathFromVertex(t);let m=t;const l=this.hasSegmentParentage();for(let u=0,c=e.getResultSegmentCount(s);u<c;u++){const g=c-u-1,_=this.getVertexIndex(m),d=this.getNextVertex(m),p=e.getResultSegment(s,g);let f=null;if(p.getGeometryType()!==T.enumLine&&(f=p.clone(),f.reverse(),f.dropAllAttributes()),u===0&&(p.queryEnd(a),this.setSegmentToIndex(_,null),this.setPointEx(m,a,e.getResultSegmentEndPointRank(s,g),e.getResultSegmentEndPointWeight(s,g),n),this.setSegmentParentageAndBreak(m,e.getResultSegmentSegmentParentage(s,g),e.getResultSegmentEndPointIsBreak(s,g))),p.getGeometryType()===T.enumLine?this.setSegmentToIndex(_,null):this.setSegmentToIndex(_,f),this.setSegmentRank(m,e.getResultSegmentInteriorRank(s,g)),this.setSegmentWeight(m,e.getResultSegmentInteriorWeight(s,g)),p.queryStart(a),u<c-1){const x=this.insertVertex(h,d,a);this.setWeight(x,e.getResultSegmentStartPointWeight(s,g)),this.setRank(x,e.getResultSegmentStartPointRank(s,g)),this.select(x),m=x,l&&this.setSegmentParentageAndBreak(x,e.getResultSegmentSegmentParentage(s,g),e.getResultSegmentEndPointIsBreak(s,g))}else this.setPointEx(o,a,e.getResultSegmentStartPointRank(s,g),e.getResultSegmentStartPointWeight(s,g),n)}}selected_(t){return this.getUserIndex(t,this.m_selectionIndex)>=0}allocateIndex(t=!0){if(this.m_deletedIndices.length){const e=this.m_deletedIndices.pop();return t&&e.setRange(-1,0,e.size()),e}return t?be(0,-1):be(0)}recycleUserIndex(t){this.m_deletedIndices.push(t)}allocatePathIndex(){if(this.m_deletedPathIndices.length){const t=this.m_deletedPathIndices.at(-1);return this.m_deletedPathIndices.pop(),t}return be(0)}recyclePathUserIndex(t){this.m_deletedPathIndices.push(t)}peelALoop_(t,e,s){const i=this.getNextVertex(t),n=this.getNextVertex(e),o=this.getVertexIndex(t),a=this.getVertexIndex(e);if(this.setNextVertex(t,n),this.setPrevVertex(n,t),this.setNextVertex(e,i),this.setPrevVertex(i,e),this.m_segments){const h=this.getSegmentFromIndex(o),m=this.getSegmentFromIndex(a);this.setSegmentToIndex(a,null),this.setSegmentToIndex(o,m),this.setSegmentToIndex(a,h)}if(this.hasSegmentParentage()){let h=this.getSegmentParentage(e),m=this.getSegmentParentage(t);h===-1&&m===-1||(m=O(h,h=m),this.setSegmentParentageAndBreak(t,m),this.setSegmentParentageAndBreak(e,h))}if(s){const h=this.getPathFromVertex(t),m=this.getGeometryFromPath(h),l=[!1],u=this.insertClosedPath(m,v,i,this.getFirstVertex(h),l);l[0]&&this.setFirstVertex(h,n);let c=this.getPathSize(h);return c-=this.getPathSize(u),this.setPathSize(h,c),u}return v}sortVerticesSimpleByYHelper(t,e,s){t.sort(e,s,(i,n)=>{let o=this.compareVerticesSimpleY(i,n);if(o===0){const a=this.getPathInternalIndexFromVertex(i),h=this.getPathInternalIndexFromVertex(n);o=a<h?-1:a>h?1:0}return o})}sortVerticesSimpleByYHelper3D(t,e,s){b(0)}constructor(){this.m_verticesMp=null,this.m_vertices=null,this.m_xyStream=null,this.m_vertexDescription=null,this.m_segments=null,this.m_weights=null,this.m_ranks=null,this.m_segmentWeights=null,this.m_segmentRanks=null,this.m_indices=[],this.m_deletedIndices=[],this.m_pathAreas=[],this.m_pathLengths=[],this.m_pathindices=[],this.m_deletedPathIndices=[],this.m_geometryIndices=[],this.m_selectedVertices=[],this.m_helperPoint=null,this.m_forceSetEnvelope=ps.constructEmpty(),this.m_hasForceSetEnvelope=0,this.m_workPoint2D=y.getNAN(),this.m_workPoint2_2D=y.getNAN(),this.m_curveStitcher=null,this.m_pathCount=0,this.m_pointCount=0,this.m_firstGeometry=v,this.m_lastGeometry=v,this.m_vertexIndexList=new At(5),this.m_pathIndexList=new At(8),this.m_geometryIndexList=new At(8),this.m_bHasAttributes=!1,this.m_selectedCount=0,this.m_selectionIndex=-1,this.m_selection=!1,this.m_bucketSort=new Ys,this.m_segmentParentageIndex=-1}getTotalPointCount(){return this.m_pointCount}getEnvelope2D(t){if(this.m_hasForceSetEnvelope!==0)return new F(this.m_forceSetEnvelope.xmin,this.m_forceSetEnvelope.ymin,this.m_forceSetEnvelope.xmax,this.m_forceSetEnvelope.ymax);const e=this.hasCurves(),s=F.constructEmpty(),i=this.queryVertexIterator();let n=!0;for(let o=i.next();o!==v;o=i.next()){if(n?s.merge(this.getXY(o)):s.mergeNe(this.getXY(o)),e){const a=this.getSegment(o);if(a!==null){const h=F.constructEmpty();a.queryLooseEnvelope(h),s.mergeEnvelope2D(h)}}n=!1}return s}getEnvelope3D(t){return b(0),ps.constructEmpty()}forceSetEnvelope2D(t){this.m_hasForceSetEnvelope=1,this.m_forceSetEnvelope.setCoords(t.xmin,t.ymin,0,t.xmax,t.ymax,0)}forceSetEnvelope3D(t){b(0)}forgetForceSetEnvelope(){this.m_hasForceSetEnvelope=0}getGeometryCount(){return this.m_geometryIndexList.size()}addGeometry(t,e){const s=t.getGeometryType();if(lt(s))return this.addMultiPath(t,e);if(s===T.enumMultiPoint)return this.addMultiPoint(t,e);if(s===T.enumPoint)return this.addPoint_(t,e);if(s===T.enumEnvelope){const i=new ct;return i.addEnvelope(t,!1),this.addMultiPath(i,e)}H("")}appendGeometry(t,e){this.mergeVertexDescription(e.getDescription());const s=e.getGeometryType();lt(s)?this.appendMultiPath(t,e):s!==T.enumMultiPoint?H(""):this.appendMultiPoint(t,e)}assignRankToGeometryVertices(t,e){e<Bt&&(e=Bt);const s=this.queryVertexIterator();for(let i=s.next();i!==v;i=s.next())this.setRank(i,e),this.setSegmentRank(i,e)}collapseAllGeometriesToFirst(){this.collapseGeometriesToFirst(T.enumUnknown)}collapseGeometriesToFirst(t){this.dbgVerifyVertexCounts();let e=v,s=-1,i=-1;for(let n=this.getFirstGeometry();n!==v;)if(t!==T.enumUnknown&&this.getGeometryType(n)!==t)n=this.getNextGeometry(n);else{if(e===v){e=n,s=this.getPathCount(e),i=this.getPointCount(e),n=this.getNextGeometry(n);continue}for(let m=this.getFirstPath(n);m!==v;m=this.getNextPath(m))this.setPathGeometry(m,e);s+=this.getPathCount(n),i+=this.getPointCount(n);const o=this.getLastPath(e),a=this.getFirstPath(n);o!==v?this.setNextPath(o,a):this.setFirstPath(e,a),a!==v&&(this.setPrevPath(a,o),this.setLastPath(e,this.getLastPath(n))),this.setFirstPath(n,v),this.setLastPath(n,v);const h=n;n=this.getNextGeometry(n),this.setGeometryVertexCount(h,0),this.removeGeometry(h)}return e!==v&&(this.setGeometryVertexCount(e,i),this.setGeometryPathCount(e,s),this.dbgVerifyVertexCounts()),e}setFillRule(t,e){let s=this.m_geometryIndexList.getField(t,2);s&=-134217729,s|=e===1?134217728:0,this.m_geometryIndexList.setField(t,2,s)}getFillRule(t){return 134217728&this.m_geometryIndexList.getField(t,2)?1:0}setGeometryModified(t,e){let s=this.m_geometryIndexList.getField(t,2);!!(67108864&s)!==e&&(s&=-67108865,s|=e?67108864:0,this.m_geometryIndexList.setField(t,2,s))}getGeometryModified(t){return!!(67108864&this.m_geometryIndexList.getField(t,2))}setGeometryModifiedWithVertex(t,e){const s=this.getPathFromVertex(t),i=this.getGeometryFromPath(s);this.setGeometryModified(i,e)}getGeometryModifiedWithVertex(t){const e=this.getPathFromVertex(t),s=this.getGeometryFromPath(e);return this.getGeometryModified(s)}swapGeometry(t,e){const s=this.getFirstPath(t),i=this.getFirstPath(e),n=this.getLastPath(t),o=this.getLastPath(e);for(let g=this.getFirstPath(t);g!==v;g=this.getNextPath(g))this.setPathGeometry(g,e);for(let g=this.getFirstPath(e);g!==v;g=this.getNextPath(g))this.setPathGeometry(g,t);this.setFirstPath(t,i),this.setFirstPath(e,s),this.setLastPath(t,o),this.setLastPath(e,n);const a=this.getPointCount(t),h=this.getPathCount(t),m=this.getPointCount(e),l=this.getPathCount(e);this.setGeometryVertexCount(t,m),this.setGeometryVertexCount(e,a),this.setGeometryPathCount(t,l),this.setGeometryPathCount(e,h);const u=this.m_geometryIndexList.getField(t,2),c=this.m_geometryIndexList.getField(e,2);this.m_geometryIndexList.setField(t,2,c),this.m_geometryIndexList.setField(e,2,u)}addPathFromMultiPath(t,e,s){const i=this.createGeometry(s?T.enumPolygon:T.enumPolyline,t.getDescription()),n=t.getImpl();if(t.getPathSize(e)<2)return i;this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+t.getPathSize(e)),this.m_verticesMp.addPoints(t,t.getPathStart(e),n.getPathEnd(e)),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0);const o=this.insertPath(i,v);this.setClosedPath(o,n.isClosedPath(e)||s);const a=this.m_segments!==null||n.getSegmentFlagsStreamRef()!==null;for(let h=n.getPathStart(e),m=n.getPathEnd(e);h<m;h++){const l=this.insertVertex_(o,v,null,!1);if(a){const u=this.getVertexIndex(l);if(1&n.getSegmentFlags(h))this.setSegmentToIndex(u,null);else{const c=new it;n.querySegment(h,c,!0),this.setSegmentToIndex(u,c.releaseSegment())}}}return n.isStrongPathStart(e)&&this.setStrongPathStart(o,!0),n.isStrongPathEnd(e)&&this.setStrongPathEnd(o,!0),i}getGeometry(t){const e=this.getGeometryType(t),s=Bf(e,this.m_verticesMp.getDescription()),i=this.getPointCount(t);if(i===0)return s;if(lt(e)){const n=s.getImpl(),o=this.getPathCount(t),a=be(o+1),h=_i(o+1,0),m=s.getDescription(),l=this.hasCurves();for(let u=0,c=m.getAttributeCount();u<c;u++){const g=m.getSemantics(u),_=ru.getComponentCount(g),d=Qc(g,i),p=this.m_vertices.getAttributeStreamRef(g);let f=0,x=0,E=0;for(let P=this.getFirstPath(t);P!==v;P=this.getNextPath(P)){let C=0;this.isClosedPath(P)&&(C|=1),this.isExterior(P)&&(C|=8),this.isStrongPathStart(P)&&(C|=2),this.isStrongPathEnd(P)&&(C|=4),C&&h.setBits(x,C);const S=this.getPathSize(P);if(a.write(x++,E),E+=S,g===0){const I=p,w=d;let D;for(let N=this.getFirstVertex(P);f<E;N=this.getNextVertex(N),f++){const A=this.getVertexIndex(N);D=I.readPoint2D(2*A),w.writePoint2D(2*f,D)}}else for(let I=this.getFirstVertex(P);f<E;I=this.getNextVertex(I),f++){const w=this.getVertexIndex(I);for(let D=0;D<_;D++){const N=p.readAsDbl(w*_+D);d.writeAsDbl(f*_+D,N)}}}n.setAttributeStreamRef(g,d),a.write(o,i)}if(n.setPathFlagsStreamRef(h),n.setPathStreamRef(a),n.notifyModifiedFlags(65535),l){let u=0,c=0;for(let g=this.getFirstPath(t);g!==v;g=this.getNextPath(g)){u+=this.getPathSize(g);for(let _=this.getFirstVertex(g);c<u;_=this.getNextVertex(_)){const d=this.getSegment(_);d!==null&&d.isCurve()&&n.replaceSegment(c,d,!0),c++}}}}else if(e===T.enumMultiPoint){const n=s.getImpl(),o=s.getDescription();n.reserve(i),n.resizeNoInit(i);for(let a=0,h=o.getAttributeCount();a<h;a++){const m=o.getSemantics(a),l=ru.getComponentCount(m),u=n.getAttributeStreamRef(m),c=this.m_vertices.getAttributeStreamRef(m);let g=0;const _=this.getFirstPath(t),d=this.getPathSize(_);for(let p=this.getFirstVertex(_);g<d;p=this.getNextVertex(p),g++){const f=this.getVertexIndex(p);for(let x=0;x<l;x++){const E=c.readAsDbl(f*l+x);u.writeAsDbl(g*l+x,E)}}n.setAttributeStreamRef(m,u)}n.notifyModifiedFlags(65535)}else $("getGeometry");return s}queryPointGeometryOnly(t,e){this.getGeometryType(t)!==T.enumMultiPoint&&H("get_point_geometry_only");const s=this.getPointCount(t);if(s>1&&H("get_point_geometry_only"),s===0)return e.assignVertexDescription(this.m_vertexDescription),void e.setEmpty();const i=this.getFirstPath(t),n=this.getFirstVertex(i);this.queryPoint(n,e)}removeGeometry(t){for(let i=this.getFirstPath(t);i!==v;i=this.removePath(i));const e=this.getPrevGeometry(t),s=this.getNextGeometry(t);return e!==v?this.setNextGeometry(e,s):this.m_firstGeometry=s,s!==v?this.setPrevGeometry(s,e):this.m_lastGeometry=e,this.freeGeometry(t),s}createGeometry(t,e){e===void 0&&(e=_e());const s=this.newGeometry(t);return this.m_vertices||(this.m_verticesMp=new Zt({vd:e}),this.m_vertices=this.m_verticesMp.getImpl()),this.mergeVertexDescription(e),this.m_firstGeometry===v?(this.m_firstGeometry=s,this.m_lastGeometry=s):(this.setPrevGeometry(s,this.m_lastGeometry),this.setNextGeometry(this.m_lastGeometry,s),this.m_lastGeometry=s),s}getFirstGeometry(){return this.m_firstGeometry}getLastGeometry(){return this.m_lastGeometry}getNextGeometry(t){return this.m_geometryIndexList.getField(t,1)}getPrevGeometry(t){return this.m_geometryIndexList.getField(t,0)}getGeometryType(t){return 16777215&this.m_geometryIndexList.getField(t,2)}setGeometryUserIndex(t,e,s){const i=this.m_geometryIndices[e],n=this.getGeometryIndex(t);n>=i.size()&&i.resize(Math.max(1.25*n,16),-1),i.write(n,s)}getGeometryUserIndex(t,e){const s=this.getGeometryIndex(t),i=this.m_geometryIndices[e];return s<i.size()?i.read(s):-1}createGeometryUserIndex(){for(let e=0;e<this.m_geometryIndices.length;e++)if(this.m_geometryIndices[e]===null)return this.m_geometryIndices[e]=be(0),e;this.m_geometryIndices.push(be(0));const t=this.m_geometryIndices.length-1;return b(t>=0&&t<=Number.MAX_SAFE_INTEGER),t}removeGeometryUserIndex(t){for(this.m_geometryIndices[t]=null;this.m_geometryIndices.length>0&&this.m_geometryIndices.at(-1)===null;)this.m_geometryIndices.pop()}getFirstPath(t){return this.m_geometryIndexList.getField(t,3)}getLastPath(t){return this.m_geometryIndexList.getField(t,4)}hasPointFeatures(){for(let t=this.getFirstGeometry();t!==v;t=this.getNextGeometry(t))if(!lt(this.getGeometryType(t)))return!0;return!1}getPointCount(t){return this.m_geometryIndexList.getField(t,5)}getPathCount(t){return this.m_geometryIndexList.getField(t,6)}filterClosePoints(t,e,s,i,n){const o=t*t;let a=0;const h=this.hasCurves(),m=this.hasSegmentParentage(),l=!0;for(let u=n===v?this.getFirstGeometry():n;u!==v;u=n===v?this.getNextGeometry(u):v){const c=this.getGeometryType(u);if(!lt(c)||s&&c!==T.enumPolygon)continue;const g=this.getGeometryType(u)===T.enumPolygon;let _=this.getGeometryModified(u);for(let d=this.getFirstPath(u);d!==v;){let p=0;for(let P=this.getFirstVertex(d);p<Math.trunc(this.getPathSize(d)/2);){const C=this.getNextVertex(P);if(C===v)break;const S=this.getXY(P),I=this.getXY(C);let w=y.sqrDistance(S,I),D=!0;do if(w<=o){if(h){const N=this.getSegment(P);if(N!==null){const A=N.calculateLength2D();if(w=A*A,w>o)break}}if(w===0?a===0&&(a=-1):a=1,C!==this.getLastVertex(d)){const N=m&&(this.getSegmentParentageBreakVertex(P)||this.getSegmentParentageBreakVertex(C));if(this.transferAllDataToTheVertex(C,P,l),this.removeVertex(C,!1),i&&!_&&(this.setGeometryModified(u,!0),_=!0),m&&P!==C){this.setSegmentParentageBreakVertex(P,N);const A=this.getNextVertex(P);b(A!==v),this.isDiscontinuousSegmentParentage(A)&&this.setSegmentParentageBreakVertex(A,!0)}}D=!1}while(!1);D&&(P=this.getNextVertex(P)),p++}let f=this.getFirstVertex(d);for(let P=this.isClosedPath(d)?f:this.getLastVertex(d);this.getPathSize(d)>0;){const C=this.getPrevVertex(P);if(C===v)break;{const S=this.getXY(C),I=this.getXY(P);let w=y.sqrDistance(S,I),D=!0;do if(w<=o){if(h){const A=this.getSegment(C);if(A!==null){const M=A.calculateLength2D();if(w=M*M,w>o)break}}if(w===0?a===0&&(a=-1):a=1,m){b(this.m_segmentParentageIndex>=0);const A=this.getUserIndex(P,this.m_segmentParentageIndex);this.transferAllDataToTheVertex(C,P,l),this.setUserIndex(P,this.m_segmentParentageIndex,A)}else this.transferAllDataToTheVertex(C,P,l);const N=m&&(this.getSegmentParentageBreakVertex(P)||this.getSegmentParentageBreakVertex(C));this.removeVertex(C,!0),i&&!_&&(this.setGeometryModified(u,!0),_=!0),m&&C!==P&&(N||this.isDiscontinuousSegmentParentage(P))&&this.setSegmentParentageBreakVertex(P,!0),f===C&&(f=this.getFirstVertex(d)),D=!1}while(!1);if(D&&(P=this.getPrevVertex(P),P===f))break}}const x=this.getPathSize(d);let E=e&&x<(g?3:2);E&&g&&x===2&&h&&(E=!this.pathHasCurves(d)),E?(d=this.removePath(d),a===0&&(a=-1),i&&!_&&(this.setGeometryModified(u,!0),_=!0)):d=this.getNextPath(d)}}return a}filterClosePoints3D(t,e,s,i,n,o){return b(0),0}hasDegenerateSegments(t){for(let e=this.getFirstGeometry();e!==v;e=this.getNextGeometry(e))if(lt(this.getGeometryType(e)))for(let s=this.getFirstPath(e);s!==v;){const i=this.getPathSize(s);if(i===0)return!0;let n=this.getFirstVertex(s);for(let o=0;o<i;o++){const a=this.getNextVertex(n);if(a===v)break;const h=this.getVertexIndex(n),m=this.getSegmentFromIndex(h);let l=0;if(m!==null){if(l=m.calculateLowerLength2D(),l<=t&&(l=m.calculateUpperLength2D(),l<=t||(l=m.calculateLength2D(),l<=t)))return!0}else{const u=this.getVertexIndex(a);if(l=this.m_vertices.getShortestDistance(h,u),l<=t)return!0}n=a}s=this.getNextPath(s)}return!1}hasDegenerateSegments3D(t,e){return b(0),!1}transferAllDataToTheVertex(t,e,s=!1){const i=this.getVertexIndex(t),n=this.getVertexIndex(e);if(s){let a=1,h=1;if(this.m_ranks&&(a=this.getRankWithIndex(i),h=this.getRankWithIndex(n)),a>h&&this.setRankWithIndex(n,a),a>=h&&this.m_weights){const m=this.getWeightWithIndex(i),l=this.getWeightWithIndex(n);(a>h||m>l)&&this.setWeightWithIndex(n,m)}}else{if(this.m_weights){const a=this.getWeightWithIndex(i);this.setWeightWithIndex(n,a)}if(this.m_ranks){const a=this.getRankWithIndex(i);this.setRankWithIndex(n,a)}}if(this.m_segmentWeights){const a=this.getSegmentWeightWithIndex(i);this.setSegmentWeightWithIndex(n,a)}if(this.m_segmentRanks){const a=this.getSegmentRankWithIndex(i);this.setSegmentRankWithIndex(n,a)}for(let a=0,h=this.m_indices.length;a<h;a++)if(a!==this.m_selectionIndex&&this.m_indices[a]!==null){const m=this.getUserIndex(t,a);this.setUserIndex(e,a,m)}const o=this.selected(t);o!==this.selected(e)&&(o?this.select(e):this.unselect(e))}splitSegmentAxisAware(t,e,s,i,n){let o=0;const a=this.getNextVertex(t);a===v&&H("");const h=this.getVertexIndex(t),m=this.getVertexIndex(a),l=this.getSegmentFromIndex(h);let u=this.m_vertices.getShortestDistance(h,m);const c=this.getPathFromVertex(t),g=this.m_bHasAttributes;g&&l&&(u=l.calculateLength2D());const _=this.getSegmentParentage(t),d=this.getHelperPoint();if(l){let p=0,f=0,x=v;for(let E=0;E<s;E++){const P=e[E];if(p<P&&P<1){const C=l.cut(p,P);if(i!==null&&(E>0&&C.setStartXY(i[E-1]),C.setEndXY(i[E]),C.normalizeAfterEndpointChange(),f=E),g){const w=u>0?l.calculateSubLengthFromStart(P)/u:0;this.m_vertices.interpolateTwoVertices(h,m,w,d)}d.setXY(C.getEndXY()),x=this.insertVertex(c,a,d),o++;const S=this.getPrevVertex(x),I=this.getVertexIndex(S);this.setSegmentToIndex(I,C),_!==-1&&this.setSegmentParentageAndBreak(x,_,!1),p=P}}if(x!==v){const E=l.cut(p,1);i!==null&&(E.setStartXY(i[f]),E.normalizeAfterEndpointChange());const P=this.getVertexIndex(x);this.setSegmentToIndex(P,E)}}else{let p=0;for(let f=0;f<s;f++){const x=e[f];if(p<x&&x<1){this.m_vertices.interpolateTwoVertices(h,m,x,d);const E=this.insertVertex(c,a,d);o++,_!==-1&&this.setSegmentParentageAndBreak(E,_,!1)}p=x}}return o}splitSegment(t,e,s,i=null){return this.splitSegmentAxisAware(t,e,s,i,-1)}snapControlPoints(t,e,s){this.getNextVertex(t)===v&&H("");let i=t,n=!1;for(let o=0;o<e;++o){const a=this.getVertexIndex(i),h=this.getSegmentFromIndex(a);if(h){const m=h.snapControlPoints(s);n||=m}i=this.getNextVertex(i)}return n}snapControlPointsOnSelection(t){if(!this.hasCurves())return!1;let e=0;const s=this.queryVertexIteratorOnSelection();for(let i=s.next();i!==v;i=s.next()){const n=this.getVertexIndex(i),o=this.getSegmentFromIndex(n);o&&(e|=o.snapControlPoints(t)?1:0)}return e!==0}calculateSubLength2D(t,e,s){return b(0),0}setPoint(t,e,s){if(this.setPointOnly(t,e),this.m_segments!==null){const i=this.getVertexIndex(t),n=this.getSegmentFromIndex(i);n!==null&&(n.setStartXY(e.getXY()),n.normalizeAfterEndpointChange(),s&&n.ensureXYMonotone());const o=this.getPrevVertex(t);if(o!==v){const a=this.getVertexIndex(o),h=this.getSegmentFromIndex(a);h!==null&&(h.setEndXY(e.getXY()),h.normalizeAfterEndpointChange(),s&&h.ensureXYMonotone())}}}setPointEx(t,e,s,i,n){this.setPoint(t,e,n);const o=this.getVertexIndex(t);this.setWeightWithIndex(o,i),this.setRankWithIndex(o,s)}setPointOnly(t,e){const s=this.getVertexIndex(t);this.m_vertices.setPointByValNoCurves(s,e)}setPointOnlyEx(t,e,s,i){b(0)}queryPoint(t,e){const s=this.getVertexIndex(t);this.m_vertices.getPointByVal(s,e)}setXY(t,e){this.setXYCoords(t,e.x,e.y)}setXYCoords(t,e,s){const i=this.getVertexIndex(t);if(this.m_vertices?.setXYCoordsNoCurves(i,e,s),this.m_segments!==null){const n=this.getSegmentFromIndex(i);n!==null&&(n.setStartXYCoords(e,s),n.normalizeAfterEndpointChange());const o=this.getPrevVertex(t);if(o!==v){const a=this.getVertexIndex(o),h=this.getSegmentFromIndex(a);h!=null&&(h.setEndXYCoords(e,s),h.normalizeAfterEndpointChange())}}}setXYMonotonic(t,e,s){const i=this.getVertexIndex(t);if(this.m_vertices.setXYCoordsNoCurves(i,e,s),this.m_segments!==null){const n=this.getSegmentFromIndex(i);if(n!==null){const a=n.getEndXY();n.setCoordsForIntersector(new y(e,s),a,!1),n.ensureXYMonotone()}const o=this.getPrevVertex(t);if(o!==v){const a=this.getVertexIndex(o),h=this.getSegmentFromIndex(a);if(h!==null){const m=h.getStartXY();h.setCoordsForIntersector(m,new y(e,s),!1),h.ensureXYMonotone()}}}}setXYMonotonicPoint2D(t,e){this.setXYMonotonic(t,e.x,e.y)}queryXY(t,e){const s=this.getVertexIndex(t);return this.m_vertices.queryXY(s,e)}getXY(t){const e=this.getVertexIndex(t);return this.m_vertices.getXY(e)}getXYWithIndex(t){return this.m_xyStream.readPoint2D(2*t)}static setSegDefault(t,e,s){b(0)}setXYZ(t,e,s){b(0)}setXYZCoords(t,e,s,i){b(0)}queryXYZ(t,e){b(0)}getXYZ(t){return b(0),mt.getNAN()}getXYZWithIndex(t){return b(0),mt.getNAN()}mergeVertexDescription(t){this.m_verticesMp.mergeVertexDescription(t),this.m_vertexDescription=this.m_verticesMp.getDescription(),this.m_bHasAttributes=this.m_vertexDescription.getAttributeCount()>1}addAttribute(t){b(0)}getAttributeAsDbl(t,e,s){return this.m_vertices.getAttributeAsDbl(t,this.getVertexIndex(e),s)}queryAttributeAsDbl(t,e,s,i){b(0)}setAttribute(t,e,s,i){b(0)}setAttributeInt(t,e,s,i){b(0)}getVertexDescription(){return this.m_vertexDescription}getMinPathVertexY(t){return b(0),0}getVertexIndex(t){return this.m_vertexIndexList.getField(t,0)}getY(t){const e=this.getVertexIndex(t);return this.m_vertices.queryXY(e,this.m_workPoint2D),this.m_workPoint2D.y}getX(t){return this.getXY(t).x}isEqualXY(t,e){return this.queryXY(t,this.m_workPoint2D),this.queryXY(e,this.m_workPoint2_2D),this.m_workPoint2D.isEqualPoint2D(this.m_workPoint2_2D)}isEqualXYPoint2D(t,e){return this.queryXY(t,this.m_workPoint2D),this.m_workPoint2D.isEqualPoint2D(e)}isEqualXYZPoint3D(t,e){return b(0),!1}setWeight(t,e){e<1&&(e=1);const s=e===1;if(this.m_weights==null){if(s)return;this.m_weights=Gi(this.m_vertices.getPointCount(),1)}const i=this.getVertexIndex(t);if(i>=this.m_weights.size()){if(s)return;this.m_weights.resize(i+1,1)}this.m_weights.write(i,e)}setWeightWithIndex(t,e){e<1&&(e=1);const s=e===1;if(this.m_weights===null){if(s)return;this.m_weights=Gi(this.m_vertices.getPointCount(),1)}if(t>=this.m_weights.size()){if(s)return;this.m_weights.resize(t+1,1)}this.m_weights.write(t,e)}getWeight(t){if(this.m_weights===null)return 1;const e=this.getVertexIndex(t);return e>=this.m_weights.size()?1:this.m_weights.read(e)}getWeightWithIndex(t){return this.m_weights===null||t>=this.m_weights.size()?1:this.m_weights.read(t)}getRank(t){if(this.m_ranks===null)return Bt;const e=this.getVertexIndex(t);return e>=this.m_ranks.size()?Bt:this.m_ranks.read(e)}getRankWithIndex(t){return this.m_ranks===null||t>=this.m_ranks.size()?Bt:this.m_ranks.read(t)}setRank(t,e){e<Bt&&(e=Bt);const s=e===Bt;if(this.m_ranks===null){if(s)return;this.m_ranks=be(this.m_vertices.getPointCount(),Bt)}const i=this.getVertexIndex(t);if(i>=this.m_ranks.size()){if(s)return;this.m_ranks.resize(i+1,Bt)}this.m_ranks.write(i,e)}setRankWithIndex(t,e){e<Bt&&(e=Bt);const s=e===Bt;if(this.m_ranks===null){if(s)return;this.m_ranks=be(this.m_vertices.getPointCount(),Bt)}if(t>=this.m_ranks.size()){if(s)return;this.m_ranks.resize(t+1,Bt)}this.m_ranks.write(t,e)}setSegmentWeight(t,e){e<1&&(e=1);const s=e===1;if(this.m_segmentWeights===null){if(s)return;this.m_segmentWeights=Gi(this.m_vertices.getPointCount(),1)}const i=this.getVertexIndex(t);if(i>=this.m_segmentWeights.size()){if(s)return;this.m_segmentWeights.resize(i+1,1)}this.m_segmentWeights.write(i,e)}setSegmentWeightWithIndex(t,e){e<1&&(e=1);const s=e===1;if(this.m_segmentWeights==null){if(s)return;this.m_segmentWeights=Gi(this.m_vertices.getPointCount(),1)}if(t>=this.m_segmentWeights.size()){if(s)return;this.m_segmentWeights.resize(t+1,1)}this.m_segmentWeights.write(t,e)}getSegmentWeight(t){if(this.m_segmentWeights===null)return 1;const e=this.getVertexIndex(t);return e>=this.m_segmentWeights.size()?1:this.m_segmentWeights.read(e)}getSegmentWeightWithIndex(t){return this.m_segmentWeights==null||t>=this.m_segmentWeights.size()?1:this.m_segmentWeights.read(t)}getSegmentRank(t){if(this.m_segmentRanks===null)return Fh.st_defaultRank;const e=this.getVertexIndex(t);return e>=this.m_segmentRanks.size()?Fh.st_defaultRank:this.m_segmentRanks.read(e)}getSegmentRankWithIndex(t){return this.m_segmentRanks===null||t>=this.m_segmentRanks.size()?Bt:this.m_segmentRanks.read(t)}setSegmentRank(t,e){e<Bt&&(e=Bt);const s=e===Bt;if(this.m_segmentRanks===null){if(s)return;this.m_segmentRanks=be(this.m_vertices.getPointCount(),Bt)}const i=this.getVertexIndex(t);if(i>=this.m_segmentRanks.size()){if(s)return;this.m_segmentRanks.resize(i+1,Bt)}this.m_segmentRanks.write(i,e)}setSegmentRankWithIndex(t,e){e<Bt&&(e=Bt);const s=e===Bt;if(this.m_segmentRanks===null){if(s)return;this.m_segmentRanks=be(this.m_vertices.getPointCount(),Bt)}if(t>=this.m_segmentRanks.size()){if(s)return;this.m_segmentRanks.resize(t+1,Bt)}this.m_segmentRanks.write(t,e)}removeWeights(){this.m_weights=null,this.m_segmentWeights=null}removeRanks(){this.m_ranks=null,this.m_segmentRanks=null}setUserIndex(t,e,s){const i=this.m_indices[e],n=this.getVertexIndex(t);if(i.size()<=n){if(s===-1)return;i.resize(this.m_vertices.getPointCount(),-1)}i.write(n,s)}getUserIndex(t,e){const s=this.getVertexIndex(t),i=this.m_indices[e];return s<i.size()?i.read(s):-1}addToUserIndex(t,e,s){const i=this.m_indices[e],n=this.getVertexIndex(t);i.size()<=n&&i.resize(this.m_vertices.getPointCount(),-1);const o=i.read(n);i.write(n,o+s)}createUserIndex(){for(let e=0;e<this.m_indices.length;e++)if(this.m_indices[e]===null)return this.m_indices[e]=this.allocateIndex(),e;this.m_indices.push(this.allocateIndex());const t=this.m_indices.length-1;return b(t>=0&&t<=Ie()),t}createUserIndexUninitialized(){for(let e=0;e<this.m_indices.length;e++)if(this.m_indices[e]===null)return this.m_indices[e]=this.allocateIndex(!1),e;this.m_indices.push(this.allocateIndex(!1));const t=this.m_indices.length-1;return b(t>=0&&t<=Number.MAX_SAFE_INTEGER),t}fillUserIndexForGeometry(t,e,s){const i=this.m_indices[e],n=i.size();for(let o=this.getFirstPath(t);o!==v;o=this.getNextPath(o)){let a=this.getFirstVertex(o);for(let h=0,m=this.getPathSize(o);h<m;h++,a=this.getNextVertex(a)){const l=this.getVertexIndex(a);l<n&&i.write(l,s)}}}fillUserIndexForSelection(t,e){b(0)}removeUserIndex(t){for(this.recycleUserIndex(this.m_indices[t]),this.m_indices[t]=null;this.m_indices.length>0&&this.m_indices[this.m_indices.length-1]===null;)this.m_indices.pop()}replaceCurveWithLine(t){if(this.m_segments!==null){const e=this.getVertexIndex(t);this.setSegmentToIndex(e,null)}}queryLineConnector(t,e,s=!1){const i=this.getNextVertex(t);if(i===v)return!1;if(!this.m_bHasAttributes||s){const n=this.getXY(t);e.setStartXY(n);const o=this.getXY(i);e.setEndXY(o)}else{const n=new st({vd:this.getVertexDescription()});this.queryPoint(t,n),e.setStart(n),this.queryPoint(i,n),e.setEnd(n)}return!0}queryLineConnector3D(t,e,s=!1){return b(0),!1}hasCurves(){return this.m_segments!==null}geometryHasCurves(t){return b(0),!1}pathHasCurves(t){if(!this.hasCurves())return!1;const e=this.getFirstVertex(t);if(e===v)return!1;const s=this.getPathSize(t);let i=e;for(let n=0;n<s;n++,i=this.getNextVertex(i)){const o=this.getSegment(i);if(o!==null&&o.getGeometryType()!==T.enumLine)return!0}return!1}insertPath(t,e){let s=v;e!==v?(t!==this.getGeometryFromPath(e)&&H(""),s=this.getPrevPath(e)):s=this.getLastPath(t);const i=this.newPath(t);return e!==v&&this.setPrevPath(e,i),this.setNextPath(i,e),this.setPrevPath(i,s),s!==v?this.setNextPath(s,i):this.setFirstPath(t,i),e===v&&this.setLastPath(t,i),this.setGeometryPathCount(t,this.getPathCount(t)+1),i}removePath(t){const e=this.getPrevPath(t),s=this.getNextPath(t),i=this.getGeometryFromPath(t);return e!==v?this.setNextPath(e,s):this.setFirstPath(i,s),s!==v?this.setPrevPath(s,e):this.setLastPath(i,e),this.clearPath(t),this.setGeometryPathCount(i,this.getPathCount(i)-1),this.freePath(t),s}clearPath(t){const e=this.getFirstVertex(t);if(e!==v){let s=e;for(let n=0,o=this.getPathSize(t);n<o;n++){const a=s;s=this.getNextVertex(s),this.freeVertex(a)}const i=this.getGeometryFromPath(t);this.setGeometryVertexCount(i,this.getPointCount(i)-this.getPathSize(t))}this.setPathSize(t,0)}getNextPath(t){return this.m_pathIndexList.getField(t,2)}getPrevPath(t){return this.m_pathIndexList.getField(t,1)}getPathSize(t){return this.m_pathIndexList.getField(t,3)}isClosedPath(t){return!!(1&this.getPathFlags(t))}setClosedPath(t,e){if(this.isClosedPath(t)===e)return;if(this.getPathSize(t)>0){const i=this.getFirstVertex(t),n=this.getLastVertex(t);if(e){this.setNextVertex(n,i),this.setPrevVertex(i,n);const o=this.getVertexIndex(n);this.setSegmentToIndex(o,null)}else{this.setNextVertex(n,v),this.setPrevVertex(i,v);const o=this.getVertexIndex(n);this.setSegmentToIndex(o,null)}}const s=(1|this.getPathFlags(t))-1;this.setPathFlags(t,s|(e?1:0))}closeAllPaths(t){b(0)}isStrongPathStart(t){return!!(8&this.getPathFlags(t))}isStrongPathEnd(t){return!!(16&this.getPathFlags(t))}setStrongPathStart(t,e){const s=(8|this.getPathFlags(t))-8;this.setPathFlags(t,s|(e?8:0))}setStrongPathEnd(t,e){const s=(16|this.getPathFlags(t))-16;this.setPathFlags(t,s|(e?16:0))}getGeometryFromPath(t){return this.m_pathIndexList.getField(t,7)}isExterior(t){return!!(2&this.getPathFlags(t))}setExterior(t,e){const s=(2|this.getPathFlags(t))-2;this.setPathFlags(t,s|(e?2:0))}getRingArea(t){if(this.isRingAreaValid(t))return this.m_pathAreas[this.getPathIndex(t)];const e=this.getFirstVertex(t);if(e===v)return 0;const s=this.getXY(e),i=new Ce(0),n=this.getPathSize(t);if(n>2){const a=s.clone(),h=a.x,m=a.y;let l=this.getNextVertex(e);const u=this.getXY(l);l=this.getNextVertex(l);const c=y.getNAN();for(let g=2;g<n;g++,l=this.getNextVertex(l))this.queryXY(l,c),i.pe((c.x-a.x)*(u.y-m)),a.setCoordsPoint2D(u),u.setCoordsPoint2D(c);i.pe((h-a.x)*(u.y-m))}if(this.hasCurves()){let a=e;for(let h=0;h<n;h++,a=this.getNextVertex(a)){const m=this.getSegment(a);if(m===null||m.getGeometryType()===T.enumLine)continue;const l=2*m.calculateArea2DHelper();i.pe(l)}}this.setRingAreaValid(t,!0);const o=.5*i.getResult();return this.m_pathAreas[this.getPathIndex(t)]=o,o}getPathIndexInternal(t){return this.getPathIndex(t)}getPathInternalIndexFromVertex(t){return this.getPathIndex(this.getPathFromVertex(t))}setPathUserIndex(t,e,s){const i=this.m_pathindices[e],n=this.getPathIndex(t);i.size()<this.m_pathAreas.length&&i.resize(this.m_pathAreas.length,-1),i.write(n,s)}getPathUserIndex(t,e){const s=this.getPathIndex(t),i=this.m_pathindices[e];return s<i.size()?i.read(s):-1}createPathUserIndex(){for(let e=0;e<this.m_pathindices.length;e++)if(this.m_pathindices[e]===null)return this.m_pathindices[e]=this.allocatePathIndex(),e;this.m_pathindices.push(this.allocatePathIndex());const t=this.m_pathindices.length-1;return b(t>=0&&t<=Number.MAX_SAFE_INTEGER),t}fillPathUserIndexForGeometry(t,e,s){const i=this.m_pathindices[e],n=i.size();for(let o=this.getFirstPath(t);o!==v;o=this.getNextPath(o)){const a=this.getPathIndex(o);a<n&&i.write(a,s)}}removePathUserIndex(t){for(this.recyclePathUserIndex(this.m_pathindices[t]),this.m_pathindices[t]=null;this.m_pathindices.length>0&&this.m_pathindices.at(-1)===null;)this.m_pathindices.pop()}movePath(t,e,s){if(s===v&&H(""),e===s)return;const i=this.getNextPath(s);let n=this.getPrevPath(s);const o=this.getGeometryFromPath(s);n===v?this.setFirstPath(o,i):this.setNextPath(n,i),i===v?this.setLastPath(o,n):this.setPrevPath(i,n),this.setGeometryVertexCount(o,this.getPointCount(o)-this.getPathSize(s)),this.setGeometryPathCount(o,this.getPathCount(o)-1),n=e===v?this.getLastPath(t):this.getPrevPath(e),this.setPrevPath(s,n),this.setNextPath(s,e),e===v?this.setLastPath(t,s):this.setPrevPath(e,s),n===v?this.setFirstPath(t,s):this.setNextPath(n,s),this.setGeometryVertexCount(t,this.getPointCount(t)+this.getPathSize(s)),this.setGeometryPathCount(t,this.getPathCount(t)+1),this.setPathGeometry(s,t)}addVertex(t,e){return this.m_vertices.getPointByVal(this.getVertexIndex(e),this.getHelperPoint()),this.insertVertex_(t,v,this.getHelperPoint(),!1)}insertVertex(t,e,s){return this.insertVertex_(t,e,s,!0)}removeVertex(t,e){const s=this.getPathFromVertex(t),i=this.getPrevVertex(t),n=this.getNextVertex(t);i!==v&&this.setNextVertex(i,n);const o=this.getPathSize(s);if(t===this.getFirstVertex(s)&&this.setFirstVertex(s,o>1?n:v),n!==v&&this.setPrevVertex(n,i),t===this.getLastVertex(s)&&this.setLastVertex(s,o>1?i:v),this.hasCurves()&&i!==v&&n!==v){const h=this.getVertexIndex(t),m=this.getVertexIndex(i),l=this.getVertexIndex(n);if(e){const u=this.getSegmentFromIndex(m);if(u!==null){const c=this.m_vertices.getXY(l);u.setEndXY(c),u.normalizeAfterEndpointChange()}this.setSegmentToIndex(h,null)}else{const u=this.getSegmentFromIndex(h);if(this.setSegmentToIndex(h,null),u!==null){const c=this.m_vertices.getXY(m);u.setStartXY(c),u.normalizeAfterEndpointChange()}this.setSegmentToIndex(m,u)}}this.setPathSize(s,o-1);const a=this.getGeometryFromPath(s);return this.setGeometryVertexCount(a,this.getPointCount(a)-1),this.freeVertex(t),n}removeVertices(t,e){b(t!==e);const s=this.getPathFromVertex(t),i=this.getPrevVertex(t),n=this.getPrevVertex(e);i!==v&&this.setNextVertex(i,e);let o=this.getPathSize(s);const a=this.getVertexIndex(t);this.setSegmentToIndex(a,null),this.setPrevVertex(e,i),this.setPrevVertex(t,v),this.setNextVertex(n,v);let h=0,m=t;const l=this.getFirstVertex(s);let u=!1;for(;;){const g=this.getNextVertex(m);if(u||=l===m,this.freeVertex(m),h++,m===n)break;m=g}o-=h,u&&this.setFirstVertex(s,o>0?e:v),this.setPathSize(s,o);const c=this.getGeometryFromPath(s);this.setGeometryVertexCount(c,this.getPointCount(c)-h)}getFirstVertex(t){return this.m_pathIndexList.getField(t,4)}getLastVertex(t){return this.m_pathIndexList.getField(t,5)}getNextVertex(t){return this.m_vertexIndexList.getField(t,2)}getPrevVertex(t){return this.m_vertexIndexList.getField(t,1)}getNextVertexEx(t,e){return e>0?this.m_vertexIndexList.getField(t,2):this.m_vertexIndexList.getField(t,1)}getPrevVertexEx(t,e){return e>0?this.m_vertexIndexList.getField(t,1):this.m_vertexIndexList.getField(t,2)}getPathFromVertex(t){return this.m_vertexIndexList.getField(t,3)}addPoint(t,e){return this.insertVertex_(t,v,e,!1)}getGeometryFromVertex(t){return this.getGeometryFromPath(this.getPathFromVertex(t))}replaceNaNs(t,e){this.m_vertexDescription.hasAttribute(t)||$(""),this.m_vertices.replaceNaNs(t,e)}removeNaNVertices(){for(let t=this.getFirstGeometry();t!==v;t=this.getNextGeometry(t))for(let e=this.getFirstPath(t);e!==v;e=this.getNextPath(e)){let s=this.getFirstVertex(e);for(let i=0,n=this.getPathSize(e);i<n;i++)s=this.getXY(s).isFinite()?this.getNextVertex(s):this.removeVertex(s,!0)}}queryVertexIterator(t=v){return this.queryVertexIteratorEx(!1,t)}queryVertexIteratorEx(t,e=v){let s=v,i=v,n=v,o=v,a=0,h=!1;for(s=e!==v?e:this.getFirstGeometry();s!==v;s=this.getNextGeometry(s))if(!t||lt(this.getGeometryType(s))){for(i=this.getFirstPath(s);i!==v;i=this.getNextPath(i))if(n=this.getFirstVertex(i),o=n,a=0,n!==v){h=!0;break}if(h||e!==v)break}return h||(s=v),Ah.create_(this,s,i,n,o,a,t,!1,e!==v)}queryVertexIteratorOnSelection(t=v){return this.m_selection?Ah.create_(this,t,v,v,v,-1,!1,!0,t!==v):this.queryVertexIteratorEx(!1,t)}hasSelection(){return this.m_selection}createEmptySelection(){b(0)}removeSelection(){this.m_selection&&(this.m_selectedVertices.length=0,this.removeUserIndex(this.m_selectionIndex),this.m_selectionIndex=-1,this.m_selection=!1,this.m_selectedCount=0)}select(t){return!!this.selected(t)||(this.setUserIndex(t,this.m_selectionIndex,this.m_selectedVertices.length),this.m_selectedVertices.push(t),this.m_selectedCount++,!1)}unselect(t){if(!this.m_selection)return;const e=this.getUserIndex(t,this.m_selectionIndex);e>=0&&(this.m_selectedVertices[e]=v,this.setUserIndex(t,this.m_selectionIndex,-1),this.m_selectedCount--)}selected(t){return!this.m_selection||this.selected_(t)}getSelectedCount(){return this.m_selection?this.m_selectedCount:this.getTotalPointCount()}createSelectionForCrackingAndClustering(t,e){return b(0),!1}peelALoop(t,e){this.peelALoop_(t,e,!1)}peelALoopIntoAPath(t,e){return this.peelALoop_(t,e,!0)}applyTransformation(t){if(this.m_verticesMp.applyTransformation(t),this.m_segments!==null)for(let e=0,s=this.m_segments.length;e<s;e++)this.m_segments[e]&&this.m_segments[e].applyTransformation(t)}setGeometryType(t,e){this.m_geometryIndexList.setField(t,2,e)}splitSegmentWithIntersector(t,e,s,i,n){i?this.splitSegmentForward(t,e,s,!0,n):this.splitSegmentBackward(t,e,s,!0,n)}setPrevVertex(t,e){this.m_vertexIndexList.setField(t,1,e)}setNextVertex(t,e){this.m_vertexIndexList.setField(t,2,e)}setPathToVertex(t,e){this.m_vertexIndexList.setField(t,3,e)}setPathSize(t,e){this.m_pathIndexList.setField(t,3,e)}setFirstVertex(t,e){this.m_pathIndexList.setField(t,4,e)}setLastVertex(t,e){this.m_pathIndexList.setField(t,5,e)}getSegment(t){if(this.m_segments!=null){const e=this.getVertexIndex(t);return this.getSegmentFromIndex(e)}return null}isCurve(t){if(this.m_segments===null)return!1;const e=this.getVertexIndex(t);return this.m_segments.length>e&&this.m_segments[e]!==null}querySegment(t,e,s=!0,i=!1){const n=this.getNextVertex(t);if(n===v)return!1;const o=this.getSegment(t);if(!o)return!s&&(this.queryLineConnector(t,e.createLine(),i),!0);if(e.copyFrom(o,!0),i)return!0;if(this.m_vertexDescription.getAttributeCount()>1){const a=this.getHelperPoint();this.queryPoint(t,a),e.get().setStart(a),this.queryPoint(n,a),e.get().setEnd(a)}return!0}getSegmentFromIndex(t){return(this.m_segments!==null&&this.m_segments.length>t?this.m_segments[t]:null)||null}getAndClearSegmentFromIndex(t){return(this.m_segments!==null&&this.m_segments.length>t?this.m_segments[t]:null)||null}setSegmentToIndex(t,e){if(this.m_hasForceSetEnvelope=0,this.m_segments===null){if(!e)return;this.m_segments=[],this.m_segments.length=this.m_vertices.getPointCount()}t>=this.m_segments.length&&(this.m_segments.length=t+1),this.m_segments[t]=e}setGeometryPathCount(t,e){this.m_geometryIndexList.setField(t,6,e)}setGeometryVertexCount(t,e){this.m_geometryIndexList.setField(t,5,e)}ringParentageCheckInternal(t,e){return b(0),!1}reverseRingInternal(t){const e=this.hasCurves(),s=this.hasSegmentParentage();let i=null,n=-1,o=t;if(e){const a=this.getVertexIndex(o);i=this.getAndClearSegmentFromIndex(a)}s&&(n=this.getSegmentParentage(o));do{const a=this.getPrevVertex(o),h=this.getNextVertex(o);if(this.setNextVertex(o,a),this.setPrevVertex(o,h),e){const m=this.getVertexIndex(h),l=this.getSegmentFromIndex(m);i&&i.reverse(),this.setSegmentToIndex(m,i),i=l}if(s){const m=this.getSegmentParentage(h);this.setSegmentParentagePreserveBreak(h,n),n=m}o=h}while(o!==t);this.dbgVerifyIntegrity(t)}setTotalPointCount(t){this.m_pointCount=t}removePathOnly(t){const e=this.getPrevPath(t),s=this.getNextPath(t),i=this.getGeometryFromPath(t);e!==v?this.setNextPath(e,s):this.setFirstPath(i,s),s!==v?this.setPrevPath(s,e):this.setLastPath(i,e),this.setFirstVertex(t,v),this.setLastVertex(t,v),this.freePath(t)}insertClosedPath(t,e,s,i,n){const o=this.insertPath(t,v);let a=0,h=s;for(n[0]=!1;;){h===i&&(n[0]=!0),this.setPathToVertex(h,o),a++;const m=this.getNextVertex(h);if(m===s)break;h=m}return this.setClosedPath(o,!0),this.setPathSize(o,a),n[0]&&(s=i),this.setFirstVertex(o,s),this.setLastVertex(o,this.getPrevVertex(s)),this.setRingAreaValid(o,!1),o}findVertex2D(t,e){return b(0),0}findVertex3D(t,e,s){return b(0),0}dbgVerifyMonotone(){}dbgCheckSelection(){}dbgVerifySegment(t){}dbgVerifyIntegrity(t,e=!0){}dbgVerifyVertexCounts(){}dbgVerifyCurves(){}dbgDumpGeometry(t,e){}getNextNthVertex(t,e){if(e===0)return t;let s=t;for(let i=0;i<e;++i)if(s=e>0?this.getNextVertex(s):this.getPrevVertex(s),s===v)return v;return s}removeVertexInternal(t,e){const s=this.getPrevVertex(t),i=this.getNextVertex(t);if(s!==v&&this.setNextVertex(s,i),i!==v&&this.setPrevVertex(i,s),this.hasCurves()&&s!==v&&i!==v){const n=this.getVertexIndex(t),o=this.getVertexIndex(s),a=this.getVertexIndex(i);if(e){const h=this.getSegmentFromIndex(o);if(h!==null){const m=this.m_vertices.getXY(a);h.setEndXY(m),h.normalizeAfterEndpointChange()}this.setSegmentToIndex(n,null)}else{const h=this.getSegmentFromIndex(n);if(this.setSegmentToIndex(n,null),h!==null){const m=this.m_vertices.getXY(o);h.setStartXY(m),h.normalizeAfterEndpointChange()}this.setSegmentToIndex(o,h)}}return this.freeVertex(t),i}isRingAreaValid(t){return!!(4&this.getPathFlags(t))}setRingAreaValid(t,e){const s=(4|this.getPathFlags(t))-4;this.setPathFlags(t,s|(e?4:0))}compareVerticesSimpleY(t,e){return this.queryXY(t,this.m_workPoint2D),this.queryXY(e,this.m_workPoint2_2D),this.m_workPoint2D.compare(this.m_workPoint2_2D)}compareVerticesSimpleY3D(t,e){return this.getXYZ(t).compare(this.getXYZ(e))}compareVerticesSimpleX(t,e){return this.getXY(t).compareX(this.getXY(e))}sortVerticesSimpleByYHeapMerge(t,e){b(0)}sortVerticesSimpleByY(t,e,s){this.m_bucketSort.sort(t,e,s,new Hf(this))}sortVerticesSimpleByX(t,e,s){b(0)}sortVerticesSimpleByY3D(t,e,s){b(0)}snapVertexForPoleClipping(t,e){const s=this.getPrevVertex(t);s!==v&&this.replaceCurveWithLine(s),this.getNextVertex(t)!==v&&this.replaceCurveWithLine(t);const i=new y;this.queryXY(t,i),i.y=e,this.setXY(t,i)}setSegmentParentageAndBreak(t,e,s=!0){if(this.m_segmentParentageIndex===-1){if(e===-1)return;this.m_segmentParentageIndex=this.createUserIndex()}e>=0&&(b(e<=we()>>1),e<<=1,e|=s?1:0),this.setUserIndex(t,this.m_segmentParentageIndex,e)}setSegmentParentagePreserveBreak(t,e){if(b(e>=-1),this.m_segmentParentageIndex===-1){if(e===-1)return;this.m_segmentParentageIndex=this.createUserIndex()}e>=0&&(b(e<=we()>>1),e<<=1,e|=this.getSegmentParentageBreakVertex(t)?1:0),this.setUserIndex(t,this.m_segmentParentageIndex,e)}getSegmentParentage(t){if(this.m_segmentParentageIndex===-1)return-1;const e=this.getUserIndex(t,this.m_segmentParentageIndex);return e<0?e:e>>1}getOriginalSegmentInfo(t){if(this.m_segmentParentageIndex!==-1){const e=this.getSegmentParentage(t);return new qh(e)}return new qh(-1)}setSegmentParentageBreakVertex(t,e){if(this.m_segmentParentageIndex===-1)return;let s=this.getUserIndex(t,this.m_segmentParentageIndex);s<0||!!(1&s)!==e&&(e?s|=1:s&=we()>>1<<1,this.setUserIndex(t,this.m_segmentParentageIndex,s))}getSegmentParentageBreakVertex(t){if(this.m_segmentParentageIndex===-1)return!0;const e=this.getUserIndex(t,this.m_segmentParentageIndex);return e<0||!!(1&e)}isDiscontinuousSegmentParentage(t){const e=this.getPrevVertex(t);return e===v?!1:this.getSegmentParentage(e)!==this.getSegmentParentage(t)}setCurveStitcherPointer(t){this.m_curveStitcher=t}hasSegmentParentage(){return this.m_segmentParentageIndex!==-1}deleteSegmentParentage(){this.m_segmentParentageIndex!==-1&&(this.removeUserIndex(this.m_segmentParentageIndex),this.m_segmentParentageIndex=-1),this.m_curveStitcher=null}clearSegments(){this.m_segments=null}};function ZS(r){if(r.isEmpty())return new ct({vd:r.getDescription()});if(lt(r.getGeometryType())&&r.hasNonLinearSegments())return Uf(r);const t=r.getImpl(),e=t.getPointCount();if(e<=2){if(e===1||t.getXY(0).equals(t.getXY(1))){const g=new st({vd:t.getDescription()});return t.getPointByVal(0,g),g}{const g=new st,_=new Pt({vd:t.getDescription()});return t.getPointByVal(0,g),_.startPathPoint(g),t.getPointByVal(1,g),_.lineToPoint(g),_}}const s=t.getAttributeStreamRef(0),i=new Fm({stream:s,n:e});let n=0,o=1;const a=s.readPoint2D(n<<1),h=new y;for(;o<e&&s.queryPoint2D(o<<1,h).equals(a);)o++;if(i.m_treeHull.addElement(n),o<e){i.m_treeHull.addBiggestElement(o);const g=new y;for(let _=o+1;_<t.getPointCount();_++){s.queryPoint2D(_<<1,g);const d=i.treeHull(g);d!==-1&&i.m_treeHull.setElement(d,_)}}const m=t.getDescription(),l=m.getAttributeCount()>1,u=i.m_treeHull.size();let c=null;if(u>=2){c=u>=3?new ct({vd:m}):new Pt({vd:m});const g=c.getImpl();g.reserve(i.m_treeHull.size()),g.addPathPoint2D(null,0,!0);const _=new y;for(let d=i.m_treeHull.getFirst();d!==-1;d=i.m_treeHull.getNext(d))if(l){const p=new st;t.getPointByVal(i.m_treeHull.getElement(d),p),g.insertPoint(0,-1,p)}else s.queryPoint2D(i.m_treeHull.getElement(d)<<1,_),g.insertPoint2D(0,-1,_)}else if(l){const g=new st({vd:m});t.getPointByVal(i.m_treeHull.getElement(i.m_treeHull.getFirst()),g),c=g}else{const g=s.readPoint2D(i.m_treeHull.getElement(i.m_treeHull.getFirst())<<1);c=new st(g)}return c}function Mh(r,t,e,s=!1){if(t<=262144)return Qf(r,t,e,s);const i=new Fm({points:r,n:t}),n=0;let o=1;const a=r[n];for(;o<t&&r[o].equals(a);)o++;if(i.m_treeHull.addElement(n),o<t){i.m_treeHull.addBiggestElement(o);for(let m=o+1;m<t;m++){const l=r[m],u=i.treeHull(l);u!==-1&&i.m_treeHull.setElement(u,m)}}let h=0;for(let m=i.m_treeHull.getFirst();m!==-1;m=i.m_treeHull.getNext(m))e[h++]=i.m_treeHull.getElement(m);return h}function Uf(r){b(r.hasNonLinearSegments()&&!r.isEmpty());const t=new Fm;return t.addGeometry(r),t.getBoundingGeometry()}function QS(r,t,e){if((t<0||t>=r.getPathCount())&&H("path index"),r.hasNonLinearSegmentsPath(t))return!1;const s=r.getImpl(),i=s.getPathStart(t),n=s.getPathEnd(t),o=!s.isClosedPath(t)&&s.isClosedPathInXYPlane(t),a=s.getAttributeStreamRef(0),h=2*i;let m=2*n;if(o&&(m-=2),m-h<6)return!0;const l=a.readPoint2D(h),u=a.readPoint2D(h+2),c=a.readPoint2D(h+4);if(!fi(y.orientationRobust(u,c,l)))return!1;const g=u.clone(),_=new y;for(let d=h+6;d<m;d+=2)if(_.assign(u),u.assign(c),a.queryPoint2D(d,c),!fi(y.orientationRobust(u,c,l))||!fi(y.orientationRobust(g,c,l))||!fi(y.orientationRobust(u,c,_)))return!1;return!0}function Of(r,t,e){r.setNAN(),t.setCoords(1,0),e.setCoords(0,0)}function KS(r,t,e,s,i){if(Of(e,s,i),r.isEmpty())return;if(r.getGeometryType()===T.enumPoint)return void e.assign(r.getXY());const n=r,o=n.getPointCount();o!==0&&(o!==1?Wf(n,o,t,e,s,i):e.assign(n.getXY(0)))}function Wf(r,t,e,s,i,n){if(t===2){const o=r.getXY(0),a=r.getXY(1);s.assign(o.add(a).mul(.5));const h=a.sub(o);i=au(h),n.setCoords(.5*h.length(),0)}else{let o=Number.MAX_VALUE;const a=[0,1,0,0],h=new Ld(4,2);for(h.set(0,0,0),h.set(0,1,1),h.set(1,0,1),h.set(1,1,2);a[0]<t;++a[0],Ha(h,0,t)){a[1]===a[0]&&(++a[1],Ha(h,1,t));for(let _=1;;++_){for(;;){const d=Jf(r.getXY(h.get(0,0)),r.getXY(h.get(0,1)),r.getXY(h.get(_,0)),r.getXY(h.get(_,1)),2^_);if(d>0||(++a[_],Ha(h,_,t),d===0))break}if(_===3)break;a[_+1]<a[_]&&(a[_+1]=a[_],h.set(_+1,0,h.get(_,0)),h.set(_+1,1,h.get(_,1)))}const m=r.getXY(h.get(0,0)).add(r.getXY(h.get(2,0))).mul(.5),l=au(r.getXY(h.get(0,1)).sub(r.getXY(h.get(0,0)))),u=new y;let c,g;if(u.x=Math.max(0,l.dotProduct(r.getXY(h.get(1,0)).sub(r.getXY(h.get(3,0))))),u.y=Math.max(0,l.crossProduct(r.getXY(h.get(0,0)).sub(r.getXY(h.get(2,0))))),e?(c=u.x*u.y,g=c<o):(c=u.y,g=c<o),g){o=c;const _=r.getXY(h.get(1,0)),d=r.getXY(h.get(3,0)),p=_.add(d).mul(.5).sub(m);s.assign(m.add(l.mul(l.dotProduct(p)))),i.assign(l),n.assign(u)}}n.mulThis(.5),n.x<n.y&&(n.y=O(n.x,n.x=n.y),i.leftPerpendicularThis())}i.y<0?i.negateThis():i.y===0&&(i.x=1)}Lt.st_defaultRank=1;let $f=class{constructor(t){this.m_handleP=-1,this.m_handleQ=-1,this.m_currentSupport=-1,this.m_area=0,this.m_bDone=!0,b(0),this.m_convexHull=t,this.m_function=this.done_}next(){return b(0),!1}get_vertex_handle_p(){return b(0),0}get_vertex_handle_q(){return b(0),0}get_current_support(){return b(0),0}getNext(t){return b(0),0}getPrev(t){return b(0),0}intialize_(){return b(0),!1}increment_(){return b(0),!1}increment_q_(){return b(0),!1}increment_p_(){return b(0),!1}parallel_edge_with_q_support_(){return b(0),!1}parallel_edge_with_p_support_(){return b(0),!1}done_(){return b(0),!1}},Fm=class Ng{nullGetXY(t){return $("m_getXY is null"),{}}nullDeleteNode(t){$("m_deleteNode is null")}constructor(t){return this.m_treeHull=new tt,this.m_shape=null,this.m_stream=null,this.m_points=null,this.m_geometryHandle=-1,this.m_pathHandle=-1,this.m_getXY=this.nullGetXY,this.m_deleteNode=this.nullDeleteNode,t?t.stream?(this.m_treeHull.setCapacity(Math.min(20,t.n)),this.m_stream=t.stream,this.m_getXY=this.getXYStream,this.m_deleteNode=this.deleteNodeStream,this.m_points=null,this.m_geometryHandle=v,void(this.m_pathHandle=v)):t.points?(this.m_treeHull.setCapacity(Math.min(20,t.n)),this.m_points=t.points,this.m_getXY=this.getXYPoints,this.m_deleteNode=this.deleteNodePoints,this.m_stream=null,this.m_geometryHandle=v,void(this.m_pathHandle=v)):void Yt("unrecognized constructor parameter"):(this.m_treeHull.setCapacity(20),this.m_shape=new Lt,this.m_geometryHandle=this.m_shape.createGeometry(T.enumMultiPoint),this.m_pathHandle=this.m_shape.insertPath(this.m_geometryHandle,v),this.m_getXY=this.getXYShape,this.m_deleteNode=this.deleteNodeShape,this.m_stream=null,void(this.m_points=null))}getXYShape(t){return this.m_shape.getXY(t)}getXYStream(t){return this.m_stream.readPoint2D(t<<1)}getXYPoints(t){return b(0),new y}deleteNodeShape(t){const e=this.m_treeHull.getElement(t);this.m_treeHull.deleteNode(t),this.m_shape.removeVertex(e,!1)}deleteNodeStream(t){this.m_treeHull.deleteNode(t)}deleteNodePoints(t){b(0)}addGeometry(t){if(t.isEmpty())return;const e=t.getGeometryType();if(e===T.enumGeometryCollection){const s=t;for(let i=0,n=s.getGeometryCount();i<n;i++)this.addGeometry(s.getGeometry(i))}else We(e)?this.addMultiVertexGeometry(t):he(e)?this.addSegment(t,!1):e===T.enumEnvelope?this.addEnvelope(t):e===T.enumPoint?this.addPoint(t):H("Convex_hull: geometry not supported")}getBoundingGeometry(){const t=new st,e=this.m_treeHull.getFirst(),s=new ct({vd:this.m_shape.getVertexDescription()});if(this.m_treeHull.size()===0)return s;s.reserve(this.m_treeHull.size()),this.m_shape.queryPoint(this.m_treeHull.getElement(e),t),s.startPathPoint(t);for(let i=this.m_treeHull.getNext(e);i!==-1;i=this.m_treeHull.getNext(i))this.m_shape.queryPoint(this.m_treeHull.getElement(i),t),s.lineToPoint(t);return s}getAntipodalPairsIterator(){return b(0),new $f(this)}getXY(t){return b(0),new y}getXYWithIndex(t){return b(0),new y}getFirst(){return b(0),0}getLast(){return b(0),0}getNext(t){return b(0),0}getPrev(t){return b(0),0}getVertexIndex(t){return b(0),0}getPointCount(){return b(0),0}addMultiVertexGeometry(t){const e=new st,s=t.getImpl(),i=new y;for(let n=0;n<t.getPointCount();n++){s.queryXY(n,i);const o=this.addPoint2D(i);if(o!==-1){t.getPointByVal(n,e);const a=this.m_shape.addPoint(this.m_pathHandle,e);this.m_treeHull.setElement(o,a)}}if(lt(t.getGeometryType())){const n=t;if(n.hasNonLinearSegments()){const o=n.querySegmentIterator();for(;o.nextPath();)for(;o.hasNextSegment();){const a=o.nextCurve();a!==null&&this.addSegment(a,!0)}}}}addEnvelope(t){const e=new st;for(let s=0;s<4;s++){const i=new y;t.queryCorner(s,i);const n=this.addPoint2D(i);if(n!==-1){t.queryCornerByVal(s,e);const o=this.m_shape.addPoint(this.m_pathHandle,e);this.m_treeHull.setElement(n,o)}}}static querySegmentControlPoints(t,e,s){const i=t.getGeometryType();if(b(i!==T.enumLine),i===T.enumEllipticArc){const n=t,o=60*Math.PI/180,a=Math.abs(n.getSweepAngle());if(a>o){const h=Math.min(6,Math.ceil(a/o)),m=1/h,l=new it;n.queryStart(e[0]);let u=1;for(let c=0;c<h;c++){n.queryCut(c*m,(c+1)*m,l);const g=R(y,3);Sr(l.get(),g);const _=y.calculateLength(g,3),d=y.calculateLength(g,2),p=_>0?d/_:.5;c<h-1?l.get().queryEnd(e[u+1]):n.queryEnd(e[u+1]),st.lerp(e[u-1],e[u+1],p,e[u]),e[u].setXY(g[1]),u+=2}return u}{const h=R(y,3);Sr(t,h);const m=y.calculateLength(h,3);t.queryStart(e[0]),t.queryEnd(e[2]);const l=y.calculateLength(h,2),u=m>0?l/m:.5;return st.lerp(e[0],e[2],u,e[1]),e[1].setXY(h[1]),3}}if(i===T.enumBezier){const n=t,o=R(y,4);n.queryControlPoints(o);const a=y.calculateLength(o,4),h=y.calculateLength(o,2),m=y.calculateLength(o,3);t.queryStart(e[0]),t.queryEnd(e[3]);const l=a>0?h/a:.5;st.lerp(e[0],e[3],l,e[1]),e[1].setXY(o[1]);const u=a>0?m/a:.5;return st.lerp(e[0],e[3],u,e[2]),e[2].setXY(o[2]),4}if(i===T.enumBezier2){const n=t,o=R(y,3);n.queryControlPoints(o);const a=y.calculateLength(o,3);t.queryStart(e[0]),t.queryEnd(e[2]);const h=y.calculateLength(o,2),m=a>0?h/a:.5;return st.lerp(e[0],e[2],m,e[1]),e[1].setXY(o[1]),3}if(i===T.enumRationalBezier2){const n=t,o=R(y,3);n.queryControlPoints(o);const a=y.calculateLength(o,3);t.queryStart(e[0]),t.queryEnd(e[2]);const h=y.calculateLength(o,2),m=a>0?h/a:.5;return st.lerp(e[0],e[2],m,e[1]),e[1].setXY(o[1]),3}H("Convex_hull: segment type not supported")}addSegment(t,e){if(!e){const s=new st,i=t.getStartXY(),n=this.addPoint2D(i);if(n!==-1){t.queryStart(s);const h=this.m_shape.addPoint(this.m_pathHandle,s);this.m_treeHull.setElement(n,h)}const o=t.getEndXY(),a=this.addPoint2D(o);if(a!==-1){t.queryEnd(s);const h=this.m_shape.addPoint(this.m_pathHandle,s);this.m_treeHull.setElement(a,h)}}if(t.isCurve()){const s=R(st,13);for(let i=1,n=Ng.querySegmentControlPoints(t,s,s.length)-1;i<n;++i){const o=s[i].getXY(),a=this.addPoint2D(o);if(a!==-1){const h=this.m_shape.addPoint(this.m_pathHandle,s[i]);this.m_treeHull.setElement(a,h)}}}}addPoint(t){const e=t.getXY(),s=this.addPoint2D(e);if(s!==-1){const i=this.m_shape.addPoint(this.m_pathHandle,t);this.m_treeHull.setElement(s,i)}}addPoint2D(t){let e=-1;if(this.m_treeHull.size()===0)return e=this.m_treeHull.addElement(-4),e;if(this.m_treeHull.size()===1){const s=this.m_treeHull.getElement(this.m_treeHull.getFirst()),i=this.m_shape.getXY(s);return t.equals(i)||(e=this.m_treeHull.addBiggestElement(-5)),e}return e=this.treeHull(t),e}treeHull(t){let e=-1;do{const s=this.m_treeHull.getFirst(),i=this.m_treeHull.getLast(),n=this.m_treeHull.getElement(s),o=this.m_treeHull.getElement(i),a=this.m_getXY(n),h=this.m_getXY(o),m=y.orientationRobust(h,t,a);if(fi(m)){e=this.m_treeHull.addBiggestElement(-1);const l=this.treeHullWalkBackward(t,i,s);l!==s&&this.treeHullWalkForward(t,s,this.m_treeHull.getPrev(l));break}if(ou(m)){let l=this.m_treeHull.getRoot(),u=this.m_treeHull.getFirst(),c=this.m_treeHull.getLast(),g=-1,_=-1,d=-1;for(;u!==this.m_treeHull.getPrev(c);){_=this.m_treeHull.getElement(l);const x=this.m_getXY(_);ou(y.orientationRobust(x,t,a))?(c=l,l=this.m_treeHull.getLeft(l)):(u=l,l=this.m_treeHull.getRight(l))}l=c,g=u,_=this.m_treeHull.getElement(l),d=this.m_treeHull.getElement(g);const p=this.m_getXY(_),f=this.m_getXY(d);if(g!==s&&!fi(y.orientationRobust(f,t,p)))break;e=this.m_treeHull.addElementAtPosition(g,l,-2,!0,!1),this.treeHullWalkForward(t,l,i),this.treeHullWalkBackward(t,g,s);break}{const l=Kf(t,h,a);if(l===-1){const u=this.m_treeHull.getPrev(i);this.m_treeHull.deleteNode(i),e=this.m_treeHull.addBiggestElement(-3),this.treeHullWalkBackward(t,u,s)}else if(l===1){const u=this.m_treeHull.getNext(s);this.m_treeHull.deleteNode(s),e=this.m_treeHull.addElementAtPosition(-1,u,-3,!0,!1),this.treeHullWalkForward(t,u,i)}break}}while(!1);return e}treeHullWalkForward(t,e,s){if(e===s)return s;let i=e,n=this.m_treeHull.getElement(i),o=this.m_treeHull.getNext(i);const a=this.m_getXY(n);for(;i!==s&&this.m_treeHull.size()>2;){const h=this.m_treeHull.getElement(o),m=this.m_getXY(h);if(fi(y.orientationRobust(m,t,a)))break;const l=i;i=o,n=h,a.assign(m),o=this.m_treeHull.getNext(i),this.m_deleteNode(l)}return i}treeHullWalkBackward(t,e,s){if(e===s)return s;let i=e,n=this.m_treeHull.getElement(i),o=this.m_treeHull.getPrev(i);const a=this.m_getXY(n);for(;i!==s&&this.m_treeHull.size()>2;){const h=this.m_treeHull.getElement(o),m=this.m_getXY(h);if(fi(y.orientationRobust(a,t,m)))break;const l=i;i=o,n=h,a.assign(m),o=this.m_treeHull.getPrev(i),this.m_deleteNode(l)}return i}};function jf(r,t,e){const s=t.sub(r),i=e.sub(t);if(s.x===0)return i.x>0?-1:0;if(s.y===0)return i.y>0?1:i.y<0?-1:0;const n=s.crossProduct(i),o=4*Number.EPSILON*(Math.abs(i.x*s.y)+Math.abs(i.y*s.x));return n>o?1:n<-o?-1:y.orientationRobust(r,t,e)}function Zf(r,t,e){const s=t.sub(r),i=e.sub(t);if(s.x===0)return i.x<0?-1:0;if(s.y===0)return i.y>0?-1:i.y<0?1:0;const n=s.crossProduct(i),o=4*Number.EPSILON*(Math.abs(i.x*s.y)+Math.abs(i.y*s.x));return n>o?1:n<-o?-1:y.orientationRobust(r,t,e)}function Qf(r,t,e,s){const i=new Xt(0);for(let h=0;h<t;h++)i.add(h);const n={userSort(h,m,l){l.sort(h,m,(u,c)=>r[u].compareX(r[c]))},getValue:h=>r[h].x};s||Ys.sortEx(i,0,t,n);let o=0;t:for(let h=0;h<t;++h){const m=i.read(h);for(;o>=2;){const l=e[o-2],u=e[o-1];if(r[u].equals(r[m])){i.write(h,-1);continue t}if(!(jf(r[l],r[u],r[m])>=0)){u===i.read(h-1)&&i.write(h-1,-1);break}o--}e[o++]=m,o===2&&r[m].equals(r[e[0]])&&(i.write(1,-1),o--)}const a=o+1;t:for(let h=t-2;h>=0;--h){const m=i.read(h);if(!(m<0)){for(;o>=a;){const l=e[o-2],u=e[o-1];if(r[u].equals(r[m]))continue t;if(!(Zf(r[l],r[u],r[m])>=0))break;o--}if(h!==0){const l=e[o-1];e[o++]=m,r[m].equals(r[l])&&o--}}}return o>1&&r[e[0]].equals(r[e[o-1]])&&o--,o}function fi(r){return r<0}function ou(r){return r>0}function Kf(r,t,e){let s=-1;t.y===e.y?s=0:t.x===e.x?s=1:s=Math.abs(t.x-e.x)>=Math.abs(t.y-e.y)?0:1;let i=-1;return i=t[s]<e[s]?r[s]<t[s]?-1:e[s]<r[s]?1:0:t[s]<r[s]?-1:r[s]<e[s]?1:0,i}function au(r){return(r=r.clone()).divThis(Math.max(Math.abs(r.x),Math.abs(r.y))),r.normalize(),r}function Ha(r,t,e){r.inc(t,0)===e&&r.set(t,0,0),r.inc(t,1)===e&&r.set(t,1,0)}function Jf(r,t,e,s,i){switch(i){case 0:break;case 1:t.rightPerpendicularThis(),r.rightPerpendicularThis();break;case 2:t.negateThis(),r.negateThis();break;case 3:t.leftPerpendicularThis(),r.leftPerpendicularThis();break;default:H("")}return y.orientationRobustEx(r,t,e,s)}let t0=class{constructor(){this.length=Number.NaN,this.specialPoints=[]}specialPointsCount(){return this.specialPoints.length}};function Ag(r){return e0(r.calculateUpperLength2D())}function e0(r){return 256*jt()*r}function s0(r){const t=y.distance(r.getStartXY(),r.getEndXY()),e=r.calculateUpperLength2D();return e-t<=8*Number.EPSILON*e}function qg(r,t,e=!1){t[1].setCoords(r.m_cp[0].x-r.getStartX(),r.m_cp[0].y-r.getStartY()),t[1].mulThis(3),t[2].setCoords(r.m_cp[1].x-r.m_cp[0].x,r.m_cp[1].y-r.m_cp[0].y),t[2].mulThis(3),t[3]=r.getEndXY().sub(r.getStartXY()),t[3].subThis(t[2]),t[2].subThis(t[1]),e?t[0].setCoords(0,0):t[0]=r.getStartXY()}function Fg(r,t,e){const s=R(y,4);r.queryControlPoints(s),Mm(s,t,e)}function Mg(r,t,e){const s=R(y,4);r.queryControlPoints(s),Gm(s,t,e)}function Mm(r,t,e){let s=r[1].x;s-=r[0].x,s*=3;let i=r[2].x;i-=r[1].x,i*=3;let n=r[3].x;n-=r[0].x,n-=i,i-=s,t[3].setWithEps(n),t[2].setWithEps(i),t[1].setWithEps(s),e?t[0].set(0):t[0].set(r[0].x)}function Gm(r,t,e){let s=r[1].y;s-=r[0].y,s*=3;let i=r[2].y;i-=r[1].y,i*=3;let n=r[3].y;n-=r[0].y,n-=i,i-=s,t[3].setWithEps(n),t[2].setWithEps(i),t[1].setWithEps(s),e?t[0].set(0):t[0].set(r[0].y)}function Sn(r,t,e=!1){const s=R(Et,4);s[0].assignPoint2D(r[0]),s[1].assignPoint2D(r[1]),s[2].assignPoint2D(r[2]),s[3].assignPoint2D(r[3]),t[1].setCoords(s[1].x.sub(s[0].x),s[1].y.sub(s[0].y)),t[1].mulThis(J.constructInt32(3)),t[2].setCoords(s[2].x.sub(s[1].x),s[2].y.sub(s[1].y)),t[2].mulThis(J.constructInt32(3)),t[3]=s[3].sub(s[0]),t[3]=t[3].sub(t[2]),t[2]=t[2].sub(t[1]),e?t[0].setCoords(Se,Se):t[0]=s[0].clone()}function gr(r,t,e){if(e){if(t<0)return t;if(t>1)return t-1+gr(r,1,!1)}if(r.isDegenerate(0))return 0;const s=t===1,i=_r(r);if(s&&!Number.isNaN(i.length)&&!Number.isNaN(i.length))return i.length;const n=Ag(r),o=n/r.calculateUpperLength2D();let a=0,h=0;for(let m=1,l=i.specialPointsCount();m<l;m++){const u=i.specialPoints[m];if(a+=I0(r,h,Math.min(t,u),o,n),t<=u)break;h=u}return s&&(i.length=a),a}function i0(r,t,e){const s=gr(r,1,!1);if(t<=0)return t;if(t>=s)return t-s+1;const i=[0];return Ti(new b0(r,t),z.unit(),1,i)!==1&&$(""),i[0]}function n0(r,t,e){e===void 0&&(e=t,t=0);const s=new y;if(t<0||e>1)return s.setNAN(),s;if(t>e&&H("calculate_sub_weightedCentroid"),t===e||r.isDegenerate(0))return s.setCoords(0,0),s;const i=_r(r),n=Ag(r),o=n/r.calculateUpperLength2D();let a=t,h=0;for(let m=1,l=i.specialPointsCount();m<l;m++)if(t<i.specialPoints[m]){h=m-1;break}s.setCoords(0,0);for(let m=h+1,l=i.specialPointsCount();m<l;m++){const u=Math.min(i.specialPoints[m],e),c=w0(r,a,u,o,n);if(s.addThis(c),a=u,e<=i.specialPoints[m])break}return s.add(r.getStartXY().mul(r.calculateLength2D()))}function _r(r){if(r.m_cachedValues)return r.m_cachedValues;const t=new t0,e=R(L,8),s=R(y,4);r.queryControlPoints(s);const i=Lg(s,e);t.specialPoints=[];for(let n=0;n<i;n++)t.specialPoints.push(e[n].value());return Gg(r,t),t}function hu(r){let t=null;return t=r.m_cachedValues,t}function Gg(r,t){r.m_cachedValues=t}function za(r){r.m_cachedValues=null}function r0(r,t){t.m_cachedValues=O(r.m_cachedValues,r.m_cachedValues=t.m_cachedValues)}function o0(r,t,e,s){if(t.isEqual(r.m_XStart,r.m_YStart)&&e.isEqual(r.m_XEnd,r.m_YEnd))return;const i=!!s&&r.isMonotoneQuickAndDirty(),n=new pt,o=R(y,3);o[0].setCoords(r.m_XStart,r.m_YStart),o[2].setCoords(r.m_XEnd,r.m_YEnd);const a=new y;a.setSub(o[2],o[0]),a.leftPerpendicularThis(),o[1].setAdd(o[0],a);const h=R(y,3);h[0].setCoordsPoint2D(t),h[2].setCoordsPoint2D(e),a.setSub(h[2],h[0]),a.leftPerpendicularThis(),h[1].setAdd(h[0],a),n.setFromTwoTriangles(o,h)?n.transformPoints2D(r.m_cp,2,r.m_cp):(Qt(t,e,1/3,r.m_cp[0]),Qt(t,e,2/3,r.m_cp[1])),r.changeEndPoints2D(t,e),i&&Xo(r)}function a0(r,t,e,s,i){return{tmin:r,tmax:t,t:e,d:s,pt:i.clone()}}function h0(r,t,e,s){const i=R(y,4);r.queryControlPoints(i);const n=j(18,NaN),o=Ti(new Rg(i,t,NaN),z.construct(e,s),18,n),a=new y;r.queryCoord2D(e,a);let h=e,m=y.distance(a,t);const l=new y;r.queryCoord2D(s,l);const u=y.distance(l,t);u<m&&(m=u,h=s,a.assign(l));for(let c=0;c<o;c++){r.queryCoord2D(n[c],l);const g=y.distance(l,t);g<m&&(m=g,h=n[c],a.assign(l))}return a0(e,s,h,m,a)}function Vg(r,t){const e=R(L,4);Fg(r,e,!0);const s=R(L,4);Mg(r,s,!0);const i=e[3].clone(),n=e[2].clone(),o=e[1].clone(),a=s[3].clone(),h=s[2].clone(),m=s[1].clone(),l=n.mulE(o).addE(h.mulE(m)).mul(4),u=n.mulE(n).mul(8).addE(i.mulE(o).mul(12)).addE(h.mulE(h).mul(8).addE(a.mulE(m).mul(12))),c=i.mulE(n).addE(a.mulE(h)).mul(36),g=i.mulE(i).addE(a.mulE(a)).mul(36),_=R(L,3),d=Go(g,c,u,l,new z(0,1),!1,_);if(b(d<=3),d>0){const p=Ri(r,1,0).sqrLength(),f=Ri(r,1,1).sqrLength();let x=p;t.set(0),x<f&&(x=f,t.set(1));for(let E=0;E<d;E++){const P=Ri(r,1,_[E].value()).sqrLength();P<x&&(x=P,t=_[E])}}}function m0(r,t,e,s){if(t===1){const i=1-e,n=i*i,o=e*e,a=r[1].sub(r[0]),h=r[2].sub(r[1]),m=r[3].sub(r[2]),l=a.mul(n).add(h.mul(2*i*e)).add(m.mul(o));s.assign(l.mul(3))}else if(t===2){const i=1-e,n=r[2].sub(r[1]).sub(r[1].sub(r[0])),o=r[3].sub(r[2]).sub(r[2].sub(r[1])),a=n.mul(i).add(o.mul(e));s.assign(a.mul(6))}else if(t===3){const i=r[2].sub(r[1]),n=r[3].sub(i.mul(3)).sub(r[0]);s.assign(n.mul(6))}else s.setCoords(0,0)}function l0(r,t,e,s){{const i=er.subE(e),n=i.sqr(),o=e.sqr(),a=r[1].subE(r[0]).mulE(n).addE(r[2].subE(r[1]).mulE(new L(2).mulE(i).mulE(e))).addE(r[3].subE(r[2]).mulE(o));s.setE(a.mulE(new L(3)))}}function ye(r,t,e){const s=new y;return m0(r,t,e,s),s}function u0(r,t,e){const s=[K.constructPoint2D(r[0]),K.constructPoint2D(r[1]),K.constructPoint2D(r[2]),K.constructPoint2D(r[3])],i=new K;return l0(s,t,e,i),i}function Ri(r,t,e){const s=R(y,4);return r.queryControlPoints(s),ye(s,t,e)}function mu(r){const t=r.m_cp[0].sub(r.getStartXY()),e=r.m_cp[1].sub(r.m_cp[0]),s=r.getEndXY().sub(r.getStartXY());return t.mulThis(3),e.mulThis(3),s.subThis(e),e.subThis(t),(3*s.x*(2*e.y+5*t.y)-3*s.y*(2*e.x+5*t.x)+10*(e.x*t.y-e.y*t.x))/60}function Xo(r){const t=R(y,4);r.queryControlPoints(t);const e=Ro(t);return e&&(r.m_cp[0].setCoordsPoint2D(t[1]),r.m_cp[1].setCoordsPoint2D(t[2]),r.afterCompletedModification()),e}function Ro(r){return eg(r)}function c0(r){return Gp(r)}function Jr(r,t,e){const s=new y,i=new y,n=new y,o=new y,a=new y;t<=.5?(ee(2,r[0],r[1],t,s),ee(2,r[1],r[2],t,i),ee(2,r[2],r[3],t,n),ee(2,s,i,t,o),ee(2,i,n,t,a),ee(2,o,a,t,e)):(se(2,r[0],r[1],t,s),se(2,r[1],r[2],t,i),se(2,r[2],r[3],t,n),se(2,s,i,t,o),se(2,i,n,t,a),se(2,o,a,t,e))}function dr(r,t,e,s){b(t>=0&&t<=1);const i=new y,n=new y,o=new y,a=new y,h=new y,m=new y;t<=.5?(ee(2,r[0],r[1],t,i),ee(2,r[1],r[2],t,n),ee(2,r[2],r[3],t,o),ee(2,i,n,t,a),ee(2,n,o,t,h),ee(2,a,h,t,m)):(se(2,r[0],r[1],t,i),se(2,r[1],r[2],t,n),se(2,r[2],r[3],t,o),se(2,i,n,t,a),se(2,n,o,t,h),se(2,a,h,t,m));const l=r[3].clone();e&&(e[0].assign(r[0]),e[1].assign(i),e[2].assign(a),e[3].assign(m)),s&&(s[0].assign(m),s[1].assign(h),s[2].assign(o),s[3].assign(l))}function vi(r,t,e,s){if(b(t>=0&&e<=1&&t<=e),t===e){const n=new y;return Rt(r,t,n),s[0].assign(n),s[1].assign(n),s[2].assign(n),void s[3].assign(n)}if(t===0&&e===1){for(let n=0;n<4;++n)s[n].assign(r[n]);return}const i=R(y,4);dr(r,e,i,null),dr(i,e>0?t/e:0,null,i),Rt(r,t,i[0]),Rt(r,e,i[3]),s[0].setCoordsPoint2D(i[0]),s[1].setCoordsPoint2D(i[1]),s[2].setCoordsPoint2D(i[2]),s[3].setCoordsPoint2D(i[3])}function Rt(r,t,e,s){if(s){if(t<0)return void Ue(new ht({start:r[0],end:r[0].add(Gh(r,0).getUnitVector())}),t,e);if(t>1)return void Ue(new ht({start:r[3],end:r[3].add(Gh(r,1).getUnitVector())}),t-1,e)}if(t<=.5){const i=new y;ee(2,r[0],r[1],t,i);const n=new y;ee(2,r[1],r[2],t,n);const o=new y;ee(2,r[2],r[3],t,o);const a=new y;ee(2,i,n,t,a);const h=new y;ee(2,n,o,t,h),ee(2,a,h,t,e)}else{const i=new y;se(2,r[0],r[1],t,i);const n=new y;se(2,r[1],r[2],t,n);const o=new y;se(2,r[2],r[3],t,o);const a=new y;se(2,i,n,t,a);const h=new y;se(2,n,o,t,h),se(2,a,h,t,e)}}function g0(r,t,e){if(t.value()<=.5){const s=new K;us(2,K.constructPoint2D(r[0]),K.constructPoint2D(r[1]),t,s);const i=new K;us(2,K.constructPoint2D(r[1]),K.constructPoint2D(r[2]),t,i);const n=new K;us(2,K.constructPoint2D(r[2]),K.constructPoint2D(r[3]),t,n);const o=new K;us(2,s,i,t,o);const a=new K;us(2,i,n,t,a),us(2,o,a,t,e)}else{const s=new K;cs(2,K.constructPoint2D(r[0]),K.constructPoint2D(r[1]),t,s);const i=new K;cs(2,K.constructPoint2D(r[1]),K.constructPoint2D(r[2]),t,i);const n=new K;cs(2,K.constructPoint2D(r[2]),K.constructPoint2D(r[3]),t,n);const o=new K;cs(2,s,i,t,o);const a=new K;cs(2,i,n,t,a),cs(2,o,a,t,e)}}function _0(r,t,e){const s=R(y,4);r.queryControlPoints(s),g0(s,t,e)}function Gh(r,t){const e=Nt(t,0,1);let s=ye(r,1,e);return s.isZero()&&(s=ye(r,2,e),s.isZero()?s=ye(r,3,e):e===1&&s.negateThis()),s}function Yg(r,t,e){const s=R(y,4);r.queryControlPoints(s),d0(s,t,e)}function d0(r,t,e){t.value()<0&&t.set(0,t.eps()),t.value()>1&&t.set(1,t.eps()),e.setE(u0(r,1,t))}function lu(r,t,e,s,i){if(i){if(Qe(t,e)!==0)return r?4:2}else if(is(t,e))return 1;return pr(r,t,e,null,null,null,s,i!==void 0&&i,!0,!1)!==0?4:0}function uu(r,t,e,s,i){if(i){if(Qe(t,e)!==0)return r?4:2}else if(is(t,e))return 1;return Vh(r,t,e,null,null,null,s,i!==void 0&&i,!0,!1)!==0?4:0}function p0(r,t,e,s,i){if(i){if(Qe(t,e)!==0)return 2}else if(is(t,e))return 1;return Vm(r,t,e,null,null,null,s,i!==void 0&&i,!0,!1)!==0?4:0}function cu(r,t,e,s,i){if(i){if(Qe(t,e)!==0)return r?4:2}else if(is(t,e))return 1;return Yh(r,t,e,null,null,null,s,i!==void 0&&i,!0,!1)!==0?4:0}function gu(r,t,e,s,i){if(i){if(Qe(t,e)!==0)return r?4:2}else if(is(t,e))return 1;return Xh(r,t,e,null,null,null,s,i??!1,!0,!1)!==0?4:0}function pr(r,t,e,s,i,n,o,a,h,m){if(i!==null&&(i.length=0),n!=null&&(n.length=0),s!==null&&(s.length=0),e.isDegenerate(0)){const w=[0,0,0],D=t.intersectPoint(e.getStartXY(),w,o);if(D>0){if(i!==null)for(let N=0;N<D;N++)i.push(w[N]);if(n!==null)for(let N=0;N<D;N++)n.push(0);if(s!=null)for(let N=0;N<D;N++){const A=new y;t.queryCoord2D(w[N],A),s.push(A)}}return D}const l=Xe(t,e);if(ns(t,e,o=Math.max(o,l)))return 0;const u=R(y,4);qg(t,u);const c=e.getEndXY();c.subThis(e.getStartXY());const g=c.clone();g.leftPerpendicularThis();let _=3*u[3].dotProduct(g),d=2*u[2].dotProduct(g),p=u[1].dotProduct(g);const f=j(15,Number.NaN),x=j(15,Number.NaN);let E=Ui(_,d,p,z.unit(),!1,f);E<0&&(f[0]=0,f[1]=1,E=2);let P,C=0;for(let w=0,D=C;w<E;++w){const N=t.getCoord2D(f[w+D]);x[C]=e.getClosestCoordinate(N,!1),y.distance(N,e.getCoord2D(x[C]))<=o&&(f[C]=f[w+D],C++)}if(u[0].subThis(e.getStartXY()),Math.abs(c.x)>=Math.abs(c.y)){const w=c.y/c.x;_=u[3].y-u[3].x*w,d=u[2].y-u[2].x*w,p=u[1].y-u[1].x*w,P=u[0].y-u[0].x*w}else{const w=c.x/c.y;_=u[3].x-u[3].y*w,d=u[2].x-u[2].y*w,p=u[1].x-u[1].y*w,P=u[0].x-u[0].y*w}const S=t.getEndXY().equals(e.getStartXY())||t.getEndXY().equals(e.getEndXY()),I=[0,0,0];E=ug(_,d,p,P,z.unit(),S,I);for(let w=0,D=C;w<E;++w){f[w+D]=I[w];const N=t.getCoord2D(f[w+D]);x[C]=e.getClosestCoordinate(N,!1),y.distance(N,e.getCoord2D(x[C]))<=o&&(f[C]=f[w+D],C++)}E=t.intersectPoint(e.getStartXY(),I,o);for(let w=0;w<E;w++)f[C]=I[w],x[C++]=0;E=t.intersectPoint(e.getEndXY(),I,o);for(let w=0;w<E;w++)f[C]=I[w],x[C++]=1;return e.intersectPoint(t.getStartXY(),I,o)!==0&&(x[C]=I[0],f[C++]=0),e.intersectPoint(t.getEndXY(),I,o)!==0&&(x[C]=I[0],f[C++]=1),C===0?0:rs(r,t,e,f,x,C,s,i,n,o,a,h,m)}function Vh(r,t,e,s,i,n,o,a,h,m){if(Ft(e))return pr(r,t,new ht({start:e.getStartXY(),end:e.getEndXY()}),s,i,n,o,a,h,m);const l=Xe(t,e);if(ns(t,e,o=Math.max(o,l)))return 0;const u=[],c=[],g=[],_=R(y,4);{t.queryControlPoints(_);const p=R(y,4),f=new pt;e.canonicToWorldTransformation(f);const x=new pt;x.setInvert(f),x.transformPoints2D(_,4,p);const E=R(Et,4);Sn(p,E);const P=[E[0].x,E[1].x,E[2].x,E[3].x],C=[E[0].y,E[1].y,E[2].y,E[3].y],S=R(J,3);S[0].setDouble(e.getSemiMinorAxis()),S[0].sqrThis(),S[1].setDouble(e.getSemiMajorAxis()),S[1].sqrThis(),S[2].setThis(S[0]),S[2].mulThis(S[1]),S[2].negateThis();const I=Nm(P,3,C,3,null,0,S,!0,z.unit(),z.unit(),c,a);if(I>0){let w=0;for(let D=0;D<I;D++){const N=new y;t.queryCoord2D(c[D],N);const A=e.getClosestCoordinate(N,!1),M=new y;e.queryCoord2D(A,M),y.distance(N,M)<=o&&(u.push(N.clone()),c[w]=c[D],g.push(A),w++)}c.length=w,u.length=w}}const d=[0,1];for(let p=0;p<2;p++){const f=p===0?e.getStartXY():e.getEndXY(),x=[0];Wi(_,f,z.unit(),!1,-1,1,x);const E=new y;Rt(_,x[0],E),y.distance(f,E)<=o&&(c.push(x[0]),g.push(d[p]),u.push(E.clone()))}for(let p=0;p<2;p++){const f=[0,3];{const x=e.getClosestCoordinate(_[f[p]],!1),E=new y;e.queryCoord2D(x,E),y.distance(_[f[p]],E)<=o&&(c.push(d[p]),g.push(x),u.push(E.clone()))}}return rs(r,t,e,c,g,c.length,s,i,n,o,a,h,m)}function Vm(r,t,e,s,i,n,o,a,h,m){const l=R(y,4);t.queryControlPoints(l);const u=R(y,4);if(e.queryControlPoints(u),wm(l,u,4)<0)return Vm(r,e,t,s,n,i,o,a,h,!m);const c=Xe(t,e);if(ns(t,e,o=Math.max(o,c)))return 0;if(D0(t,e,s,i,n,o,a,h,m))return 2;const g=new z(0,1),_=new z(0,1);{const P=new ce;ko(l,new z(0,1),P);const C=new ce;ko(u,new z(0,1),C);const S=Math.max(P.maxDim(),C.maxDim());if(P.inflate(3*o),C.inflate(3*o),!P.intersectW(C))return 0;if(P.maxDim()<.1*S){if(Rh(l,P,g),g.isEmpty()||(Rh(u,P,_),_.isEmpty()))return 0;vi(l,g.vmin,g.vmax,l),vi(u,_.vmin,_.vmax,u)}}const d=Vn(l,3,u,3,o);if(d===0)return 0;const p=[],f=[],x=[];let E=!1;if(d===-1){const P=R(Et,4);Sn(l,P);const C=[P[0].x,P[1].x,P[2].x,P[3].x],S=[P[0].y,P[1].y,P[2].y,P[3].y],I=R(Et,4);Sn(u,I);const w=[],D=[],N=Mn(C,3,S,3,null,0,[I[0].x,I[1].x,I[2].x,I[3].x],3,[I[0].y,I[1].y,I[2].y,I[3].y],3,null,0,!0,z.unit(),z.unit(),w,D,h);if(N>0)for(let A=0;A<N;A++){const M=new y;Rt(u,D[A],M);const G=new y;Rt(l,w[A],G),y.distance(G,M)<=o&&(p.push(G.clone()),x.push(D[A]),f.push(w[A]))}else N===-1&&(E=!0)}for(let P=0;P<2;P++){const C=P===0?l:u,S=P===0?u:l;for(let I=0;I<2;I++){const w=I===0?0:3,D=[0];Wi(S,C[w],z.unit(),!1,-1,1,D);const N=new y;Rt(S,D[0],N),y.distance(C[w],N)<=o&&(P===0?(f.push(w===0?0:1),x.push(D[0])):(x.push(w===0?0:1),f.push(D[0])),p.push(N.clone()))}}if(f.length===0&&E){const P=t.calculateUpperLength2D()>e.calculateUpperLength2D();{const C=[0,0];if(kg(P?t:e,C,!0)===2&&(b(z.unit().containsCoordinate(C[0])),!z.unit().containsCoordinate(C[1]))){const S=new y;Rt(P?l:u,C[0],S);const I=[0,0];Wi(P?u:l,S,z.unit(),!1,-1,2,I)===1&&(p.push(S.clone()),f.push(P?C[0]:I[0]),x.push(P?I[0]:C[0]))}}}if(f.length===0)return 0;if(!g.equalsRange(0,1))for(let P=0;P<f.length;++P)f[P]=ws.recalculateParentT(g.vmin,g.vmax,f[P]);if(!_.equalsRange(0,1))for(let P=0;P<x.length;++P)x[P]=ws.recalculateParentT(_.vmin,_.vmax,x[P]);return rs(r,t,e,f,x,f.length,s,i,n,o,a,h,m)}function Yh(r,t,e,s,i,n,o,a,h,m){const l=Xe(t,e);if(e.isDegenerateToLineHelper(l)){const C=new ht({start:e.getStartXY(),end:e.getEndXY()}),S=pr(r,t,C,s,i,n,o,a,h,m);if(n)for(let I=0;I<S;++I){const w=C.getCoord2D(n[I]);n[I]=e.getClosestCoordinate(w,!1)}return S}if(ns(t,e,o=Math.max(o,l)))return 0;const u=R(y,4);t.queryControlPoints(u);const c=R(y,3);e.queryControlPoints(c);const g=new z(0,1),_=new z(0,1),d=[0,0,0];e.queryWeights(d);const p=[1,Ds(d),1];{const C=new ce;ko(u,new z(0,1),C);const S=new ce;yr(c,p,new z(0,1),S);const I=Math.max(C.maxDim(),S.maxDim());if(C.inflate(3*o),S.inflate(3*o),!C.intersectW(S))return 0;if(C.maxDim()<.1*I){if(Rh(u,C,g),g.isEmpty()||(Wh(c,p,C,_),_.isEmpty()))return 0;vi(u,g.vmin,g.vmax,u),bi(c,p,_.vmin,_.vmax,c,p)}}const f=Vn(u,3,c,2,o);if(f===0)return 0;const x=[],E=[],P=[];if(f===-1){const C=R(Et,4);Sn(u,C);const S=[C[0].x,C[1].x,C[2].x,C[3].x],I=[C[0].y,C[1].y,C[2].y,C[3].y],w=R(J,3),D=R(J,3),N=R(J,3);Cr(c,p,w,D,N);const A=[],M=[],G=Mn(w,2,D,2,N,2,S,3,I,3,null,0,!0,z.unit(),z.unit(),M,A,h);if(G>0)for(let q=0;q<G;q++){const V=new y;Rt(u,A[q],V);const k=new y;Ut(c,p,M[q],k),y.distance(V,k)<=o&&(x.push(V.clone()),E.push(A[q]),P.push(M[q]))}}for(let C=0;C<2;C++){let S,I;C===0?(S=u,I=c):(I=u,S=c);for(let w=0;w<2;w++){const D=w===0?0:S.length-1,N=[0],A=new y;if(C===0){const M=Ym(I,p,S[D],z.unit(),!1,-1,1,N);b(M===1),Ut(I,p,N[0],A)}else{const M=Wi(I,S[D],z.unit(),!1,-1,1,N);b(M===1),Rt(I,N[0],A)}y.distance(S[D],A)<=o&&(C===0?(E.push(D===0?0:1),P.push(N[0])):(P.push(D===0?0:1),E.push(N[0])),x.push(A.clone()))}}if(E.length===0)return 0;if(!g.equalsRange(0,1))for(let C=0;C<E.length;++C)E[C]=ws.recalculateParentT(g.vmin,g.vmax,E[C]);if(!_.equalsRange(0,1))for(let C=0;C<P.length;++C)P[C]=Ge.recalculateParentT(_.vmin,_.vmax,P[C]);for(let C=0;C<P.length;++C)P[C]=vn(d,P[C]);return rs(r,t,e,E,P,E.length,s,i,n,o,a,h,m)}function Xh(r,t,e,s,i,n,o,a,h,m){const l=Xe(t,e);if(ns(t,e,o=Math.max(o,l)))return 0;const u=R(y,4);t.queryControlPoints(u);const c=R(y,3);e.queryControlPoints(c);const g=Vn(u,3,c,2,o);if(g===0)return 0;const _=[],d=[],p=[];if(g===-1){const f=R(Et,4);Sn(u,f);const x=[f[0].x,f[1].x,f[2].x,f[3].x],E=[f[0].y,f[1].y,f[2].y,f[3].y],P=R(Et,3);En(c,P);const C=Mn([P[0].x,P[1].x,P[2].x],2,[P[0].y,P[1].y,P[2].y],2,null,0,x,3,E,3,null,0,!0,z.unit(),z.unit(),p,d,a);if(C>0){let S=0;for(let I=0;I<C;I++){const w=new y;t.queryCoord2D(d[I],w);const D=new y;e.queryCoord2D(p[I],D),y.distance(w,D)<=o&&(_.push(w.clone()),d[S]=d[I],p[S]=p[I],S++)}d.length=S,_.length=S}}for(let f=0;f<2;f++){let x,E;f===0?(x=u,E=c):(E=u,x=c);for(let P=0;P<2;P++){const C=P===0?0:x.length-1,S=[0],I=new y;if(f===0)pa(E,x[C],S),Is(E,S[0],I);else{const w=Wi(E,x[C],z.unit(),!1,-1,1,S);b(w===1),Rt(E,S[0],I)}y.distance(x[C],I)<=o&&(f===0?(d.push(C===0?0:1),p.push(S[0])):(p.push(C===0?0:1),d.push(S[0])),_.push(I.clone()))}}return rs(r,t,e,d,p,d.length,s,i,n,o,a,h,m)}function f0(r,t,e,s,i){const n=new ce;if(Xg(r,z.unit(),n),n.inflate(s),!n.isIntersectingPoint2D(t))return 0;const o=_r(r);let a=0,h=o.specialPoints[0];const m=[];for(let l=1,u=o.specialPoints.length;l<u;++l){const c=o.specialPoints[l],g=h0(r,t,h,c);if(m.length===0)m.push(g);else if(g.t===g.tmin)b(m.at(-1).d<=g.d),m.at(-1).tmax=g.tmax;else if(m.at(-1).t===m.at(-1).tmax){b(m.at(-1).d>=g.d);const _=m.at(-1).tmin;m[m.length-1]=g,m.at(-1).tmin=_}else m.push(g);h=c}for(const l of m)if(l.d<=s){const u=l.t;e&&(a>=e.length&&ut(""),e[a]=u),a++}return a}function Xg(r,t,e){const s=R(y,4);r.queryControlPoints(s),ko(s,t,e)}function ko(r,t,e){if(t.equalsRange(0,1))return void e.setFromPoints(r,4);const s=R(y,4);vi(r,t.vmin,t.vmax,s),e.setFromPoints(s,4)}let Rg=class{constructor(t,e,s){this.dbgCounter=0,this.controlPoints=t,this.point=e.clone(),this.maxDistance=s}getMaxDerivative(){return 6}getValue(t,e){switch(t){case 0:{const s=new y;Rt(this.controlPoints,e,s);const i=ye(this.controlPoints,1,e);return 2*s.sub(this.point).dotProduct(i)}case 1:{const s=new y;Rt(this.controlPoints,e,s);const i=ye(this.controlPoints,1,e),n=ye(this.controlPoints,2,e);return 2*(s.sub(this.point).dotProduct(n)+i.dotProduct(i))}case 2:{const s=new y;Rt(this.controlPoints,e,s);const i=ye(this.controlPoints,1,e),n=ye(this.controlPoints,2,e),o=ye(this.controlPoints,3,e);return 2*(s.sub(this.point).dotProduct(o)+3*i.dotProduct(n))}case 3:{const s=ye(this.controlPoints,1,e),i=ye(this.controlPoints,2,e),n=ye(this.controlPoints,3,e);return 2*(4*s.dotProduct(n)+3*i.sqrLength())}case 4:{const s=ye(this.controlPoints,2,e),i=ye(this.controlPoints,3,e);return 2*(10*s.dotProduct(i))}case 5:{const s=ye(this.controlPoints,3,e);return 2*(10*s.dotProduct(s))}default:return 0}}getError(t){return 0}isInterestingInterval(t,e){if(t>=0&&e<=1){const s=R(y,4);vi(this.controlPoints,t,e,s);const i=new ce;if(i.setFromPoints(s,4),Math.sqrt(i.sqrMinDistance(this.point))>this.maxDistance)return!1}return!0}};function Wi(r,t,e,s,i,n,o){tr(z.unit().contains(e)&&n>0,"getClosestCoordinate"),(i<0||Number.isNaN(i))&&(i=Number.MAX_VALUE);const a=[],h=new y;Rt(r,e.vmin,h);let m=y.distance(h,t);if(m<=i&&a.push(new y(e.vmin,m)),e.vmin!==e.vmax&&(Rt(r,e.vmax,h),m=y.distance(h,t),m<=i&&a.push(new y(e.vmax,m))),e.width()>0){const c=j(18,Number.NaN),g=Ti(new Rg(r,t,i),e,18,c);for(let _=0;_<g;_++)Rt(r,c[_],h),m=y.distance(h,t),m>i||a.push(new y(c[_],m))}if(s){b(e.equals(z.unit()));{Rt(r,-1,h,!0);const c=new y;Rt(r,0,c);const g=new ht({start:h,end:c}),_=g.getClosestCoordinate(t,!0);_<1&&(h.assign(g.getCoord2D(_)),m=y.distance(h,t),m<=i&&a.push(new y(_-1,m)))}{Rt(r,2,h,!0);const c=new y;Rt(r,e.vmax,c);const g=new ht({start:c,end:h}),_=g.getClosestCoordinate(t,!0);_>0&&(h.assign(g.getCoord2D(_)),m=y.distance(h,t),m<=i&&a.push(new y(1+_,m)))}}if(!a.length)return 0;a.sort((c,g)=>c.compare(g));let l=0;const u=a[0].x;if(o[l++]=u,l<n){const c=Jc(r,4,!1).total(),g=a[0].y;for(let _=1,d=a.length;_<d;_++)if(a[_].y>g+c){a.length=_;break}a.sort((_,d)=>Os(_.x,d.x)),l=0,o[l++]=a[0].x;for(let _=1,d=a.length;_<d;_++)a[_].x!==o[l-1]&&l<n&&(o[l++]=a[_].x)}return l}function Lo(r,t,e,s,i,n,o){const a=R(y,4);return r.queryControlPoints(a),Wi(a,t,e,s,i,n,o)}function x0(r){return r.getStartXY().norm(1)+r.getEndXY().norm(1)+r.m_cp[0].norm(1)+r.m_cp[1].norm(1)}function y0(r){return r[0].norm(1)+r[1].norm(1)+r[2].norm(1)+r[3].norm(1)}function P0(r,t,e){if(b(e>=2),e===2){const _=new y;Qt(t[0],t[e-1],1/3,_);const d=new y;return Qt(t[0],t[e-1],2/3,d),void r.construct(t[0],_,d,t[e-1])}const s=t[0],i=t[e-1],n=[0,0],o=Lo(r,s,z.unit(),!1,Number.NaN,2,n),a=[0,0],h=Lo(r,i,z.unit(),!1,Number.NaN,2,a),m=[];for(let _=0;_<o;_++)for(let d=0;d<h;d++){const p=n[_],f=a[d],x=p>f,E=(I,w)=>{const D=j(e-2,Number.NaN),N=()=>{let B=0;for(let W=1,Z=e-1;W<Z;W++){B+=y.distance(t[W-1],t[W]);const gt=B;D[W-1]=gt}B+=y.distance(t[e-2],t[e-1]),x&&D.reverse();for(let W=1,Z=e-1;W<Z;W++)D[W-1]/=B,x&&(D[W-1]=1-D[W-1])};let A=!1,M=!1;{const B=new it;x?(r.queryCut(f,p,B,!0),I.assign(B.get().getControlPoint2()),w.assign(B.get().getControlPoint1())):(r.queryCut(p,f,B,!0),I.assign(B.get().getControlPoint1()),w.assign(B.get().getControlPoint2())),s.equals(I)&&(A=!0),i.equals(w)&&(M=!0)}N();let G=Number.MAX_VALUE;const q=I.clone(),V=w.clone();for(let B=0;B<5;B++)G=Ua(!0,!1,s,q,V,i,A,M,D,e-2,t,e);for(let B=0;B<30;B++){const W=q.clone();V.clone();const Z=Ua(!0,!0,s,q,V,i,A,M,D,e-2,t,e);if(G<=Z&&W.equals(q)&&W.equals(V))break;G=Z}N();let k=!1,Y=Number.MAX_VALUE;const U=I.clone(),X=w.clone();for(let B=0;B<30;B++){const W=U.clone();X.clone();const Z=Ua(k,!0,s,U,X,i,A,M,D,e-2,t,e);if(Y<=Z&&W.equals(U)&&W.equals(X))break;k=!0,Y=Z}return Y<G?(I.assign(U),w.assign(X)):(I.assign(q),w.assign(V),Y=G),Y},P=new y,C=new y,S=[E(P,C),y.distance(s,P)+y.distance(P,C)+y.distance(C,i),P.x,P.y,C.x,C.y];m.splice(m.length,0,...S)}let l=m[0],u=m[1],c=0;for(let _=6;_<m.length;_+=6)m[_]<l&&(l=m[_],u=m[_+1],c=_);let g=c;for(let _=0;_<m.length;_+=6)_!==c&&m[_+1]<u&&Math.abs(l-m[_])<10*l&&(u=m[_+1],g=_);r.construct(s,new y(m[g+2],m[g+3]),new y(m[g+4],m[g+5]),i)}function kg(r,t,e=!1){const s=R(y,4);r.queryControlPoints(s);const i=R(Et,4);let n,o,a;Sn(s,i,!0);const h=i[3].x.isZero(),m=i[3].y.isZero();if(h||m)if(h&&!m){if(i[2].x.isZero())return 0;n=i[1].x.div(i[2].x).negate(),o=i[2].y.div(i[3].y),a=i[1].y.div(i[3].y)}else{if(h||!m||i[2].y.isZero())return 0;n=i[1].y.div(i[2].y).negate(),o=i[2].x.div(i[3].x),a=i[1].x.div(i[3].x)}else{i[2].x.divThis(i[3].x),i[1].x.divThis(i[3].x),i[2].y.divThis(i[3].y),i[1].y.divThis(i[3].y);const g=i[2].x.sub(i[2].y);if(g.isZero())return 0;n=i[1].x.sub(i[1].y).div(g).negate(),o=i[2].x.clone(),a=i[1].x.clone()}if(!e&&n.abs().value()>2)return 0;const l=[0,0],u=r.getStartXY().equals(r.getEndXY()),c=Ui(1,-n.toDouble(),n.add(o).mul(n).add(a).toDouble(),z.unit(),u,l);if(c===0)return 0;if(l[0]>=0&&l[0]<=1){const g=n.toDouble()-l[0];if(e||g>=0&&g<=1)return t[0]=l[0],t[1]=g,t[0]>t[1]&&(t[1]=O(t[0],t[0]=t[1])),2}if(c===2&&l[1]>=0&&l[1]<=1){const g=n.toDouble()-l[1];if(e||g>=0&&g<=1)return t[0]=l[1],t[1]=g,t[0]>t[1]&&(t[1]=O(t[0],t[0]=t[1])),2}return 0}function C0(r,t,e){const s=r[1].mulE(t[2]).subThisE(r[2].mulE(t[1])),i=r[1].mulE(t[3]).subThisE(r[3].mulE(t[1])).mulThis(3),n=r[2].mulE(t[3]).subThisE(r[3].mulE(t[2])).mulThis(3),o=R(L,2);let a=$e(n,i,s,new z(0,1),!1,o);a<0&&(a=0);let h=0;for(let m=0;m<a;m++)qt(o[m].value(),0,1)||(e[h].setE(o[m]),h++);return h}function Lg(r,t){t[0].set(0);let e=1;const s=R(L,4);Mm(r,s,!0);const i=R(L,4);Gm(r,i,!0);{const n=s[3].mul(3),o=s[2].mul(2),a=s[1].clone(),h=R(L,2);let m=$e(n,o,a,new z(0,1),!1,h);m<0&&(m=0);for(let l=0;l<m;l++)qt(h[l].value(),0,1)||(t[e]=h[l],e++)}{const n=i[3].mul(3),o=i[2].mul(2),a=i[1].clone(),h=R(L,2);let m=$e(n,o,a,new z(0,1),!1,h);m<0&&(m=0);for(let l=0;l<m;l++)qt(h[l].value(),0,1)||(t[e]=h[l],e++)}if(e+=C0(s,i,t.slice(e)),t[e].set(1),e++,e>2){Vs(t,0,e,(l,u)=>{const c=l.value(),g=u.value();return c<g?-1:c>g?1:0});let n=0;const o=t[0].clone();let a=0;const h=y0(r)*jt(),m=new y;Jr(r,t[0].value(),m);for(let l=1;l<e;l++){const u=new y;if(Jr(r,t[l].value(),u),t[l].eq(o)||u.isEqualPoint2D(m,h)){if(n!==0){if(t[l].eps()===0)o.setE(t[l]),a=0;else if(a!==0){const c=yt(1/t[l].eps()),g=1/a,_=c+g;o.set((t[l].value()*c+o.value()*g)/_),a=1/_,o.setError(Math.sqrt(a))}t[n].setE(o),Jr(r,o.value(),m)}}else n++,t[n].setE(t[l]),o.setE(t[l]),Jr(r,o.value(),m),a=yt(t[l].eps())}n++,e=n}return e===1&&(e=2,t[1].set(1)),b(t[0].value()===0),b(t[e-1].value()===1),e}function E0(r,t,e,s,i){const n=R(L,4),o=R(L,3),a=new z(0,1);let h=0;if(t){if(Gm(r,n,!1),h=Go(n[3],n[2],n[1],n[0].sub(e),a,!1,o),s)for(let m=0;m<h;m++){const l=new y;Rt(r,o[m].value(),l),s[m]=l.x}}else if(Mm(r,n,!1),h=Go(n[3],n[2],n[1],n[0].sub(e),a,!1,o),s)for(let m=0;m<h;m++){const l=new y;Rt(r,o[m].value(),l),s[m]=l.y}if(i)for(let m=0;m<h;m++)i[m]=o[m].value();else s&&Vs(s,0,h,Os);return h}function S0(r,t,e,s){const i=_u(r,t,e,s.getEnvelope2D());if(i.isEmpty())return new z(i);const n=R(y,e);for(let a=0;a<e;++a)s.xyRot(r[a],n[a]);const o=_u(n,t,e,s.getRotatedEnvelope2D());return i.intersect(new z(o)),new z(i)}function _u(r,t,e,s){const i=R(y,e);for(let a=0;a<e;++a)i[a]=new y(a/(e-1),0);const n=(a,h,m,l)=>{const c=new L(h.x).subE(new L(a.x)).divE(new L(h.y).subE(new L(a.y))).mulE(new L(m).subE(new L(a.y))).addE(new L(a.x));if(c.eps()>.1){const d=(h.x-a.x)/(h.y-a.y)*(m-a.y)+a.x;c.set(d,jt())}if(c.lt(new L(0))||c.gt(new L(1)))return!1;let g=c.value()-c.eps();g=Nt(g,0,1);let _=c.value()+c.eps();return _=Nt(_,0,1),l.mergeCoordinate(g),l.mergeCoordinate(_),!0},o=[];{const a=(l,u)=>{o.length=e;const c=Mh(i,e,o,!0),g=new z;g.setEmpty();const _=f=>f.y<l?-1:f.y>u?1:0;let d=i[o[0]],p=_(d);p===0&&g.mergeCoordinate(d.x);for(let f=1;f<=c;++f){const x=i[o[f%c]],E=_(x);E===0&&g.mergeCoordinate(x.x);let P=0;E!==p&&(P=E*p===0?E===1||p===1?2:1:3,1&P&&n(d,x,l,g),2&P&&n(d,x,u,g)),d=x,p=E}return g};for(let l=0;l<e;++l)i[l].y=r[l].x;const h=a(s.xmin,s.xmax);if(h.isEmpty())return new z(h);for(let l=0;l<e;++l)i[l].y=r[l].y;const m=a(s.ymin,s.ymax);return h.intersect(new z(m)),new z(h)}}function Rh(r,t,e){e.setEmpty(),e.merge(S0(r,null,4,t))}function v0(r,t,e){e.length=0;{const w=new L;Vg(r,w);const D=new K;if(Yg(r,w,D),D.isZero())return w.isZero()||w.eq(new L(1))?0:(e.push(w.value()),1)}const s=R(L,4);Fg(r,s,!0);const i=R(L,4);Mg(r,i,!0);const n=R(L,6),o=s[3].negate().mulE(i[1]).addE(s[2].mulE(i[2]).mul(2)).addE(s[1].mulE(i[3])),a=s[3].negate().mulE(i[1]).subE(s[2].mulE(i[2]).mul(2)).addE(s[1].mulE(i[3])),h=s[2].mulE(s[2]).subE(i[2].mulE(i[2]));n[0]=i[1].mulE(i[1]).mulE(o).addE(s[1].mulE(s[1]).mulE(a)).addE(s[1].mulE(i[1]).mulE(h).mul(2)).mul(6),n[1]=s[2].mulE(i[1]).subE(s[1].mulE(i[2])).mulE(s[2].mulE(s[2]).addE(s[1].mulE(s[3]).mul(2)).addE(i[2].mulE(i[2])).addE(i[1].mulE(i[3]).mul(2))).mul(24);const m=s[1].mulE(i[2]).mulE(i[2]).mulE(i[3]),l=s[2].mulE(s[2]).mulE(s[3]).mulE(i[1]).subE(m).mul(156),u=s[3].mulE(i[1]).subE(s[1].mulE(i[3])),c=s[3].mulE(i[1]).subE(s[1].mulE(i[3])),g=s[1].mulE(s[3]).mulE(c).addE(i[1].mulE(i[3]).mulE(u)).mul(72),_=i[1].mulE(i[3]).subE(s[1].mulE(s[3])),d=s[2].mulE(i[2]).mulE(_).mul(120),p=s[1].mulE(s[2]).mulE(s[2]).mulE(i[3]),f=s[3].mulE(i[1]).mulE(i[2]).mulE(i[2]).subE(p).mul(36);n[2]=l.addE(g).addE(d).addE(f);const x=s[2].mulE(s[3]).mulE(s[3]).mulE(i[1]).subE(s[1].mulE(i[2]).mulE(i[3]).mulE(i[3])).mul(360),E=s[2].mulE(i[2]).mulE(s[2].mulE(s[3]).subE(i[2].mulE(i[3]))).addE(s[3].mulE(i[2]).mulE(i[2]).mulE(i[2])).subE(s[2].mulE(s[2]).mulE(s[2]).mulE(i[3])).mul(24),P=s[2].mulE(i[1]).mulE(i[3]).mulE(i[3]).subE(s[1].mulE(s[3]).mulE(s[3]).mulE(i[2])).mul(72),C=s[3].mulE(i[3]).mulE(i[1].mulE(i[2]).subE(s[1].mulE(s[2]))).mul(288);n[3]=x.addE(E).addE(P).addE(C),n[4]=i[3].mulE(i[3]).addE(s[3].mulE(s[3])).mulE(s[3].mulE(i[1]).subE(s[1].mulE(i[3]))).mul(270).addE(s[3].mulE(i[2]).subE(s[2].mulE(i[3]))).mulE(s[2].mulE(s[3]).addE(i[2].mulE(i[3]))).mul(180),n[5]=s[3].mulE(i[2]).subE(s[2].mulE(i[3])).mulE(s[3].mulE(s[3]).addE(i[3].mulE(i[3]))).mul(216);const S=R(L,5),I=cg(n,5,new z(0,1),!1,S,5);if(I>0){let w=Math.abs(r.getCurvature(0)),D=0;const N=Math.abs(r.getCurvature(1));(N>w||!Number.isFinite(N))&&(D=1);for(let A=0;A<I;A++){const M=Math.abs(r.getCurvature(S[A].value()));r.getCoord2D(S[A].value()),(M>w||!Number.isFinite(M))&&(w=M,D=S[A].value())}if((!Number.isFinite(w)||1/w<t)&&!qt(D,0,1)){const A=r.getCoord2D(D);if(!A.equals(r.getStartXY())&&!A.equals(r.getEndXY()))return e.push(D),1}}if(!r.isClosed()){const w=[0,0],D=kg(r,w,!1);for(let N=0;N<D;N++)w[N]>0&&w[N]<1&&e.push(w[N]);return e.length}return 0}let b0=class{constructor(t,e){this.b=t,this.len=e}getMaxDerivative(){return 1}getValue(t,e){return t===0?this.len-gr(this.b,e,!1):0}getError(t){return 0}};function kh(r,t,e,s,i,n,o){for(;;){const a=y.distance(t[0],t[3]),h=y.distance(t[0],t[1])+y.distance(t[1],t[2])+y.distance(t[2],t[3]);if(h-a<=s+e*h)return r+Ct(a,h,.5);const m=C=>ye(t,1,C).length();{b(o<12);let C=m(0),S=m(1);i[0]+=2,C>S&&(S=O(C,C=S),t[3]=O(t[0],t[0]=t[3]),t[2]=O(t[1],t[1]=t[2]));let I=C/(C+S),w=1,D=h;for(;I<1/32&&D>=32*(s+e*D);){w/=4;const N=m(w);i[0]++,I=C/(N+C);const A=new y;if(Rt(t,.5*w,A),D=y.distance(A,t[0]),D<=s){const M=new y;Rt(t,w,M),D+=y.distance(M,A)}}if(w!==1){const N=R(y,4);dr(t,w,t,N),r=kh(r,N,e,s,i,0,o+1),n++,o++;continue}}const l=8;i[0]+=l;const u=zs(l,m,0,1),c=16;i[0]+=c;const g=zs(c,m,0,1);let _=Math.abs(u-g)>s+e*h;if(!_)return r+g;if(n<3){const C=R(y,4);dr(t,.5,t,C),r=kh(r,C,e,s,i,n+1,o+1),n++,o++;continue}const d=32;i[0]+=d;const p=zs(d,m,0,1);if(_=Math.abs(g-p)>s+e*h,!_)return r+p;const f=64;i[0]+=f;const x=zs(f,m,0,1);if(_=Math.abs(p-x)>s+e*h,!_)return r+x;const E=128;i[0]+=E;const P=zs(E,m,0,1);return _=Math.abs(x-P)>s+e*h,r+P}}function I0(r,t,e,s,i){if(e===t)return 0;const n=R(y,4);r.queryControlPoints(n);const o=R(y,4);return vi(n,t,e,o),kh(0,o,s,i,[0],0,0)}function w0(r,t,e,s,i){let n=!0;const o=Cn(5,t,e,s,i,h=>{const m=Ri(r,1,h);return(n?r.getCoordX(h)-r.getStartX():r.getCoordY(h)-r.getStartY())*m.length()});n=!1;const a=Cn(5,t,e,s,i,h=>{const m=Ri(r,1,h);return(n?r.getCoordX(h)-r.getStartX():r.getCoordY(h)-r.getStartY())*m.length()});return new y(o,a)}function D0(r,t,e,s,i,n,o,a,h){const m=R(y,4);r.queryControlPoints(m);const l=R(y,4);if(t.queryControlPoints(l),m[0].equals(l[0])){if(m[1].equals(l[1])&&m[2].equals(l[2])&&m[3].equals(l[3]))return e&&(e.length=0,e.push(m[0]),e.push(m[3])),s&&(s.length=0,s.push(0),s.push(1)),i&&(i.length=0,i.push(0),i.push(1)),!0;if(!m[0].equals(l[3]))return!1}return!!(m[0].equals(l[3])&&m[1].equals(l[2])&&m[2].equals(l[1])&&m[3].equals(l[0]))&&(s&&(s.length=0,s.push(0),s.push(1),h&&(s[1]=O(s[0],s[0]=s[1]))),i&&(i.length=0,i.push(1),i.push(0),h&&(i[1]=O(i[0],i[0]=i[1]))),e&&(e.length=0,e.push(m[0]),e.push(m[3]),h&&(e[1]=O(e[0],e[0]=e[1]))),!0)}function Ua(r,t,e,s,i,n,o,a,h,m,l,u){b(m+2===u);let c=0,g=0,_=0,d=0,p=0,f=0,x=0;const E=(C,S)=>{const I=1-S,w=e.mul(yl(I)),D=s.mul(3*S*I*I),N=i.mul(3*S*S*I),A=n.mul(yl(S));return w.add(D).add(N).add(A).sub(l[C]).sqrLength()};for(let C=1,S=u-1;C<S;C++){let I=h[C-1];if(r){C>2?(I=Nt(2*h[C-2]-h[C-3],0,1),h[C-1]=I):C===2&&(I=Nt(2*h[C-2],0,1),h[C-1]=I);const k=(Y,U,X)=>{let B=-1;for(let W=0;!(Math.abs(U-B)<1e-12)&&W!==10;W++){const Z=U*U,gt=1-U,at=gt*gt,Q=at*gt,rt=e.x-2*s.x+i.x,nt=e.x-3*s.x+3*i.x-n.x,ot=e.y-2*s.y+i.y,Gt=e.y-3*s.y+3*i.y-n.y,Ot=e.x-s.x-2*rt*U+nt*Z,Ht=-l[Y].x+e.x*Q+U*(3*s.x*at+U*(3*i.x*gt+n.x*U)),It=e.y-s.y-2*ot*U+Gt*Z,Jt=-l[Y].y+e.y*Q+U*(3*s.y*at+U*(3*i.y*gt+n.y*U)),Wt=-6*(Ot*Ht+It*Jt),Re=6*(3*yt(Ot)-(-2*rt+2*nt*U)*Ht)+6*(3*yt(It)-(-2*ot+2*Gt*U)*Jt);if(B=U,Re===0)break;U=Nt(U-Wt/Re,X,1)}return B};{const Y=E(C,h[C-1]);let U=k(C,h[C-1],0),X=E(C,U);if(1.01*Y<X){const B=C>1?h[C-2]:0,W=k(C,.3*(h[C-1]-B)+B,0),Z=E(C,W);Z<X&&(X=Z,U=W)}Y>X&&(h[C-1]=U)}}const w=h[C-1],D=w*w,N=D*w,A=1-w,M=A*A,G=M*A;c+=3*D*M*M,g+=3*N*G,_+=3*D*D*M;const q=-(G*e.x+N*n.x-l[C].x);d+=q*w*M,p+=q*D*A;const V=-(G*e.y+N*n.y-l[C].y);f+=V*w*M,x+=V*D*A}if(t){const C=c*_-g*g;Math.abs(C)>=1e-12*(Math.abs(c*_)+Math.abs(g*g))+1e-10?(o||(s.x=(d*_-p*g)/C,s.y=(f*_-x*g)/C),a||(i.x=(c*p-g*d)/C,i.y=(c*x-g*f)/C)):(Qt(e,n,.3,s),Qt(e,n,.6,i))}let P=0;for(let C=1,S=u-1;C<S;C++)P+=E(C,h[C-1]);return P}var to=Mt;let ws=class Bg extends Rr{constructor(t){t&&t.cp?(super({start:t.cp[0],end:t.cp[3],vd:t.vd}),this.m_cp=R(y,2),this.m_cp[0].assign(t.cp[1]),this.m_cp[1].assign(t.cp[2])):t===void 0||ha(t,"vd")?(super({vd:t?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_cp=R(y,2),this.m_cp[0].setCoords(0,0),this.m_cp[1].setCoords(0,0)):t.from?(super({start:t.from,end:t.to,vd:t.vd}),this.m_cp=R(y,2),this.m_cp[0].assign(t.cp1),this.m_cp[1].assign(t.cp2)):(super({XStart:0,YStart:0,XEnd:0,YEnd:0,vd:t.vd}),$("unrecognized constructor params"),this.m_cp=R(y,2),this.m_cp[0].setCoords(0,0),this.m_cp[1].setCoords(0,0)),this.m_cachedValues=0}getBoundary(){return Gs(this)}construct(t,e,s,i){this.m_XStart=t.x,this.m_YStart=t.y,this.m_XEnd=i.x,this.m_YEnd=i.y,this.m_cp[0].assign(e),this.m_cp[1].assign(s),this.afterCompletedModification()}constructPoints(t){this.m_XStart=t[0].x,this.m_YStart=t[0].y,this.m_XEnd=t[3].x,this.m_YEnd=t[3].y,this.m_cp[0].assign(t[1]),this.m_cp[1].assign(t[2]),this.afterCompletedModification()}constructFromQuadratic(t){const e=R(y,4);Xf(t,e),this.constructPoints(e)}constructFromQuadraticSegment(t){this.dropAllAttributes(),this.assignVertexDescription(t.getDescription()),this.m_XStart=t.getStartX(),this.m_YStart=t.getStartY(),this.m_XEnd=t.getEndX(),this.m_YEnd=t.getEndY(),Qn(2,t.getStartXY(),t.getControlPoint1(),2/3,this.m_cp[0]),Qn(2,t.getControlPoint1(),t.getEndXY(),1/3,this.m_cp[1]),this.afterCompletedModification(),ng(this,t)}getGeometryType(){return T.enumBezier}queryEnvelope(t){if(t.m_EnvelopeType!==2)return void b(0);if(t.setCoords(this.getStartXY()),t.mergeNe(this.getEndXY()),t.contains(this.m_cp[0])&&t.contains(this.m_cp[1]))return;const e=hu(this);if(e!==null){const a=new y;for(const h of e.specialPoints)this.queryCoord2D(h,a),t.mergeNe(a);return}const s=R(L,8),i=R(y,4);this.queryControlPoints(i);const n=Lg(i,s),o=new y;for(let a=1;a<n-1;a++)this.queryCoord2D(s[a].value(),o),t.mergeNe(o)}applyTransformation(t){if(t.m_TransformationType===1){const e=R(y,4);return this.queryControlPoints(e),t.transformPoints2D(e,4,e),this.setStartXY(e[0]),this.m_cp[0].assign(e[1]),this.m_cp[1].assign(e[2]),this.setEndXY(e[3]),void za(this)}b(0)}createInstance(){return new Bg({vd:this.m_description})}calculateLength2D(){return gr(this,1,!1)}calculateLowerLength2D(){return y.distance(this.getStartXY(),this.getEndXY())}calculateUpperLength2D(){return y.distance(this.getStartXY(),this.m_cp[0])+y.distance(this.m_cp[0],this.m_cp[1])+y.distance(this.getEndXY(),this.m_cp[1])}queryCoord2D(t,e){return this.queryCoord2DExtends(t,e,!0)}queryCoord2DMP(t,e){b(0)}queryCoord2DExtends(t,e,s){const i=R(y,4);this.queryControlPoints(i),Rt(i,t,e,s)}queryCoord2DE(t,e){_0(this,t,e)}getCoordX(t){if(t<0||t>1){const a=new y;return this.queryCoord2DExtends(t,a,!0),a.x}const e=Ct(this.getStartX(),this.m_cp[0].x,t),s=Ct(this.m_cp[0].x,this.m_cp[1].x,t),i=Ct(this.m_cp[1].x,this.getEndX(),t),n=Ct(e,s,t),o=Ct(s,i,t);return Ct(n,o,t)}getCoordY(t){if(t<0||t>1){const a=new y;return this.queryCoord2DExtends(t,a,!0),a.y}const e=Ct(this.getStartY(),this.m_cp[0].y,t),s=Ct(this.m_cp[0].y,this.m_cp[1].y,t),i=Ct(this.m_cp[1].y,this.getEndY(),t),n=Ct(e,s,t),o=Ct(s,i,t);return Ct(n,o,t)}cut(t,e,s){const i=new it;return this.queryCut(t,e,i,s),i.releaseSegment()}queryCut(t,e,s,i){const n=s.createCubicBezier();if(this.cutBezierIgnoreAttributes(t,e,n),i)return;n.assignVertexDescription(this.m_description);const o=this.m_description.getAttributeCount();if(o>1){for(let a=1;a<o;a++){const h=this.m_description.getSemantics(a),m=to.getComponentCount(h);for(let l=0;l<m;l++){const u=this.getAttributeAsDbl(t,h,l);n.setStartAttribute(h,l,u)}}for(let a=1;a<o;a++){const h=this.m_description.getSemantics(a),m=to.getComponentCount(h);for(let l=0;l<m;l++){const u=this.getAttributeAsDbl(e,h,l);n.setEndAttribute(h,l,u)}}}}queryDerivative(t,e){Yg(this,t,e)}cutBezierIgnoreAttributes(t,e,s){(t<0||e>1||t>e)&&H("Cubic_bezier.cut_bezier_ignore_attributes");const i=R(y,4);this.queryControlPoints(i);const n=R(y,4);vi(i,t,e,n),s.setControlPoints(n)}splitBezierIgnoreAttributes(t,e,s){this===e&&this===s&&H("Cubic_bezier.split_bezier_ignore_attributes");const i=R(y,4);this.queryControlPoints(i);const n=R(y,4),o=R(y,4);dr(i,t,n,o),e&&e.setControlPoints(n),s&&s.setControlPoints(o)}getAttributeAsDbl(t,e,s){if(e===0)return s===0?this.getCoordX(t):this.getCoordY(t);if(t===0)return this.getStartAttributeAsDbl(e,s);if(t===1)return this.getEndAttributeAsDbl(e,s);const i=this.getStartAttributeAsDbl(e,s),n=this.getEndAttributeAsDbl(e,s),o=this.calculateLength2D(),a=o>0?this.tToLength(t)/o:0,h=to.getInterpolation(e);return Fr(h,i,n,a,to.getDefaultValue(e))}getClosestCoordinate(t,e){const s=[Number.NaN];return Lo(this,t,z.unit(),e,-1,1,s),s[0]}getClosestCoordinateOnInterval(t,e,s=-1){const i=[Number.NaN];return Lo(this,t,e,!1,s,1,i)===0?Number.NaN:i[0]}getYMonotonicParts(t,e=!1){return this.getMonotonicParts(t,e)}getMonotonicParts(t,e){t.length<2&&H("");const s=_r(this);if(s.specialPointsCount()===2&&this.isMonotoneQuickAndDirty())return 0;let i=0;b(t.length>=s.specialPointsCount()-1);for(let n=1,o=s.specialPointsCount();n<o;++n)this.queryCut(s.specialPoints[n-1],s.specialPoints[n],t[i],e),i++;for(let n=0;n<i;++n)Xo(t[n].get());return i}intersectionWithAxis2D(t,e,s,i){const n=R(y,4);return this.queryControlPoints(n),E0(n,t,e,s,i)}intersectionOfYMonotonicWithAxisX(t,e){if(this.m_YStart===this.m_YEnd)return t===this.m_YStart?e:Number.NaN;if(t===this.m_YStart)return this.m_XStart;if(t===this.m_YEnd)return this.m_XEnd;const s=[0,0],i=this.intersectionWithAxis2D(!0,t,s,null);return b(i!==2),i===-1?e:s[0]}isCurve(){return!0}isDegenerate(t){return _a(this,t)}isDegenerate3D(t,e){return b(0),!1}queryLooseEnvelope(t){if(t.m_EnvelopeType===2)return t.setCoords({pt:this.getStartXY()}),t.mergeNe(this.m_cp[0]),t.mergeNe(this.m_cp[1]),void t.mergeNe(this.getEndXY());b(0)}clone(t){const e=this.createInstance();return this.copyTo(e),e}queryInterval(t,e){if(t===0){const s=F.constructEmpty();this.queryEnvelope(s);const i=z.constructEmpty();return e===0?s.queryIntervalX(i):s.queryIntervalY(i),i}return super.queryInterval(t,e)}queryLooseEnvelopeOnInterval(t,e){const s=R(y,4);this.queryControlPoints(s),vi(s,t.vmin,t.vmax,s),e.setFromPoints(s,4)}changeEndPoints2D(t,e){if(t.isEqual(this.m_XStart,this.m_YStart)&&e.isEqual(this.m_XEnd,this.m_YEnd))return;const s=this.m_cp[0].isEqual(this.m_XStart,this.m_YStart),i=this.m_cp[0].isEqual(this.m_XEnd,this.m_YEnd),n=this.m_cp[1].isEqual(this.m_XStart,this.m_YStart),o=this.m_cp[1].isEqual(this.m_XEnd,this.m_YEnd);this.setStartXY(t),this.setEndXY(e),s?this.m_cp[0].setCoordsPoint2D(t):i&&this.m_cp[0].setCoordsPoint2D(e),o?this.m_cp[1].setCoordsPoint2D(e):n&&this.m_cp[1].setCoordsPoint2D(t),this.normalizeAfterEndpointChange()}tToLength(t){return gr(this,t,!0)}lengthToT(t){return i0(this,t)}calculateWeightedAreaCentroid2D(t){const e=R(y,4);qg(this,e);const s=e[3],i=e[2],n=e[1],o=new y;o.x=(5*s.x*s.x*(7*i.y+16*n.y)+s.x*(-35*s.y*i.x+40*i.x*i.y-80*s.y*n.x+140*i.x*n.y+112*n.x*n.y)-2*(s.y*(20*i.x*i.x+70*i.x*n.x+56*n.x*n.x)-7*(4*i.x+5*n.x)*(-i.y*n.x+i.x*n.y)))/840,o.y=(-5*s.y*s.y*(7*i.x+16*n.x)+s.y*(5*s.x*(7*i.y+16*n.y)-4*(10*i.x*i.y+35*i.y*n.x+28*n.x*n.y))+2*(-7*(4*i.y+5*n.y)*(i.y*n.x-i.x*n.y)+s.x*(20*i.y*i.y+70*i.y*n.y+56*n.y*n.y)))/840;const a=mu(this);return o.x+=(e[0].x-t.x)*a,o.y+=(e[0].y-t.y)*a,o}calculateWeightedCentroid2D(){const t=new y;return this.isDegenerate(0)?(t.setCoords(0,0),t):s0(this)?(t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t):(t.assign(n0(this,1)),t)}getControlPoint1(){return this.m_cp[0].clone()}setControlPoint1(t){this.m_cp[0].setCoordsPoint2D(t),this.afterCompletedModification()}getControlPoint2(){return this.m_cp[1].clone()}setControlPoint2(t){this.m_cp[1].setCoordsPoint2D(t),this.afterCompletedModification()}queryControlPoints(t){t[0].assign(this.getStartXY()),t[1].assign(this.m_cp[0]),t[2].assign(this.m_cp[1]),t[3].assign(this.getEndXY())}queryControlPointsHelper(t){return this.queryControlPoints(t),4}setControlPoints(t){for(let e=0;e<4;e++)t[e].isNAN()&&H("NAN control points in bezier are not supported");this.m_XStart=t[0].x,this.m_YStart=t[0].y,this.m_cp[0].setCoordsPoint2D(t[1]),this.m_cp[1].setCoordsPoint2D(t[2]),this.m_XEnd=t[3].x,this.m_YEnd=t[3].y,this.afterCompletedModification()}getTangent(t){const e=R(y,4);return this.queryControlPoints(e),Gh(e,t)}getDerivative(t){const e=R(y,4);return this.queryControlPoints(e),ye(e,1,t)}getCurvature(t){const e=Ri(this,1,t),s=Ri(this,2,t),i=e.sqrLength();return i===0?Number.NaN:(e.divThis(Math.sqrt(i)),e.crossProduct(s)/i)}isIntersectingPoint(t,e,s){if(s&&(t.equals(this.getStartXY())||t.equals(this.getEndXY())))return!1;const i=new F;if(this.queryLooseEnvelope(i),i.inflateCoords(e,e),!i.contains(t))return!1;const n=this.getClosestCoordinate(t,!1),o=new y;return this.queryCoord2D(n,o),y.distance(o,t)<=e}isIntersectingPoint3D(t,e,s,i,n=1){return b(0),!1}isMonotoneQuickAndDirty(){const t=R(y,4);return this.queryControlPoints(t),c0(t)}getMonotonicPartParams(t,e){const s=_r(this),i=s.specialPointsCount();if(b(Xr.s_maxMonotonicPartParams>=i),!e)return s.specialPointsCount();t<i&&H("");for(let n=0;n<i;n++)e[n]=s.specialPoints[n];return i}normalizeAfterEndpointChange(){return!1}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){this.m_XEnd=O(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=O(this.m_YStart,this.m_YStart=this.m_YEnd);for(let t=0,e=this.m_description.getTotalComponentCount()-2;t<e;t++)this.m_attributes[t+e]=O(this.m_attributes[t],this.m_attributes[t]=this.m_attributes[t+e]);this.m_cp[1]=O(this.m_cp[0],this.m_cp[0]=this.m_cp[1]),this.m_cachedValues=null}}findMinDeriv(){const t=new L;return Vg(this,t),t.value()}isLine(){return!1}isDegenerateToLineHelper(t){const e=R(y,4);this.queryControlPoints(e);const s=e[3].sub(e[0]),i=s.length();if(y.distance(e[0],e[1])+y.distance(e[2],e[1])+y.distance(e[2],e[3])-i>t)return!1;const n=t;let o=e[1].clone();o.subThis(e[0]);let a=Math.abs(o.crossProduct(s))/i;return!(a>n)&&(o=e[2].clone(),o.subThis(e[1]),a=Math.abs(o.crossProduct(s))/i,!(a>n))}copyIgnoreAttributes(t){const e=R(y,4);this.queryControlPoints(e),t.setControlPoints(e)}calculateArea2DHelper(){return mu(this)}absNorm(){return x0(this)}queryEnvelopeW(t,e){Xg(this,t,e)}setSegmentFromCoordsForStitcher(t,e){P0(this,t,e)}writeInBufferStream(t,e){const s=new Float64Array(4);return this.writeInBuffer_(s),t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}writeInBuffer_(t){return t[0]=this.m_cp[0].x,t[1]=this.m_cp[0].y,t[2]=this.m_cp[1].x,t[3]=this.m_cp[1].y,4}readFromBufferStream(t,e){const s=new Float64Array(4);t.queryRange(e,s.length,s,!0,1),this.readFromBuffer_(s)}readFromBuffer_(t){this.m_cp=R(y,2),this.m_cp[0].x=t[0],this.m_cp[0].y=t[1],this.m_cp[1].x=t[2],this.m_cp[1].y=t[3],this.m_cachedValues=null}snapControlPoints(t){const e=R(y,4);this.queryControlPoints(e);const s=(o,a,h)=>{let m=!1;return y.sqrDistance(o,h)<=t&&(m=!o.equals(h),o.setCoordsPoint2D(h),y.sqrDistance(a,h)<=t&&(m||=!a.equals(h),a.setCoordsPoint2D(h))),m},i=s(e[1],e[2],e[0]),n=s(e[2],e[1],e[3]);return(i||n)&&this.setControlPoints(e),i||n}needsSnapControlPoints(t){if(!t)return!1;const e=R(y,4);this.queryControlPoints(e);const s=(o,a,h)=>{let m=!1;return y.sqrDistance(o,h)<=t&&(m=!o.equals(h),o.setCoordsPoint2D(h),y.sqrDistance(a,h)<=t&&(m||=!a.equals(h),a.setCoordsPoint2D(h))),m},i=s(e[1],e[2],e[0]),n=s(e[2],e[1],e[3]);return i||n}calculateSpecialPointsForCracking(t,e){return v0(this,t,e)}ensureXYMonotone(){return Xo(this)}setCoordsForIntersector(t,e,s){o0(this,t,e,s)}copyToImpl(t){const e=t;e.m_cp[0].assign(this.m_cp[0]),e.m_cp[1].assign(this.m_cp[1]),Gg(e,hu(this))}reverseImpl(){this.m_cp[1]=O(this.m_cp[0],this.m_cp[0]=this.m_cp[1])}equalsImpl(t){const e=t;return!!this.m_cp[0].equals(e.m_cp[0])&&!!this.m_cp[1].equals(e.m_cp[1])}equalsImplTol(t,e){const s=t;return!!this.m_cp[0].isEqualPoint2D(s.m_cp[0],e)&&!!this.m_cp[1].isEqualPoint2D(s.m_cp[1],e)}swapImpl(t){const e=t;e.m_cp[0]=O(this.m_cp[0],this.m_cp[0]=e.m_cp[0]),e.m_cp[1]=O(this.m_cp[1],this.m_cp[1]=e.m_cp[1]),r0(this,e)}afterCompletedModification(){za(this)}isIntersecting(t,e,s){return Gn(!1,this,t,e,s)!==0}intersect(t,e,s,i,n){return en(!1,this,t,e,s,i,n)}intersectPoint(t,e,s){return f0(this,t,e,s)}endPointModified(){za(this)}clearEndPointModified(){}};ws.type=T.enumBezier;let T0=class{constructor(){this.length=Number.NaN,this.area=Number.NaN,this.centroidX=Number.NaN,this.centroidY=0,this.specialPoints=[],this.specialPointsLength=[]}specialPointsCount(){return this.specialPoints.length}};function Lh(r,t,e,s,i,n,o,a){for(;;){const h=y.distance(t[0],t[2]),m=y.distance(t[0],t[1])+y.distance(t[1],t[2]);if(m-h<=i+s*m)return r+Ct(h,m,.5);const l=R(y,4),u=I=>(pn(t,e,1,I,l),l[1].length());if(o===0&&a<8){b(a<8);let I=u(0),w=u(1);n[0]+=2,I>w&&(w=O(I,I=w),t[2]=O(t[0],t[0]=t[2]),e[2]=O(e[0],e[0]=e[2]));let D=I/(I+w),N=1,A=m;for(;D<1/32&&A>=i+s*A;){N/=4;const M=u(N);n[0]++,D=I/(M+I);const G=new y;if(Ut(t,e,.5*N,G),A=y.distance(G,t[0]),A<=i){const q=new y;Ut(t,e,N,q),A+=y.distance(q,G)}}if(N!==1){const M=R(y,3),G=[0,0,0];xu(t,e,N,t,e,M,G),r=Lh(r,M,G,s,i,n,0,a+1),o++,a++;continue}}let c=!1;const g=8;n[0]+=g;const _=zs(g,u,0,1),d=16;n[0]+=d;const p=zs(d,u,0,1);if(c=Math.abs(_-p)>i+s*m,!c)return r+p;if(o<8&&a<9){const I=R(y,3),w=[0,0,0];xu(t,e,.5,t,e,I,w),r=Lh(r,I,w,s,i,n,o+1,a+1),o++,a++;continue}const f=32;n[0]+=f;const x=zs(f,u,0,1);if(c=Math.abs(p-x)>i+s*m,!c)return r+x;const E=64;n[0]+=E;const P=zs(E,u,0,1);if(c=Math.abs(x-P)>i+s*m,!c)return r+P;const C=128;n[0]+=C;const S=zs(C,u,0,1);return c=Math.abs(P-S)>i+s*m,r+S}}function N0(r,t,e,s,i){if(e===t)return 0;const n=R(y,3),o=[0,0,0];r.queryControlPoints(n),r.queryWeights(o);const a=[0,0,0],h=R(y,3);return bi(n,o,t,e,h,a),Lh(0,h,a,s,i,[0],0,0)}let A0=class{constructor(t,e,s){this.controlPoints=No(t,3),this.weights=[0,0,0],ne(this.weights,e,0,0,3),this.point=s.clone()}getMaxDerivative(){return 3}getValue(t,e){if(t===0){const s=new y;Ut(this.controlPoints,this.weights,e,s);const i=R(y,4);return pn(this.controlPoints,this.weights,1,e,i),2*s.sub(this.point).dotProduct(i[1])}if(t===1){const s=new y;Ut(this.controlPoints,this.weights,e,s);const i=R(y,4);return pn(this.controlPoints,this.weights,2,e,i),2*(s.sub(this.point).dotProduct(i[2])+i[1].dotProduct(i[1]))}if(t===2){const s=new y;Ut(this.controlPoints,this.weights,e,s);const i=R(y,4);return pn(this.controlPoints,this.weights,3,e,i),2*(s.sub(this.point).dotProduct(i[3])+3*i[1].dotProduct(i[2]))}return 0}getError(t){return b(0),0}};function q0(r,t,e,s){const i=$0(0,0,0,0,y.getNAN()),n=j(18,Number.NaN),o=R(y,3);r.queryControlPoints(o),o[2].subThis(t),o[1].subThis(t),o[0].subThis(t);const a=[0,0,0];r.queryWeights(a);const h=[1,Ds(a),1],m=Er(a,e),l=Er(a,s),u=Ti(new A0(o,h,new y(0,0)),z.construct(m,l),18,n);Ut(o,h,m,i.pt),i.t=m,i.d=y.distance(i.pt,new y(0,0));const c=new y;Ut(o,h,l,c);const g=y.distance(c,new y(0,0));g<i.d&&(i.d=g,i.t=l,i.pt.assign(c));for(let _=0;_<u;_++){Ut(o,h,n[_],c);const d=y.distance(c,new y(0,0));d<i.d&&(i.d=d,i.t=vn(a,n[_]),i.pt.assign(c))}return i}function F0(r,t,e,s,i){let n=!0;const o=R(y,4),a=Cn(5,t,e,s,i,m=>(Bo(r,1,m,o),(n?r.getCoordX(m)-r.getStartX():r.getCoordY(m)-r.getStartY())*o[1].length()));n=!1;const h=Cn(5,t,e,s,i,m=>(Bo(r,1,m,o),(n?r.getCoordX(m)-r.getStartX():r.getCoordY(m)-r.getStartY())*o[1].length()));return new y(a,h)}function Bn(r){r.m_cachedValues=null}function M0(r,t){t.m_cachedValues=O(r.m_cachedValues,r.m_cachedValues=t.m_cachedValues)}function fr(r){if(r.m_cachedValues)return r.m_cachedValues;const t=new T0,e=R(y,3);r.queryControlPoints(e);const s=[0,0,0];return r.queryWeights(s),Hg(e,s,t.specialPoints),Ug(r,t),t}function Hg(r,t,e){if(t[1]===0)return e.length=0,e.push(0),void e.push(1);const s=R(L,8);s[0].set(0);let i=1;{const n=new L(r[1].x).subThis(r[0].x).mulThis(t[1]).mulThis(t[0]),o=new L(r[2].x).subThis(r[0].x).mulThis(t[2]).mulThis(t[0]),a=n.subE(o).addThisE(new L(r[2].x).subThis(r[1].x).mulThis(t[2]).mulThis(t[1]));o.subThisE(n.mul(2));const h=R(L,2);let m=$e(a,o,n,new z(0,1),!1,h);m<0&&(m=0);for(let l=0;l<m;l++)qt(h[l].value(),0,1)||(s[i]=h[l],i++)}{const n=new L(r[1].y).subThis(r[0].y).mulThis(t[1]).mulThis(t[0]),o=new L(r[2].y).subThis(r[0].y).mulThis(t[2]).mulThis(t[0]),a=n.subE(o).addThisE(new L(r[2].y).subThis(r[1].y).mulThis(t[2]).mulThis(t[1]));o.subThisE(n.mul(2));const h=R(L,2);let m=$e(a,o,n,new z(0,1),!1,h);m<0&&(m=0);for(let l=0;l<m;l++)qt(h[l].value(),0,1)||(s[i]=h[l],i++)}if(s[i].set(1),i++,i>2){Vs(s,0,i,(h,m)=>Os(h.value(),m.value()));let n=0,o=s[0].value(),a=1;for(let h=1;h<i;h++)s[h].eq(s[h-1])?(o+=s[h].value(),a++):(a>1&&(o/=a,s[n].set(o)),n++,s[n]=s[h],o=s[h].value(),a=1);n++,i=n}s[0].set(0),s[i-1].set(1),e.length=i;for(let n=0;n<i;n++)e[n]=s[n].value()}function xr(r,t,e){if(e){if(t<0)return t;if(t>1)return t-1+xr(r,1,!1)}if(r.isDegenerate(0))return 0;const s=t===1,i=fr(r);if(s&&!Number.isNaN(i.length))return i.length;const n=zg(r),o=n/r.calculateUpperLength2D();let a=0,h=0;for(let m=1,l=i.specialPointsCount();m<l;m++){const u=i.specialPoints[m];if(a+=N0(r,h,Math.min(t,u),o,n),t<=u)break;h=u}return s&&(i.length=a),a}function Bo(r,t,e,s){const i=R(y,3);r.queryControlPoints(i);const n=[0,0,0];r.queryWeights(n),pn(i,n,t,e,s)}function pn(r,t,e,s,i){const n=[r[0],r[1],r[2]],o=[t[0],t[1],t[2]],a=R(y,4);G0(n,o,e,s,a);for(let h=0;h<=e;h++)i[h].setCoords(a[h].x,a[h].y)}function G0(r,t,e,s,i){b(e>0);const n=[r[0].clone(),r[1].clone(),r[2].clone()];if(!n[0].isZero()){for(let E=1;E<3;++E)n[E].subThis(n[0]);n[0].setCoords(0,0)}const o=eo(n,t,0,s),a=Oa(t,0,s),h=o.divide(a);if(i[0].assign(h),e===0)return;const m=[t[1]*t[0],t[2]*t[0]*.5,t[1]*t[2]],l=[r[1].sub(r[0]),r[2].sub(r[0]),r[2].sub(r[1])],u=a*a,c=eo(l,m,0,s).mul(2).divide(u);if(i[1].assign(c),e===1)return;const g=Oa(t,1,s),_=2*a*g,d=eo(l,m,1,s).mul(2).sub(c.mul(_)).divide(u);if(i[2].assign(d),e===2)return;const p=eo(l,m,2,s).mul(2),f=2*(g*g+a*Oa(t,2,s)),x=p.sub(d.mul(_).mul(2)).sub(c.mul(f)).divide(u);i[3].assign(x),e!==3&&$("")}function eo(r,t,e,s){if(e===0){if(s<=.5){const i=new y;ee(2,r[0].mul(t[0]),r[1].mul(t[1]),s,i);const n=new y;ee(2,r[1].mul(t[1]),r[2].mul(t[2]),s,n);const o=new y;return ee(2,i,n,s,o),o}{const i=new y;se(2,r[0].mul(t[0]),r[1].mul(t[1]),s,i);const n=new y;se(2,r[1].mul(t[1]),r[2].mul(t[2]),s,n);const o=new y;return se(2,i,n,s,o),o}}if(e===1){const i=r[1].mul(t[1]),n=i.sub(r[0].mul(t[0])).mul(1-s).add(r[2].mul(t[2]).sub(i).mul(s));return n.mulThis(2),n}if(e===2){const i=r[1].mul(t[1]),n=r[2].mul(t[2]).sub(i).sub(i.sub(r[0].mul(t[0])));return n.mulThis(2),n}$("")}function du(r,t,e,s){if(s.toDouble()<=.5){const i=new K;us(2,r[0].mulE(t[0]),r[1].mulE(t[1]),s,i);const n=new K;us(2,r[1].mulE(t[1]),r[2].mulE(t[2]),s,n);const o=new K;return us(2,i,n,s,o),o}{const i=new K;cs(2,r[0].mulE(t[0]),r[1].mulE(t[1]),s,i);const n=new K;cs(2,r[1].mulE(t[1]),r[2].mulE(t[2]),s,n);const o=new K;return cs(2,i,n,s,o),o}}function Oa(r,t,e){if(t===0){const s=Ct(r[0],r[1],e),i=Ct(r[1],r[2],e);return Ct(s,i,e)}if(t===1)return 2*((1-e)*(r[1]-r[0])+(r[2]-r[1])*e);if(t===2)return 2*(r[2]-r[1]-(r[1]-r[0]));$("")}function V0(r,t,e){if(e.toDouble()<=.5){const s=Cs(r[0],r[1],e),i=Cs(r[1],r[2],e);return Cs(s,i,e)}{const s=Es(r[0],r[1],e),i=Es(r[1],r[2],e);return Es(s,i,e)}}function Y0(r,t,e,s,i){const n=[K.constructPoint2D(r[0]),K.constructPoint2D(r[1]),K.constructPoint2D(r[2])];n[2].subThisE(n[0]),n[1].subThisE(n[0]),n[0].setCoords(0,0),X0(n,[new L(t[0]),new L(t[1]),new L(t[2])],e,s,i)}function X0(r,t,e,s,i){b(e>0);const n=[r[0].clone(),r[1].clone(),r[2].clone()];if(!n[0].isZero()){for(let g=1;g<3;++g)n[g].subThisE(n[0]);n[0]=K.constructCoords(0,0)}const o=du(n,t,0,s),a=V0(t,0,s),h=o.divE(a);i[0].setE(h);const m=[t[1].mulE(t[0]),t[2].mulE(t[0]).mul(.5),t[1].mulE(t[2])],l=du([r[1].subE(r[0]),r[2].subE(r[0]),r[2].subE(r[1])],m,0,s).mul(2),u=a.sqr(),c=l.divE(u);i[1].setE(c)}function R0(r,t,e){const s=R(y,3);r.queryControlPoints(s);const i=j(3,Number.NaN);r.queryWeights(i),k0(s,i,t,e)}function k0(r,t,e,s){e.value()<0&&e.set(0,e.eps()),e.value()>1&&e.set(1,e.eps());const i=R(K,4);Y0(r,t,1,e,i),s.setE(i[1])}function Bh(r,t,e){const s=Nt(e,0,1),i=R(y,4);if(pn(r,t,3,s,i),i[1].isZero()){if(i[2].isZero())return i[3];{const n=i[2].clone();return s===1&&n.negateThis(),n}}return i[1]}let L0=class{constructor(t,e){this.len=0,this.b=t,this.len=e}getMaxDerivative(){return 1}getValue(t,e){return t===0?this.len-xr(this.b,e,!1):0}getError(t){return b(0),0}};function B0(r,t,e){const s=xr(r,1,!1);if(t<=0)return t;if(t>=s)return t-s+1;const i=[0];return Ti(new L0(r,t),z.unit(),1,i)!==1&&$(""),i[0]}function pu(r){const t=R(y,3),e=[0,0,0];return r.queryControlPoints(t),r.queryWeights(e),H0(t,e)}function H0(r,t){const e=Ds(t);if(e===1)return Ig(r);if(e===0)return 0;const s=[new y(0,0),r[1].sub(r[0]),r[2].sub(r[0])],i=s[1].crossProduct(s[2]);if(e<1){b(e>0);const n=1-e;let o;if(n<.01)o=-1/3+n*(2/15+n*(3/35+n*(16/315+n*(20/693+n*(16/1001+n*(56/6435))))));else{const a=n*(1+e),h=Math.atan2(Math.sqrt(n),Math.sqrt(1+e));o=e*(.5*e-Kd(a)*h)/a}return i*o}{const n=(e-1)*(e+1);return .25*e/Math.pow(n,1.5)*(-2*e*Math.sqrt(n)*i-4*s[1].y*s[2].x*Math.atanh(Math.sqrt((e-1)/(e+1)))-s[1].x*s[2].y*Math.log(2*e*(e-Math.sqrt(n))-1))}}function z0(r,t){const e=Ds(t);if(e===1){const n=R(y,3);qm(r,n);const o=n[2].clone(),a=n[1].clone(),h=new y,m=o.y*a.x-o.x*a.y;return h.x=-(4*o.x+5*a.x)*m/60,h.y=-(4*o.y+5*a.y)*m/60,h}if(e===0)return new y(0,0);b(e>0);const s=r[1].sub(r[0]),i=r[2].sub(r[0]);if(e<1){const n=Math.sqrt(1-e),o=Math.sqrt(1+e),a=(s.y*i.x-s.x*i.y)*e/Math.pow(n*o,5)/12,h=Math.atan2(n,o),m=e*n*o,l=e*e,u=s.mul(2*(2+l)),c=i.mul(2*l-5),g=u.add(c).mul(m),_=i.sub(s.mul(2*l)).mul(6*h);return g.add(_).mul(a)}{const n=Math.sqrt(e-1),o=Math.sqrt(e+1),a=(s.y*i.x-s.x*i.y)*e/Math.pow(n*o,5)/12,h=Math.atanh(n/o),m=e*n*o,l=e*e,u=s.mul(4).sub(i.mul(5)),c=s.add(i).mul(2*l),g=u.add(c).mul(m),_=i.sub(s.mul(2*l)).mul(6*h);return g.add(_).mul(a)}}function U0(r){const t=R(y,3),e=[0,0,0];return r.queryControlPoints(t),r.queryWeights(e),z0(t,e)}function zg(r){return O0(r.calculateUpperLength2D())}function O0(r){return 256*jt()*r}function W0(r){if(r.m_weights[1]===0)return!0;const t=y.distance(r.getStartXY(),r.getEndXY()),e=r.calculateUpperLength2D();return e-t<=8*Number.EPSILON*e}function fu(r){return r.m_cachedValues}function Ug(r,t){r.m_cachedValues=t}function Ho(r,t,e,s,i){const n=R(y,3);r.queryControlPoints(n);const o=[0,0,0];r.queryWeights(o);const a=[0];return Ym(n,o,t,z.unit(),s,i,1,a)===1?a[0]:Number.NaN}function Ym(r,t,e,s,i,n,o,a){tr(z.unit().contains(s)&&o>0,""),(n<0||Number.isNaN(n))&&(n=Number.MAX_VALUE);const h=new Array(3);for(let X=0;X<3;++X)h[X]=r[X].sub(e);const m=Ds(t),l=Et.constructPoint2D(h[0]),u=Et.constructPoint2D(h[1]),c=Et.constructPoint2D(h[2]),g=J.constructDouble(m),_=g.clone();_.ldexpThis(1);const d=l.dotProduct(u.sub(l)).mul(g),p=g.mul(g.addDouble(2)),f=c.sub(u.mul(p.ldexp(1))),x=u.sqrLength().mul(g.mul(g).ldexp(1)).add(l.sqrLength().mul(g.ldexp(2).subDouble(1))).add(l.dotProduct(f)),E=c.sub(u.mul(_)).add(l.mul(_.subDouble(1))),P=u.mul(g).sub(l).dotProduct(E).mulDouble(3),C=u.dotProduct(c).mul(g.subDouble(3).mul(g)).ldexp(1),S=u.sqrLength().mul(g.mul(g).ldexp(2)),I=l.sqrLength().mul(g.ldexp(2).subDouble(3)),w=l.dotProduct(c.sub(u.mul(g.mulDouble(3).subDouble(1)).mul(g))).ldexp(1),D=c.sqrLength().addThis(C).addThis(S).addThis(I).addThis(w),N=l.add(c).sub(u.mul(_)),A=g.subDouble(1),M=c.sub(l).dotProduct(N).mul(A),G=new y(0,0),q=[];let V=new y;Ut(h,t,s.vmin,V);let k=y.distance(V,G);if(k<=n&&q.push(new y(s.vmin,k)),s.vmin!==s.vmax&&(Ut(h,t,s.vmax,V),k=y.distance(V,G),k<=n&&q.push(new y(s.vmax,k))),s.width()>0){const X=h[2].isZero(),B=R(J,4),W=Pg(M,D,P,x,d,58,s,X,B);for(let Z=0;Z<W;Z++){if(!s.containsExclusiveCoordinate(B[Z].toDouble()))continue;let gt=B[Z].toDouble();gt=vn(t,gt);const at=new y;Ut(h,t,gt,at),k=y.distance(at,G),k<=n&&q.push(new y(gt,k))}}if(i){b(s.equals(z.unit()));{Ut(h,t,-1,V,!0);const X=new y;Ut(h,t,0,X);const B=new ht({start:V,end:X}),W=B.getClosestCoordinate(G,!0);W<1&&(V=B.getCoord2D(W),k=y.distance(V,G),k<=n&&q.push(new y(W-1,k)))}{Ut(h,t,2,V,!0);const X=new y;Ut(h,t,s.vmax,X);const B=new ht({start:X,end:V}),W=B.getClosestCoordinate(G,!0);W>0&&(V=B.getCoord2D(W),k=y.distance(V,G),k<=n&&q.push(new y(1+W,k)))}}if(!q.length)return 0;q.sort((X,B)=>X.compare(B));let Y=0;const U=q[0].x;if(a[Y++]=U,Y<o){const X=Jc(h,4,!1).total(),B=q[0].y;for(let W=1,Z=q.length;W<Z;W++)if(q[W].y>B+X){q.length=W;break}q.sort((W,Z)=>Os(W.x,Z.x)),Y=0,a[Y++]=q[0].x;for(let W=1,Z=q.length;W<Z;W++)q[W].x!==a[Y-1]&&Y<o&&(a[Y++]=q[W].x)}return Y}function $0(r,t,e,s,i){return{tmin:r,tmax:t,t:e,d:s,pt:i.clone()}}function j0(r,t,e,s,i){const n=new ce;if(Og(r,z.unit(),n),n.inflate(s),!n.isIntersectingPoint2D(t))return 0;const o=fr(r);let a=0;const h=[];let m=o.specialPoints[0];for(let l=1,u=o.specialPoints.length;l<u;++l){const c=o.specialPoints[l],g=q0(r,t,m,c);if(h.length===0)h.push(g);else if(g.t===g.tmin)b(h.at(-1).d<=g.d),h.at(-1).tmax=g.tmax;else if(h.at(-1).t===h.at(-1).tmax){b(h.at(-1).d>=g.d);const _=h.at(-1).tmin;h[h.length-1]=g,h.at(-1).tmin=_}else h.push(g);m=c}for(const l of h)if(l.d<=s){const u=l.t;e&&(e[a]=u),a++}return a}function Og(r,t,e){const s=R(y,3);r.queryControlPoints(s);const i=[0,0,0];r.queryWeights(i),yr(s,i,t,e)}function yr(r,t,e,s){if(e.equalsRange(0,1))return void s.setFromPoints(r,3);const i=R(y,3),n=[0,0,0];bi(r,t,e.vmin,e.vmax,i,n),s.setFromPoints(i,3)}function fa(r){const t=Vt(r[0].y,r[1].y),e=Vt(r[1].y,r[2].y);if(t>=0&&e>=0||t<=0&&e<=0){const s=Vt(r[0].x,r[1].x),i=Vt(r[1].x,r[2].x);if(s>=0&&i>=0||s<=0&&i<=0)return!0}return!1}function Hh(r){const t=R(y,3);r.queryControlPoints(t);const e=$i(t);return e&&(r.m_cp.setCoordsPoint2D(t[1]),r.afterCompletedModification()),e}function $i(r){let t=!1;for(let e=0;e<2;e++){const s=Vt(r[0][e],r[2][e]);s>0?(Vt(r[0][e],r[1][e])<0&&(r[1][e]=r[0][e],t=!0),Vt(r[1][e],r[2][e])<0&&(r[1][e]=r[2][e],t=!0)):s<0?(Vt(r[0][e],r[1][e])>0&&(r[1][e]=r[0][e],t=!0),Vt(r[1][e],r[2][e])>0&&(r[1][e]=r[2][e],t=!0)):r[1][e]!==r[0][e]&&(r[1][e]=r[0][e],t=!0)}return t}function Z0(r,t,e){e===void 0&&(e=t,t=0);const s=new y;if(t<0||e>1)return s.setNAN(),s;if(t>e&&H("calculate_sub_weighted_centroid"),t===e||r.isDegenerate(0))return s.setCoords(0,0),s;const i=fr(r),n=zg(r),o=n/r.calculateUpperLength2D();let a=t,h=0;for(let m=1,l=i.specialPointsCount();m<l;m++)if(t<i.specialPoints[m]){h=m-1;break}s.setCoords(0,0);for(let m=h+1,l=i.specialPointsCount();m<l;m++){const u=Math.min(i.specialPoints[m],e),c=F0(r,a,u,o,n);if(s.addThis(c),a=u,e<=i.specialPoints[m])break}return s.add(r.getStartXY().mul(r.calculateLength2D()))}function xu(r,t,e,s,i,n,o){b(e>=0&&e<=1&&s!==n&&i!==o),b(t[0]>0&&t[2]>0&&t[1]>=0);const a=[1,Ds(t),1],h=Er(t,e),m=No(r,3),l=R(mt,3);Wg(m,a,l);const u=R(mt,3),c=R(mt,3);$h(l,h,s?u:null,n?c:null),jh(t,e,i,o);const g=fa(m);if(s){for(let _=0;_<3;++_)Oh(u[_],s[_]);Zh(m,s),g&&$i(s)}if(n){for(let _=0;_<3;++_)Oh(c[_],n[_]);Zh(m,n),g&&$i(n)}}function bi(r,t,e,s,i,n){if(b(e>=0&&s<=1&&e<=s),e===s){const l=new y,u=$g(r,t,e,l);return xa(r,l),i[0].assign(l),i[1].assign(l),i[2].assign(l),n[0]=u,n[1]=u,void(n[2]=u)}if(e===0&&s===1)return i[0].assign(r[0]),i[1].assign(r[1]),i[2].assign(r[2]),n[0]=t[0],n[1]=t[1],void(n[2]=t[2]);const o=R(mt,3);{const l=[1,Ds(t),1],u=Er(t,e),c=Er(t,s);Wg(r,l,o),$h(o,c,o,null),$h(o,u>=c?1:u/c,null,o)}const a=[0,0,0];jh(t,s,a,null),jh(a,e/s,null,a);const h=fa(r),m=R(y,3);Oh(o[1],m[1]),Ut(r,t,e,m[0]),Ut(r,t,s,m[2]),Zh(r,m);for(let l=0;l<3;++l)i[l].assign(m[l]),n[l]=a[l];h&&$i(i)}function Q0(r,t,e){const s=Ds(t),i=[1,s,1],n=4*s/(3*(1+s));e[0].assign(r[0]),e[3].assign(r[2]),Qt(r[0],r[1],n,e[1]),Qt(r[2],r[1],n,e[2]),new ws({cp:e}),new Ge({points:r,weight:s});let o=0,a=.1,h=0;for(let m=0;m<9;m++,a+=.1){const l=new y;Ut(r,i,a,l);const u=new y;Rt(e,a,u);const c=y.sqrDistance(l,u);c>o&&(o=c,h=a)}{const m=new y;Ut(r,i,h,m);const l=[0];Wi(e,m,z.unit(),!1,-1,1,l);const u=new y;return Rt(e,l[0],u),o=y.sqrDistance(m,u),Math.sqrt(o)}}function K0(r,t,e,s){if(t.isEqual(r.m_XStart,r.m_YStart)&&e.isEqual(r.m_XEnd,r.m_YEnd))return;const i=!!s&&r.isMonotoneQuickAndDirty(),n=new pt,o=R(y,3);o[0].setCoords(r.m_XStart,r.m_YStart),o[2].setCoords(r.m_XEnd,r.m_YEnd);const a=new y;a.setSub(o[2],o[0]),a.leftPerpendicularThis(),o[1].setAdd(o[0],a);const h=R(y,3);h[0].setCoordsPoint2D(t),h[2].setCoordsPoint2D(e),a.setSub(h[2],h[0]),a.leftPerpendicularThis(),h[1].setAdd(h[0],a),n.setFromTwoTriangles(o,h)?n.transformInPlace(r.m_cp):Qt(t,e,.5,r.m_cp),r.changeEndPoints2D(t,e),i&&Hh(r)}function yu(r,t,e,s,i){if(i){if(Qe(t,e)!==0)return r?4:2}else if(is(t,e))return 1;return ji(r,t,e,null,null,null,s,i!==void 0&&i,!0,!1)!==0?4:0}function Pu(r,t,e,s,i){if(i){if(Qe(t,e)!==0)return r?4:2}else if(is(t,e))return 1;return zh(r,t,e,null,null,null,s,i??!1,!0,!1)!==0?4:0}function J0(r,t,e,s,i){if(i){const n=Qe(t,e);if(n!==0){if(r){if(n===1){if(t.m_weights[0]===e.m_weights[0]&&t.m_weights[1]===e.m_weights[1]&&t.m_weights[2]===e.m_weights[2])return 2}else if(t.m_weights[0]===e.m_weights[2]&&t.m_weights[1]===e.m_weights[1]&&t.m_weights[2]===e.m_weights[0])return 2;return 4}return 2}}else if(is(t,e))return 1;return Pr(r,t,e,null,null,null,s,i!==void 0&&i,!0,!1)!==0?4:0}function Cu(r,t,e,s,i){if(i){if(Qe(t,e)!==0)return r?4:2}else if(is(t,e))return 1;return Uh(r,t,e,null,null,null,s,i??!1,!0,!1)!==0?4:0}function ji(r,t,e,s,i,n,o,a,h,m){if(i!==null&&(i.length=0),n!==null&&(n.length=0),s!==null&&(s.length=0),e.isDegenerate(0)){const Q=[0,0],rt=t.intersectPoint(e.getStartXY(),Q,o);if(rt>0){if(i!==null)for(let nt=0;nt<rt;nt++)i.push(Q[nt]);if(n!=null)for(let nt=0;nt<rt;nt++)n.push(0);if(s!=null)for(let nt=0;nt<rt;nt++){const ot=new y;t.queryCoord2D(Q[nt],ot),s.push(ot)}}return rt}const l=Xe(t,e);if(o=Math.max(o,l),t.isDegenerateToLineHelper(l)){const Q=new ht({start:t.getStartXY(),end:t.getEndXY()}),rt=da(Q,e,s,i,n,o,a,m);if(i)for(let nt=0;nt<rt;++nt){const ot=Q.getCoord2D(i[nt]);i[nt]=t.getClosestCoordinate(ot,!1)}return rt}if(ns(t,e,o))return 0;const u=R(y,3);t.queryControlPoints(u);const c=[0,0,0];t.queryWeights(c);const g=[1,Ds(c),1],_=e.getEndXY().sub(e.getStartXY()),d=_.clone();d.leftPerpendicularThis();const p=u[0].clone(),f=u[1].clone(),x=u[2].clone(),E=f.sub(p),P=x.sub(p),C=x.sub(f),S=g[0],I=g[1],w=g[2],D=S*I,N=S*w,A=I*w,M=E.dotProduct(d)*D,G=P.dotProduct(d)*N;let q=M,V=G-2*M,k=C.dotProduct(d)*A+G-G;const Y=j(13,Number.NaN),U=j(13,Number.NaN);let X=Ui(k,V,q,z.unit(),!1,Y);X<0&&(Y[0]=0,Y[1]=1,X=2);let B=0;for(let Q=0,rt=B;Q<X;++Q){const nt=new y;Ut(u,g,Y[Q+rt],nt),U[B]=e.getClosestCoordinate(nt,!1),y.distance(nt,e.getCoord2D(U[B]))<=o&&(Y[B]=Y[Q+rt],B++)}const W=R(y,3),Z=R(y,3);if(t.queryControlPoints(Z),Z[0].subThis(e.getStartXY()),Z[1].subThis(e.getStartXY()),Z[2].subThis(e.getStartXY()),t1(Z,g,W,!1),Math.abs(_.x)>=Math.abs(_.y)){const Q=_.y/_.x;k=W[2].y-W[2].x*Q,V=W[1].y-W[1].x*Q,q=W[0].y-W[0].x*Q}else{const Q=_.x/_.y;k=W[2].x-W[2].y*Q,V=W[1].x-W[1].y*Q,q=W[0].x-W[0].y*Q}const gt=t.getEndXY().equals(e.getStartXY())||t.getEndXY().equals(e.getEndXY()),at=[0,0];X=Ui(k,V,q,z.unit(),gt,at);for(let Q=0,rt=B;Q<X;++Q){Y[Q+rt]=at[Q];const nt=new y;Ut(u,g,Y[Q+rt],nt),U[B]=e.getClosestCoordinate(nt,!1),y.distance(nt,e.getCoord2D(U[B]))<=o&&(Y[B]=Y[Q+rt],B++)}b(B<Y.length+4);for(let Q=0;Q<B;Q++)Y[Q]=vn(c,Y[Q]);X=t.intersectPoint(e.getStartXY(),at,o);for(let Q=0;Q<X;Q++)Y[B]=at[Q],U[B++]=0;X=t.intersectPoint(e.getEndXY(),at,o);for(let Q=0;Q<X;Q++)Y[B]=at[Q],U[B++]=1;X=e.intersectPoint(t.getStartXY(),at,o);for(let Q=0;Q<X;Q++)U[B]=at[Q],Y[B++]=0;X=e.intersectPoint(t.getEndXY(),at,o);for(let Q=0;Q<X;Q++)U[B]=at[Q],Y[B++]=1;return B===0?0:rs(r,t,e,Y,U,B,s,i,n,o,a,h,m)}function zh(r,t,e,s,i,n,o,a,h,m){if(Ft(e))return ji(r,t,new ht({start:e.getStartXY(),end:e.getEndXY()}),s,i,n,o,a,h,m);const l=Xe(t,e);if(ns(t,e,o=Math.max(o,l)))return 0;const u=[],c=[],g=R(y,4);{t.queryControlPoints(g);const d=R(y,4),p=new pt;e.canonicToWorldTransformation(p);const f=new pt;f.setInvert(p),f.transformPoints2D(g,4,d);const x=R(J,3),E=R(J,3),P=R(J,3),C=[0,0,0];t.queryWeights(C),Cr(d,C,x,E,P);const S=R(J,3);S[0].setDouble(e.getSemiMinorAxis()),S[0].sqrThis(),S[1].setDouble(e.getSemiMajorAxis()),S[1].sqrThis(),S[2].setThis(S[0]),S[2].mulThis(S[1]),S[2].negateThis();const I=Nm(x,2,E,2,P,2,S,!0,z.unit(),z.unit(),u,a);if(I>0){let w=0;for(let D=0;D<I;D++){const N=new y;t.queryCoord2D(u[D],N);const A=e.getClosestCoordinate(N,!1),M=new y;e.queryCoord2D(A,M),y.distance(N,M)<=o&&(u[w]=u[D],c.push(A),w++)}u.length=w}}const _=[0,1];for(let d=0;d<2;d++){const p=d===0?e.getStartXY():e.getEndXY(),f=Ho(t,p,z.unit(),!1,-1),x=new y;t.queryCoord2D(f,x),y.distance(p,x)<=o&&(u.push(f),c.push(_[d]))}for(let d=0;d<2;d++){const p=[0,3];{const f=e.getClosestCoordinate(g[p[d]],!1),x=new y;e.queryCoord2D(f,x),y.distance(g[p[d]],x)<=o&&(u.push(_[d]),c.push(f))}}return rs(r,t,e,u,c,u.length,s,i,n,o,a,h,m)}function Pr(r,t,e,s,i,n,o,a,h,m){const l=R(y,3);t.queryControlPoints(l);const u=R(y,3);if(e.queryControlPoints(u),wm(l,u,3)<0)return Pr(r,e,t,s,n,i,o,a,h,!m);const c=Xe(t,e);if(t.isDegenerateToLineHelper(c)){const S=new ht({start:t.getStartXY(),end:t.getEndXY()}),I=ji(r,e,S,s,n,i,o,a,h,!m);if(i)for(let w=0;w<I;++w){const D=S.getCoord2D(i[w]);i[w]=t.getClosestCoordinate(D,!1)}return I}if(e.isDegenerateToLineHelper(c)){const S=new ht({start:e.getStartXY(),end:e.getEndXY()}),I=ji(r,t,S,s,i,n,o,a,h,m);if(n)for(let w=0;w<I;++w){const D=S.getCoord2D(n[w]);n[w]=e.getClosestCoordinate(D,!1)}return I}if(ns(t,e,o=Math.max(o,c)))return 0;const g=j(3,Number.NaN);t.queryWeights(g);const _=j(3,Number.NaN);e.queryWeights(_);const d=[1,Ds(g),1],p=[1,Ds(_),1],f=new z(0,1),x=new z(0,1);{const S=ce.constructEmpty();yr(l,d,new z(0,1),S);const I=ce.constructEmpty();yr(u,p,new z(0,1),I);const w=Math.max(S.maxDim(),I.maxDim());if(S.inflate(3*o),I.inflate(3*o),!S.intersectW(I))return 0;if(S.maxDim()<.1*w){if(Wh(l,d,S,f),Wh(u,p,S,x),f.isEmpty()||x.isEmpty())return 0;bi(l,d,f.vmin,f.vmax,l,d),bi(u,p,x.vmin,x.vmax,u,p)}}const E=Vn(l,2,u,2,o);if(E===0)return 0;const P=[],C=[];if(E===-1){const S=R(J,3),I=R(J,3),w=R(J,3);Cr(l,d,S,I,w);const D=R(J,3),N=R(J,3),A=R(J,3);Cr(u,p,D,N,A);const M=[],G=[],q=Mn(S,2,I,2,w,2,D,2,N,2,A,2,!0,z.unit(),z.unit(),M,G,a,h,m);if(q>0)for(let V=0;V<q;V++){const k=new y;Ut(u,p,G[V],k);const Y=new y;Ut(l,d,M[V],Y),y.distance(Y,k)<=o&&(P.push(M[V]),C.push(G[V]))}}for(let S=0;S<2;S++){let I,w,D;S===0?(I=l,w=u,D=p):(I=u,w=l,D=d);for(let N=0;N<2;N++){const A=N===0?0:I.length-1,M=new y,G=[0],q=Ym(w,D,I[A],z.unit(),!1,-1,1,G);b(q===1),Ut(w,D,G[0],M),y.distance(I[A],M)<=o&&(S===0?(P.push(A===0?0:1),C.push(G[0])):(C.push(A===0?0:1),P.push(G[0])))}}if(P.length===0)return 0;if(!f.equalsRange(0,1))for(let S=0;S<P.length;++S)P[S]=Ge.recalculateParentT(f.vmin,f.vmax,P[S]);if(!x.equalsRange(0,1))for(let S=0;S<C.length;++S)C[S]=Ge.recalculateParentT(x.vmin,x.vmax,C[S]);for(let S=0;S<P.length;++S)P[S]=vn(g,P[S]);for(let S=0;S<C.length;++S)C[S]=vn(_,C[S]);return rs(r,t,e,P,C,P.length,s,i,n,o,a,h,m)}function Uh(r,t,e,s,i,n,o,a,h,m){if(t.isLine())return cr(r,e,new ht({start:t.getStartXY(),end:t.getEndXY()}),s,n,i,o,a,h,!m);if(e.isLine())return ji(r,t,new ht({start:e.getStartXY(),end:e.getEndXY()}),s,i,n,o,a,h,m);const l=Xe(t,e);if(ns(t,e,o=Math.max(o,l)))return 0;const u=R(y,3);t.queryControlPoints(u);const c=R(y,3);e.queryControlPoints(c);const g=Vn(u,2,c,2,o);if(g===0)return 0;const _=[],d=[];if(g===-1){const p=R(J,3),f=R(J,3),x=R(J,3),E=[0,0,0];t.queryWeights(E),Cr(u,E,p,f,x);const P=R(Et,3);En(c,P);const C=Mn(p,2,f,2,x,2,[P[0].x,P[1].x,P[2].x],2,[P[0].y,P[1].y,P[2].y],2,null,0,!0,z.unit(),z.unit(),_,d,a,h,m);if(C>0){let S=0;for(let I=0;I<C;I++){const w=new y;e.queryCoord2D(d[I],w);const D=new y;t.queryCoord2D(_[I],D),y.distance(D,w)<=o&&(_[S]=_[I],d[S]=d[I],S++)}_.length=S,d.length=S}}for(let p=0;p<2;p++){let f;f=p===0?u:c;for(let x=0;x<2;x++){const E=x===0?0:f.length-1;let P;const C=new y;p===0?(P=Yo(e,f[E],z.unit(),!1),e.queryCoord2D(P,C)):(P=Ho(t,f[E],z.unit(),!1,-1),t.queryCoord2D(P,C)),y.distance(f[E],C)<=o&&(p===0?(_.push(E===0?0:1),d.push(P)):(d.push(E===0?0:1),_.push(P)))}}return rs(r,t,e,_,d,_.length,s,i,n,o,a,h,m)}function t1(r,t,e,s=!1){const i=R(y,3);s?(i[0].setCoordsPoint2D(r[0]),i[1].setCoordsPoint2D(r[1]),i[1].subThis(i[0]),i[2].setCoordsPoint2D(r[2]),i[2].subThis(i[0]),i[0].setCoords(0,0)):(i[0].setCoordsPoint2D(r[0]),i[1].setCoordsPoint2D(r[1]),i[2].setCoordsPoint2D(r[2])),i[0].mulThis(t[0]),i[1].mulThis(t[1]),i[2].mulThis(t[2]),e[1].setCoords(i[1].x-i[0].x,i[1].y-i[0].y),e[2].setCoordsPoint2D(i[2].sub(i[1])),e[2].subThis(e[1]),e[1].x*=2,e[1].y*=2,e[0].setCoordsPoint2D(i[0])}function Cr(r,t,e,s,i){const n=J.constructDouble(t[0]),o=J.constructDouble(t[1]),a=J.constructDouble(t[2]);e[0].setDouble(r[0].x),e[0].mulThis(n),e[1].setDouble(r[1].x),e[1].mulThis(o),e[2].setDouble(r[2].x),e[2].mulThis(a),e[2].subThis(e[1]),e[1].subThis(e[0]),e[2].subThis(e[1]),e[1].ldexpThis(1),s[0].setDouble(r[0].y),s[0].mulThis(n),s[1].setDouble(r[1].y),s[1].mulThis(o),s[2].setDouble(r[2].y),s[2].mulThis(a),s[2].subThis(s[1]),s[1].subThis(s[0]),s[2].subThis(s[1]),s[1].ldexpThis(1),i[0].setDouble(t[0]),i[1].setDouble(t[1]),i[2].setThis(i[1]),i[2].ldexpThis(1),i[2].negateThis(),i[2].addThis(i[0]),i[2].addDoubleThis(t[2]),i[1].subThis(i[0]),i[1].ldexpThis(1)}function Wg(r,t,e){for(let s=0;s<3;++s)e[s].setCoordsPoint2DZ(r[s].mul(t[s]),t[s])}function $g(r,t,e,s){if(e===0)return s.assign(r[0]),t[0];if(e===1)return s.assign(r[2]),t[2];const i=[r[0].x*t[0],r[1].x*t[1],r[2].x*t[2]],n=[r[0].y*t[0],r[1].y*t[1],r[2].y*t[2]],o=[t[0],t[1],t[2]],a=e;let h,m,l;if(e<=.5){const u=fe(i[0],i[1],a),c=fe(i[1],i[2],a);h=Ct(u,c,a);const g=fe(n[0],n[1],a),_=fe(n[1],n[2],a);m=Ct(g,_,a);const d=fe(o[0],o[1],a),p=fe(o[1],o[2],a);l=fe(d,p,a)}else{const u=ue(i[0],i[1],a),c=ue(i[1],i[2],a);h=ue(u,c,a);const g=ue(n[0],n[1],a),_=ue(n[1],n[2],a);m=ue(g,_,a);const d=ue(o[0],o[1],a),p=ue(o[1],o[2],a);l=ue(d,p,a)}return h/=l,m/=l,s.setCoords(h,m),xa(r,s),l}function e1(r,t,e){const s=R(y,3);r.queryControlPoints(s);const i=[0,0,0];r.queryWeights(i),s1([K.constructPoint2D(s[0]),K.constructPoint2D(s[1]),K.constructPoint2D(s[2])],[new L(i[0]),new L(i[1]),new L(i[2])],t,e)}function s1(r,t,e,s){if(e.value()===0)return void s.setE(r[0]);if(e.value()===1)return void s.setE(r[2]);const i=[r[0].x.mulE(t[0]),r[1].x.mulE(t[1]),r[2].x.mulE(t[2])],n=[r[0].y.mulE(t[0]),r[1].y.mulE(t[1]),r[2].y.mulE(t[2])],o=[t[0].clone(),t[1].clone(),t[2].clone()],a=new L,h=new L,m=new L;if(e.value()<=.5){const u=Cs(i[0],i[1],e),c=Cs(i[1],i[2],e);a.setE(Cs(u,c,e));const g=Cs(n[0],n[1],e),_=Cs(n[1],n[2],e);h.setE(Cs(g,_,e));const d=Cs(o[0],o[1],e),p=Cs(o[1],o[2],e);m.setE(Cs(d,p,e))}else{const u=Es(i[0],i[1],e),c=Es(i[1],i[2],e);a.setE(Es(u,c,e));const g=Es(n[0],n[1],e),_=Es(n[1],n[2],e);h.setE(Es(g,_,e));const d=Es(o[0],o[1],e),p=Es(o[1],o[2],e);m.setE(Es(d,p,e))}a.divThisE(m),h.divThisE(m);const l=new y(a.value(),h.value());xa([r[0].value(),r[1].value(),r[2].value()],l),s.x.set(l.x,a.eps()),s.y.set(l.y,h.eps())}function i1(r,t,e,s){const i=e.lte(Ud)?J.lerpLo:J.lerpHi,[n,o,a]=[t.map((m,l)=>r[l].x.mul(m)),t.map((m,l)=>r[l].y.mul(m)),t].map(([m,l,u])=>i(i(m,l,e),i(l,u,e),e)),h=new y(n.divThis(a).value(),o.divThis(a).value());xa(r.map(m=>m.asPoint2D()),h),s.x=J.constructDouble(h.x),s.y=J.constructDouble(h.y)}function Oh(r,t){return t.setCoords(r.x/r.z,r.y/r.z),r.z}function Ut(r,t,e,s,i){if(i){if(e<0)return void Ue(new ht({start:r[0],end:r[0].add(Bh(r,t,0).getUnitVector())}),e,s);if(e>1)return void Ue(new ht({start:r[2],end:r[2].add(Bh(r,t,1).getUnitVector())}),e-1,s)}$g(r,t,e,s)}function Wh(r,t,e,s){s.setEmpty();const i=[];i.push(new z(0,1));const n=.5*Math.max(e.width(),e.height());for(;i.length;){const o=i.at(-1);i.pop();const a=new ce;if(yr(r,t,o,a),a.isIntersectingW(e)){const h=Math.max(a.width(),a.height());if(e.containsW(a)||h<=n||o.width()<1e-12)s.merge(o);else{const m=o.getCenter();i.push(z.construct(o.vmin,m)),i.push(z.construct(m,o.vmax))}}}}function Ds(r){return r[1]/Math.sqrt(r[0]*r[2])}function vn(r,t){const e=Math.sqrt(r[2]/r[0]);return t/Ct(e,1,t)}function Er(r,t){const e=Math.sqrt(r[0]/r[2]);return t/Ct(e,1,t)}function $h(r,t,e,s){b(t>=0&&t<=1),new mt().setCoordsPoint3D(r[0]),new mt().setCoordsPoint3D(r[1]),new mt().setCoordsPoint3D(r[2]);const i=new mt,n=new mt,o=new mt;Qn(3,r[0],r[1],t,i),Qn(3,r[1],r[2],t,n),Qn(3,i,n,t,o);const a=r[2].clone();e&&(e[0].assign(r[0]),e[1].assign(i),e[2].assign(o)),s&&(s[0].assign(o),s[1].assign(n),s[2].assign(a))}function jh(r,t,e,s){const i=[r[0],r[1],r[2]];b(t>=0&&t<=1&&e!==s);const n=Ct(i[0],i[1],t),o=Ct(i[1],i[2],t),a=Ct(n,o,t);e&&(e[0]=i[0],e[1]=n,e[2]=a),s&&(s[0]=a,s[1]=o,s[2]=i[2])}function xa(r,t){const e=z.constructEmpty();e.vmin=e.vmax=r[0].x,e.mergeNeCoordinate(r[1].x),e.mergeNeCoordinate(r[2].x),t.x=Nt(t.x,e.vmin,e.vmax),e.vmin=e.vmax=r[0].y,e.mergeNeCoordinate(r[1].y),e.mergeNeCoordinate(r[2].y),t.y=Nt(t.y,e.vmin,e.vmax)}function Zh(r,t){const e=new z;e.vmin=e.vmax=r[0].x,e.mergeNeCoordinate(r[1].x),e.mergeNeCoordinate(r[2].x),t[0].x=Nt(t[0].x,e.vmin,e.vmax),t[1].x=Nt(t[1].x,e.vmin,e.vmax),t[2].x=Nt(t[2].x,e.vmin,e.vmax),e.vmin=e.vmax=r[0].y,e.mergeNeCoordinate(r[1].y),e.mergeNeCoordinate(r[2].y),t[0].y=Nt(t[0].y,e.vmin,e.vmax),t[1].y=Nt(t[1].y,e.vmin,e.vmax),t[2].y=Nt(t[2].y,e.vmin,e.vmax)}const n1=Uc/180,r1=180/Uc;function o1(r){let t=r;return t>=-360&&t<720?(t<0?t+=360:t>=360&&(t-=360),t):(t=Ci(t,360),t<0&&(t+=360),t)}function jg(r){let t=r;return t=o1(t),t>180&&(t-=360),t}function Zg(r){return r*n1}function fo(r){return r*r1}function Qg(r){const t=Ee();let e=r;return e>=-t&&e<2*t?(e<0&&(e+=t),e>=t&&(e-=t),e):(e=Ci(e,t),e<0&&(e+=t),e)}function Eu(r){const t=xt();let e=r;return e>-t&&e<=t||(e=Qg(e),e>t&&(e-=Ee())),e}function Su(r,t){return jg(t-r)}var Hn=Mt;let Xs=class Qh extends Rr{constructor(t){if(t===void 0||ha(t,"vd"))return super({vd:t?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_semiMajorAxis=0,this.m_minorMajorRatio=1,this.m_rotation=0,this.m_cosr=1,this.m_sinr=0,this.m_center=new y(0,0),this.m_sweepAngle=0,this.m_startAngle=0,this.m_interior=new y(0,0),void(this.m_bits=0);if(t.copy)return super(t),void(this!==t.copy&&(this.m_center=new y(0,0),this.m_interior=new y(0,0),t.copy.copyToImpl(this)));if(t.move)super(t),this.m_semiMajorAxis=t.move.m_semiMajorAxis,this.m_minorMajorRatio=t.move.m_minorMajorRatio,this.m_rotation=t.move.m_rotation,this.m_cosr=t.move.m_cosr,this.m_sinr=t.move.m_sinr,this.m_center=t.move.m_center.clone(),this.m_sweepAngle=t.move.m_sweepAngle,this.m_startAngle=t.move.m_startAngle,this.m_interior=t.move.m_interior.clone(),this.m_bits=t.move.m_bits,this.m_cachedValues=t.move.m_cachedValues,t.move.m_cachedValues=null;else{if(t.fromPoint)return super({XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_center=new y(0,0),this.m_interior=new y(0,0),void this.constructCircularArcThreePoint(t.fromPoint,t.toPoint,t.interiorPoint);if(t.center)return super({XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_center=new y(0,0),this.m_interior=new y(0,0),void this.constructCircleRadius(t.radius,t.center,t.bIsCounterClockwise);if(t.semiMajorAxis)return super({XStart:0,YStart:0,XEnd:0,YEnd:0}),void this.constructEllipticArcEndPoints(t.fromPoint,t.toPoint,t.semiMajorAxis,t.minorMajorRatio,t.axisXRotationRad,t.bBigArc,t.bIsCounterClockwise)}}getBoundary(){return Gs(this)}assignCopy(t){return this!==t&&t.copyTo(this),this}constructCircleRadius(t,e,s=!1){return this.constructEllipse(t,1,e,0,s),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructCircleCenterAndPoint(t,e,s=!1){const i=y.distance(t,e);return this.constructEllipticArcEndPointsCenter(e,e,i,1,0,!0,s,t),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructTwoPointCircle(t,e,s=!1){const i=y.lerp(t,e,.5);return this.constructCircleCenterAndPoint(i,t,s),this}constructLineEllipticArc(t,e){return ds(this,t,e,1),this}constructLineCircularArc(t,e){return ds(this,t,e,0),this}constructEllipse(t,e,s,i,n=!1){this.m_semiMajorAxis=Math.abs(t),this.m_minorMajorRatio=Math.abs(e),this.m_minorMajorRatio>1&&(this.m_semiMajorAxis*=this.m_minorMajorRatio,this.m_minorMajorRatio=1/this.m_minorMajorRatio);const o=new y(0,this.m_minorMajorRatio*this.m_semiMajorAxis),a=Math.cos(i),h=Math.sin(i);return o.rotateDirect(a,h),o.addThis(s),this.constructEllipticArcEndPointsCenter(o,o,this.m_semiMajorAxis,this.m_minorMajorRatio,i,!0,n,s),this}inflate(t){if(this.isDegenerateToLine())return;let e=this.getSemiMinorAxis()+t;if(e=e<=0?0:(this.getSemiMajorAxis()+t)/this.getSemiMajorAxis(),this.isCircular()){const s=new pt;s.setShiftCoords(-this.m_center.x,-this.m_center.y),s.scale(e,e),s.shiftCoords(this.m_center.x,this.m_center.y),this.applyTransformation(s)}else{const s=new pt;this.canonicToWorldTransformation(s);const i=s.clone();i.invertPreciseThis(),i.scale(e,e),i.multiply(s),this.applyTransformation(i)}}constructEnclosingCircle(t,e,s=!1){return I1(this,t,e,s),this}constructThreePointCircle(t,e,s,i=!1){if(t.equals(e)||e.equals(s)||t.equals(s)){const n=t.clone(),o=e.clone(),a=s.clone();return n.equals(o)&&o.assign(a),this.constructTwoPointCircle(n,o,i)}{const n=y.calculateCircleCenterFromThreePoints(t,e,s);if(!n.isFinite()||!Number.isFinite(y.distance(t,n))){const o=y.distance(t,e),a=y.distance(t,s);this.constructLineCircularArc(t,o>=a?e:s)}return this.constructCircleCenterAndPoint(n,t,i)}}constructCircularArcThreePoint(t,e,s){const i=new L(t.x),n=new L(e.x),o=new L(s.x),a=new L(t.y),h=new L(e.y),m=new L(s.y),l=new L(.5),u=n.subE(i),c=h.subE(a),g=o.subE(i),_=m.subE(a),d=u.mulE(_).subThisE(c.mulE(g));if(d.scaleError(10),d.isZero()){if(!u.isZero()||!c.isZero())return ds(this,t,e,0),this;{const U=t.clone().addThis(e).mulThis(.5).addThis(s).mulThis(.5),X=s.sub(U).length();this.constructEllipticArcEndPointsCenter(t,e,X,1,0,!0,!1,U),this.m_interior.assign(s)}return this.setProjectionBehavior(0),this}const p=u.sqr().addThisE(c.sqr()).mulThisE(l),f=g.sqr().addThisE(_.sqr()).mulThisE(l),x=p.mulE(_).subThisE(f.mulE(c)),E=u.mulE(f).subThisE(g.mulE(p));x.divThisE(d),E.divThisE(d);const P=x.sqr().addThisE(E.sqr());P.sqrtThis();const C=x.addE(i),S=E.addE(a);let I=t.x-C.value(),w=t.y-S.value();const D=Math.atan2(w,I);I=e.x-C.value(),w=e.y-S.value();const N=Math.atan2(w,I);I=s.x-C.value(),w=s.y-S.value();const A=Math.atan2(w,I);let M=A-2*xt();for(;M<D;)M+=2*xt();let G=N-2*xt();for(;G<M;)G+=2*xt();let q=A+2*xt();for(;q>D;)q-=2*xt();let V,k=N+2*xt();for(;k>q;)k-=2*xt();V=G-D<D-k?G-D:k-D;const Y=new y(C.value(),S.value());return this.constructEllipticArcEndPointsCenter(t,e,P.value(),1,0,Math.abs(V)>xt(),V>0,Y),this.m_interior.assign(s),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructCircularArc(t,e,s,i){return this.constructEllipticArcGeneral(t,1,e,s,i,0),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructEllipticArcEndPoints(t,e,s,i,n,o,a){return Tu(this,t,e,s,i,n,o,a)}constructEllipticArcEndPointsCenter(t,e,s,i,n,o,a,h){return Tu(this,t,e,s,i,n,o,a,h)}constructEllipticArcGeneral(t,e,s,i,n,o){this.m_semiMajorAxis=Math.abs(t),this.m_minorMajorRatio=Math.abs(e),this.m_minorMajorRatio>1&&(this.m_semiMajorAxis*=this.m_minorMajorRatio,this.m_minorMajorRatio=1/this.m_minorMajorRatio);const a=Eu(o),h=Math.cos(a),m=Math.sin(a),l=new y(this.m_semiMajorAxis,this.m_minorMajorRatio*this.m_semiMajorAxis),u=y.getNAN(),c=Eu(i);u.x=l.x*Math.cos(c),u.y=l.y*Math.sin(c),u.rotateDirect(h,m),u.addThis(s);const g=Bd(n,Ee());let _=g;Math.abs(_)===Ee()&&(_=0);const d=y.getNAN();return d.x=l.x*Math.cos(c+_),d.y=l.y*Math.sin(c+_),d.rotateDirect(h,m),d.addThis(s),this.constructEllipticArcEndPointsCenter(u,d,this.m_semiMajorAxis,this.m_minorMajorRatio,a,Math.abs(g)>xt(),g>0,s)}constructEllipticArcAsNURB(t,e,s,i){return(i>=1||i<0)&&H("construct_elliptic_arc_as_NURB: weight"),e.isFinite()||H("construct_elliptic_arc_as_NURB: control_point"),vr([t,e,s],i*i,null,!1,this),this}constructCanonic(t){return this.assignCopy(t),t.isDegenerateToLine()||t.m_center.isEqual(0,0)&&this.m_rotation===0||(this.m_XStart=t.getSemiMajorAxis()*Math.cos(t.m_startAngle),this.m_YStart=t.getSemiMinorAxis()*Math.sin(t.m_startAngle),this.m_XEnd=t.getSemiMajorAxis()*Math.cos(t.getEndAngle()),this.m_YEnd=t.getSemiMinorAxis()*Math.sin(t.getEndAngle()),this.m_center.setCoords(0,0),this.m_rotation=0,this.m_cosr=1,this.m_sinr=0,gn(this),this.afterCompletedModification(),t!==this&&ng(this,t)),this}isCircular(){return this.m_minorMajorRatio===1&&this.m_rotation===0&&!this.isDegenerateToLine()}isDegenerateToLineHelper(t){if(this.isLine())return!0;if(this.isMajor())return!1;const e=this.getEndXY().sub(this.getStartXY()).length();return!(this.calculateLength2D()-e>t)}isDegenerateToLine(){return Ft(this)}getCenter(){return this.m_center.clone()}setCenter(t){if(!this.m_center.isNAN()){const e=t.sub(this.m_center);this.m_XStart+=e.x,this.m_YStart+=e.y,this.m_XEnd+=e.x,this.m_YEnd+=e.y,this.m_interior.addThis(e),this.m_center.assign(t),this.endPointModified(),this.normalizeAfterEndpointChange()}}getAxisXRotation(){return this.m_rotation}getSemiAxes(){return y.construct(this.m_semiMajorAxis,this.m_semiMajorAxis*this.m_minorMajorRatio)}getSemiMajorAxis(){return this.m_semiMajorAxis}getSemiMinorAxis(){return this.m_semiMajorAxis*this.m_minorMajorRatio}getMinorMajorRatio(){return this.m_minorMajorRatio}isClockwise(){return!bn(this)}isMajor(){return Bm(this)}getSweepAngle(){return this.m_sweepAngle}getStartAngle(){return this.m_startAngle}getEndAngle(){return this.m_startAngle+this.m_sweepAngle}getGeometryType(){return T.enumEllipticArc}queryEnvelope(t){if(t.m_EnvelopeType===4){t.setEmpty(),t.assignVertexDescription(this.m_description);const e=F.constructEmpty();this.queryEnvelope(e),t.setEnvelope(e);for(let s=1,i=this.m_description.getAttributeCount();s<i;s++){const n=this.m_description.getSemantics(s);for(let o=0,a=Hn.getComponentCount(n);s<a;s++){const h=this.queryInterval(n,o);t.setIntervalEnvelope(n,o,h)}}}else t.m_EnvelopeType===2?Fu(this,z.unit(),t):ft("3d not impl")}applyTransformation(t){Lm(this,t,!1,null,null)}createInstance(){return new Qh}calculateLength2D(){return x1(this,0,1)}queryControlPointsHelper(t){$("")}queryCoord2D(t,e){if(Ft(this))Dm(t,this.getStartXY(),this.getEndXY(),e);else if(t===0)e.assign(y.construct(this.m_XStart,this.m_YStart));else if(t===1)e.assign(y.construct(this.m_XEnd,this.m_YEnd));else{const s=Ss(this,t),i=new y(this.m_semiMajorAxis*Math.cos(s),this.getSemiMinorAxis()*Math.sin(s));i.rotateDirect(this.m_cosr,this.m_sinr),i.addThis(this.m_center),e.assign(i)}}queryCoord2DE(t,e){g1(this,t,e)}queryCoord2DMP(t,e){ft("")}getCoordX(t){const e=new y;return this.queryCoord2D(t,e),e.x}getCoordY(t){const e=new y;return this.queryCoord2D(t,e),e.y}cut(t,e,s){const i=new it;return this.queryCut(t,e,i,s),i.releaseSegment()}queryCut(t,e,s,i){const n=s.createEllipticArc();i&&n.dropAllAttributes();let o=t===0&&e===1;if(o&&!i)return void this.copyTo(n);const a=y.getNAN();this.queryCoord2D(t,a);const h=y.getNAN();if(this.queryCoord2D(e,h),!o){if(a.equals(h))e-t>.5&&this.isMajor()&&this.isClosed()?(o=!0,t=0,e=1):e===1?t=e:e=t;else if(t>0&&a.isEqual(this.m_XStart,this.m_YStart)&&(t=0),e<1&&h.isEqual(this.m_XEnd,this.m_YEnd)&&(e=1),o=t===0&&e===1,o&&!i)return void this.copyTo(n)}if(n.m_center.assign(this.m_center),n.m_semiMajorAxis=this.m_semiMajorAxis,n.m_minorMajorRatio=this.m_minorMajorRatio,n.m_interior.assign(this.m_interior),n.m_rotation=this.m_rotation,n.m_cosr=this.m_cosr,n.m_sinr=this.m_sinr,n.m_sweepAngle=this.m_sweepAngle,n.m_startAngle=this.m_startAngle,n.m_bits=this.m_bits,ql(n,a.x,a.y),Fl(n,h.x,h.y),o)return void ja(n,$a(this));n.m_startAngle=Ss(this,t),n.m_sweepAngle=Ss(this,e)-n.m_startAngle,n.m_startAngle=ki(n.m_startAngle),In(n,Math.abs(n.m_sweepAngle)>xt()),i&&n.assignVertexDescription(this.m_description),gn(n),Kh(n);const m=this.m_description.getAttributeCount();if(m>1&&!i){for(let l=1;l<m;l++){const u=this.m_description.getSemantics(l),c=Hn.getComponentCount(u);for(let g=0;g<c;g++){const _=this.getAttributeAsDbl(t,u,g);n.setStartAttribute(u,g,_)}}for(let l=1;l<m;l++){const u=this.m_description.getSemantics(l),c=Hn.getComponentCount(u);for(let g=0;g<c;g++){const _=this.getAttributeAsDbl(e,u,g);n.setEndAttribute(u,g,_)}}}n.afterCompletedModification()}queryDerivative(t,e){T1(this,t,e)}cutArcIgnoreAttributes(t,e,s){let i=t===0&&e===1;const n=new y;this.queryCoord2D(t,n);const o=new y;this.queryCoord2D(e,o),i||(n.equals(o)?e-t>.5&&this.isMajor()&&this.isClosed()?(i=!0,t=0,e=1):e===1?t=e:e=t:(t>0&&n.isEqual(this.m_XStart,this.m_YStart)&&(t=0),e<1&&o.isEqual(this.m_XEnd,this.m_YEnd)&&(e=1),i=t===0&&e===1)),s.m_center.assign(this.m_center),s.m_semiMajorAxis=this.m_semiMajorAxis,s.m_minorMajorRatio=this.m_minorMajorRatio,s.m_interior.assign(this.m_interior),s.m_rotation=this.m_rotation,s.m_cosr=this.m_cosr,s.m_sinr=this.m_sinr,s.m_sweepAngle=this.m_sweepAngle,s.m_startAngle=this.m_startAngle,s.m_bits=this.m_bits,ql(s,n.x,n.y),Fl(s,o.x,o.y),i?ja(s,$a(this)):(s.m_startAngle=Ss(this,t),s.m_sweepAngle=Ss(this,e)-s.m_startAngle,s.m_startAngle=ki(s.m_startAngle),In(s,Math.abs(s.m_sweepAngle)>Math.PI),gn(s),s.afterCompletedModification())}changeEndPoints2D(t,e){Du(this,t,e,!1)}getAttributeAsDbl(t,e,s){if(e===0)return s===0?this.getCoordX(t):this.getCoordY(t);if(t===0)return this.getStartAttributeAsDbl(e,s);if(t===1)return this.getEndAttributeAsDbl(e,s);const i=this.calculateLength2D(),n=i>0?this.tToLength(t)/i:0,o=Hn.getInterpolation(e),a=this.getStartAttributeAsDbl(e,s),h=this.getEndAttributeAsDbl(e,s);return Fr(o,a,h,n,Hn.getDefaultValue(e))}getClosestCoordinate(t,e){return Mu(this,t,z.unit(),e)}getClosestCoordinateOnInterval(t,e,s=-1){return Mu(this,t,e,!1)}getYMonotonicParts(t,e=!1){t.length<2&&H("");const s=this.getSemiAxes(),i=Math.atan2(s.y*this.m_cosr,s.x*this.m_sinr),n=i+xt(),o=j(3,Number.NaN);let a=0;if(o[0]=zt(this,i),o[0]>0&&o[0]<1&&a++,o[1]=zt(this,n),o[1]>0&&o[1]<1&&(o[a]=o[1],a++),a===0)return 0;o[a]=1,a++,b(t.length>=a);let h=0;for(let m=0;m<a;m++){const l=o[m];this.queryCut(h,l,t[m],e),h=l}return a}getMonotonicParts(t,e){if(t.length<4&&H(""),this.isDegenerateToLine())return t[0].createEllipticArc().assignCopy(this),e&&t[0].get().dropAllAttributes(),1;const s=this.getSemiAxes(),i=j(4,Number.NaN);i[0]=Math.atan2(s.y*this.m_cosr,s.x*this.m_sinr),i[1]=i[0]+xt(),i[2]=Math.atan2(-s.y*this.m_sinr,s.x*this.m_cosr),i[3]=i[2]+xt();const n=j(5,Number.NaN);let o=0;for(let h=0;h<4;h++)n[o]=zt(this,i[h]),n[o]>0&&n[o]<1&&o++;if(o===0)return 0;ch(n,o),n[o-1]<1&&(n[o]=1,o++),b(t.length>=o);let a=0;for(let h=0;h<o;h++){const m=n[h];this.queryCut(a,m,t[h],e),a=m}return o}intersectionWithAxis2D(t,e,s,i){if(Ft(this))return new ht({start:this.getStartXY(),end:this.getEndXY()}).intersectionWithAxis2D(t,e,s,i);let n,o;const a=new L(e),h=this.getSemiAxes();if(t){if(e>this.m_center.y+h.x||e<this.m_center.y-h.x)return 0;n=new L(h.x).mulThis(this.m_sinr),o=new L(h.y).mulThis(this.m_cosr),a.subThis(this.m_center.y)}else{if(e>this.m_center.x+h.x||e<this.m_center.x-h.x)return 0;n=new L(h.x).mulThis(this.m_cosr),o=new L(h.y).mulThis(-this.m_sinr),a.subThis(this.m_center.x)}const m=n.sqr(),l=o.sqr(),u=m.addE(l),c=o.mulE(a).mulThis(-2),g=a.sqr().subThisE(m),_=c.sqr().subThisE(u.mulE(g).mulThis(4)),d=n.mulE(a).mulThis(-2),p=a.sqr().subThisE(l),f=d.sqr().subThisE(u.mulE(p).mulThis(4));let x=_.eps()*Math.abs(f.value())<=f.eps()*Math.abs(_.value());x?n.isZero()&&(x=!1):o.isZero()&&(x=!0),x||(c.setE(d),g.setE(p));const E=R(L,2);let P=$e(u,c,g,z.construct(-1,1),!1,E);if(P===0)return 0;const C=[0,0];let S=0;for(let I=0;I<P;I++){const w=new L,D=new L;x?(w.setE(E[I]),D.setE(a.subE(o.mulE(E[I])).divThisE(n))):(D.setE(E[I]),w.setE(a.subE(n.mulE(E[I])).divThisE(o)));const N=zt(this,Math.atan2(w.value(),D.value()));N>=0&&N<=1&&(C[S]=N,S++)}return P=S,P===0?0:(P===2&&C[0]>C[1]&&(C[1]=O(C[0],C[0]=C[1])),i&&ne(i,C,0,0,P),s&&(s[0]=t?this.getCoordX(C[0]):this.getCoordY(C[0]),P>1&&(s[1]=t?this.getCoordX(C[1]):this.getCoordY(C[1]),!i&&s[0]>s[1]&&(s[1]=O(s[0],s[0]=s[1])))),P)}intersectionOfYMonotonicWithAxisX(t,e){if(this.m_YStart===this.m_YEnd)return t===this.m_YStart?e:Number.NaN;if(t===this.m_YStart)return this.m_XStart;if(t===this.m_YEnd)return this.m_XEnd;const s=[0,0];return this.intersectionWithAxis2D(!0,t,s,null)===-1?e:s[0]}isCurve(){return!0}isDegenerate(t){return _a(this,t)}isDegenerate3D(t,e){return b(0),!1}queryLooseEnvelope(t){t.m_EnvelopeType!==3?this.queryLooseEnvelopeOnInterval(new z(0,1),t):ft("3d not impl")}clone(t){const e=new Qh;return this.copyTo(e),e}queryInterval(t,e){if(t===0){if(Ft(this))return e===0?z.construct(this.getStartX(),this.getEndX()):z.construct(this.getStartY(),this.getEndY());let s;const i=this.getSemiAxes();s=e===0?Math.atan2(-i.y*this.m_sinr,i.x*this.m_cosr):Math.atan2(i.y*this.m_cosr,i.x*this.m_sinr);const n=s+Math.PI,o=[0,0];o[0]=zt(this,s),o[1]=zt(this,n);const a=e===0?z.construct(this.getStartX(),this.getEndX()):z.construct(this.getStartY(),this.getEndY()),h=new y;for(let m=0;m<2;m++){const l=o[m];l>0&&l<1&&(this.queryCoord2D(l,h),a.mergeNeCoordinate(e===0?h.x:h.y))}return a}return super.queryInterval(t,e)}queryLooseEnvelopeOnInterval(t,e){const s=new z(0,1);if(s.intersect(t),s.isEmpty())return void e.setEmpty();if(Ft(this))return e.setCoords(this.getCoord2D(s.vmin)),void e.mergeNe(this.getCoord2D(s.vmax));const i=this.getCoord2D(s.vmin),n=this.getCoord2D(s.vmax);if(this.m_minorMajorRatio===1&&Math.abs(this.m_sweepAngle)*s.width()<=dt){let o=y.lerp(i,n,.5);const a=o.sub(this.m_center);return a.normalize(),o=o.add(a.mul(.5*y.distance(i,n))),e.setCoords(i),e.mergeNe(n),void e.mergeNe(o)}Fu(this,s,e)}tToLength(t){return Ft(this)?t*y.distance(this.getStartXY(),this.getEndXY()):this.m_minorMajorRatio===1?Math.abs(this.getSweepAngle()*t)*this.m_semiMajorAxis:Jh(this,t)}parametricAngleToT(t){return zt(this,t)}tToParametricAngle(t){return Ss(this,t)}lengthToT(t){if(Ft(this)){const e=y.distance(this.getStartXY(),this.getEndXY());return e===0?0:t/e}if(this.m_minorMajorRatio===1){const e=Math.abs(this.getSweepAngle())*this.m_semiMajorAxis;return e===0?0:t/e}return C1(this,t)}calculateWeightedAreaCentroid2D(t){if(Ft(this)){const l=new y;return l.setCoords(0,0),l}const e=Au(this),s=this.getStartXY().sub(this.m_center),i=this.getEndXY().sub(this.m_center),n=this.m_semiMajorAxis,o=this.getSemiMinorAxis(),a=this.m_startAngle+this.m_sweepAngle,h=new y;h.x=n*o*(n*this.m_cosr*(-Math.sin(a)+Math.sin(this.m_startAngle))+o*(-Math.cos(a)+Math.cos(this.m_startAngle))*this.m_sinr)/3,h.y=n*o*(o*(Math.cos(a)-Math.cos(this.m_startAngle))*this.m_cosr+n*(-Math.sin(a)+Math.sin(this.m_startAngle))*this.m_sinr)/3;const m=i.add(s).mul(i.crossProduct(s)/6);return h.x-=m.x,h.y-=m.y,h.add(this.m_center.sub(t).mul(e))}calculateWeightedCentroid2D(){const t=new y;if(this.isDegenerate(0))return t.setCoords(0,0),t;if(Ft(this))return t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t;let e=this.m_startAngle,s=this.m_startAngle+this.m_sweepAngle;if(s<e){const h=e;e=s,s=h}const i=Math.sin(e),n=Math.sin(s),o=Math.cos(e),a=Math.cos(s);if(this.m_minorMajorRatio===1){const h=this.getSemiMajorAxis(),m=h*h,l=m*(n-i),u=m*(o-a);t.setCoords(l,u)}else{const h=this.getSemiMajorAxis(),m=this.getSemiMinorAxis(),l=h*h,u=m*m,c=h*m,g=l-u,_=g/u,d=g/l,p=Math.sqrt(_),f=Math.sqrt(d),x=.5*c*(Math.asinh(p*n)/p+n*Math.sqrt(1+_*n*n))-.5*c*(Math.asinh(p*i)/p+i*Math.sqrt(1+_*i*i)),E=-.5*c*(Math.asin(f*a)/f+a*Math.sqrt(1-d*a*a))- -.5*c*(Math.asin(f*o)/f+o*Math.sqrt(1-d*o*o));t.setCoords(x,E)}return t.rotateDirect(this.m_cosr,this.m_sinr),t.assign(t.add(this.m_center.mul(this.calculateLength2D()))),t}isIntersectingPoint(t,e,s){if(s&&(t.isEqualPoint2D(this.getStartXY())||t.isEqualPoint2D(this.getEndXY())))return!1;if(!Ft(this)){const o=y.distance(t,this.m_center),a=this.getSemiAxes();if(o<a.x-e||o>a.y+e)return!1}const i=this.getClosestCoordinate(t,!1),n=new y;return this.queryCoord2D(i,n),y.distance(n,t)<=e}isIntersectingPoint3D(t,e,s,i,n=1){return b(0),!1}getTangent(t){if(Ft(this))return this.getEndXY().sub(this.getStartXY());{const e=Ss(this,t),s=new y;return s.setCoords(-this.m_semiMajorAxis*Math.sin(e),this.getSemiMinorAxis()*Math.cos(e)),this.m_rotation&&s.rotateDirect(this.m_cosr,this.m_sinr),s.scale(this.getSweepAngle()),s}}getDerivative(t){if(Ft(this))return this.getEndXY().sub(this.getStartXY());{const e=Ss(this,t),s=new y;return s.setCoords(-this.m_semiMajorAxis*Math.sin(e),this.getSemiMinorAxis()*Math.cos(e)),this.m_rotation&&s.rotateDirect(this.m_cosr,this.m_sinr),s.scale(this.getSweepAngle()),s}}normalizeAfterEndpointChange(){return!!t_(this)&&(Ft(this)?(yo(this),!1):e_(this,!1))}projectionBehavior(){return(4&this.m_bits)>>2}setProjectionBehavior(t){this.m_bits=-5&this.m_bits|t<<2}convertToCanonic(t){const e=new y(t.x,t.y);return e.subThis(this.m_center),e.rotateReverse(this.m_cosr,this.m_sinr),e}convertFromCanonic(t){const e=new y(t.x,t.y);return e.rotateDirect(this.m_cosr,this.m_sinr),e.addThis(this.m_center),e}canonicToWorldTransformation(t){t.setRotate(this.m_cosr,this.m_sinr),t.shiftCoords(this.m_center.x,this.m_center.y)}getCurvature(t){const e=Ss(this,t),s=new y,i=this.getSemiMinorAxis();s.setCoords(-this.m_semiMajorAxis*Math.sin(e),i*Math.cos(e));const n=new y;n.setCoords(-this.m_semiMajorAxis*Math.cos(e),-i*Math.sin(e)),this.m_rotation&&(s.rotateDirect(this.m_cosr,this.m_sinr),n.rotateDirect(this.m_cosr,this.m_sinr));const o=s.sqrLength();if(o===0)return Number.NaN;const a=Math.sqrt(o);return s.divThis(a),s.crossProduct(n)/o}getMonotonicPartParams(t,e){const s=j(6,Number.NaN);s[0]=0;let i=1;if(this.isDegenerateToLine())s[1]=1,i=2;else{const n=this.getSemiAxes(),o=j(4,Number.NaN);this.m_rotation?(o[0]=Math.atan2(n.y*this.m_cosr,n.x*this.m_sinr),o[1]=o[0]+Math.PI,o[2]=Math.atan2(-n.y*this.m_sinr,n.x*this.m_cosr),o[3]=o[2]+Math.PI):(o[0]=0,o[1]=Math.PI,o[2]=.5*Math.PI,o[3]=Hd());for(let a=0;a<4;a++){const h=zt(this,o[a]);h>0&&h<1&&(s[i]=h,i++)}i>2&&ch(s,i),s[i]=1,i++}if(e){t<i&&H("");for(let n=0;n<i;n++)e[n]=s[n]}return i}calculateLowerLength2D(){const t=y.distance(this.getStartXY(),this.getEndXY());if(this.isDegenerateToLine())return t;const e=Math.abs(this.m_sweepAngle)*this.getSemiMinorAxis();return Math.max(e,t)}calculateUpperLength2D(){const t=y.distance(this.getStartXY(),this.getEndXY());if(this.isDegenerateToLine())return t;const e=Math.abs(this.m_sweepAngle)*this.getSemiMajorAxis();return Math.max(e,t)}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){this.m_XEnd=O(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=O(this.m_YStart,this.m_YStart=this.m_YEnd);for(let t=0,e=this.m_description.getTotalComponentCount()-2;t<e;t++)this.m_attributes[t+e]=O(this.m_attributes[t],this.m_attributes[t]=this.m_attributes[t+e]);this.m_startAngle=this.m_startAngle+this.m_sweepAngle,this.m_sweepAngle=-this.m_sweepAngle}}isLine(){return Ft(this)}copyIgnoreAttributes(t){t.m_XStart=this.m_XStart,t.m_YStart=this.m_YStart,t.m_XEnd=this.m_XEnd,t.m_YEnd=this.m_YEnd,t.m_center.assign(this.m_center),t.m_semiMajorAxis=this.m_semiMajorAxis,t.m_minorMajorRatio=this.m_minorMajorRatio,t.m_interior.assign(this.m_interior),t.m_rotation=this.m_rotation,t.m_cosr=this.m_cosr,t.m_sinr=this.m_sinr,t.m_sweepAngle=this.m_sweepAngle,t.m_startAngle=this.m_startAngle,t.m_bits=this.m_bits,xo(t)}calculateArea2DHelper(){return Au(this)}absNorm(){let t=this.getStartXY().norm(1)+this.getEndXY().norm(1);return this.isDegenerateToLine()||(t+=this.m_center.norm(1),t+=this.m_semiMajorAxis),t}queryEnvelopeW(t,e){if(e.setCoords(this.getCoord2D(t.vmin)),e.mergeNe(this.getCoord2D(t.vmax)),Ft(this))return;const s=this.getSemiAxes(),i=j(8,Number.NaN);{const o=Math.atan2(-s.y*this.m_sinr,s.x*this.m_cosr),a=o+Math.PI,h=Math.atan2(s.y*this.m_cosr,s.x*this.m_sinr),m=h+Math.PI;i[0]=zt(this,o),i[1]=zt(this,a),i[2]=zt(this,h),i[3]=zt(this,m)}{const o=this.m_cosr+this.m_sinr,a=this.m_cosr-this.m_sinr,h=Math.atan2(-s.y*o,s.x*a),m=h+Math.PI,l=Math.atan2(s.y*a,s.x*o),u=l+Math.PI;i[4]=zt(this,h),i[5]=zt(this,m),i[6]=zt(this,l),i[7]=zt(this,u)}const n=y.getNAN();for(let o=0;o<8;o++){const a=i[o];t.containsExclusiveCoordinate(a)&&(this.queryCoord2D(a,n),e.mergeNe(n))}}setSegmentFromCoordsForStitcher(t,e){y1(this,t,e)}writeInBufferStream(t,e){const s=new Float64Array(10);return s[0]=this.m_bits,s[1]=this.m_semiMajorAxis,s[2]=this.m_minorMajorRatio,s[3]=this.m_rotation,s[4]=this.m_center.x,s[5]=this.m_center.y,s[6]=this.m_sweepAngle,s[7]=this.m_startAngle,s[8]=this.m_interior.x,s[9]=this.m_interior.y,t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}readFromBufferStream(t,e){const s=new Float64Array(10);t.queryRange(e,s.length,s,!0,1),this.m_bits=s[0],this.m_semiMajorAxis=s[1],this.m_minorMajorRatio=s[2],this.m_rotation=s[3],this.m_center.x=s[4],this.m_center.y=s[5],this.m_sweepAngle=s[6],this.m_startAngle=s[7],this.m_interior.x=s[8],this.m_interior.y=s[9],this.m_cosr=Math.cos(this.m_rotation),this.m_sinr=Math.sin(this.m_rotation),this.m_cachedValues=null}snapControlPoints(t){return!1}needsSnapControlPoints(t){return!1}calculateSpecialPointsForCracking(t,e){return $("should not1; be called"),0}ensureXYMonotone(){if(Ft(this))return!1;if(this.getStartXY().equals(this.getEndXY()))return ds(this,this.getStartXY(),this.getEndXY(),this.projectionBehavior()),!0;const t=R(y,3);let e=Sr(this,t);if($i(t)){let s=!1;if(this.projectionBehavior()===0){const i=new F;i.setCoords({pt:t[0]}),i.mergeNe(t[2]);const n=new y;n.setSub(t[2],t[0]),n.leftPerpendicularThis(),n.normalize(),n.scale(y.distance(t[2],t[0]));const o=y.lerp(t[2],t[0],.5),a=o.sub(n),h=o.add(n);i.clipLine(a,h);const m=y.getClosestCoordinate(a,h,t[1],!1);t[1]=y.lerp(a,h,m);const l=t[2].sub(t[1]),u=t[0].sub(t[1]),c=l.crossProduct(u),g=l.dotProduct(u);e=ei()-Math.abs(.5*Math.atan2(c,g)),s=!0}return vr(t,e*e,null,s,this),!0}return!1}setCoordsForIntersector(t,e,s){Du(this,t,e,s)}getInteriorPoint(){return this.m_interior.clone()}copyToImpl(t){const e=t;e.m_center.assign(this.m_center),e.m_semiMajorAxis=this.m_semiMajorAxis,e.m_minorMajorRatio=this.m_minorMajorRatio,e.m_interior.assign(this.m_interior),e.m_rotation=this.m_rotation,e.m_cosr=this.m_cosr,e.m_sinr=this.m_sinr,e.m_sweepAngle=this.m_sweepAngle,e.m_startAngle=this.m_startAngle,e.m_bits=this.m_bits,ja(e,$a(this))}reverseImpl(){ya(this,!bn(this)),Kh(this),(this.projectionBehavior()!==0||this.getStartXY().equals(this.getEndXY()))&&gn(this)}equalsImpl(t){const e=t;if(this.m_bits!==e.m_bits||this.m_semiMajorAxis!==e.m_semiMajorAxis||this.m_minorMajorRatio!==e.m_minorMajorRatio||!(this.m_center.isEqualPoint2D(e.m_center)||this.m_center.isNAN()&&e.m_center.isNAN())||this.m_rotation!==e.m_rotation||!this.m_interior.equals(e.m_interior))return!1;const s=e.m_sweepAngle;if(this.m_sweepAngle!==s)return!1;const i=e.m_startAngle;return this.m_startAngle===i}equalsImplTol(t,e){const s=t;if(this.m_bits!==s.m_bits)return!1;if(this.m_center.isNAN()&&s.m_center.isNAN())return!0;if(this.m_center.isNAN()!==s.m_center.isNAN()||!this.getSemiAxes().isEqualPoint2D(s.getSemiAxes(),e)||!this.m_center.isEqualPoint2D(s.m_center,e))return!1;const i=Math.abs(Zg(jg(fo(this.m_rotation-s.m_rotation)))),n=Math.abs(xt()-i),o=Math.min(i,n);if(this.m_semiMajorAxis*Math.abs(o)>e)return!1;const a=this.getCoord2D(.5),h=s.getCoord2D(.5);return!!a.isEqualPoint2D(h,e)}swapImpl(t){const e=t;this.m_center=O(e.m_center,e.m_center=this.m_center),this.m_semiMajorAxis=O(e.m_semiMajorAxis,e.m_semiMajorAxis=this.m_semiMajorAxis),this.m_minorMajorRatio=O(e.m_minorMajorRatio,e.m_minorMajorRatio=this.m_minorMajorRatio),this.m_interior=O(e.m_interior,e.m_interior=this.m_interior),this.m_rotation=O(e.m_rotation,e.m_rotation=this.m_rotation),this.m_cosr=O(e.m_cosr,e.m_cosr=this.m_cosr),this.m_sinr=O(e.m_sinr,e.m_sinr=this.m_sinr),this.m_sweepAngle=O(e.m_sweepAngle,e.m_sweepAngle=this.m_sweepAngle),this.m_startAngle=O(e.m_startAngle,e.m_startAngle=this.m_startAngle),this.m_bits=O(e.m_bits,e.m_bits=this.m_bits),S1(this,e)}afterCompletedModification(){yo(this),xo(this)}intersect(t,e,s,i,n){return en(!1,this,t,e,s,i,n)}intersectPoint(t,e,s){if(e.length<2&&ut(""),Ft(this))return new ht({start:this.getStartXY(),end:this.getEndXY()}).intersectPoint(t,e,s);{const o=y.distance(t,this.m_center);if(o>this.m_semiMajorAxis+s||o<this.getSemiMinorAxis()-s)return 0}const i=this.getClosestCoordinate(t,!1),n=y.getNAN();return this.queryCoord2D(i,n),y.distance(n,t)<=s?qt(i,0,1)&&(this.queryCoord2D(i===0?1:0,n),y.distance(n,t)<=s)?(e&&(e[0]=0,e[1]=1),2):(e&&(e[0]=i),1):0}isIntersecting(t,e,s){return Gn(!1,this,t,e,s)!==0}endPointModified(){this.m_bits|=8,xo(this)}clearEndPointModified(){yo(this)}};function a1(r,t,e,s){const i=[];return h1(t,i),m1(r,i,t,e)}function h1(r,t){t.length=r;for(let e=0;e<t.length;++e)t[e]=e;r>3&&Ap(r,t)}function m1(r,t,e,s,i){let n=0;const o=[0,0,0];let a=0;const h=3;let m=0;for(let l=0;l<h;++l){let u=!1;for(;m<e;){const c=r.at(t[m]);let g=1;if(n===3?g=y.inCircleRobust(r.at(s[0]),r.at(s[1]),r.at(s[2]),c):n===2?g=y.inCircleRobust3Point(r.at(s[0]),r.at(s[1]),c):n===1&&c.equals(r.at(s[0]))&&(g=0),g<=0){if(g<0&&l+1<h){t[a]=O(t[m],t[m]=t[a]);for(let d=0;d<n;d++)if(s[d]===t[m]){o[d]=m;break}a++}m++;continue}u=!0;let _=0;for(let d=0;d<n;d++)o[d]>m&&(s[_]=s[d],o[_]=o[d],_++);n=_,s[n]=t[m],o[n]=m,n++,n<3?m=a:(y.orientationRobust(r.at(s[0]),r.at(s[1]),r.at(s[2]))===1&&(s[2]=O(s[0],s[0]=s[2]),o[2]=O(o[0],o[0]=o[2])),m++)}if(!u)break;if(l+1<h){a=0;let c=!1;for(let g=0;g<n;g++)for(let _=g+1;_<n;_++)o[g]>o[_]&&(o[_]=O(o[g],o[g]=o[_]),s[_]=O(s[g],s[g]=s[_]),c=!0);for(let g=0;g<n;g++)t[o[g]]=O(t[g],t[g]=t[o[g]]),o[g]=g;c&&n===3&&y.orientationRobust(r.at(s[0]),r.at(s[1]),r.at(s[2]))===1&&(s[2]=O(s[0],s[0]=s[2]),o[2]=O(o[0],o[0]=o[2]))}m=n}return n}function l1(r,t,e,s,i,n){return new Rm(0,0,0,null,!1,Ie()).densifyEx(r,t,e,s,!1,n)}function Xm(r,t,e,s,i,n,o,a){n&&(n.length=0),o&&(o.length=0);const h=r.getGeometryType();if(h===T.enumLine)return n&&(n.push(r.getStartXY()),n.push(y.getNAN()),n.push(y.getNAN()),n.push(r.getEndXY())),o&&(o.push(0),o.push(1)),1;if(h===T.enumBezier){if(!s)return n&&(n.push(r.getStartXY()),n.push(r.getControlPoint1()),n.push(r.getControlPoint2()),n.push(r.getEndXY())),o&&(o.push(0),o.push(1)),1;const m=j(9,Number.NaN);let l=r.getMonotonicPartParams(m.length,m);if(m.length=l,l=Jn(r,e,m),l===2&&i&&(m[1]=.5,m.push(1),l=3),o&&o.splice(0,0,...m.slice(0,l)),n){const u=new it;for(let c=1;c<l;c++){const g=m[c-1],_=m[c];r.queryCut(g,_,u,!0);const d=u.get();Xo(d),c===1&&n.push(d.getStartXY()),n.push(d.getControlPoint1()),n.push(d.getControlPoint2()),n.push(d.getEndXY())}}return l-1}if(h===T.enumEllipticArc){const m=r;if(m.isDegenerateToLine()||m.isDegenerate(0))return n&&(n.push(r.getStartXY()),n.push(y.getNAN()),n.push(y.getNAN()),n.push(r.getEndXY())),o&&(o.push(0),o.push(1)),1;if(s&&(i||!m.isMonotoneQuickAndDirty())){const l=j(6,Number.NaN);let u=m.getMonotonicPartParams(l.length,l);l.length=u,u=Jn(r,e,l),u===2&&i&&(l[1]=.5,l.push(1),u=3);let c=0;if(u>2){const g=new it,_=o||[];let d=0;for(let p=1;p<u;p++){const f=l[d],x=l[p];if(m.queryCut(f,x,g,!0),g.get().isDegenerate(0))continue;const E=_.length,P=vu(p===1,g.get(),t,e,s,n,o);b(P>0),c+=P;const C=p===u-1,S=l[d],I=g.get().getSweepAngle()/m.getSweepAngle();for(let w=E,D=_.length;w<D;w++)if(_[w]=!C||w+1<D?S+_[w]*I:1,n){const N=3*w,A=m.getCoord2D(_[w]);n[N].setCoordsPoint2D(A),N>0&&Ro(n.slice(N-3))}d=p}return c}}return vu(!0,m,t,e,s,n,o)}if(h===T.enumRationalBezier2){const m=r;if(s&&(i||!m.isMonotoneQuickAndDirty())){const l=j(6,Number.NaN);let u=m.getMonotonicPartParams(l.length,l);l.length=u,u=Jn(r,e,l),u===2&&i&&(l[1]=.5,l.push(1),u=3);let c=0;if(u>2){const g=new it,_=o||[];for(let d=1;d<u;d++){const p=l[d-1],f=l[d];m.queryCut(p,f,g,!0);const x=_.length;c+=bu(d===1,g.get(),t,e,!1,n,o);const E=d===u-1,P=l[d-1];for(let C=x,S=_.length;C<S;C++)if(_[C]=!E||C+1<S?P+_[C]:1,n){const I=3*C,w=m.getCoord2D(_[C]);n[I].setCoordsPoint2D(w),I>0&&Dg(n.slice(I-3))}}return c}}return bu(!0,m,t,e,s,n,o)}if(h===T.enumBezier2){const m=r,l=R(y,3);m.queryControlPoints(l);const u=new ws;u.constructFromQuadratic(l);const c=Xm(u,t,e,s,i,n,o);if(n!=null&&o!=null)for(let _=1,d=0;_<c;++_,d+=3){const p=new y;m.queryCoord2D(o[_],p);const f=n[d+3];!p.equals(f)&&(n[d+3].setCoordsPoint2D(p),s)&&Ro(n.slice(d,d+4))}return c}ft("")}function zo(r,t,e,s,i,n,o,a,h){const m=r.getGeometryType();if(n&&(n.length=0,o.length=0),a&&(a.length=0),m===T.enumEllipticArc){const c=r;if(c.isDegenerateToLine()||c.isDegenerate(0))return n&&(n.push(r.getStartXY()),n.push(y.getNAN()),n.push(r.getEndXY()),o.push(Number.NaN),o.push(Number.NaN),o.push(Number.NaN)),a&&(a.push(0),a.push(1)),1}const l=j(9,Number.NaN);let u;if(i)u=r.getMonotonicPartParams(l.length,l),l.length=u,u=Jn(r,e,l);else{if(u=2,l[0]=0,l[1]=1,m===Xs.type){const c=r.getSweepAngle();if(c>.9*Math.PI){const g=2*Math.PI/3;Math.min(3,Math.trunc(c/g+.5))>2?(l[0]=0,l[1]=1/3,l[2]=2/3,l[3]=1,u=4):(l[0]=0,l[1]=.5,l[2]=1,u=3)}}else b(m===Ge.type);l.length=u}if(u===2&&s&&(l[1]=.5,l.push(1),u=3),n){const c=new it;let g=1;for(;g<u;){const _=l[g-1],d=l[g];r.queryCut(_,d,c,!0);const p=R(y,3),f=[1,1,1];if(m===T.enumEllipticArc){const x=c.get();if(Math.abs(x.getSweepAngle())>.9*Math.PI){const E=(d-_)/3;l.splice(g,0,_+E),l.splice(g+1,0,_+2*E),u+=2;continue}f[1]=Sr(x,p)}else{const x=c.get();x.queryControlPoints(p),x.queryWeights(f)}i&&$i(p),g===1&&(n.push(p[0].clone()),o.push(f[0])),n.push(p[1].clone()),n.push(p[2].clone()),o.push(f[1]),o.push(f[2]),g++}}return a&&(a.length=u,ne(a,l,0,0,u)),u-1}Xs.type=T.enumEllipticArc;let Rm=class Bs{static constructDefault(t){return new Bs(0,0,0,t,!1,Ie())}constructor(t,e,s,i,n,o){this.m_segmentBuffer=null,this.m_dummyPoint=new st,this.m_progressCounter=0,this.m_progressTracker=i,this.m_bSetDensifyFlag=n,this.m_maxLength=t,this.m_maxDeviation=e,this.m_maxAngle=s>ei()?ei():s,this.m_cosMaxAngle=Math.cos(this.m_maxAngle),this.m_bOnlyCurveDensify=this.m_maxAngle>0||this.m_maxDeviation>0,this.m_maxSegmentsPerCurve=o,tr(this.m_maxSegmentsPerCurve>0,"this.m_maxSegmentsPerCurve > 0"),this.m_minStep=1/this.m_maxSegmentsPerCurve}densify(t){return this.densifyGeom(t)}densifySegment(t,e){this.densifySegmentEx(t,null,!0,!1,e)}densifyEx(t,e,s,i,n,o){return this.m_maxLength=e,this.m_maxDeviation=s,this.m_maxAngle=i>ei()?ei():i,this.m_cosMaxAngle=Math.cos(this.m_maxAngle),this.m_bOnlyCurveDensify=this.m_maxAngle>0||this.m_maxDeviation>0,this.m_bSetDensifyFlag=n,this.m_maxSegmentsPerCurve=o,tr(this.m_maxSegmentsPerCurve>0,"this.m_maxSegmentsPerCurve > 0"),this.m_minStep=1/this.m_maxSegmentsPerCurve,this.densifyGeom(t)}densifyGeom(t){if(t.isEmpty()||t.getDimension()<1)return t;const e=t.getGeometryType();return Hc(e)?t:lt(e)?this.densifyMultiPath(t):he(e)?this.densifySegmentImpl(t):e===T.enumEnvelope?this.densifyEnvelope(t):void $("")}densifySegmentEx(t,e,s,i,n){const o=t.getGeometryType();if(!(this.m_maxLength>0||this.m_bOnlyCurveDensify&&o!==T.enumLine)&&(!i||s))return void(e?o===T.enumLine?e.addSegment(t,s):(s&&(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)),t.queryEnd(this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint)):(s&&n.push(0),n.push(1)));if(o===T.enumBezier)return void this.densifyCubicBezier(t,e,s,i,n);if(o===T.enumRationalBezier2)return void this.densifyRationalBezier2(t,e,s,i,n);if(o===T.enumBezier2)return void this.densifyBezier2(t,e,s,i,n);if(o===T.enumEllipticArc&&!t.isLine()&&t.getMinorMajorRatio()<.25)return void this.densifyEllipticArc(t,e,s,i,n);let a=1;this.m_maxLength>0&&(a=this.calculateLengthSubdivisionStep(t,this.m_maxLength)),this.m_maxDeviation>0&&(a=Math.min(a,this.calculateDeviationSubdivisionStep(t,this.m_maxDeviation))),this.m_maxAngle>0&&(a=Math.min(a,this.calculateAngularSubdivisionStep(t,this.m_maxAngle))),this.densifySegmentByLength(t,a,e,s,i,n)}densifyMultiPath(t){if(!t.hasNonLinearSegments()){if(t.getDescription().getAttributeCount()===1)return this.densifyMultiPathLinear(t);if(!(this.m_maxLength>0))return t}const e=t.createInstance();e.getGeometryType()===T.enumPolygon&&e.setFillRule(t.getFillRule()),e.reserve(t.getPointCount());const s=t.getImpl().querySegmentIterator();for(;s.nextPath();){let i=!0;for(;s.hasNextSegment();){const n=s.nextSegment(),o=s.isClosingSegment();this.densifySegmentEx(n,e,i,o,null),o&&e.closePathWithLine(),i=!1}}return e}densifySegmentImpl(t){const e=new Pt({vd:t.getDescription()}),s=[0];return this.densifySegmentEx(t,e,!0,!1,s),e}densifyEnvelope(t){const e=new ct({vd:t.getDescription()});e.addEnvelope(t,!1);const s=F.constructEmpty();t.queryEnvelope(s);const i=s.width(),n=s.height();return!(this.m_maxLength>0)||i<=this.m_maxLength&&n<=this.m_maxLength?e:this.densifyMultiPath(e)}densifyMultiPathLinear(t){if(!(this.m_maxLength>0))return t;const e=t.createInstance();e.getGeometryType()===T.enumPolygon&&e.setFillRule(t.getFillRule()),e.reserve(t.getPointCount());const s=e.getImpl(),i=t.getImpl(),n=i.getAttributeStreamRef(0),o=new ht;for(let a=0,h=i.getPathCount();a<h;a++){const m=i.isClosedPath(a);if(i.getPathSize(a)===0)continue;const l=i.getPathStart(a),u=n.readPoint2D(2*l),c=u.clone();s.startPath(u);for(let g=l+1,_=i.getPathEnd(a);g<_;g++){const d=n.readPoint2D(2*g),p=y.distance(c,d);if(p>this.m_maxLength){let f=Math.ceil(p/this.m_maxLength);f>Ie()&&(f=Ie());const x=1/f;let E,P,C;c.compare(d)<0?(o.setStartXY(c),o.setEndXY(d),E=0,P=1):(o.setStartXY(d),o.setEndXY(c),E=f-2,P=-1);for(let S=0,I=f-1;S<I;S++,E+=P){this.progress_(),C=x*(E+1);const w=new y;o.queryCoord2D(C,w),s.lineTo(w),this.m_bSetDensifyFlag&&s.setAttributeNoCurves(10,s.getPointCount()-1,0,1)}}else this.progress_();e.lineTo(d),c.assign(d)}if(m){const g=y.distance(c,u);if(g>this.m_maxLength){const _=u;let d=Math.ceil(g/this.m_maxLength);d>Ie()&&(d=Ie());const p=1/d;let f,x;c.compare(_)<0?(o.setStartXY(c),o.setEndXY(_),f=0,x=1):(o.setStartXY(_),o.setEndXY(c),f=d-2,x=-1);const E=new y(0,0);let P;for(let C=0,S=d-1;C<S;C++,f+=x)this.progress_(),P=p*(f+1),o.queryCoord2D(P,E),s.lineTo(E),this.m_bSetDensifyFlag&&s.setAttributeNoCurves(10,s.getPointCount()-1,0,1)}s.closePathWithLine()}}return e}densifySegmentByLength(t,e,s,i,n,o){b(t.getGeometryType()!==T.enumBezier);let a=t.getStartXY().compare(t.getEndXY());a===0&&e<1&&(t.getGeometryType()===T.enumEllipticArc?a=t.getSweepAngle()<0?1:-1:ft("densify segment by length"));let h=0;if(i&&(s?(t.queryStart(this.m_dummyPoint),s.startPathPoint(this.m_dummyPoint)):o.push(0),++h),e*this.m_maxSegmentsPerCurve<1&&(e=1/this.m_maxSegmentsPerCurve),e<1){this.m_segmentBuffer||(this.m_segmentBuffer=new it);let m=Math.ceil(1/e);m>Ie()&&(m=Ie()),e=1/m,this.m_segmentBuffer.create(t.getGeometryType());let l,u,c,g=t;a<0?(l=0,u=1):(t.copyTo(this.m_segmentBuffer.get()),this.m_segmentBuffer.get().reverse(),l=m-2,u=-1,g=this.m_segmentBuffer.get());const _=m-1;for(let d=0;d<_;d++,l+=u)c=e*(l+1),s?(g.queryCoord(c,this.m_dummyPoint),s.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&c!==1&&c!==0&&s.setAttribute(10,s.getPointCount()-1,0,1)):o.push(a>0?1-c:c),this.progress_();c=1,h+=_}(!n||n&&i&&h<2)&&(s?(t.queryEnd(this.m_dummyPoint),s.lineToPoint(this.m_dummyPoint)):o.push(1))}densifyCubicBezier(t,e,s,i,n){const o=new ws;let a=t;const h=t.calculateUpperLength2D();let m=t.getStartXY().compare(t.getEndXY());if(m===0&&h>0){const p=R(y,4);t.queryControlPoints(p),m=p[1].compare(p[2]),m===0&&(m=p[1].compare(p[0]))}m>0&&(t.copyTo(o),o.reverse(),a=o);let l=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):n.push(0),++l);const u=[],c=[],g=Math.trunc(Math.log2(this.m_maxSegmentsPerCurve));let _=!0,d=0;if(m>0)for(u.push([a.getStartXY(),a.getControlPoint1(),a.getControlPoint2(),a.getEndXY(),new y(0,1)]),c.push(0);u.length;){this.progress_();const p=u.at(-1),f=c.at(-1),x=p[4].x,E=p[4].y;if(f<g&&this.bezierNeedsSplit(p)){_&&(d=a.findMinDeriv(),_=!1);let P=.5*(x+E);Math.abs(d-P)<.4*(E-x)&&(P=d);const C=(P-x)/(E-x),S=p[0].mul(1-C).add(p[1].mul(C)),I=p[1].mul(1-C).add(p[2].mul(C)),w=p[2].mul(1-C).add(p[3].mul(C)),D=S.mul(1-C).add(I.mul(C)),N=I.mul(1-C).add(w.mul(C)),A=D.mul(1-C).add(N.mul(C)),M=p[3];p[1]=S,p[2]=D,p[3]=A,p[4].setCoords(x,P);const G=[A,N,w,M,new y(P,E)];u.push(G),c[c.length-1]=f+1,c.push(f+1)}else u.pop(),c.pop(),(u.length>0||!i||i&&s&&l<2)&&(e?(a.queryCoord(x,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&x!==1&&x!==0&&e.setAttribute(10,e.getPointCount()-1,0,1)):n.push(1-x),++l)}else for(u.push([a.getStartXY(),a.getControlPoint1(),a.getControlPoint2(),a.getEndXY(),new y(0,1)]),c.push(0);u.length;){this.progress_();const p=u.at(-1),f=c.at(-1),x=p[4].x,E=p[4].y;if(f<g&&this.bezierNeedsSplit(p)){_&&(d=a.findMinDeriv(),_=!1);let P=.5*(x+E);Math.abs(d-P)<.4*(E-x)&&(P=d);const C=(P-x)/(E-x),S=p[0].mul(1-C).add(p[1].mul(C)),I=p[1].mul(1-C).add(p[2].mul(C)),w=p[2].mul(1-C).add(p[3].mul(C)),D=S.mul(1-C).add(I.mul(C)),N=I.mul(1-C).add(w.mul(C)),A=D.mul(1-C).add(N.mul(C)),M=p[0];p[0]=A,p[1]=N,p[2]=w,p[4].setCoords(P,E);const G=[M,S,D,A,new y(x,P)];u.push(G),c[c.length-1]=f+1,c.push(f+1)}else u.pop(),c.pop(),(u.length>0||!i||i&&s&&l<2)&&(e?(a.queryCoord(E,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&E!==1&&E!==0&&e.setAttribute(10,e.getPointCount()-1,0,1)):n.push(E),++l)}}densifyRationalBezier2(t,e,s,i,n){const o=new Ge;let a=t;const h=t.calculateUpperLength2D();let m=t.getStartXY().compare(t.getEndXY());m===0&&h>0&&(m=0),m>0&&(t.copyTo(o),o.reverse(),a=o);let l=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):n.push(0),++l);const u=Math.trunc(Math.log2(this.m_maxSegmentsPerCurve)),c=new Ge,g=[],_=[];for(g.push(new z(0,1)),_.push(0);g.length;){this.progress_();const d=g.at(-1).clone(),p=_.at(-1);if(p<u&&this.rationalBezier2NeedsSplit(a,c,d.vmin,d.vmax)){const f=d.getCenter();m>0?(g.at(-1).vmax=f,g.push(new z(f,d.vmax))):(g.at(-1).vmin=f,g.push(new z(d.vmin,f))),_[_.length-1]=p+1,_.push(p+1)}else if(g.pop(),_.pop(),g.length>0||!i||i&&s&&l<2){const f=m>0?d.vmin:d.vmax;e?(a.queryCoord(f,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&f!==1&&f!==0&&e.setAttribute(10,e.getPointCount()-1,0,1)):n.push(m>0?1-f:f),++l}}}densifyBezier2(t,e,s,i,n){const o=new Oi;let a=t;const h=t.calculateUpperLength2D();let m=t.getStartXY().compare(t.getEndXY());m===0&&h>0&&(m=0),m>0&&(t.copyTo(o),o.reverse(),a=o);let l=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):n.push(0),++l);const u=Math.ceil(Math.log2(this.m_maxSegmentsPerCurve)),c=new Oi,g=[],_=[];for(g.push(new z(0,1)),_.push(0);g.length;){this.progress_();const d=g.at(-1).clone(),p=_.at(-1);if(p<u&&this.bezier2NeedsSplit(a,c,d.vmin,d.vmax)){const f=d.getCenter();m>0?(g.at(-1).vmax=f,g.push(new z(f,d.vmax))):(g.at(-1).vmin=f,g.push(new z(d.vmin,f))),_[_.length-1]=p+1,_.push(p+1)}else if(g.pop(),_.pop(),g.length>0||!i||i&&s&&l<2){const f=m>0?d.vmin:d.vmax;e?(a.queryCoord(f,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&f!==1&&f!==0&&e.setAttribute(10,e.getPointCount()-1,0,1)):n.push(m>0?1-f:f),++l}}}densifyEllipticArc(t,e,s,i,n){const o=new Xs;let a=t;const h=t.calculateUpperLength2D();let m=t.getStartXY().compare(t.getEndXY());m===0&&h>0&&(m=t.isClockwise()?0:1),m>0&&(t.copyTo(o),o.reverse(),a=o);let l=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):n.push(0),++l);const u=Math.trunc(Math.log2(this.m_maxSegmentsPerCurve)),c=new Xs,g=[],_=[];for(g.push(new z(0,1)),_.push(0);g.length;){this.progress_();const d=g.at(-1).clone(),p=_.at(-1);if(p<u&&this.ellipticArcNeedsSplit(a,c,d.vmin,d.vmax)){const f=d.getCenter();m>0?(g.at(-1).vmax=f,g.push(new z(f,d.vmax))):(g.at(-1).vmin=f,g.push(new z(d.vmin,f))),_[_.length-1]=p+1,_.push(p+1)}else if(g.pop(),_.pop(),g.length>0||!i||i&&s&&l<2){const f=m>0?d.vmin:d.vmax;e?(a.queryCoord(f,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&f!==1&&f!==0&&e.setAttribute(10,e.getPointCount()-1,0,1)):n.push(m>0?1-f:f),++l}}}calculateLengthSubdivisionStep(t,e){const s=t.calculateUpperLength2D();if(!t.isCurve())return s?e/s:1;if(t.getGeometryType()===T.enumEllipticArc){const i=t;if(i.isCircular()||i.isDegenerate(0)||i.isDegenerateToLine()){let n=e/s;return n<this.m_minStep&&(n=this.m_minStep),n}return e/s*i.getSemiAxes().y/i.getSemiAxes().x}t.getGeometryType()===T.enumBezier&&ft(""),ft("")}calculateDeviationSubdivisionStep(t,e){if(!t.isCurve())return 1;if(t.getGeometryType()===T.enumEllipticArc){const s=t;if(s.isDegenerate(0)||s.isDegenerateToLine())return 1;{const i=s.getSemiMajorAxis(),n=1-e/i;let o=Math.PI/2;if(n>0){const h=4*Math.sqrt(e/i*.5);o=Math.min(Math.PI/2,Math.abs(h))}o=Math.max(o,2*Math.PI/this.m_maxSegmentsPerCurve);const a=o*i;return this.calculateLengthSubdivisionStep(t,a)}}ft("")}calculateAngularSubdivisionStep(t,e){if(!t.isCurve())return 1;if(t.getGeometryType()===T.enumEllipticArc){const s=t;return s.isDegenerate(0)||s.isDegenerateToLine()?1:this.calculateLengthSubdivisionStep(t,e*s.getSemiMinorAxis())}ft("")}rationalBezier2NeedsSplit(t,e,s,i){t.cutBezierIgnoreAttributes(s,i,e);let n=!1;if(this.m_maxLength>0&&e.calculateUpperLength2D()>this.m_maxLength)return n=!0,!0;const o=R(y,3);e.queryControlPoints(o);const a=[0,0,0];return e.queryWeights(a),!n&&this.m_maxDeviation>0&&(n=!Bs.checkRationalBezier2MaxDeviation(o,a,this.m_maxDeviation)),!n&&this.m_maxAngle>0&&(n=!Bs.checkRationalBezier2MaxAngle(o,a,this.m_cosMaxAngle)),n}bezier2NeedsSplit(t,e,s,i){t.cutBezierIgnoreAttributes(s,i,e);let n=!1;if(this.m_maxLength>0&&e.calculateUpperLength2D()>this.m_maxLength)return n=!0,!0;const o=R(y,3);return e.queryControlPoints(o),!n&&this.m_maxDeviation>0&&(n=!Bs.checkBezier2MaxDeviation(o,this.m_maxDeviation)),!n&&this.m_maxAngle>0&&(n=!Bs.checkBezier2MaxAngle(o,this.m_cosMaxAngle)),n}ellipticArcNeedsSplit(t,e,s,i){t.cutArcIgnoreAttributes(s,i,e);let n=!1;return this.m_maxLength>0&&e.calculateUpperLength2D()>this.m_maxLength?(n=!0,!0):(!n&&this.m_maxDeviation>0&&(n=!Bs.checkEllipticArcMaxDeviation(e,this.m_maxDeviation)),!n&&this.m_maxAngle>0&&(n=!Bs.checkEllipticArcMaxAngle(e,this.m_cosMaxAngle)),n)}bezierNeedsSplit(t){let e=!1;return this.m_maxLength>0&&y.distance(t[0],t[1])+y.distance(t[1],t[2])+y.distance(t[2],t[3])>this.m_maxLength?(e=!0,!0):(!e&&this.m_maxDeviation>0&&(e=!Bs.checkBezierMaxDeviation(t,this.m_maxDeviation)),!e&&this.m_maxAngle>0&&(e=!Bs.checkBezierMaxAngle(t,this.m_cosMaxAngle)),e)}progress_(){}static checkBezierMaxDeviation(t,e){const s=t[3].sub(t[0]);if(s.sqrLength()>0){const i=s.clone();i.leftPerpendicularThis(),i.normalize();const n=i.dotProduct(t[0].sub(t[1])),o=i.dotProduct(t[0].sub(t[2]));if(Math.max(Math.abs(n),Math.abs(o))<=e){const a=new y;Rt(t,.5,a,!1);const h=a.sub(t[0]).dotProduct(s);return h>=0&&h<=s.sqrLength()}return!1}return Math.max(t[0].sub(t[1]).sqrLength(),t[0].sub(t[2]).sqrLength())<=e*e}static checkBezierMaxAngle(t,e){if(t[0].equals(t[3]))return!(!t[0].equals(t[1])||!t[1].equals(t[2]));const s=t[3].sub(t[0]);s.normalize();{const i=t[1].sub(t[0]),n=i.dotProduct(s);if(n<0||i.length()*e>n)return!1}{const i=t[2].sub(t[0]),n=i.dotProduct(s);if(n<0||i.length()*e>n)return!1}{const i=t[2].sub(t[1]),n=i.dotProduct(s);if(n<0||i.length()*e>n)return!1}return!0}static checkRationalBezier2MaxDeviation(t,e,s){if(e[1]===0)return!1;const i=t[2].sub(t[0]);if(i.sqrLength()>0){const n=i.clone();n.leftPerpendicularThis(),n.normalize();const o=n.dotProduct(t[0].sub(t[1]));if(Math.abs(o)<=s){const a=t[1].sub(t[0]).dotProduct(i);return a>=0&&a<=i.sqrLength()}return!1}return t[0].sub(t[1]).sqrLength()<=s*s}static checkRationalBezier2MaxAngle(t,e,s){if(e[1]===0)return!1;if(t[0].equals(t[2]))return!!t[0].equals(t[1]);const i=t[2].sub(t[0]);i.normalize();{const n=t[1].sub(t[0]),o=n.dotProduct(i);if(o<0||n.length()*s>o)return!1}return!0}static checkBezier2MaxDeviation(t,e){const s=t[2].sub(t[0]);if(s.sqrLength()>0){const i=s.clone();i.leftPerpendicularThis(),i.normalize();const n=i.dotProduct(t[0].sub(t[1]));if(Math.abs(n)<=e){const o=t[1].sub(t[0]).dotProduct(s);return o>=0&&o<=s.sqrLength()}return!1}return t[0].sub(t[1]).sqrLength()<=e*e}static checkBezier2MaxAngle(t,e){if(t[0].equals(t[2]))return!!t[0].equals(t[1]);const s=t[2].sub(t[0]);s.normalize();{const i=t[1].sub(t[0]),n=i.dotProduct(s);if(n<0||i.length()*e>n)return!1}return!0}static checkEllipticArcMaxDeviation(t,e){if(Math.abs(t.getSweepAngle())<Math.PI){const n=t.getEndXY().sub(t.getStartXY()),o=[0,0];if(D1(t,n,o)===1){const a=t.getCoord2D(o[0]),h=y.getClosestCoordinate(t.getStartXY(),t.getEndXY(),a),m=new y;return Qt(t.getStartXY(),t.getEndXY(),h,m),y.distance(a,m)<=e}}const s=t.getCoord2D(.5),i=new y;return Qt(t.getEndXY(),t.getStartXY(),.5,i),y.distance(s,i)<=e}static checkEllipticArcMaxAngle(t,e){const s=t.getTangent(0),i=t.getTangent(1),n=s.dotProduct(i);return!(n<0)&&!(s.length()*i.length()*e>n)}static checkTypeForReplace(t,e){return t.getGeometryType()===e&&(e!==T.enumEllipticArc||t.isCircular())}};function Jn(r,t,e){const s=e.length;if(t<=0||s<=2)return s;let i=0;const n=j(s-1,Number.NaN);for(let o=1,a=s;o<a;o++){const h=r.tToLength(e[o]);n[o-1]=h-i,i=h}for(;n.length>1;){const o=n.findIndex(m=>m<=2*t);if(o===-1)break;let a=o+1,h=o+1;if(o>0){const m=o-1;(h===n.length||n[m]>n[h])&&(h=m,a--)}n[h]+=n[o],n.splice(o,1),e.splice(a,1)}return e.length}function vu(r,t,e,s,i,n,o,a){const h=t.clone();h.dropAllAttributes();const m=(Y,U,X,B)=>(U&&(Y&&U.push(B.getStartXY()),U.push(y.getNAN()),U.push(y.getNAN()),U.push(B.getEndXY())),X&&(Y&&X.push(0),X.push(1)),1);if(h.isDegenerateToLine()||h.isDegenerate(0))return m(r,n,o,t);const l=h.getStartXY(),u=h.getEndXY(),c=h.getSemiAxes(),g=new pt;if(h.isCircular())g.setIdentity();else{const Y=h.getAxisXRotation();g.setScaleCoords(1,h.getMinorMajorRatio()),g.rotateAngle(Y)}const _=h.getCenter();g.shift(_);const d=g.clone();d.invertThis(),h.applyTransformation(d);const p=h.getSweepAngle();if(p===0)return m(r,n,o,t);const f=F.constructEmpty();f.setCoords({center:_,width:2*c.x,height:2*c.x});const x=.05*f.calculateToleranceFromEnvelope(),E=Math.max(e/c.x,x/c.x);let P=4*Math.pow(E/.0741,1/6);P=Math.min(P,Math.PI/2);const C=Qg(h.getStartAngle());let S=p>0?Math.floor(C/P):Math.ceil(C/P);S*=P;const I=p>0?P:-P;S+I===C&&(S+=I);let w=4/3*Math.tan(Math.abs(P)/4);p>0&&(w=-w),o&&r&&o.push(0);const D=P/Math.abs(p);let N=(S-C)/p;const A=l.clone(),M=new y;h.queryCoord2D(0,M);const G=M.clone(),q=1-.01*D;let V=0,k=0;for(;N<1;){let Y;if(N+=D,k>0&&N<q)Y=w;else{N>=q&&(N=1);const Z=(N-k)*p;Y=4/3*Math.tan(Math.abs(Z)/4),p>0&&(Y=-Y)}h.queryCoord2D(N,M);const U=new y;g.queryTransform(M,U);const X=t.getClosestCoordinate(U,!1);if(t.queryCoord2D(X,U),N!==1&&(y.distance(A,U)<=2*s||y.distance(U,u)<=2*s))continue;A.setCoordsPoint2D(U);const B=R(y,4);B[0].assign(G),B[3].assign(M),B[1].rightPerpendicularOther(G),B[1].scaleAddThis(Y,G),B[2].leftPerpendicularOther(M),B[2].scaleAddThis(Y,M),g.transformPoints2D(B,3,B),B[3].assign(U),k===0&&B[0].setCoordsPoint2D(l),N===1&&B[3].setCoordsPoint2D(u),i&&Ro(B);let W=!0;for(let Z=1;Z<4;Z++)if(!B[Z].isEqualPoint2D(B[0])){W=!1;break}W||(o&&o.push(X),n&&(k===0&&r&&n.push(B[0].clone()),n.push(B[1].clone()),n.push(B[2].clone()),n.push(B[3].clone())),V++),k=N,G.setCoordsPoint2D(M)}return V}function bu(r,t,e,s,i,n,o,a){t.clone().dropAllAttributes();const h=new F;t.queryLooseEnvelope(h);const m=.05*h.calculateToleranceFromEnvelope(),l=Math.max(e,m);o&&r&&o.push(0);let u=0;const c=R(y,3);t.queryControlPoints(c);const g=[0,0,0];t.queryWeights(g);const _=[],d=j(9,Number.NaN);let p=0;i?(p=t.getMonotonicPartParams(d.length,d),d.length=p,p=Jn(t,s,d)):(d.length=2,p=2,d[0]=0,d[1]=1);let f=0,x=r;for(let E=1;E<p;E++){const P=d[E];for(_.length=0,_.push(P),_.push(f);_.length>1;){const C=_.at(-1);_.pop();const S=_.at(-1),I=R(y,3),w=[0,0,0];bi(c,g,C,S,I,w);const D=R(y,4),N=Q0(I,w,D),A=16,M=_.length>A;l>=N||M?(o.push(S),n&&(x&&(n.push(D[0]),x=!1),n.push(D[1]),n.push(D[2]),n.push(D[3])),u++):(_.push(.5*(C+S)),_.push(C))}f=P}return u}function u1(){return{e2:0,completeE:0}}let c1=class{constructor(t,e){this.m_arc=t,this.m_sqrChordLength=e}getMaxDerivative(){return 1}getValue(t,e){return t===0?y.sqrDistance(this.m_arc.getCoord2D(e),this.m_arc.getCoord2D(1-e))-this.m_sqrChordLength:0}getError(t){return 0}};function g1(r,t,e){if(Ft(r))og(new ht({start:r.getStartXY(),end:r.getEndXY()}),t,e);else if(t.value()===0)e.set(r.getStartXY());else if(t.value()===1)e.set(r.getEndXY());else{const s=new L;Kg(r,t,s);const i=new L,n=new L;L.st_cosAndSin(s,i,n);const o=K.constructCoordsE(new L(r.m_semiMajorAxis).mulThisE(i),new L(r.m_semiMajorAxis).mulThis(r.m_minorMajorRatio).mulThisE(n)),a=new L(r.m_rotation);L.st_cosAndSin(a,i,n),o.rotateDirect(i,n),o.addThisE(K.constructPoint2D(r.m_center)),e.setE(o)}}function Wa(r,t){return r.convertToCanonic(t)}function _1(r,t){const e=new z(r.getStartAngle(),r.getEndAngle());e.normalize();const s=Ee(),i=Ci(t,s);if(i<e.vmin){let n=i+s;for(;n<e.vmin;)n+=s;return e.containsCoordinate(n)?n:e.vmin-i<n-e.vmax?i:n}if(i>e.vmax){let n=i-s;for(;n>e.vmax;)n-=s;return e.containsCoordinate(n)||e.vmin-n<i-e.vmax?n:i}return i}function d1(r,t,e,s){let i=r.m_startAngle,n=r.m_sweepAngle;const o=1e-12;for(;i>xt();)i-=2*xt();for(;i<=-xt();)i+=2*xt();if(!Number.isNaN(t)){for(;t>xt();)t-=2*xt();for(;t<=-xt();)t+=2*xt();!e&&t>i&&(t-=2*xt()),e&&t<i&&(t+=2*xt()),n=t-i,Math.abs(n)<o&&!s&&(n=e?2*xt():-2*xt()),Math.abs(n)>2*xt()-o&&s&&(n=0)}Math.abs(n)>2*xt()-o&&(n=n>=0?2*xt():-2*xt(),r.setEndXY(r.getStartXY())),Math.abs(n)<o&&(n=0,r.setEndXY(r.getStartXY())),s=Math.abs(n)<=xt(),n&&(e=n>0),r.m_startAngle=ki(i),r.m_sweepAngle=n,In(r,!s),ya(r,e)}function ki(r){let t=r,e=!1;return t<=-xt()?(t+=Ee(),e=!0):t>xt()&&(t-=Ee(),e=!0),t<=-xt()?(t=Ci(t,Ee()),t<=-xt()&&(t+=Ee()),e=!0):t>xt()&&(t=Ci(t,Ee()),t>xt()&&(t-=Ee()),e=!0),e&&(t>xt()||t<=-xt())&&(t=xt()),t}function Iu(r,t,e){const s=e,i=s.getSemiAxes();let n=new y(i.x*Math.cos(r[0]),i.y*Math.sin(r[0]));return n=s.convertFromCanonic(n),y.sqrDistance(n,s.getStartXY())}function wu(r,t,e){const s=e,i=s.getSemiAxes(),n=r[0]+s.getStartAngle();let o=new y(i.x*Math.cos(n),i.y*Math.sin(n));return o=s.convertFromCanonic(o),y.sqrDistance(o,s.getEndXY())}function Kh(r){if(r.m_center.isNAN())return r.m_startAngle=0,void(r.m_sweepAngle=0);const t=r.getStartXY(),e=r.getEndXY(),s=t.equals(e),i=Bm(r),n=bn(r),o=r.projectionBehavior();if(s){const a=r.convertToCanonic(t),h=new y(r.m_semiMajorAxis,r.m_semiMajorAxis*r.m_minorMajorRatio);a.x/=h.x,a.y/=h.y,r.m_startAngle=ki(Math.atan2(a.y,a.x)),r.m_sweepAngle=i?n?Ee():-Ee():0}else{const a=r.convertToCanonic(t),h=new y(r.m_semiMajorAxis,r.m_semiMajorAxis*r.m_minorMajorRatio);a.x/=h.x,a.y/=h.y;const m=r.convertToCanonic(e);m.x/=h.x,m.y/=h.y,r.m_startAngle=Math.atan2(a.y,a.x),r.m_sweepAngle=y.calculateAngle(a,m),n?r.m_sweepAngle<0&&(r.m_sweepAngle+=Ee()):r.m_sweepAngle>0&&(r.m_sweepAngle-=Ee()),r.m_startAngle=ki(r.m_startAngle);let l=Iu([r.m_startAngle],1,r);if(l=Math.sqrt(l),l>.25*si(r)){const c=r.m_startAngle-1e-4,g=r.m_startAngle+1e-4,_=[0];Bl(Iu,r,1,[r.m_startAngle],[c],[g],1e-14,_),r.m_startAngle=ki(_[0])}if(l=wu([r.m_sweepAngle],1,r),l=Math.sqrt(l),l>.25*si(r)){const c=r.m_sweepAngle-1e-4,g=r.m_sweepAngle+1e-4,_=[0];Bl(wu,r,1,[r.m_sweepAngle],[c],[g],1e-14,_),r.m_sweepAngle=_[0]}const u=Math.abs(r.m_sweepAngle)>xt();if(In(r,u),i!==u&&!i&&Math.abs(r.m_sweepAngle)>1.5*xt()||r.m_sweepAngle===0||n!==r.m_sweepAngle>0)return void ds(r,t,e,o)}}function zt(r,t){return(_1(r,t)-r.getStartAngle())/r.getSweepAngle()}function Ss(r,t){return r.m_startAngle+t*r.m_sweepAngle}function Kg(r,t,e){e.assign(new L(r.m_startAngle).addE(t.mulE(new L(r.m_sweepAngle))))}function p1(r,t){const e=new L(r.m_cosr).sqrThis(),s=new L(r.m_sinr).sqrThis(),i=new L(r.m_minorMajorRatio),n=new L(1/r.m_minorMajorRatio),o=i.mulE(e).addThisE(n.mulE(s)),a=i.subE(n).mulThis(2*r.m_cosr*r.m_sinr),h=i.mulE(s).addThisE(n.mulE(e));t[0]=o,t[1]=a,t[2]=h,t[3]=new L(-r.m_semiMajorAxis).mulThis(r.m_semiMajorAxis).mulThis(r.m_minorMajorRatio)}function f1(r,t){const e=new ar;e.a11.setE(r[0]),e.a12=L.st_mulByPower2(r[1],.5),e.a21.setE(e.a12),e.a22.setE(r[2]);const s=[y.getNAN(),y.getNAN()],i=[new L,new L];e.eigenSymmetric(i,s);const n=r[3].clone();return n.negateThis(),n.invThis(),i[0].mulThisE(n),i[1].mulThisE(n),i[0].sqrtThis().invThis(),i[1].sqrtThis().invThis(),t.x=i[0].toDouble(),t.y=i[1].toDouble(),Math.atan2(s[0].y,s[0].x)}function x1(r,t,e){if(Ft(r))return(e-t)*y.distance(r.getStartXY(),r.getEndXY());if(r.m_minorMajorRatio===1)return Math.abs(r.getSweepAngle()*(t-e))*r.m_semiMajorAxis;const s=Jh(r,t);return Jh(r,e)-s}function $a(r){return r.m_cachedValues}function km(r){if(r.m_cachedValues)return r.m_cachedValues;const t=u1();return t.e2=P1(r),t.completeE=$d(t.e2),r.m_cachedValues=t,t}function Du(r,t,e,s){if(!t.isEqual(r.m_XStart,r.m_YStart)||!e.isEqual(r.m_XEnd,r.m_YEnd)){if(Ft(r))return r.m_XStart=t.x,r.m_YStart=t.y,r.m_XEnd=e.x,r.m_YEnd=e.y,gn(r),void r.afterCompletedModification();if(s&&Math.abs(r.getSweepAngle())<=1.01*ei()){const i=R(y,3),n=Sr(r,i);if(fa(i)){if(i[0].assign(t),i[2].assign(e),$i(i),r.projectionBehavior()===0){let o=0,a=2;y.sqrDistance(i[1],i[0])<y.sqrDistance(i[1],i[2])&&(a=O(o,o=a));const h=i[a].sub(i[o]),m=h.length();h.divThis(m);const l=i[1].sub(i[o]),u=l.length(),c=l.dotProduct(h)/u,g=l.crossProduct(h)/u,_=new y;Qt(i[o],i[a],.5,_);const d=.5*m/g*Nt(1-c,0,1),p=i[1].side(i[o],i[a]),f=h.clone();p?f.leftPerpendicularThis():f.rightPerpendicularThis();const x=_.sub(f.mul(d));r.constructCircularArcThreePoint(i[0],i[2],x)}else vr(i,n*n,null,!1,r);return}}r.projectionBehavior()===0?N1(r,t,e):i_(r,t,e)}}function y1(r,t,e){const s=r.projectionBehavior()===0;if(e<=2)return void ds(r,t[0],t[e-1],s?0:1);if(s){r.constructCircularArcThreePoint(t[0],t[e-1],t[Math.trunc(e/2)]);const _=new y;return r.queryCoord2D(.5,_),void r.m_interior.setCoordsPoint2D(_)}const i=r.getSemiMajorAxis(),n=r.getMinorMajorRatio(),o=r.getAxisXRotation(),a=r.getCenter(),h=new Array(4);h[0]=r.isMajor(),h[1]=!h[0],h[2]=h[0],h[3]=!h[0];const m=new Array(4);m[0]=r.isClockwise(),m[1]=m[0],m[2]=!m[0],m[3]=!m[0];const l=Math.trunc(e<5?1:(e+4)/5),u=R(Xs,4),c=j(4,Number.NaN);let g=0;for(let _=0;_<4;_++){u[_].constructEllipticArcEndPointsCenter(t[0],t[e-1],i,n,o,h[_],m[_],a),c[_]=0;let d=0;for(let p=l;p<e-1;p+=l){const f=u[_].getClosestCoordinate(t[p],!1);c[_]+=y.sqrDistance(u[_].getCoord2D(f),t[p]),d++}c[_]/=d,c[_]<c[g]&&(g=_)}r.assignCopy(u[g])}function P1(r){return 1-yt(r.m_minorMajorRatio)}function Tu(r,t,e,s,i,n,o,a,h){return r.m_bits=0,r.m_rotation=n,bm(r,t),Im(r,e),r.m_cosr=Math.cos(n),r.m_sinr=Math.sin(n),In(r,o),ya(r,a),h!==void 0?r.m_center.assign(h):r.m_center.setNAN(),r.setProjectionBehavior(1),r.m_semiMajorAxis=s,r.m_minorMajorRatio=i,e_(r,h===void 0)}function ds(r,t,e,s){r.m_bits=0,r.m_rotation=0,bm(r,t),Im(r,e),r.m_interior.assign(t.add(e).mul(.5)),r.m_startAngle=0,r.m_sweepAngle=0,r.m_cosr=1,r.m_sinr=0,In(r,!1),ya(r,!1),r.m_center.setNAN(),r.m_semiMajorAxis=1,r.m_minorMajorRatio=0,r.setProjectionBehavior(s),r.afterCompletedModification()}function Ft(r){return r.m_center.isNAN()}function Jh(r,t){if(t===0)return 0;const e=km(r),s=Ss(r,t),i=ei(),n=Jg(r),o=zc(s+i,e.e2,e.completeE),a=r.m_semiMajorAxis*(o-n);return Math.abs(a)}function C1(r,t){if(Ft(r)){const h=y.distance(r.getStartXY(),r.getEndXY());return h===0?0:t/h}if(r.m_minorMajorRatio===1){const h=Math.abs(r.getSweepAngle()*r.m_semiMajorAxis);return h===0?0:t/h}if(t===0)return 0;const e=r.getSweepAngle();if(e===0)return .5;const s=km(r),i=ei(),n=Jg(r);e<0&&(t=-t);const o=t/r.m_semiMajorAxis+n;let a=Od(o,s.e2,s.completeE);return a-=i,a-=r.getStartAngle(),a/e}function Jg(r){const t=km(r);return zc(r.getStartAngle()+ei(),t.e2,t.completeE)}function Lm(r,t,e,s,i){if(t.m_TransformationType===2)return void b(0);if(b(!t_(r)),t.isIdentity()&&(!s||s.equals(r.getStartXY())&&i.equals(r.getEndXY())))return;xo(r);let n=y.getNAN(),o=y.getNAN();if(s===null?(n.x=r.m_XStart,n.y=r.m_YStart,t.transformInPlace(n),o.x=r.m_XEnd,o.y=r.m_YEnd,t.transformInPlace(o)):(n=s,o=i),Ft(r))return r.m_XStart=n.x,r.m_YStart=n.y,r.m_XEnd=o.x,void(r.m_YEnd=o.y);const a=r.m_center.clone();if(t.transformInPlace(a),e||t.isUniformNoRotation()){let h=bn(r);if(t.isReflective()&&(h=!h),r.projectionBehavior()===0){if(!n.equals(o)){const g=r.m_interior.clone();return t.transformInPlace(g),void r.constructCircularArcThreePoint(n,o,g)}return void E1(r,n,o,a,h,!1)}const m=new y(r.m_cosr,r.m_sinr);t.transformWithoutTranslateInPlace(m);const l=Math.atan2(m.y,m.x),u=r.getSemiAxes();t.transformWithoutTranslateInPlace(u);const c=r.m_center.clone();return t.transformInPlace(c),void r.constructEllipticArcEndPointsCenter(n,o,u.x,u.y/u.x,l,r.isMajor(),h,c)}{{const g=new Array(4);p1(r,g);const _=new ar;if(_.a11.setE(g[0]),_.a12.setE(g[1]),_.a12.mulThisByPower2(.5),_.a21.setE(_.a12),_.a22.setE(g[2]),!_.det().isZero()){const d=new ar;if(d.a11.set(t.xx),d.a12.set(t.xy),d.a21.set(t.yx),d.a22.set(t.yy),d.invertThis()){const p=d.clone();p.transposeThis();const f=_.clone();if(f.mulThis(d),f.mulLeftThis(p),!f.det().isZero()){const x=R(L,4);x[0].setE(f.a11),x[1].setE(f.a12),x[1].mulThisByPower2(2),x[2].setE(f.a22),x[3].setE(g[3]);const E=y.getNAN(),P=f1(x,E);let C=bn(r);return t.isReflective()&&(C=!C),void r.constructEllipticArcEndPointsCenter(n,o,E.x,E.y/E.x,P,r.isMajor(),C,a)}}}}const h=[y.getNAN(),y.getNAN(),y.getNAN()];h[0].setCoords(r.getSemiMajorAxis(),0),h[0].rotateDirect(r.m_cosr,r.m_sinr),h[1].setCoords(r.getSemiMajorAxis(),r.getSemiMinorAxis()),h[1].rotateDirect(r.m_cosr,r.m_sinr),h[2].setCoords(0,r.getSemiMinorAxis()),h[2].rotateDirect(r.m_cosr,r.m_sinr);let m=r.isClockwise();m&&(h[2]=O(h[0],h[0]=h[2]));const l=.5;t.transformWithoutTranslateArray(h,3,h),t.isReflective()&&(m=!m);const u=new y(0,0),c=r.createInstance();vr(h,l,u,!1,c),r.constructEllipticArcEndPointsCenter(n,o,c.getSemiMajorAxis(),c.getMinorMajorRatio(),c.getAxisXRotation(),r.isMajor(),!m,a)}}function E1(r,t,e,s,i,n){const o=.5*(s.sub(t).length()+s.sub(e).length());r.m_center.assign(s),r.m_startAngle=Math.atan2(t.y-r.m_center.y,t.x-r.m_center.x),d1(r,Math.atan2(e.y-r.m_center.y,e.x-r.m_center.x),i,n);const a=r.constructEllipticArcEndPointsCenter(t,e,o,1,0,Math.abs(r.m_sweepAngle)>Math.PI,r.m_sweepAngle>0,s);return r.setProjectionBehavior(0),a}function ja(r,t){r.m_cachedValues=t}function xo(r){r.m_cachedValues=null}function S1(r,t){t.m_cachedValues=O(r.m_cachedValues,r.m_cachedValues=t.m_cachedValues)}function ya(r,t){const e=t?1:0;r.m_bits=-2&r.m_bits|e}function bn(r){return!!(1&r.m_bits)}function In(r,t){const e=t?1:0;r.m_bits=-3&r.m_bits|e<<1}function Bm(r){return!!(2&r.m_bits)}function v1(r){if(r.m_center.isNAN())return!1;const t=8,e=new K;e.setWithEps(r.getStartXY(),t),e.subThisE(new K().setWithEps(r.m_center,t));const s=new L;s.setWithEps(r.m_rotation,t);const i=new L,n=new L;L.st_cosAndSin(s,i,n),e.rotateReverse(i,n);const o=new K;o.setWithEps(r.getEndXY()),o.subThisE(K.constructPoint2D(r.m_center)),o.rotateReverse(i,n);const a=new L;a.setWithEps(r.m_semiMajorAxis,t);const h=a.clone(),m=new L;m.setWithEps(r.m_minorMajorRatio),h.mulThisE(m),e.x.divThisE(a),e.y.divThisE(h),o.x.divThisE(a),o.y.divThisE(h);const l=e.x.sqr().addThisE(e.y.sqr()).subThisE(er),u=o.x.sqr().addThisE(o.y.sqr()).subThisE(er);return!l.isZero()||!u.isZero()}function t_(r){return!!(8&r.m_bits)}function yo(r){r.m_bits&=-9}function e_(r,t){yo(r);const e=r.getStartXY(),s=r.getEndXY();let i=!1;const n=Bm(r),o=bn(r),a=r.projectionBehavior(),h=e.equals(s);let m=r.m_minorMajorRatio===0||r.m_semiMajorAxis===0;if(Number.isNaN(r.m_minorMajorRatio)&&(r.m_semiMajorAxis===0?r.m_minorMajorRatio=1:Bc("NAN minor major ratio and non-zero major axis")),m||=t?h:r.m_center.isNAN(),m)return ds(r,e,s,a),!0;r.m_semiMajorAxis=Math.abs(r.m_semiMajorAxis),r.m_minorMajorRatio=Math.abs(r.m_minorMajorRatio),r.m_minorMajorRatio>1&&(r.m_semiMajorAxis*=r.m_minorMajorRatio,r.m_minorMajorRatio=1/r.m_minorMajorRatio);const l=new y(r.m_semiMajorAxis,r.m_semiMajorAxis*r.m_minorMajorRatio);if(b(l.y>0&&l.x>=l.y),h){const u=r.convertToCanonic(e);b(!l.isZero()),u.x/=l.x,u.y/=l.y;const c=Math.sqrt(yt(u.x)+yt(u.y));if(i=c!==1,r.m_semiMajorAxis*=c,l.mulThis(c),r.m_startAngle=ki(Math.atan2(u.y,u.x)),!n)return r.m_interior.assign(e),r.m_sweepAngle=0,r.afterCompletedModification(),i;r.m_sweepAngle=o?Ee():-Ee()}else{let u=r.m_center.isNAN()||v1(r);if(!u){const c=r.convertToCanonic(e);c.x/=l.x,c.y/=l.y;const g=new y(1,0);r.m_startAngle=y.calculateAngle(g,c);const _=r.convertToCanonic(s);_.x/=l.x,_.y/=l.y,r.m_sweepAngle=y.calculateAngle(c,_),u=!Nu(r)}if(u){i=!0;const c=e.sub(s).mulThis(.5);c.rotateReverse(r.m_cosr,r.m_sinr);let g=yt(c.x/l.x)+yt(c.y/l.y);g>1&&(g=Math.sqrt(g),r.m_semiMajorAxis*=g,l.mulThis(g));const _=new y(0,0);{const d=l.x*l.x,p=l.y*l.y,f=d*c.y*c.y+p*c.x*c.x,x=d*p-f;if(x>0){const E=Math.sqrt(x/f);_.setCoords(l.x*c.y/l.y,-l.y*c.x/l.x),_.mulThis(E),n===o&&_.negateThis()}}{const d=new y(_.x,_.y);d.rotateDirect(r.m_cosr,r.m_sinr),d.addThis(e.add(s).mulThis(.5)),r.m_center.assign(d)}}if(Kh(r),!Nu(r))return ds(r,e,s,a),!0}return gn(r),r.afterCompletedModification(),i}function Sr(r,t){b(Math.abs(r.getSweepAngle())<15*Math.PI/16);const e=r.getSemiMajorAxis(),s=r.getSemiMinorAxis();let i;if(e===0)return t[0].setCoordsPoint2D(r.getStartXY()),t[1].setCoordsPoint2D(r.getStartXY()),t[2].setCoordsPoint2D(r.getStartXY()),i=1,i;if(s===0)return t[0].setCoordsPoint2D(r.getStartXY()),t[2].setCoordsPoint2D(r.getEndXY()),t[1]=y.lerp(t[0],t[2],.5),i=1,i;const n=r.getSweepAngle(),o=r.getStartAngle(),a=o+n,h=new y(-e*Math.sin(o),s*Math.cos(o)),m=new y(-e*Math.sin(a),s*Math.cos(a));h.normalize(),m.normalize(),h.rotateDirect(r.m_cosr,r.m_sinr),m.rotateDirect(r.m_cosr,r.m_sinr),t[0].setCoordsPoint2D(r.getStartXY()),t[2].setCoordsPoint2D(r.getEndXY()),t[1].setSub(t[2],t[0]);const l=h.crossProduct(m);return t[1].assign(h.mul(t[1].crossProduct(m)/l)),t[1].addThis(t[0]),i=Math.cos(.5*n),i}function vr(r,t,e,s,i){if(s){const Y=Math.sqrt(t),U=yt(1-.5)+2*Y*.5*(1-.5)+yt(.5),X=r[0].mul(yt(1-.5)).add(r[1].mul(2*Y*.5*(1-.5))).add(r[2].mul(yt(.5))).divThis(U);return i.constructCircularArcThreePoint(r[0],r[2],X),!0}const n=r[0].sub(r[1]),o=r[2].sub(r[1]),a=n.crossProduct(o),h=n.dotProduct(o),m=t;b(m<=1),b(m>0);const l=.5/(1-m),u=n.sqrLength(),c=h,g=o.sqrLength(),_=yt(a),d=n.sub(o).sqrLength();if(_===0||h<=-Math.sqrt(u)*Math.sqrt(g))return ds(i,r[0],r[2],1),!1;const p=[0,0],f=new z;f.setInfinite();const x=Ui(2*_,-(d/m+4*c),2*(1-m)/m,f,!1,p);if(x===0)return ds(i,r[0],r[2],1),!1;x===1&&(p[1]=p[0]);const E=Math.sqrt(l/p[0]),P=Math.sqrt(l/p[1]),C=.5/m;let S=C-g*p[0],I=C-u*p[0];Math.abs(S)>Math.abs(I)?I=c*p[0]-C+1:S=c*p[0]-C+1;const w=n.mul(S).add(o.mul(I)),D=w.norm(1)<1e-15*E?0:Math.atan2(w.y,w.x)+Math.PI,N=n.add(o),A=e?e.clone():r[1].add(N.mul(l)),M=r[0].sub(A),G=r[2].sub(A),q=M.crossProduct(G)<0,V=!1;return new Xs,i.constructEllipticArcEndPointsCenter(r[0],r[2],E,P/E,D,V,!q,A)}function b1(r,t,e,s,i){return vr(r,t,e,s,i)}function Nu(r){const t=si(r);let e=!1;{const i=new y(r.m_semiMajorAxis*Math.cos(r.m_startAngle),r.getSemiMinorAxis()*Math.sin(r.m_startAngle));i.rotateDirect(r.m_cosr,r.m_sinr),i.addThis(r.m_center),e=y.distance(r.getStartXY(),i)>t}let s=!1;if(!e){const i=new y(r.m_semiMajorAxis*Math.cos(r.m_startAngle+r.m_sweepAngle),r.getSemiMinorAxis()*Math.sin(r.m_startAngle+r.m_sweepAngle));i.rotateDirect(r.m_cosr,r.m_sinr),i.addThis(r.m_center),s=y.distance(r.getEndXY(),i)>t}return!e&&!s}function I1(r,t,e,s){e===0&&H("construct_enclosing_circle");const i=[0,0,0],n=a1(t,e,i);if(n===1)r.constructCircleRadius(0,t[i[0]],s);else if(n===2){const o=y.lerp(t[i[0]],t[i[1]],.5),a=y.distance(t[i[0]],o),h=y.distance(t[i[1]],o);r.constructCircleRadius(Math.max(a,h),o,s)}else if(n===3){const o=y.calculateCircleCenterFromThreePoints(t[i[0]],t[i[1]],t[i[2]]),a=y.distance(t[i[0]],o),h=y.distance(t[i[1]],o),m=y.distance(t[i[2]],o);r.constructCircleRadius(Math.max(a,h,m),o,s)}else $("unexpected")}function Au(r){if(Ft(r)||r.isDegenerate(0))return 0;const t=r.m_semiMajorAxis,e=r.getSemiMinorAxis(),s=t*t+e*e,i=r.getStartAngle(),n=r.getEndAngle(),o=r.m_center.y-r.m_YStart,a=r.m_cosr,h=r.m_sinr;let m=1,l=0;r.m_rotation&&(m=(a-h)*(a+h),l=2*a*h);const u=((-.5*(n-i)+.25*m*(2*Math.cos(n+i)*Math.sin(n-i)))*e+-2*Math.sin(.5*(n+i))*Math.sin(.5*(n-i))*a*o)*t/s;let c=0;return r.m_rotation&&(c=.125*(-2*Math.sin(n+i)*Math.sin(n-i))*l-e*o/s*(2*Math.cos(.5*(n+i))*Math.sin(.5*(n-i)))*h),s*(u+c)+-.5*(r.m_XEnd-r.m_XStart)*(r.m_YEnd-r.m_YStart)}function gn(r){r.queryCoord2D(.5,r.m_interior)}function qu(r,t,e,s,i){if(i){if(Qe(t,e)!==0)return 2}else if(is(t,e))return 1;return br(r,t,e,null,null,null,s,i!==void 0&&i,!0,!1)!==0?4:0}function w1(r,t,e,s,i){if(i){if(Qe(t,e)!==0)return 2}else if(is(t,e))return 1;return s_(r,t,e,null,null,null,s,i!==void 0&&i,!0,!1)!==0?4:0}function br(r,t,e,s,i,n,o,a,h,m){if(Ft(t))return da(new ht({start:t.getStartXY(),end:t.getEndXY()}),e,s,i,n,o,a,m);i!==null&&(i.length=0),n!==null&&(n.length=0),s!==null&&(s.length=0);const l=Xe(t,e);if(ns(t,e,o=Math.max(l,o)))return 0;const u=e.getStartXY();u.subThis(t.m_center);const c=e.getEndXY();c.subThis(t.m_center),u.rotateReverse(t.m_cosr,t.m_sinr),c.rotateReverse(t.m_cosr,t.m_sinr);const g=c.clone();g.subThis(u);const _=t.m_semiMajorAxis,d=1/_,p=t.getSemiMinorAxis(),f=1/p,x=g.clone();x.leftPerpendicularThis();const E=Math.atan2(p*x.y,_*x.x),P=j(16,Number.NaN),C=j(16,Number.NaN);let S=0;const I=[E,E+Math.PI];for(let q=0;q<2;++q){const V=zt(t,I[q]);if(V>=0&&V<=1){P[S]=V;const k=t.getCoord2D(P[S]);C[S]=e.getClosestCoordinate(k,!1),y.distance(k,e.getCoord2D(C[S]))<=o&&S++}}const w=u.x*d,D=u.y*f,N=g.x*d,A=g.y*f;let M=Ui(N*N+A*A,2*(w*N+D*A),w*w+D*D-1,z.unit(),!1,C);b(M>=0);for(let q=0;q<M;q++){const V=g.mul(C[q]).add(u);V.x*=d,V.y*=f;const k=zt(t,Math.atan2(V.y,V.x));if(k>=0&&k<=1){P[S]=k;const Y=t.getCoord2D(k);C[S]=e.getClosestCoordinate(Y,!1),y.distance(Y,e.getCoord2D(C[S]))<=o&&S++}}b(S<P.length+4);const G=j(16,Number.NaN);M=t.intersectPoint(e.getStartXY(),G,o);for(let q=0;q<M;q++,S++)P[S]=G[q],C[S]=0;M=t.intersectPoint(e.getEndXY(),G,o);for(let q=0;q<M;q++,S++)P[S]=G[q],C[S]=1;M=e.intersectPoint(t.getStartXY(),G,o);for(let q=0;q<M;q++,S++)P[S]=0,C[S]=G[q];M=e.intersectPoint(t.getEndXY(),G,o);for(let q=0;q<M;q++,S++)P[S]=1,C[S]=G[q];return S===0?0:rs(r,t,e,P,C,S,s,i,n,o,a,h,m)}function s_(r,t,e,s,i,n,o,a,h,m){if(Ft(t)){const N=new ht({start:t.getStartXY(),end:t.getEndXY()});return br(r,e,N,s,n,i,o,a,h,!0)}if(Ft(e)){const N=new ht({start:e.getStartXY(),end:e.getEndXY()});return br(r,t,N,s,i,n,o,a,h,m)}const l=Xe(t,e);o=Math.max(o,l);let u=!1;{const N=t.getSemiAxes(),A=t.getCenter(),M=e.getSemiAxes(),G=e.getCenter(),q=y.distance(G,A),V=N.x+M.x;if(q>V+o)return 0;if(N.y>M.x){if(q+M.x+o<N.y)return 0}else if(M.y>N.x&&q+N.x+o<M.y)return 0;if(h&&!a){const k=t.m_minorMajorRatio===1&&t.isClosed()&&t.isMajor(),Y=e.m_minorMajorRatio===1&&e.isClosed()&&e.isMajor();if(k&&Y&&(u=!0,q<=V)&&Math.max(N.x,M.x)<=Math.min(N.x,M.x)+q)return b(!i&&!n),1}}if(!u&&ns(t,e,o))return 0;const c=[],g=[],_=!1,d=!1,p=zo(t,0,0,_,d,c,g,null),f=[],x=[],E=zo(e,0,0,_,d,f,x,null);if(p===1&&E===1){const N=new Ge({points:c,weights:g}),A=new Ge({points:f,weights:x}),M=[],G=[],q=Pr(!1,N,A,s,i===null?null:M,n===null?null:G,o,a,h,m);if(q>0&&i!==null||n!==null){i&&(i.length=0),n&&(n.length=0);for(let V=0;V<q;++V){if(i)if(qt(M[V],0,1))i.push(M[V]);else{const k=N.tToLength(M[V]),Y=t.lengthToT(k);i.push(Y)}if(n)if(qt(G[V],0,1))n.push(G[V]);else{const k=A.tToLength(G[V]),Y=e.lengthToT(k);n.push(Y)}}}return q}let P=[];const C=[];let S=0;const I=h&&!a;for(let N=0;N<p;N++){const A=new Ge({points:c.slice(2*N,2*N+3),weights:g.slice(2*N,2*N+3)});let M=0;for(let G=0;G<E;G++){C.length<=G&&C.push(new Ge({points:f.slice(2*G,2*G+3),weights:x.slice(2*G,2*G+3)}));const q=[],V=[],k=I?null:q,Y=I?null:V,U=Pr(!1,A,C[G],null,k,Y,o,!1,I,!1);if(U>0&&I)return 1;for(let X=0;X<U;++X){if(q[X]===0&&N===0)q[X]=0;else if(q[X]===1&&N===p-1)q[X]=1;else{const B=A.tToLength(q[X])+S,W=t.lengthToT(B);q[X]=W}if(V[X]===0&&G===0)V[X]=0;else if(V[X]===1&&G===E-1)V[X]=1;else{const B=C[G].tToLength(V[X])+M,W=e.lengthToT(B);V[X]=W}P.push(te(q[X],V[X]))}M+=C[G].calculateLength2D()}S+=A.calculateLength2D()}if(P.length===0)return 0;if(a&&(P=P.filter(N=>!qt(N.first,0,1)||!qt(N.second,0,1)||!t.getCoord2D(N.first).equals(e.getCoord2D(N.second)))),h)return P.length;const w=[],D=[];for(const N of P)w.push(N.first),D.push(N.second);return rs(r,t,e,w,D,w.length,s,i,n,o,a,h,m)}function Fu(r,t,e){if(e.setCoords(r.getCoord2D(t.vmin)),e.mergeNe(r.getCoord2D(t.vmax)),Ft(r))return;const s=r.getSemiAxes(),i=[0,0,0,0];{const o=Math.atan2(-s.y*r.m_sinr,s.x*r.m_cosr),a=o+Math.PI,h=Math.atan2(s.y*r.m_cosr,s.x*r.m_sinr),m=h+Math.PI;i[0]=zt(r,o),i[1]=zt(r,a),i[2]=zt(r,h),i[3]=zt(r,m)}const n=new y;for(let o=0;o<4;o++){const a=i[o];t.containsExclusiveCoordinate(a)&&(r.queryCoord2D(a,n),e.mergeNe(n))}}function Mu(r,t,e,s,i){if(r.m_semiMajorAxis===0)return e.vmin;let n=y.getNAN();r.queryCoord2D(e.vmin,n);let o=y.getNAN();if(r.queryCoord2D(e.vmax,o),Ft(r))return new ht({start:n,end:o}).getClosestCoordinate(t,s);const a=Wa(r,t);if(n=Wa(r,n),o=Wa(r,o),r.m_minorMajorRatio===1){if(a.isEqual(0,0))return e.vmin;const S=zt(r,Math.atan2(a.y,a.x));return s||e.containsCoordinate(S)?S:y.distance(a,n)<=y.distance(a,o)?e.vmin:e.vmax}const h=r.getSemiMajorAxis(),m=r.getSemiMinorAxis(),l=(h-m)*(h+m),u=yt(l),c=a.x,g=a.y,_=yt(m*g),d=m*l*g*2,p=[new L(_),new L(d),new L(u-yt(h*c)-_),new L(-d),new L(-u)],f=R(L,4),x=cg(p,4,new z(-1,1),!1,f,4);let E=e.vmin,P=y.sqrDistance(a,n);{const S=y.sqrDistance(a,o);S<P&&(E=e.vmax,P=S)}b(!s);let C=j(8,Number.NaN);for(let S=0;S<x;++S){const I=f[S].value(),w=Math.sqrt(1-I*I),D=Math.atan2(I,w),N=Math.atan2(I,-w);C[2*S]=zt(r,D),C[2*S+1]=zt(r,N)}C=C.slice(0,2*x),Mr(C);for(let S=0,I=2*x;S<I;++S)if(C[S]>e.vmin&&C[S]<e.vmax){const w=y.sqrDistance(t,r.getCoord2D(C[S]));P>w&&(P=w,E=C[S])}return E}function D1(r,t,e){b(!Ft(r));const s=new pt;s.setRotateAngle(-r.getAxisXRotation());const i=new y;s.queryTransform(t,i);const n=Math.atan2(-i.x*r.getMinorMajorRatio(),i.y),o=n+xt();let a=zt(r,n),h=zt(r,o);h<a&&(h=O(a,a=h));let m=0;return a>=0&&a<=1&&(e[m++]=a),h>=0&&h<=1&&(e[m++]=h),m}function Gu(r,t,e){return r.m_semiMajorAxis===t.m_semiMajorAxis&&r.isMajor()!==t.isMajor()&&!!r.m_center.equals(t.m_center)&&r.m_sinr===t.m_sinr&&r.m_cosr===t.m_cosr&&r.m_minorMajorRatio===t.m_minorMajorRatio&&(e?r.isClockwise()!==t.isClockwise():r.isClockwise()===t.isClockwise())}function T1(r,t,e){if(Ft(r))e.setE(K.constructPoint2D(r.getEndXY()).subE(K.constructPoint2D(r.getStartXY())));else{const s=new L;Kg(r,t,s);const i=new K;if(i.setCoordsE(new L(r.m_semiMajorAxis).negate().mulE(new L().setSin(s)),new L(r.getSemiMinorAxis()).mulE(new L().setCos(s))),r.m_rotation){const n=new L(r.m_rotation);i.rotateDirect(new L().setCos(n),new L().setSin(n))}i.scaleThis(new L(r.getSweepAngle())),e.setE(i)}}function N1(r,t,e,s){const i=r.getStartXY(),n=r.getEndXY(),o=i.equals(n),a=t.equals(e);if(!o&&!a){const d=new pt;d.setShiftCoords(-r.m_XStart,-r.m_YStart);const p=y.distance(t,e),f=y.distance(i,n),x=p/f;d.scale(x,x);const E=n.sub(i);E.divThis(f);const P=e.sub(t);P.divThis(p);const C=E.crossProduct(P),S=P.dotProduct(E);return d.rotate(S,C),d.shiftCoords(t.x,t.y),void Lm(r,d,!0,t,e)}const h=new y;if(r.queryCoord2D(.5,h),a){if(o){const d=r.m_center.add(t.sub(i));r.constructEllipticArcEndPointsCenter(t,e,r.getSemiMajorAxis(),1,0,!0,!r.isClockwise(),d),r.setProjectionBehavior(0)}else if(r.isMajor()){const d=h.sub(t).getUnitVector().mul(2*r.getSemiMajorAxis()).add(t);r.constructCircularArcThreePoint(t,e,d)}else r.constructCircularArcThreePoint(t,e,t);return}const m=t.add(e).mul(.5),l=e.sub(t);l.rightPerpendicularThis();const u=m.add(l),c=y.getClosestCoordinate(m,u,r.getCenter(),!0),g=new y;Qt(m,u,c,g);const _=y.distance(t,g);r.constructEllipticArcEndPointsCenter(t,e,_,1,0,!0,!r.isClockwise(),g),r.setProjectionBehavior(0)}function i_(r,t,e,s){const i=r.getStartXY(),n=r.getEndXY(),o=i.equals(n),a=t.equals(e);if(!o&&!a){const g=new pt;return g.initializeFromTwoPoints(i,n,t,e),Lm(r,g,!0,t,e),r.endPointModified(),void r.normalizeAfterEndpointChange()}if(!r.isMajor())return void ds(r,t,e,1);if(o&&a){const g=r.m_center.add(t.sub(i));return void r.constructEllipticArcEndPointsCenter(t,e,r.getSemiMajorAxis(),r.getMinorMajorRatio(),r.getAxisXRotation(),!0,!r.isClockwise(),g)}if(!o){const g=.5*(Ee()-Math.abs(r.getSweepAngle())),_=(r.getSweepAngle()+g*kt(r.getSweepAngle()))/r.getSweepAngle(),d=new y;r.queryCoord2D(_,d),r.constructEllipticArcEndPointsCenter(d,d,r.getSemiMajorAxis(),r.getMinorMajorRatio(),r.getAxisXRotation(),!0,!r.isClockwise(),r.getCenter());const p=r.getCenter().add(t.sub(d));return void r.constructEllipticArcEndPointsCenter(t,e,r.getSemiMajorAxis(),r.getMinorMajorRatio(),r.getAxisXRotation(),!0,!r.isClockwise(),p)}const h=y.sqrDistance(t,e);let m=.25,l=.75;if(h<y.sqrDistance(r.getCoord2D(.25),r.getCoord2D(.75))){const g=[0],_=Ti(new c1(r,h),z.construct(0,.25),1,g);_>0&&(b(_===1),m=g[0],l=1-g[0])}const u=r.getCoord2D(m),c=r.getCoord2D(l);b(!u.equals(c)),r.constructEllipticArcEndPointsCenter(u,c,r.getSemiMajorAxis(),r.getMinorMajorRatio(),r.getAxisXRotation(),!0,!r.isClockwise(),r.m_center),i_(r,t,e)}function Gn(r,t,e,s,i){return Pa(r,!1,t,e,s,i)}function Pa(r,t,e,s,i,n){const o=e.getGeometryType(),a=s.getGeometryType(),h=Math.max(i,Xe(e,s));if(o===T.enumLine&&a===T.enumLine)return yh(e,s,h,n);let m=e,l=s,u=e.getStartXY(),c=e.getEndXY();if(u.compare(c)>0&&(m=e.clone().reverse()),u=s.getStartXY(),c=s.getEndXY(),u.compare(c)>0&&(l=s.clone().reverse()),t){if(e.equals(s))return 2;if(Vp(e,s,h))return 4}switch(o){case T.enumLine:switch(a){case T.enumEllipticArc:return qu(r,l,m,h,n);case T.enumBezier:return lu(r,l,m,h,n);case T.enumRationalBezier2:return yu(r,l,m,h,n);case T.enumBezier2:return Ql(r,l,m,h,n);default:$("")}break;case T.enumEllipticArc:switch(a){case T.enumLine:return qu(r,m,l,h,n);case T.enumEllipticArc:return w1(r,m,l,h,n);case T.enumBezier:return uu(r,l,m,h,n);case T.enumRationalBezier2:return Pu(r,l,m,h,n);case T.enumBezier2:return Kl(r,l,m,h,n);default:$("")}break;case T.enumBezier:switch(a){case T.enumLine:return lu(r,m,l,h,n);case T.enumEllipticArc:return uu(r,m,l,h,n);case T.enumBezier:return p0(r,m,l,h,n);case T.enumRationalBezier2:return cu(r,m,l,h,n);case T.enumBezier2:return gu(r,m,l,h,n);default:$("")}break;case T.enumRationalBezier2:switch(a){case T.enumLine:return yu(r,m,l,h,n);case T.enumEllipticArc:return Pu(r,m,l,h,n);case T.enumBezier:return cu(r,l,m,h,n);case T.enumRationalBezier2:return J0(r,m,l,h,n);case T.enumBezier2:return Cu(r,m,l,h,n);default:$("")}break;case T.enumBezier2:switch(a){case T.enumLine:return Ql(r,m,l,h,n);case T.enumEllipticArc:return Kl(r,m,l,h,n);case T.enumBezier:return gu(r,l,m,h,n);case T.enumRationalBezier2:return Cu(r,l,m,h,n);case T.enumBezier2:return Nf(r,m,l,h,n);default:$("")}break;default:$("")}}function Qe(r,t,e=!0){if(!e&&!n_(r,t))return 0;const s=r.isLine()&&t.isLine();if(r.getStartXY().equals(t.getStartXY())&&r.getEndXY().equals(t.getEndXY())){if(s)return 1;const n=r.getGeometryType();if(n!==t.getGeometryType())return 0;if(n===T.enumBezier){const o=r,a=t;return o.getControlPoint1().equals(a.getControlPoint1())&&o.getControlPoint2().equals(a.getControlPoint2())?1:0}if(n===T.enumEllipticArc)return Gu(r,t,!1)?1:0;if(n===T.enumRationalBezier2){const o=r,a=t;if(o.getControlPoint1().equals(a.getControlPoint1())&&o.getStandardFormWeight()===a.getStandardFormWeight())return 1}else if(n===T.enumBezier2){const o=t;if(r.getControlPoint1().equals(o.getControlPoint1()))return 1}return 0}if(r.getStartXY().equals(t.getEndXY())&&r.getEndXY().equals(t.getStartXY())){if(s)return-1;const n=r.getGeometryType();if(n!==t.getGeometryType())return 0;if(n===T.enumBezier){const o=r,a=t;return o.getControlPoint1().equals(a.getControlPoint2())&&o.getControlPoint2().equals(a.getControlPoint1())?-1:0}if(n===T.enumEllipticArc)return Gu(r,t,!0),-1;if(n===T.enumRationalBezier2){const o=r,a=t;if(o.getControlPoint1().equals(a.getControlPoint1())&&o.getStandardFormWeight()===a.getStandardFormWeight())return-1}else if(n===T.enumBezier2){const o=t;if(r.getControlPoint1().equals(o.getControlPoint1()))return-1}return 0}return 0}function n_(r,t){const e=r.getGeometryType();return e===t.getGeometryType()&&(e!==T.enumEllipticArc||r.projectionBehavior()===t.projectionBehavior())}function en(r,t,e,s,i,n,o){!i&&n&&H("");const a=t.getGeometryType(),h=e.getGeometryType(),m=Math.max(o,Xe(t,e));if(s&&(s.length=0),i&&(i.length=0),n&&(n.length=0),a===T.enumLine&&h===T.enumLine)return da(t,e,s,i,n,m,!1,!1);let l=t,u=e,c=t.getStartXY(),g=t.getEndXY(),_=!1,d=!1;c.compare(g)>0&&(l=t.clone(!0).reverse(),_=!0),c=e.getStartXY(),g=e.getEndXY(),c.compare(g)>0&&(u=e.clone(!0).reverse(),d=!0);let p=0;switch(a){case T.enumLine:switch(h){case T.enumEllipticArc:p=br(r,u,l,s,n,i,m,!1,!1,!0);break;case T.enumBezier:p=pr(r,u,l,s,n,i,m,!1,!1,!0);break;case T.enumRationalBezier2:p=ji(r,u,l,s,n,i,m,!1,!1,!0);break;case T.enumBezier2:p=cr(r,u,l,s,n,i,m,!1,!1,!0);break;default:$("")}break;case T.enumEllipticArc:switch(h){case T.enumLine:p=br(r,l,u,s,i,n,m,!1,!1,!1);break;case T.enumEllipticArc:p=s_(r,l,u,s,i,n,m,!1,!1,!1);break;case T.enumBezier:p=Vh(r,u,l,s,n,i,m,!1,!1,!0);break;case T.enumRationalBezier2:p=zh(r,u,l,s,n,i,m,!1,!1,!0);break;case T.enumBezier2:p=Th(r,u,l,s,n,i,m,!1,!1,!0);break;default:$("")}break;case T.enumRationalBezier2:switch(h){case T.enumLine:p=ji(r,l,u,s,i,n,m,!1,!1,!1);break;case T.enumEllipticArc:p=zh(r,l,u,s,i,n,m,!1,!1,!1);break;case T.enumBezier:p=Yh(r,u,l,s,n,i,m,!1,!1,!0);break;case T.enumRationalBezier2:p=Pr(r,l,u,s,i,n,m,!1,!1,!1);break;case T.enumBezier2:p=Uh(r,l,u,s,i,n,m,!1,!1,!1);break;default:$("")}break;case T.enumBezier2:switch(h){case T.enumLine:p=cr(r,l,u,s,i,n,m,!1,!1,!1);break;case T.enumEllipticArc:p=Th(r,l,u,s,i,n,m,!1,!1,!1);break;case T.enumBezier:p=Xh(r,u,l,s,n,i,m,!1,!1,!0);break;case T.enumRationalBezier2:p=Uh(r,u,l,s,n,i,m,!1,!1,!0);break;case T.enumBezier2:p=Am(r,l,u,s,i,n,m,!1,!1,!1);break;default:$("")}break;case T.enumBezier:switch(h){case T.enumLine:p=pr(r,l,u,s,i,n,m,!1,!1,!1);break;case T.enumEllipticArc:p=Vh(r,l,u,s,i,n,m,!1,!1,!1);break;case T.enumBezier:p=Vm(r,l,u,s,i,n,m,!1,!1,!1);break;case T.enumRationalBezier2:p=Yh(r,l,u,s,i,n,m,!1,!1,!1);break;case T.enumBezier2:p=Xh(r,l,u,s,i,n,m,!1,!1,!1);break;default:$("")}break;default:$("")}if(_){if(i){for(let f=0;f<p;f++)i[f]=1-i[f];i.reverse()}s&&s.reverse(),n&&n.reverse()}if(d&&n)for(let f=0;f<p;f++)n[f]=1-n[f];return p}function so(r,t,e){return t===e?0:(t>e&&(e=O(t,t=e)),r.cut(t,e,!0).calculateUpperLength2D())}function A1(r,t,e,s,i){const n=[],o=[],a=[];for(let m=0,l=i;m<l;m++)n.push(r.calculateSubLengthFromStart(e[m])),o.push(t.calculateSubLengthFromStart(s[m])),qt(e[m],0,1)&&qt(s[m],0,1)&&r.getCoord2D(e[m]).equals(t.getCoord2D(s[m]))&&a.push(m);if(a.length===0||a.length===i)return;a.sort((m,l)=>e[m]<e[l]?-1:e[m]>e[l]?1:s[m]<s[l]?-1:s[m]>s[l]?1:0);let h=-1;for(const m of a){if(h>=0&&e[m]===e[h]&&e[m]===e[h]){h=m;continue}h=m;const l=[];l.length=i;for(let u=0;u<l.length;++u)l[u]=u;l.sort((u,c)=>{const g=n[m],_=o[m],d=n[u]-g,p=o[u]-_,f=d*d+p*p,x=n[c]-g,E=o[c]-_,P=x*x+E*E;return f<P?-1:f>P?1:0});for(let u=0;u<i;u++){const c=l[u];if(c===m||e[c]===e[m]&&s[c]===s[m]||qt(e[c],0,1)&&qt(s[c],0,1))continue;const g=(S,I,w,D)=>{const N=new K,A=new L;A.setWithEps(1);const M=new L;M.set(I,A.eps()),r.queryCoord2DE(M,N);const G=new K;r.queryCoord2DE(new L(S),G);let q=!1;return N.eq(G)&&(M.set(D,A.eps()),t.queryCoord2DE(M,N),t.queryCoord2DE(new L(w),G),q=N.eq(G)),!q},_=y.getNAN();r.queryCoord2D(e[c],_);const d=y.getNAN();if(t.queryCoord2D(s[c],d),y.distance(_,d)===0&&g(e[m],e[c],s[m],s[c]))break;const p=new z(s[c],s[m]);p.normalizeNoNAN();const f=new z(e[c],e[m]);f.normalizeNoNAN();let x=-1,E=Number.POSITIVE_INFINITY,P=Number.POSITIVE_INFINITY,C=e[c];_.assign(r.getCoord2D(C));for(let S=0;S<5;S++){const I=t.getClosestCoordinateOnInterval(_,p,-1);d.assign(t.getCoord2D(I));const w=y.distance(_,d);if(C=r.getClosestCoordinateOnInterval(d,f,-1),C===e[m]&&I===s[m]){x=1;break}_.assign(r.getCoord2D(C));const D=y.distance(d,_);if(!(D<P&&w<E)){x=0;break}if(D===0&&w===0){g(e[m],e[c],s[m],s[c])?(e[c]=C,s[c]=I,x=0):x=1;break}P=D,E=w}if(x===-1&&(x=qt(e[c],0,1)||qt(s[c],0,1)?0:1),x!==1)break;e[c]=e[m],s[c]=s[m]}}}function rs(r,t,e,s,i,n,o,a,h,m,l,u,c){if(!n)return 0;const g=(f,x)=>{for(let E=0;E<n;++E){let P=x[E];if(qt(P,0,1)){P=Zd(P);continue}const C=f.getCoord2D(P);P<.5?C.equals(f.getStartXY())&&so(f,0,P)<=si(f)&&(x[E]=0):C.equals(f.getEndXY())&&so(f,P,1)<=si(f)&&(x[E]=1)}};g(t,s),g(e,i),A1(t,e,s,i,n);const _=[];for(let f=0,x=n;f<x;f++)_.push(f);const d=(f,x)=>c?fl(i[f],s[f],i[x],s[x]):fl(s[f],i[f],s[x],i[x]);if(_.length>1){_.sort(d);const f=Math.max(si(t),si(e));let x=0;for(let E=1,P=_.length;E<P;E++){const C=s[_[x]],S=s[_[E]],I=i[_[x]],w=i[_[E]];if(C!==S||I!==w)if(!(so(t,C,S)<=f&&so(e,I,w)<=f)||qt(C,0,1)&&qt(I,0,1)||qt(S,0,1)&&qt(w,0,1))x++,_[x]=_[E];else{const D=y.distance(t.getCoord2D(C),e.getCoord2D(I)),N=y.distance(t.getCoord2D(S),e.getCoord2D(w));if(D<=N)continue;if(N<D){_[x]=_[E];continue}}}if(_.length=x+1,_.length===1&&_[0]!==0&&(s[0]=s[_[0]],i[0]=i[_[0]],_[0]=0),_.length>2){const E=z.constructEmpty(),P=z.constructEmpty();E.setCoords(s[_[0]],s[_.at(-1)]),P.setCoords(i[_[0]],i[_.at(-1)]);let C=!0;for(let S=1,I=_.length-1;S<I;S++)if(!E.containsCoordinate(s[_[S]])||!P.containsCoordinate(i[_[S]])){C=!1;break}if(C){const S=[.5,.2,.7,.1,.3,.4,.6,.8,.9];for(let I=0;I<S.length;I++){let w=Ct(E.vmin,E.vmax,S[I]);const D=t.getCoord2D(w);if(!e.isCloserThanDistance(D,P,m)){C=!1;break}w=Ct(P.vmin,P.vmax,S[I]);const N=e.getCoord2D(w);if(!t.isCloserThanDistance(N,E,m)){C=!1;break}}}C&&(_[1]=_.at(-1),_.length=2)}}if(_.length===1&&r&&Un(t,e,s[0],i[0],m,1,[0],[0])&&(_.push(1),s[1]=0,i[1]=0,_.sort(d)),l&&_.length===1){let f=!0;for(let x=0,E=_.length;x<E;x++)if(!(qt(s[_[x]],0,1)&&qt(i[_[x]],0,1)&&y.distance(t.getCoord2D(s[_[x]]),e.getCoord2D(i[_[x]]))===0)){f=!1;break}if(f)return 0}let p=0;for(let f=0,x=_.length;f<x;f++){if(a&&a.push(s[_[f]]),h&&h.push(i[_[f]]),o){const E=y.getNAN();t.queryCoord2D(s[_[f]],E),o.push(E)}p++}return p}function io(r,t,e,s,i,n,o,a,h){if(qt(e,0,1)&&qt(s,0,1)&&y.distance(r.getCoord2D(e),t.getCoord2D(s))===0){const l=new K,u=Number.EPSILON;if(r.queryDerivative(new L(e,u),l),l.isTrueZero()){const p=e===1?-1e-12:1e-12;r.queryDerivative(new L(e,u).add(p),l)}e===1&&l.negateThis();const c=new K;if(t.queryDerivative(new L(s,u),c),c.isTrueZero()){const p=e===1?-1e-12:1e-12;t.queryDerivative(new L(s,u).add(p),c)}s===1&&c.negateThis(),l.isZero()||l.normalize(),c.isZero()||c.normalize();const g=l.dotProduct(c),_=l.crossProduct(c);_.scaleError(3);const d=()=>{if(h)return .001;{const p=r.calculateUpperLength2D(),f=t.calculateUpperLength2D();return Math.min(.01*i/Math.min(p,f),1e-10)}};if(g.ge(qn)&&(_.isZero()||Math.abs(_.value())<d()))return ig(r,t,e,s,i,n,o,a)}return 0}function Vn(r,t,e,s,i){let n=-1,o=-1,a=-1,h=-1;{const m=[0,t],l=[t,0],u=[0,s],c=[s,0];for(let g=0;g<2&&n===-1;++g)for(let _=0;_<2;++_)if(r[m[g]].equals(e[u[_]])){n=m[g],o=l[g],a=u[_],h=c[_];break}}if(n===-1){const m=new ce;m.setFromPoints(r,t+1);const l=new ce;return l.setFromPoints(e,s+1),l.inflate(i),m.isIntersectingW(l)?-1:0}{const m=j(t+1,Number.NaN),l=Mh(r,t+1,m);b(l>1);let u=0,c=0;for(let w=0;w<l;++w)n===m[w]&&(c=w,u++),o===m[w]&&u++;if(u!==2)return-1;const g=j(s+1,Number.NaN),_=Mh(e,s+1,g);b(_>1),u=0;let d=0;for(let w=0;w<_;++w)a===g[w]&&(d=w,u++),h===g[w]&&u++;if(u!==2)return-1;const p=r[m[(c+l-1)%l]],f=r[m[(c+1)%l]],x=e[g[(d+_-1)%_]],E=e[g[(d+1)%_]],P=r[n],C=[p,f,x,E],S=[0,1,2,3];S.sort((w,D)=>y.compareVectorsOrigin(P,C[w],C[D]));let I=S[0];for(let w=1;w<4;w++){if(S[w]!==(I+1)%4)return-1;I=S[w]}{const w=p.sub(P),D=E.sub(P),N=D.dotProduct(w);if(N>0){const A=D.crossProduct(w),M=Math.abs(Math.atan2(A,N)),G=M*w.length(),q=M*D.length();if(G<=i||q<=i)return-1}}{const w=f.sub(P),D=x.sub(P),N=D.dotProduct(w);if(N>0){const A=D.crossProduct(w),M=Math.abs(Math.atan2(A,N)),G=M*w.length(),q=M*D.length();if(G<=i||q<=i)return-1}}return 1}}var no=Mt;let ht=class Po extends Bp{constructor(t){super(t||{XStart:0,YStart:0,XEnd:0,YEnd:0})}assignMove(t){return this!==t&&(this.m_description=t.m_description,t.m_description=null,this.m_attributes=t.m_attributes,t.m_attributes=null,this.m_XStart=t.m_XStart,t.m_XStart=Number.NaN,this.m_YStart=t.m_YStart,this.m_XEnd=t.m_XEnd,t.m_XEnd=Number.NaN,this.m_YEnd=t.m_YEnd),this}assignCopy(t){return this!==t&&t.copyTo(this),this}calculateLowerLength3D(){return b(0),0}calculateUpperLength3D(){return b(0),0}changeEndPoints3D(t,e){b(0)}getClosestCoordinate3D(t,e,s){return b(0),0}getBoundary(){return Gs(this)}getAttributeAsDbl(t,e,s){if(e===0)return s===0?$r(this,t):ka(this,t);const i=no.getInterpolation(e),n=this.getStartAttributeAsDbl(e,s),o=this.getEndAttributeAsDbl(e,s);return Fr(i,n,o,t,no.getDefaultValue(e))}constructFromCoords(t,e,s,i){this.dropAllAttributes(),this.setStartXYCoords(t,e),this.setEndXYCoords(s,i)}construct(t,e){this.dropAllAttributes(),this.setStartXY(t),this.setEndXY(e)}construct3D(t,e){b(0)}constructPoint(t,e){this.assignVertexDescription(t.getDescription()),this.mergeVertexDescription(e.getDescription()),this.setStart(t),this.setEnd(e)}getGeometryType(){return Po.type}queryEnvelope(t){if(t.m_EnvelopeType===4){t.setEmpty(),t.assignVertexDescription(this.m_description);const e=F.constructEmpty();this.queryEnvelope(e),t.setEnvelope(e);for(let s=1,i=this.m_description.getAttributeCount();s<i;s++){const n=this.m_description.getSemantics(s);for(let o=0,a=no.getComponentCount(n);s<a;s++){const h=this.queryInterval(n,o);t.setIntervalEnvelope(n,o,h)}}}else t.m_EnvelopeType===2?t.setCoords({xmin:this.m_XStart,ymin:this.m_YStart,xmax:this.m_XEnd,ymax:this.m_YEnd}):t.m_EnvelopeType===3?(t.setEmpty(),t.mergeCoords(this.m_XStart,this.m_YStart,As(this,0,1,0)),t.mergeCoords(this.m_XEnd,this.m_YEnd,As(this,1,1,0))):ft("env type not impl")}applyTransformation(t){b(t instanceof pt);const e=new y;e.x=this.m_XStart,e.y=this.m_YStart,t.transformInPlace(e),this.m_XStart=e.x,this.m_YStart=e.y,e.x=this.m_XEnd,e.y=this.m_YEnd,t.transformInPlace(e),this.m_XEnd=e.x,this.m_YEnd=e.y}createInstance(){return new Po({vd:this.m_description})}calculateLength2D(){return Math.sqrt(Ph(this))}calculateLength3D(t){return b(0),0}changeEndPoints2D(t,e){this.setStartXY(t),this.setEndXY(e),this.normalizeAfterEndpointChange()}queryControlPointsHelper(t){return b(t.length>=2),t[0]=this.getStartXY(),t[1]=this.getEndXY(),2}queryCoord2D(t,e){return Ue(this,t,e)}queryCoord3D(t,e){b(0)}getCoordZ(t){return Hp(this,t)}queryCoord2DE(t,e){og(this,t,e)}queryCoord2DMP(t,e){e.assignPoint2D(this.getStartXY());const s=Et.constructPoint2D(this.getEndXY());s.subThis(e),s.mulThis(J.constructDouble(t)),e.addThis(s)}getCoordX(t){return $r(this,t)}getCoordY(t){return ka(this,t)}cut(t,e,s){const i=new it;return this.queryCut(t,e,i,s),i.releaseSegment()}queryCut(t,e,s,i){const n=s.createLine();i&&n.assignVertexDescription(this.m_description);const o=y.getNAN();if(Ue(this,t,o),n.setStartXYCoords(o.x,o.y),Ue(this,e,o),n.setEndXYCoords(o.x,o.y),!i)for(let a=1,h=this.m_description.getAttributeCount();a<h;a++){const m=this.m_description.getSemantics(a),l=no.getComponentCount(m);for(let u=0;u<l;u++){const c=this.getAttributeAsDbl(t,m,u);n.setStartAttribute(m,u,c);const g=this.getAttributeAsDbl(e,m,u);n.setEndAttribute(m,u,g)}}}queryDerivative(t,e){zp(this,t,e)}getClosestCoordinate(t,e){return y.getClosestCoordinate(this.getStartXY(),this.getEndXY(),t,e)}getClosestCoordinateOnInterval(t,e,s=-1){const i=new y;this.queryCoord2D(e.vmin,i);const n=new y;this.queryCoord2D(e.vmax,n);const o=y.getClosestCoordinate(i,n,t,!1);return Xr.recalculateParentT(e.vmin,e.vmax,o)}intersectionOfYMonotonicWithAxisX(t,e){const s=this.m_YEnd-this.m_YStart;if(!s)return t===this.m_YEnd?e:Number.NaN;const i=(t-this.m_YStart)/s;let n=$r(this,i);return i===1&&(n=this.m_XEnd),n}isCurve(){return!1}isMonotoneQuickAndDirty(){return!0}isDegenerate(t){const e=this.m_XStart-this.m_XEnd,s=this.m_YStart-this.m_YEnd;return Math.sqrt(e*e+s*s)<=t}isDegenerate3D(t,e){return b(0),!1}queryLooseEnvelope(t){this.queryEnvelope(t)}clone(t){const e=new Po;return this.copyTo(e),e}tToLength(t){return t*this.calculateLength2D()}lengthToT(t){const e=this.calculateLength2D();return e!==0?t/e:0}calculateWeightedAreaCentroid2D(t){const e=new y;return e.setCoords(0,0),e}calculateWeightedCentroid2D(){return this.getCoord2D(.5).mul(this.calculateLength2D())}getTangent(t){const e=y.getNAN();return e.setSub(this.getEndXY(),this.getStartXY()),e}getDerivative(t){const e=new y;return e.setSub(this.getEndXY(),this.getStartXY()),e}getCurvature(t){return 0}isIntersectingPoint(t,e,s){return cn(this,t,e,s)>=0}isIntersectingPoint3D(t,e,s,i,n=1){return b(0),!1}getYMonotonicParts(t,e){return 0}getMonotonicParts(t,e){return 0}getMonotonicPartParams(t,e){return e&&(t<2&&H(""),e[0]=0,e[1]=1),2}intersectionWithAxis2D(t,e,s,i){if(t){const n=this.m_YEnd-this.m_YStart;if(!n)return e===this.m_YEnd?-1:0;const o=(e-this.m_YStart)/n;return o<0||o>1?0:(s&&(s[0]=$r(this,o)),i&&(i[0]=o),1)}{const n=this.m_XEnd-this.m_XStart;if(!n)return e===this.m_XEnd?-1:0;const o=(e-this.m_XStart)/n;return o<0||o>1?0:(s&&(s[0]=ka(this,o)),i&&(i[0]=o),1)}}calculateUpperLength2D(){return this.calculateLength2D()}calculateLowerLength2D(){return this.calculateLength2D()}normalizeAfterEndpointChange(){return!1}queryLooseEnvelopeOnInterval(t,e){if(e.m_EnvelopeType===2){let s=Nt(t.vmin,0,1);const i=new y;return this.queryCoord2D(s,i),e.setCoords({pt:i}),s=Nt(t.vmax,0,1),this.queryCoord2D(s,i),void e.mergeNe(i)}ft("3d dst not impl")}orientBottomUp(){ag(this)}isLine(){return!0}isDegenerateToLineHelper(t){return!0}copyIgnoreAttributes(t){t.setStartXY(this.getStartXY()),t.setEndXY(this.getEndXY()),t.normalizeAfterEndpointChange()}calculateArea2DHelper(){return 0}absNormXYZ(t){return Up(this,t)}absNorm(){return this.getStartXY().norm(1)+this.getEndXY().norm(1)}queryEnvelopeW(t,e){e.setCoords(this.getCoord2D(t.vmin)),e.mergeNe(this.getCoord2D(t.vmax))}setSegmentFromCoordsForStitcher(t,e){Yl(this,t[0],t[e-1])}writeInBufferStream(t,e){return b(0),0}readFromBufferStream(t,e){b(0)}snapControlPoints(t){return!1}needsSnapControlPoints(t){return!1}calculateSpecialPointsForCracking(t,e){return 0}ensureXYMonotone(){return!1}setCoordsForIntersector(t,e,s){Yl(this,t,e)}static isIntersectingLineLine(t,e,s,i){return yh(t,e,s,i)}static isIntersectingLineLine_(t,e,s,i){return yh(t,e,s,i)}copyToImpl(t){}reverseImpl(){}equalsImpl(t){return!0}equalsImplTol(t,e){return!0}swapImpl(t){}afterCompletedModification(){}endPointModified(){}clearEndPointModified(){}intersect(t,e,s,i,n){return en(!1,this,t,e,s,i,n)}intersectPoint(t,e,s){e.length<1&&ut("");const i=cn(this,t,s,!1);return i>=0?(e&&(e[0]=i),1):0}isIntersecting(t,e,s){return Gn(!1,this,t,e,s)!==0}};ht.type=T.enumLine;let it=class Co{constructor(t){this.m_seg=null,this.m_curves=null,this.m_lineBuffer=new ht,this.m_mask=0,this.m_active=0,t!==void 0&&(t.copy?t.copy.copyTo(this,!1):t.move?this.assignMove(t.move):t.segment?this.copyFrom(t.segment,!!t.bIgnoreAttributes):$("bad constructor params"))}assignCopy(t){return t instanceof Co?this!==t&&t.copyTo(this,!1):this.copyFrom(t,!1),this}assignMove(t){if(t instanceof Co){if(this===t)return this;this.reset(),1&t.m_mask&&(this.m_lineBuffer=t.m_lineBuffer,t.m_lineBuffer=null,this.m_mask=1),this.m_curves=t.m_curves,this.m_mask=t.m_mask,this.m_active=t.m_active,t.reset(),this.m_seg=this.activeSegment(),t.m_seg=null}else{if(this.m_seg===t)return this;this.create(t.getGeometryType()),this.m_seg.swap(t)}return this}activeSegment(){switch(this.m_active){case 0:return null;case 1:return this.line();case 2:return this.arc();case 4:return this.bezier3();case 8:return this.bezier2();case 16:return this.rbezier2();default:$("")}}get(){return this.m_seg}reset(){1&this.m_mask&&(this.m_lineBuffer=null),this.m_mask>1&&(this.m_curves=null),this.m_mask=0,this.m_active=0}empty(){return this.m_seg===null}copyTo(t,e){this!==t&&(this.empty()?t.m_seg=null:t.copyFrom(this.m_seg,e))}copyToWithZ(t,e){b(0)}createImpl(t){switch(t){case T.enumLine:1&this.m_mask||(this.m_lineBuffer=new ht,this.m_mask|=1,this.m_active=1);break;case T.enumEllipticArc:2&this.m_mask||(this.m_curves=new Xs,this.m_mask=1&this.m_mask|2,this.m_active=2);break;case T.enumBezier:4&this.m_mask||(this.m_curves=new ws,this.m_mask=1&this.m_mask|4,this.m_active=4);break;case T.enumBezier2:8&this.m_mask||(this.m_curves=new Oi,this.m_mask=1&this.m_mask|8,this.m_active=8);break;case T.enumRationalBezier2:16&this.m_mask||(this.m_curves=new Ge,this.m_mask=1&this.m_mask|16,this.m_active=16);break;default:H("")}}create(t){t===T.enumLine?this.createLine():t===T.enumEllipticArc?this.createEllipticArc():t===T.enumBezier?this.createCubicBezier():t===T.enumRationalBezier2?this.createQuadraticRationalBezier():t===T.enumBezier2?this.createQuadraticBezier():H("Segment_buffer.create")}copyFrom(t,e){this.m_seg!==t&&(this.create(t.getGeometryType()),e?t.copyIgnoreAttributes(this.m_seg):t.copyTo(this.m_seg))}copyFromWithZ(t,e){b(0)}line(){return this.m_lineBuffer}arc(){return this.m_curves}bezier3(){return this.m_curves}bezier2(){return this.m_curves}rbezier2(){return this.m_curves}createLine(){return this.createImpl(T.enumLine),this.m_seg=this.line(),this.line()}createEllipticArc(){return this.createImpl(T.enumEllipticArc),this.m_seg=this.arc(),this.arc()}createCubicBezier(){return this.createImpl(T.enumBezier),this.m_seg=this.bezier3(),this.bezier3()}createQuadraticRationalBezier(){return this.createImpl(T.enumRationalBezier2),this.m_seg=this.rbezier2(),this.rbezier2()}createQuadraticBezier(){return this.createImpl(T.enumBezier2),this.m_seg=this.bezier2(),this.bezier2()}releaseSegment(){if(this.m_seg=null,this.m_active===0&&$("releaseSegment"),1&this.m_active){const e=this.line();return this.m_mask-=1,this.m_active=0,this.m_lineBuffer=null,e}let t;return 2&this.m_active?t=this.arc():4&this.m_active?t=this.bezier3():8&this.m_active?t=this.bezier2():16&this.m_active?t=this.rbezier2():$("releaseSegment"),this.m_mask-=this.m_active,this.m_active=0,this.m_curves=null,t}equals(t){return t instanceof Co?this===t||(this.empty()?t.empty():!t.empty()&&this.get().equals(t.get())):(ft("seg comparison not yet impl"),!1)}};function Dt(r,t,e,s,i){return r_(r,t,null,e,s,i)}function r_(r,t,e,s,i,n){const o=r.getGeometryType();if(o===T.enumPoint){const l=r.getXY();return t.contains(l)?r:r.createInstance()}if(o===T.enumEnvelope){const l=F.constructEmpty();if(r.queryEnvelope(l),l.intersect(t)){const u=r.clone();return u.setEnvelope(l),u}return r.createInstance()}if(r.isEmpty())return r;if(t.isEmpty())return r.createInstance();const a=t.clone();{const l=new F;if(r.queryLooseEnvelope(l),a.containsEnvelope(l))return r;if(!a.isIntersecting(l))return r.createInstance();i===0&&(l.intersect(a),l.inflate(Math.max(.1*l.maxDimension(),1)),l.intersect(a),a.assign(l))}let h=s;if((e!==null||Number.isNaN(h))&&(h=re(e,a,!1).total()),o===T.enumGeometryCollection){const l=r,u=r.createInstance();for(let c=0,g=l.getGeometryCount();c<g;c++){const _=l.getGeometry(c);if(_.isEmpty())continue;const d=Dt(_,a,h,i,n);d.isEmpty()||(d===_?u.addGeometry(d.clone()):u.addGeometry(d))}return u}We(o)||H("Clip: geometry not supported");const m=r.getImpl().getAccelerators();if(m!==null){const l=m.getRasterizedGeometry();b(l===null)}switch(o){case T.enumMultiPoint:{const l=r;let u;const c=l.getPointCount(),g=l.getImpl().getAttributeStreamRef(0);let _=0;for(let d=0;d<c;d++){const p=g.readPoint2D(2*d);a.contains(p)||(_===0&&(u=l.createInstance()),_<d&&u.addPoints(l,_,d),_=d+1)}return _>0&&u.addPoints(l,_,c),_===0?l:(b(u!==null),u)}case T.enumPolygon:case T.enumPolyline:return F1(r,a,h,i,n);default:$("")}}function q1(r,t,e,s,i,n){const o=new ms(t,n),a=new F;return r.queryLooseEnvelope(a),t.containsEnvelope(a)?r:t.isIntersecting(a)?o.clipPolesOut(r,i):r.createInstance()}function F1(r,t,e,s,i){return new ms(t,i).clipMultiPath2(r,e,s)}class ms{constructor(t,e){this.m_shape=new Lt,this.m_geometry=v,this.m_verticesOnExtentIndex=-1,this.m_verticesOnExtent=[],this.m_progressCounter=0,this.m_extent=new F(t),this.m_progressTracker=e}progress_(){}clipMultiPath2(t,e,s){return t.getGeometryType()===T.enumPolygon?this.clipPolygonOrProjectedPolyline2(t,s):this.clipPolyline(t,e)}clipPolygonOrProjectedPolyline2(t,e){const s=t.getGeometryType()===T.enumPolyline;if(this.m_extent.width()===0||this.m_extent.height()===0)return t.createInstance();const i=F.constructEmpty();t.queryLooseEnvelope(i),this.m_geometry=s?this.m_shape.addGeometry(t):this.m_shape.addGeometry(t,this.m_extent);const n=F.constructEmpty(),o=F.constructEmpty(),a=new y,h=new y,m=j(9,Number.NaN),l=j(9,Number.NaN),u=R(y,9);let c=null;const g=new ht,_=[];let d=!1;for(let f=0;!d&&f<4;f++){let x=!1;const E=!!(1&f);let P=0;switch(f){case 0:P=this.m_extent.xmin,x=i.xmin<=P&&i.xmax>=P;break;case 1:P=this.m_extent.ymin,x=i.ymin<=P&&i.ymax>=P;break;case 2:P=this.m_extent.xmax,x=i.xmin<=P&&i.xmax>=P;break;case 3:P=this.m_extent.ymax,x=i.ymin<=P&&i.ymax>=P}if(x){d=!0;for(let C=this.m_shape.getFirstPath(this.m_geometry);C!==v;){let S=!0,I=-1,w=-1;const D=this.m_shape.getFirstVertex(C);let N=D;do{this.progress_(),c=this.m_shape.getSegment(N);let A=c;if(A===null){const V=this.m_shape.getNextVertex(N);if(V===v){b(s),I===0&&_.push(N);break}this.m_shape.queryXY(N,a),g.setStartXY(a),this.m_shape.queryXY(V,h),g.setEndXY(h),A=g}A.queryLooseEnvelope(n);let M=ms.checkSegmentIntersection(n,f,P);A.isCurve()&&M===0&&A.isCurve()&&(g.setStartXY(A.getStartXY()),g.setEndXY(A.getEndXY()),this.m_shape.replaceCurveWithLine(N),A=g,g.queryEnvelope(n),M=ms.checkSegmentIntersection(n,f,P));let G=0,q=v;if(M===-1){const V=A.intersectionWithAxis2D(E,P,m,l);if(V>0){let U=null;if(A.isCurve()){U=u,b(V<=9);for(let X=0;X<V;X++)E?u[X].setCoords(m[X],P):u[X].setCoords(P,m[X]);G=this.m_shape.splitSegmentAxisAware(N,l,V,U,E?1:0)}else G=this.m_shape.splitSegmentAxisAware(N,l,V,null,-1)}else G=0;G+=1;let k=N,Y=this.m_shape.getNextVertex(k);A=null;for(let U=0;U<G;U++){this.m_shape.queryXY(k,a),this.m_shape.queryXY(Y,h),c=this.m_shape.getSegment(k);let X=c;X===null&&(g.setStartXY(a),g.setEndXY(h),X=g),X.queryEnvelope(o);let B=ms.checkSegmentIntersection(o,f,P);X.isCurve()&&B===0&&(this.m_shape.replaceCurveWithLine(k),g.setStartXY(a),g.setEndXY(h),X=g,X.queryEnvelope(o),B=ms.checkSegmentIntersection(o,f,P)),B===-1&&(E?Math.abs(a.y-P)<Math.abs(h.y-P)?(a.y=P,this.m_shape.setXY(k,a)):(h.y=P,this.m_shape.setXY(Y,h)):Math.abs(a.x-P)<Math.abs(h.x-P)?(a.x=P,this.m_shape.setXY(k,a)):(h.x=P,this.m_shape.setXY(Y,h)),c=this.m_shape.getSegment(k),X=c,X===null&&(g.setStartXY(a),g.setEndXY(h),X=g),X.queryEnvelope(o),B=ms.checkSegmentIntersection(o,f,P),B===-1&&(B=ms.checkSegmentIntersectionLoose(o,f,P)));const W=I;I=B,w===-1&&(w=I),W===0&&I===1||W===1&&I===0||W===0&&I===0&&_.push(k),I===1&&(d=!1,S=!1),k=Y,q=k,Y=this.m_shape.getNextVertex(Y)}}if(G===0){const V=I;I=M,w===-1&&(w=I),V===0&&I>=1||V>=1&&I===0||V===0&&I===0&&_.push(N),I===1&&(d=!1,S=!1),q=this.m_shape.getNextVertex(N)}if(N=q,_.length>=256){for(let V=1,k=_.length-1;V<k;V++){const Y=_[V];s?this.m_shape.snapVertexForPoleClipping(Y,P):this.m_shape.removeVertex(Y,!1)}_[1]=_.at(-1),_.length=2}}while(N!==D);if(!S){w!==0||!s&&I!==0&&I!==2||_.push(D);for(let A=0,M=_.length;A<M;A++){const G=_[A];s?this.m_shape.snapVertexForPoleClipping(G,P):this.m_shape.removeVertex(G,!1)}}_.length=0,C=S||this.m_shape.getPathSize(C)===0?this.m_shape.removePath(C):this.m_shape.getNextPath(C)}}}if(d)return t.createInstance();c=null,s?this.removeSpikesAlongPoles():this.resolveBoundaryOverlaps(),e>0&&this.densifyAlongClipExtent(e);const p=this.m_shape.getGeometry(this.m_geometry);return p.getGeometryType()===T.enumPolygon&&p.setFillRule(t.getFillRule()),p}clipPolyline(t,e){const s=F.constructEmpty(),i=F.constructEmpty(),n=j(9,Number.NaN),o=j(9,Number.NaN),a=new it;let h=t;const m=F.constructEmpty();t.queryLooseEnvelope(m);for(let l=0;l<4;l++){let u=!1;const c=!!(1&l);let g=0;switch(l){case 0:g=this.m_extent.xmin,u=m.xmin<=g&&m.xmax>=g;break;case 1:g=this.m_extent.ymin,u=m.ymin<=g&&m.ymax>=g;break;case 2:g=this.m_extent.xmax,u=m.xmin<=g&&m.xmax>=g;break;case 3:g=this.m_extent.ymax,u=m.ymin<=g&&m.ymax>=g}if(!u)continue;const _=h;h=t.createInstance();const d=_.getImpl().querySegmentIterator();d.resetToFirstPath();const p=new y,f=new y;for(;d.nextPath();){let x=-1,E=!0;for(;d.hasNextSegment();){this.progress_();const P=d.nextSegment(),C=P.isDegenerate(0);P.queryLooseEnvelope(s);const S=ms.checkSegmentIntersection(s,l,g);if(S===-1){const I=P.intersectionWithAxis2D(c,g,n,o);let w=0;p.assign(P.getStartXY());for(let D=0;D<=I;D++){const N=D<I?o[D]:1;if(w===N)continue;P.queryCut(w,N,a,!1);const A=a.get();let M=!1;if(A.getStartXY().equals(p)||(A.setStartXY(p),M=!0),D<I&&(c?(f.x=n[D],f.y=g):(f.x=g,f.y=n[D]),A.getEndXY().equals(f)||(A.setEndXY(f),M=!0)),M&&A.normalizeAfterEndpointChange(),!C&&A.isDegenerate(0))continue;A.queryEnvelope(i);let G=ms.checkSegmentIntersection(i,l,g);if(G===-1){const q=A.getStartXY(),V=A.getEndXY();M=!1,c?Math.abs(q.y-g)<Math.abs(V.y-g)?(q.y=g,A.setStartXY(q),q.equals(A.getStartXY())||(A.setStartXY(q),M=!0)):(V.y=g,V.equals(A.getEndXY())||(A.setEndXY(V),M=!0)):Math.abs(q.x-g)<Math.abs(V.x-g)?(q.x=g,q.equals(A.getStartXY())||(A.setStartXY(q),M=!0)):(V.x=g,V.equals(A.getEndXY())||(A.setEndXY(V),M=!0)),M&&A.normalizeAfterEndpointChange(),A.queryEnvelope(i),G=ms.checkSegmentIntersection(i,l,g),G===-1&&(G=ms.checkSegmentIntersectionLoose(i,l,g))}p.assign(A.getEndXY()),w=N,x=G,x>=1?(h.addSegment(A,E),E=!1):E=!0}}else x=S,x>=1?(h.addSegment(P,E),E=!1):E=!0}}}return h}static checkSegmentIntersection(t,e,s){switch(e){case 0:return t.xmin<s&&t.xmax<=s?0:t.xmin>=s?t.xmax===s?2:1:-1;case 1:return t.ymin<s&&t.ymax<=s?0:t.ymin>=s?t.ymax===s?2:1:-1;case 2:return t.xmin>=s&&t.xmax>s?0:t.xmax<=s?t.xmin===s?2:1:-1;case 3:return t.ymin>=s&&t.ymax>s?0:t.ymax<=s?t.ymin===s?2:1:-1}return $(""),0}static checkSegmentIntersectionLoose(t,e,s){switch(e){case 0:{const i=Math.abs(t.xmin-s),n=Math.abs(t.xmax-s);return t.xmin<s?i>n?0:1:($(""),1)}case 1:{const i=Math.abs(t.ymin-s),n=Math.abs(t.ymax-s);return t.ymin<s?i>n?0:1:($(""),1)}case 2:{const i=Math.abs(t.xmin-s),n=Math.abs(t.xmax-s);return t.xmax>s?i<n?0:1:($(""),1)}case 3:{const i=Math.abs(t.ymin-s),n=Math.abs(t.ymax-s);return t.ymax>s?i<n?0:1:($(""),1)}}return $(""),0}resolveBoundaryOverlaps(){this.m_verticesOnExtentIndex=-1,this.splitSegments(!1,this.m_extent.xmin),this.splitSegments(!1,this.m_extent.xmax),this.splitSegments(!0,this.m_extent.ymin),this.splitSegments(!0,this.m_extent.ymax),this.m_verticesOnExtent.length=0,this.m_verticesOnExtentIndex=this.m_shape.createUserIndex();const t=new y;for(let e=this.m_shape.getFirstPath(this.m_geometry);e!==v;e=this.m_shape.getNextPath(e)){let s=this.m_shape.getFirstVertex(e);for(let i=0,n=this.m_shape.getPathSize(e);i<n;i++,s=this.m_shape.getNextVertex(s))this.progress_(),this.m_shape.queryXY(s,t),this.m_extent.xmin!==t.x&&this.m_extent.xmax!==t.x&&this.m_extent.ymin!==t.y&&this.m_extent.ymax!==t.y||(this.m_shape.setUserIndex(s,this.m_verticesOnExtentIndex,this.m_verticesOnExtent.length),this.m_verticesOnExtent.push(s))}this.dbgCheckPathFirst(),this.resolveOverlaps(!1,this.m_extent.xmin),this.dbgCheckPathFirst(),this.resolveOverlaps(!1,this.m_extent.xmax),this.dbgCheckPathFirst(),this.resolveOverlaps(!0,this.m_extent.ymin),this.dbgCheckPathFirst(),this.resolveOverlaps(!0,this.m_extent.ymax),this.fixPaths()}densifyAlongClipExtent(t){const e=new y(0,0),s=new y(0,0),i=j(2048,Number.NaN);for(let n=this.m_shape.getFirstPath(this.m_geometry);n!==v;n=this.m_shape.getNextPath(n)){const o=this.m_shape.getFirstVertex(n);let a=o;do{const h=this.m_shape.getNextVertex(a);this.m_shape.queryXY(a,e);let m=-1;if(e.x===this.m_extent.xmin?(this.m_shape.queryXY(h,s),s.x===this.m_extent.xmin&&(m=1)):e.x===this.m_extent.xmax&&(this.m_shape.queryXY(h,s),s.x===this.m_extent.xmax&&(m=1)),e.y===this.m_extent.ymin?(this.m_shape.queryXY(h,s),s.y===this.m_extent.ymin&&(m=0)):e.y===this.m_extent.ymax&&(this.m_shape.queryXY(h,s),s.y===this.m_extent.ymax&&(m=0)),m===-1){a=h;continue}if(this.isCurve(a)){a=h;continue}const l=e.clone(),u=new y(0,0);if(m){const _=e.y-this.m_extent.ymin;u.y=kt(s.y-e.y),l.y=t*ri(Math.floor(Math.abs(_)/t),_)+this.m_extent.ymin,u.y<0&&(l.y+=t)}else{const _=e.x-this.m_extent.xmin;u.x=kt(s.x-e.x),l.x=t*ri(Math.floor(Math.abs(_)/t),_)+this.m_extent.xmin,u.x<0&&(l.x+=t)}const c=m?s.y-e.y:s.x-e.x,g=Math.abs(c);if(g/t>65536&&$(""),g>0){const _=Math.trunc(g/t)+2;i.length<_&&(i.length=_);let d=0;for(let p=0;;p++){const f=l.add(u.mul(p*t)),x=(m?f.y-e.y:f.x-e.x)/c;if(x>=1)break;x<=0||(b(d<=i.length),i[d]=x,d++)}d!==0&&this.m_shape.splitSegment(a,i,d)}a=h}while(a!==o)}}splitSegments(t,e){let s=-1;const i=new y,n=[];for(let _=this.m_shape.getFirstPath(this.m_geometry);_!==v;_=this.m_shape.getNextPath(_)){let d=this.m_shape.getFirstVertex(_),p=v;for(let f=0,x=this.m_shape.getPathSize(_);f<x;f++,d=p)if(this.progress_(),p=this.m_shape.getNextVertex(d),this.m_shape.queryXY(d,i),(t?i.y===e:i.x===e)&&(this.m_shape.queryXY(p,i),t?i.y===e:i.x===e)){if(this.isCurve(d))continue;s===-1&&(s=this.m_shape.createUserIndex()),this.m_shape.getUserIndex(d,s)!==1&&(n.push(d),this.m_shape.setUserIndex(d,s,1)),this.m_shape.getUserIndex(p,s)!==1&&(n.push(p),this.m_shape.setUserIndex(p,s,1))}}if(s!==-1&&this.m_shape.removeUserIndex(s),n.length<3)return;n.sort((_,d)=>this.compareVertices(_,d));const o=new y,a=new y,h=new y;a.setNAN();let m=-1,l=[],u=[];const c=this.m_shape.createUserIndex(),g=this.m_shape.createUserIndex();for(let _=0,d=n.length;_<d;_++){const p=n[_];if(this.m_shape.queryXY(p,i),!i.isEqualPoint2D(a)){if(m===-1){m=_,a.setCoordsPoint2D(i);continue}for(let x=m;x<_;x++){const E=n[x],P=this.m_shape.getNextVertex(E),C=this.m_shape.getPrevVertex(E);let S=!1;this.m_shape.queryXY(P,o),a.compare(o)<0&&(t?o.y===e:o.x===e)&&(this.isCurve(E)||(l.push(E),S=!0,this.m_shape.setUserIndex(E,g,1))),this.m_shape.queryXY(C,o),a.compare(o)<0&&(t?o.y===e:o.x===e)&&(this.isCurve(C)||(S||l.push(E),this.m_shape.setUserIndex(E,c,1)))}for(let x=0,E=l.length;x<E;x++){const P=l[x],C=this.m_shape.getUserIndex(P,c),S=this.m_shape.getUserIndex(P,g);if(C===1){const I=this.m_shape.getPrevVertex(P);this.m_shape.queryXY(I,h);let w=0;if(!h.isEqualPoint2D(i)){const D=y.distance(a,h);w=y.distance(h,i)/D,w===0?w=Number.EPSILON:w===1&&(w=1-Number.EPSILON),this.m_shape.splitSegment(I,[w],1);const N=this.m_shape.getPrevVertex(P);this.m_shape.setXY(N,i),u.push(N),this.m_shape.setUserIndex(N,c,1),this.m_shape.setUserIndex(N,g,-1)}}if(S===1){const I=this.m_shape.getNextVertex(P);this.m_shape.queryXY(I,h);let w=0;if(!h.isEqualPoint2D(i)){const D=y.distance(a,h);w=y.distance(a,i)/D,w===0?w=Number.EPSILON:w===1&&(w=1-Number.EPSILON),this.m_shape.splitSegment(P,[w],1);const N=this.m_shape.getNextVertex(P);this.m_shape.setXY(N,i),u.push(N),this.m_shape.setUserIndex(N,c,-1),this.m_shape.setUserIndex(N,g,1)}}}const f=l;l=u,u=f,u.length=0,m=_,a.setCoordsPoint2D(i)}}this.m_shape.removeUserIndex(c),this.m_shape.removeUserIndex(g)}resolveOverlaps(t,e){const s=new y,i=[];let n=-1;for(let m=0,l=this.m_verticesOnExtent.length;m<l;m++){this.progress_();const u=this.m_verticesOnExtent[m];if(u===v)continue;const c=this.m_shape.getNextVertex(u);if(this.m_shape.queryXY(u,s),(t?s.y===e:s.x===e)&&(this.m_shape.queryXY(c,s),t?s.y===e:s.x===e)){if(this.isCurve(u))continue;n===-1&&(n=this.m_shape.createUserIndex()),this.m_shape.getUserIndex(u,n)!==-2&&(i.push(u),this.m_shape.setUserIndex(u,n,-2)),this.m_shape.getUserIndex(c,n)!==-2&&(i.push(c),this.m_shape.setUserIndex(c,n,-2))}}if(i.length===0)return void(n!==-1&&this.m_shape.removeUserIndex(n));b(n!==-1),i.sort((m,l)=>this.compareVertices(m,l));for(let m=0,l=i.length;m<l;m++){const u=i[m];this.m_shape.setUserIndex(u,n,m)}const o=new y,a=new y;a.setNAN();let h=-1;for(let m=0,l=i.length;m<l;m++){this.progress_();const u=i[m];if(u!==v&&(this.m_shape.queryXY(u,s),!s.isEqualPoint2D(a))){if(h!==-1)for(;;){let c=!1;const g=m;for(let _=h;_<g;_++){const d=i[_];if(d===v)continue;let p=v;const f=this.m_shape.getNextVertex(d);this.m_shape.queryXY(f,o),a.compare(o)<0&&(t?o.y===e:o.x===e)&&(this.isCurve(d)||(p=f));let x=v;const E=this.m_shape.getPrevVertex(d);if(this.m_shape.queryXY(E,o),a.compare(o)<0&&(t?o.y===e:o.x===e)&&(this.isCurve(E)||(x=E)),p===v||x===v){if(p!==v||x!==v){for(let P=_+1;P<m;P++){const C=i[P];if(C===v)continue;const S=this.m_shape.getNextVertex(C);let I=v;this.m_shape.queryXY(S,o),a.compare(o)<0&&(t?o.y===e:o.x===e)&&(this.isCurve(C)||(I=S));const w=this.m_shape.getPrevVertex(C);let D=v;if(this.m_shape.queryXY(w,o),a.compare(o)<0&&(t?o.y===e:o.x===e)&&(this.isCurve(w)||(D=w)),I!==v&&D!==v){this.beforeRemoveVertex(C,i,n),this.m_shape.removeVertex(C,!1),this.beforeRemoveVertex(I,i,n),this.m_shape.removeVertex(I,!1),c=!0;break}if(p!==v&&D!==v){this.removeOverlap(i,d,p,C,D,n),c=!0;break}if(x!==v&&I!==v){this.removeOverlap(i,C,I,d,x,n),c=!0;break}}if(c)break}}else this.beforeRemoveVertex(d,i,n),this.m_shape.removeVertex(d,!1),this.beforeRemoveVertex(p,i,n),this.m_shape.removeVertex(p,!1),c=!0}if(!c)break}h=m,a.setCoordsPoint2D(s)}}this.m_shape.removeUserIndex(n)}beforeRemoveVertex(t,e,s){let i=this.m_shape.getUserIndex(t,s);b(i>=0),e[i]=v,i=this.m_shape.getUserIndex(t,this.m_verticesOnExtentIndex),b(i>=0),this.m_verticesOnExtent[i]=v;const n=this.m_shape.getPathFromVertex(t);n!==v&&this.m_shape.getFirstVertex(n)===t&&(this.m_shape.setFirstVertex(n,v),this.m_shape.setLastVertex(n,v))}removeOverlap(t,e,s,i,n,o){this.m_shape.setNextVertex(e,i),this.m_shape.setPrevVertex(i,e),this.m_shape.setPrevVertex(s,n),this.m_shape.setNextVertex(n,s),this.beforeRemoveVertex(i,t,o),this.m_shape.removeVertexInternal(i,!1),this.beforeRemoveVertex(n,t,o),this.m_shape.removeVertexInternal(n,!0)}removeSpikesAlongPoles(){this.removeSpikesOnPole(this.m_extent.ymin),this.removeSpikesOnPole(this.m_extent.ymax)}removeSpikesOnPole(t){for(let e=this.m_shape.getFirstPath(this.m_geometry);e!==v;e=this.m_shape.getNextPath(e)){const s=this.m_shape.getPathSize(e);if(s<3)continue;let i=this.m_shape.getFirstVertex(e);const n=new y;this.m_shape.queryXY(i,n);let o=n.y===t&&!this.isCurve(i);i=this.m_shape.getNextVertex(i);const a=new y;this.m_shape.queryXY(i,a);let h=a.y===t&&!this.isCurve(i);i=this.m_shape.getNextVertex(i);const m=new y;for(let l=0,u=s-2;l<u;l++,i=this.m_shape.getNextVertex(i)){this.progress_(),this.m_shape.queryXY(i,m);const c=m.y===t;if(h&&o&&c&&(a.x-n.x)*(m.x-a.x)<=0){this.m_shape.removeVertex(this.m_shape.getPrevVertex(i),!1),a.setCoordsPoint2D(m),h=c&&!this.isCurve(i);continue}n.setCoordsPoint2D(a),o=h,a.setCoordsPoint2D(m),h=c&&!this.isCurve(i)}}}fixPaths(){for(let n=0,o=this.m_verticesOnExtent.length;n<o;n++){const a=this.m_verticesOnExtent[n];a!==v&&this.m_shape.setPathToVertex(a,v)}const t=this.m_shape.hasCurves();let e=0,s=0;for(let n=this.m_shape.getFirstPath(this.m_geometry);n!==v;){const o=this.m_shape.getFirstVertex(n);if(o===v||n!==this.m_shape.getPathFromVertex(o)){const m=n;n=this.m_shape.getNextPath(n),this.m_shape.setFirstVertex(m,v),this.m_shape.removePathOnly(m);continue}let a=o,h=0;do this.m_shape.setPathToVertex(a,n),h++,a=this.m_shape.getNextVertex(a);while(a!==o);this.m_shape.setRingAreaValid(n,!1),this.m_shape.setLastVertex(n,this.m_shape.getPrevVertex(o)),this.m_shape.setPathSize(n,h),s+=h,e++,n=this.m_shape.getNextPath(n)}for(let n=0,o=this.m_verticesOnExtent.length;n<o;n++){let a=this.m_verticesOnExtent[n];if(a===v)continue;let h=this.m_shape.getPathFromVertex(a);if(h!==v)continue;h=this.m_shape.insertPath(this.m_geometry,v);let m=!1,l=0;const u=a;do this.m_shape.setPathToVertex(a,h),l++,t&&l<=2&&(m||=this.isCurve(a)),a=this.m_shape.getNextVertex(a);while(a!==u);if(m?l===0:l<=2){let c=this.m_shape.getUserIndex(u,this.m_verticesOnExtentIndex);b(c>=0),this.m_verticesOnExtent[c]=v;const g=this.m_shape.removeVertex(u,!1);l===2&&(c=this.m_shape.getUserIndex(g,this.m_verticesOnExtentIndex),c>=0&&(this.m_verticesOnExtent[c]=v),this.m_shape.removeVertex(g,!1));const _=h;h=this.m_shape.getNextPath(h),this.m_shape.setFirstVertex(_,v),this.m_shape.removePathOnly(_)}else this.m_shape.setClosedPath(h,!0),this.m_shape.setPathSize(h,l),this.m_shape.setFirstVertex(h,u),this.m_shape.setLastVertex(h,this.m_shape.getPrevVertex(u)),this.m_shape.setRingAreaValid(h,!1),s+=l,e++}this.m_shape.setGeometryPathCount(this.m_geometry,e),this.m_shape.setGeometryVertexCount(this.m_geometry,s);let i=0;for(let n=this.m_shape.getFirstGeometry();n!==v;n=this.m_shape.getNextGeometry(n))i+=this.m_shape.getPointCount(n);this.m_shape.setTotalPointCount(i)}dbgCheckPathFirst(){}isCurve(t){return this.m_shape.getSegment(t)!==null}compareVertices(t,e){const s=new y;this.m_shape.queryXY(t,s);const i=new y;return this.m_shape.queryXY(e,i),s.compare(i)}clipPolesOut(t,e){return this.clipPolygonOrProjectedPolyline2(t,e)}}class wn{getOperatorType(){return 10004}supportsCurves(){return!0}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,s,i){return new M1(t,e,s,i)}execute(t,e,s,i){return G1(t,e,s,i)}}class M1 extends mi{constructor(t,e,s,i){super(),this.m_progressTracker=i,this.m_index=-1,t||H(""),this.m_envelope=e,this.m_inputGeometryCursor=t,this.m_spatialRefImpl=s,this.m_tolerance=re(s,e,!1).total()}next(){let t;return(t=this.m_inputGeometryCursor.next())?(ni(t),this.m_index=this.m_inputGeometryCursor.getGeometryID(),Dt(t,this.m_envelope,this.m_tolerance,0,this.m_progressTracker)):null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}function G1(r,t,e,s){return r_(r,t,e,Number.NaN,0,s)}var V1=Rm;class Y1 extends mi{constructor(t,e,s,i,n,o){super(),this.m_densificator=new V1(e,s,i,o,!1,n),this.m_index=-1,this.m_inputGeoms=t}tock(){return!0}getRank(){return 1}next(){let t=null;for(;t=this.m_inputGeoms.next();)return ni(t),this.m_index=this.m_inputGeoms.getGeometryID(),this.densify(t);return null}getGeometryID(){return this.m_index}densify(t){return this.m_densificator.densify(t)}}class Fi{getOperatorType(){return 10202}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}executeMany(t,e,s,i,n,o=12e3){return new Y1(t,e,s,i,o,n)}execute(t,e,s,i,n,o=12e3){return l1(t,e,s,i,n,o)}}class Ir{constructor(t){if(this.m_geom=this.m_sr=null,t){if(t.move)return this.m_geom=t.move.m_geom,t.move.m_geom=null,this.m_sr=t.move.m_sr,void(t.move.m_sr=null);if(t.copy)return this.m_geom=t.copy.m_geom?t.copy.m_geom.clone():null,void(this.m_sr=t.copy.m_sr);t.geom&&(this.m_geom=t.geom),t.sr&&(this.m_sr=t.sr)}}getGeometry(){return this.m_geom}getSpatialReference(){return this.m_sr}setGeometry(t){this.m_geom=t}setSpatialReference(t){this.m_sr=t}equals(t,e){const s=t;return!(!this.m_sr&&s.m_sr)&&!(this.m_sr&&!s.m_sr)&&!(!this.m_geom&&s.m_geom)&&!(this.m_geom&&!s.m_geom)&&!(this.m_sr&&s.m_sr&&!this.m_sr.equals(s.m_sr))&&!(this.m_geom&&s.m_geom&&!this.m_geom.equals(s.m_geom,e))}clone(){let t=null;return this.m_geom&&(t=this.m_geom.clone()),new Ir({geom:t,sr:this.m_sr})}hasGeom(){return!!this.m_geom}}class o_{constructor(t){this.m_factor=1,this.m_wkid=0,this.m_peUnit=null,t&&(this.m_peUnit=t,this.m_factor=t.getUnitFactor(),this.m_wkid=t.getCode(),this.m_wkid<0&&(this.m_wkid=0))}getName(){return this.m_peUnit?this.m_peUnit.getName():""}getID(){return this.m_wkid}getConversionFactor(t){return this.getUnitType()!==t.getUnitType()&&H("unit type mismatch"),this.getUnitToBaseFactor()/t.getUnitToBaseFactor()}getUnitToBaseFactor(){return this.m_factor}getHashCode(){return le(qs(this.getUnitType()),qs(this.getUnitToBaseFactor()))}equals(t){return!!t&&this.getUnitType()===t.getUnitType()&&this.getUnitToBaseFactor()===t.getUnitToBaseFactor()&&this.getID()===t.getID()&&this.getName()===t.getName()}static isValidWkid(t){return!1}}const Uo={330:104878,500:104879,1300:104899,1450:104986,2230:104988,3800:104978,5e3:104919,6200:104906,8200:104909,9500:104927,9600:104977,1e4:[104911,104936],11e3:104941,11080:104872,11100:104907,12e3:104920,12400:104995,13e3:104948,14e3:[104923,104989],15e3:[104913,104954],15100:104976,16e3:[104926,104931],18e3:[104922,104982],21e3:104947,21500:104877,27e3:[104950,104957],29e3:104964,3e4:104921,31e3:104949,33e3:104946,4e4:[104914,104967],40600:104897,41900:104937,42e3:104951,43100:104993,49300:104924,50100:104939,54e3:104955,58200:104981,59500:104930,74e3:104961,77e3:104956,79e3:104962,83500:104910,85e3:104917,88800:104934,89200:104985,96e3:104997,104e3:104963,106500:104898,11e4:104938,133e3:104932,135e3:104983,17e4:104965,198200:104987,198630:104935,208e3:104966,235800:104952,249400:104929,252100:104980,255e3:104973,47e4:104972,529800:104942,531e3:104996,56e4:104928,561400:104979,578900:104945,584700:104959,593e3:104970,606e3:104999,718e3:104933,745700:104984,761400:104953,763500:104994,764e3:104940,788900:104958,1188300:104998,1195e3:104969,1352600:104968,1560800:104874,1562090:104915,1737400:104903,1821460:104918,1821490:104876,2409300:104912,2410300:104873,2439400:104974,2439700:104900,2575e3:104943,2631200:104875,2632345:104916,3393400:104904,3396190:[104905,104971],6051e3:104901,6051800:104902,637e4:104128,6370997:[4052,37008],6371e3:4035,6371007:4047,6371228:[4053,10346],6376045:[8042,8043],6376523:[4027,4901,4902],6376896:37007,6378135:[4122,4322,4324,4720,4985,4987],6378136:[4740,4923,7678,7680,9474,9475,104017,104018],6378137:[3823,3824,3888,3889,4017,4019,4023,4031,4040,4046,4055,4074,4075,4080,4081,4121,4126,4130,4133,4140,4141,4148,4151,4152,4163,4166,4167,4170,4171,4172,4173,4176,4180,4189,4190,4258,4269,4283,4318,4319,4326,4463,4466,4469,4470,4480,4482,4483,4490,4557,4558,4612,4617,4619,4624,4627,4659,4661,4667,4669,4670,4674,4686,4687,4693,4694,4702,4737,4742,4747,4749,4750,4755,4756,4757,4758,4759,4761,4762,4763,4764,4765,4883,4885,4887,4889,4893,4895,4898,4907,4909,4921,4925,4927,4929,4931,4933,4935,4937,4939,4941,4943,4945,4947,4949,4951,4953,4955,4957,4959,4961,4963,4965,4967,4971,4975,4977,4979,4981,4983,4989,4997,4999,5012,5013,5245,5246,5251,5252,5263,5264,5323,5324,5340,5342,5353,5354,5359,5360,5364,5365,5370,5371,5372,5373,5380,5381,5392,5393,5488,5489,5545,5546,5592,5593,5885,5886,6134,6135,6310,6311,6318,6319,6321,6322,6324,6325,6364,6365,6667,6668,6705,6706,6782,6783,6980,6982,6983,6987,6989,6990,7034,7035,7036,7037,7038,7039,7040,7041,7042,7072,7073,7084,7085,7086,7087,7133,7135,7136,7138,7139,7372,7373,7657,7659,7661,7663,7665,7685,7686,7797,7798,7816,7843,7844,7880,7881,7885,7886,7900,7901,7902,7903,7904,7905,7906,7907,7908,7909,7910,7911,7912,7915,7917,7919,7921,7923,7925,7927,7929,7931,8085,8086,8231,8232,8235,8237,8239,8240,8244,8246,8248,8249,8251,8252,8254,8255,8399,8403,8426,8427,8449,8542,8544,8545,8684,8685,8698,8699,8817,8818,8860,8888,8899,8900,8901,8902,8906,8907,8916,8918,8920,8922,8924,8926,8928,8930,8932,8934,8936,8938,8940,8942,8944,8946,8948,8949,8972,8973,8974,8975,8976,8977,8978,8979,8980,8981,8982,8983,8984,8985,8986,8987,8988,8989,8990,8991,8992,8993,8994,8995,8996,8997,8998,8999,9e3,9002,9003,9005,9006,9008,9009,9011,9012,9013,9014,9016,9017,9018,9019,9053,9054,9055,9056,9057,9059,9060,9061,9062,9063,9064,9065,9066,9067,9068,9069,9071,9072,9074,9075,9139,9140,9147,9148,9152,9153,9183,9184,9293,9294,9299,9308,9309,9332,9333,9364,9372,9379,9380,9384,9453,9469,9470,9546,9547,9695,9696,9701,9702,9739,9754,9755,9758,9763,9776,9777,9778,9779,9781,9782,9783,9784,9866,9871,9939,9964,9969,9974,9989,9990,10175,10177,10178,10185,10191,10196,10204,10209,10214,10219,10224,10229,10237,10272,10277,10283,10284,10298,10299,10300,10304,10305,10307,10309,10310,10311,10312,10327,10328,10413,10414,10468,10474,10475,10570,10571,10605,10606,10623,10628,10638,10639,10670,10671,10672,10673,10689,10690,10724,10725,10738,10739,10761,10762,10780,10781,10784,10785,10799,10800,20033,20040,20041,20045,20046,104009,104010,104011,104012,104013,104014,104015,104016,104019,104020,104021,104022,104024,104027,104028,104050,104100,104107,104108,104110,104111,104114,104115,104116,104117,104118,104119,104120,104121,104122,104123,104124,104129,104133,104134,104137,104141,104142,104143,104144,104145,104179,104180,104181,104182,104183,104184,104185,104186,104199,104223,104257,104258,104259,104260,104286,104287,104602,104613,104644,104645,104646,104647,104653,104804,104896,104991],6378140:4610,6378145:[4025,4276,4760,4891,37001],6378150:37003,6378155:[37004,37207],6378160:[3821,4003,4021,4036,4202,4203,4237,4238,4291,4618,4708,5527,37231,104023,104136],6378166:37002,6378200:[4020,4229,4286,4303,4706],6378245:[4024,4147,4164,4178,4179,4191,4200,4205,4214,4284,4317,4555,4676,4677,4678,4991,4993,5560,5561,37257,104135],6378270:[4732,37005,37229],6378273:[4054,10345],6378300:[4029,4168,4174],6378388:[4022,4123,4153,4154,4158,4159,4160,4161,4165,4181,4182,4183,4184,4185,4192,4194,4195,4196,4199,4204,4207,4208,4215,4218,4221,4224,4225,4230,4231,4233,4235,4236,4247,4248,4249,4254,4255,4259,4264,4265,4271,4272,4274,4285,4287,4288,4292,4297,4309,4311,4313,4316,4472,4475,4611,4614,4615,4616,4621,4622,4623,4625,4626,4628,4629,4630,4631,4632,4633,4636,4637,4639,4641,4642,4643,4644,4645,4646,4658,4660,4662,4663,4664,4665,4668,4672,4673,4684,4688,4689,4690,4691,4692,4698,4704,4705,4707,4709,4710,4711,4712,4714,4715,4716,4718,4719,4721,4722,4724,4725,4727,4728,4729,4730,4733,4734,4735,4739,4741,4753,4754,4802,4803,4806,4809,4810,4823,4824,4900,5524,6883,8428,8430,8431,9248,9251,9253,9403,9893,10158,10249,10252,10635,10636,10735,10736,10758,37201,37204,37205,37212,37213,37214,37215,37216,37217,37218,37219,37221,37222,37224,37226,37227,37230,37232,37233,37234,37235,37237,37238,37241,37242,37245,37246,37247,37249,37250,37251,37253,37259,104104,104106,104125,104126,104127,104130,104138,104248],6378523:104786,24764e3:104960,25559e3:104944,60268e3:104925,71492e3:104908,6957e5:104975,6377397155e-3:[3819,3906,4004,4120,4124,4125,4149,4150,4156,4162,4211,4219,4257,4262,4280,4289,4294,4295,4301,4306,4308,4312,4314,4613,4666,4745,4746,4801,4804,4805,4808,4813,4814,4815,4818,4820,4904,5132,5228,5229,5681,5830,8351,9267,10268,37255,104101,104102,104105,104131,104648,104696,104697,104990,104992],6377563396e-3:[4001,4188,4277,4278,4279],6377340189e-3:[4002,4299,4300],6377492018e-3:[4005,4273,4817],6377483865280418e-9:[4006,4293],6378293645208759e-9:[4007,4157,4302,4738,5464],63782064e-1:[4008,4127,4128,4129,4135,4136,4137,4138,4139,4169,4216,4242,4253,4267,4608,4609,4638,4675,4683,4695,4717,4723,4726,4995,5451,5467,37220,37239,37243,37252,37260,104e3,104109,104112,104113,104132],6378450047e-3:[4009,4268],6378300789e-3:[4010,4281],63782492e-1:[4011,4014,4155,4193,4206,4213,4223,4226,4227,4228,4252,4261,4266,4275,4282,4296,4304,4310,4315,4671,4807,4811,4816,4821,37223,37225,104139,104140,104261,104304],6378249145e-3:[4012,4013,4132,4134,4142,4143,4175,4197,4198,4201,4209,4210,4212,4220,4222,4232,4234,4246,4250,4251,4256,4260,4263,4270,4305,4307,4600,4601,4602,4603,4604,4605,4606,4607,4620,4679,4680,4696,4697,4699,4700,4701,4703,4713,4731,4736,4743,4744,4812,4819,6881,6882,6892,6894,8694,37206,37208,37211,37228,37240,37254,104025,104026,104103,104305],6377276345e-3:[4015,4131,4144,4239,4240,4244,4682,5233,6207,37202,104256,104664,104693],6377298556e-3:[4016,4298],6377304063e-3:[4018,4245],63782983e-1:[4028,4903],63781362e-1:4032,63781363e-1:4033,6378249144808011e-9:[4034,4241],209229318e-1:[4042,4243],6377301243e-3:[4044,4145,37203],6377299151e-3:[4045,4146],637701927e-2:[4657,10256,10260,10265],63783063696e-4:[4748,4752],6377295664e-3:[4751,37006],63781365e-1:[7682,7683],63710087714e-4:104047,6378418941e-3:[104700,104726,104760],6378586581e-3:[104701,104743],6378505809e-3:104702,6378544823e-3:104703,6378490569e-3:104704,6378470757e-3:[104705,104776],6378403701e-3:[104706,104750],6378434181e-3:[104707,104724,104739,104764],6378454907e-3:104708,6378400653e-3:104709,6378567378e-3:104710,6378546957e-3:[104711,104717,104780],6378476853e-3:[104712,104736],6378411321e-3:[104713,104728],6378647541e-3:[104714,104715],6378514953e-3:[104716,104782],6378421989e-3:[104718,104770],6378481425e-3:[104719,104753,104774,104781],6378518001e-3:[104720,104725],6378521049e-3:[104721,104723,104731,104745,104748],6378464661e-3:104722,6378436619e-3:104727,6378574389e-3:[104729,104730],6378472281e-3:[104732,104756],6378498189e-3:[104733,104746],6378449421e-3:[104734,104766],6378525621e-3:[104735,104754],6378466185e-3:104737,6378496665e-3:104738,6378643579e-3:104740,6378559758e-3:104741,6378414369e-3:[104742,104763,104772],6378441801e-3:104744,6378502761e-3:[104747,104759,104773,104775],6378617061e-3:104749,6378624681e-3:[104751,104765],6378468623e-3:104752,6378445763e-3:[104755,104758,104761],6378670401e-3:104757,6378438753e-3:104762,6378543909e-3:104767,6378605783e-3:104768,6378540861e-3:104769,6378443325e-3:[104771,104784],6378548481e-3:104777,6378463746e-3:104778,6378426561e-3:104779,6378453688e-3:104783,6378530193e-3:104785,6378376271e-3:[104800,104828],637847192e-2:104801,6378472931e-3:104802,6378411351e-3:104803,6378380991e-3:104805,637841496e-2:104806,637834509e-2:[104807,104819,104844,104870],6378412542e-3:104808,6378470401e-3:104809,6378376331e-3:104810,6378379031e-3:104811,6378407621e-3:104812,6378376811e-3:[104813,104827],637831392e-2:104814,637841493e-2:104815,6378413021e-3:104816,6378380381e-3:104817,6378530851e-3:104818,6378591521e-3:104820,6378378881e-3:104821,6378408481e-3:[104822,104832],6378375601e-3:[104823,104838],6378408041e-3:104824,6378655071e-3:104825,6378409151e-3:104826,63783157e-1:[104829,104840,104845,104851],637828586e-2:[104830,104835,104859],6378379301e-3:104831,6378560121e-3:104833,6378531821e-3:104834,63785006e-1:104836,6378376041e-3:104837,6378406601e-3:104839,6378438991e-3:104841,637834542e-2:104842,637859386e-2:104843,6378381271e-3:[104846,104847],6378413671e-3:104848,6378344377e-3:104849,6378563891e-3:104850,6378408091e-3:104852,6378377671e-3:104853,6378472751e-3:104854,6378412511e-3:104855,6378407281e-3:104856,6378534451e-3:104857,6378406051e-3:104858,6378532921e-3:104860,6378380091e-3:104861,6378408941e-3:104862,6378624171e-3:104863,6378377411e-3:104864,6378474591e-3:104865,6378407141e-3:104866,6378376871e-3:104867,6378375251e-3:104868,6378405971e-3:104869,6378437651e-3:104871};function X1(){for(const r in Uo)delete Uo[r]}class wr extends o_{constructor(t){if(typeof t=="number")return super(),this.m_factor=t,void(this.m_wkid=0);super(t)}getUnitType(){return 1}convertFromRadians(t){return t/this.getUnitToBaseFactor()}convertToRadians(t){return t*this.getUnitToBaseFactor()}}function R1(r){return new hi}function k1(r){return r.getType()===et.PE_TYPE_LINUNIT?new hi(r):r.getType()===et.PE_TYPE_ANGUNIT?new wr(r):void H("peUnit")}function L1(r){const t=Rn(null);return r.getType()===et.PE_TYPE_PROJCS||r.getType()===et.PE_TYPE_GEOGCS?t.reset(r.getUnit()):H("PE_coord_sys"),t.get()||$("cannot create units from coord sys"),k1(t.get())}class Ks{constructor(t,e,s){t===void 0?(this.x=new L,this.y=new L,this.z=new L):t instanceof mt?(this.x=new L(t.x),this.y=new L(t.y),this.z=new L(t.z)):t instanceof L?(this.x=t.clone(),this.y=e.clone(),this.z=s.clone()):H("EPoint3D constructor")}dotProduct(t){return this.x.mulE(t.x).addE(this.y.mulE(t.y)).addE(this.z.mulE(t.z))}crossProduct(t){return new Ks(this.y.mulE(t.z).subE(this.z.mulE(t.y)),this.z.mulE(t.x).subE(this.x.mulE(t.z)),this.x.mulE(t.y).subE(this.y.mulE(t.x)))}crossProductVector(t){const e=this.y.mulE(t.z).subE(t.y.mulE(this.z)),s=t.x.mulE(this.z).subE(this.x.mulE(t.z)),i=this.x.mulE(t.y).subE(t.x.mulE(this.y));return new Ks(e,s,i)}sqrLength(){return this.x.mulE(this.x).addE(this.y.mulE(this.y)).addE(this.z.mulE(this.z))}length(){return this.sqrLength().sqrt()}static distance(t,e){return t.sub(e).length()}negate(){return new Ks(this.x.negate(),this.y.negate(),this.z.negate())}add(t){return new Ks(this.x.addE(t.x),this.y.addE(t.y),this.z.addE(t.z))}sub(t){return new Ks(this.x.subE(t.x),this.y.subE(t.y),this.z.subE(t.z))}subThis(t){return this.x.subThisE(t.x),this.y.subThisE(t.y),this.z.subThisE(t.z),this}addThis(t){return this.x.addThisE(t.x),this.y.addThisE(t.y),this.z.addThisE(t.z),this}mul(t){return new Ks(this.x.mulE(t),this.y.mulE(t),this.z.mulE(t))}div(t){return new Ks(this.x.divE(t),this.y.divE(t),this.z.divE(t))}eq(t){return this.x.eq(t.x)&&this.y.eq(t.y)&&this.z.eq(t.z)}isZero(){return this.x.isZero()&&this.y.isZero()&&this.z.isZero()}value(){return mt.construct(this.x.value(),this.y.value(),this.z.value())}}class B1{constructor(t){if(this.m_origin=new mt,this.m_normal=new mt,this.m_axisX=new mt,this.m_axisY=new mt,!t)return this.m_origin=new mt,this.m_normal=new mt(0,0,1),this.m_axisX=new mt(1,0,0),void(this.m_axisY=new mt(0,1,0));t.pt0&&t.pt1&&t.pt2?this.setFromPoints(t.pt0,t.pt1,t.pt2):b(0,`unimplemented constructor options ${JSON.stringify(t)}`)}assign(t){return b(0),this}set(t,e,s,i){b(0)}setFromPoints(t,e,s){let i=e.sub(t);const n=s.sub(t);this.m_normal=i.crossProductVector(n);let o=!0;if(this.m_normal.isZero()){if(o=!1,i.isZero()&&(i=n),i.isZero())return this.m_normal.setCoords(0,0,1),this.m_axisX.setCoords(1,0,0),this.m_axisY.setCoords(0,1,0),this.m_origin=t,!1;this.m_axisX=i.getUnitVector(),this.m_normal=this.m_axisX.createAPerpendicular()}else this.m_normal.normalizeThis(),this.m_axisX=i.getUnitVector();return this.m_axisY=this.m_normal.crossProductVector(this.m_axisX),this.m_origin=t,o}getCoord(t,e){return b(0),{}}getCoord2D(t){return b(0),{}}getCoordX(t,e){return b(0),0}getCoordY(t,e){return b(0),0}getCoordZ(t,e){return b(0),0}setPreferredAxisX(t){b(0)}getOrigin(){return b(0),{}}getNormal(){return b(0),{}}getAxisX(){return this.m_axisX.clone()}getAxisY(){return this.m_axisY.clone()}setAxisX(t,e=!1){b(0)}setAxisY(t,e=!1){b(0)}recalculateAxisY(){b(0)}setOrigin(t){b(0)}setNormal(t,e){b(0)}intersect(t,e){return b(0),!1}intersectLine(t){return b(0),0}intersectLineEx(t,e){return b(0),0}closestCoordinate(t){const e=t.sub(this.m_origin),s=new y;return s.x=e.dotProduct(this.m_axisX),s.y=e.dotProduct(this.m_axisY),s}projectVector(t){return b(0),{}}signedDistance(t){return b(0),0}distance(t){return b(0),0}}function H1(r,t){return!1}function Hm(r,t,e,s,i=100,n=H1){let o,a,h,m,l,u,c,g,_;b(s>0);let d,p,f,x=0,E=0;const P=gh();t>e&&(e=O(t,t=e));const C=r(t),S=r(e);C<S?(o=a=h=t,m=l=u=C):(o=a=h=e,m=l=u=S);let I=0;for(;I<i&&(f=.5*(e-t),_=t+f,d=s*(Math.abs(o)+.25),p=2*d,!(n(o,m)||Math.abs(o-_)<=p-f));++I){if(Math.abs(E)>d){const w=(o-a)*(m-u);let D=(o-h)*(m-l),N=(o-h)*D-(o-a)*w;D=2*(D-w),D>0&&(N=-N),D=Math.abs(D);const A=E;E=x,Math.abs(N)>=Math.abs(D*A*.5)||N<=D*(t-o)||N>=D*(e-o)?(E=o>=_?t-o:e-o,x=gh()*E):(x=N/D,g=o+x,(g-t<p||e-g<p)&&(x=_-o<0?-Math.abs(d):Math.abs(d)))}else E=o>=_?t-o:e-o,x=E*P;g=o+x,c=r(g),c<m?(g>=o?t=o:e=o,h=a,a=o,o=g,u=l,l=m,m=c):(g<o?t=g:e=g,c<=l||a===o?(h=a,a=g,u=l,l=c):(c<=u||h===o||h===a)&&(h=g,u=c))}return te(o,m)}function tm(r,t,e){return r>e?r-=Math.ceil((r-e)/zr)*zr:r<t&&(r+=Math.ceil((t-r)/zr)*zr),r}function ae(r,t,e){return z1(r,t,e,0)}function z1(r,t,e,s){const i=e.x,n=e.y;return a_(r,t,Math.cos(i),Math.sin(i),Math.cos(n),Math.sin(n),s)}function U1(r,t,e,s,i,n){return a_(r,t,e,s,i,n,0)}function a_(r,t,e,s,i,n,o){const a=r/Math.sqrt(1-t*n*n),h=a+o,m=h*i*e,l=h*i*s,u=(a*(1-t)+o)*n;return mt.construct(m,l,u)}function Oo(r,t,e){const s=new L,i=new L,n=new L,o=new L;s.setCos(e.x),i.setSin(e.x),n.setCos(e.y),o.setSin(e.y);const a=o.negate().mulE(o.mul(t)).add(1).sqrt(),h=new L(r).divE(a),m=h.mulE(n).mulE(s),l=h.mulE(n).mulE(i),u=h.mul(1-t).mulE(o);return new Ks(m,l,u)}function Dn(r,t,e){const s=e.x,i=e.y,n=e.z,o=Math.atan2(i,s),a=Math.sqrt(s*s+i*i),h=Math.atan2(n,(1-t)*a);return y.construct(o,h)}function $n(r,t,e){const s=1-t,i=r/Math.sqrt(yt(e.x)+yt(e.y)+yt(e.z)/s);return e.mul(i)}function O1(r,t,e,s,i){const n=ae(r,t,e),o=ae(r,t,s);return Dn(r,t,mt.lerp(n,o,i))}function em(r,t,e){const s=new mt;return s.setCrossProductVector(t,e),Math.abs(Math.atan2(s.length(),t.dotProduct(e)))*r}function W1(r,t,e,s,i){const n=e.getUnitVector(),o=s.getUnitVector(),a=t.getUnitVector(),h=new mt;if(h.setCrossProductVector(n,o),!h.isZero()){h.normalizeThis();const u=a.sub(h.mul(h.dotProduct(a)));if(!u.isZero()){u.normalizeThis();const c=n.add(o).mul(.5);if(c.dotProduct(u)>c.dotProduct(n)){const g=Math.abs(h.dotProduct(a)),_=Math.asin(g);return i.assign(u.getUnitVector().mul(r)),_*r}}}const m=em(1,n,a),l=em(1,o,a);return m<=l?(i.assign(e),m*r):(i.assign(s),l*r)}function $1(r,t,e,s){const i={stack:[],error:void 0,hasError:!1};try{const n=Te(i,new xe,!1);return Ze.geodeticDistance(r,t,e.x,e.y,s.x,s.y,n,null,null,et.PE_LINETYPE_GEODESIC),n.val}catch(n){i.error=n,i.hasError=!0}finally{li(i)}}function j1(r,t,e,s,i){switch(b(e.isFinite()&&s.isFinite()),i){case 0:return $1(r,t,e,s);case 1:return Q1(r,t,e);case 2:case 3:{const n=ae(r,t,e),o=ae(r,t,s);return mt.distance(n,o)}default:ft("")}}function jn(r,t,e,s,i,n=0,o){if(n===2||n===3)return Z1(r,t,e,s,i,n===3,o);const a=Dn(r,t,e),h=l=>{const u=Dn(r,t,mt.lerp(s,i,l));return j1(r,t,a,u,n)},m=mt.distance(s,i);if(m>0){const l=l_(r,m),{first:u,second:c}=Hm(h,0,1,l);return o&&o.assign($n(r,t,mt.lerp(s,i,u))),te(u,c)}{const l=h(0);return o&&o.assign(s),te(.5,l)}}function Z1(r,t,e,s,i,n=!1,o){const a=$n(r,t,e);if(n){const l=new B1({pt0:new mt(0,0,0),pt1:s,pt2:i}),u=l.closestCoordinate(e),c=l.closestCoordinate(s),g=l.closestCoordinate(i),_=y.getClosestCoordinate(c,g,u),d=$n(r,t,mt.lerp(s,i,_)),p=mt.distance(d,a);return o&&o.assign(d),te(_,p)}const h=l=>{const u=$n(r,t,mt.lerp(s,i,l));return mt.distance(u,a)},m=mt.distance(s,i);if(m>0){const l=l_(r,m),{first:u,second:c}=Hm(h,0,1,l);return o&&o.assign($n(r,t,mt.lerp(s,i,u))),te(u,c)}{const l=mt.distance(e,s);return o&&o.assign(e),te(.5,l)}}function Q1(r,t,e,s){const i={stack:[],error:void 0,hasError:!1};try{const n=Te(i,new xe,!1);return Ze.greatEllipticDistance(r,t,e.x,e.y,e.x,e.y,n,null,null),n.val}catch(n){i.error=n,i.hasError=!0}finally{li(i)}}function K1(r,t,e,s,i){if(Math.abs(e.x-s.x)>Math.PI||Math.abs(e.y)>dt||Math.abs(s.y)>dt||(Math.abs(e.y)===dt||Math.abs(s.y)===dt)&&e.x!==s.x)return Number.NaN;const{first:n,second:o}=rp(e.x,s.x);let a=i;if(a=tm(a,n,o),!z.construct(e.x,s.x).containsCoordinate(a))return Number.NaN;const h=K.constructPoint2D(e),m=K.constructPoint2D(s),l=Oo(1,t,h),u=Oo(1,t,m),c=l.crossProductVector(u);if(c.z.isZero())return e.y;const g=c.x.divE(c.z.negate()),_=c.y.divE(c.z.negate()),d=g.mulE(g).addE(_.mulE(_)).sqrt();if(d.isZero()||g.isZero()&&_.isZero())return e.y;const p=Math.atan2(_.value(),g.value());let f=Math.atan2(d.value()*Math.cos(p-a),1-t);const x=ae(1,t,y.construct(a,f)),E=mt.construct(x.x,x.y,-x.z),P=c.value().dotProduct(x),C=c.value().dotProduct(E);return Math.abs(C)<Math.abs(P)&&(f=-f),f}function h_(r,t,e,s,i,n){if(n[0]=Number.NaN,n[1]=Number.NaN,Math.abs(e.x-s.x)>Math.PI||Math.abs(e.y)>dt||Math.abs(s.y)>dt||(Math.abs(e.y)===dt||Math.abs(s.y)===dt)&&e.x!==s.x||Math.abs(i)>=dt||e.y>0&&s.y>0&&e.y>i&&s.y>i||e.y<0&&s.y<0&&e.y<i&&s.y<i)return 0;const o=K.constructPoint2D(e),a=K.constructPoint2D(s),h=Oo(1,t,o),m=Oo(1,t,a),l=h.crossProductVector(m);if(l.z.isZero())return z.construct(e.y,s.y).containsCoordinate(i)?(n[0]=e.x,1):0;const u=l.x.divE(l.z.negate()),c=l.y.divE(l.z.negate()),g=u.mulE(u).addE(c.mulE(c)).sqrt();if(g.isZero()||u.isZero()&&c.isZero())return i===0?(n[0]=e.x,n[1]=s.x,2):0;const _=(1-t)*Math.tan(i)/g.value();if(Math.abs(_)>1)return 0;const d=Math.acos(_),p=Math.atan2(c.value(),u.value()),f=p-d;let x=p+d;const E=Math.min(e.x,s.x),P=Math.max(e.x,s.x);tm(f,E,P),i!==0?tm(x,E,P):x=f;let C=0;return E<=f&&f<=P&&(n[C]=f,C++),x!==f&&E<=x&&x<=P&&(n[C]=x,C++),C}function Vu(r,t){t[0]>.5*Math.PI?(r[0]+=Math.PI,t[0]=Math.PI-t[0]):t[0]<.5*-Math.PI&&(r[0]-=Math.PI,t[0]=-Math.PI-t[0]),b(t[0]>=.5*-Math.PI&&t[0]<=.5*Math.PI)}function J1(r,t){return r*Math.sqrt(1-t)}function tx(r){return 1-r}function ex(r,t,e,s,i){s=Nt(s,-dt,dt),i=Nt(i,-dt,dt);const n=dt-.03;let o;return o=s>n&&i>n||s<-n&&i<-n?sx(r,s,i):Yu(r,i)-Yu(r,s),.5*(e-t)*o*tx(r)}function sx(r,t,e){let s=1;if(t<0&&(s=-1,t=-t,e=-e),r!==0){const i=r*r,n=i*r,o=[1,(1+11*r)/12,(1+118*r+241*i)/360,(1+1089*r+10419*i+8651*n)/20160,(1+9836*r+318246*i+1027436*n+458881*(n*r))/1814400],a=m=>{let l=0;const u=yt(m)/(r-1);for(let c=o.length-1;c>=0;--c)l=o[c]+l*u;return l*=-yt(m/(1-r)),l},h=a(dt-t);return(a(dt-e)-h)*s}{const i=dt-t,n=dt-e,o=-4*yt(Math.sin(i/2));return(-4*yt(Math.sin(n/2))-o)*s}}function Yu(r,t){if(t===0)return 0;const e=Math.sin(t);let s=e,i=e;if(r!==0){s/=1-r*e*e;const n=Math.sqrt(r);i=e*mp(n*e)}return s+i}function ix(r,t){return r/Math.sqrt(1-t)}function m_(r,t){return(1-t)*r}function nx(r,t,e){const s=e/(2*m_(r,t)),i=s*s;return e*(1-i*(.16666666666666666-.008333333333333333*i))}function l_(r,t){if(t!==0){const e=r*up()/t;return Math.min(e,1e-10)}return 0}class kr{constructor(t){this.m_currentShift=63n,this.m_currentElt=0n,this.m_iCurrentElt=-1,this.m_parent=t,this.m_aiSetElts=t.m_bits.flatMap((e,s)=>s)}next(){if(this.m_currentShift++,this.m_currentShift===64n){if(this.m_iCurrentElt++,this.m_iCurrentElt===this.m_aiSetElts.length)return kr.npos();this.m_currentShift=0n,this.m_currentElt=this.m_parent.m_bits[this.m_aiSetElts[this.m_iCurrentElt]]}for(;this.m_currentShift<63n&&!(this.m_currentElt&1n<<this.m_currentShift);)this.m_currentShift++;return this.m_currentElt&1n<<this.m_currentShift?64*this.m_aiSetElts[this.m_iCurrentElt]+Number(this.m_currentShift):this.next()}static npos(){return Number.MAX_SAFE_INTEGER}}function Za(r){return 1n<<(0x3fn&BigInt(r))}function Qa(r){return r>>6}class Ts{constructor(t){this.m_bits=[],t!==void 0&&t.copy&&(this.m_bits=t.copy.m_bits.slice())}assignMove(){return this}assignCopy(){return this}hasBit(t){const e=Za(t),s=Qa(t);return this.m_bits[s]!==void 0&&!!(this.m_bits[s]&e)}setBit(t){const e=Za(t),s=Qa(t);this.m_bits[s]===void 0&&(this.m_bits[s]=0n),this.m_bits[s]|=e}clearBit(t){}flipBit(t){const e=Za(t),s=Qa(t);return this.m_bits[s]===void 0&&(this.m_bits[s]=0n),this.m_bits[s]^=e,(this.m_bits[s]&e)!==0n}clear(){this.m_bits.length=0}isZero(){let t=0;return this.m_bits.forEach(e=>{t|=e?2:1}),!(2&t)}equals(t){if(this===t)return!0;if(this.m_bits.length!==t.m_bits.length)return!1;let e=0;return this.m_bits.forEach((s,i)=>{e|=s===t.m_bits[i]?2:1}),!(1&e)&&(t.m_bits.forEach((s,i)=>{e|=s===this.m_bits[i]?2:1}),!(1&e))}notEquals(t){return!this.equals(t)}assignOr(t){return t.m_bits.forEach((e,s)=>{this.m_bits[s]===void 0?this.m_bits[s]=e:this.m_bits[s]|=e}),this}assignSubtract(t){return t.m_bits.forEach((e,s)=>{this.m_bits[s]!==void 0&&(this.m_bits[s]&=~e)}),this}assignAnd(t){return t.m_bits.forEach((e,s)=>{this.m_bits[s]!==void 0&&(this.m_bits[s]&=e)}),this}assignXor(t){return t.m_bits.forEach((e,s)=>{this.m_bits[s]===void 0?this.m_bits[s]=e:this.m_bits[s]^=e}),this}getHashCode(){return this.m_bits.reduce((t,e)=>ip(t,e),qs(0))}getUnorderedBitIterator(){return new kr(this)}}class rx{constructor(t,e){this.m_map=new Map,this.m_hf=t,this.m_ef=e}add(t){const e=this.m_hf(t);if(!this.m_map.has(e))return this.m_map.set(e,t),this;const s=this.m_map.get(e);return s instanceof Array?s.find(i=>this.m_ef(i,t))||s.push(t):this.m_ef(s,t)||this.m_map.set(e,[s,t]),this}clear(){this.m_map.clear()}delete(t){return!1}has(t){const e=this.m_hf(t);if(!this.m_map.has(e))return!1;const s=this.m_map.get(e);return s instanceof Array?s.find(i=>this.m_ef(i,t))!==void 0:this.m_ef(s,t)}get(t){const e=this.m_hf(t),s=this.m_map.get(e);if(s!==void 0)return s instanceof Array?s.find(i=>this.m_ef(i,t)):s}get size(){let t=0;for(const e of this.m_map.values())t+=e instanceof Array?e.length:1;return t}forEach(t,e){}[Symbol.iterator](){return new Set()[Symbol.iterator]()}entries(){return new Set().entries()}keys(){return new Set().keys()}values(){return new Set().values()}get[Symbol.toStringTag](){return"ValueSet"}}class ox extends tn{constructor(t){super(),this.m_bufferLeft=new it,this.m_bufferRight=new it,this.m_intervalLeft=z.constructEmpty(),this.m_intervalRight=z.constructEmpty(),this.m_yScanline=Number.NaN,this.m_helper=t}compare(t,e,s){const i=e,n=t.getElement(s);this.m_helper.querySegmentXY(i,this.m_bufferLeft),this.m_helper.querySegmentXY(n,this.m_bufferRight);const o=this.m_bufferLeft.get(),a=this.m_bufferRight.get();if(this.m_intervalLeft.setCoords(o.getStartX(),o.getEndX()),this.m_intervalRight.setCoords(a.getStartX(),a.getEndX()),this.m_intervalLeft.vmax<this.m_intervalRight.vmin)return-1;if(this.m_intervalLeft.vmin>this.m_intervalRight.vmax)return 1;const h=o.getStartY()===o.getEndY(),m=a.getStartY()===a.getEndY();if(h||m){if(h&&m)return 0;if(o.getStartY()===a.getStartY()&&o.getStartX()===a.getStartX())return h?1:-1;if(o.getEndY()===a.getEndY()&&o.getEndX()===a.getEndX())return h?-1:1}let l=o.intersectionOfYMonotonicWithAxisX(this.m_yScanline,this.m_intervalLeft.vmin),u=a.intersectionOfYMonotonicWithAxisX(this.m_yScanline,this.m_intervalRight.vmin);if(l===u){const c=o.getEndY(),g=a.getEndY(),_=Math.min(c,g);let d=.5*(_+this.m_yScanline);d===this.m_yScanline&&(d=_),l=o.intersectionOfYMonotonicWithAxisX(d,this.m_intervalLeft.vmin),u=a.intersectionOfYMonotonicWithAxisX(d,this.m_intervalRight.vmin)}return l<u?-1:l>u?1:0}setY(t){this.m_yScanline=t}}class ax{constructor(t){this.m_segmentBuffer=new it,this.m_point=y.getNAN(),this.m_parent=t}setPointXY(t){this.m_point.assign(t)}compare(t,e){const s=t.getElement(e);this.m_parent.querySegmentXY(s,this.m_segmentBuffer);const i=this.m_segmentBuffer.get(),n=new z;if(n.setCoords(i.getStartX(),i.getEndX()),this.m_point.x<n.vmin)return-1;if(this.m_point.x>n.vmax)return 1;const o=i.intersectionOfYMonotonicWithAxisX(this.m_point.y,this.m_point.x);return this.m_point.x<o?-1:this.m_point.x>o?1:0}}var ve,di;function Xu(r,t){return{parentage:r,rank:t}}function hx(r,t){const e=r.length;if(e!==t.length)return!1;const s=r[0].parentage;if(s!==t[0].parentage)return!1;if(s===-1)return!0;for(let i=1;i<e;++i)if(r[i].parentage!==t[i].parentage)return!1;return!0}function Ru(r,t,e){e.length=0;let s=!1;{let i=r.getHalfEdgeVertexIterator(t);for(;i!==v;){const n=r.getVertexFromVertexIterator(i),o=r.getShape().getSegmentRank(n),a=r.getShape().getSegmentParentage(n);s||=a>=0,e.push(Xu(a,o)),i=r.incrementVertexIterator(i)}}{let i=r.getHalfEdgeVertexIterator(r.getHalfEdgeTwin(t));for(;i!==v;){const n=r.getVertexFromVertexIterator(i),o=r.getShape().getSegmentRank(n),a=r.getShape().getSegmentParentage(n);s||=a>=0,e.push(Xu(a,o)),i=r.incrementVertexIterator(i)}}s&&e.sort((i,n)=>i.rank>n.rank?-1:i.rank<n.rank?1:i.parentage<n.parentage?-1:i.parentage>n.parentage?1:0),e[0].parentage===-1&&(e.length=1)}function mx(){return new rx(r=>r.getHashCode(),(r,t)=>r.equals(t))}(function(r){r[r.enumInputModeBuildGraph=0]="enumInputModeBuildGraph",r[r.enumInputModeSimplifyAlternate=1]="enumInputModeSimplifyAlternate",r[r.enumInputModeSimplifyWinding=2]="enumInputModeSimplifyWinding"})(ve||(ve={})),function(r){r[r.enumSegmentParentageBreakNode=1]="enumSegmentParentageBreakNode",r[r.enumPathBreakNode=2]="enumPathBreakNode"}(di||(di={}));class gs{constructor(){this.m_shape=null,this.m_clusterData=new At(8),this.m_clusterVertices=new At(2),this.m_firstCluster=v,this.m_lastCluster=v,this.m_halfEdgeData=new At(8),this.m_chainData=new At(8),this.m_chainAreas=null,this.m_chainPerimeters=null,this.m_universeChain=-1,this.m_simplifiedGeometry=-1,this.m_edgeIndices=[],this.m_clusterIndices=[],this.m_chainIndices=[],this.m_bBuildGeometryParentageSets=!1,this.m_chainBitSetIndex=-1,this.m_edgeBitSetIndex=-1,this.m_edgeBitSetIndexLeft=-1,this.m_emptyBitSet=null,this.m_geometryMapID=null,this.m_uniqueBitSets=null,this.m_chainBitSets=[],this.m_edgeBitSets=[],this.m_checkDirtyPlanesweepTolerance=Number.NaN,this.m_geometryIDIndex=-1,this.m_clusterIndex=-1,this.m_halfEdgeIndex=-1,this.m_tmpHalfEdgeParentageIndex=-1,this.m_tmpHalfEdgeParentageIndexLeft=-1,this.m_tmpHalfEdgeWindingNumberIndex=-1,this.m_tmpHalfEdgeOddEvenNumberIndex=-1,this.m_segmentParentageIndex=-1,this.m_segmentIndexHe=-1,this.m_clusterBreakNodeIndex=-1,this.m_universeGeomID=-1,this.m_pointCount=0,this.m_progressCounter=0,this.m_bBuildChains=!0,this.m_bDirtyCheckFailed=!1}setCheckDirtyPlanesweepTolerance(t){this.m_checkDirtyPlanesweepTolerance=t}dirtyCheckFailed(){return this.m_bDirtyCheckFailed}getShape(){return this.m_shape}setEditShape(t,e,s=!0,i=!1){i?this.setEditShapeImpl3D_(t,ve.enumInputModeBuildGraph,null,e,!1):this.setEditShapeImpl_(t,ve.enumInputModeBuildGraph,null,e,s)}setAndSimplifyEditShapeAlternate(t,e,s=null,i=!1){const n=[];n.push(e),this.m_simplifiedGeometry=e,i?this.setEditShapeImpl3D_(t,ve.enumInputModeSimplifyAlternate,n,s,!1):this.setEditShapeImpl_(t,ve.enumInputModeSimplifyAlternate,n,s,t.getGeometryType(e)===T.enumPolygon)}setAndSimplifyEditShapeWinding(t,e,s=null){const i=[];i.push(e),this.m_simplifiedGeometry=e,this.setEditShapeImpl_(t,ve.enumInputModeSimplifyWinding,i,s,!0)}removeShape(){this.m_shape!==null&&(this.m_geometryIDIndex!==-1&&(this.m_shape.removeGeometryUserIndex(this.m_geometryIDIndex),this.m_geometryIDIndex=-1),this.m_clusterIndex!==-1&&(this.m_shape.removeUserIndex(this.m_clusterIndex),this.m_clusterIndex=-1),this.m_halfEdgeIndex!==-1&&(this.m_shape.removeUserIndex(this.m_halfEdgeIndex),this.m_halfEdgeIndex=-1),this.m_tmpHalfEdgeParentageIndex!==-1&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex),this.m_tmpHalfEdgeParentageIndex=-1),this.m_tmpHalfEdgeParentageIndexLeft!==-1&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft),this.m_tmpHalfEdgeParentageIndexLeft=-1),this.m_tmpHalfEdgeWindingNumberIndex!==-1&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeWindingNumberIndex),this.m_tmpHalfEdgeWindingNumberIndex=-1),this.m_tmpHalfEdgeOddEvenNumberIndex!==-1&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeOddEvenNumberIndex),this.m_tmpHalfEdgeOddEvenNumberIndex=-1),this.m_segmentParentageIndex!==-1&&(this.deleteUserIndexForHalfEdges(this.m_segmentParentageIndex),this.m_segmentParentageIndex=-1),this.m_segmentIndexHe!==-1&&(this.deleteUserIndexForHalfEdges(this.m_segmentIndexHe),this.m_segmentIndexHe=-1),this.m_clusterBreakNodeIndex!==-1&&(this.deleteUserIndexForClusters(this.m_clusterBreakNodeIndex),this.m_clusterBreakNodeIndex=-1),this.deleteEdgeBitSets_(),this.deleteChainBitSets_(),this.m_emptyBitSet=null,this.m_geometryMapID=null,this.m_shape=null,this.m_clusterData.deleteAll(!0),this.m_clusterVertices.deleteAll(!0),this.m_firstCluster=v,this.m_lastCluster=v,this.m_halfEdgeData.deleteAll(!0),this.m_edgeIndices.length=0,this.m_clusterIndices.length=0,this.m_chainIndices.length=0,this.m_chainData.deleteAll(!0),this.m_universeChain=v,this.m_chainAreas=null)}getClusterHalfEdge(t){return this.m_clusterData.getField(t,2)}queryXY(t,e){const s=this.getClusterVertexIndex_(t);e.assign(this.m_shape.getXYWithIndex(s))}queryXYZ(t,e){b(0)}getClusterParentage(t){return this.m_clusterData.getField(t,1)}getFirstCluster(){return this.m_firstCluster}getPrevCluster(t){return this.m_clusterData.getField(t,3)}getNextCluster(t){return this.m_clusterData.getField(t,4)}getClusterChain(t){return this.m_clusterData.getField(t,6)}getClusterVertexIterator(t){return this.m_clusterData.getField(t,7)}incrementVertexIterator(t){return this.m_clusterVertices.getField(t,1)}getVertexFromVertexIterator(t){return this.m_clusterVertices.getField(t,0)}getClusterUserIndex(t,e){const s=this.getClusterIndex_(t),i=this.m_clusterIndices[e];return i.size()<=s?-1:i.read(s)}setClusterUserIndex(t,e,s){const i=this.getClusterIndex_(t),n=this.m_clusterIndices[e];n.size()<=i&&n.resize(this.m_clusterData.size(),-1),n.write(i,s)}hasClusterUserIndexFlags(t,e,s){if(e===-1)return!1;const i=this.getClusterUserIndex(t,e);return i!==-1&&(s&i)!==0}setClusterUserIndexFlags(t,e,s){const i=this.getClusterIndex_(t),n=this.m_clusterIndices[e];n.size()<=i&&n.resize(this.m_clusterData.size(),-1);let o=n.read(i);o===-1&&(o=0),n.write(i,s|o)}clearClusterUserIndexFlags(t,e,s){const i=this.getClusterIndex_(t),n=this.m_clusterIndices[e];n.size()<=i&&n.resize(this.m_clusterData.size(),-1);let o=n.read(i);o===-1&&(o=0),n.write(i,~s&o)}createUserIndexForClusters(t=-1){const e=new Xt(this.m_clusterData.capacity(),t);for(let s=0,i=this.m_clusterIndices.length;s<i;s++)if(this.m_clusterIndices[s]===null)return this.m_clusterIndices[s]=e,s;return this.m_clusterIndices.push(e),this.m_clusterIndices.length-1}deleteUserIndexForClusters(t){this.m_clusterIndices[t]=null}getHalfEdgeOrigin(t){return this.m_halfEdgeData.getField(t,1)}getHalfEdgeTo(t){return this.getHalfEdgeOrigin(this.getHalfEdgeTwin(t))}getHalfEdgeTwin(t){return this.m_halfEdgeData.getField(t,4)}getHalfEdgePrev(t){return this.m_halfEdgeData.getField(t,5)}getHalfEdgeNext(t){return this.m_halfEdgeData.getField(t,6)}getHalfEdgeChain(t){return this.m_halfEdgeData.getField(t,2)}getHalfEdgeFaceParentage(t){return this.getChainParentage(this.getHalfEdgeChain(t))}getHalfEdgeVertexIterator(t){return this.m_halfEdgeData.getField(t,7)}getHalfEdgeFromXY(t,e){this.queryXY(this.getHalfEdgeOrigin(t),e)}getHalfEdgeToXY(t,e){this.queryXY(this.getHalfEdgeTo(t),e)}isHalfEdgeCurve(t){return this.m_segmentIndexHe!==-1?this.getHalfEdgeUserIndex(t,this.m_segmentIndexHe)!==-1:!1}getHalfEdgeFromXYZ(t,e){b(0)}getHalfEdgeToXYZ(t,e){b(0)}getHalfEdgeParentage(t){return this.m_halfEdgeData.getField(t,3)&gs.c_EdgeParentageMask}getHalfEdgeUserIndex(t,e){const s=this.getHalfEdgeIndex_(t),i=this.m_edgeIndices[e];return i.size()<=s?-1:i.read(s)}setHalfEdgeUserIndex(t,e,s){const i=this.getHalfEdgeIndex_(t),n=this.m_edgeIndices[e];n.size()<=i&&n.resize(this.m_halfEdgeData.size(),-1),n.write(i,s)}createUserIndexForHalfEdges(t){t===void 0&&(t=-1);const e=new Xt(this.m_halfEdgeData.capacity(),t);for(let i=0,n=this.m_edgeIndices.length;i<n;i++)if(this.m_edgeIndices[i]===null)return this.m_edgeIndices[i]=e,i;this.m_edgeIndices.push(e);const s=this.m_edgeIndices.length-1;return b(s>=0&&s<=Number.MAX_SAFE_INTEGER),s}deleteUserIndexForHalfEdges(t){this.m_edgeIndices[t]=null}deleteEdgesBreakFaces_(t){for(let e=0,s=t.length;e<s;e++){const i=t[e],n=this.getHalfEdgeChain(i),o=this.getHalfEdgeTwin(i),a=this.getHalfEdgeChain(o);this.setChainHalfEdge_(n,v),this.setChainHalfEdge_(a,v),this.updateVertexToHalfEdgeConnection_(i,!0),this.deleteEdgeImpl_(i)}}doesHalfEdgeBelongToAPolygonInterior(t,e){return b(0),!1}doesHalfEdgeBelongToAPolygonExterior(t,e){return b(0),!1}doesHalfEdgeBelongToAPolygonBoundary(t,e){return b(0),!1}doesHalfEdgeBelongToAPolylineInterior(t,e){return b(0),!1}doesHalfEdgeBelongToAPolylineExterior(t,e){return b(0),!1}doesClusterBelongToAPolygonInterior(t,e){return b(0),!1}doesClusterBelongToAPolygonExterior(t,e){return b(0),!1}doesClusterBelongToAPolygonBoundary(t,e){return b(0),!1}getFirstChain(){return this.m_universeChain}getChainHalfEdge(t){return this.m_chainData.getField(t,1)}getChainParentage(t){return this.m_chainData.getField(t,2)}getChainParent(t){return this.m_chainData.getField(t,3)}getChainFirstIsland(t){return this.m_chainData.getField(t,4)}getChainNextInParent(t){return this.m_chainData.getField(t,5)}getChainNext(t){return this.m_chainData.getField(t,7)}getChainArea(t){const e=this.getChainIndex_(t);let s=this.m_chainAreas.read(e);return Number.isNaN(s)&&(this.updateChainAreaAndPerimeter_(t),s=this.m_chainAreas.read(e)),s}getChainPerimeter(t){return b(0),0}getChainUserIndex(t,e){const s=this.getChainIndex_(t),i=this.m_chainIndices[e];return i.size()<=s?-1:i.read(s)}setChainUserIndex(t,e,s){const i=this.getChainIndex_(t),n=this.m_chainIndices[e];n.size()<=i&&n.resize(this.m_chainData.size(),-1),n.write(i,s)}createUserIndexForChains(){const t=new Xt(this.m_chainData.capacity(),-1);for(let e=0,s=this.m_chainIndices.length;e<s;e++)if(this.m_chainIndices[e]===null)return this.m_chainIndices[e]=t,e;return this.m_chainIndices.push(t),this.m_chainIndices.length-1}deleteUserIndexForChains(t){this.m_chainIndices[t]=null}extractPolygonFromChainAndIslands(t,e,s,i){const n=e===v?t.createGeometry(T.enumPolygon):e,o=new it;this.extractPolygonPathFromChain_(t,n,s,i,o);for(let a=this.getChainFirstIsland(s);a!==v;a=this.getChainNextInParent(a))this.extractPolygonPathFromChain_(t,n,a,i,o);return n}getGeometryID(t){const e=this.m_shape.getGeometryUserIndex(t,this.m_geometryIDIndex);return b(e>=0),1<<Math.min(e,31)}getClusterFromVertex(t){return this.m_shape.getUserIndex(t,this.m_clusterIndex)}getHalfEdgeFromVertex(t){return this.m_shape.getUserIndex(t,this.m_halfEdgeIndex)}buildGeometryParentageSets(){this.m_bBuildGeometryParentageSets=!0}getChainBitSet(t){if(b(this.m_bBuildGeometryParentageSets),this.m_chainBitSetIndex===-1)return this.getEmptySet();const e=this.getChainUserIndex(t,this.m_chainBitSetIndex);b(e>=0);let s=this.m_chainBitSets.at(e);return s||(s=this.getEmptySet()),s}getChainBoundaryBitSet(t){b(this.m_bBuildGeometryParentageSets);const e=new Ts,s=i=>{const n=this.getChainHalfEdge(i);let o=n;do{const a=this.getEdgeBitSet_(o);a!==null&&e.assignOr(a);const h=this.getEdgeBitSet_(this.getHalfEdgeTwin(o));h!==null&&e.assignOr(h),o=this.getHalfEdgeNext(o)}while(o!==n)};s(t);for(let i=this.getChainFirstIsland(t);i!==v;i=this.getChainNextInParent(i))s(t);return e}getChainPolygons(t){return b(0),[]}getGeometriesFromBits(t){if(!this.m_bBuildGeometryParentageSets||t===null)return[];if(this.m_geometryMapID===null){this.m_geometryMapID=new Map;for(let i=this.m_shape.getFirstGeometry();i!==v;i=this.m_shape.getNextGeometry(i))this.m_geometryMapID.set(this.m_shape.getGeometryUserIndex(i,this.m_geometryIDIndex),i)}const e=[],s=t.getUnorderedBitIterator();for(let i=s.next();i!==kr.npos();i=s.next())b(this.m_geometryMapID.has(i)),e.push(this.m_geometryMapID.get(i));return e}getVertexDominant(t,e){if(e===v)return t;const s=this.getClusterFromVertex(t);return this.getVertexDominantFromCluster(s,e)}getVertexDominantFromCluster(t,e){if(e!==v){let s=v;for(let i=this.getClusterVertexIterator(t);i!==v;i=this.incrementVertexIterator(i)){const n=this.getVertexFromVertexIterator(i);s===v&&(s=n);const o=this.m_shape.getPathFromVertex(n);if(this.m_shape.getGeometryFromPath(o)===e){s=n;break}}return s}{const s=this.getClusterVertexIterator(t);return s!==v?this.getVertexFromVertexIterator(s):v}}isBreakNode(t){return this.hasClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,di.enumSegmentParentageBreakNode)}setBreakNode(t,e){b(this.m_clusterBreakNodeIndex!==-1),e?this.setClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,di.enumSegmentParentageBreakNode):this.clearClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,di.enumSegmentParentageBreakNode)}isStrongPathNode(t){return this.hasClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,di.enumPathBreakNode)}setStrongPathNode(t,e){if(this.m_clusterBreakNodeIndex===-1){if(!e)return;this.m_clusterBreakNodeIndex=this.createUserIndexForClusters()}e?this.setClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,di.enumPathBreakNode):this.clearClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,di.enumPathBreakNode)}getSegmentParentage(t){if(this.m_segmentParentageIndex===-1)return-1;const e=this.getHalfEdgeUserIndex(t,this.m_segmentParentageIndex);return e>=0?e:-1}isCrossroadAhead(t){const e=this.getHalfEdgeNext(t);if(this.isStrongPathNode(this.getHalfEdgeOrigin(e)))return!0;const s=this.getHalfEdgeTwin(e),i=this.getHalfEdgeNext(s);return t!==this.getHalfEdgeTwin(i)}isCrossroadBehind(t){return b(0),!1}getHalfEdgeConnector(t,e){const s=this.getClusterHalfEdge(t);if(s===v)return v;let i=s,n=v,o=v;do{if(this.getHalfEdgeTo(i)===e)return i;if(n===v){if(n=this.getClusterHalfEdge(e),n===v)return v;o=n}if(this.getHalfEdgeTo(o)===t)return i=this.getHalfEdgeTwin(o),i;i=this.getHalfEdgeNext(this.getHalfEdgeTwin(i)),o=this.getHalfEdgeNext(this.getHalfEdgeTwin(o))}while(i!==s&&o!==n);return v}querySegmentXY(t,e){if(this.m_segmentIndexHe!==-1){let n=this.getHalfEdgeUserIndex(t,this.m_segmentIndexHe);if(n!==-1){if(n!==-2){const o=this.m_shape.getSegmentFromIndex(n);e.copyFrom(o,!0)}else{n=this.getHalfEdgeUserIndex(this.getHalfEdgeTwin(t),this.m_segmentIndexHe);const o=this.m_shape.getSegmentFromIndex(n);e.copyFrom(o,!0),e.get().reverse()}return}}e.createLine();const s=e.get(),i=y.getNAN();this.getHalfEdgeFromXY(t,i),s.setStartXY(i),this.getHalfEdgeToXY(t,i),s.setEndXY(i)}isCurveEdge(t){return this.m_segmentIndexHe!==-1?this.getHalfEdgeUserIndex(t,this.m_segmentIndexHe)!==-1:!1}compareEdgeAnglesCurveHelper_(t,e,s){const i=new it,n=new it;this.querySegmentXY(t,i),this.querySegmentXY(e,n);const o=i.get(),a=n.get();if(o.equals(a))return 0;const h=new y;this.getHalfEdgeFromXY(t,h);const m=new y;this.getHalfEdgeToXY(t,m);const l=new y;return this.getHalfEdgeToXY(e,l),b(!m.isEqualPoint2D(l)),sg(o,a)}compareEdgeAnglesHelper_(t,e,s){if(t===e)return 0;if(this.isHalfEdgeCurve(t)||this.isHalfEdgeCurve(e))return this.compareEdgeAnglesCurveHelper_(t,e,s);const i=y.getNAN();this.getHalfEdgeToXY(t,i);const n=y.getNAN();if(this.getHalfEdgeToXY(e,n),i.isEqualPoint2D(n))return 0;const o=y.getNAN();this.getHalfEdgeFromXY(t,o);const a=y.getNAN();a.setSub(i,o);const h=y.getNAN();return h.setSub(n,o),!s||h.y>=0&&a.y>0?y.compareVectors(a,h):0}compareEdgeAngles_(t,e){return this.compareEdgeAnglesHelper_(t,e,!1)}compareEdgeAnglesForPair_(t,e){return this.compareEdgeAnglesHelper_(t,e,!0)}compareEdgeAngles3D_(t,e){return b(0),0}compareEdgeAnglesForPair3D_(t,e){return b(0),0}dbgDumpChains_(){}dbgDumpChainToPolygon_(t,e){}deleteEdgeInternal_(t){const e=this.getHalfEdgeChain(t),s=this.getHalfEdgeTwin(t),i=this.getHalfEdgeChain(s);b(i===e),b(t===this.getHalfEdgeNext(s)||s===this.getHalfEdgeNext(t));let n=this.getHalfEdgeNext(t);n===s&&(n=this.getHalfEdgeNext(n),n===t&&(n=v));const o=this.getChainIndex_(e),a=this.m_chainAreas.read(o);Number.isNaN(a)||(this.setChainArea_(e,Number.NaN),this.setChainPerimeter_(e,Number.NaN));const h=this.getChainHalfEdge(e);h!==t&&h!==s||this.setChainHalfEdge_(e,n),this.updateVertexToHalfEdgeConnection_(t,!0),this.deleteEdgeImpl_(t)}getFirstUnvisitedHalfEdgeOnCluster_(t,e,s){let i=e!==v?e:this.getClusterHalfEdge(t);if(i===v)return v;const n=i;for(;;){if(this.getHalfEdgeUserIndex(i,s)!==1)return i;const o=this.getHalfEdgeNext(this.getHalfEdgeTwin(i));if(o===n)return v;i=o}}removeSpikes_(){let t=!1;const e=this.createUserIndexForHalfEdges();for(let s=this.getFirstCluster();s!==v;s=this.getNextCluster(s)){let i=v;for(;;){let n=this.getFirstUnvisitedHalfEdgeOnCluster_(s,i,e);if(n===v)break;i=this.getHalfEdgeNext(this.getHalfEdgeTwin(n));let o=n;for(;;){const a=this.getHalfEdgeNext(o),h=this.getHalfEdgePrev(o),m=this.getHalfEdgeTwin(o);if(h===m){if(this.deleteEdgeInternal_(o),t=!0,i!==o&&i!==m||(i=v),o===n||h===n){if(n=a,o===n||h===n)break;o=a;continue}}else this.setHalfEdgeUserIndex(o,e,1);if(o=a,o===n)break}}}return this.deleteUserIndexForHalfEdges(e),t}progress_(t,e=!1){}newCluster_(){const t=this.m_clusterData.newElement();return this.m_clusterData.setField(t,1,0),t}newHalfEdgePair_(){const t=this.m_halfEdgeData.newElement();this.m_halfEdgeData.setField(t,2,0),this.m_halfEdgeData.setField(t,3,0);const e=this.m_halfEdgeData.newElement();return this.m_halfEdgeData.setField(e,2,0),this.m_halfEdgeData.setField(e,3,0),this.setHalfEdgeTwin_(t,e),this.setHalfEdgeTwin_(e,t),t}newChain_(){const t=this.m_chainData.newElement();return this.m_chainData.setField(t,2,0),t}deleteChain_(t){return b(0),0}getClusterIndex_(t){return this.m_clusterData.elementToIndex(t)}setClusterVertexIterator_(t,e){this.m_clusterData.setField(t,7,e)}setClusterHalfEdge_(t,e){this.m_clusterData.setField(t,2,e)}setClusterParentage_(t,e){this.m_clusterData.setField(t,1,e)}setPrevCluster_(t,e){this.m_clusterData.setField(t,3,e)}setNextCluster_(t,e){this.m_clusterData.setField(t,4,e)}setClusterVertexIndex_(t,e){this.m_clusterData.setField(t,5,e)}getClusterVertexIndex_(t){return this.m_clusterData.getField(t,5)}setClusterChain_(t,e){this.m_clusterData.setField(t,6,e)}addClusterToExteriorChain_(t,e){this.setClusterChain_(e,t)}getHalfEdgeIndex_(t){return this.m_halfEdgeData.elementToIndex(t)}setHalfEdgeOrigin_(t,e){this.m_halfEdgeData.setField(t,1,e)}setHalfEdgeTwin_(t,e){this.m_halfEdgeData.setField(t,4,e)}setHalfEdgePrev_(t,e){this.m_halfEdgeData.setField(t,5,e)}setHalfEdgeNext_(t,e){this.m_halfEdgeData.setField(t,6,e)}setHalfEdgeChain_(t,e){this.m_halfEdgeData.setField(t,2,e)}setHalfEdgeParentage_(t,e){this.m_halfEdgeData.setField(t,3,e)}getHalfEdgeParentageMask_(t){return this.m_halfEdgeData.getField(t,3)}setHalfEdgeVertexIterator_(t,e){this.m_halfEdgeData.setField(t,7,e)}updateVertexToHalfEdgeConnectionHelper_(t,e){const s=e?v:t;for(let i=this.getHalfEdgeVertexIterator(t);i!==v;i=this.incrementVertexIterator(i)){const n=this.getVertexFromVertexIterator(i);this.m_shape.setUserIndex(n,this.m_halfEdgeIndex,s)}}updateVertexToHalfEdgeConnection_(t,e){t!==v&&(this.updateVertexToHalfEdgeConnectionHelper_(t,e),this.updateVertexToHalfEdgeConnectionHelper_(this.getHalfEdgeTwin(t),e))}getChainIndex_(t){return this.m_chainData.elementToIndex(t)}setChainHalfEdge_(t,e){this.m_chainData.setField(t,1,e)}setChainParentage_(t,e){this.m_chainData.setField(t,2,e)}setChainParent_(t,e){this.m_chainData.setField(t,3,e);const s=this.getChainFirstIsland(e);this.setChainNextInParent_(t,s),this.setChainFirstIsland_(e,t)}setChainFirstIsland_(t,e){this.m_chainData.setField(t,4,e)}setChainNextInParent_(t,e){this.m_chainData.setField(t,5,e)}setChainPrev_(t,e){this.m_chainData.setField(t,6,e)}setChainNext_(t,e){this.m_chainData.setField(t,7,e)}setChainArea_(t,e){const s=this.getChainIndex_(t);this.m_chainAreas.write(s,e)}setChainPerimeter_(t,e){const s=this.getChainIndex_(t);this.m_chainPerimeters.write(s,e)}updateChainAreaAndPerimeter_(t){const e=this.m_shape.hasCurves(),s=new Ce(0),i=new Ce(0),n=this.getChainHalfEdge(t),o=y.getNAN(),a=y.getNAN(),h=y.getNAN();this.getHalfEdgeFromXY(n,o),a.setCoordsPoint2D(o);let m=n;do this.getHalfEdgeToXY(m,h),e&&this.isCurveEdge(m)||i.pe(y.distance(a,h)),this.getHalfEdgeChain(this.getHalfEdgeTwin(m))!==t&&s.pe((h.x-o.x-(a.x-o.x))*(h.y-o.y+(a.y-o.y))*.5),a.setCoordsPoint2D(h),m=this.getHalfEdgeNext(m);while(m!==n);if(e){const u=new it;m=n;do{this.getHalfEdgeToXY(m,h);const c=this.isCurveEdge(m);if(c&&(this.querySegmentXY(m,u),i.pe(u.get().calculateLength2D())),this.getHalfEdgeChain(this.getHalfEdgeTwin(m))!==t&&c){const g=u.get().calculateArea2DHelper();s.pe(g)}m=this.getHalfEdgeNext(m)}while(m!==n)}const l=this.getChainIndex_(t);this.m_chainAreas.write(l,s.getResult()),this.m_chainPerimeters.write(l,i.getResult())}getChainTopmostEdge_(t){return b(0),0}planeSweepParentage_(t,e){const s=new ox(this),i=new tt;i.setCapacity(Math.trunc(this.m_pointCount/2)),i.setComparator(s);const n=[],o=this.createUserIndexForHalfEdges();let a=null;const h=y.getNAN();for(let m=this.getFirstCluster();m!==v;m=this.getNextCluster(m)){this.progress_(e);const l=this.getClusterHalfEdge(m);if(l!==v){if(n.length=0,!this.tryOptimizedInsertion_(i,o,n,m,l)){this.queryXY(m,h),s.setY(h.y);let u=l;do{const c=this.getHalfEdgeUserIndex(u,o);c!==-1&&(i.deleteNode(c),this.setHalfEdgeUserIndex(u,o,At.impossibleIndex2())),u=this.getHalfEdgeNext(this.getHalfEdgeTwin(u))}while(l!==u);u=l;do{if(this.getHalfEdgeUserIndex(u,o)===-1){const c=i.addElement(u);n.push(c)}u=this.getHalfEdgeNext(this.getHalfEdgeTwin(u))}while(l!==u)}for(let u=n.length-1;u>=0;u--){const c=n[u],g=i.getElement(c),_=this.getHalfEdgeTwin(g);this.setHalfEdgeUserIndex(_,o,c),this.planeSweepParentagePropagateParentage_(i,c,t)}}else if(this.getClusterChain(m)===v){a===null&&(a=new ax(this)),this.queryXY(m,h),a.setPointXY(h);const u=i.searchLowerBound(a);let c=this.m_universeChain;if(u!==-1){let g=i.getElement(u);this.getHalfEdgeChain(g)===this.getHalfEdgeChain(this.getHalfEdgeTwin(g))&&(g=this.getLeftSkipPolylines_(i,u)),g!==v&&(c=this.getHalfEdgeChain(g))}this.addClusterToExteriorChain_(c,m)}}this.deleteUserIndexForHalfEdges(o)}planeSweepParentagePropagateParentage_(t,e,s){const i=t.getElement(e),n=this.getHalfEdgeChain(i);if(this.getChainParent(n)!==v)return;const o=this.getLeftSkipPolylines_(t,e),a=this.getHalfEdgeTwin(i),h=this.getHalfEdgeChain(a);let m=this.getChainParent(n),l=this.getChainParent(h);if(o===v)m===v&&(h===n?(this.setChainParent_(h,this.m_universeChain),l=this.m_universeChain,m=l):(l===v&&(this.setChainParent_(h,this.m_universeChain),l=this.m_universeChain),this.setChainParent_(n,h),m=h));else{const u=this.getHalfEdgeChain(o);if(l===v){if(this.getChainArea(u)<=0){const c=this.getChainParent(u);this.setChainParent_(h,c),l=c}else this.setChainParent_(h,u),l=u;h===n&&(m=l)}}m===v&&(this.trySetChainParentFromTwin_(n,h),m=this.getChainParent(n)),b(m!==v),s===ve.enumInputModeBuildGraph?this.propagateParentageBuildGraph_(t,e,i,o):s===ve.enumInputModeSimplifyWinding?this.propagateParentageWinding_(t,e,i,o,a,n,h):s===ve.enumInputModeSimplifyAlternate&&this.propagateParentageAlternate_(t,e,i,o,a,n,h)}propagateParentageBuildGraph_(t,e,s,i){let n,o=e;i===v?(o=t.getNext(o),n=this.getHalfEdgeChain(s)):n=this.getHalfEdgeChain(i);let a=null,h=this.getChainParentage(n);for(this.m_bBuildGeometryParentageSets&&(a=this.getChainBitSet(n));o!==-1;o=t.getNext(o)){const m=t.getElement(o),l=this.getHalfEdgeTwin(m);n=this.getHalfEdgeChain(m);const u=this.getHalfEdgeChain(l);if(this.m_bBuildGeometryParentageSets){let p=this.getChainBitSet(u);p=new Ts({copy:p}),p.assignOr(a),this.setChainBitSet_(u,p);let f=this.getChainBitSet(n);const x=this.getLeftEdgeBitSet_(m),E=new Ts({copy:a});if(E.assignSubtract(x),E.isZero())break;f=new Ts({copy:f}),f.assignOr(E),this.setChainBitSet_(n,f),a=f}const c=this.getChainParentage(u),g=c|h;g!==c&&this.setChainParentage_(u,g);let _=this.getChainParentage(n);const d=h&~this.getHalfEdgeUserIndex(m,this.m_tmpHalfEdgeParentageIndexLeft);if(d&&(_|=d,this.setChainParentage_(n,_)),d===0)break;h=_}}propagateParentageWinding_(t,e,s,i,n,o,a){if(o===a)return;let h=this.getHalfEdgeUserIndex(s,this.m_tmpHalfEdgeWindingNumberIndex);h+=this.getHalfEdgeUserIndex(n,this.m_tmpHalfEdgeWindingNumberIndex);let m=0;const l=[],u=[];u.push(0);for(let c=t.getFirst();c!==e;c=t.getNext(c)){const g=t.getElement(c),_=this.getHalfEdgeTwin(g),d=this.getHalfEdgeChain(g),p=this.getHalfEdgeChain(_);if(d!==p){let f=this.getHalfEdgeUserIndex(g,this.m_tmpHalfEdgeWindingNumberIndex);f+=this.getHalfEdgeUserIndex(_,this.m_tmpHalfEdgeWindingNumberIndex),m+=f;let x=!1;l.length!==0&&l.at(-1)===p&&(u.pop(),l.pop(),x=!0),b(this.getChainParent(p)!==v),x&&this.getChainParent(p)===d||(u.push(m),l.push(d))}}if(m+=h,l.length!==0&&l.at(-1)===a&&(u.pop(),l.pop()),m!==0){if(u.at(-1)===0){const c=this.m_simplifiedGeometry,g=this.getGeometryID(c);this.setChainParentage_(o,g)}}else if(u.at(-1)!==0){const c=this.m_simplifiedGeometry,g=this.getGeometryID(c);this.setChainParentage_(o,g)}}propagateParentageAlternate_(t,e,s,i,n,o,a){const h=this.m_simplifiedGeometry,m=this.getGeometryID(h);if(i===v)this.setChainParentage_(a,this.m_universeGeomID),1&this.getHalfEdgeUserIndex(s,this.m_tmpHalfEdgeOddEvenNumberIndex)?this.setChainParentage_(o,m):this.setChainParentage_(o,this.m_universeGeomID);else{const l=this.getChainParentage(a);if(l===0){const u=this.getHalfEdgeChain(i),c=this.getChainParentage(u);this.setChainParentage_(a,c),1&this.getHalfEdgeUserIndex(s,this.m_tmpHalfEdgeOddEvenNumberIndex)?this.setChainParentage_(o,c===m?this.m_universeGeomID:m):this.setChainParentage_(o,c)}else 1&this.getHalfEdgeUserIndex(s,this.m_tmpHalfEdgeOddEvenNumberIndex)?this.setChainParentage_(o,l===m?this.m_universeGeomID:m):this.setChainParentage_(o,l)}}tryOptimizedInsertion_(t,e,s,i,n){let o=n,a=-1,h=v,m=0;do{if(m===2)return!1;const l=this.getHalfEdgeUserIndex(o,e);if(l!==-1){if(a!==-1)return!1;a=l}else{if(h!==v)return!1;h=o}m++,o=this.getHalfEdgeNext(this.getHalfEdgeTwin(o))}while(n!==o);return h!==v&&a!==-1&&(this.setHalfEdgeUserIndex(t.getElement(a),e,At.impossibleIndex2()),t.setElement(a,h),s.push(a),!0)}trySetChainParentFromTwin_(t,e){const s=this.getChainArea(t);if(s===0)return!1;const i=this.getChainArea(e);if(s>0&&i<0||s<0&&i>0)return this.setChainParent_(t,e),!0;{const n=this.getChainParent(e);if(n!==v)return this.setChainParent_(t,n),!0}return!1}createHalfEdges_(t,e){this.m_halfEdgeIndex=this.m_shape.createUserIndex();for(let s=0,i=e.size();s<i;s++){const n=e.read(s),o=this.m_shape.getUserIndex(n,this.m_clusterIndex),a=this.m_shape.getPathFromVertex(n),h=this.m_shape.getGeometryFromPath(a),m=this.m_shape.getGeometryType(h);if(lt(m)){const l=this.m_shape.getNextVertex(n);if(l===v)continue;const u=this.m_shape.getUserIndex(l,this.m_clusterIndex);if(o===u)continue;const c=this.newHalfEdgePair_(),g=this.getHalfEdgeTwin(c),_=this.m_clusterVertices.newElement();this.m_clusterVertices.setField(_,0,n),this.m_clusterVertices.setField(_,1,-1),this.setHalfEdgeVertexIterator_(c,_),this.m_shape.setUserIndex(n,this.m_halfEdgeIndex,c),this.setHalfEdgeOrigin_(c,o);const d=this.getClusterHalfEdge(o);if(d===v)this.setClusterHalfEdge_(o,c),this.setHalfEdgePrev_(c,g),this.setHalfEdgeNext_(g,c);else{const E=this.getHalfEdgePrev(d);this.setHalfEdgePrev_(d,g),this.setHalfEdgeNext_(g,d),this.setHalfEdgeNext_(E,c),this.setHalfEdgePrev_(c,E)}this.setHalfEdgeOrigin_(g,u);const p=this.getClusterHalfEdge(u);if(p===v)this.setClusterHalfEdge_(u,g),this.setHalfEdgeNext_(c,g),this.setHalfEdgePrev_(g,c);else{const E=this.getHalfEdgePrev(p);this.setHalfEdgePrev_(p,c),this.setHalfEdgeNext_(c,p),this.setHalfEdgeNext_(E,g),this.setHalfEdgePrev_(g,E)}const f=this.getGeometryID(h);if(t===ve.enumInputModeBuildGraph){const E=m===T.enumPolygon?f:0;if(this.setHalfEdgeUserIndex(g,this.m_tmpHalfEdgeParentageIndex,0),this.setHalfEdgeUserIndex(c,this.m_tmpHalfEdgeParentageIndex,E),this.setHalfEdgeUserIndex(g,this.m_tmpHalfEdgeParentageIndexLeft,E),this.setHalfEdgeUserIndex(c,this.m_tmpHalfEdgeParentageIndexLeft,0),this.m_bBuildGeometryParentageSets){const P=new Ts,C=this.m_shape.getGeometryUserIndex(h,this.m_geometryIDIndex);P.setBit(C),this.setEdgeBitSet_(c,P),this.setEdgeBitSet_(g,null),this.setLeftEdgeBitSet_(g,P),this.setLeftEdgeBitSet_(c,null)}}else if(t===ve.enumInputModeSimplifyWinding){const E=this.m_shape.getXY(n),P=this.m_shape.getXY(l);let C=0,S=0;E.compare(P)<0?C=1:S=-1,this.setHalfEdgeUserIndex(c,this.m_tmpHalfEdgeWindingNumberIndex,C),this.setHalfEdgeUserIndex(g,this.m_tmpHalfEdgeWindingNumberIndex,S)}else t===ve.enumInputModeSimplifyAlternate&&(this.setHalfEdgeUserIndex(c,this.m_tmpHalfEdgeOddEvenNumberIndex,1),this.setHalfEdgeUserIndex(g,this.m_tmpHalfEdgeOddEvenNumberIndex,1));const x=m===T.enumPolygon?gs.c_EdgeBitMask:0;this.setHalfEdgeParentage_(c,f|x),this.setHalfEdgeParentage_(g,f|x)}}if(this.m_shape.hasCurves()){this.m_segmentIndexHe=this.createUserIndexForHalfEdges();for(let s=0,i=e.size();s<i;s++){const n=e.read(s);if(this.m_shape.getSegment(n)){const o=this.m_shape.getUserIndex(n,this.m_halfEdgeIndex);o!==v&&(this.setHalfEdgeUserIndex(o,this.m_segmentIndexHe,this.m_shape.getVertexIndex(n)),this.setHalfEdgeUserIndex(this.getHalfEdgeTwin(o),this.m_segmentIndexHe,-2))}}}}mergeVertexListsOfEdges_(t,e){{const n=this.getHalfEdgeVertexIterator(e);if(n!==v){const o=this.getHalfEdgeVertexIterator(t);this.m_clusterVertices.setField(n,1,o),this.setHalfEdgeVertexIterator_(t,n),this.setHalfEdgeVertexIterator_(e,v)}}const s=this.getHalfEdgeTwin(t),i=this.getHalfEdgeTwin(e);{const n=this.getHalfEdgeVertexIterator(i);if(n!==v){const o=this.getHalfEdgeVertexIterator(s);this.m_clusterVertices.setField(n,1,o),this.setHalfEdgeVertexIterator_(s,n),this.setHalfEdgeVertexIterator_(i,v)}}if(this.m_segmentIndexHe!==-1){let n=this.getHalfEdgeUserIndex(t,this.m_segmentIndexHe);if(n!==-1){if(n===-2){const o=this.getHalfEdgeUserIndex(e,this.m_segmentIndexHe);this.setHalfEdgeUserIndex(t,this.m_segmentIndexHe,o)}if(n=this.getHalfEdgeUserIndex(s,this.m_segmentIndexHe),n===-2){const o=this.getHalfEdgeUserIndex(i,this.m_segmentIndexHe);this.setHalfEdgeUserIndex(s,this.m_segmentIndexHe,o)}}}}sortHalfEdgesByAngle_(t){const e=[];for(let s=this.getFirstCluster();s!==v;s=this.getNextCluster(s)){e.length=0;const i=this.getClusterHalfEdge(s);if(i!==v){let n=i;do e.push(n),n=this.getHalfEdgeNext(this.getHalfEdgeTwin(n));while(n!==i);if(e.length>1){let o=!0;e.length>2?(e.sort((c,g)=>this.compareEdgeAngles_(c,g)),e.push(e[0])):this.compareEdgeAnglesForPair_(e[0],e[1])>0?e[1]=O(e[0],e[0]=e[1]):o=!1;let a=e[0],h=a,m=this.getHalfEdgeTo(h),l=this.getHalfEdgeTwin(h),u=v;for(let c=1,g=e.length;c<g;c++){const _=e[c],d=this.getHalfEdgeTwin(_),p=this.getHalfEdgeOrigin(d);if(p!==m||_===h)this.updateVertexToHalfEdgeConnection_(u,!1),u=v,h=_,m=p,l=d;else{if(t===ve.enumInputModeBuildGraph){const f=this.getHalfEdgeParentageMask_(h)|this.getHalfEdgeParentageMask_(_);if(this.setHalfEdgeParentage_(h,f),this.setHalfEdgeParentage_(l,f),this.setHalfEdgeUserIndex(h,this.m_tmpHalfEdgeParentageIndex,this.getHalfEdgeUserIndex(h,this.m_tmpHalfEdgeParentageIndex)|this.getHalfEdgeUserIndex(_,this.m_tmpHalfEdgeParentageIndex)),this.setHalfEdgeUserIndex(l,this.m_tmpHalfEdgeParentageIndex,this.getHalfEdgeUserIndex(l,this.m_tmpHalfEdgeParentageIndex)|this.getHalfEdgeUserIndex(d,this.m_tmpHalfEdgeParentageIndex)),this.setHalfEdgeUserIndex(h,this.m_tmpHalfEdgeParentageIndexLeft,this.getHalfEdgeUserIndex(h,this.m_tmpHalfEdgeParentageIndexLeft)|this.getHalfEdgeUserIndex(_,this.m_tmpHalfEdgeParentageIndexLeft)),this.setHalfEdgeUserIndex(l,this.m_tmpHalfEdgeParentageIndexLeft,this.getHalfEdgeUserIndex(l,this.m_tmpHalfEdgeParentageIndexLeft)|this.getHalfEdgeUserIndex(d,this.m_tmpHalfEdgeParentageIndexLeft)),this.m_bBuildGeometryParentageSets){let x,E,P;x=this.getEdgeBitSet_(h),E=this.getEdgeBitSet_(_),P=new Ts({copy:x}),P.assignOr(E),this.setEdgeBitSet_(h,P),x=this.getEdgeBitSet_(l),E=this.getEdgeBitSet_(d),P=new Ts({copy:x}),P.assignOr(E),this.setEdgeBitSet_(l,P),x=this.getLeftEdgeBitSet_(h),E=this.getLeftEdgeBitSet_(_),P=new Ts({copy:x}),P.assignOr(E),this.setLeftEdgeBitSet_(h,P),x=this.getLeftEdgeBitSet_(l),E=this.getLeftEdgeBitSet_(d),P=new Ts({copy:x}),P.assignOr(E),this.setLeftEdgeBitSet_(l,P)}}else if(this.m_tmpHalfEdgeWindingNumberIndex!==-1){const f=this.getHalfEdgeUserIndex(h,this.m_tmpHalfEdgeWindingNumberIndex)+this.getHalfEdgeUserIndex(_,this.m_tmpHalfEdgeWindingNumberIndex),x=this.getHalfEdgeUserIndex(l,this.m_tmpHalfEdgeWindingNumberIndex)+this.getHalfEdgeUserIndex(d,this.m_tmpHalfEdgeWindingNumberIndex);this.setHalfEdgeUserIndex(h,this.m_tmpHalfEdgeWindingNumberIndex,f),this.setHalfEdgeUserIndex(l,this.m_tmpHalfEdgeWindingNumberIndex,x)}else if(this.m_tmpHalfEdgeOddEvenNumberIndex!==-1){const f=this.getHalfEdgeUserIndex(h,this.m_tmpHalfEdgeOddEvenNumberIndex)+this.getHalfEdgeUserIndex(_,this.m_tmpHalfEdgeOddEvenNumberIndex),x=this.getHalfEdgeUserIndex(l,this.m_tmpHalfEdgeOddEvenNumberIndex)+this.getHalfEdgeUserIndex(d,this.m_tmpHalfEdgeOddEvenNumberIndex);this.setHalfEdgeUserIndex(h,this.m_tmpHalfEdgeOddEvenNumberIndex,f),this.setHalfEdgeUserIndex(l,this.m_tmpHalfEdgeOddEvenNumberIndex,x)}this.mergeVertexListsOfEdges_(h,_),this.deleteEdgeImpl_(_),u=h,e[c]=v,_===a&&(e[0]=v,a=v)}}if(this.updateVertexToHalfEdgeConnection_(u,!1),u=v,!o){a=v;for(let c=0,g=e.length;c<g;c++){const _=e[c];if(_!==v){a=_;break}}i!==a&&this.setClusterHalfEdge_(s,a);continue}a=v;for(let c=0,g=e.length;c<g;c++){const _=e[c];if(_===v)continue;if(a===v){a=_,h=a,m=this.getHalfEdgeTo(h),l=this.getHalfEdgeTwin(h);continue}if(_===h)continue;const d=this.getHalfEdgeTwin(_),p=this.getHalfEdgeOrigin(d);this.setHalfEdgeNext_(l,_),this.setHalfEdgePrev_(_,l),h=_,m=p,l=d}this.setClusterHalfEdge_(s,a)}}}}sortHalfEdgesByAngle3D_(t){b(0)}buildChains_(t){this.m_universeChain=this.newChain_(),this.setChainHalfEdge_(this.m_universeChain,v);let e=this.m_universeChain;const s=this.createUserIndexForHalfEdges();for(let i=this.getFirstCluster();i!==v;i=this.getNextCluster(i)){const n=this.getClusterHalfEdge(i);if(n!==v){let o=n;do{if(this.getHalfEdgeUserIndex(o,s)!==1){const a=this.newChain_();this.setChainHalfEdge_(a,o),this.setChainPrev_(a,e),this.setChainNext_(e,a);let h=null;this.m_bBuildGeometryParentageSets&&(h=new Ts),e=a;let m=0,l=o;do this.m_tmpHalfEdgeParentageIndex!==-1&&(m|=this.getHalfEdgeUserIndex(l,this.m_tmpHalfEdgeParentageIndex)),this.m_bBuildGeometryParentageSets&&h.assignOr(this.getEdgeBitSet_(l)),this.setHalfEdgeChain_(l,a),this.setHalfEdgeUserIndex(l,s,1),l=this.getHalfEdgeNext(l);while(l!==o);this.m_bBuildGeometryParentageSets&&this.setChainBitSet_(a,h),this.setChainParentage_(a,m)}o=this.getHalfEdgeNext(this.getHalfEdgeTwin(o))}while(o!==n)}}this.m_chainAreas=new Ei(this.m_chainData.size(),Number.NaN),this.m_chainPerimeters=new Ei(this.m_chainData.size(),Number.NaN),this.setChainArea_(this.m_universeChain,Number.POSITIVE_INFINITY),this.setChainPerimeter_(this.m_universeChain,Number.POSITIVE_INFINITY),this.deleteUserIndexForHalfEdges(s)}simplify_(t){b(0)}simplifyAlternate_(){b(0)}simplifyWinding_(){b(0)}setEditShapeImpl_(t,e,s,i,n){this.removeShape(),this.m_bBuildChains=n,this.m_shape=t,this.m_geometryIDIndex=this.m_shape.createGeometryUserIndex();let o=this.m_shape.getTotalPointCount();if(s){o=0;for(let g=0,_=s.length;g<_;g++)o+=this.m_shape.getPointCount(s[g])}const a=new Xt(0);let h=0,m=0;{let g=s!=null?s[0]:this.m_shape.getFirstGeometry(),_=1;for(;g!==v;){this.m_shape.setGeometryUserIndex(g,this.m_geometryIDIndex,m++);for(let d=this.m_shape.getFirstPath(g);d!==v;d=this.m_shape.getNextPath(d)){let p=this.m_shape.getFirstVertex(d);for(let f=0,x=this.m_shape.getPathSize(d);f<x;f++)a.add(p),p=this.m_shape.getNextVertex(p)}xn(this.m_shape.getGeometryType(g))||(h+=this.m_shape.getPathCount(g)),s!=null?(g=_<s.length?s[_]:v,_++):g=this.m_shape.getNextGeometry(g)}}this.m_universeGeomID=1<<Math.min(m,31),this.m_pointCount=a.size(),this.m_shape.sortVerticesSimpleByY(a,0,this.m_pointCount),this.m_clusterVertices.setCapacity(this.m_pointCount),this.progress_(i,!0),this.m_clusterData.setCapacity(this.m_pointCount+10),this.m_halfEdgeData.setCapacity(2*this.m_pointCount+32),this.m_chainData.setCapacity(Math.max(32,h)),this.m_clusterIndex=this.m_shape.createUserIndex();const l=y.getNAN();let u=0;const c=y.getNAN();for(let g=0;g<=this.m_pointCount;g++){if(g<this.m_pointCount){const _=a.read(g);this.m_shape.queryXY(_,c)}else c.setNAN();if(!l.isEqualPoint2D(c)){if(u<g){const _=this.newCluster_();let d=v,p=-1;for(let f=u;f<g;f++){p=a.read(f),this.m_shape.setUserIndex(p,this.m_clusterIndex,_);const x=this.m_clusterVertices.newElement();this.m_clusterVertices.setField(x,0,p),this.m_clusterVertices.setField(x,1,d),d=x;const E=this.m_shape.getPathFromVertex(p),P=this.m_shape.getGeometryFromPath(E),C=this.getGeometryID(P);this.setClusterParentage_(_,this.getClusterParentage(_)|C)}this.setClusterVertexIterator_(_,d),this.setClusterVertexIndex_(_,this.m_shape.getVertexIndex(p)),this.m_lastCluster!==v&&this.setNextCluster_(this.m_lastCluster,_),this.setPrevCluster_(_,this.m_lastCluster),this.m_lastCluster=_,this.m_firstCluster===v&&(this.m_firstCluster=_)}u=g,l.setCoordsPoint2D(c)}}if(this.m_shape.hasSegmentParentage()){this.m_clusterBreakNodeIndex===-1&&(this.m_clusterBreakNodeIndex=this.createUserIndexForClusters());for(let g=0;g<this.m_pointCount;g++){const _=a.read(g);if(this.m_shape.getSegmentParentageBreakVertex(_)){const d=this.getClusterFromVertex(_);this.setBreakNode(d,!0)}}}this.progress_(i,!0);{let g=s!=null?s[0]:this.m_shape.getFirstGeometry(),_=1;for(;g!==v;){for(let d=this.m_shape.getFirstPath(g);d!==v;d=this.m_shape.getNextPath(d)){if(this.m_shape.isStrongPathStart(d)){const p=this.m_shape.getFirstVertex(d),f=this.getClusterFromVertex(p);this.setStrongPathNode(f,!0)}if(this.m_shape.isStrongPathEnd(d)){const p=this.m_shape.isClosedPath(d)?this.m_shape.getFirstVertex(d):this.m_shape.getLastVertex(d),f=this.getClusterFromVertex(p);this.setStrongPathNode(f,!0)}}s!=null?(g=_<s.length?s[_]:v,_++):g=this.m_shape.getNextGeometry(g)}}if(e===ve.enumInputModeBuildGraph&&(this.m_tmpHalfEdgeParentageIndex=this.createUserIndexForHalfEdges(),this.m_tmpHalfEdgeParentageIndexLeft=this.createUserIndexForHalfEdges()),e===ve.enumInputModeSimplifyWinding&&(this.m_tmpHalfEdgeWindingNumberIndex=this.createUserIndexForHalfEdges()),e===ve.enumInputModeSimplifyAlternate&&(this.m_tmpHalfEdgeOddEvenNumberIndex=this.createUserIndexForHalfEdges()),this.createHalfEdges_(e,a),this.dbgNavigate_(),this.sortHalfEdgesByAngle_(e),!Number.isNaN(this.m_checkDirtyPlanesweepTolerance)&&!this.checkStructureAfterDirtySweep_())return this.m_bDirtyCheckFailed=!0,void this.cleanSetEditShapeImpl_();this.buildChains_(e),this.m_tmpHalfEdgeParentageIndex!==-1&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex),this.m_tmpHalfEdgeParentageIndex=-1),this.m_bBuildChains&&this.planeSweepParentage_(e,i),this.m_tmpHalfEdgeParentageIndexLeft!==-1&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft),this.m_tmpHalfEdgeParentageIndexLeft=-1),this.dbgChkChainParents_(),this.dbgDumpChains_(),this.mergeSegmentParentage_(),this.dbgNavigate_(),this.dbgDumpChains_(),this.cleanSetEditShapeImpl_()}setEditShapeImpl3D_(t,e,s,i,n){b(0)}cleanSetEditShapeImpl_(){this.m_tmpHalfEdgeParentageIndex!==-1&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex),this.m_tmpHalfEdgeParentageIndex=-1),this.m_tmpHalfEdgeParentageIndexLeft!==-1&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft),this.m_tmpHalfEdgeParentageIndexLeft=-1),this.m_tmpHalfEdgeWindingNumberIndex!==-1&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeWindingNumberIndex),this.m_tmpHalfEdgeWindingNumberIndex=-1),this.m_tmpHalfEdgeOddEvenNumberIndex!==-1&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeOddEvenNumberIndex),this.m_tmpHalfEdgeOddEvenNumberIndex=-1)}cleanSetEditShapeImpl3D_(){b(0)}dbgNavigate_(){}dbgChkChainParents_(){}deleteEdgeImpl_(t){const e=this.getHalfEdgeNext(t),s=this.getHalfEdgePrev(t),i=this.getHalfEdgeTwin(t),n=this.getHalfEdgeNext(i),o=this.getHalfEdgePrev(i);e!==i&&(this.setHalfEdgeNext_(o,e),this.setHalfEdgePrev_(e,o)),s!==i&&(this.setHalfEdgeNext_(s,n),this.setHalfEdgePrev_(n,s));const a=this.getHalfEdgeOrigin(t);this.getClusterHalfEdge(a)===t&&(n!==t?this.setClusterHalfEdge_(a,n):this.setClusterHalfEdge_(a,v));const h=this.getHalfEdgeOrigin(i);this.getClusterHalfEdge(h)===i&&(e!==i?this.setClusterHalfEdge_(h,e):this.setClusterHalfEdge_(h,v)),this.m_halfEdgeData.deleteElement(t),this.m_halfEdgeData.deleteElement(i)}getLeftSkipPolylines_(t,e){let s=e;for(;;){if(s=t.getPrev(s),s===-1)return v;{const i=t.getElement(s);if(this.getHalfEdgeChain(i)!==this.getHalfEdgeChain(this.getHalfEdgeTwin(i)))return i}}}checkStructureAfterDirtySweep_(){const t=yt(this.m_checkDirtyPlanesweepTolerance),e=new y,s=new y,i=new y,n=new y,o=new y;for(let a=this.getFirstCluster();a!==v;a=this.getNextCluster(a)){const h=this.getClusterHalfEdge(a);if(h!==v){let m=h;this.getHalfEdgeFromXY(m,e),this.getHalfEdgeToXY(m,s),i.setSub(s,e);let l=i.sqrLength();do{const u=m;if(m=this.getHalfEdgeNext(this.getHalfEdgeTwin(m)),m!==u){this.getHalfEdgeToXY(m,n),o.setSub(n,e);const c=o.sqrLength(),g=o.crossProduct(i),_=g*g/(c*l);if(Math.min(c,l)*_<=t&&o.dotProduct(i)>=0)return!1;i.assign(o),l=c,s.assign(n)}}while(m!==h)}}return!0}extractPolygonPathFromChain_(t,e,s,i,n){const o=this.m_shape.hasSegmentParentage(),a=this.getChainHalfEdge(s);let h=a,m=v;const l=new st;do{const u=this.getHalfEdgeTwin(h);if(this.getHalfEdgeChain(u)!==s){let c=v;const g=this.getHalfEdgeOrigin(h);if(i===v){const d=this.getClusterVertexIterator(g);c=this.getVertexFromVertexIterator(d)}else for(let d=this.getClusterVertexIterator(g);d!==v;d=this.incrementVertexIterator(d)){const p=this.getVertexFromVertexIterator(d);c===v&&(c=p);const f=this.m_shape.getPathFromVertex(p);if(this.m_shape.getGeometryFromPath(f)===i){c=p;break}}let _;if(m===v&&(m=t.insertPath(e,v),t.setClosedPath(m,!0)),this.m_shape===t?_=t.addVertex(m,c):(this.m_shape.queryPoint(c,l),_=t.addPoint(m,l)),this.isHalfEdgeCurve(h)&&(this.querySegmentXY(h,n),t.setSegmentToIndex(t.getVertexIndex(_),n.get().clone())),o){const d=this.getSegmentParentage(h);t.setSegmentParentageAndBreak(_,d,this.isBreakNode(g))}}h=this.getHalfEdgeNext(h)}while(h!==a)}mergeSegmentParentage_(){if(!this.m_shape.hasSegmentParentage())return;b(this.m_clusterBreakNodeIndex!==-1),b(this.m_segmentParentageIndex===-1);for(let i=this.getFirstCluster();i!==v;i=this.getNextCluster(i)){let n=0;const o=this.getClusterHalfEdge(i);if(o!==v){let a=o;do n++,a=this.getHalfEdgeNext(this.getHalfEdgeTwin(a));while(a!==o&&n<3)}n!==2&&this.setBreakNode(i,!0)}let t=[],e=[];this.m_segmentParentageIndex=this.createUserIndexForHalfEdges();const s=this.createUserIndexForHalfEdges();for(let i=this.getFirstCluster();i!==v;i=this.getNextCluster(i)){const n=this.getClusterHalfEdge(i);if(n!==v){let o=!1,a=n;do{let h=a;for(;this.getHalfEdgeUserIndex(h,s)===-1;){const m=this.getHalfEdgeNext(h),l=this.getHalfEdgeTwin(h);Ru(this,h,e);const u=e.at(-1).parentage;if(!o){const g=this.getHalfEdgeOrigin(h);if(!this.isBreakNode(g)){const _=this.getHalfEdgePrev(h);h!==_&&(Ru(this,_,t),o=!0)}}if(o&&!hx(e,t)){const g=this.getHalfEdgeOrigin(h);this.setBreakNode(g,!0)}t=O(e,e=t),o=!0;const c=this.getHalfEdgeOrigin(m);this.isBreakNode(c)&&(o=!1),this.setHalfEdgeUserIndex(h,this.m_segmentParentageIndex,u),this.setHalfEdgeUserIndex(l,this.m_segmentParentageIndex,u),this.setHalfEdgeUserIndex(h,s,1),this.setHalfEdgeUserIndex(l,s,1),h=m}a=this.getHalfEdgeNext(this.getHalfEdgeTwin(a))}while(a!==n)}}this.deleteUserIndexForHalfEdges(s)}registerNewBitSet(t){return this.m_uniqueBitSets===null&&(this.m_uniqueBitSets=mx(),this.m_uniqueBitSets.add(this.getEmptySet())),t===null?this.getEmptySet():this.m_uniqueBitSets.has(t)?this.m_uniqueBitSets.get(t):(this.m_uniqueBitSets.add(t),t)}getLeftEdgeBitSet_(t){const e=this.getHalfEdgeUserIndex(t,this.m_edgeBitSetIndexLeft);return b(e>=0),b(this.m_edgeBitSets.at(e)),this.m_edgeBitSets.at(e)}getEdgeBitSet_(t){const e=this.getHalfEdgeUserIndex(t,this.m_edgeBitSetIndex);return b(e>=0),this.m_edgeBitSets.at(e)}setEdgeBitSet_(t,e){b(this.m_bBuildGeometryParentageSets),e=this.registerNewBitSet(e),this.m_edgeBitSetIndex===-1&&(this.m_edgeBitSetIndex=this.createUserIndexForHalfEdges());const s=this.getHalfEdgeUserIndex(t,this.m_edgeBitSetIndex);s!==-1?this.m_edgeBitSets[s]=e:(this.setHalfEdgeUserIndex(t,this.m_edgeBitSetIndex,this.m_edgeBitSets.length),this.m_edgeBitSets.push(e))}setLeftEdgeBitSet_(t,e){b(this.m_bBuildGeometryParentageSets),e=this.registerNewBitSet(e),this.m_edgeBitSetIndexLeft===-1&&(this.m_edgeBitSetIndexLeft=this.createUserIndexForHalfEdges());const s=this.getHalfEdgeUserIndex(t,this.m_edgeBitSetIndexLeft);s!==-1?this.m_edgeBitSets[s]=e:(this.setHalfEdgeUserIndex(t,this.m_edgeBitSetIndexLeft,this.m_edgeBitSets.length),this.m_edgeBitSets.push(e))}setChainBitSet_(t,e){b(this.m_bBuildGeometryParentageSets),e=this.registerNewBitSet(e),this.m_chainBitSetIndex===-1&&(this.m_chainBitSetIndex=this.createUserIndexForChains());const s=this.getChainUserIndex(t,this.m_chainBitSetIndex);s!==-1?this.m_chainBitSets[s]=e:(this.setChainUserIndex(t,this.m_chainBitSetIndex,this.m_chainBitSets.length),this.m_chainBitSets.push(e))}getEmptySet(){return this.m_emptyBitSet||(this.m_emptyBitSet=new Ts),this.m_emptyBitSet}deleteEdgeBitSets_(){this.m_edgeBitSetIndex!==-1&&(this.deleteUserIndexForHalfEdges(this.m_edgeBitSetIndex),this.m_edgeBitSetIndex=-1),this.m_edgeBitSetIndexLeft!==-1&&(this.deleteUserIndexForHalfEdges(this.m_edgeBitSetIndexLeft),this.m_edgeBitSetIndexLeft=-1),this.m_edgeBitSets.length=0,this.m_uniqueBitSets=null}deleteChainBitSets_(){this.m_chainBitSetIndex!==-1&&(this.deleteUserIndexForChains(this.m_chainBitSetIndex),this.m_chainBitSetIndex=-1,this.m_chainBitSets.length=0)}dbgPrintEdge_(t){}dbgVerifyEdgeSegment(t){}}gs.c_EdgeParentageMask=2147483647,gs.c_EdgeBitMask=1<<31;class wt{freeNode_(t){this.m_listNodes.deleteElement(t)}newNode_(){return this.m_listNodes.newElement()}freeList_(t){this.m_lists.deleteElement(t)}newList_(){return this.m_lists.newElement()}Init_(t){b(0)}constructor(t){this.m_listNodes=new At(2),this.m_listOfLists=wt.st_nullNode(),this.m_bAllowNavigationBetweenLists=!0,t===void 0&&(t=!0),this.m_bAllowNavigationBetweenLists=t,this.m_lists=new At(this.m_bAllowNavigationBetweenLists?4:2)}createList(){const t=this.newList_();return this.m_bAllowNavigationBetweenLists&&(this.m_lists.setField(t,3,this.m_listOfLists),this.m_listOfLists!==wt.st_nullNode()&&this.m_lists.setField(this.m_listOfLists,2,t),this.m_listOfLists=t),t}deleteList(t){let e=this.getFirst(t);for(;e!==wt.st_nullNode();){const s=e;e=this.getNext(e),this.freeNode_(s)}if(this.m_bAllowNavigationBetweenLists){const s=this.m_lists.getField(t,2),i=this.m_lists.getField(t,3);s!==wt.st_nullNode()?this.m_lists.setField(s,3,i):this.m_listOfLists=i,i!==wt.st_nullNode()&&this.m_lists.setField(i,2,s)}this.freeList_(t)}reserveLists(t){this.m_lists.setCapacity(t)}addElement(t,e){this.m_lists.getField(t,0);const s=this.m_lists.getField(t,1),i=this.newNode_();return s!==wt.st_nullNode()?(this.m_listNodes.setField(s,1,i),this.m_lists.setField(t,1,i)):(this.m_lists.setField(t,0,i),this.m_lists.setField(t,1,i)),this.m_listNodes.setField(i,0,e),i}reserveNodes(t){this.m_listNodes.setCapacity(t)}deleteElementDirect(t,e,s){e!==wt.st_nullNode()?(this.m_listNodes.setField(e,1,this.m_listNodes.getField(s,1)),this.m_lists.getField(t,1)===s&&this.m_lists.setField(t,1,e)):(this.m_lists.setField(t,0,this.m_listNodes.getField(s,1)),this.m_lists.getField(t,1)===s&&this.m_lists.setField(t,1,wt.st_nullNode())),this.freeNode_(s)}deleteElementSearch(t,e){let s=-1,i=this.getFirst(t);for(;i!==e;)s=i,i=this.getNext(i);this.deleteElementDirect(t,s,e)}concatenateLists(t,e){const s=this.m_lists.getField(t,1),i=this.m_lists.getField(e,0);if(i!==wt.st_nullNode()&&(s!==wt.st_nullNode()?(this.m_listNodes.setField(s,1,i),this.m_lists.setField(t,1,this.m_lists.getField(e,1))):(this.m_lists.setField(t,0,i),this.m_lists.setField(t,1,this.m_lists.getField(e,1)))),this.m_bAllowNavigationBetweenLists){const n=this.m_lists.getField(e,2),o=this.m_lists.getField(e,3);n!==wt.st_nullNode()?this.m_lists.setField(n,3,o):this.m_listOfLists=o,o!==wt.st_nullNode()&&this.m_lists.setField(o,2,n)}return this.freeList_(e),t}getElement(t){return this.m_listNodes.getField(t,0)}getData(t){return this.getElement(t)}setElement(t,e){b(0)}getNext(t){return this.m_listNodes.getField(t,1)}getFirst(t){return this.m_lists.getField(t,0)}getFirstElement(t){const e=this.getFirst(t);return this.getElement(e)}static st_nullNode(){return-1}clear(){this.m_listNodes.deleteAll(!0),this.m_lists.deleteAll(!0),this.m_listOfLists=wt.st_nullNode()}isEmpty(t){return b(0),!1}getNodeCount(){return this.m_listNodes.size()}getListCount(){return this.m_lists.size()}getFirstList(){return this.m_listOfLists}getNextList(t){return this.m_lists.getField(t,3)}}function Ka(r=-1){return{m_value:r,m_line:new ht,m_segment:null,m_segmentInfo:new qh(-1),m_env:new z(0,0),m_dxdy:55555555,m_bHorizontal:!1,m_bCurve:!1}}const lx=67;class u_ extends tn{constructor(t,e,s){super(!0),this.m_bIntersectionDetected=!1,this.m_nonSimpleResult=new Tt,this.m_tempSimpleEdge1=Ka(),this.m_tempSimpleEdge2=Ka(),this.m_prev1=v,this.m_prev2=v,this.m_vertex1=v,this.m_vertex2=v,this.m_currentNode=-1,this.m_prevX1=Number.NaN,this.m_prevX2=Number.NaN,this.m_prevY=Number.NaN,this.m_prevX=0,this.m_sweepY=Number.NaN,this.m_sweepX=0,this.m_ptSweep=new y,this.m_simpleEdgesCache=[],this.m_simpleEdgesRecycle=[],this.m_cOutstandingConstructedEdges=0,this.m_shape=t,this.m_bShapeHasSegments=this.m_shape.hasCurves(),this.m_tolerance=e,this.m_tolerance10=10*e,this.m_bIsSimple=s;const i=Math.trunc(Math.min(3*t.getTotalPointCount()/2,lx)),n=Math.min(7,i);this.m_simpleEdgesCache.length=n}tryGetCachedEdge_(t){const e=this.m_simpleEdgesCache[(t&we())%this.m_simpleEdgesCache.length];return e&&e.m_value===t?e:null}tryDeleteCachedEdge_(t){const e=(t&we())%this.m_simpleEdgesCache.length,s=this.m_simpleEdgesCache[e];s&&s.m_value===t&&(this.m_simpleEdgesRecycle.push(s),this.m_simpleEdgesCache[e]=null)}tryCreateCachedEdge_(t){const e=(t&we())%this.m_simpleEdgesCache.length;let s=this.m_simpleEdgesCache[e];return s?null:(this.m_simpleEdgesRecycle.length===0?(s=Ka(),this.m_cOutstandingConstructedEdges++):s=this.m_simpleEdgesRecycle.pop(),s.m_value=t,this.m_simpleEdgesCache[e]=s,s)}initSimpleEdge_(t,e){this.m_bShapeHasSegments&&this.initSimpleEdgeHelper_(t,e)||t.m_bCurve||(this.m_shape.queryLineConnector(e,t.m_line,!0),t.m_segment=t.m_line,t.m_env.setCoordsNoNAN(t.m_line.getStartX(),t.m_line.getEndX()),t.m_env.vmax+=this.m_tolerance,t.m_line.orientBottomUp(),t.m_bHorizontal=t.m_line.getEndY()===t.m_line.getStartY(),t.m_bHorizontal||(t.m_dxdy=(t.m_line.getEndX()-t.m_line.getStartX())/(t.m_line.getEndY()-t.m_line.getStartY())))}initSimpleEdgeHelper_(t,e){if(t.m_segment=this.m_shape.getSegment(e),t.m_segmentInfo=this.m_shape.getOriginalSegmentInfo(e),t.m_bCurve=t.m_segment!==null,t.m_bCurve){const s=t.m_segment.clone();return s.orientBottomUp(),t.m_segment=s,t.m_env=t.m_segment.queryInterval(0,0),t.m_env.vmax+=this.m_tolerance,!0}return!1}compareTwoSegments_(t,e){const s=t.getStartXY(),i=t.getEndXY(),n=e.getStartXY(),o=e.getEndXY();if(this.m_ptSweep.setCoords(this.m_sweepX,this.m_sweepY),s.isEqualPoint2D(n)&&this.m_sweepY===s.y){this.m_ptSweep.assign(i.compare(o)<0?i:o);const u=t.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y,this.m_ptSweep.x),c=e.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y,this.m_ptSweep.x);if(Math.abs(u-c)>this.m_tolerance)return u<c?-1:1}const a=s.compare(n)<0?n:s,h=i.compare(o)<0?i:o;let m=0,l=0;for(let u=1;u<5;u++){Qt(a,h,u/5,this.m_ptSweep);const c=t.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y,this.m_ptSweep.x),g=e.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y,this.m_ptSweep.x),_=Math.abs(c-g);_>m&&(m=_,l=c<g?-1:1)}return l===0?this.errorCracking():l}compareNonHorizontal_(t,e){if(t.m_line.getStartY()===e.m_line.getStartY()&&t.m_line.getStartX()===e.m_line.getStartX())return t.m_line.getEndY()===e.m_line.getEndY()&&t.m_line.getEndX()===e.m_line.getEndX()?this.m_bIsSimple?this.errorCoincident():0:this.compareNonHorizontalUpperEnd_(t,e);if(t.m_line.getEndY()===e.m_line.getEndY()&&t.m_line.getEndX()===e.m_line.getEndX())return this.compareNonHorizontalLowerEnd_(t,e);const s=this.compareNonHorizontalLowerEnd_(t,e),i=this.compareNonHorizontalUpperEnd_(t,e);return s<0&&i<0?-1:s>0&&i>0?1:this.errorCracking()}compareHorizontal1Case1_(t,e){if(t.getEndX()>e.getEndX()){if(e.getEndX()>e.getStartX()&&e.getEndY()-e.getStartY()<2*this.m_tolerance&&t.isIntersectingPoint(e.getEndXY(),this.m_tolerance,!0))return this.errorCracking()}else if((e.getEndY()-e.getStartY())/(e.getEndX()-e.getStartX())*(t.getEndX()-t.getStartX())<this.m_tolerance10&&e.isIntersectingPoint(t.getEndXY(),this.m_tolerance,!0))return this.errorCracking();return 1}compareHorizontal1Case2_(t,e){if(t.getStartX()<e.getStartX()){if(e.getEndX()>e.getStartX()&&e.getEndY()-e.getStartY()<2*this.m_tolerance&&t.isIntersectingPoint(e.getEndXY(),this.m_tolerance,!0))return this.errorCracking()}else if((e.getEndY()-e.getStartY())/(e.getEndX()-e.getStartX())*(t.getStartX()-t.getEndX())<this.m_tolerance10&&e.isIntersectingPoint(t.getStartXY(),this.m_tolerance,!0))return this.errorCracking();return-1}compareHorizontal1Case3_(t,e){const s=y.getNAN();s.setSub(e.getEndXY(),e.getStartXY()),s.rightPerpendicularThis(),s.normalize();const i=y.getNAN();i.setSub(t.getStartXY(),e.getStartXY());const n=y.getNAN();n.setSub(t.getEndXY(),e.getStartXY());const o=i.dotProduct(s),a=n.dotProduct(s),h=Math.abs(o),m=Math.abs(a);if(h<m){if(h<this.m_tolerance10&&e.isIntersectingPoint(t.getStartXY(),this.m_tolerance,!0))return this.errorCracking()}else if(m<this.m_tolerance10&&e.isIntersectingPoint(t.getEndXY(),this.m_tolerance,!0))return this.errorCracking();return o<0&&a<0?-1:o>0&&a>0?1:this.errorCracking()}compareHorizontal1_(t,e){return t.getStartY()===e.getStartY()&&t.getStartX()===e.getStartX()?this.compareHorizontal1Case1_(t,e):t.getEndY()===e.getEndY()&&t.getEndX()===e.getEndX()?this.compareHorizontal1Case2_(t,e):this.compareHorizontal1Case3_(t,e)}compareHorizontal2_(t,e){return t.getEndY()===e.getEndY()&&t.getEndX()===e.getEndX()&&t.getStartY()===e.getStartY()&&t.getStartX()===e.getStartX()?this.m_bIsSimple?this.errorCoincident():0:this.errorCracking()}compareNonHorizontalLowerEnd_(t,e){let s=1;if(t.m_line.getStartY()<e.m_line.getStartY()){s=-1;const m=t;t=e,e=m}const i=t.m_line,n=e.m_line,o=i.getStartX()-n.getStartX(),a=e.m_dxdy*(i.getStartY()-n.getStartY()),h=this.m_tolerance10;return o<a-h?-s:o>a+h?s:n.isIntersectingPoint(i.getStartXY(),this.m_tolerance,!0)?this.errorCracking():o<a?-s:s}compareNonHorizontalUpperEnd_(t,e){let s=1;if(e.m_line.getEndY()<t.m_line.getEndY()){s=-1;const m=t;t=e,e=m}const i=t.m_line,n=e.m_line,o=i.getEndX()-n.getStartX(),a=e.m_dxdy*(i.getEndY()-n.getStartY()),h=this.m_tolerance10;return o<a-h?-s:o>a+h?s:n.isIntersectingPoint(i.getEndXY(),this.m_tolerance,!0)?this.errorCracking():o<a?-s:s}errorCoincident(){this.m_bIntersectionDetected=!0;const t=7;return this.m_nonSimpleResult=new Tt(t,this.m_vertex1,this.m_vertex2),-1}errorCracking(){return this.m_bIntersectionDetected=!0,this.m_bIsSimple?this.m_nonSimpleResult=new Tt(6,this.m_vertex1,this.m_vertex2):(this.m_prev1=v,this.m_prev2=v,this.m_vertex1=v,this.m_vertex2=v),-1}compareSegments_(t,e,s,i){if(s.m_env.vmax<i.m_env.vmin)return-1;if(i.m_env.vmax<s.m_env.vmin)return 1;if(!s.m_bCurve&&!i.m_bCurve){let m=s.m_bHorizontal?1:0;return m|=i.m_bHorizontal?2:0,m===0?this.compareNonHorizontal_(s,i):m===1?this.compareHorizontal1_(s.m_line,i.m_line):m===2?-1*this.compareHorizontal1_(i.m_line,s.m_line):this.compareHorizontal2_(s.m_line,i.m_line)}if(this.m_bIntersectionDetected)return-1;const n=this.m_prevY===this.m_sweepY&&this.m_prevX===this.m_sweepX;let o,a;if(n&&t===this.m_prev1?o=this.m_prevX1:(o=Number.NaN,this.m_prev1=v),n&&e===this.m_prev2?a=this.m_prevX2:(a=Number.NaN,this.m_prev2=v),this.m_prevY=this.m_sweepY,this.m_prevX=this.m_sweepX,Number.isNaN(o)){this.m_prev1=t;const m=s.m_segment.intersectionOfYMonotonicWithAxisX(this.m_sweepY,this.m_sweepX);o=m,this.m_prevX1=m}if(Number.isNaN(a)){this.m_prev2=e;const m=i.m_segment.intersectionOfYMonotonicWithAxisX(this.m_sweepY,this.m_sweepX);a=m,this.m_prevX2=m}const h=Pa(!0,!0,s.m_segment,i.m_segment,this.m_tolerance,!0);return h!==0?h===2?this.m_bIsSimple?this.errorCoincident():s.m_segmentInfo.equals(i.m_segmentInfo)?0:this.errorCracking():this.errorCracking():Math.abs(o-a)<=this.m_tolerance?this.compareTwoSegments_(s.m_segment,i.m_segment):o<a?-1:o>a?1:0}clearIntersectionDetectedFlag(){this.m_bIntersectionDetected=!1}intersectionDetected(){return this.m_bIntersectionDetected}getLastComparedNode(){return this.m_currentNode}getResult(){return this.m_nonSimpleResult}setSweepY(t,e){this.m_sweepY=t,this.m_sweepX=e,this.m_prev1=v,this.m_prev2=v,this.m_vertex1=v,this.m_vertex2=v}compare(t,e,s){if(this.m_bIntersectionDetected)return-1;const i=t.getElement(s),n=e;return this.m_currentNode=s,this.compareSegments(n,n,i,i)}compareSegments(t,e,s,i){let n=this.tryGetCachedEdge_(t);n===null?this.m_vertex1===e?n=this.m_tempSimpleEdge1:(this.m_vertex1=e,n=this.tryCreateCachedEdge_(t),n===null&&(n=this.m_tempSimpleEdge1,this.m_tempSimpleEdge1.m_value=t),this.initSimpleEdge_(n,e)):this.m_vertex1=e;let o=this.tryGetCachedEdge_(s);return o===null?this.m_vertex2===i?o=this.m_tempSimpleEdge2:(this.m_vertex2=i,o=this.tryCreateCachedEdge_(s),o===null&&(o=this.m_tempSimpleEdge2,this.m_tempSimpleEdge2.m_value=s),this.initSimpleEdge_(o,i)):this.m_vertex2=i,this.compareSegments_(e,i,n,o)}onDelete(t){this.tryDeleteCachedEdge_(t)}onSet(t){this.tryDeleteCachedEdge_(t)}onEndSearch(t){this.tryDeleteCachedEdge_(t)}onAddUniqueElementFailed(t){this.tryDeleteCachedEdge_(t)}}class c_{constructor(t,e){this.m_bIntersectionDetected=!1,this.m_pointOfInterest=y.getNAN(),this.m_line1=new ht,this.m_seg1=null,this.m_env=z.constructEmpty(),this.m_vertex1=-1,this.m_currentNode=-1,this.m_minDist=Number.MAX_VALUE,this.m_shape=t,this.m_tolerance=e}getCurrentNode(){return this.m_currentNode}clearIntersectionDetectedFlag(){this.m_bIntersectionDetected=!1,this.m_minDist=Number.MAX_VALUE}intersectionDetected(){return this.m_bIntersectionDetected}setPoint(t){this.m_pointOfInterest.assign(t)}compare(t,e){const s=t.getElement(e);return this.compareVertex(t,e,s)}compareVertex(t,e,s){let i,n=this.m_shape.getSegment(s),o=!0;if(n==null)this.m_shape.queryLineConnector(s,this.m_line1,!0),this.m_env.setCoordsNoNAN(this.m_line1.getStartX(),this.m_line1.getEndX()),n=this.m_line1,i=this.m_line1.getStartY()===this.m_line1.getEndY();else{const h=F.constructEmpty();n.queryLooseEnvelope(h),h.queryIntervalX(this.m_env),i=h.height()===0,o=!1}if(this.m_pointOfInterest.x+this.m_tolerance<this.m_env.vmin)return-1;if(this.m_pointOfInterest.x-this.m_tolerance>this.m_env.vmax)return 1;if(i)return this.m_currentNode=e,this.m_bIntersectionDetected=!0,0;let a=0;if(o){ag(this.m_line1);const h=this.m_line1.getStartXY(),m=new y;m.setSub(this.m_line1.getEndXY(),h),m.rightPerpendicularThis();const l=new y;l.setSub(this.m_pointOfInterest,h),a=m.dotProduct(l),a/=m.length()}else a=n.intersectionOfYMonotonicWithAxisX(this.m_pointOfInterest.y,this.m_pointOfInterest.x)-this.m_pointOfInterest.x;return a<10*-this.m_tolerance?-1:a>10*this.m_tolerance?1:(n.isIntersectingPoint(this.m_pointOfInterest,this.m_tolerance)&&(Math.abs(a)<this.m_minDist&&(this.m_currentNode=e,this.m_minDist=a),this.m_bIntersectionDetected=!0),a<0?-1:a>0?1:0)}}class _n{constructor(t,e){this.m_lists=new wt(!1),this.m_hash=e,this.m_hashBuckets=new Int32Array(t),this.m_hashBuckets.fill(_n.st_nullNode()),this.m_bitFilter=new Int32Array(10*t+31>>5)}reserveElements(t){this.m_lists.reserveLists(Math.min(this.m_hashBuckets.length,t)),this.m_lists.reserveNodes(t)}addElement(t,e){e===void 0&&(e=this.m_hash.getHash(t));const s=e%(this.m_bitFilter.length<<5);this.m_bitFilter[s>>5]|=1<<(31&s);const i=e%this.m_hashBuckets.length;let n=this.m_hashBuckets[i];return n===wt.st_nullNode()&&(n=this.m_lists.createList(),this.m_hashBuckets[i]=n),this.m_lists.addElement(n,t)}deleteElement(t,e){e===void 0&&(e=this.m_hash.getHash(t));const s=e%this.m_hashBuckets.length,i=this.m_hashBuckets[s];i===wt.st_nullNode()&&H("");let n=this.m_lists.getFirst(i),o=wt.st_nullNode();for(;n!==wt.st_nullNode();){const a=this.m_lists.getData(n),h=this.m_lists.getNext(n);a===t?(this.m_lists.deleteElementDirect(i,o,n),this.m_lists.getFirst(i)===wt.st_nullNode()&&(this.m_lists.deleteList(i),this.m_hashBuckets[s]=wt.st_nullNode())):o=n,n=h}}getFirstInBucket(t){const e=t%(this.m_bitFilter.length<<5);if(!(this.m_bitFilter[e>>5]&1<<(31&e)))return wt.st_nullNode();const s=t%this.m_hashBuckets.length,i=this.m_hashBuckets[s];return i===wt.st_nullNode()?wt.st_nullNode():this.m_lists.getFirst(i)}getNextInBucket(t){return this.m_lists.getNext(t)}findNode(t){const e=this.m_hash.getHash(t);let s=this.getFirstInBucket(e);for(;s!==wt.st_nullNode();){const i=this.m_lists.getData(s);if(this.m_hash.equal(i,t))return s;s=this.m_lists.getNext(s)}return wt.st_nullNode()}deleteNode(t){const e=this.getElement(t),s=this.m_hash.getHash(e)%this.m_hashBuckets.length,i=this.m_hashBuckets[s];i===wt.st_nullNode()&&H(""),this.m_lists.deleteElementSearch(i,t),this.m_lists.getFirst(i)===wt.st_nullNode()&&(this.m_lists.deleteList(i),this.m_hashBuckets[s]=wt.st_nullNode())}getElement(t){return this.m_lists.getData(t)}static st_nullNode(){return wt.st_nullNode()}clear(){b(0)}size(){return this.m_lists.getNodeCount()}dbgPrintBucketHistogram(){}}function g_(r,t,e,s,i){const n=new p_(i);return n.m_shape=r,n.m_sqrTolerance=t*t,n.m_cellSize=2*t,n.m_invCellSize=1/n.m_cellSize,n.m_geometry=e,n.m_bTrackChanges=s,n.m_bHasSegmentParentage=r.hasSegmentParentage(),n.clusterNonReciprocal()}function zm(r,t,e,s,i){const n=r-e,o=t-s;return n*n+o*o<=i}function ux(){return{pt:new y,weight:0,rank:0,bMerged:!1}}function __(r,t,e,s,i,n){const o=ux(),a=e+i;let h=!1,m=r.x;r.x!==t.x&&(s===n&&(m=(r.x*e+t.x*i)/a),h=!0);let l=r.y;return r.y!==t.y&&(s===n&&(l=(r.y*e+t.y*i)/a),h=!0),s!==n?s>n?(o.rank=s,o.weight=e,o.pt=r):(o.rank=n,o.weight=i,o.pt=t):(o.pt.setCoords(m,l),o.weight=a,o.rank=s),o.bMerged=h,o}function cx(r,t,e,s,i,n,o,a,h){const m=r.equals(t);if(s>n)return o.assignCopy(r),h[0]=s,a[0]=e,m;if(n>s)return o=t,h[0]=n,a[0]=i,m;o.assignCopy(r);const l=__(r.getXY(),t.getXY(),e,s,i,n);return o.setXY(l.pt),a[0]=l.weight,h[0]=l.rank,m}function gx(r,t,e,s,i){const n=new p_(i);return n.m_shape=r,n.m_sqrTolerance=t*t,n.m_cellSize=2*t,n.m_invCellSize=1/n.m_cellSize,n.m_geometry=e,n.m_bTrackChanges=!1,n.needsClustering()}function d_(r,t){const e=lp(r);return hp(e,t)}class ku{constructor(t,e,s,i,n){this.m_workPt=new y,this.m_shape=t,this.m_sqrTolerance=s,this.m_invCellSize=i,this.m_origin=e.clone(),this.m_hashValues=n}getHash(t){return this.m_shape.getUserIndex(t,this.m_hashValues)}calculateHashFromVertex(t){this.m_shape.queryXY(t,this.m_workPt);const e=this.m_workPt.x-this.m_origin.x,s=Math.trunc(e*this.m_invCellSize+.5),i=this.m_workPt.y-this.m_origin.y;return d_(s,Math.trunc(i*this.m_invCellSize+.5))}equal(t,e){return b(0),!1}}class p_{constructor(t){this.m_origin=y.getNAN(),this.m_sqrTolerance=0,this.m_cellSize=0,this.m_invCellSize=0,this.m_geometry=v,this.m_bucketArray=j(4,Number.NaN),this.m_bucketHash=j(4,Number.NaN),this.m_dbgCandidateCheckCount=0,this.m_nsr=new Tt,this.m_hashValues=-1,this.m_newClusters=-1,this.m_bTrackChanges=!1,this.m_bHasSegmentParentage=!1,this.m_shape=null,this.m_clusters=new wt,this.m_hashFunction=null,this.m_hashTable=null,this.m_progressCounter=0,this.m_progressTracker=t}progress_(){}collectClusterCandidates(t,e){const s=y.getNAN();this.m_shape.queryXY(t,s);const i=(s.x-this.m_origin.x)*this.m_invCellSize,n=(s.y-this.m_origin.y)*this.m_invCellSize,o=Math.trunc(i),a=Math.trunc(n);let h=0;for(let m=0;m<=1;m+=1)for(let l=0;l<=1;l+=1){const u=d_(o+m,a+l),c=this.m_hashTable.getFirstInBucket(u);c!==_n.st_nullNode()&&(this.m_bucketArray[h]=c,this.m_bucketHash[h]=u,h++)}for(let m=h-1;m>=1;m--){const l=this.m_bucketArray[m];for(let u=m-1;u>=0;u--)if(l===this.m_bucketArray[u]){this.m_bucketHash[u]=-1,h--,m!==h&&(this.m_bucketHash[m]=this.m_bucketHash[h],this.m_bucketArray[m]=this.m_bucketArray[h]);break}}for(let m=0;m<h;m++)this.collectNearestNeighbourCandidates(t,this.m_bucketHash[m],s,this.m_bucketArray[m],e)}collectNearestNeighbourCandidates(t,e,s,i,n){const o=y.getNAN();for(let a=i;a!==_n.st_nullNode();a=this.m_hashTable.getNextInBucket(a)){const h=this.m_hashTable.getElement(a);t===h||e!==-1&&this.m_shape.getUserIndex(h,this.m_hashValues)!==e||(this.m_shape.queryXY(h,o),zm(s.x,s.y,o.x,o.y,this.m_sqrTolerance)&&n.push(a))}}mergeClusters(t,e,s){let i=this.m_shape.getUserIndex(t,this.m_newClusters);const n=this.m_shape.getUserIndex(e,this.m_newClusters);i===-1&&(i=this.m_clusters.createList(),this.m_clusters.addElement(i,t),this.m_shape.setUserIndex(t,this.m_newClusters,i)),n===-1?this.m_clusters.addElement(i,e):this.m_clusters.concatenateLists(i,n),this.m_shape.setUserIndex(e,this.m_newClusters,At.impossibleIndex2());const o=this.mergeVertices(t,e);if(s){const a=this.m_hashFunction.calculateHashFromVertex(t);this.m_shape.setUserIndex(t,this.m_hashValues,a)}return o}mergeVertices(t,e){const s=y.getNAN();this.m_shape.queryXY(t,s);const i=y.getNAN();this.m_shape.queryXY(e,i);const n=this.m_shape.getRank(t),o=this.m_shape.getRank(e),a=this.m_shape.getWeight(t),h=this.m_shape.getWeight(e);let m,l,u,c,g=!1;if(n===o?(m=n,l=a+h,u=s.x,s.x!==i.x&&(u=(s.x*a+i.x*h)/l,g=!0),c=s.y,s.y!==i.y&&(c=(s.y*a+i.y*h)/l,g=!0)):(n>o?(u=s.x,c=s.y,l=a,m=n):(u=i.x,c=i.y,l=h,m=o),g=!s.equals(i)),g&&(this.m_shape.setXYMonotonic(t,u,c),this.m_bTrackChanges&&this.m_shape.setGeometryModifiedWithVertex(t,!0),this.m_bHasSegmentParentage)){const _=this.m_shape.getSegmentParentageBreakVertex(t)||this.m_shape.getSegmentParentageBreakVertex(e);this.m_shape.setSegmentParentageBreakVertex(t,_),this.m_shape.setSegmentParentageBreakVertex(e,_)}return this.m_shape.setWeight(t,l),this.m_shape.setRank(t,m),g}needsClustering(){const t={stack:[],error:void 0,hasError:!1};try{Te(t,$c(()=>{this.m_hashTable=null,this.m_hashFunction=null,this.m_shape.removeUserIndex(this.m_hashValues),this.m_shape.removeUserIndex(this.m_newClusters)}),!1);const e=this.m_shape.getSelectedCount(),s=this.m_shape.getEnvelope2D(this.m_progressTracker);this.m_origin.assign(s.getLowerLeft());const i=Math.max(s.height(),s.width())/(Ie()-1);this.m_cellSize<i&&(this.m_cellSize=i,this.m_invCellSize=1/this.m_cellSize),this.m_clusters.clear(),this.m_clusters.reserveLists(this.m_shape.getSelectedCount()/3+1),this.m_clusters.reserveNodes(this.m_shape.getSelectedCount()/3+1),this.m_hashValues=this.m_shape.createUserIndex(),this.m_newClusters=this.m_shape.createUserIndex(),this.m_hashFunction=new ku(this.m_shape,this.m_origin,this.m_sqrTolerance,this.m_invCellSize,this.m_hashValues),this.m_hashTable=new _n(4*e/3,this.m_hashFunction),this.m_hashTable.reserveElements(this.m_shape.getSelectedCount());let n=!1;for(let o=0;o<2;o++){const a=[],h=this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);for(let m=h.next();m!==v;m=h.next()){if(this.progress_(),o>0&&this.m_shape.getUserIndex(m,this.m_newClusters)===At.impossibleIndex2())continue;let l;if(o===0?(l=this.m_hashFunction.calculateHashFromVertex(m),this.m_shape.setUserIndex(m,this.m_hashValues,l)):l=this.m_shape.getUserIndex(m,this.m_hashValues),this.collectClusterCandidates(m,a),a.length!==0){for(let u=0,c=a.length;u<c;u++){this.progress_();const g=a[u],_=this.m_hashTable.getElement(g);if(this.m_hashTable.deleteNode(g),!this.m_shape.isEqualXY(m,_))return this.m_nsr=new Tt(5,this.m_shape.getVertexIndex(m),this.m_shape.getVertexIndex(_)),n=!0,n;this.mergeClusters(m,_,!1)}a.length=0}o===0&&this.m_hashTable.addElement(m,l)}}return n}catch(e){t.error=e,t.hasError=!0}finally{li(t)}}clusterNonReciprocal(){const t=this.m_shape.getSelectedCount(),e=this.m_shape.getEnvelope2D(this.m_progressTracker);this.m_origin=e.getLowerLeft();const s=Math.max(e.height(),e.width())/(Ie()-1);this.m_cellSize<s&&(this.m_cellSize=s,this.m_invCellSize=1/this.m_cellSize),this.m_clusters.clear(),this.m_clusters.reserveLists(Math.trunc(this.m_shape.getSelectedCount()/3+1)),this.m_clusters.reserveNodes(Math.trunc(this.m_shape.getSelectedCount()/3+1)),this.m_hashValues=this.m_shape.createUserIndex(),this.m_newClusters=this.m_shape.createUserIndex(),this.m_hashFunction=new ku(this.m_shape,this.m_origin,this.m_sqrTolerance,this.m_invCellSize,this.m_hashValues),this.m_hashTable=new _n(Math.trunc(4*t/3),this.m_hashFunction),this.m_hashTable.reserveElements(this.m_shape.getSelectedCount());let i=!1;{const n=this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);for(let o=n.next();o!==v;o=n.next()){this.progress_();const a=this.m_hashFunction.calculateHashFromVertex(o);this.m_shape.setUserIndex(o,this.m_hashValues,a),this.m_hashTable.addElement(o,a)}}{const n=[],o=this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);for(let a=o.next();a!==v;a=o.next()){if(this.m_shape.getUserIndex(a,this.m_newClusters)===At.impossibleIndex2())continue;let h=this.m_shape.getUserIndex(a,this.m_hashValues);this.m_hashTable.deleteElement(a,h);let m=!1;for(;this.collectClusterCandidates(a,n),n.length!==0;){let l=0;for(let u=0,c=n.length;u<c;u++){this.progress_();const g=n[u],_=this.m_hashTable.getElement(g);this.m_hashTable.deleteNode(g);const d=u+1===c;l|=this.mergeClusters(a,_,d)?1:0}if(m||=l!==0,i||=l!==0,n.length=0,!l)break}m&&(h=this.m_shape.getUserIndex(a,this.m_hashValues)),this.m_hashTable.addElement(a,h)}n.length=0}return i&&this.applyClusterPositions_(),this.m_hashTable=null,this.m_hashFunction=null,this.m_shape.removeUserIndex(this.m_hashValues),this.m_shape.removeUserIndex(this.m_newClusters),i}applyClusterPositions_(){const t=y.getNAN();for(let e=this.m_clusters.getFirstList();e!==wt.st_nullNode();e=this.m_clusters.getNextList(e)){let s=this.m_clusters.getFirst(e);const i=this.m_clusters.getElement(s);this.m_shape.queryXY(i,t);const n=this.m_shape.getRank(i),o=this.m_shape.getWeight(i);for(s=this.m_clusters.getNext(s);s!==wt.st_nullNode();s=this.m_clusters.getNext(s)){const a=this.m_clusters.getElement(s);if(this.m_bTrackChanges?this.m_shape.isEqualXYPoint2D(a,t)||(this.m_shape.setXYMonotonicPoint2D(a,t),this.m_shape.setGeometryModifiedWithVertex(a,!0)):this.m_shape.setXYMonotonicPoint2D(a,t),this.m_bHasSegmentParentage){const h=this.m_shape.getSegmentParentageBreakVertex(i)||this.m_shape.getSegmentParentageBreakVertex(a);this.m_shape.setSegmentParentageBreakVertex(i,h),this.m_shape.setSegmentParentageBreakVertex(a,h)}this.m_shape.setWeight(a,o),this.m_shape.setRank(a,n)}}}}class He{constructor(){this.m_inputParts=[],this.m_resultParts1=[],this.m_resultParts2=[],this.m_resultSegments=[],this.m_freeSegments=[],this.m_inputSegments=[],this.m_param1=[],this.m_param2=[],this.m_tolerance=0,this.m_toleranceZ=0,this.m_point=new st,this.m_pointWeight=1,this.m_maxDensifyLimit=0,this.m_pointRank=0,this.m_changed1=!1,this.m_changed2=!1,this.m_adaptiveDensify=!1}clear(){this.freeAllResultSegments(),this.m_inputSegments.length=0,this.m_inputParts.length=0,this.m_resultParts1.length=0,this.m_resultParts2.length=0,this.m_param1.length=0,this.m_param2.length=0,this.m_adaptiveDensify=!1,this.m_changed1=!1,this.m_changed2=!1}newIntersectionPart_(t,e,s,i,n,o,a,h,m,l){return dx(t,e,s,i,n,o,a,h,m,l)}pushSegment(t,e,s,i,n,o,a,h,m,l){return this.m_inputParts.push(this.newIntersectionPart_(this.m_inputSegments.length,e,s,i,n,o,a,h,m,l)),this.m_inputSegments.push(t),this.m_inputParts.length-1}getResultSegmentCount(t){return this.m_adaptiveDensify?t===0?this.m_param1.length-1:this.m_param2.length-1:t===0?this.m_resultParts1.length:this.m_resultParts2.length}getResultPart_(t,e){return t===0?this.m_resultParts1[e]:this.m_resultParts2[e]}getResultSegment(t,e){return this.m_resultSegments[this.getResultPart_(t,e).segmentIndex].get()}getSegmentChanged(t){return t===0?this.m_changed1:this.m_changed2}getResultSegmentStartPointWeight(t,e){return this.getResultPart_(t,e).weightStart}getResultSegmentStartPointRank(t,e){return this.getResultPart_(t,e).rankStart}getResultSegmentSegmentParentage(t,e){return this.getResultPart_(t,e).segmentParentage}getResultSegmentStartPointIsBreak(t,e){return this.getResultPart_(t,e).u.bBreakStart}getResultSegmentEndPointWeight(t,e){return this.getResultPart_(t,e).weightEnd}getResultSegmentEndPointRank(t,e){return this.getResultPart_(t,e).rankEnd}getResultSegmentEndPointIsBreak(t,e){return this.getResultPart_(t,e).u.bBreakEnd}getResultSegmentInteriorRank(t,e){return this.getResultPart_(t,e).rankInterior}getResultSegmentInteriorWeight(t,e){return this.getResultPart_(t,e).weightInterior}getResultPoint(){return this.m_point}getResultPointWeight(){return this.m_pointWeight}getResultPointRank(){return this.m_pointRank}getResultPointChanged(){return this.m_changed2}intersectLines(t,e){this.m_inputSegments.length!==2&&$(""),this.m_changed1=!1,this.m_changed2=!1,this.m_tolerance=t;const s=yt(t*He.c_smallToleranceFactor);let i=!1;const n=this.m_inputParts[0],o=this.m_inputParts[1],a=this.m_inputSegments[n.segmentIndex],h=this.m_inputSegments[o.segmentIndex];if(e||5&Gn(!0,a,h,t,!0)){const m=en(!0,a,h,null,this.m_param1,this.m_param2,t);m===0&&$("");const l=new Array(m);for(let S=0;S<m;++S)l[S]=y.getNAN();const u=new Float64Array(m),c=new Int32Array(m),g=new Array(m),_=new Array(m);for(let S=0;S<m;++S)g[S]=Wo(),_[S]=Wo();for(let S=0;S<m;S++){const I=this.m_param1[S],w=this.m_param2[S];let D,N=n.rankInterior,A=n.weightInterior;I===0?(N=n.rankStart,A=n.weightStart,D=n.u.bBreakStart):I===1?(N=n.rankEnd,A=n.weightEnd,D=n.u.bBreakEnd):(this.m_changed1=!0,D=!1);let M,G=o.rankInterior,q=o.weightInterior;w===0?(G=o.rankStart,q=o.weightStart,M=o.u.bBreakStart):w===1?(G=o.rankEnd,q=o.weightEnd,M=o.u.bBreakEnd):(this.m_changed2=!0,M=!1);const V=N,k=G;let Y=1,U=0,X=y.getNAN();if(V===k){const B=a.getCoord2D(I),W=h.getCoord2D(w);Y=A+q,U=N,Qt(B,W,q/Y,X);const Z=y.sqrDistance(X,B),gt=y.sqrDistance(X,W);g[S].bBigMove=Z>s,_[S].bBigMove=gt>s,this.m_changed1||B.equals(X)||(this.m_changed1=!0),this.m_changed2||W.equals(X)||(this.m_changed2=!0)}else if(V>k){X=a.getCoord2D(I);const B=h.getCoord2D(w);Y=A,U=N;const W=y.sqrDistance(X,B);g[S].bBigMove=!1,_[S].bBigMove=W>s,this.m_changed2||B.equals(X)||(this.m_changed2=!0)}else{X=h.getCoord2D(w),Y=q,U=G;const B=a.getCoord2D(I),W=y.sqrDistance(X,B);g[S].bBigMove=W>s,_[S].bBigMove=!1,this.m_changed1||B.equals(X)||(this.m_changed1=!0)}l[S].assign(X),u[S]=Y,c[S]=U,g[S].bIsBreak=D||M,_[S].bIsBreak=D||M,i||=g[S].bBigMove||_[S].bBigMove}const d=n.rankInterior,p=n.weightInterior;let f=0,x=-1;for(let S=0;S<=m;S++){const I=S<m?this.m_param1[S]:1;if(I!==f){const w=this.allocResultSegment(),D=this.m_resultSegments[w];let N,A,M,G;a.queryCut(f,I,D,!1),D.get().snapControlPoints(t*t);let q=!1,V=!1,k=!1,Y=!1,U=!1,X=y.getNAN(),B=y.getNAN();x!==-1?(A=c[x],N=u[x],q=g[x].bBigMove,X.assign(l[x]),k=g[x].bIsBreak,U=!0):(N=n.weightStart,A=n.rankStart,X=D.get().getStartXY(),k=n.u.bBreakStart),S<m?(G=c[S],M=u[S],V=g[S].bBigMove,B.assign(l[S]),Y=g[S].bIsBreak,U=!0):(M=n.weightEnd,G=n.rankEnd,B=D.get().getEndXY(),Y=n.u.bBreakEnd),U&&D.get().setCoordsForIntersector(X,B,!0),this.m_resultParts1.push(this.newIntersectionPart_(w,N,A,M,G,p,d,k,Y,n.segmentParentage));const W=this.m_resultParts1.at(-1);W.u.bBigMoveStart=q,W.u.bBigMoveEnd=V,f=I,x=S}else x===-1&&(x=S)}const E=j(m,0);for(let S=0;S<m;S++)E[S]=S;m>2?(E.sort((S,I)=>this.m_param2[S]<this.m_param2[I]?-1:this.m_param2[S]>this.m_param2[I]?1:0),Mr(this.m_param2)):m===2&&this.m_param2[0]>this.m_param2[1]&&(this.m_param2[1]=O(this.m_param2[0],this.m_param2[0]=this.m_param2[1]),E[1]=O(E[0],E[0]=E[1]));const P=o.rankInterior,C=o.weightInterior;f=0,x=-1;for(let S=0;S<=m;S++){const I=S<m?this.m_param2[S]:1;if(I!==f){const w=this.allocResultSegment(),D=this.m_resultSegments[w];let N,A,M,G;h.queryCut(f,I,D,!1),D.get().snapControlPoints(t*t);let q=y.getNAN(),V=y.getNAN(),k=!1,Y=!1,U=!1,X=!1,B=!1;if(x!==-1){const Z=E[x];N=u[Z],A=c[Z],q.assign(l[Z]),U=_[Z].bBigMove,k=_[Z].bIsBreak,B=!0}else N=o.weightStart,A=o.rankStart,q=D.get().getStartXY(),k=o.u.bBreakStart;if(S!==m){const Z=E[S];M=u[Z],G=c[Z],V.assign(l[Z]),X=_[Z].bBigMove,Y=_[Z].bIsBreak,B=!0}else M=o.weightEnd,G=o.rankEnd,V=D.get().getEndXY(),Y=o.u.bBreakEnd;B&&D.get().setCoordsForIntersector(q,V,!0),this.m_resultParts2.push(this.newIntersectionPart_(w,N,A,M,G,C,P,k,Y,o.segmentParentage));const W=this.m_resultParts2.at(-1);W.u.bBigMoveStart=U,W.u.bBigMoveEnd=X,f=I,x=S}else x===-1&&(x=S)}return i?3:2}return 0}intersectLines3D(t,e,s,i){return b(0),1}intersect2D(t,e){const s=this.m_inputParts[0],i=this.m_inputParts[1],n=this.m_inputSegments[s.segmentIndex].getGeometryType(),o=this.m_inputSegments[i.segmentIndex].getGeometryType();return n!==T.enumLine||o!==T.enumLine?new px(this).intersectCurves(t,e):this.intersectLines(t,e)}intersect2DEx(t,e,s,i,n){this.m_point.assignCopy(e),this.m_inputSegments.length!==1&&$(""),this.m_tolerance=t,this.m_changed1=!1,this.m_changed2=!1;const o=yt(t*He.c_smallToleranceFactor);let a=!1;const h=this.m_inputParts[0],m=this.m_inputSegments[h.segmentIndex];if(n||m.isIntersectingPoint(e.getXY(),t,!0)){this.m_param1=j(16,Number.NaN);const l=m.getClosestCoordinate(e.getXY(),!1);this.m_param1[0]=l;let u=h.rankInterior,c=h.weightInterior;l===0?(u=h.rankStart,c=h.weightStart):l===1?(u=h.rankEnd,c=h.weightEnd):this.m_changed1=!0;let g=u;const _=s,d=i;g===_&&m.isCurve()&&(g=_+1);let p=1,f=0;const x=new y;if(g===_){const S=m.getCoord2D(l),I=e.getXY();p=c+d,f=u,Qt(S,I,d/p,x),this.m_changed1||S.equals(x)||(this.m_changed1=!0),this.m_changed2||I.equals(x)||(this.m_changed2=!0),a=y.sqrDistance(x,S)>o}else g>_?(x.assign(m.getCoord2D(l)),p=c,f=u,this.m_changed2||x.equals(e.getXY())||(this.m_changed2=!0)):(x.assign(m.getCoord2D(l)),p=d,f=_,this.m_changed1||x.equals(e.getXY())||(this.m_changed1=!0),a=y.sqrDistance(x,e.getXY())>o);let E=0,P=-1;const C=1;for(let S=0;S<=C;S++){const I=S<C?this.m_param1[0]:1;if(I!==E){const w=this.allocResultSegment(),D=this.m_resultSegments[w];m.queryCut(E,I,D),D.get().snapControlPoints(t*t);let N=h.weightStart,A=h.weightEnd,M=h.rankStart,G=h.rankEnd;const q=h.rankInterior,V=h.weightInterior;let k=h.u.bBreakStart,Y=h.u.bBreakEnd;P!==-1&&(N=p,M=f,k=!0,D.get().setCoordsForIntersector(x,D.get().getEndXY(),!0)),S!==C&&(A=p,G=f,Y=!0,D.get().setCoordsForIntersector(D.get().getStartXY(),x,!0)),E=I,this.m_resultParts1.push(this.newIntersectionPart_(w,N,M,A,G,V,q,k,Y,h.segmentParentage))}P=S}return this.m_point.setXY(x),this.m_pointWeight=p,this.m_pointRank=f,a?3:2}return 0}intersect3D(t,e,s,i){return b(0),1}intersect3DEx(t,e,s,i,n,o,a){return b(0),1}getTolerance(){return this.m_tolerance}freeAllResultSegments(){this.m_resultSegments.length=0,this.m_freeSegments.length=0}freeResultSegment(t){this.m_freeSegments.push(t)}allocResultSegment(){if(this.m_freeSegments.length)return this.m_freeSegments.pop();const t=new it,e=this.m_resultSegments.length;return this.m_resultSegments.push(t),e}allocResultSegmentFromBuffer(t){if(this.m_freeSegments.length)return this.m_freeSegments.pop();const e=new it({copy:t}),s=this.m_resultSegments.length;return this.m_resultSegments.push(e),s}allocResultSegmentFromSegment(t){if(this.m_freeSegments.length)return this.m_freeSegments.pop();const e=new it({segment:t}),s=this.m_resultSegments.length;return this.m_resultSegments.push(e),s}}function _x(r,t){return{bBigMoveStart:!1,bBigMoveEnd:!1,bBreakStart:r,bBreakEnd:t}}function dx(r,t,e,s,i,n,o,a,h,m){return{segmentIndex:r,weightStart:t,rankStart:e,weightEnd:s,rankEnd:i,weightInterior:n,rankInterior:o,segmentParentage:m,u:_x(a,h)}}function Wo(){return{bBigMove:!1,bIsBreak:!1}}He.maxWeight=.1*Number.MAX_VALUE,He.c_smallToleranceFactor=.01,He.c_maxGeometryTypeToRankDelta=8;let Lu=class{constructor(){this.start=null,this.end=null,this.equalEdge=null,this.segmentIndex=-1,this.segmentParentage=-1,this.weight=0,this.rank=0}hasSegment(){return this.segmentIndex>=0}transferAttributes(r,t,e){if(t.getDescription().getAttributeCount()===1)return;const s=r.parent.m_resultSegments[this.segmentIndex].get().getStartXY(),i=r.parent.m_resultSegments[this.segmentIndex].get().getEndXY(),n=new st;t.queryStart(n),e?(n.setXY(s),r.parent.m_resultSegments[this.segmentIndex].get().setStart(n)):(n.setXY(i),r.parent.m_resultSegments[this.segmentIndex].get().setEnd(n)),t.queryEnd(n),e?(n.setXY(i),r.parent.m_resultSegments[this.segmentIndex].get().setEnd(n)):(n.setXY(s),r.parent.m_resultSegments[this.segmentIndex].get().setStart(n))}copyFromWhenOverlap(r,t,e){this.equalEdge=t,t.equalEdge=this,this.segmentIndex=r.parent.allocResultSegmentFromBuffer(r.parent.m_resultSegments[t.segmentIndex]),this.segmentParentage=t.segmentParentage,this.weight=t.weight,this.rank=t.rank,e?(this.start.copyFrom(t.start),this.end.copyFrom(t.end)):(this.start.copyFrom(t.end),this.end.copyFrom(t.start),r.parent.m_resultSegments[this.segmentIndex].get().reverse())}getEnd(){return this.end}getNextInChain(){return this.end.nextInChain}getPrevInChain(){return this.start.prevInChain}};class Bu{constructor(){this.hash=0,this.pt=new y,this.prevInChain=null,this.nextInChain=null,this.prevInHash=null,this.nextInHash=null,this.prevEqual=null,this.nextEqual=null,this.weight=0,this.rank=0,this.bBigMove=!1,this.bIsBreak=!1}copyFrom(t){this.pt.assign(t.pt),this.weight=t.weight,this.rank=t.rank,this.bBigMove=t.bBigMove,this.bIsBreak=t.bIsBreak}nextNode(){return this.nextInChain?this.nextInChain.end:null}prevNode(){return this.prevInChain?this.prevInChain.start:null}equalListHead(){let t=this;for(;t.prevEqual!==null;t=t.prevEqual);return t}}function gi(r,t,e,s){return{edge1:r,edge2:t,recursion:e,bIsIntersecting:s}}class px{constructor(t){this.m_pairs=[],this.m_chainOrigin1=null,this.m_chainOrigin2=null,this.m_newNodes=[],this.m_hashTableOfEquals=[],this.m_hashTableOfEqualsSize=0,this.m_origin=new y,this.m_cell=new y,this.parent=t}addSegment(t,e,s,i,n,o,a,h,m,l,u){const c=this.newNode(this.parent.m_resultSegments[t].get().getStartXY(),s,i,m),g=this.newNode(this.parent.m_resultSegments[t].get().getEndXY(),n,o,l);this.newEdge(c,g,t,a,h,u),this.m_chainOrigin1===null?this.m_chainOrigin1=c:this.m_chainOrigin2===null?this.m_chainOrigin2=c:b(0)}intersectCurvesHelper(t,e,s,i,n){const o=this.getSegment(t).get(),a=this.getSegment(e).get();if(o.isDegenerate(0)||a.isDegenerate(0))return 0;const h=this.tryOverlapIntersectCurves(t,e,s,i);if(h!==0)return h;const m=yt(.01*s);let l=!1,u=this.processSharpCorners(o,a,s,n>4);const c=u>0;if(!c){if(!(i||5&Pa(!0,!1,o,a,s,!0)))return 0;u=en(!0,o,a,null,this.parent.m_param1,this.parent.m_param2,s)}u===0&&$("");const g=o.getGeometryType(),_=a.getGeometryType(),d=R(y,u),p=R(y,u),f=j(u,Number.NaN),x=j(u,Number.NaN),E=j(u,Number.NaN),P=j(u,Number.NaN),C=Cl(Wo,u),S=Cl(Wo,u);let I=!1,w=!1;for(let X=0;X<u;X++){const B=this.parent.m_param1[X],W=this.parent.m_param2[X];let Z=t.rank,gt=t.weight,at=!0,Q=!1;B===0?(Z=t.start.rank,gt=t.start.weight,Q=t.start.bIsBreak):B===1?(Z=t.end.rank,gt=t.end.weight,Q=t.end.bIsBreak):(I=!0,at=!1);let rt=e.rank,nt=e.weight,ot=!1,Gt=!0;W===0?(rt=e.start.rank,nt=e.start.weight,ot=e.start.bIsBreak):W===1?(rt=e.end.rank,nt=e.end.weight,ot=e.end.bIsBreak):(w=!0,Gt=!1);let Ot=Z,Ht=rt;if(Ot===Ht&&(Ot*=He.c_maxGeometryTypeToRankDelta,Ht*=He.c_maxGeometryTypeToRankDelta,Ot+=on(g,o,!1),Ht+=on(_,a,!1)),at&&Gt&&Ht===Ot){const js=o.getCoord2D(B),Ya=a.getCoord2D(W);js.equals(Ya)&&(Ht=Ot-1)}let It=1,Jt=0,Wt=1,Re=0;const $t=new y,qe=new y,as=o.getCoord2D(B),Ke=a.getCoord2D(W);if(c&&y.distance(as,Ke)>s)$t.setCoordsPoint2D(as),qe.setCoordsPoint2D(Ke),It=gt,Wt=nt,Jt=Z,Re=rt,C[X].bBigMove=!1,S[X].bBigMove=!1,Q=!0,ot=!0;else if(Ot===Ht){Wt=It=gt+nt,Re=Jt=Z,Qt(as,Ke,nt/It,$t),qe.setCoordsPoint2D($t);const js=y.sqrDistance($t,as),Ya=y.sqrDistance($t,Ke);C[X].bBigMove=js>m,S[X].bBigMove=Ya>m,I||as.equals($t)||(I=!0),w||Ke.equals(qe)||(w=!0)}else if(Ot>Ht){$t.setCoordsPoint2D(as),qe.setCoordsPoint2D($t),Wt=It=gt,Re=Jt=Z;const js=y.sqrDistance($t,Ke);C[X].bBigMove=!1,S[X].bBigMove=js>m,w||Ke.equals(qe)||(w=!0)}else{qe.setCoordsPoint2D(Ke),$t.setCoordsPoint2D(qe),Wt=It=nt,Re=Jt=rt;const js=y.sqrDistance($t,as);C[X].bBigMove=js>m,S[X].bBigMove=!1,I||as.equals($t)||(I=!0)}d[X].assign($t),p[X].assign(qe),f[X]=It,x[X]=Wt,E[X]=Jt,P[X]=Re,C[X].bIsBreak=Q||ot,S[X].bIsBreak=Q||ot,l||=C[X].bBigMove||S[X].bBigMove,X>0&&(B!==this.parent.m_param1[X-1]&&W!==this.parent.m_param2[X-1]||(E[X]<=E[X-1]?(d[X].assign(p[X-1]),f[X]=x[X-1],E[X]=P[X-1],p[X].assign(p[X-1]),x[X]=x[X-1],P[X]=P[X-1],C[X].bBigMove||=C[X-1].bBigMove,S[X].bBigMove||=S[X-1].bBigMove,C[X].bIsBreak||=C[X-1].bIsBreak,S[X].bIsBreak||=S[X-1].bIsBreak):(d[X-1].assign(d[X]),f[X-1]=f[X],E[X-1]=E[X],p[X-1].assign(p[X]),x[X-1]=x[X],P[X-1]=P[X],C[X-1].bBigMove||=C[X].bBigMove,S[X-1].bBigMove||=S[X].bBigMove,C[X-1].bIsBreak||=C[X].bIsBreak,S[X-1].bIsBreak||=S[X].bIsBreak)))}if(!(I||w||u!==2||g===T.enumLine&&_===T.enumLine)){if(this.processDoublyConnectedEdges(t,e,n+1,s))return this.parent.m_changed1=!0,this.parent.m_changed2=!0,2;b(0)}this.parent.m_changed1||=I,this.parent.m_changed2||=w;let D=t,N=t.end.weight,A=t.end.rank,M=t.end.bBigMove,G=t.end.bIsBreak,q=0,V=-1;for(let X=0;X<=u;X++){const B=X<u?this.parent.m_param1[X]:1;if(B!==q){const W=this.parent.allocResultSegment(),Z=this.parent.m_resultSegments[W];let gt,at,Q,rt;o.queryCut(q,B,Z,!1),Z.get().snapControlPoints(s*s);let nt=!1,ot=!1,Gt=!1,Ot=!1;const Ht=new y,It=new y;V!==-1?(at=E[V],gt=f[V],Gt=C[V].bBigMove,nt=C[V].bIsBreak,Ht.assign(d[V])):(gt=t.start.weight,at=t.start.rank,Gt=t.start.bBigMove,nt=t.start.bIsBreak,Ht.assign(Z.get().getStartXY())),X<u?(rt=E[X],Q=f[X],Ot=C[X].bBigMove,ot=C[X].bIsBreak,It.assign(d[X])):(Q=N,rt=A,Ot=M,ot=G,It.assign(Z.get().getEndXY()));let Jt=D;B<1&&(this.splitEdgeInPlace(D),Jt=D.getNextInChain()),this.updateSegmentOnly(D,W),D.start.hash===0||D.start.pt.equals(Ht)||(this.m_newNodes.push(D.start),this.removeNodeFromHash(D.start),D.start.hash=0),D.end.hash===0||D.end.pt.equals(It)||(this.m_newNodes.push(D.end),this.removeNodeFromHash(D.end),D.end.hash=0),D.start.pt.assign(Ht),D.end.pt.assign(It),D.start.bBigMove||=Gt,D.end.bBigMove||=Ot,D.start.bIsBreak||=nt,D.end.bIsBreak||=ot,D.start.weight=gt,D.start.rank=at,D.end.weight=Q,D.end.rank=rt,D=Jt,q=B,V=X}else V===-1&&(V=X)}const k=D.getNextInChain(),Y=[];Y.length=u;for(let X=0;X<u;X++)Y[X]=X;u>2?(Y.sort((X,B)=>Os(this.parent.m_param2[X],this.parent.m_param2[B])),this.parent.m_param2.sort(Os)):u===2&&this.parent.m_param2[0]>this.parent.m_param2[1]&&(this.parent.m_param2[1]=O(this.parent.m_param2[0],this.parent.m_param2[0]=this.parent.m_param2[1]),Y[1]=O(Y[0],Y[0]=Y[1])),D=e,N=e.end.weight,A=e.end.rank,M=e.end.bBigMove,G=e.end.bIsBreak,q=0,V=-1;for(let X=0;X<=u;X++){const B=X<u?this.parent.m_param2[X]:1;if(B!==q){const W=this.parent.allocResultSegment(),Z=this.parent.m_resultSegments[W];let gt,at,Q,rt;a.queryCut(q,B,Z,!1),Z.get().snapControlPoints(s*s);const nt=new y,ot=new y;let Gt=!1,Ot=!1,Ht=!1,It=!1;if(V!==-1){const Wt=Y[V];gt=x[Wt],at=P[Wt],nt.assign(p[Wt]),Ht=S[Wt].bBigMove,Gt=S[Wt].bIsBreak}else gt=e.start.weight,at=e.start.rank,Ht=e.start.bBigMove,Gt=e.start.bIsBreak,nt.assign(Z.get().getStartXY());if(X!==u){const Wt=Y[X];Q=x[Wt],rt=P[Wt],ot.assign(p[Wt]),It=S[Wt].bBigMove,Ot=S[Wt].bIsBreak}else Q=N,rt=A,It=M,Ot=G,ot.assign(Z.get().getEndXY());let Jt=D;B<1&&(this.splitEdgeInPlace(D),Jt=D.getNextInChain()),this.updateSegmentOnly(D,W),D.start.hash===0||D.start.pt.equals(nt)||(this.m_newNodes.push(D.start),this.removeNodeFromHash(D.start),D.start.hash=0),D.end.hash===0||D.end.pt.equals(ot)||(this.m_newNodes.push(D.end),this.removeNodeFromHash(D.end),D.end.hash=0),D.start.pt.assign(nt),D.end.pt.assign(ot),D.start.bBigMove||=Ht,D.end.bBigMove||=It,D.start.bIsBreak||=Gt,D.end.bIsBreak||=Ot,D.start.weight=gt,D.start.rank=at,D.end.weight=Q,D.end.rank=rt,D=Jt,q=B,V=X}else V===-1&&(V=X)}const U=D.getNextInChain();return this.postProcessResultPartsForCurves(t,k,e,U,n+1),l?3:2}intersectCurves(t,e){this.parent.m_inputSegments.length!==2&&$(""),this.parent.m_changed1=!1,this.parent.m_changed2=!1,this.parent.m_tolerance=t,this.m_hashTableOfEqualsSize=0,this.m_hashTableOfEquals=Kn(16);const s=F.constructEmpty();for(let o=0;o<2;o++){const a=this.parent.allocResultSegmentFromSegment(this.parent.m_inputSegments[this.parent.m_inputParts[o].segmentIndex]),h=F.constructEmpty();this.parent.m_inputSegments[this.parent.m_inputParts[o].segmentIndex].queryLooseEnvelope(h),s.mergeEnvelope2D(h);const m=this.parent.m_inputParts[o];this.addSegment(a,0,m.weightStart,m.rankStart,m.weightEnd,m.rankEnd,m.weightInterior,m.rankInterior,m.u.bBreakStart,m.u.bBreakEnd,m.segmentParentage)}s.inflateCoords(100*t,100*t),this.m_origin.assign(s.getLowerLeft()),this.m_cell.setCoords(2*t,2*t),this.m_pairs.push(gi(this.m_chainOrigin1.nextInChain,this.m_chainOrigin2.nextInChain,0,e));let i=0,n=!0;for(;this.m_pairs.length;){const o=this.m_pairs.at(-1);this.m_pairs.pop(),b(o.recursion>=0),b(o.recursion<=256),this.clusterNodes(t);const a=this.intersectCurvesHelper(o.edge1,o.edge2,t,o.bIsIntersecting,o.recursion);n&&(n=!1,i=a)}for(let o=0;o<2;o++){const a=o===0?this.parent.m_resultParts1:this.parent.m_resultParts2;for(let h=(o===0?this.m_chainOrigin1:this.m_chainOrigin2).nextInChain;h!=null;h=h.getNextInChain())a.push(this.parent.newIntersectionPart_(h.segmentIndex,h.start.weight,h.start.rank,h.end.weight,h.end.rank,h.weight,h.rank,h.start.bIsBreak,h.end.bIsBreak,h.segmentParentage)),a.at(-1).u.bBigMoveStart=h.start.bBigMove,a.at(-1).u.bBigMoveEnd=h.end.bBigMove}return i}tryOverlapIntersectCurves(t,e,s,i){const n=this.parent.m_resultSegments[t.segmentIndex].get(),o=this.parent.m_resultSegments[e.segmentIndex].get(),a=n.getStartXY().equals(o.getStartXY())&&n.getEndXY().equals(o.getEndXY()),h=n.getStartXY().equals(o.getEndXY())&&n.getEndXY().equals(o.getStartXY());if(!a&&!h)return 0;const m=Qe(n,o,!0);if(m!==0&&n_(n,o)&&t.segmentParentage===e.segmentParentage){let _=!1;if(m>0)_=n.equals(o);else{b(m===-1);const d=new it({segment:o});d.get().reverse(),_=n.equals(d.get())}if(_)return 1}const l=s*He.c_smallToleranceFactor;let u=!1;if(m===0){const _=[.5,.25,.75,.125,.375,.625,.875,.5625,.3125];for(let d=0,p=_.length;d<p;++d){const f=_[d],x=new y;n.queryCoord2D(f,x);const E=o.getClosestCoordinate(x,!1),P=new y;o.queryCoord2D(E,P);const C=y.distance(x,P);if(C>s)return 0;u||=C>l}for(let d=0,p=_.length;d<p;++d){const f=_[d],x=new y;o.queryCoord2D(f,x);const E=n.getClosestCoordinate(x,!1),P=new y;n.queryCoord2D(E,P);const C=y.distance(x,P);if(C>s)return 0;u||=C>l}}let c=t.rank,g=e.rank;return c===g&&(c*=He.c_maxGeometryTypeToRankDelta,g*=He.c_maxGeometryTypeToRankDelta,c+=on(n.getGeometryType(),n,!0),g+=on(o.getGeometryType(),o,!0)),c>g?(e.copyFromWhenOverlap(this,t,a),e.transferAttributes(this,n,a)):g>c?(t.copyFromWhenOverlap(this,e,a),t.transferAttributes(this,o,a)):t.segmentParentage<=e.segmentParentage?(t.weight=t.weight+e.weight,e.copyFromWhenOverlap(this,t,a),e.transferAttributes(this,n,a)):(e.weight=t.weight+e.weight,t.copyFromWhenOverlap(this,e,a),t.transferAttributes(this,o,a)),u?3:2}postProcessResultPartsForCurves(t,e,s,i,n){n===El()&&$("curve_helper");for(let o=t;o!==e;o=o.getNextInChain())this.updateSegmentToNodes(o);for(let o=s;o!==i;o=o.getNextInChain())this.updateSegmentToNodes(o);for(let o=t;o!==e;o=o.getNextInChain()){const a=o.end.pt.sub(o.start.pt);for(let h=s;h!==i;h=h.getNextInChain()){let m=0;if(o.start.pt.equals(h.start.pt)&&o.end.pt.equals(h.end.pt)?m=1:o.start.pt.equals(h.end.pt)&&o.end.pt.equals(h.start.pt)&&(m=-1),!m){let d=o.start.pt.equals(h.start.pt)?1:0;if(d||(d=o.end.pt.equals(h.end.pt)?2:0,d||(d=o.end.pt.equals(h.start.pt)?3:0,d||(d=o.start.pt.equals(h.end.pt)?4:0))),d){const p=h.end.pt.sub(h.start.pt),f=a.dotProduct(p);let x;switch(d){case 1:case 2:x=f>0;break;case 3:case 4:x=f<0;break;default:$("post_process_result_parts_for_curves_")}x&&this.m_pairs.push(gi(o,h,n,!1))}continue}const l=this.parent.m_resultSegments[o.segmentIndex],u=this.parent.m_resultSegments[h.segmentIndex],c=[.5,.25,.75];for(let d=0,p=c.length;d<p;++d){const f=c[d],x=new y;l.get().queryCoord2D(f,x);const E=u.get().getClosestCoordinate(x,!1),P=new y;if(u.get().queryCoord2D(E,P),y.distance(x,P)>this.parent.m_tolerance){m=0;break}}if(!m){this.m_pairs.push(gi(o,h,n,!1));continue}for(let d=0,p=c.length;d<p;++d){const f=c[d],x=new y;u.get().queryCoord2D(f,x);const E=l.get().getClosestCoordinate(x,!1),P=new y;if(l.get().queryCoord2D(E,P),y.distance(x,P)>this.parent.m_tolerance){m=0;break}}if(!m){this.m_pairs.push(gi(o,h,n,!1));continue}o.equalEdge=h,h.equalEdge=o;let g=o.rank,_=h.rank;g===_&&(g*=He.c_maxGeometryTypeToRankDelta,_*=He.c_maxGeometryTypeToRankDelta,g+=on(l.get().getGeometryType(),l.get(),!0),_+=on(u.get().getGeometryType(),u.get(),!0)),g>_||g===_&&o.segmentParentage<=h.segmentParentage?(l.copyTo(u,!1),h.segmentParentage=o.segmentParentage,m===-1&&u.get().reverse()):(u.copyTo(l,!1),o.segmentParentage=h.segmentParentage,m===-1&&l.get().reverse());break}}this.updateAttachedEdgesAfterNodeChange(t.start),e&&this.updateAttachedEdgesAfterNodeChange(e.start),this.updateAttachedEdgesAfterNodeChange(s.start),i&&this.updateAttachedEdgesAfterNodeChange(i.start)}processDoublyConnectedEdges(t,e,s,i){s===El()&&$("curve_helper");const n=this.getSegment(t).get(),o=this.getSegment(e).get(),a=n.getStartXY().equals(o.getStartXY())&&n.getEndXY().equals(o.getEndXY())?1:n.getEndXY().equals(o.getStartXY())&&n.getStartXY().equals(o.getEndXY())?-1:0;if(a!==0){const h=new it;n.queryCut(0,.5,h),h.get().snapControlPoints(i*i);const m=new it;n.queryCut(.5,1,m),m.get().snapControlPoints(i*i),this.splitEdgeInPlace(t),t.end.pt=h.get().getEndXY(),t.segmentIndex=this.parent.allocResultSegmentFromBuffer(h),t.getNextInChain().segmentIndex=this.parent.allocResultSegmentFromBuffer(m);let l=o.getClosestCoordinate(t.end.pt,!1);return Math.abs(l-.5)>.2&&(l=.5),o.queryCut(0,l,h),h.get().snapControlPoints(i*i),o.queryCut(l,1,m),m.get().snapControlPoints(i*i),this.splitEdgeInPlace(e),e.end.pt=h.get().getEndXY(),e.segmentIndex=this.parent.allocResultSegmentFromBuffer(h),e.getNextInChain().segmentIndex=this.parent.allocResultSegmentFromBuffer(m),a>0?(this.m_pairs.push(gi(t,e,s,!1)),this.m_pairs.push(gi(t.getNextInChain(),e.getNextInChain(),s,!1))):(this.m_pairs.push(gi(t,e.getNextInChain(),s,!1)),this.m_pairs.push(gi(t.getNextInChain(),e,s,!1))),!0}return!1}newNode(t,e,s,i){const n=new Bu;return this.m_newNodes.push(n),n.pt=t,n.rank=s,n.weight=e,n.bIsBreak=i,n}newEdge(t,e,s,i,n,o){const a=new Lu;return a.start=t,a.end=e,t.nextInChain=a,e.prevInChain=a,a.segmentIndex=s,a.segmentParentage=o,a.rank=n,a.weight=i,a}splitEdgeInPlace(t){t.segmentIndex=-1;const e=new Lu,s=new Bu;this.m_newNodes.push(s),s.pt.setNAN(),s.nextInChain=e,s.prevInChain=t,s.prevInHash=null,s.nextInHash=null,s.prevEqual=null,s.nextEqual=null,s.weight=t.weight,s.rank=t.rank,s.bIsBreak=!1,s.bBigMove=!1,e.start=s,e.segmentIndex=-1,e.end=t.end,e.end.prevInChain=e,e.rank=t.rank,e.weight=t.weight,e.segmentParentage=t.segmentParentage,t.end=s,t.equalEdge&&(t.equalEdge.equalEdge=null),t.equalEdge=null}updateSegmentOnly(t,e){t.segmentIndex=e}updateAttachedEdgesAfterNodeChange(t){for(let e=t.equalListHead();e!==null;e=e.nextEqual)this.updateAttachedEdgesAfterNodeChangeImpl(e)}updateAttachedEdgesAfterNodeChangeImpl(t){const e=t.prevInChain;if(e&&e.hasSegment()){const i=this.getSegment(e).get();t.pt.equals(i.getEndXY())||(i.setCoordsForIntersector(e.start.pt,e.end.pt,!1),i.ensureXYMonotone())}const s=t.nextInChain;if(s&&s.hasSegment()){const i=this.getSegment(s).get();t.pt.equals(i.getStartXY())||(i.setCoordsForIntersector(s.start.pt,s.end.pt,!1),i.ensureXYMonotone())}}updateSegmentToNodes(t){const e=this.getSegment(t).get();t.start.pt.equals(e.getStartXY())&&t.end.pt.equals(e.getEndXY())||(e.setCoordsForIntersector(t.start.pt,t.end.pt,!1),e.ensureXYMonotone()),this.updateAttachedEdgesAfterNodeChange(t.start),this.updateAttachedEdgesAfterNodeChange(t.end)}getSegment(t){return this.parent.m_resultSegments[t.segmentIndex]}clusterNodes(t){let e=!1;const s=[],i=[],n=[];for(let o=0,a=this.m_newNodes.length;o<a;o++){const h=this.m_newNodes[o];if(h===null)continue;let m=h;for(let l=o+1;l<a;l++){const u=this.m_newNodes[l];u!==null&&h.pt.equals(u.pt)&&(m.nextInHash=u,u.prevInHash=m,m=u,this.m_newNodes[l]=null)}}for(let o=0,a=this.m_newNodes.length;o<a;o++){const h=this.m_newNodes[o];if(h==null)continue;for(h.hash=this.calculateHash(h.pt);;){const g=Kn(4),_=this.hashTableBinsToCheck(h,g);for(let p=0;p<_;p++)if(g[p]!==null)for(let f=g[p];f!==null;){const x=f.nextInHash;y.distance(h.pt,f.pt)<=t&&(s.push(f),this.removeNodeFromHash(f),f.hash=0,n.push(f),i.push(f)),f=x}let d=!1;for(const p of s)if(!h.pt.equals(p.pt)){const f=__(h.pt,p.pt,h.weight,h.rank,p.weight,p.rank);h.pt.assign(f.pt),h.weight=f.weight,h.rank=f.rank,d=!0,e=!0}if(s.length=0,!d)break;h.hash=this.calculateHash(h.pt)}n.push(h),i.push(h);for(let g=h.nextInHash;g!==null;){g.prevInHash=null;const _=g.nextInHash;g.nextInHash=null,n.push(g),i.push(g),g=_}const m=h.hash;let l=null,u=null;for(const g of i)h!==g&&(g.hash=m,g.pt.assign(h.pt),g.rank=h.rank,g.weight=h.weight),g.prevInHash=l,l&&(l.nextInHash=g),g.prevEqual=u,g.nextEqual=null,u&&(u.nextEqual=g),u=g,l=g;const c=m%this.m_hashTableOfEquals.length;l.nextInHash=this.m_hashTableOfEquals[c],this.m_hashTableOfEquals[c]!==null&&(this.m_hashTableOfEquals[c].prevInHash=l),this.m_hashTableOfEquals[c]=i[0],this.m_hashTableOfEqualsSize+=i.length,i.length=0,this.rehashIfNeeded()}if(this.m_newNodes.length=0,e)for(const o of n)this.updateAttachedEdgesAfterNodeChange(o)}rehashIfNeeded(){if(2*this.m_hashTableOfEqualsSize>this.m_hashTableOfEquals.length){const t=this.m_hashTableOfEquals;this.m_hashTableOfEquals=Kn(2*t.length),this.m_hashTableOfEqualsSize=0;for(const e of t){let s=e;for(;s;){const i=s.nextInHash;s.nextInHash=null,s.prevInHash=null,this.addNodeToHashImpl(s),s=i}}}}addNodeToHashImpl(t){const e=t.hash%this.m_hashTableOfEquals.length,s=this.m_hashTableOfEquals[e];t.nextInHash=s,s!==null&&(s.prevInHash=t),this.m_hashTableOfEquals[e]=t,this.m_hashTableOfEqualsSize++}removeNodeFromHash(t){const e=t.hash%this.m_hashTableOfEquals.length,s=t.prevInHash,i=t.nextInHash;s?s.nextInHash=i:this.m_hashTableOfEquals[e]=i,i&&(i.prevInHash=s),this.m_hashTableOfEqualsSize--,t.prevInHash=null,t.nextInHash=null}hashTableBinsToCheck(t,e){const s=(t.pt.x-this.m_origin.x)/this.m_cell.x,i=(t.pt.y-this.m_origin.y)/this.m_cell.y,n=Ie()-1,o=Math.round(Nt(s,-2147483646,n)),a=Math.round(Nt(i,-2147483646,n));let h=o|a<<32;h=qs(h),e[0]=this.m_hashTableOfEquals[h%this.m_hashTableOfEquals.length];let m=o+1|a<<32;m=qs(m);let l=1;e[1]=this.m_hashTableOfEquals[m%this.m_hashTableOfEquals.length],e[1]!==e[0]&&(l=2);let u=o+1|a+1<<32;u=qs(u),e[l]=this.m_hashTableOfEquals[u%this.m_hashTableOfEquals.length];for(let g=0;g<l;g++)if(e[l]===e[g]){l--;break}l++;let c=o|a+1<<32;c=qs(c),e[l]=this.m_hashTableOfEquals[c%this.m_hashTableOfEquals.length];for(let g=0;g<l;g++)if(e[l]===e[g]){l--;break}return l++,l}calculateHash(t){const e=(t.x-this.m_origin.x)/this.m_cell.x,s=(t.y-this.m_origin.y)/this.m_cell.y,i=Ie()-1;let n=Math.round(Nt(e,-2147483646,i))|Math.round(Nt(s,-2147483646,i))<<32;return n=qs(n),n===0&&(n=1),n}processSharpCorners(t,e,s,i){if(this.parent.m_param1.length=0,this.parent.m_param2.length=0,t.getStartXY().equals(e.getStartXY())){const n=[0,0],o=[0,0],a=io(t,e,0,0,s,2,n,o,i);if(a){this.parent.m_param1.push(0),this.parent.m_param2.push(0);for(let h=0;h<a;h++)this.parent.m_param1.push(n[h]),this.parent.m_param2.push(o[h]);return a+1}}if(t.getEndXY().equals(e.getEndXY())){const n=[0,0],o=[0,0],a=io(t,e,1,1,s,2,n,o,i);if(a){for(let h=0;h<a;h++)this.parent.m_param1.push(n[h]),this.parent.m_param2.push(o[h]);return this.parent.m_param1.push(1),this.parent.m_param2.push(1),a+1}}if(t.getStartXY().equals(e.getEndXY())){const n=[0,0],o=[0,0],a=io(t,e,0,1,s,2,n,o,i);if(a){this.parent.m_param1.push(0),this.parent.m_param2.push(1);for(let h=0;h<a;h++)this.parent.m_param1.push(n[h]),this.parent.m_param2.push(o[h]);return a+1}}if(t.getEndXY().equals(e.getStartXY())){const n=[0,0],o=[0,0],a=io(t,e,1,0,s,2,n,o,i);if(a){for(let h=0;h<a;h++)this.parent.m_param1.push(n[h]),this.parent.m_param2.push(o[h]);return this.parent.m_param1.push(1),this.parent.m_param2.push(0),a+1}}return 0}}function on(r,t,e){let s=0;switch(r){case T.enumLine:s=0;break;case T.enumBezier:s=2;break;case T.enumRationalBezier2:s=3;break;case T.enumBezier2:s=1;break;case T.enumEllipticArc:s=t.projectionBehavior()===0?5:4;break;default:$("")}return e?5-s:s}class fx extends u_{constructor(t){super(t.m_shape,t.m_tolerance,!1),this.m_parent=t}compare(t,e,s){if(this.m_bIntersectionDetected)return-1;const i=t.getElement(s),n=this.m_parent.getEdgeOriginVertices(e),o=this.m_parent.m_edgeVertices.getFirstElement(n),a=this.m_parent.getEdgeOriginVertices(i),h=this.m_parent.m_edgeVertices.getFirstElement(a);return this.m_currentNode=s,this.compareSegments(e,o,i,h)}}class xx extends c_{constructor(t){super(t.m_shape,t.m_tolerance),this.m_parent=t}compare(t,e){if(this.m_bIntersectionDetected)return-1;const s=t.getElement(e),i=this.m_parent.getEdgeOriginVertices(s),n=this.m_parent.m_edgeVertices.getFirstElement(i);return this.m_currentNode=e,this.compareVertex(t,e,n)}}class yx extends tn{constructor(t){super(),this.pt1=y.getNAN(),this.pt2=y.getNAN(),this.m_shape=t}compare(t,e,s){this.m_shape.queryXY(e,this.pt1);const i=t.getElement(s);return this.m_shape.queryXY(i,this.pt2),this.pt1.compare(this.pt2)}}class Px{constructor(t){this.m_point=y.getNAN(),this.m_pt=y.getNAN(),this.m_shape=t}setPoint(t){this.m_point.setCoordsPoint2D(t)}compare(t,e){const s=t.getElement(e);return this.m_shape.queryXY(s,this.m_pt),this.m_point.compare(this.m_pt)}}class sm{constructor(t,e){this.m_shape=null,this.m_progressTracker=null,this.m_edges=new At(8),this.m_clusters=new At(5),this.m_clusterVertices=new wt(!1),this.m_edgeVertices=new wt(!1),this.m_helperPoint=new st,this.m_eventQ=new tt,this.m_sweepStructure=new tt,this.m_bComplications=!1,this.m_sweepComparator=null,this.m_tempEdgeBuffer=[],this.m_modifiedClusters=[],this.m_edgesToInsertInSweepStructure=[],this.m_prevNeighbour=-1,this.m_nextNeighbour=-1,this.m_bContinuingSegmentChainOptimization=!1,this.m_progressCounter=0,this.m_segmentIntersector=new He,this.m_segBuf1=new it,this.m_segBuf2=new it,this.m_sweepPoint=new y(0,0),this.m_tolerance=0,this.m_toleranceSqr=0,this.m_sweepPointCluster=-1,this.m_vertexClusterIndex=-1,this.m_bCracked=!1,this.m_bSweepPointClusterWasModified=!1,this.m_progressTracker=t,this.m_bTrackChanges=e}hadComplications(){return this.m_bComplications}sweep(t,e){const s=new pt;s.setSwapCoordinates(),t.applyTransformation(s),this.setEditShape_(t),this.m_bCracked=!1,this.m_tolerance=e,this.m_toleranceSqr=e*e;let i=this.sweepImpl_();return t.applyTransformation(s),i||(this.fillEventQueuePass2(),i=this.sweepImpl_()||i),this.m_shape.removeUserIndex(this.m_vertexClusterIndex),this.m_shape=null,this.m_bCracked}sweepVertical(t,e){this.setEditShape_(t),this.m_bCracked=!1,this.m_tolerance=e,this.m_toleranceSqr=e*e,this.m_bComplications=!1;let s=this.sweepImpl_();if(!this.m_bComplications){const i=t.filterClosePoints(e,!0,!1,this.m_bTrackChanges,v);this.m_bComplications=i===1,s||=i===1}return this.m_vertexClusterIndex!==-1&&(this.m_shape.removeUserIndex(this.m_vertexClusterIndex),this.m_vertexClusterIndex=-1),this.m_shape=null,s}getEdgeCluster(t,e){return this.m_edges.getField(t,0+e)}setEdgeCluster_(t,e,s){this.m_edges.setField(t,0+e,s)}getEdgeOriginVertices(t){return this.m_edges.getField(t,2)}setEdgeOriginVertices_(t,e){this.m_edges.setField(t,2,e)}getNextEdgeEx(t,e){return this.m_edges.getField(t,3+e)}setNextEdgeEx_(t,e,s){this.m_edges.setField(t,3+e,s)}getEdgeSweepNode(t){return this.m_edges.getField(t,7)}setEdgeSweepNode_(t,e){this.m_edges.setField(t,7,e)}getNextEdge(t,e){const s=this.getEdgeEnd(t,e);return this.m_edges.getField(t,3+s)}setNextEdge_(t,e,s){const i=this.getEdgeEnd(t,e);this.m_edges.setField(t,3+i,s)}getPrevEdge(t,e){const s=this.getEdgeEnd(t,e);return this.m_edges.getField(t,5+s)}setPrevEdge_(t,e,s){const i=this.getEdgeEnd(t,e);this.m_edges.setField(t,5+i,s)}getClusterVertices(t){return this.m_clusters.getField(t,0)}setClusterVertices_(t,e){this.m_clusters.setField(t,0,e)}getClusterSweepEdgeList(t){return this.m_clusters.getField(t,2)}setClusterSweepEdgeList_(t,e){this.m_clusters.setField(t,2,e)}getClusterFirstEdge(t){return this.m_clusters.getField(t,1)}setClusterFirstEdge_(t,e){this.m_clusters.setField(t,1,e)}getClusterEventQNode(t){return this.m_clusters.getField(t,3)}setClusterEventQNode_(t,e){this.m_clusters.setField(t,3,e)}newCluster_(t){const e=this.m_clusters.newElement(),s=this.m_clusterVertices.createList();return this.setClusterVertices_(e,s),t!==v&&(this.m_clusterVertices.addElement(s,t),this.m_shape.setUserIndex(t,this.m_vertexClusterIndex,e)),e}deleteCluster_(t){this.m_clusters.deleteElement(t)}addVertexToCluster_(t,e){const s=this.getClusterVertices(t);this.m_clusterVertices.addElement(s,e),this.m_shape.setUserIndex(e,this.m_vertexClusterIndex,t)}newEdge_(t){const e=this.m_edges.newElement(),s=this.m_edgeVertices.createList();return this.setEdgeOriginVertices_(e,s),t!==-1&&this.m_edgeVertices.addElement(s,t),e}addVertexToEdge_(t,e){const s=this.getEdgeOriginVertices(t);this.m_edgeVertices.addElement(s,e)}deleteEdge_(t){this.m_edges.deleteElement(t);const e=this.m_edgesToInsertInSweepStructure.findIndex(s=>s===t);e>=0&&sp(this.m_edgesToInsertInSweepStructure,e)}addEdgeToCluster(t,e){this.getEdgeCluster(t,0)===-1?this.setEdgeCluster_(t,0,e):this.getEdgeCluster(t,1)===-1?this.setEdgeCluster_(t,1,e):$(""),this.addEdgeToClusterImpl_(t,e)}addEdgeToClusterImpl_(t,e){const s=this.getClusterFirstEdge(e);if(s!==-1){const i=this.getNextEdge(s,e);this.setPrevEdge_(i,e,t),this.setNextEdge_(t,e,i),this.setNextEdge_(s,e,t),this.setPrevEdge_(t,e,s)}else this.setPrevEdge_(t,e,t),this.setNextEdge_(t,e,t),this.setClusterFirstEdge_(e,t)}getEdgeEnd(t,e){return this.getEdgeCluster(t,0)===e?0:1}mergeClusters_(t,e){this.dbgCheckCluster_(t),this.dbgCheckCluster_(e);const s=this.getClusterEventQNode(e);s!==-1&&(this.m_eventQ.deleteNode(s),this.setClusterEventQNode_(e,-1));let i=this.getClusterFirstEdge(t),n=this.getClusterFirstEdge(e);if(n!==-1){let h=n,m=n,l=!1;do{this.dbgCheckEdge_(h),l=!1;const u=this.getEdgeEnd(h,e),c=this.getNextEdgeEx(h,u);if(this.getEdgeCluster(h,u+1&1)===t){this.disconnectEdge_(h);const g=this.getEdgeOriginVertices(h);if(this.m_edgeVertices.deleteList(g),this.deleteEdge_(h),h===c){n=-1;break}n===h&&(n=this.getClusterFirstEdge(e),m=c,l=!0)}h=c}while(h!==m||l);if(n!==-1){do{const u=this.getEdgeEnd(h,e),c=this.getNextEdgeEx(h,u);this.setEdgeCluster_(h,u,t),h=c}while(h!==m);if(i=this.getClusterFirstEdge(t),i!==-1){const u=this.getNextEdge(i,t),c=this.getNextEdge(n,t);u===i?(this.setClusterFirstEdge_(t,n),this.addEdgeToClusterImpl_(i,t),this.setClusterFirstEdge_(t,i)):c===n&&this.addEdgeToClusterImpl_(n,t),this.setNextEdge_(n,t,u),this.setPrevEdge_(u,t,n),this.setNextEdge_(i,t,c),this.setPrevEdge_(c,t,i)}else this.setClusterFirstEdge_(t,n)}}const o=this.getClusterVertices(t),a=this.getClusterVertices(e);for(let h=this.m_clusterVertices.getFirst(a);h!==-1;h=this.m_clusterVertices.getNext(h)){const m=this.m_clusterVertices.getElement(h);this.m_shape.setUserIndex(m,this.m_vertexClusterIndex,t)}this.m_clusterVertices.concatenateLists(o,a),this.deleteCluster_(e),this.dbgCheckCluster_(t)}mergeEdges_(t,e){this.dbgCheckEdge_(t),this.dbgCheckEdge_(e);const s=this.getEdgeCluster(t,0),i=this.getEdgeCluster(t,1),n=this.getEdgeCluster(e,0),o=this.getEdgeCluster(e,1),a=this.getEdgeOriginVertices(t),h=this.getEdgeOriginVertices(e);if(this.m_edgeVertices.concatenateLists(a,h),e===this.getClusterFirstEdge(s)&&this.setClusterFirstEdge_(s,t),e===this.getClusterFirstEdge(i)&&this.setClusterFirstEdge_(i,t),this.disconnectEdge_(e),this.deleteEdge_(e),!(s===n&&i===o||i===n&&s===o)){const m=this.getClusterXY(s),l=this.getClusterXY(n);m.isEqualPoint2D(l)?(s!==n&&this.mergeClusters_(s,n),i!==o&&this.mergeClusters_(i,o)):(i!==n&&this.mergeClusters_(i,n),s!==o&&this.mergeClusters_(s,o))}this.dbgCheckEdge_(t)}disconnectEdge_(t){const e=this.getEdgeCluster(t,0),s=this.getEdgeCluster(t,1);this.disconnectEdgeFromCluster_(t,e),this.disconnectEdgeFromCluster_(t,s)}disconnectEdgeFromCluster_(t,e){const s=this.getNextEdge(t,e),i=this.getPrevEdge(t,e),n=this.getClusterFirstEdge(e);s!==t?(this.setNextEdge_(i,e,s),this.setPrevEdge_(s,e,i),n===t&&this.setClusterFirstEdge_(e,s)):this.setClusterFirstEdge_(e,-1)}applyIntersectorToEditShape_(t,e,s){let i=this.m_edgeVertices.getFirst(t);const n=this.m_edgeVertices.getElement(i),o=this.getClusterFromVertex(n),a=this.m_shape.getNextVertex(n),h=this.getClusterFromVertex(a),m=this.m_shape.getXY(n),l=this.m_shape.getXY(a);let u=!1,c=!1;const g=e.getResultSegment(s,0).getStartXY(),_=e.getResultSegment(s,e.getResultSegmentCount(s)-1).getEndXY();m.equals(g)||(u=!0),l.equals(_)||(c=!0),this.m_shape.splitSegmentWithIntersector(n,e,s,!0,!0);const d=this.m_bTrackChanges&&e.getSegmentChanged(s);for(d&&this.m_shape.setGeometryModifiedWithVertex(n,!0),i=this.m_edgeVertices.getNext(i);i!==-1;i=this.m_edgeVertices.getNext(i)){const p=this.m_edgeVertices.getElement(i),f=this.getClusterFromVertex(p)===o;this.m_shape.splitSegmentWithIntersector(p,e,s,f,!0),d&&this.m_shape.setGeometryModifiedWithVertex(p,!0)}if(u&&this.updateClusterXY(!0,o,g,e.getResultSegmentStartPointWeight(s,0),e.getResultSegmentStartPointRank(s,0)),c){const p=e.getResultSegmentCount(s)-1;this.updateClusterXY(!0,h,_,e.getResultSegmentEndPointWeight(s,p),e.getResultSegmentEndPointRank(s,p))}}createEdgesAndClustersFromSplitEdge_(t,e,s){this.dbgCheckNewEdgesArray_();const i=this.getEdgeOriginVertices(t),n=this.getEdgeCluster(t,0),o=this.getEdgeCluster(t,1);let a=this.newEdge_(-1);this.m_edgesToInsertInSweepStructure.push(a);const h=At.impossibleIndex3();this.setEdgeSweepNode_(a,h),this.m_tempEdgeBuffer.push(a),this.addEdgeToCluster(a,n);const m=e.getResultSegmentCount(s);for(let l=1;l<m;l++){const u=this.newCluster_(-1);this.m_modifiedClusters.push(u),this.m_tempEdgeBuffer.push(u),this.addEdgeToCluster(a,u);const c=this.newEdge_(-1);this.m_edgesToInsertInSweepStructure.push(c),this.setEdgeSweepNode_(c,h),this.m_tempEdgeBuffer.push(c),this.addEdgeToCluster(c,u),a=c}this.addEdgeToCluster(a,o);for(let l=this.m_edgeVertices.getFirst(i);l!==-1;l=this.m_edgeVertices.getNext(l)){let u=this.m_edgeVertices.getElement(l);if(this.getClusterFromVertex(u)===n){let c=0;const g=this.m_tempEdgeBuffer.length;do{if(c>0){const d=this.m_tempEdgeBuffer[c-1];this.addVertexToCluster_(d,u)}const _=this.m_tempEdgeBuffer[c];c+=2,this.addVertexToEdge_(_,u),u=this.m_shape.getNextVertex(u)}while(c<g)}else{let c=this.m_tempEdgeBuffer.length-1;do{if(c<this.m_tempEdgeBuffer.length-2){const _=this.m_tempEdgeBuffer[c+1];this.addVertexToCluster_(_,u)}const g=this.m_tempEdgeBuffer[c];c-=2,this.addVertexToEdge_(g,u),u=this.m_shape.getNextVertex(u)}while(c>=0)}}this.m_tempEdgeBuffer.length=0,this.dbgCheckNewEdgesArray_()}getVertexFromClusterIndex(t){const e=this.getClusterVertices(t);return this.m_clusterVertices.getFirstElement(e)}getClusterFromVertex(t){return this.m_shape.getUserIndex(t,this.m_vertexClusterIndex)}processSplitHelper1_(t,e,s){const i=this.getEdgeCluster(e,0),n=this.getClusterXY(i),o=this.getEdgeCluster(e,1),a=this.getClusterXY(o),h=s.getResultSegmentCount(t);let m=s.getResultSegment(t,0);const l=m.getStartXY();if(n.isEqualPoint2D(l)||(this.m_bComplications||n.compare(this.m_sweepPoint)*l.compare(this.m_sweepPoint)<0&&(this.m_bComplications=!0),this.getAffectedEdges(i,this.m_tempEdgeBuffer),this.m_modifiedClusters.push(i)),!this.m_bComplications&&h>1){const c=n.compare(a),g=m.getEndXY();(n.compare(g)!==c||g.compare(a)!==c||g.compare(this.m_sweepPoint)<0)&&(this.m_bComplications=!0)}m=s.getResultSegment(t,h-1);const u=m.getEndXY();a.isEqualPoint2D(u)||(this.m_bComplications||a.compare(this.m_sweepPoint)*u.compare(this.m_sweepPoint)<0&&(this.m_bComplications=!0),this.getAffectedEdges(o,this.m_tempEdgeBuffer),this.m_modifiedClusters.push(o)),this.m_tempEdgeBuffer.push(e);for(let c=0,g=this.m_tempEdgeBuffer.length;c<g;c++){const _=this.m_tempEdgeBuffer[c],d=this.getEdgeSweepNode(_);At.isValidElement(d)&&(this.m_sweepStructure.deleteNode(d),this.setEdgeSweepNode_(_,-1));const p=At.impossibleIndex3();_!==e&&this.getEdgeSweepNode(_)!==p&&(this.m_edgesToInsertInSweepStructure.push(_),this.setEdgeSweepNode_(_,p))}this.m_tempEdgeBuffer.length=0}checkAndFixIntersection_(t,e){const s=this.m_sweepStructure.getElement(t);return this.m_sweepComparator.compare(this.m_sweepStructure,s,e),!!this.m_sweepComparator.intersectionDetected()&&(this.m_sweepComparator.clearIntersectionDetectedFlag(),this.fixIntersection_(t,e),!0)}fixIntersection_(t,e){this.m_bCracked=!0;const s=this.m_sweepStructure.getElement(t),i=this.m_sweepStructure.getElement(e);let n=null,o=null;const a=this.getEdgeOriginVertices(s),h=this.m_edgeVertices.getFirstElement(a),m=this.getEdgeOriginVertices(i),l=this.m_edgeVertices.getFirstElement(m);this.m_shape.querySegment(h,this.m_segBuf1,!1,!1),n=this.m_segBuf1.get();const u=this.m_shape.getNextVertex(h),c=this.m_shape.getWeight(h),g=this.m_shape.getSegmentParentageBreakVertex(h),_=this.m_shape.getWeight(u),d=this.m_shape.getSegmentParentageBreakVertex(u),p=this.m_shape.getSegmentWeight(h),f=this.m_shape.getRank(h),x=this.m_shape.getRank(u),E=this.m_shape.getSegmentRank(h),P=this.m_shape.getSegmentParentage(h);this.m_shape.querySegment(l,this.m_segBuf2,!1,!1),o=this.m_segBuf2.get();const C=this.m_shape.getNextVertex(l),S=this.m_shape.getWeight(l),I=this.m_shape.getSegmentParentageBreakVertex(l),w=this.m_shape.getWeight(C),D=this.m_shape.getSegmentParentageBreakVertex(C),N=this.m_shape.getSegmentWeight(l),A=this.m_shape.getRank(l),M=this.m_shape.getRank(C),G=this.m_shape.getSegmentRank(l),q=this.m_shape.getSegmentParentage(l);this.m_segmentIntersector.pushSegment(n,c,f,_,x,p,E,g,d,P),this.m_segmentIntersector.pushSegment(o,S,A,w,M,N,G,I,D,q),this.m_segmentIntersector.intersect2D(this.m_tolerance,!0)===3&&(this.m_bComplications=!0),this.splitEdge_(s,i,-1,this.m_segmentIntersector),this.m_segmentIntersector.clear()}fixIntersectionPointSegment_(t,e){this.m_bCracked=!0;const s=this.m_sweepStructure.getElement(e);let i=null;const n=this.getEdgeOriginVertices(s),o=this.m_edgeVertices.getFirstElement(n);this.m_shape.querySegment(o,this.m_segBuf1,!1,!1),i=this.m_segBuf1.get();const a=this.m_shape.getNextVertex(o),h=this.m_shape.getWeight(o),m=this.m_shape.getSegmentParentageBreakVertex(o),l=this.m_shape.getWeight(a),u=this.m_shape.getSegmentParentageBreakVertex(a),c=this.m_shape.getSegmentWeight(o),g=this.m_shape.getRank(o),_=this.m_shape.getRank(a),d=this.m_shape.getSegmentRank(o),p=this.m_shape.getSegmentParentage(o),f=this.getClusterFirstVertex(t);this.m_segmentIntersector.pushSegment(i,h,g,l,_,c,d,m,u,p),this.m_shape.queryPoint(f,this.m_helperPoint);const x=this.m_shape.getWeight(f),E=this.m_shape.getRank(f);this.m_segmentIntersector.intersect2DEx(this.m_tolerance,this.m_helperPoint,E,x,!0),this.splitEdge_(s,-1,t,this.m_segmentIntersector),this.m_segmentIntersector.clear()}insertNewEdges_(){if(this.m_edgesToInsertInSweepStructure.length===0)return!0;this.dbgCheckNewEdgesArray_();let t=!0,e=0;const s=this.m_edgesToInsertInSweepStructure.length,i=Math.max(2*s+200,this.m_sweepStructure.size()+200);for(;this.m_edgesToInsertInSweepStructure.length;){if(this.m_edgesToInsertInSweepStructure.length>Math.max(100,this.m_shape.getTotalPointCount())||e>i){this.m_edgesToInsertInSweepStructure.length=0,this.m_bComplications=!0,t=!1;break}const n=this.m_edgesToInsertInSweepStructure.at(-1);this.m_edgesToInsertInSweepStructure.pop(),this.setEdgeSweepNode_(n,-1);const o=this.isEdgeOnSweepLine_(n);At.isValidElement(o)?(this.insertNewEdgeToSweepStructure_(n,o),e++):o!==At.impossibleIndex2()&&(t=!1),this.m_bContinuingSegmentChainOptimization=!1}return t}insertNewEdgeToSweepStructure_(t,e){let s;if(this.m_bContinuingSegmentChainOptimization?(s=this.m_sweepStructure.addElementAtPosition(this.m_prevNeighbour,this.m_nextNeighbour,t,!0,!0),this.m_bContinuingSegmentChainOptimization=!1):s=this.m_sweepStructure.addUniqueElement(t),s===-1){const i=this.m_sweepStructure.getDuplicateElement(),n=this.m_sweepStructure.getElement(i);return this.mergeEdges_(n,t),!1}if(this.setEdgeSweepNode_(t,s),this.m_sweepComparator.intersectionDetected()){this.m_sweepComparator.clearIntersectionDetectedFlag();const i=this.m_sweepComparator.getLastComparedNode();return this.m_prevNeighbour===i&&(this.m_prevNeighbour=-1),this.m_nextNeighbour===i&&(this.m_nextNeighbour=-1),this.fixIntersection_(i,s),!0}return!1}isEdgeOnSweepLine_(t){const e=this.getEdgeCluster(t,0),s=this.getEdgeCluster(t,1),i=this.getClusterXY(e),n=this.getClusterXY(s);if(y.sqrDistance(i,n)<=this.m_toleranceSqr)return this.m_bComplications=!0,-1;const o=i.compare(this.m_sweepPoint),a=n.compare(this.m_sweepPoint);return o<=0&&a>0?s:a<=0&&o>0?e:o>0&&a>0?At.impossibleIndex2():-1}fillEventQueue(){const t=new Xt(0),e=this.m_shape.queryVertexIteratorOnSelection();for(let n=e.next();n!==v;n=e.next())this.m_shape.getUserIndex(n,this.m_vertexClusterIndex)!==-1&&t.add(n);this.m_shape.sortVerticesSimpleByY(t,0,t.size()),this.progress_(!0),this.m_eventQ.clear(),this.m_eventQ.setCapacity(t.size()),this.m_eventQ.setComparator(new yx(this.m_shape));const s=y.getNAN();s.setNAN();let i=-1;for(let n=0,o=t.size();n<o;n++){const a=t.read(n);if(this.m_shape.getXY(a).isEqualPoint2D(s)){const m=this.m_shape.getUserIndex(a,this.m_vertexClusterIndex);this.mergeClusters_(i,m);continue}i=this.getClusterFromVertex(a),this.m_shape.queryXY(a,s);const h=this.m_eventQ.addBiggestElement(a);this.setClusterEventQNode_(i,h)}}fillEventQueuePass2(){const t=new Xt(0);for(let e=this.m_eventQ.getFirst();e!==-1;e=this.m_eventQ.getNext(e)){const s=this.m_eventQ.getElement(e);t.add(s)}this.m_eventQ.clear(),this.m_shape.sortVerticesSimpleByY(t,0,t.size()),this.progress_(!0);for(let e=0,s=t.size();e<s;e++){const i=t.read(e),n=this.getClusterFromVertex(i),o=this.m_eventQ.addBiggestElement(i);this.setClusterEventQNode_(n,o)}}getAffectedEdges(t,e){const s=this.getClusterFirstEdge(t);if(s===-1)return;let i=s;do{const n=this.getEdgeSweepNode(i);At.isValidElement(n)&&e.push(i),i=this.getNextEdge(i,t)}while(i!==s)}updateClusterXY(t,e,s,i,n){const o=this.getClusterVertices(e);for(let a=this.m_clusterVertices.getFirst(o);a!==-1;a=this.m_clusterVertices.getNext(a)){const h=this.m_clusterVertices.getElement(a);this.m_shape.setXYMonotonicPoint2D(h,s),this.m_shape.setWeight(h,i),this.m_shape.setRank(h,n),t&&this.m_bTrackChanges&&this.m_shape.setGeometryModifiedWithVertex(h,!0),this.m_shape.setSegmentParentageBreakVertex(h,!0)}}splitEdge_(t,e,s,i){this.dbgCheckEdge_(t),e!==-1&&this.dbgCheckEdge_(e),this.disconnectEdge_(t),e!==-1&&this.disconnectEdge_(e),this.processSplitHelper1_(0,t,i),e!==-1&&this.processSplitHelper1_(1,e,i),s!==-1&&i.getResultPointChanged()&&this.m_modifiedClusters.push(s);for(let a=0,h=this.m_modifiedClusters.length;a<h;a++){const m=this.m_modifiedClusters[a],l=this.getClusterEventQNode(m);l!==-1&&(this.m_eventQ.deleteNode(l),this.setClusterEventQNode_(m,-1))}const n=this.getEdgeOriginVertices(t),o=e!==-1?this.getEdgeOriginVertices(e):-1;if(this.applyIntersectorToEditShape_(n,i,0),o!==-1)this.applyIntersectorToEditShape_(o,i,1);else{const a=i.getResultPoint().getXY();this.updateClusterXY(i.getResultPointChanged(),s,a,i.getResultPointWeight(),i.getResultPointRank())}this.createEdgesAndClustersFromSplitEdge_(t,i,0),e!==-1&&this.createEdgesAndClustersFromSplitEdge_(e,i,1),this.m_edgeVertices.deleteList(n),this.deleteEdge_(t),e!==-1&&(this.m_edgeVertices.deleteList(o),this.deleteEdge_(e));for(let a=0,h=this.m_modifiedClusters.length;a<h;a++){const m=this.m_modifiedClusters[a];m===this.m_sweepPointCluster&&(this.m_bSweepPointClusterWasModified=!0);let l=this.getClusterEventQNode(m);if(l===-1){const u=this.getClusterFirstVertex(m);if(l=this.m_eventQ.addUniqueElement(u),l===-1){const c=this.m_eventQ.getDuplicateElement(),g=this.m_eventQ.getElement(c),_=this.getClusterFromVertex(g);this.mergeClusters_(_,m)}else this.setClusterEventQNode_(m,l)}}this.m_modifiedClusters.length=0}getClusterXY(t){const e=this.getClusterFirstVertex(t);return this.m_shape.getXY(e)}getClusterFirstVertex(t){const e=this.getClusterVertices(t);return this.m_clusterVertices.getFirstElement(e)}dbgCheckEdge_(t){}dbgCheckCluster_(t){}dbgCheckNewEdgesArray_(){}dbgSaveSweepStructure_(t){}sweepImpl_(){this.progress_(!0),this.m_bSweepPointClusterWasModified=!1,this.m_sweepPointCluster=-1,this.m_sweepComparator===null&&(this.m_sweepStructure.disableBalancing(),this.m_sweepComparator=new fx(this),this.m_sweepStructure.setComparator(this.m_sweepComparator));const t=[];let e=null,s=null;this.m_prevNeighbour=-1,this.m_nextNeighbour=-1,this.m_bContinuingSegmentChainOptimization=!1;const i=At.impossibleIndex2(),n=At.impossibleIndex3();for(let o=this.m_eventQ.getFirst();o!==-1;){this.progress_(),this.dbgCheckSweepStructure_(),this.m_bContinuingSegmentChainOptimization=!1,this.m_prevNeighbour=-1,this.m_nextNeighbour=-1;const a=this.m_eventQ.getElement(o);this.m_sweepPointCluster=this.getClusterFromVertex(a),this.m_shape.queryXY(a,this.m_sweepPoint),this.m_sweepComparator.setSweepY(this.m_sweepPoint.y,this.m_sweepPoint.x);let h=!1;{const l=this.getClusterFirstEdge(this.m_sweepPointCluster);if(h=l===-1,!h){let u=l;do{const c=this.getEdgeSweepNode(u);c===-1?(this.m_edgesToInsertInSweepStructure.push(u),this.setEdgeSweepNode_(u,n)):c!==n&&t.push(c),u=this.getNextEdge(u,this.m_sweepPointCluster)}while(u!==l)}}if(!this.m_sweepStructure.isAutoBalancing()&&(this.m_sweepStructure.getMaxDepthEver()>4||this.m_edgesToInsertInSweepStructure.length>10)&&this.m_sweepStructure.enableBalancing(),t.length>0){this.m_bContinuingSegmentChainOptimization=t.length===1&&this.m_edgesToInsertInSweepStructure.length===1;for(let c=0,g=t.length;c<g;c++){const _=this.m_sweepStructure.getElement(t[c]);this.setEdgeSweepNode_(_,i)}let l=i,u=i;for(let c=0,g=t.length;c<g;c++){const _=t[c];if(l===i){const d=this.m_sweepStructure.getPrev(_);if(d!==-1){const p=this.m_sweepStructure.getElement(d);this.getEdgeSweepNode(p)!==i&&(l=d)}else l=-1}if(u===i){const d=this.m_sweepStructure.getNext(_);if(d!==-1){const p=this.m_sweepStructure.getElement(d);this.getEdgeSweepNode(p)!==i&&(u=d)}else u=-1}if(l!==i&&u!==i)break}for(let c=0,g=t.length;c<g;c++){const _=t[c],d=this.m_sweepStructure.getElement(_);this.m_sweepStructure.deleteNode(_),this.setEdgeSweepNode_(d,-1)}t.length=0,this.m_prevNeighbour=l,this.m_nextNeighbour=u,l!==-1&&u!==-1?this.m_bContinuingSegmentChainOptimization||this.checkAndFixIntersection_(l,u):l===-1&&u===-1&&(this.m_bContinuingSegmentChainOptimization=!1)}else h&&(e===null&&(e=new xx(this)),e.setPoint(this.m_sweepPoint),this.m_sweepStructure.searchUpperBound(e),e.intersectionDetected()&&(e.clearIntersectionDetectedFlag(),this.fixIntersectionPointSegment_(this.m_sweepPointCluster,e.getCurrentNode())));const m=this.m_bContinuingSegmentChainOptimization;!this.insertNewEdges_()&&m&&this.m_prevNeighbour!==-1&&this.m_nextNeighbour!==-1&&this.checkAndFixIntersection_(this.m_prevNeighbour,this.m_nextNeighbour),this.m_bSweepPointClusterWasModified?(this.m_bSweepPointClusterWasModified=!1,s===null&&(s=new Px(this.m_shape)),s.setPoint(this.m_sweepPoint),o=this.m_eventQ.searchUpperBound(s)):o=this.m_eventQ.getNext(o)}return this.m_bCracked}setEditShape_(t){this.m_shape=t,this.m_vertexClusterIndex=this.m_shape.createUserIndex(),this.m_edges.setCapacity(t.getSelectedCount()+32),this.m_clusters.setCapacity(t.getSelectedCount()),this.m_clusterVertices.reserveLists(t.getSelectedCount()),this.m_clusterVertices.reserveNodes(t.getSelectedCount()),this.m_edgeVertices.reserveLists(t.getSelectedCount()+32),this.m_edgeVertices.reserveNodes(t.getSelectedCount()+32);for(let e=this.m_shape.getFirstGeometry();e!==v;e=this.m_shape.getNextGeometry(e))if(lt(this.m_shape.getGeometryType(e)))for(let s=this.m_shape.getFirstPath(e);s!==v;s=this.m_shape.getNextPath(s)){const i=this.m_shape.getPathSize(s),n=this.m_shape.getFirstVertex(s);if(n===v)continue;let o=this.m_shape.getNextVertex(n);if(o===v||o===n)continue;let a=-1;t.selected(n)&&(a=this.newCluster_(n));let h=-1;a!==-1&&t.selected(o)&&(h=this.newEdge_(n),this.addEdgeToCluster(h,a));let m=h;for(let l=0,u=i-2;l<u;l++){const c=this.m_shape.getNextVertex(o);let g=-1;if(this.m_shape.selected(o)){const _=this.newCluster_(o);m!==-1&&this.addEdgeToCluster(m,_),this.m_shape.selected(c)&&(g=this.newEdge_(o),this.addEdgeToCluster(g,_))}m=g,o=c}if(this.m_shape.isClosedPath(s)){const l=this.m_shape.getNextVertex(o);if(this.m_shape.selected(o)){const u=this.newCluster_(o);if(m!==-1&&this.addEdgeToCluster(m,u),this.m_shape.selected(l)){const c=this.newEdge_(o);this.addEdgeToCluster(c,u),this.addEdgeToCluster(c,a)}}}else{let l=-1;this.m_shape.selected(o)&&(l=this.newCluster_(o),m!==-1&&this.addEdgeToCluster(m,l))}}else for(let s=this.m_shape.getFirstPath(e);s!==v;s=this.m_shape.getNextPath(s)){let i=this.m_shape.getFirstVertex(s);for(let n=0,o=this.m_shape.getPathSize(s);n<o;n++)this.m_shape.selected(i)&&this.newCluster_(i),i=this.m_shape.getNextVertex(i)}this.fillEventQueue()}progress_(t=!1){}dbgCheckSweepStructure_(){}}function Cx(r,t,e,s){e>0&&g_(r,e,t,!1,s),new Ex(s).executeImpl_(r,t)}function Hu(r,t,e){return{vertex0:r,vertex1:t,dir:e}}class Ex{constructor(t){this.m_shape=null,this.m_spikes=[],this.m_points=new Xt(0),this.m_pointsIndex=-1,this.m_dissolvedEdges=0,this.m_progressTracker=t}executeImpl_(t,e){if(this.m_shape=t,t.getPathCount(e)<2&&t.getPointCount(e)<6)return;this.m_points.resize(0);for(let u=t.getFirstPath(e);u!==v;u=t.getNextPath(u)){let c=t.getFirstVertex(u);for(let g=0,_=t.getPathSize(u);g<_;g++,c=t.getNextVertex(c))this.m_points.add(c)}this.m_pointsIndex=t.createUserIndex();for(let u=0,c=this.m_points.size();u<c;++u)t.setUserIndex(this.m_points.read(u),this.m_pointsIndex,u);t.sortVerticesSimpleByY(this.m_points,0,this.m_points.size());let s=this.m_points.read(0);const i=t.getXY(s);let n=1,o=0;const a=[];for(let u=1;u<this.m_points.size();u++){const c=this.m_points.read(u);if(c===v||t.getUserIndex(c,this.m_pointsIndex)===-1)continue;const g=t.getXY(c);if(g.isEqualPoint2D(i))n++;else{if(n>1){for(let _=o;_<u;_++){const d=this.m_points.read(_);if(t.getUserIndex(d,this.m_pointsIndex)===-1)continue;const p=t.getNextVertex(d),f=t.getPrevVertex(d);if(d!==p&&!t.isEqualXYPoint2D(p,i)){const x=Hu(d,p,1);a.push(x)}if(d!==f&&f!==p&&!t.isEqualXYPoint2D(f,i)){const x=Hu(d,f,-1);a.push(x)}}a.length>0&&this.processBunch_(a,i)}s=c,i.assign(g),n=1,o=u}}if(this.m_dissolvedEdges===0)return t.removeUserIndex(this.m_pointsIndex),void(this.m_pointsIndex=-1);let h=t.getPointCount(e);for(let u=0;u<this.m_points.size();u++){const c=this.m_points.read(u);if(c===v)continue;if(t.getUserIndex(c,this.m_pointsIndex)!==-1){t.setUserIndex(c,this.m_pointsIndex,-1);continue}const g=t.getPathFromVertex(c);t.getFirstVertex(g)===c&&t.setFirstVertex(g,v),t.freeVertex(c),this.m_points.write(u,v),h--}const m=t.createPathUserIndex();let l=t.getPathCount(e);for(let u=0,c=this.m_points.size();u<c;++u){if(this.m_points.read(u)===v)continue;let g=this.m_points.read(u);if(t.getUserIndex(g,this.m_pointsIndex)!==-1)continue;let _=t.getPathFromVertex(g),d=-1;if(t.getPathUserIndex(_,m)===2){_=v;for(let E=t.getNextVertex(g);E!==g;E=t.getNextVertex(E)){const P=t.getPathFromVertex(E);if(t.getPathUserIndex(P,m)!==2){_=P,g=E;break}}_===v&&(_=t.insertPath(e,v),t.setClosedPath(_,!0),l++),b(_!==v)}t.setPathUserIndex(_,m,2),d=t.getFirstVertex(_);let p=0,f=!1,x=g;do{d===x&&(f=!0),t.setUserIndex(x,this.m_pointsIndex,1);const E=t.getPathFromVertex(x);E!==_&&(t.getPathUserIndex(E,m)!==2&&(t.setPathUserIndex(E,m,1),t.setFirstVertex(E,v)),t.setPathToVertex(x,_)),p++,x=t.getNextVertex(x)}while(x!==g);f||t.setFirstVertex(_,g),t.setPathSize(_,p)}for(let u=t.getFirstPath(e);u!==v;){const c=t.getNextPath(u);t.getPathUserIndex(u,m)!==1&&t.getFirstVertex(u)!==v||(t.removePathOnly(u),l--),u=c}t.setGeometryVertexCount(e,h),t.setGeometryPathCount(e,l),t.removePathUserIndex(m),t.removeUserIndex(this.m_pointsIndex),this.m_pointsIndex=-1,t.dbgVerifyVertexCounts(),t.filterClosePoints(0,!0,!1,!1,e)}processBunch_(t,e){t.sort((a,h)=>{const m=this.m_shape.getXY(a.vertex1).sub(e),l=this.m_shape.getXY(h.vertex1).sub(e),u=y.compareVectors(m,l);return u===0?a.dir<h.dir?-1:1:u});let s=0;const i=this.m_shape.getXY(t[0].vertex1);let n=1;const o=this.m_shape.hasCurves();for(let a=1,h=t.length;a<h;a++){const m=this.m_shape.getXY(t[a].vertex1);if(!(m.isEqualPoint2D(i)&&(n++,a+1<h))){if(n===2){const l=t[s],u=t[s+1],c=l.dir;if(c!==u.dir){let g=!0;if(o&&(g=!this.m_shape.isCurve(l.dir===1?l.vertex0:l.vertex1)&&!this.m_shape.isCurve(u.dir===1?u.vertex0:u.vertex1)),g){if(c===1){const _=l.vertex0,d=u.vertex0;this.m_shape.setNextVertex(_,d),this.m_shape.setPrevVertex(d,_),this.m_shape.getPrevVertex(_)===d&&(this.m_shape.setUserIndex(_,this.m_pointsIndex,-1),this.m_shape.setUserIndex(d,this.m_pointsIndex,-1));const p=l.vertex1,f=u.vertex1;this.m_shape.setPrevVertex(p,f),this.m_shape.setNextVertex(f,p),this.m_shape.getNextVertex(p)===f&&(this.m_shape.setUserIndex(p,this.m_pointsIndex,-1),this.m_shape.setUserIndex(f,this.m_pointsIndex,-1))}else{const _=l.vertex0,d=u.vertex0;this.m_shape.setPrevVertex(_,d),this.m_shape.setNextVertex(d,_),this.m_shape.getNextVertex(_)===d&&(this.m_shape.setUserIndex(_,this.m_pointsIndex,-1),this.m_shape.setUserIndex(d,this.m_pointsIndex,-1));const p=l.vertex1,f=u.vertex1;this.m_shape.setNextVertex(p,f),this.m_shape.setPrevVertex(f,p),this.m_shape.getPrevVertex(p)===f&&(this.m_shape.setUserIndex(p,this.m_pointsIndex,-1),this.m_shape.setUserIndex(f,this.m_pointsIndex,-1))}this.m_dissolvedEdges+=2}}}i.assign(m),s=a,n=1}}t.length=0}}function f_(r){for(let t=r.getFirstGeometry();t!==v;t=r.getNextGeometry(t))if(lt(r.getGeometryType(t)))return!0;return!1}function Sx(r,t,e,s){if(!f_(r))return!1;const i=new Zi(s);i.m_shape=r,i.m_tolerance=t,i.m_bTrackChanges=e;let n=!1;const o=r.hasCurves()?5:15;return n=r.getTotalPointCount()<o?i.crackBruteForce_():i.crackerPlaneSweep_(),n}function Um(r,t,e,s,i){if(!f_(t))return!1;let n=new Zi(i);if(n.m_shape=t,n.m_tolerance=e,n.m_bAllowCoincident=r,n.m_bNeedsNonSimpleResult=s!==null,n.needsCrackingImpl_())return s&&s.assign(n.m_nonSimpleResult),!0;const o=new pt;o.setSwapCoordinates(),t.applyTransformation(o),n=new Zi(i),n.m_shape=t,n.m_tolerance=e,n.m_bAllowCoincident=r,n.m_bNeedsNonSimpleResult=s!==null;const a=n.needsCrackingImpl_();return t.applyTransformation(o),!!a&&(s&&s.assign(n.m_nonSimpleResult),!0)}function vx(r,t,e,s){const i=t.getGeometryType();if(lt(i))return new Zi(s).crackAWithBMultiPath_(r,t,e);ft("crack_A_with_B")}function zu(r,t){return{t:r,index:t}}class Zi{crackBruteForce_(){let t=this.crackBruteForceImpl_();if(!t&&this.m_shape.hasCurves()){const e=new pt;e.setSwapCoordinates(),this.m_shape.applyTransformation(e),t=this.crackBruteForceImpl_(),this.m_shape.applyTransformation(e)}return t}crackBruteForceImpl_(){let t=!1;const e=new it,s=new it,i=F.constructEmpty(),n=F.constructEmpty(),o=!1,a=new st,h=new He,m=this.m_shape.getTotalPointCount(),l=m*m*2,u=this.m_shape.queryVertexIteratorOnSelection();for(let c=u.next();c!==v;c=u.next()){const g=this.m_shape.getGeometryType(u.currentGeometry());let _=1,d=1,p=1,f=0,x=0,E=0;const P=this.m_shape.getSegmentParentage(c);let C=!1,S=!1,I=null,w=!1;if(xn(g))_=this.m_shape.getWeight(c),f=this.m_shape.getRank(c);else{if(I=this.getSegment_(c,e),I===null)continue;const M=this.m_shape.getVertexIndex(c);_=this.m_shape.getWeightWithIndex(M),f=this.m_shape.getRankWithIndex(M),p=this.m_shape.getSegmentWeightWithIndex(M),E=this.m_shape.getSegmentRankWithIndex(M),C=this.m_shape.getSegmentParentageBreakVertex(c);{const G=this.m_shape.getNextVertex(c);d=this.m_shape.getWeight(G),x=this.m_shape.getRank(G),S=this.m_shape.getSegmentParentageBreakVertex(G)}if(I.queryLooseEnvelope(i),i.inflateCoords(this.m_tolerance,this.m_tolerance),I.isDegenerate(this.m_tolerance)){if(!I.isDegenerate(0))continue;w=!0,I=null}}const D=new Ah({copy:u});let N=D.next();N!==v&&(N=D.next());let A=0;for(;N!==v;N=D.next()){if(A!==0){A--;continue}if(this.m_shape.getTotalPointCount()>l)return t;this.progress_();const M=this.m_shape.getGeometryType(D.currentGeometry());let G=null,q=!1,V=0,k=0,Y=0,U=0,X=0,B=0,W=!1,Z=!1;const gt=this.m_shape.getSegmentParentage(N);if(xn(M))V=this.m_shape.getWeight(N),U=this.m_shape.getRank(N);else{if(G=this.getSegment_(N,s),G===null)continue;const rt=this.m_shape.getVertexIndex(N);V=this.m_shape.getWeightWithIndex(rt),U=this.m_shape.getRankWithIndex(rt),Y=this.m_shape.getSegmentWeightWithIndex(rt),B=this.m_shape.getSegmentRankWithIndex(rt),W=this.m_shape.getSegmentParentageBreakVertex(N);{const nt=this.m_shape.getNextVertex(N);k=this.m_shape.getWeight(nt),X=this.m_shape.getRank(nt),Z=this.m_shape.getSegmentParentageBreakVertex(nt)}if(G.queryLooseEnvelope(n),G.isDegenerate(this.m_tolerance)){if(!G.isDegenerate(0))continue;q=!0,G=null}}let at=0,Q=0;if(I!==null&&G!==null)i.isIntersectingNe(n)&&Pa(!0,!0,I,G,this.m_tolerance,!0)!==0&&(h.pushSegment(I,_,f,d,x,p,E,C,S,P),h.pushSegment(G,V,U,k,X,Y,B,W,Z,gt),h.intersect2D(this.m_tolerance,!0),t||=h.getSegmentChanged(0)||h.getSegmentChanged(1),at=h.getResultSegmentCount(0),Q=h.getResultSegmentCount(1),at+Q>0&&(this.m_shape.splitSegmentWithIntersector(c,h,0,!0,!0),this.m_shape.splitSegmentWithIntersector(N,h,1,!0,!0),this.m_bTrackChanges&&(h.getSegmentChanged(0)&&this.m_shape.setGeometryModifiedWithVertex(c,!0),h.getSegmentChanged(1)&&this.m_shape.setGeometryModifiedWithVertex(N,!0))),Q>1&&(A+=Q-1),h.clear());else if(I!==null){const rt=this.m_shape.getXY(N);if(i.contains(rt)){if(h.pushSegment(I,_,f,d,x,p,E,C,S,P),this.m_shape.queryPoint(N,a),h.intersect2DEx(this.m_tolerance,a,U,V,o),t||=h.getSegmentChanged(0)||h.getResultPointChanged(),at=h.getResultSegmentCount(0),at>0)if(this.m_bTrackChanges&&(h.getSegmentChanged(0)&&this.m_shape.setGeometryModifiedWithVertex(c,!0),h.getSegmentChanged(1)&&this.m_shape.setGeometryModifiedWithVertex(N,!0)),this.m_shape.splitSegmentWithIntersector(c,h,0,!0,!0),q){let nt=v;for(let ot=this.m_shape.getNextVertex(N);ot!==v&&ot!==N&&(G=this.getSegment_(ot,s),nt=ot,G!=null&&G.isDegenerate(0));ot=this.m_shape.getNextVertex(ot));for(let ot=N;ot!==v&&(this.m_shape.setPoint(ot,h.getResultPoint(),!0),ot!==nt);ot=this.m_shape.getNextVertex(ot));}else this.m_shape.setPoint(N,h.getResultPoint(),!0);h.clear()}}else{if(G===null)continue;{const rt=this.m_shape.getXY(c);if(n.inflateCoords(this.m_tolerance,this.m_tolerance),n.contains(rt)){if(h.pushSegment(G,V,U,k,X,Y,B,W,Z,gt),this.m_shape.queryPoint(c,a),h.intersect2DEx(this.m_tolerance,a,f,_,o),t||=h.getSegmentChanged(0)||h.getResultPointChanged(),Q=h.getResultSegmentCount(0),Q>0)if(this.m_bTrackChanges&&(h.getSegmentChanged(0)&&this.m_shape.setGeometryModifiedWithVertex(N,!0),h.getSegmentChanged(1)&&this.m_shape.setGeometryModifiedWithVertex(c,!0)),this.m_shape.splitSegmentWithIntersector(N,h,0,!0,!0),A+=Q-1,w){let nt=v;for(let ot=this.m_shape.getNextVertex(c);ot!==v&&ot!==c&&(G=this.getSegment_(ot,s),nt=ot,G!=null&&G.isDegenerate(0));ot=this.m_shape.getNextVertex(ot));for(let ot=c;ot!==v&&(this.m_shape.setPoint(ot,h.getResultPoint(),!0),ot!==nt);ot=this.m_shape.getNextVertex(ot));}else this.m_shape.setPoint(c,h.getResultPoint(),!0);h.clear()}}}if(at+Q!==0&&at!==0){let rt=!1;for(;I=this.getSegment_(c,e),I!=null&&(I.queryEnvelope(i),I.isDegenerate(this.m_tolerance));){if(!(at>1)){rt=!0;break}c=u.next(),at--,b(c!==v)}if(rt)break}}}return t}crackerPlaneSweep_(){return this.planesweep_()}planesweep_(){return new sm(this.m_progressTracker,this.m_bTrackChanges).sweep(this.m_shape,this.m_tolerance)}needsCrackingImpl_(){let t=!1;const e=new Xt(0);e.resize(this.m_shape.getSelectedCount());const s=this.m_shape.queryVertexIteratorOnSelection();for(let u=0,c=s.next();c!==v;++u,c=s.next())e.write(u,c);this.m_shape.sortVerticesSimpleByY(e,0,e.size()),e.add(v);const i=this.m_shape.createUserIndex(),n=this.m_shape.createUserIndex();this.m_sweepComparator=new u_(this.m_shape,this.m_tolerance,!this.m_bAllowCoincident),this.m_sweepStructure.setComparator(this.m_sweepComparator);let o=null;const a=[],h=[];let m=0;const l=new y;for(let u=e.read(m++);u!==v;){this.m_shape.queryXY(u,l);let c=!1;do{let f=this.m_shape.getNextVertex(u),x=this.m_shape.getPrevVertex(u);c||=f!==v||x!==v,f===v||this.m_shape.selected(f)||(f=v),x===v||this.m_shape.selected(x)||(x=v),f!==v&&this.m_shape.compareVerticesSimpleY(u,f)<0&&(h.push(u),h.push(f)),x!==v&&this.m_shape.compareVerticesSimpleY(u,x)<0&&(h.push(x),h.push(x));const E=this.m_shape.getUserIndex(u,i);E!==-1&&(a.push(E),this.m_shape.setUserIndex(u,i,-1));const P=this.m_shape.getUserIndex(u,n);P!==-1&&(a.push(P),this.m_shape.setUserIndex(u,n,-1)),u=e.read(m++)}while(u!==v&&this.m_shape.isEqualXYPoint2D(u,l));if(!c&&(o===null&&(o=new c_(this.m_shape,this.m_tolerance)),o.setPoint(l),this.m_sweepStructure.searchUpperBound(o),o.intersectionDetected())){t=!0,this.m_bNeedsNonSimpleResult&&($("needsCrackingIMpl_"),this.m_nonSimpleResult=new Tt(6,-1,-1));break}let g=a.length===1&&h.length===2;a.length>32&&Mr(a);let d=-1,p=-1;if(!g)for(let f=0,x=a.length;f<x;f++){const E=a[f],P=this.m_sweepStructure.getPrev(E);if(P!==-1&&a.indexOf(P)===-1)if(d===-1)d=P;else{if(t=!0,!this.m_bNeedsNonSimpleResult)break;this.m_nonSimpleResult=new Tt(6,-1,-1)}const C=this.m_sweepStructure.getNext(E);if(C!==-1&&a.indexOf(C)===-1)if(p===-1)p=C;else{if(t=!0,!this.m_bNeedsNonSimpleResult)break;this.m_nonSimpleResult=new Tt(6,-1,-1)}if(d!==-1&&p!==-1)break}if(t&&!this.m_bNeedsNonSimpleResult)break;if(this.m_sweepComparator.setSweepY(l.y,l.x),!g){for(let f=0,x=a.length;f<x;f++){const E=a[f];this.m_sweepStructure.deleteNode(E)}a.length=0}if(!g&&d!==-1&&p!==-1&&this.checkForIntersections_(d,p)){t=!0,this.m_bNeedsNonSimpleResult&&(this.m_nonSimpleResult=this.m_sweepComparator.getResult());break}for(let f=0,x=h.length;f<x;f+=2){const E=h[f],P=h[f+1];let C;if(g?(C=this.m_sweepStructure.replaceElementAtPosition(a[0],E,!0,!0),a.length=0,g=!1):C=this.m_sweepStructure.addElement(E),this.m_sweepComparator.intersectionDetected()){this.m_bNeedsNonSimpleResult&&(this.m_nonSimpleResult=this.m_sweepComparator.getResult()),t=!0;break}this.m_shape.getUserIndex(P,i)===-1?this.m_shape.setUserIndex(P,i,C):this.m_shape.setUserIndex(P,n,C)}if(t)break;h.length=0}return this.m_shape.removeUserIndex(i),this.m_shape.removeUserIndex(n),t}checkForIntersections_(t,e){const s=this.m_sweepStructure.getElement(t);this.m_sweepComparator.compare(this.m_sweepStructure,s,e);const i=this.m_sweepComparator.intersectionDetected();return this.m_sweepComparator.clearIntersectionDetectedFlag(),i}getSegment_(t,e){return Zi.st_getSegment(this.m_shape,t,e)}static st_getSegment(t,e,s){return t.querySegment(e,s,!1,!1)?s.get():null}dbgPrintSweepEdge(t){}dbgPrintSweepStructure(){}dbgSaveSweepStructure(t=null){}dbgCheckSweepStructure(){}progress_(t=!1){this.m_progressCounter++}crackAWithBMultiPath_(t,e,s){const i=F.constructEmpty();t.queryLooseEnvelope(i);const n=F.constructEmpty();if(e.queryLooseEnvelope(n),n.inflateCoords(s,s),!n.isIntersecting(i))return t;const o=t.getImpl(),a=o.getAccelerators();let h=null,m=null;a&&(m=a.getQuadTree()),bx(t,sr(e))&&(h=Pn(o,n),m=h);const l=m?m.getIteratorForQT():null,u=e.querySegmentIterator(),c=t.querySegmentIterator(),g=j(15,Number.NaN),_=[];for(;u.nextPath();)for(;u.hasNextSegment();){const P=u.nextSegment();if(m){l.resetIterator(P,s);for(let C=l.next();C!==-1;C=l.next()){this.progress_();const S=m.getElement(C);if(c.resetToVertex(S,-1),c.hasNextSegment()){const I=c.nextSegment().intersect(P,null,g,null,s);for(let w=0;w<I;w++){const D=g[w];if(D===0||D===1)continue;const N=zu(D,c.getStartPointIndex());_.push(N)}}}}else{const C=F.constructEmpty();if(P.queryLooseEnvelope(C),C.inflateCoords(s,s),!i.isIntersecting(C))continue;for(c.resetToFirstPath();c.nextPath();)for(;c.hasNextSegment();){const S=c.nextSegment(),I=F.constructEmpty();if(S.queryLooseEnvelope(I),!I.isIntersecting(C))continue;const w=S.intersect(P,null,g,null,s);for(let D=0;D<w;D++){const N=g[D];if(N===0||N===1)continue;const A=zu(N,c.getStartPointIndex());_.push(A)}}}}if(_.length===0)return t;_.sort((P,C)=>P.index<C.index?-1:P.index>C.index?1:P.t<C.t?-1:P.t>C.t?1:0);const d=t.createInstance();for(d.getGeometryType()===T.enumPolygon&&d.setFillRule(t.getFillRule()),c.resetToFirstPath();c.nextPath()&&!c.hasNextSegment(););b(c.hasNextSegment());let p=c.nextSegment();const f=new it;let x=-1;for(let P=0,C=_.length;P<C;){const S=_[P].index;let I=P+1;for(;I<C&&_[I].index===S;)++I;for(;c.getStartPointIndex()<S;){this.progress_();const N=c.hasNextSegment(),A=c.getPathIndex();if((N||!c.isClosingSegment()||c.isCurve())&&(b(p!==null),d.addSegment(p,x!==A)),x=A,!N){for(c.isPathClosed();c.nextPath()&&!c.hasNextSegment(););b(c.hasNextSegment())}p=c.nextSegment()}let w=0;for(let N=P;N<I;N++){const A=_[N].t;if(A===w)continue;b(p!==null),p.queryCut(w,A,f),w=A;const M=c.getPathIndex();d.addSegment(f.get(),x!==M),x=M}const D=c.hasNextSegment();if((D||!c.isClosingSegment()||c.isCurve())&&(b(p!=null),p.queryCut(w,1,f),d.addSegment(f.get(),!1)),D)p=c.nextSegment();else{for(;c.nextPath()&&!c.hasNextSegment(););p=c.hasNextSegment()?c.nextSegment():null}P=I}if(p!==null){const P=c.getPathIndex();(c.hasNextSegment()||!c.isClosingSegment()||c.isCurve())&&d.addSegment(p,x!==P),x=P}let E=c.hasNextSegment();for(;;){if(!E){for(;c.nextPath()&&(E=c.hasNextSegment(),!E););if(!E)break}p=c.nextSegment();const P=c.getPathIndex();E=c.hasNextSegment(),(E||!c.isClosingSegment()||c.isCurve())&&d.addSegment(p,x!==P),x=P}return d}constructor(t){this.m_shape=null,this.m_progressTracker=null,this.m_nonSimpleResult=new Tt,this.m_tolerance=0,this.m_sweepComparator=null,this.m_progressCounter=0,this.m_bTrackChanges=!1,this.m_bNeedsNonSimpleResult=!1,this.m_bAllowCoincident=!0,this.m_sweepStructure=new tt,this.m_progressTracker=t}}function bx(r,t){const e=r.getPointCount();return e<16?!1:2*e+1*(Math.log(e)/Math.log(2))*t<1*e*t}Zi.s_bForceBruteForce=!0;class x_{constructor(t,e){this.m_monotoneParts=R(it,16),this.m_xOrds=j(16,Number.NaN),this.m_inputPoint=y.getNAN(),this.m_miny=0,this.m_maxy=0,this.m_windnum=0,this.m_bAlternate=t,this.m_tolerance=e,this.m_toleranceSqr=e*e,this.m_bTestBorder=!!e,this.m_bBreak=!1}_DoOne(t){if(!this.m_bTestBorder&&(this.m_bAlternate&&this.m_inputPoint.equals(t.getStartXY())||this.m_inputPoint.equals(t.getEndXY())))return void(this.m_bBreak=!0);if(t.getStartY()===this.m_inputPoint.y&&t.getStartY()===t.getEndY()){if(this.m_bAlternate&&!this.m_bTestBorder){const i=Math.min(t.getStartX(),t.getEndX()),n=Math.max(t.getStartX(),t.getEndX());this.m_inputPoint.x>i&&this.m_inputPoint.x<n&&(this.m_bBreak=!0)}return}let e=!1;const s=Math.max(t.getStartX(),t.getEndX());if(this.m_inputPoint.x>s)e=!0;else if(this.m_inputPoint.x>=Math.min(t.getStartX(),t.getEndX())){const i=t.intersectionOfYMonotonicWithAxisX(this.m_inputPoint.y,s);e=!Number.isNaN(i)&&i<=this.m_inputPoint.x}if(e){if(this.m_inputPoint.y===t.getStartY()){if(this.m_inputPoint.y<t.getEndY())return}else if(this.m_inputPoint.y===t.getEndY()&&this.m_inputPoint.y<t.getStartY())return;this.m_bAlternate?this.m_windnum^=1:this.m_windnum+=t.getStartY()>t.getEndY()?1:-1}}_Result(){return!!this.m_windnum}testBorder(t){const e=t.getClosestCoordinate(this.m_inputPoint,!1),s=t.getCoord2D(e);return y.sqrDistance(s,this.m_inputPoint)<=this.m_toleranceSqr}setInputPoint(t){this.m_inputPoint.setCoordsPoint2D(t),this.m_miny=t.y-this.m_tolerance,this.m_maxy=t.y+this.m_tolerance}processSegment(t){const e=t.queryInterval(0,1);if(e.vmin>this.m_maxy||e.vmax<this.m_miny)return!1;if(this.m_bTestBorder&&this.testBorder(t))return!0;if(e.vmin>this.m_inputPoint.y||e.vmax<this.m_inputPoint.y)return!1;let s=0;if(t.isCurve()&&(this.m_monotoneParts.length===0&&(this.m_monotoneParts.length=128),s=t.getMonotonicParts(this.m_monotoneParts,!0),b(this.m_monotoneParts.length>=s)),s>0)for(let i=0;i<s;i++){const n=this.m_monotoneParts[i].get(),o=z.construct(n.getStartY(),n.getEndY());if(!(o.vmin>this.m_inputPoint.y||o.vmax<this.m_inputPoint.y)&&(this._DoOne(n),this.m_bBreak))return!0}else if(this._DoOne(t),this.m_bBreak)return!0;return!1}result(){return b(0),2}}function Ix(r,t,e,s){const i=new F;r.queryLooseEnvelope(i),i.inflateCoords(s,s);const n=r.getFillRule()===0,o=new x_(n,s);o.setInputPoint(e);const a=i.clone();a.xmax=e.x+s,a.ymin=e.y-s,a.ymax=e.y+s;const h=r.getImpl().querySegmentIterator(),m=t.getIterator(a,s);for(let l=m.next();l!==-1;l=m.next())if(h.resetToVertex(t.getElement(l),-1),h.hasNextSegment()){const u=h.nextSegment();if(o.processSegment(u))return-1}return o._Result()?1:0}function wx(r,t,e){const s=r.getFillRule()===0,i=new x_(s,e);i.setInputPoint(t);const n=r.getImpl().querySegmentIterator();for(;n.nextPath();)for(;n.hasNextSegment();){const o=n.nextSegment();if(i.processSegment(o))return-1}return i._Result()?1:0}function Dx(r,t,e){return t.isEmpty()?0:$o(r,t.getXY(),e)}function $o(r,t,e){if(r.isEmpty())return 0;const s=F.constructEmpty();if(r.queryLooseEnvelope(s),s.inflateCoords(e,e),!s.contains(t))return 0;const i=r.getImpl().getAccelerators();if(i){i.getRasterizedGeometry()&&b(0);const n=i.getQuadTree();if(n)return Ix(r,n,t,e)}return wx(r,t,e)}function Ii(r,t){const e=r.getPointCount();return e<16?!1:2*e+1*(Math.log(e)/Math.log(2))*t<1*e*t}function Tx(r,t,e,s,i){const n=new y_(i);return n.m_shape=r,n.m_geometry=t,n.m_sortedVertices=e,n.m_bFixSelfTangency=s,n.fixRingOrientation_()}function Nx(r,t,e){const s=new y_(e);return s.m_shape=r,s.m_geometry=t,s.m_sortedVertices=null,s.m_bFixSelfTangency=!1,s.fixRingOrientationForMp2sp_()}class Ax{getDirection_(t){return this.m_shape.getNextVertex(this.getEnd1(t))===this.getEnd2(t)}getEnd_(t){const e=this.getEnd1(t),s=this.getEnd2(t);return this.m_shape.getNextVertex(e)===s?s:e}constructor(t){this.m_end1Nodes=[],this.m_end2Nodes=[],this.m_directions=[],this.m_shape=t,this.m_firstFree=-1}getSegment(t){return this.m_shape.getSegment(this.getStart(t))}isBottomUp(t){let e=this.getEnd1(t),s=this.getEnd2(t);this.m_shape.getPrevVertex(e)===s&&(s=O(e,e=s));const i=y.getNAN(),n=y.getNAN();return this.m_shape.queryXY(e,i),this.m_shape.queryXY(s,n),b(!i.equals(n)),i.y<n.y}getStart(t){const e=this.getEnd1(t),s=this.getEnd2(t);return this.m_shape.getNextVertex(e)===s?e:s}getEnd1(t){return this.m_end1Nodes[t]}getEnd2(t){return this.m_end2Nodes[t]}freeEdge(t){this.m_end1Nodes[t]=this.m_firstFree,this.m_firstFree=t}newEdge(t){if(this.m_firstFree!==-1){const s=this.m_firstFree;return this.m_firstFree=this.m_end1Nodes[s],this.m_end1Nodes[s]=t,this.m_end2Nodes[s]=this.m_shape.getNextVertex(t),s}const e=this.m_end1Nodes.length;return this.m_end1Nodes.push(t),this.m_end2Nodes.push(this.m_shape.getNextVertex(t)),e}getShape(){return this.m_shape}getPath(t){return this.m_shape.getPathFromVertex(this.getEnd1(t))}}let qx=class extends tn{constructor(r){super(),this.m_line1=new ht,this.m_line2=new ht,this.m_leftElm=-1,this.m_leftx=0,this.m_seg1=null,this.m_helper=r}compare(r,t,e){const s=r.getElement(e),i=this.m_helper.m_edges;let n;this.m_leftElm===t?n=this.m_leftx:(this.m_seg1=i.getSegment(t),this.m_seg1?n=this.m_seg1.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0):(i.getShape().queryLineConnector(i.getStart(t),this.m_line1,!0),this.m_seg1=this.m_line1,n=this.m_line1.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0)),this.m_leftx=n,this.m_leftElm=t);let o,a=i.getSegment(s);if(a?o=a.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0):(i.getShape().queryLineConnector(i.getStart(s),this.m_line2,!0),a=this.m_line2,o=this.m_line2.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0)),n===o){const h=i.isBottomUp(t),m=i.isBottomUp(s),l=h?this.m_seg1.getEndY():this.m_seg1.getStartY(),u=m?a.getEndY():a.getStartY(),c=Math.min(l,u);let g=.5*(c+this.m_helper.m_yScanline);g===this.m_helper.m_yScanline&&(g=c),n=this.m_seg1.intersectionOfYMonotonicWithAxisX(g,0),o=a.intersectionOfYMonotonicWithAxisX(g,0),n===o&&To("")}return n<o?-1:n>o?1:0}reset(){this.m_leftElm=-1}};class Uu{constructor(t){this.m_node=-1,this.m_index=0,this.m_sortedVertices=t.m_sortedVertices,this.m_sortedVerticesArray=t.m_sortedVerticesArray,this.m_sortedVertices&&(this.m_node=this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList()))}next(){if(this.m_sortedVertices){const t=this.m_node;if(t===-1)return v;const e=this.m_sortedVertices.getData(t);return this.m_node=this.m_sortedVertices.getNext(t),e}if(this.m_index<this.m_sortedVerticesArray.size()){const t=this.m_sortedVerticesArray.read(this.m_index);return this.m_index++,t}return v}}class y_{constructor(t){this.m_edges=null,this.m_shape=null,this.m_AET=new tt,this.m_yScanline=0,this.m_geometry=v,this.m_unknownRingOrientationCount=-1,this.m_sortedVertices=null,this.m_sortedVerticesArray=null,this.m_unknownNodes=[],this.m_node1UserIndex=-1,this.m_node2UserIndex=-1,this.m_pathOrientationIndex=-1,this.m_pathParentageIndex=-1,this.m_pathParentsIndex=-1,this.m_progressCounter=0,this.m_bFixSelfTangency=!1,this.m_progressTracker=t,this.m_AET.disableBalancing(),this.m_sweepComparator=new qx(this),this.m_AET.setComparator(this.m_sweepComparator)}fixRingOrientation_(){const t=this.fixRingOrientationImplMain_();return this.m_pathOrientationIndex===-1||this.fixRingOrientationImplSimplify_(),t}fixRingOrientationForMp2sp_(){return this.fixRingOrientationImplMain_(),this.m_pathOrientationIndex===-1?-1:this.fixRingOrientationImplMp2sp_()}processBunchForRingOrientationTest_(t){return this.processBunchForRingOrientationTestOddEven_(t)}processBunchForRingOrientationTestOddEven_(t){let e=!1;if(this.m_edges||(this.m_edges=new Ax(this.m_shape)),this.m_unknownNodes.length=0,this.processBunchForRingOrientationRemoveEdges_(t),!this.m_AET.isAutoBalancing()){let s=0;for(let i=0,n=t.length;i<n;i++)t[i]!==-1&&s++;(s>10||this.m_AET.getMaxDepthEver()>4)&&this.m_AET.enableBalancing()}for(let s=0,i=t.length;s<i;s++){const n=t[s];n!==v&&this.insertEdge_(n,-1)}for(let s=0;s<this.m_unknownNodes.length&&this.m_unknownRingOrientationCount>0;s++){const i=this.m_unknownNodes[s],n=this.m_AET.getElement(i),o=this.m_edges.getPath(n),a=this.m_shape.getPathUserIndex(o,this.m_pathOrientationIndex);let h=v;if(a===0){let m=this.m_AET.getPrev(i),l=i,u=!1;for(;m!==tt.st_nullNode();){const c=this.m_AET.getElement(m),g=this.m_edges.getPath(c);if(this.m_shape.getPathUserIndex(g,this.m_pathOrientationIndex)!==0){h=g;break}l=m,m=this.m_AET.getPrev(m)}if(m===tt.st_nullNode())u=!0,m=l;else{const c=this.m_AET.getElement(m);u=this.m_edges.isBottomUp(c),m=this.m_AET.getNext(m),u=!u}do{const c=this.m_AET.getElement(m),g=this.m_edges.getPath(c);if(this.m_shape.getPathUserIndex(g,this.m_pathOrientationIndex)===0){if(u!==this.m_edges.isBottomUp(c)){const _=this.m_shape.getFirstVertex(g);this.m_shape.reverseRingInternal(_),this.m_shape.setLastVertex(g,this.m_shape.getPrevVertex(_)),e=!0}if(this.m_shape.setPathUserIndex(g,this.m_pathOrientationIndex,u?3:2),!u){let _=this.m_shape.getPathUserIndex(h,this.m_pathOrientationIndex);_===2?(h=this.m_shape.getPathUserIndex(h,this.m_pathParentsIndex),_=this.m_shape.getPathUserIndex(h,this.m_pathOrientationIndex),b(_===3)):b(_===3);const d=this.m_shape.getPathUserIndex(h,this.m_pathParentageIndex);this.m_shape.setPathUserIndex(h,this.m_pathParentageIndex,g),this.m_shape.setPathUserIndex(g,this.m_pathParentageIndex,d),this.m_shape.setPathUserIndex(g,this.m_pathParentsIndex,h)}if(this.m_unknownRingOrientationCount--,!this.m_unknownRingOrientationCount)return e}h=g,l=m,m=this.m_AET.getNext(m),u=!u}while(l!==i)}}return e}processBunchForRingOrientationRemoveEdges_(t){for(let e=0,s=t.length;e<s;e++){const i=t[e],n=this.m_shape.getUserIndex(i,this.m_node1UserIndex),o=this.m_shape.getUserIndex(i,this.m_node2UserIndex);if(n!==-1){const h=this.m_AET.getElement(n);this.m_edges.freeEdge(h),this.m_shape.setUserIndex(i,this.m_node1UserIndex,-1)}if(o!==-1){const h=this.m_AET.getElement(o);this.m_edges.freeEdge(h),this.m_shape.setUserIndex(i,this.m_node2UserIndex,-1)}let a=-1;n!==-1&&o!==-1?(this.m_AET.deleteNode(n),this.m_AET.deleteNode(o),t[e]=v):a=n!==-1?n:o,a!==-1&&(this.insertEdge_(i,a)||this.m_AET.deleteNode(a),t[e]=v)}}dbgVerifyRingOrientation_(){}insertEdge_(t,e){const s=y.getNAN(),i=y.getNAN();this.m_shape.queryXY(t,s);const n=this.m_shape.getNextVertex(t);this.m_shape.queryXY(n,i);let o=!1;if(s.y<i.y){o=!0;const h=this.m_edges.newEdge(t);let m;e===-1?m=this.m_AET.addElement(h):(m=e,this.m_AET.setElement(m,h)),this.m_shape.getUserIndex(n,this.m_node1UserIndex)===-1?this.m_shape.setUserIndex(n,this.m_node1UserIndex,m):this.m_shape.setUserIndex(n,this.m_node2UserIndex,m);const l=this.m_shape.getPathFromVertex(t);this.m_shape.getPathUserIndex(l,this.m_pathOrientationIndex)===0&&this.m_unknownNodes.push(m)}const a=this.m_shape.getPrevVertex(t);if(this.m_shape.queryXY(a,i),s.y<i.y){o=!0;const h=this.m_edges.newEdge(a);let m;e===-1?m=this.m_AET.addElement(h):(m=e,this.m_AET.setElement(m,h)),this.m_shape.getUserIndex(a,this.m_node1UserIndex)===-1?this.m_shape.setUserIndex(a,this.m_node1UserIndex,m):this.m_shape.setUserIndex(a,this.m_node2UserIndex,m);const l=this.m_shape.getPathFromVertex(t);this.m_shape.getPathUserIndex(l,this.m_pathOrientationIndex)===0&&this.m_unknownNodes.push(m)}return o}fixRingSelfTangency_(){const t=[],e=[];let s=-1,i=-1;const n=new y;let o=v,a=v,h=-1;const m=new Uu(this);for(let l=m.next();l!==v;l=m.next()){const u=new y;this.m_shape.queryXY(l,u);const c=this.m_shape.getPathFromVertex(l);n.equals(u)&&a===c?(i===-1&&(s=this.m_shape.createPathUserIndex(),this.m_shape.fillPathUserIndexForGeometry(this.m_geometry,s,-1),i=this.m_shape.createUserIndex(),this.m_shape.fillUserIndexForGeometry(this.m_geometry,i,-1)),h===-1&&(h=e.length,this.m_shape.setUserIndex(o,i,h),e.push(1),this.m_shape.getPathUserIndex(c,s)===-1&&(this.m_shape.setPathUserIndex(c,s,o),t.push(c))),this.m_shape.setUserIndex(l,i,h),e[e.length-1]++):(h=-1,n.assign(u)),o=l,a=c}if(t.length===0)return!1;b(s!==-1);for(let l=0,u=t.length;l<u;l++){const c=t[l];let g=this.m_shape.getPathUserIndex(c,s);const _=this.m_shape.getUserIndex(g,i),d=[],p=[];d.push(g),p.push(_);for(let f=this.m_shape.getNextVertex(g);f!==g;f=this.m_shape.getNextVertex(f)){const x=f,E=this.m_shape.getUserIndex(x,i);if(E!==-1){if(p.length===0){p.push(E),d.push(x);continue}if(p.at(-1)===E){const P=d.at(-1);this.m_shape.peelALoopIntoAPath(P,x),this.m_shape.setUserIndex(f,i,-1),e[E]--,e[E]===1&&(e[E]=0,p.pop(),d.pop()),g=P,f=P}else d.push(f),p.push(E)}}}return this.m_shape.removePathUserIndex(s),this.m_shape.removeUserIndex(i),this.m_shape.dbgVerifyVertexCounts(),!0}progress_(t=!1){}fixRingOrientationImplMain_(){const t={stack:[],error:void 0,hasError:!1};try{let e,s=!1;const i=Te(t,$c(()=>{this.m_sortedVerticesArray=null}),!1);if(this.m_sortedVertices===null){const h=this.m_shape.getPointCount(this.m_geometry);e=new Xt(0);for(let m=this.m_shape.getFirstPath(this.m_geometry);m!==v;m=this.m_shape.getNextPath(m)){let l=this.m_shape.getFirstVertex(m);for(let u=0,c=this.m_shape.getPathSize(m);u<c;u++)e.add(l),l=this.m_shape.getNextVertex(l)}this.m_shape.sortVerticesSimpleByY(e,0,h),this.progress_(!0),this.m_sortedVerticesArray=e}else i.bForget=!0;if(this.m_bFixSelfTangency&&(s=this.fixRingSelfTangency_()),this.m_shape.getPathCount(this.m_geometry)===1){const h=this.m_shape.getFirstPath(this.m_geometry),m=this.m_shape.getRingArea(h);if(this.m_shape.setExterior(h,!0),m<0){const l=this.m_shape.getFirstVertex(h);return this.m_shape.reverseRingInternal(l),this.m_shape.setLastVertex(h,this.m_shape.getPrevVertex(l)),!0}return!1}this.m_shape.dbgVerifyCurves(),this.m_pathOrientationIndex=this.m_shape.createPathUserIndex(),this.m_pathParentageIndex=this.m_shape.createPathUserIndex(),this.m_pathParentsIndex=this.m_shape.createPathUserIndex();for(let h=this.m_shape.getFirstPath(this.m_geometry);h!==v;h=this.m_shape.getNextPath(h))this.m_shape.setPathUserIndex(h,this.m_pathOrientationIndex,0),this.m_shape.setPathUserIndex(h,this.m_pathParentageIndex,-1),this.m_shape.setPathUserIndex(h,this.m_pathParentsIndex,-1);const n=[];this.m_yScanline=Number.NaN;const o=y.getNAN();this.m_unknownRingOrientationCount=this.m_shape.getPathCount(this.m_geometry),this.m_node1UserIndex=this.m_shape.createUserIndexUninitialized(),this.m_shape.fillUserIndexForGeometry(this.m_geometry,this.m_node1UserIndex,-1),this.m_node2UserIndex=this.m_shape.createUserIndexUninitialized(),this.m_shape.fillUserIndexForGeometry(this.m_geometry,this.m_node2UserIndex,-1);const a=new Uu(this);for(let h=a.next();h!==v&&(this.progress_(),this.m_shape.queryXY(h,o),o.y!==this.m_yScanline&&n.length&&(s=this.processBunchForRingOrientationTest_(n)||s,this.m_sweepComparator.reset(),n.length=0),n.push(h),this.m_yScanline=o.y,this.m_unknownRingOrientationCount!==0);h=a.next());return this.m_unknownRingOrientationCount>0&&(s=this.processBunchForRingOrientationTest_(n)||s,n.length=0),this.m_shape.removeUserIndex(this.m_node1UserIndex),this.m_shape.removeUserIndex(this.m_node2UserIndex),this.dbgVerifyRingOrientation_(),s}catch(e){t.error=e,t.hasError=!0}finally{li(t)}}fixRingOrientationImplSimplify_(){const t=[];for(let e=this.m_shape.getFirstPath(this.m_geometry);e!==v;)if(this.progress_(),this.m_shape.getPathUserIndex(e,this.m_pathOrientationIndex)===3){this.m_shape.setExterior(e,!0);for(let n=this.m_shape.getPathUserIndex(e,this.m_pathParentageIndex);n!==v;){const o=this.m_shape.getPathUserIndex(n,this.m_pathParentageIndex);t.push(n),this.m_shape.setExterior(n,!1),this.m_shape.setPathUserIndex(n,this.m_pathParentageIndex,e),n=o}let s=e,i=t.length;for(let n=this.m_shape.getNextPath(e);i>0&&n!==v;n=this.m_shape.getNextPath(n),--i){if(this.m_shape.getPathUserIndex(n,this.m_pathParentageIndex)!==e){s=v;break}s=n}if(i!==0){s=e;for(let n=0,o=t.length;n<o;n++){const a=t[n];this.m_shape.setPathUserIndex(a,this.m_pathParentageIndex,un),this.m_shape.movePath(this.m_geometry,this.m_shape.getNextPath(s),a),s=a}}t.length=0,e=this.m_shape.getNextPath(s)}else e=this.m_shape.getNextPath(e);this.m_shape.removePathUserIndex(this.m_pathOrientationIndex),this.m_shape.removePathUserIndex(this.m_pathParentageIndex),this.m_shape.removePathUserIndex(this.m_pathParentsIndex)}fixRingOrientationImplMp2sp_(){const t=this.m_shape.createPathUserIndex();let e=0;const s=[];for(let i=this.m_shape.getFirstPath(this.m_geometry);i!==v;)if(this.progress_(),this.m_shape.getPathUserIndex(i,this.m_pathOrientationIndex)===3){this.m_shape.setExterior(i,!0),this.m_shape.setPathUserIndex(i,t,e),e++;for(let h=this.m_shape.getPathUserIndex(i,this.m_pathParentageIndex);h!==v;){const m=this.m_shape.getPathUserIndex(h,this.m_pathParentageIndex);s.push(h),this.m_shape.setExterior(h,!1),this.m_shape.setPathUserIndex(h,this.m_pathParentageIndex,i),h=m}let n=i,o=s.length,a=e;for(let h=this.m_shape.getNextPath(i);o>0&&h!==v;h=this.m_shape.getNextPath(h),--o){if(this.m_shape.getPathUserIndex(h,this.m_pathParentageIndex)!==i){n=v;break}n=h,this.m_shape.setPathUserIndex(h,t,-a),a++}if(o!==0){n=i,a=e;for(let h=0,m=s.length;h<m;h++){const l=s[h];this.m_shape.setPathUserIndex(l,t,-a),a++,this.m_shape.setPathUserIndex(l,this.m_pathParentageIndex,un)}n=i}e=a,s.length=0,i=this.m_shape.getNextPath(n)}else i=this.m_shape.getNextPath(i);return this.m_shape.removePathUserIndex(this.m_pathOrientationIndex),this.m_shape.removePathUserIndex(this.m_pathParentageIndex),this.m_shape.removePathUserIndex(this.m_pathParentsIndex),t}}function ii(r,t,e,s,i,n){const o=new Fx(n);return o.m_shape=r,o.m_geometry=t,o.m_knownSimpleResult=e,o.m_bFixSelfTangency=s,o.m_polylineDegeneracies=i,o.m_bHasSegmentParentage=r.hasSegmentParentage(),o.m_bHasSegments=r.hasCurves(),o.simplify_()}class Fx{constructor(t){this.m_shape=null,this.m_geometry=v,this.m_sortedVertices=new ge,this.m_bunchEdgeEndPoints=[],this.m_bunchEdgeCenterPoints=[],this.m_bunchEdgeIndices=[],this.m_sorterSegmentBuffer1=null,this.m_sorterSegmentBuffer2=null,this.m_knownSimpleResult=-1,this.m_sortedVerticesListIndex=-1,this.m_polylineDegeneracies=v,this.m_userIndexSortedIndexToVertex=-1,this.m_userIndexSortedAngleIndexToVertex=-1,this.m_nextVertexToProcess=-1,this.m_firstCoincidentVertex=-1,this.m_progressCounter=0,this.m_bFixSelfTangency=!1,this.m_bHasSegmentParentage=!1,this.m_bHasSegments=!1,this.m_progressTracker=t}compareAngles_(t,e){return this.m_bHasSegments?this.compareAnglesCurves_(t,e):this.compareAnglesLines_(t,e)}compareAnglesLines_(t,e){const s=this.m_bunchEdgeEndPoints[t],i=new y;this.m_shape.queryXY(s,i);const n=new y,o=this.m_bunchEdgeEndPoints[e];if(this.m_shape.queryXY(o,n),i.equals(n))return 0;const a=this.m_bunchEdgeCenterPoints[t],h=new y;this.m_shape.queryXY(a,h);const m=this.m_bunchEdgeCenterPoints[e],l=new y;this.m_shape.queryXY(m,l);const u=new y;u.setSub(i,h);const c=new y;return c.setSub(n,l),(u.isZero()||c.isZero())&&To(""),y.compareVectors(u,c)}compareAnglesCurves_(t,e){const s=this.m_bunchEdgeEndPoints[t],i=this.m_bunchEdgeEndPoints[e],n=this.m_bunchEdgeCenterPoints[t],o=this.m_bunchEdgeCenterPoints[e],a=this.m_shape.getNextVertex(n)===s,h=this.m_shape.getNextVertex(o)===i,m=a?this.m_shape.isCurve(n):this.m_shape.isCurve(s),l=h?this.m_shape.isCurve(o):this.m_shape.isCurve(i);return!m&&!l?this.compareAnglesLines_(t,e):(this.m_sorterSegmentBuffer1||(this.m_sorterSegmentBuffer1=new it),this.m_sorterSegmentBuffer2||(this.m_sorterSegmentBuffer2=new it),a?this.m_shape.querySegment(n,this.m_sorterSegmentBuffer1,!1,!0):(this.m_shape.querySegment(s,this.m_sorterSegmentBuffer1,!1,!0),this.m_sorterSegmentBuffer1.get().reverse()),h?this.m_shape.querySegment(o,this.m_sorterSegmentBuffer2,!1,!0):(this.m_shape.querySegment(i,this.m_sorterSegmentBuffer2,!1,!0),this.m_sorterSegmentBuffer2.get().reverse()),sg(this.m_sorterSegmentBuffer1.get(),this.m_sorterSegmentBuffer2.get()))}beforeRemoveVertex_(t,e){const s=this.m_shape.getUserIndex(t,this.m_userIndexSortedIndexToVertex);if(this.m_nextVertexToProcess===s&&(this.m_nextVertexToProcess=this.m_sortedVertices.getNext(this.m_nextVertexToProcess)),this.m_firstCoincidentVertex===s&&(this.m_firstCoincidentVertex=this.m_sortedVertices.getNext(this.m_firstCoincidentVertex)),this.m_sortedVertices.deleteElement(this.m_sortedVerticesListIndex,s),this.removeAngleSortInfo_(t),e){const i=this.m_shape.getPathFromVertex(t);if(i!==v&&this.m_shape.getFirstVertex(i)===t){const n=this.m_shape.getNextVertex(t);if(n!==t){if(this.m_shape.getPathFromVertex(n)===i)return void this.m_shape.setFirstVertex(i,n);{const o=this.m_shape.getPrevVertex(t);if(o!==t&&this.m_shape.getPathFromVertex(o)===i)return void this.m_shape.setFirstVertex(i,o)}}this.m_shape.setFirstVertex(i,v),this.m_shape.setLastVertex(i,v)}}}processBunch_(){let t=!1;const e=new y(0,0);for(;;){this.m_bunchEdgeEndPoints.length=0,this.m_bunchEdgeCenterPoints.length=0,this.m_bunchEdgeIndices.length=0;let s=this.m_firstCoincidentVertex,i=0,n=!0;for(;s!==this.m_nextVertexToProcess;){const a=this.m_sortedVertices.getData(s);n&&(this.m_shape.queryXY(a,e),n=!1);const h=this.m_shape.getPrevVertex(a),m=this.m_shape.getNextVertex(a);this.m_shape.getUserIndex(h,this.m_userIndexSortedAngleIndexToVertex)!==un&&(this.m_bunchEdgeEndPoints.push(h),this.m_shape.setUserIndex(h,this.m_userIndexSortedAngleIndexToVertex,un),this.m_bunchEdgeCenterPoints.push(a),this.m_bunchEdgeIndices.push(i++)),this.m_shape.getUserIndex(m,this.m_userIndexSortedAngleIndexToVertex)!==un&&(this.m_bunchEdgeEndPoints.push(m),this.m_shape.setUserIndex(m,this.m_userIndexSortedAngleIndexToVertex,un),this.m_bunchEdgeCenterPoints.push(a),this.m_bunchEdgeIndices.push(i++)),s=this.m_sortedVertices.getNext(s)}if(this.m_bunchEdgeEndPoints.length<2){this.m_bunchEdgeEndPoints.length===1&&this.m_shape.setUserIndex(this.m_bunchEdgeEndPoints[0],this.m_userIndexSortedAngleIndexToVertex,-1);break}this.m_bunchEdgeIndices.sort((a,h)=>this.compareAngles_(a,h));for(let a=0,h=this.m_bunchEdgeIndices.length;a<h;a++){const m=this.m_bunchEdgeIndices[a],l=this.m_bunchEdgeEndPoints[m];this.m_shape.setUserIndex(l,this.m_userIndexSortedAngleIndexToVertex,a)}const o=this.processCrossOvers_(e);for(let a=0,h=this.m_bunchEdgeIndices.length;a<h;a++){const m=this.m_bunchEdgeIndices[a];if(m===-1)continue;const l=this.m_bunchEdgeEndPoints[m];this.m_shape.setUserIndex(l,this.m_userIndexSortedAngleIndexToVertex,-1)}if(!o)break;t=!0}return t}processCrossOvers_(t){let e=!1,s=!0;for(;s;){s=!1;let i=0;this.m_bunchEdgeIndices[i]===-1&&(i=this.getNextEdgeIndex_(i));let n=this.getNextEdgeIndex_(i);for(let o=0,a=this.m_bunchEdgeIndices.length;o<a&&i!==-1&&n!==-1&&i!==n;o++){const h=this.m_bunchEdgeIndices[i],m=this.m_bunchEdgeIndices[n],l=this.m_bunchEdgeEndPoints[h],u=this.m_bunchEdgeEndPoints[m];let c=this.m_shape.getNextVertex(l),g=!1;this.m_shape.isEqualXYPoint2D(c,t)||(c=this.m_shape.getPrevVertex(l),g=!0);let _=this.m_shape.getNextVertex(u),d=!1;this.m_shape.isEqualXYPoint2D(_,t)||(_=this.m_shape.getPrevVertex(u),d=!0);const p=g?this.m_shape.getPrevVertex(c):this.m_shape.getNextVertex(c),f=d?this.m_shape.getPrevVertex(_):this.m_shape.getNextVertex(_);let x=!1;(this.removeSpike_(c)||this.removeSpike_(_)||this.removeSpike_(l)||this.removeSpike_(u)||this.removeSpike_(p)||this.removeSpike_(f))&&(x=!0),c!==_&&(!x&&this.m_shape.isEqualXY(l,u)&&(x=this.resolveOverlap_(g,d,c,l,_,u)),!x&&this.m_shape.isEqualXY(p,f)&&(x=this.resolveOverlap_(!g,!d,c,p,_,f)),!x&&this.m_shape.isEqualXY(l,f)&&(x=this.resolveOverlap_(g,!d,c,l,_,f)),!x&&this.m_shape.isEqualXY(p,u)&&(x=this.resolveOverlap_(!g,d,c,p,_,u))),x&&(e=!0),s||=x,i=x?this.getNextEdgeIndex_(i):n,n=this.getNextEdgeIndex_(i)}}if(!e){let i=0;this.m_bunchEdgeIndices[i]===-1&&(i=this.getNextEdgeIndex_(i));let n=this.getNextEdgeIndex_(i);for(let o=0,a=this.m_bunchEdgeIndices.length;o<a&&i!==-1&&n!==-1&&i!==n;o++){const h=this.m_bunchEdgeIndices[i],m=this.m_bunchEdgeIndices[n],l=this.m_bunchEdgeEndPoints[h],u=this.m_bunchEdgeEndPoints[m];let c=this.m_shape.getNextVertex(l);this.m_shape.isEqualXYPoint2D(c,t)||(c=this.m_shape.getPrevVertex(l));let g=this.m_shape.getNextVertex(u);this.m_shape.isEqualXYPoint2D(g,t)||(g=this.m_shape.getPrevVertex(u));const _=this.getDirection_(c,l),d=this.getDirection_(g,u),p=_?this.m_shape.getPrevVertex(c):this.m_shape.getNextVertex(c),f=d?this.m_shape.getPrevVertex(g):this.m_shape.getNextVertex(g),x=this.detectAndResolveCrossOver_(_,d,l,c,p,u,g,f);x!==1?x===0?(i=this.getNextEdgeIndex_(i),n=this.getNextEdgeIndex_(i)):(i=this.getPrevEdgeIndex_(i),n=this.getNextEdgeIndex_(i)):e=!0}}return e}simplify_(){this.m_shape.getGeometryType(this.m_geometry)===T.enumPolygon&&this.m_shape.getFillRule(this.m_geometry)===1&&new je(this.m_progressTracker).planarSimplifyNoCrackingAndCluster(this.m_bFixSelfTangency,this.m_shape,this.m_geometry,0);let t=!1;this.m_userIndexSortedIndexToVertex=-1,this.m_userIndexSortedAngleIndexToVertex=-1,this.m_userIndexSortedAngleIndexToVertex=this.m_shape.createUserIndexUninitialized();const e=this.m_shape.getPointCount(this.m_geometry),s=new Xt(0);this.m_shape.dbgVerifyMonotone();for(let o=this.m_shape.getFirstPath(this.m_geometry);o!==v;o=this.m_shape.getNextPath(o)){let a=this.m_shape.getFirstVertex(o);for(let h=0,m=this.m_shape.getPathSize(o);h<m;h++)this.m_shape.setUserIndex(a,this.m_userIndexSortedAngleIndexToVertex,-1),s.add(a),a=this.m_shape.getNextVertex(a)}this.m_shape.sortVerticesSimpleByY(s,0,e),this.progress_(!0),this.m_userIndexSortedIndexToVertex=this.m_shape.createUserIndexUninitialized(),this.m_sortedVertices.reserveNodes(e),this.m_sortedVerticesListIndex=this.m_sortedVertices.createList(0);for(let o=0;o<e;o++){const a=s.read(o),h=this.m_sortedVertices.addElement(this.m_sortedVerticesListIndex,a);this.m_shape.setUserIndex(a,this.m_userIndexSortedIndexToVertex,h)}this.m_nextVertexToProcess=-1,this.cleanupSpikes_()&&(t=!0);let i=0,n=!1;do{n=!1,this.m_nextVertexToProcess=-1,this.m_firstCoincidentVertex=this.m_sortedVertices.getFirst(this.m_sortedVerticesListIndex);const o=new y(0,0);this.m_firstCoincidentVertex!==ge.st_nullNode()&&this.m_shape.queryXY(this.m_sortedVertices.getData(this.m_firstCoincidentVertex),o);let a=0,h=this.m_firstCoincidentVertex;for(;h!==ge.st_nullNode()&&(h=this.m_sortedVertices.getNext(h),h!==ge.st_nullNode());){this.progress_();const m=this.m_sortedVertices.getData(h),l=y.getNAN();if(this.m_shape.queryXY(m,l),o.equals(l))a++;else{if(a>0){this.m_nextVertexToProcess=h;const u=this.processBunch_();h=this.m_nextVertexToProcess,h!==ge.st_nullNode()&&this.m_shape.queryXY(this.m_sortedVertices.getData(h),l),u&&(n=!0)}o.setCoordsPoint2D(l),this.m_firstCoincidentVertex=h,a=0}}this.m_nextVertexToProcess=-1,a>0&&this.processBunch_()&&(n=!0),i++>10&&$(""),n&&this.fixOrphanVertices_(),this.cleanupSpikes_()&&(n=!0),t||=n}while(n);return this.m_shape.dbgVerifyMonotone(),this.m_shape.dbgVerifyCurves(),this.m_shape.removeUserIndex(this.m_userIndexSortedIndexToVertex),this.m_shape.removeUserIndex(this.m_userIndexSortedAngleIndexToVertex),t=Tx(this.m_shape,this.m_geometry,this.m_sortedVertices,this.m_bFixSelfTangency,this.m_progressTracker)||t,this.m_shape.dbgVerifyCurves(),t}getDirection_(t,e){return this.m_shape.getNextVertex(e)!==t}detectAndResolveCrossOver_(t,e,s,i,n,o,a,h){if(i===a)return this.removeAngleSortInfo_(s),this.removeAngleSortInfo_(o),-1;const m=this.m_shape.getUserIndex(s,this.m_userIndexSortedAngleIndexToVertex),l=this.m_shape.getUserIndex(n,this.m_userIndexSortedAngleIndexToVertex),u=this.m_shape.getUserIndex(o,this.m_userIndexSortedAngleIndexToVertex),c=this.m_shape.getUserIndex(h,this.m_userIndexSortedAngleIndexToVertex),g=j(8,Number.NaN),_=j(4,Number.NaN);g[0]=0,_[0]=m,g[1]=0,_[1]=l,g[2]=1,_[2]=u,g[3]=1,_[3]=c;for(let p=1;p<4;p++){const f=_[p],x=g[p];let E=p-1;for(;E>=0&&_[E]>f;)_[E+1]=_[E],g[E+1]=g[E],E--;_[E+1]=f,g[E+1]=x}let d=0;if(g[0]&&(d|=1),g[1]&&(d|=2),g[2]&&(d|=4),g[3]&&(d|=8),d!==5&&d!==10)return 0;if(t!==e&&(h=O(o,o=h)),t)this.m_shape.setNextVertex(h,i),this.m_shape.setPrevVertex(i,h),this.m_shape.setNextVertex(n,a),this.m_shape.setPrevVertex(a,n),this.m_bHasSegmentParentage&&(this.m_shape.setSegmentParentageBreakVertex(i,!0),this.m_shape.setSegmentParentageBreakVertex(a,!0));else{if(this.m_shape.setPrevVertex(h,i),this.m_shape.setNextVertex(i,h),this.m_shape.setPrevVertex(n,a),this.m_shape.setNextVertex(a,n),this.m_bHasSegmentParentage){const p=this.m_shape.getSegmentParentage(i),f=this.m_shape.getSegmentParentage(a);this.m_shape.setSegmentParentageAndBreak(i,f,!0),this.m_shape.setSegmentParentageAndBreak(a,p,!0)}if(this.m_bHasSegments){const p=this.m_shape.getVertexIndex(i),f=this.m_shape.getVertexIndex(a),x=this.m_shape.getSegmentFromIndex(p);this.m_shape.setSegmentToIndex(p,null);const E=this.m_shape.getSegmentFromIndex(f);this.m_shape.setSegmentToIndex(f,null),this.m_shape.setSegmentToIndex(p,E),this.m_shape.setSegmentToIndex(f,x)}}return 1}resolveOverlap_(t,e,s,i,n,o){return this.resolveOverlapOddEven_(t,e,s,i,n,o)}resolveOverlapOddEven_(t,e,s,i,n,o){if(t!==e){t||(n=O(s,s=n),o=O(i,i=o));const a=this.m_shape.getNextVertex(n),h=this.m_shape.getNextVertex(s);if(this.m_shape.setNextVertex(s,a),this.m_shape.setPrevVertex(a,s),this.m_shape.setNextVertex(n,h),this.m_shape.setPrevVertex(h,n),this.m_bHasSegments){const m=this.m_shape.getVertexIndex(s),l=this.m_shape.getVertexIndex(n),u=this.m_shape.getSegmentFromIndex(m);this.m_shape.setSegmentToIndex(m,null);const c=this.m_shape.getSegmentFromIndex(l);this.m_shape.setSegmentToIndex(l,null),this.m_shape.setSegmentToIndex(m,c),this.m_shape.setSegmentToIndex(l,u)}if(this.m_bHasSegmentParentage){const m=this.m_shape.getSegmentParentage(s),l=this.m_shape.getSegmentParentage(n);this.m_shape.setSegmentParentageAndBreak(s,l,!0),this.m_shape.setSegmentParentageAndBreak(n,m,!0),this.m_shape.setSegmentParentageBreakVertex(i,!0),this.m_shape.setSegmentParentageBreakVertex(o,!0)}this.removeSpike_(n)}else{const a=t?s:i,h=e?n:o,m=t?i:s,l=e?o:n;let u=null;if(this.m_bHasSegments){const x=this.m_shape.getVertexIndex(l);u=this.m_shape.getSegmentFromIndex(x),this.m_shape.setSegmentToIndex(x,null);const E=this.m_shape.getVertexIndex(h);this.m_shape.setSegmentToIndex(E,null);const P=this.m_shape.getVertexIndex(a);this.m_shape.setSegmentToIndex(P,null)}let c=-1;this.m_bHasSegmentParentage&&(c=this.m_shape.getSegmentParentage(l));let g=!1;this.m_shape.setNextVertex(a,h),this.m_shape.setNextVertex(h,a),this.m_shape.setPrevVertex(m,l),this.m_shape.setPrevVertex(l,m);let _=l;for(;_!==h;){const x=this.m_shape.getPrevVertex(_),E=this.m_shape.getNextVertex(_);if(this.m_shape.setPrevVertex(_,E),this.m_shape.setNextVertex(_,x),g||=_===a,this.m_bHasSegments&&_!==a){const P=this.m_shape.getVertexIndex(E),C=u;u=this.m_shape.getSegmentFromIndex(P),C!==null&&C.reverse(),this.m_shape.setSegmentToIndex(P,C)}if(this.m_bHasSegmentParentage){const P=this.m_shape.getSegmentParentage(E);this.m_shape.setSegmentParentagePreserveBreak(E,c),c=P}_=E}let d=null;if(!g){const x=this.m_shape.getPrevVertex(h),E=this.m_shape.getNextVertex(h);if(this.m_shape.setPrevVertex(h,E),this.m_shape.setNextVertex(h,x),this.m_bHasSegments){const P=this.m_shape.getVertexIndex(h);d=this.m_shape.getSegmentFromIndex(P),this.m_shape.setSegmentToIndex(P,null)}}let p=-1,f=-1;if(this.m_bHasSegmentParentage&&(p=g?this.m_shape.getSegmentParentage(a):this.m_shape.getSegmentParentage(h),f=this.m_shape.getSegmentParentage(m)),this.transferVertexData_(h,a),this.beforeRemoveVertex_(h,!0),this.m_shape.removeVertexInternal(h,!0),this.removeAngleSortInfo_(a),this.transferVertexData_(l,m),this.beforeRemoveVertex_(l,!0),this.m_shape.removeVertexInternal(l,!0),this.removeAngleSortInfo_(m),this.m_bHasSegmentParentage&&(this.m_shape.setSegmentParentageAndBreak(a,p,!0),this.m_shape.setSegmentParentageAndBreak(m,f,!0)),d){const x=this.m_shape.getVertexIndex(a);this.m_shape.setSegmentToIndex(x,d)}}return!0}cleanupSpikes_(){let t=!1;for(let e=this.m_shape.getFirstPath(this.m_geometry);e!==v;){const s=this.m_shape.getNextPath(e);let i=this.m_shape.getFirstVertex(e);for(let n=0,o=this.m_shape.getPathSize(e);n<o&&o>1;){this.progress_();const{v:a,bModified:h}=this.checkAndCleanupSpike_(e,i);if(a===v)break;h?(t=!0,i=a,n=0,o=this.m_shape.getPathSize(e)):(i=a,n++)}e=s}return t}checkAndCleanupSpike_(t,e){const s={v,bModified:!1};let i=this.m_shape.getPrevVertex(e),n=this.m_shape.getNextVertex(e),o=v,a=v;for(;this.m_shape.isEqualXY(i,n)&&(o=i,a=n,n!==e);)i=this.m_shape.getPrevVertex(i),n=this.m_shape.getNextVertex(n);if(o===v)return s.v=n,s;s.bModified=!0;for(let h=this.m_shape.getNextVertex(o);this.beforeRemoveVertex_(h,!1),h!==a;h=this.m_shape.getNextVertex(h));if(o===e)return this.m_polylineDegeneracies!==v?this.m_shape.movePath(this.m_polylineDegeneracies,v,t):this.m_shape.removePath(t),s.v=v,s;{const h=this.m_shape.peelALoopIntoAPath(o,a);this.m_polylineDegeneracies!==v?this.m_shape.movePath(this.m_polylineDegeneracies,v,h):this.m_shape.removePath(h)}return s.v=o,s}removeSpike_(t){let e=this.m_shape.getPrevVertex(t),s=this.m_shape.getNextVertex(t),i=v,n=v;for(;this.m_shape.isEqualXY(e,s)&&(i=e,n=s,s!==t);)e=this.m_shape.getPrevVertex(e),s=this.m_shape.getNextVertex(s);if(i===v)return!1;if(this.m_shape.peelALoop(i,n),this.m_bHasSegmentParentage&&(this.m_shape.setSegmentParentageBreakVertex(i,!0),this.m_shape.setSegmentParentageBreakVertex(n,!0)),this.removeAngleSortInfo_(i),this.m_polylineDegeneracies===v)for(let o=this.m_shape.getNextVertex(n);;){const a=this.m_shape.getNextVertex(o);if(this.removeAngleSortInfo_(o),this.beforeRemoveVertex_(o,!0),this.m_shape.setSegmentToIndex(this.m_shape.getVertexIndex(o),null),this.m_shape.removeVertexInternal(o,!1),o===n)break;o=a}else{for(let a=n;;){const h=this.m_shape.getNextVertex(a);if(this.removeAngleSortInfo_(a),this.beforeRemoveVertex_(a,!1),a=h,a===n)break}const o=[!1];this.m_shape.insertClosedPath(this.m_polylineDegeneracies,v,n,n,o)}return!0}fixOrphanVertices_(){let t=0;for(let i=this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList());i!==-1;i=this.m_sortedVertices.getNext(i)){const n=this.m_sortedVertices.getData(i);this.m_shape.setPathToVertex(n,v)}let e=0;for(let i=this.m_shape.getFirstPath(this.m_geometry);i!==v;){const n=this.m_shape.getFirstVertex(i);if(n===v||this.m_shape.getPathFromVertex(n)!==v){const a=i;i=this.m_shape.getNextPath(i),this.m_shape.removePathOnly(a);continue}this.m_shape.setPathToVertex(n,i);let o=1;for(let a=this.m_shape.getNextVertex(n);a!==n;a=this.m_shape.getNextVertex(a))this.m_shape.setPathToVertex(a,i),o++;this.m_shape.setRingAreaValid(i,!1),this.m_shape.setPathSize(i,o),this.m_shape.setLastVertex(i,this.m_shape.getPrevVertex(n)),e+=o,t++,i=this.m_shape.getNextPath(i)}for(let i=this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList());i!==-1;i=this.m_sortedVertices.getNext(i)){const n=this.m_sortedVertices.getData(i);if(this.m_shape.getPathFromVertex(n)!==v)continue;const o=[!1],a=this.m_shape.insertClosedPath(this.m_geometry,v,n,n,o);e+=this.m_shape.getPathSize(a),t++}this.m_shape.setGeometryPathCount(this.m_geometry,t),this.m_shape.setGeometryVertexCount(this.m_geometry,e);let s=0;for(let i=this.m_shape.getFirstGeometry();i!==v;i=this.m_shape.getNextGeometry(i))s+=this.m_shape.getPointCount(i);this.m_shape.setTotalPointCount(s)}getNextEdgeIndex_(t){if(t===-1)return-1;for(let e=0,s=this.m_bunchEdgeIndices.length-1;e<s;e++)if(t=(t+1)%this.m_bunchEdgeIndices.length,this.m_bunchEdgeIndices[t]!==-1)return t;return-1}getPrevEdgeIndex_(t){if(t===-1)return-1;for(let e=0,s=this.m_bunchEdgeIndices.length-1;e<s;e++)if(t=(this.m_bunchEdgeIndices.length+t-1)%this.m_bunchEdgeIndices.length,this.m_bunchEdgeIndices[t]!==-1)return t;return-1}transferVertexData_(t,e){const s=this.m_shape.getUserIndex(e,this.m_userIndexSortedIndexToVertex),i=this.m_shape.getUserIndex(e,this.m_userIndexSortedAngleIndexToVertex);this.m_shape.transferAllDataToTheVertex(t,e),this.m_shape.setUserIndex(e,this.m_userIndexSortedIndexToVertex,s),this.m_shape.setUserIndex(e,this.m_userIndexSortedAngleIndexToVertex,i)}removeAngleSortInfo_(t){const e=this.m_shape.getUserIndex(t,this.m_userIndexSortedAngleIndexToVertex);e!==-1&&(this.m_bunchEdgeIndices[e]=-1,this.m_shape.setUserIndex(t,this.m_userIndexSortedAngleIndexToVertex,-1))}progress_(t=!1){}}function fs(r,t,e,s,i,n=!0){switch(P_(s)){case 0:break;case 1:H("relation string length has to be 9 characters");break;default:H("relation string")}if(n){const c=Lx(s,r.getDimension(),t.getDimension());if(c!==0)return ti(r,t,e,c,i)}let o=0;if(typeof e=="number")o=e;else{const c=F.constructEmpty();r.queryEnvelope(c);const g=F.constructEmpty();t.queryEnvelope(g);const _=F.constructEmpty();_.setCoords({env2D:c}),_.mergeEnvelope2D(g),o=Di(e,_,!1)}const a=Ku(r,o),h=Ku(t,o);if(a.isEmpty()||h.isEmpty())return kx(a,h,s);const m=a.getGeometryType(),l=h.getGeometryType();let u=!1;switch(m){case T.enumPolygon:switch(l){case T.enumPolygon:u=Vx(a,h,o,s,i);break;case T.enumPolyline:u=Ou(a,h,o,s,i);break;case T.enumPoint:u=ju(a,h,o,s);break;case T.enumMultiPoint:u=Wu(a,h,o,s,i)}break;case T.enumPolyline:switch(l){case T.enumPolygon:u=Ou(h,a,o,an(s),i);break;case T.enumPolyline:u=Yx(a,h,o,s,i);break;case T.enumPoint:u=Zu(a,h,o,s,i);break;case T.enumMultiPoint:u=$u(a,h,o,s,i)}break;case T.enumPoint:switch(l){case T.enumPolygon:u=ju(h,a,o,an(s));break;case T.enumPolyline:u=Zu(h,a,o,an(s),i);break;case T.enumPoint:u=Rx(a,h,o,s);break;case T.enumMultiPoint:u=Qu(h,a,o,an(s))}break;case T.enumMultiPoint:switch(l){case T.enumPolygon:u=Wu(h,a,o,an(s),i);break;case T.enumPolyline:u=$u(h,a,o,an(s),i);break;case T.enumMultiPoint:u=Xx(a,h,o,s,i);break;case T.enumPoint:u=Qu(a,h,o,s)}break;default:u=!1}return u}function Mx(r,t,e,s){const i=new Ls;i.resetMatrix_(),i.setPredicates_("T*****F**"),i.setAreaAreaPredicates_();const n=F.constructEmpty(),o=F.constructEmpty();r.queryEnvelope(n),t.queryEnvelope(o);let a=!1;if($s(n,o,e)&&(i.areaAreaDisjointPredicates_(r,t),a=!0),a||vt(r,t),a)return Ae(i.m_matrix,i.m_scl);let h=new Lt,m=h.addGeometry(r),l=h.addGeometry(t),u=null,c=0;if(r.hasNonLinearSegments()||t.hasNonLinearSegments()){u=new ts;const p=Je(e,h.getEnvelope2D(s));c=Ms(p,0),_s(h,p,e,12e3,u,null,s)}Ns(h,new Ve(e,0).add(c),s,!1,!1);const g=h.getGeometry(l).getBoundary();if(h.filterClosePoints(0,!0,!0,!1,v),ii(h,m,-1,!1,v,s),h.getPointCount(m)===0)return!1;ii(h,l,-1,!1,v,s),i.setEditShape_(h,s);const _=h.getPointCount(l)===0;if(!_){i.computeMatrixTopoGraphHalfEdges_(m,l),i.m_topoGraph.removeShape();const p=Ae(i.m_matrix,i.m_scl);if(!p)return p}const d=h.getGeometry(m);return h=new Lt,m=h.addGeometry(d),l=h.addGeometry(g),i.setEditShape_(h,s),i.m_predicateCount=0,i.resetMatrix_(),i.setPredicates_(_?"T*****F**":"******F**"),i.setAreaLinePredicates_(),i.computeMatrixTopoGraphHalfEdges_(m,l),i.m_topoGraph.removeShape(),Ae(i.m_matrix,i.m_scl)}function Gx(r,t,e,s){const i=new Ls;i.resetMatrix_(),i.setPredicates_("T*****F**"),i.setAreaLinePredicates_();const n=F.constructEmpty(),o=F.constructEmpty();r.queryEnvelope(n),t.queryEnvelope(o);let a=!1;if($s(n,o,e)&&(i.areaLineDisjointPredicates_(r,t),a=!0),a||vt(r,t),a)return Ae(i.m_matrix,i.m_scl);const h=new Lt,m=h.addGeometry(r),l=h.addGeometry(t);return i.setEditShapeCrackAndCluster_(h,new Ve(e,0),s),h.getPointCount(m)===0?!1:(i.computeMatrixTopoGraphHalfEdges_(m,l),i.m_topoGraph.removeShape(),Ae(i.m_matrix,i.m_scl))}function P_(r){if(r.length!==9)return 1;for(let t=0;t<9;t++){const e=r[t];if(e!=="*"&&e!=="T"&&e!=="F"&&e!=="0"&&e!=="1"&&e!=="2")return 2}return 0}function Vx(r,t,e,s,i){const n=new Ls;n.resetMatrix_(),n.setPredicates_(s),n.setAreaAreaPredicates_();const o=F.constructEmpty(),a=F.constructEmpty();r.queryEnvelope(o),t.queryEnvelope(a);let h=!1;if($s(o,a,e)&&(n.areaAreaDisjointPredicates_(r,t),h=!0),h||vt(r,t),!h){const m=new Lt,l=m.addGeometry(r),u=m.addGeometry(t);n.setEditShapeCrackAndCluster_(m,new Ve(e,0),i),n.computeMatrixTopoGraphHalfEdges_(l,u),n.m_topoGraph.removeShape()}return Ae(n.m_matrix,n.m_scl)}function Ou(r,t,e,s,i){const n=new Ls;n.resetMatrix_(),n.setPredicates_(s),n.setAreaLinePredicates_();const o=F.constructEmpty(),a=F.constructEmpty();r.queryEnvelope(o),t.queryEnvelope(a);let h=!1;if($s(o,a,e)&&(n.areaLineDisjointPredicates_(r,t),h=!0),h||vt(r,t),!h){const m=new Lt,l=m.addGeometry(r),u=m.addGeometry(t);n.setEditShapeCrackAndCluster_(m,new Ve(e,0),i),n.m_clusterIndexB=n.m_topoGraph.createUserIndexForClusters(),jo(u,n.m_topoGraph,n.m_clusterIndexB),n.computeMatrixTopoGraphHalfEdges_(l,u),n.m_topoGraph.deleteUserIndexForClusters(n.m_clusterIndexB),n.m_topoGraph.removeShape()}return Ae(n.m_matrix,n.m_scl)}function Wu(r,t,e,s,i){const n=new Ls;n.resetMatrix_(),n.setPredicates_(s),n.setAreaPointPredicates_();const o=F.constructEmpty(),a=F.constructEmpty();r.queryEnvelope(o),t.queryEnvelope(a);let h=!1;if($s(o,a,e)&&(n.areaPointDisjointPredicates_(r),h=!0),h||vt(r,t),!h){const m=new Lt,l=m.addGeometry(r),u=m.addGeometry(t);n.setEditShapeCrackAndCluster_(m,new Ve(e,0),i),n.computeMatrixTopoGraphClusters_(l,u),n.m_topoGraph.removeShape()}return Ae(n.m_matrix,n.m_scl)}function Yx(r,t,e,s,i){const n=new Ls;n.resetMatrix_(),n.setPredicates_(s),n.setLineLinePredicates_();const o=F.constructEmpty(),a=F.constructEmpty();r.queryEnvelope(o),t.queryEnvelope(a);let h=!1;if($s(o,a,e)&&(n.lineLineDisjointPredicates_(r,t),h=!0),h||vt(r,t),!h){const m=new Lt,l=m.addGeometry(r),u=m.addGeometry(t);n.setEditShapeCrackAndCluster_(m,new Ve(e,0),i),n.m_clusterIndexA=n.m_topoGraph.createUserIndexForClusters(),n.m_clusterIndexB=n.m_topoGraph.createUserIndexForClusters(),jo(l,n.m_topoGraph,n.m_clusterIndexA),jo(u,n.m_topoGraph,n.m_clusterIndexB),n.computeMatrixTopoGraphHalfEdges_(l,u),n.m_topoGraph.deleteUserIndexForClusters(n.m_clusterIndexA),n.m_topoGraph.deleteUserIndexForClusters(n.m_clusterIndexB),n.m_topoGraph.removeShape()}return Ae(n.m_matrix,n.m_scl)}function $u(r,t,e,s,i){const n=new Ls;n.resetMatrix_(),n.setPredicates_(s),n.setLinePointPredicates_();const o=F.constructEmpty(),a=F.constructEmpty();r.queryEnvelope(o),t.queryEnvelope(a);let h=!1;if($s(o,a,e)&&(n.linePointDisjointPredicates_(r),h=!0),h||vt(r,t),!h){const m=new Lt,l=m.addGeometry(r),u=m.addGeometry(t);n.setEditShapeCrackAndCluster_(m,new Ve(e,0),i),n.m_clusterIndexA=n.m_topoGraph.createUserIndexForClusters(),jo(l,n.m_topoGraph,n.m_clusterIndexA),n.computeMatrixTopoGraphClusters_(l,u),n.m_topoGraph.deleteUserIndexForClusters(n.m_clusterIndexA),n.m_topoGraph.removeShape()}return Ae(n.m_matrix,n.m_scl)}function Xx(r,t,e,s,i){const n=new Ls;n.resetMatrix_(),n.setPredicates_(s),n.setPointPointPredicates_();const o=new F,a=new F;r.queryEnvelope(o),t.queryEnvelope(a);let h=!1;if($s(o,a,e)&&(n.pointPointDisjointPredicates_(),h=!0),!h){const m=new Lt,l=m.addGeometry(r),u=m.addGeometry(t);n.setEditShapeCrackAndCluster_(m,new Ve(e,0),i),n.computeMatrixTopoGraphClusters_(l,u),n.m_topoGraph.removeShape()}return Ae(n.m_matrix,n.m_scl)}function ju(r,t,e,s,i){const n=new Ls;n.resetMatrix_(),n.setPredicates_(s),n.setAreaPointPredicates_();const o=F.constructEmpty();r.queryEnvelope(o);const a=t.getXY();let h=!1;if(Ca(a,o,e)&&(n.areaPointDisjointPredicates_(r),h=!0),!h){const m=Ye(r,a,e);if(m===1)n.m_matrix[0]=0,n.m_matrix[2]=2,n.m_matrix[3]=-1,n.m_matrix[5]=1,n.m_matrix[6]=-1;else if(m===2)if(n.m_matrix[6]=-1,r.calculateArea2D()!==0)n.m_matrix[0]=-1,n.m_matrix[3]=0,n.m_matrix[2]=2,n.m_matrix[5]=1;else{n.m_matrix[0]=0,n.m_matrix[3]=-1,n.m_matrix[5]=-1;const l=F.constructEmpty();r.queryEnvelope(l),n.m_matrix[2]=l.height()||l.width()?1:-1}else n.areaPointDisjointPredicates_(r)}return Ae(n.m_matrix,s)}function Zu(r,t,e,s,i){const n=new Ls;n.resetMatrix_(),n.setPredicates_(s),n.setLinePointPredicates_();const o=F.constructEmpty();r.queryEnvelope(o);let a=!1;if(Ca(t.getXY(),o,e)&&(n.linePointDisjointPredicates_(r),a=!0),!a){let h=null,m=!1,l=!1;if((n.m_performPredicates[0]||n.m_performPredicates[6])&&(ti(r,t,e,4,i)?(n.m_matrix[0]=-1,n.m_matrix[6]=0):(n.m_performPredicates[0]&&(h=Gs(r),l=!ti(h,t,e,4,i),m=!0,n.m_matrix[0]=l?-1:0),n.m_matrix[6]=-1)),n.m_performPredicates[3]&&(h!==null&&h.isEmpty()?n.m_matrix[3]=-1:(m||(h==null&&(h=Gs(r)),l=!ti(h,t,e,4,i),m=!0),n.m_matrix[3]=l?0:-1)),n.m_performPredicates[5])if(h!==null&&h.isEmpty())n.m_matrix[5]=-1;else if(m&&!l)n.m_matrix[5]=0;else{h===null&&(h=Gs(r));const u=ti(h,t,e,3,i);n.m_matrix[5]=u?-1:0}if(n.m_performPredicates[2])if(r.calculateLength2D()!==0)n.m_matrix[2]=1;else{const u=new Zt({vd:r.getDescription()});u.addPoints(r,0,r.getPointCount());const c=ti(u,t,e,3,i);n.m_matrix[2]=c?-1:0}}return Ae(n.m_matrix,n.m_scl)}function Qu(r,t,e,s,i){const n=new Ls;n.resetMatrix_(),n.setPredicates_(s),n.setPointPointPredicates_();const o=F.constructEmpty();r.queryEnvelope(o);const a=t.getXY(),h=new y;let m=!1;if(Ca(a,o,e)&&(n.pointPointDisjointPredicates_(),m=!0),!m){let l=!1,u=!0;const c=e*e;for(let g=0;g<r.getPointCount()&&(r.queryXY(g,h),y.sqrDistance(h,a)<=c?l=!0:u=!1,!l||u);g++);l?(n.m_matrix[0]=0,n.m_matrix[2]=u?-1:0,n.m_matrix[6]=-1):(n.m_matrix[0]=-1,n.m_matrix[2]=0,n.m_matrix[6]=0)}return Ae(n.m_matrix,s)}function Rx(r,t,e,s,i){const n=r.getXY(),o=t.getXY(),a=j(9,-1);return y.sqrDistance(n,o)<=e*e?a[0]=0:(a[2]=0,a[6]=0),a[8]=2,Ae(a,s)}function Ae(r,t){for(let e=0;e<9;e++)switch(t[e]){case"T":if(r[e]===-1)return!1;break;case"F":if(r[e]!==-1)return!1;break;case"0":if(r[e]!==0)return!1;break;case"1":if(r[e]!==1)return!1;break;case"2":if(r[e]!==2)return!1}return!0}function kx(r,t,e){const s=j(9,-1);if(r.isEmpty()&&t.isEmpty())return Ae(s,e);let i,n=!1;r.isEmpty()?(i=t,n=!0):i=r,s[0]=-1,s[1]=-1,s[3]=-1,s[4]=-1,s[6]=-1,s[7]=-1,s[8]=2;const o=i.getGeometryType();if(lt(o))if(o===T.enumPolygon)if(i.calculateArea2D()!==0)s[2]=2,s[5]=1;else{s[5]=-1;const a=F.constructEmpty();i.queryEnvelope(a),s[2]=a.height()||a.width()?1:0}else{const a=i.calculateLength2D()!==0;s[2]=a?1:0,s[5]=Ai(i)?0:-1}else s[2]=0,s[5]=-1;return n&&C_(s),Ae(s,e)}function Lx(r,t,e){return Bx(r)?3:Hx(r)?4:zx(r,t,e)?8:Ux(r,t,e)?16:Wx(r)?64:Ox(r)?1:$x(r,t,e)?32:0}function Bx(r){return r==="T*F**FFF*"}function Hx(r){return r==="FF*FF****"}function zx(r,t,e){return(t!==0||e!==0)&&(t===2&&e===2?r==="F***T****":(t===2||t===1)&&e===0&&r==="F**T*****")}function Ux(r,t,e){return t>e?r==="T*****T**":t===1&&e===1&&r==="0********"}function Ox(r){return r==="T*****FF*"}function Wx(r){return r==="T**FF*FF*"}function $x(r,t,e){return t===e&&(t!==1?r==="T*T***T**":r==="1*T***T**")}function jo(r,t,e){const s=t.getGeometryID(r);for(let i=t.getFirstCluster();i!==v;i=t.getNextCluster(i)){if((t.getClusterParentage(i)&s)===0)continue;const n=t.getClusterHalfEdge(i);if(n===v){t.setClusterUserIndex(i,e,0);continue}let o=n,a=0;do{const h=o;(t.getHalfEdgeParentage(h)&s)!==0&&a++,o=t.getHalfEdgeNext(t.getHalfEdgeTwin(h))}while(o!==n);t.setClusterUserIndex(i,e,a)}}class Ls{nullFunc(){return $("should not be called"),!1}constructor(){this.m_clusterIndexA=-1,this.m_clusterIndexB=-1,this.m_visitedIndex=-1,this.m_topoGraph=new gs,this.m_matrix=j(9,0),this.m_maxDim=j(9,0),this.m_performPredicates=j(9,!1),this.m_scl="",this.m_predicateCount=0,this.m_predicatesHalfEdge=this.nullFunc,this.m_predicatesCluster=this.nullFunc}resetMatrix_(){this.m_matrix.fill(-2),this.m_maxDim.fill(-2)}setPredicates_(t){this.m_scl=t;for(let e=0;e<9;e++)this.m_scl[e]!=="*"?(this.m_performPredicates[e]=!0,this.m_predicateCount++):this.m_performPredicates[e]=!1}setRemainingPredicatesToFalse_(){for(let t=0;t<9;t++)this.m_performPredicates[t]&&this.m_matrix[t]===-2&&(this.m_matrix[t]=-1,this.m_performPredicates[t]=!1)}isPredicateKnown_(t){return this.m_matrix[t]!==-2&&(this.m_matrix[t]===-1?(this.m_performPredicates[t]=!1,this.m_predicateCount--,!0):this.m_scl[t]!=="T"&&this.m_scl[t]!=="F"?!(this.m_matrix[t]<this.m_maxDim[t])&&(this.m_performPredicates[t]=!1,this.m_predicateCount--,!0):(this.m_performPredicates[t]=!1,this.m_predicateCount--,!0))}setAreaAreaPredicates_(){this.m_predicatesHalfEdge=this.areaAreaPredicates_,this.m_maxDim[0]=2,this.m_maxDim[1]=1,this.m_maxDim[2]=2,this.m_maxDim[3]=1,this.m_maxDim[4]=1,this.m_maxDim[5]=1,this.m_maxDim[6]=2,this.m_maxDim[7]=1,this.m_maxDim[8]=2,this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setAreaLinePredicates_(){this.m_predicatesHalfEdge=this.areaLinePredicates_,this.m_predicatesCluster=this.areaPointPredicates_,this.m_maxDim[0]=1,this.m_maxDim[1]=0,this.m_maxDim[2]=2,this.m_maxDim[3]=1,this.m_maxDim[4]=0,this.m_maxDim[5]=1,this.m_maxDim[6]=1,this.m_maxDim[7]=0,this.m_maxDim[8]=2,this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setLineLinePredicates_(){this.m_predicatesHalfEdge=this.lineLinePredicates_,this.m_predicatesCluster=this.linePointPredicates_,this.m_maxDim[0]=1,this.m_maxDim[1]=0,this.m_maxDim[2]=1,this.m_maxDim[3]=0,this.m_maxDim[4]=0,this.m_maxDim[5]=0,this.m_maxDim[6]=1,this.m_maxDim[7]=0,this.m_maxDim[8]=2,this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setAreaPointPredicates_(){this.m_predicatesCluster=this.areaPointPredicates_,this.m_maxDim[0]=0,this.m_maxDim[1]=-1,this.m_maxDim[2]=2,this.m_maxDim[3]=0,this.m_maxDim[4]=-1,this.m_maxDim[5]=1,this.m_maxDim[6]=0,this.m_maxDim[7]=-1,this.m_maxDim[8]=2,this.m_performPredicates[1]&&(this.m_matrix[1]=-1,this.m_performPredicates[1]=!1,this.m_predicateCount--),this.m_performPredicates[4]&&(this.m_matrix[4]=-1,this.m_performPredicates[4]=!1,this.m_predicateCount--),this.m_performPredicates[7]&&(this.m_matrix[7]=-1,this.m_performPredicates[7]=!1,this.m_predicateCount--),this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setLinePointPredicates_(){this.m_predicatesCluster=this.linePointPredicates_,this.m_maxDim[0]=0,this.m_maxDim[1]=-1,this.m_maxDim[2]=1,this.m_maxDim[3]=0,this.m_maxDim[4]=-1,this.m_maxDim[5]=0,this.m_maxDim[6]=0,this.m_maxDim[7]=-1,this.m_maxDim[8]=2,this.m_performPredicates[1]&&(this.m_matrix[1]=-1,this.m_performPredicates[1]=!1,this.m_predicateCount--),this.m_performPredicates[4]&&(this.m_matrix[4]=-1,this.m_performPredicates[4]=!1,this.m_predicateCount--),this.m_performPredicates[7]&&(this.m_matrix[7]=-1,this.m_performPredicates[7]=!1,this.m_predicateCount--),this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setPointPointPredicates_(){this.m_predicatesCluster=this.pointPointPredicates_,this.m_maxDim[0]=0,this.m_maxDim[1]=-1,this.m_maxDim[2]=0,this.m_maxDim[3]=-1,this.m_maxDim[4]=-1,this.m_maxDim[5]=-1,this.m_maxDim[6]=0,this.m_maxDim[7]=-1,this.m_maxDim[8]=2,this.m_performPredicates[1]&&(this.m_matrix[1]=-1,this.m_performPredicates[1]=!1,this.m_predicateCount--),this.m_performPredicates[3]&&(this.m_matrix[3]=-1,this.m_performPredicates[3]=!1,this.m_predicateCount--),this.m_performPredicates[4]&&(this.m_matrix[4]=-1,this.m_performPredicates[4]=!1,this.m_predicateCount--),this.m_performPredicates[5]&&(this.m_matrix[5]=-1,this.m_performPredicates[5]=!1,this.m_predicateCount--),this.m_performPredicates[7]&&(this.m_matrix[7]=-1,this.m_performPredicates[7]=!1,this.m_predicateCount--),this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}areaAreaDisjointPredicates_(t,e){this.m_matrix[0]=-1,this.m_matrix[1]=-1,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.areaGeomContainsOrDisjointPredicates_(t,this.m_performPredicates[2]?2:-1,this.m_scl[2],this.m_performPredicates[5]?5:-1,this.m_scl[5]),this.areaGeomContainsOrDisjointPredicates_(e,this.m_performPredicates[6]?6:-1,this.m_scl[6],this.m_performPredicates[7]?7:-1,this.m_scl[7])}areaGeomContainsOrDisjointPredicates_(t,e,s,i,n){const o=e!==-1,a=i!==-1;if(o||a){if(!(s!=="T"&&s!=="F"&&o||n!=="T"&&n!=="F"&&a)||t.calculateArea2D()!==0)o&&(this.m_matrix[e]=2),a&&(this.m_matrix[i]=1);else if(a&&(this.m_matrix[i]=-1),o){const h=F.constructEmpty();t.queryEnvelope(h),this.m_matrix[e]=h.height()||h.width()?1:0}}}areaAreaContainsPredicates_(t){this.m_matrix[2]=2,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.m_matrix[5]=1,this.m_matrix[6]=-1,this.m_matrix[7]=-1,this.areaGeomContainsOrDisjointPredicates_(t,this.m_performPredicates[0]?0:-1,this.m_scl[0],this.m_performPredicates[1]?1:-1,this.m_scl[1])}areaAreaWithinPredicates_(t){this.areaAreaContainsPredicates_(t),C_(this.m_matrix)}areaLineDisjointPredicates_(t,e){if(this.m_matrix[0]=-1,this.m_matrix[1]=-1,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.m_performPredicates[6]){const s=this.m_scl[6],i=s==="T"||s==="F"||e.calculateLength2D()!==0;this.m_matrix[6]=i?1:0}if(this.m_performPredicates[7]){const s=Ai(e);this.m_matrix[7]=s?0:-1}this.areaGeomContainsOrDisjointPredicates_(t,this.m_performPredicates[2]?2:-1,this.m_scl[2],this.m_performPredicates[5]?5:-1,this.m_scl[5])}areaLineContainsPredicates_(t,e){if(this.m_performPredicates[0]){const s=this.m_scl[0],i=s==="T"||s==="F"||e.calculateLength2D()!==0;this.m_matrix[0]=i?1:0}if(this.m_performPredicates[1]){const s=Ai(e);this.m_matrix[1]=s?0:-1}this.m_matrix[2]=2,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.m_matrix[5]=1,this.m_matrix[6]=-1,this.m_matrix[7]=-1}areaPointDisjointPredicates_(t){this.m_matrix[0]=-1,this.m_matrix[3]=-1,this.m_matrix[6]=0,this.areaGeomContainsOrDisjointPredicates_(t,this.m_performPredicates[2]?2:-1,this.m_scl[2],this.m_performPredicates[5]?5:-1,this.m_scl[5])}areaPointContainsPredicates_(t){this.m_matrix[0]=0,this.m_matrix[2]=2,this.m_matrix[3]=-1,this.m_matrix[5]=1,this.m_matrix[6]=-1}lineLineDisjointPredicates_(t,e){if(this.m_matrix[0]=-1,this.m_matrix[1]=-1,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.m_performPredicates[2]){const s=this.m_scl[2],i=s==="T"||s==="F"||t.calculateLength2D()!==0;this.m_matrix[2]=i?1:0}if(this.m_performPredicates[5]){const s=Ai(t);this.m_matrix[5]=s?0:-1}if(this.m_performPredicates[6]){const s=this.m_scl[6],i=s==="T"||s==="F"||e.calculateLength2D()!==0;this.m_matrix[6]=i?1:0}if(this.m_performPredicates[7]){const s=Ai(e);this.m_matrix[7]=s?0:-1}}linePointDisjointPredicates_(t){if(this.m_matrix[0]=-1,this.m_matrix[3]=-1,this.m_performPredicates[2]){const e=this.m_scl[2],s=e==="T"||e==="F"||t.calculateLength2D()!==0;this.m_matrix[2]=s?1:0}if(this.m_performPredicates[5]){const e=Ai(t);this.m_matrix[5]=e?0:-1}this.m_matrix[6]=0}pointPointDisjointPredicates_(){this.m_matrix[0]=-1,this.m_matrix[2]=0,this.m_matrix[6]=0}areaAreaPredicates_(t,e,s){let i=!0;if(this.m_performPredicates[0]){this.interiorAreaInteriorArea_(t,e,s);const n=this.isPredicateKnown_(0);i&&=n}if(this.m_performPredicates[1]){this.interiorAreaBoundaryArea_(t,e,1);const n=this.isPredicateKnown_(1);i&&=n}if(this.m_performPredicates[2]){this.interiorAreaExteriorArea_(t,e,s,2);const n=this.isPredicateKnown_(2);i&&=n}if(this.m_performPredicates[3]){this.interiorAreaBoundaryArea_(t,s,3);const n=this.isPredicateKnown_(3);i&&=n}if(this.m_performPredicates[4]){this.boundaryAreaBoundaryArea_(t,e,s);const n=this.isPredicateKnown_(4);i&&=n}if(this.m_performPredicates[5]){this.boundaryAreaExteriorArea_(t,e,s,5);const n=this.isPredicateKnown_(5);i&&=n}if(this.m_performPredicates[6]){this.interiorAreaExteriorArea_(t,s,e,6);const n=this.isPredicateKnown_(6);i&&=n}if(this.m_performPredicates[7]){this.boundaryAreaExteriorArea_(t,s,e,7);const n=this.isPredicateKnown_(7);i&&=n}return i}areaLinePredicates_(t,e,s){let i=!0;if(this.m_performPredicates[0]){this.interiorAreaInteriorLine_(t,e,s);const n=this.isPredicateKnown_(0);i&&=n}if(this.m_performPredicates[1]){this.interiorAreaBoundaryLine_(t,e,s,this.m_clusterIndexB);const n=this.isPredicateKnown_(1);i&&=n}if(this.m_performPredicates[2]){this.interiorAreaExteriorLine_(t,e,s);const n=this.isPredicateKnown_(2);i&&=n}if(this.m_performPredicates[3]){this.boundaryAreaInteriorLine_(t,e,s,this.m_clusterIndexB);const n=this.isPredicateKnown_(3);i&&=n}if(this.m_performPredicates[4]){this.boundaryAreaBoundaryLine_(t,e,s,this.m_clusterIndexB);const n=this.isPredicateKnown_(4);i&&=n}if(this.m_performPredicates[5]){this.boundaryAreaExteriorLine_(t,e,s);const n=this.isPredicateKnown_(5);i&&=n}if(this.m_performPredicates[6]){this.exteriorAreaInteriorLine_(t,e);const n=this.isPredicateKnown_(6);i&&=n}if(this.m_performPredicates[7]){this.exteriorAreaBoundaryLine_(t,e,s,this.m_clusterIndexB);const n=this.isPredicateKnown_(7);i&&=n}return i}lineLinePredicates_(t,e,s){let i=!0;if(this.m_performPredicates[0]){this.interiorLineInteriorLine_(t,e,s,this.m_clusterIndexA,this.m_clusterIndexB);const n=this.isPredicateKnown_(0);i&&=n}if(this.m_performPredicates[1]){this.interiorLineBoundaryLine_(t,e,s,this.m_clusterIndexA,this.m_clusterIndexB,1);const n=this.isPredicateKnown_(1);i&&=n}if(this.m_performPredicates[2]){this.interiorLineExteriorLine_(t,e,s,2);const n=this.isPredicateKnown_(2);i&&=n}if(this.m_performPredicates[3]){this.interiorLineBoundaryLine_(t,s,e,this.m_clusterIndexB,this.m_clusterIndexA,3);const n=this.isPredicateKnown_(3);i&&=n}if(this.m_performPredicates[4]){this.boundaryLineBoundaryLine_(t,e,s,this.m_clusterIndexA,this.m_clusterIndexB);const n=this.isPredicateKnown_(4);i&&=n}if(this.m_performPredicates[5]){this.boundaryLineExteriorLine_(t,e,s,this.m_clusterIndexA,5);const n=this.isPredicateKnown_(5);i&&=n}if(this.m_performPredicates[6]){this.interiorLineExteriorLine_(t,s,e,6);const n=this.isPredicateKnown_(6);i&&=n}if(this.m_performPredicates[7]){this.boundaryLineExteriorLine_(t,s,e,this.m_clusterIndexB,7);const n=this.isPredicateKnown_(7);i&&=n}return i}areaPointPredicates_(t,e,s){let i=!0;if(this.m_performPredicates[0]){this.interiorAreaInteriorPoint_(t,e);const n=this.isPredicateKnown_(0);i&&=n}if(this.m_performPredicates[2]){this.interiorAreaExteriorPoint_(t,e);const n=this.isPredicateKnown_(2);i&&=n}if(this.m_performPredicates[3]){this.boundaryAreaInteriorPoint_(t,e,s);const n=this.isPredicateKnown_(3);i&&=n}if(this.m_performPredicates[5]){this.boundaryAreaExteriorPoint_(t,e);const n=this.isPredicateKnown_(5);i&&=n}if(this.m_performPredicates[6]){this.exteriorAreaInteriorPoint_(t,e);const n=this.isPredicateKnown_(6);i&&=n}return i}linePointPredicates_(t,e,s){let i=!0;if(this.m_performPredicates[0]){this.interiorLineInteriorPoint_(t,e,s,this.m_clusterIndexA);const n=this.isPredicateKnown_(0);i&&=n}if(this.m_performPredicates[2]){this.interiorLineExteriorPoint_(t,e,s,this.m_clusterIndexA);const n=this.isPredicateKnown_(2);i&&=n}if(this.m_performPredicates[3]){this.boundaryLineInteriorPoint_(t,e,s,this.m_clusterIndexA);const n=this.isPredicateKnown_(3);i&&=n}if(this.m_performPredicates[5]){this.boundaryLineExteriorPoint_(t,e,s,this.m_clusterIndexA);const n=this.isPredicateKnown_(5);i&&=n}if(this.m_performPredicates[6]){this.exteriorLineInteriorPoint_(t,e,s);const n=this.isPredicateKnown_(6);i&&=n}return i}pointPointPredicates_(t,e,s){let i=!0;if(this.m_performPredicates[0]){this.interiorPointInteriorPoint_(t,e,s);const n=this.isPredicateKnown_(0);i&&=n}if(this.m_performPredicates[2]){this.interiorPointExteriorPoint_(t,e,s,2);const n=this.isPredicateKnown_(2);i&&=n}if(this.m_performPredicates[6]){this.interiorPointExteriorPoint_(t,s,e,6);const n=this.isPredicateKnown_(6);i&&=n}return i}interiorAreaInteriorArea_(t,e,s){if(this.m_matrix[0]===2)return;const i=this.m_topoGraph.getHalfEdgeFaceParentage(t);(i&e)!==0&&(i&s)!==0&&(this.m_matrix[0]=2)}interiorAreaBoundaryArea_(t,e,s){if(this.m_matrix[s]===1)return;const i=this.m_topoGraph.getHalfEdgeFaceParentage(t),n=this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t));(i&e)!==0&&(n&e)!==0&&(this.m_matrix[s]=1)}interiorAreaExteriorArea_(t,e,s,i){if(this.m_matrix[i]===2)return;const n=this.m_topoGraph.getHalfEdgeFaceParentage(t);(n&e)!==0&&(n&s)===0&&(this.m_matrix[i]=2)}boundaryAreaBoundaryArea_(t,e,s){if(this.m_matrix[4]===1)return;const i=this.m_topoGraph.getHalfEdgeParentage(t);if((i&e)===0||(i&s)===0){if(this.m_matrix[4]!==0&&this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)!==1){const n=this.m_topoGraph.getHalfEdgeTo(t),o=this.m_topoGraph.getClusterParentage(n);if((o&e)!==0&&(o&s)!==0)return void(this.m_matrix[4]=0)}}else this.m_matrix[4]=1}boundaryAreaExteriorArea_(t,e,s,i){if(this.m_matrix[i]===1)return;const n=this.m_topoGraph.getHalfEdgeFaceParentage(t),o=this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t));(n&s)===0&&(o&s)===0&&(this.m_matrix[i]=1)}interiorAreaInteriorLine_(t,e,s){if(this.m_matrix[0]===1)return;const i=this.m_topoGraph.getHalfEdgeFaceParentage(t),n=this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t));(i&e)!==0&&(n&e)!==0&&(this.m_matrix[0]=1)}interiorAreaBoundaryLine_(t,e,s,i){if(this.m_matrix[1]!==0&&this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)!==1){const n=this.m_topoGraph.getHalfEdgeTo(t),o=this.m_topoGraph.getClusterParentage(n);if((o&e)===0&&(this.m_topoGraph.getHalfEdgeFaceParentage(t)&e)!==0){const a=this.m_topoGraph.getClusterUserIndex(n,i);if((o&s)!==0&&a%2!=0)return void(this.m_matrix[1]=0)}}}interiorAreaExteriorLine_(t,e,s){this.m_matrix[2]!==2&&(this.m_topoGraph.getHalfEdgeParentage(t)&e)!==0&&(this.m_matrix[2]=2)}boundaryAreaInteriorLine_(t,e,s,i){if(this.m_matrix[3]===1)return;const n=this.m_topoGraph.getHalfEdgeParentage(t);if((n&e)===0||(n&s)===0){if(this.m_matrix[3]!==0&&this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)!==1){const o=this.m_topoGraph.getHalfEdgeTo(t),a=this.m_topoGraph.getClusterParentage(o);if((a&e)!==0){const h=this.m_topoGraph.getClusterUserIndex(o,i);if((a&s)!==0&&h%2==0)return void(this.m_matrix[3]=0)}}}else this.m_matrix[3]=1}boundaryAreaBoundaryLine_(t,e,s,i){if(this.m_matrix[4]!==0&&this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)!==1){const n=this.m_topoGraph.getHalfEdgeTo(t),o=this.m_topoGraph.getClusterParentage(n);if((o&e)!==0){const a=this.m_topoGraph.getClusterUserIndex(n,i);if((o&s)!==0&&a%2!=0)return void(this.m_matrix[4]=0)}}}boundaryAreaExteriorLine_(t,e,s){if(this.m_matrix[5]===1)return;const i=this.m_topoGraph.getHalfEdgeParentage(t);(i&e)!==0&&(i&s)===0&&(this.m_matrix[5]=1)}exteriorAreaInteriorLine_(t,e){if(this.m_matrix[6]===1)return;const s=this.m_topoGraph.getHalfEdgeFaceParentage(t),i=this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t));(s&e)===0&&(i&e)===0&&(this.m_matrix[6]=1)}exteriorAreaBoundaryLine_(t,e,s,i){if(this.m_matrix[7]!==0&&this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)!==1){const n=this.m_topoGraph.getHalfEdgeTo(t),o=this.m_topoGraph.getClusterParentage(n);if((o&e)===0&&(this.m_topoGraph.getHalfEdgeFaceParentage(t)&e)===0){const a=this.m_topoGraph.getClusterUserIndex(n,i);if((o&s)!==0&&a%2!=0)return void(this.m_matrix[7]=0)}}}interiorLineInteriorLine_(t,e,s,i,n){if(this.m_matrix[0]===1)return;const o=this.m_topoGraph.getHalfEdgeParentage(t);if((o&e)===0||(o&s)===0){if(this.m_matrix[0]!==0&&this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)!==1){const a=this.m_topoGraph.getHalfEdgeTo(t),h=this.m_topoGraph.getClusterParentage(a);if((h&e)!==0&&(h&s)!==0){const m=this.m_topoGraph.getClusterUserIndex(a,i),l=this.m_topoGraph.getClusterUserIndex(a,n);if(m%2==0&&l%2==0)return void(this.m_matrix[0]=0)}}}else this.m_matrix[0]=1}interiorLineBoundaryLine_(t,e,s,i,n,o){if(this.m_matrix[o]!==0&&this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)!==1){const a=this.m_topoGraph.getHalfEdgeTo(t),h=this.m_topoGraph.getClusterParentage(a);if((h&e)!==0&&(h&s)!==0){const m=this.m_topoGraph.getClusterUserIndex(a,i),l=this.m_topoGraph.getClusterUserIndex(a,n);if(m%2==0&&l%2!=0)return void(this.m_matrix[o]=0)}}}interiorLineExteriorLine_(t,e,s,i){if(this.m_matrix[i]===1)return;const n=this.m_topoGraph.getHalfEdgeParentage(t);(n&e)!==0&&(n&s)===0&&(this.m_matrix[i]=1)}boundaryLineBoundaryLine_(t,e,s,i,n){if(this.m_matrix[4]!==0&&this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)!==1){const o=this.m_topoGraph.getHalfEdgeTo(t),a=this.m_topoGraph.getClusterParentage(o);if((a&e)!==0&&(a&s)!==0){const h=this.m_topoGraph.getClusterUserIndex(o,i),m=this.m_topoGraph.getClusterUserIndex(o,n);if(h%2!=0&&m%2!=0)return void(this.m_matrix[4]=0)}}}boundaryLineExteriorLine_(t,e,s,i,n){if(this.m_matrix[n]!==0&&this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)!==1){const o=this.m_topoGraph.getHalfEdgeTo(t);if((this.m_topoGraph.getClusterParentage(o)&s)===0&&this.m_topoGraph.getClusterUserIndex(o,i)%2!=0)return void(this.m_matrix[n]=0)}}interiorAreaInteriorPoint_(t,e){if(this.m_matrix[0]!==0&&(this.m_topoGraph.getClusterParentage(t)&e)===0){const s=this.m_topoGraph.getClusterChain(t);if((this.m_topoGraph.getChainParentage(s)&e)!==0)return void(this.m_matrix[0]=0)}}interiorAreaExteriorPoint_(t,e){this.m_matrix[2]!==2&&(this.m_topoGraph.getClusterParentage(t)&e)!==0&&(this.m_matrix[2]=2)}boundaryAreaInteriorPoint_(t,e,s){if(this.m_matrix[3]===0)return;const i=this.m_topoGraph.getClusterParentage(t);(i&e)===0||(i&s)===0||(this.m_matrix[3]=0)}boundaryAreaExteriorPoint_(t,e){this.m_matrix[5]!==1&&(this.m_topoGraph.getClusterParentage(t)&e)!==0&&(this.m_matrix[5]=1)}exteriorAreaInteriorPoint_(t,e){if(this.m_matrix[6]!==0&&(this.m_topoGraph.getClusterParentage(t)&e)===0){const s=this.m_topoGraph.getClusterChain(t);if((this.m_topoGraph.getChainParentage(s)&e)===0)return void(this.m_matrix[6]=0)}}interiorLineInteriorPoint_(t,e,s,i){if(this.m_matrix[0]===0)return;const n=this.m_topoGraph.getClusterParentage(t);if((n&e)!==0&&(n&s)!==0&&this.m_topoGraph.getClusterUserIndex(t,i)%2==0)return void(this.m_matrix[0]=0)}interiorLineExteriorPoint_(t,e,s,i){if(this.m_matrix[2]!==1)if(this.m_topoGraph.getClusterHalfEdge(t)===-1){if(this.m_matrix[2]!==0&&(this.m_topoGraph.getClusterParentage(t)&s)===0)return void(this.m_matrix[2]=0)}else this.m_matrix[2]=1}boundaryLineInteriorPoint_(t,e,s,i){if(this.m_matrix[3]===0)return;const n=this.m_topoGraph.getClusterParentage(t);if((n&e)!==0&&(n&s)!==0&&this.m_topoGraph.getClusterUserIndex(t,i)%2!=0)return void(this.m_matrix[3]=0)}boundaryLineExteriorPoint_(t,e,s,i){if(this.m_matrix[5]===0)return;const n=this.m_topoGraph.getClusterParentage(t);if((n&e)!==0&&(n&s)===0&&this.m_topoGraph.getClusterUserIndex(t,i)%2!=0)return void(this.m_matrix[5]=0)}exteriorLineInteriorPoint_(t,e,s){if(this.m_matrix[6]===0)return;const i=this.m_topoGraph.getClusterParentage(t);(i&e)!==0||(i&s)===0||(this.m_matrix[6]=0)}interiorPointInteriorPoint_(t,e,s){if(this.m_matrix[0]===0)return;const i=this.m_topoGraph.getClusterParentage(t);(i&e)===0||(i&s)===0||(this.m_matrix[0]=0)}interiorPointExteriorPoint_(t,e,s,i){if(this.m_matrix[i]===0)return;const n=this.m_topoGraph.getClusterParentage(t);(n&e)===0||(n&s)!==0||(this.m_matrix[i]=0)}computeMatrixTopoGraphHalfEdges_(t,e){let s=!1;const i=this.m_topoGraph.getGeometryID(t),n=this.m_topoGraph.getGeometryID(e);this.m_visitedIndex=this.m_topoGraph.createUserIndexForHalfEdges();for(let o=this.m_topoGraph.getFirstCluster();o!==v;o=this.m_topoGraph.getNextCluster(o)){const a=this.m_topoGraph.getClusterHalfEdge(o);if(a===v){if(this.m_predicatesCluster!==null&&(s=this.m_predicatesCluster(o,i,n),s))break;continue}let h=a;do{let m=h;if(this.m_topoGraph.getHalfEdgeUserIndex(m,this.m_visitedIndex)!==1)do{if(s=this.m_predicatesHalfEdge(m,i,n),s)break;this.m_topoGraph.setHalfEdgeUserIndex(m,this.m_visitedIndex,1),m=this.m_topoGraph.getHalfEdgeNext(m)}while(m!==h&&!s);if(s)break;h=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(m))}while(h!==a);if(s)break}s||this.setRemainingPredicatesToFalse_(),this.m_topoGraph.deleteUserIndexForHalfEdges(this.m_visitedIndex)}computeMatrixTopoGraphClusters_(t,e){let s=!1;const i=this.m_topoGraph.getGeometryID(t),n=this.m_topoGraph.getGeometryID(e);for(let o=this.m_topoGraph.getFirstCluster();o!==v&&(s=this.m_predicatesCluster(o,i,n),!s);o=this.m_topoGraph.getNextCluster(o));s||this.setRemainingPredicatesToFalse_()}setEditShape_(t,e){this.m_topoGraph.setEditShape(t,e)}setEditShapeCrackAndCluster_(t,e,s){let i=0;if(t.hasCurves()){const n=new ts,o=t.getEnvelope2D(s),a=Je(e.total(),o);i=Ms(a,0),_s(t,a,e.total(),12e3,n,null,s),n.clearStitcher(t)}Ns(t,e.add(i),s,!1,!1),t.filterClosePoints(0,!0,!0,!1,v);for(let n=t.getFirstGeometry();n!==v;n=t.getNextGeometry(n))t.getGeometryType(n)===T.enumPolygon&&ii(t,n,-1,!1,v,s);this.setEditShape_(t,s)}}function C_(r){const t=r[1],e=r[2],s=r[5];r[1]=r[3],r[2]=r[6],r[5]=r[7],r[3]=t,r[6]=e,r[7]=s}function Ku(r,t,e){const s=r.getGeometryType();if(he(s)){const i=new Pt({vd:r.getDescription()});return i.addSegment(r,!0),i}if(s===T.enumEnvelope){const i=r,n=F.constructEmpty();if(r.queryEnvelope(n),n.height()<=t&&n.width()<=t){const a=new st({vd:r.getDescription()});return i.getCenter(a),a}if(n.height()<=t||n.width()<=t){const a=new Pt({vd:r.getDescription()}),h=new st;return i.queryCornerByVal(0,h),a.startPathPoint(h),i.queryCornerByVal(2,h),a.lineToPoint(h),a}const o=new ct({vd:r.getDescription()});return o.addEnvelope(i,!1),o}return r}function an(r){return`${r[0]}${r[3]}${r[6]}${r[1]}${r[4]}${r[7]}${r[2]}${r[5]}${r[8]}`}class os{nullFunc(){return $("should not be called"),!1}constructor(t,e,s,i=!1){this.m_bDone=!1,this.m_tolerance=0,this.m_elementHandle=-1,this.m_query=F.constructEmpty(),this.m_envInter=F.constructEmpty(),this.m_quadTree=null,this.m_intersector=null,this.m_function=this.nullFunc;const n=t.getAccelerators();let o=null;n!=null&&(o=i?n.getQuadTreeForPaths():n.getQuadTree());const a=e.getAccelerators();let h=null;if(a!=null&&(h=i?a.getQuadTreeForPaths():a.getQuadTree()),o===null&&h===null&&!i){const m=t.getPointCount(),l=e.getPointCount();if(m>10&&l>10){const u=F.constructEmpty(),c=F.constructEmpty(),g=F.constructEmpty();t.queryLooseEnvelope(u),e.queryLooseEnvelope(c),u.inflateCoords(s,s),c.inflateCoords(s,s),g.setCoords({env2D:u}),g.intersect(c),m>=l?o=lt(t.getGeometryType())?Pn(t,g):Nl(t,g):h=lt(e.getGeometryType())?Pn(e,g):Nl(e,g)}}this.construct_(t,o,e,h,s,i)}next(){if(this.m_bQuadTree){if(this.m_bDone)return!1;for(;this.m_function(););return!this.m_bDone}return!!this.m_intersector&&this.m_intersector.next()}getRedElement(){return this.m_bQuadTree?this.m_bSwapElements?this.m_quadTree.getElement(this.m_elementHandle):lt(this.m_queryType)?this.m_bPaths?this.m_pathIndex:this.m_segIter.getStartPointIndex():this.m_pointIndex:this.m_bSwapElements?this.m_intersector.getBlueElement(this.m_intersector.getHandleB()):this.m_intersector.getRedElement(this.m_intersector.getHandleA())}getBlueElement(){return this.m_bQuadTree?this.m_bSwapElements?lt(this.m_queryType)?this.m_bPaths?this.m_pathIndex:this.m_segIter.getStartPointIndex():this.m_pointIndex:this.m_quadTree.getElement(this.m_elementHandle):this.m_bSwapElements?this.m_intersector.getRedElement(this.m_intersector.getHandleA()):this.m_intersector.getBlueElement(this.m_intersector.getHandleB())}getRedEnvelope(){return this.m_bPaths||Yt(""),this.m_bQuadTree?this.m_bSwapElements?this.m_quadTree.getElementExtent(this.m_elementHandle):this.m_query:this.m_bSwapElements?this.m_intersector.getBlueEnvelope(this.m_intersector.getHandleB()):this.m_intersector.getRedEnvelope(this.m_intersector.getHandleA())}getBlueEnvelope(){return this.m_bPaths||Yt(""),this.m_bQuadTree?this.m_bSwapElements?this.m_query:this.m_quadTree.getElementExtent(this.m_elementHandle):this.m_bSwapElements?this.m_intersector.getRedEnvelope(this.m_intersector.getHandleA()):this.m_intersector.getBlueEnvelope(this.m_intersector.getHandleB())}construct_(t,e,s,i,n,o){const a=F.constructEmpty(),h=F.constructEmpty();t.queryLooseEnvelope(a),s.queryLooseEnvelope(h),a.inflateCoords(n,n),h.inflateCoords(n,n),this.m_envInter.setCoords({env2D:a}),this.m_envInter.intersect(h),this.m_multiVertexImplA=t,this.m_multiVertexImplB=s;const m=t.getGeometryType(),l=s.getGeometryType();this.m_bPaths=o,this.m_pathIndex=-1,this.m_pointIndex=-1,this.m_bSwapElements=!1,this.m_queryType=T.enumUnknown,this.m_bQuadTree=!1,e!==null&&(this.m_bDone=!1,this.m_tolerance=n,this.m_quadTree=e,this.m_qtIter=this.m_quadTree.getIteratorForQT(),this.m_bQuadTree=!0,this.m_bSwapElements=!0,lt(l)?(this.m_queryType=l,this.m_function=this.nextPath_,o?this.m_pathIndex=s.getPathCount():this.m_segIter=s.querySegmentIterator()):(this.m_queryType=l,this.m_function=this.nextPoint_,this.m_pointIndex=s.getPointCount())),this.m_bQuadTree||i!==null&&(this.m_bDone=!1,this.m_tolerance=n,this.m_quadTree=i,this.m_qtIter=this.m_quadTree.getIteratorForQT(),this.m_bQuadTree=!0,this.m_bSwapElements=!1,lt(m)?(this.m_queryType=m,this.m_function=this.nextPath_,o?this.m_pathIndex=t.getPathCount():this.m_segIter=t.querySegmentIterator()):(this.m_queryType=m,this.m_function=this.nextPoint_,this.m_pointIndex=t.getPointCount())),this.m_bQuadTree||(o&&lt(m)&&lt(l)?this.m_intersector=bp(t,s,n):lt(m)&&lt(l)?(this.m_intersector=vp(t,s,n),this.m_bSwapElements=!1):lt(m)&&!lt(l)?(this.m_intersector=Tl(t,s,n),this.m_bSwapElements=!1):!lt(m)&&lt(l)?(this.m_intersector=Tl(s,t,n),this.m_bSwapElements=!0):(this.m_intersector=Ip(t,s,n),this.m_bSwapElements=!1))}nextPath_(){return this.m_bPaths?--this.m_pathIndex===-1?(this.m_bDone=!0,!1):(this.m_bSwapElements?this.m_multiVertexImplB.queryPathEnvelope(this.m_pathIndex,this.m_query):this.m_multiVertexImplA.queryPathEnvelope(this.m_pathIndex,this.m_query),this.m_qtIter.resetIterator(this.m_query,this.m_tolerance),this.m_function=this.iterate_,!0):this.m_segIter.nextPath()?(this.m_function=this.nextSegment_,!0):(this.m_bDone=!0,!1)}nextSegment_(){if(!this.m_segIter.hasNextSegment())return this.m_function=this.nextPath_,!0;const t=this.m_segIter.nextSegment(),e=new F;return t.queryLooseEnvelope(e),!e.isIntersecting(this.m_envInter)||(this.m_qtIter.resetIterator(t,this.m_tolerance),this.m_function=this.iterate_,!0)}nextPoint_(){if(--this.m_pointIndex===-1)return this.m_bDone=!0,!1;const t=new y;if(this.m_bSwapElements){const e=this.m_multiVertexImplB.getXY(this.m_pointIndex);t.setCoordsPoint2D(e)}else{const e=this.m_multiVertexImplA.getXY(this.m_pointIndex);t.setCoordsPoint2D(e)}return!this.m_envInter.contains(t)||(this.m_qtIter.resetIterator(F.construct(t.x,t.y,t.x,t.y),this.m_tolerance),this.m_function=this.iterate_,!0)}iterate_(){return this.m_elementHandle=this.m_qtIter.next(),this.m_elementHandle===-1&&(lt(this.m_queryType)?(this.m_function=this.m_bPaths?this.nextPath_:this.nextSegment_,!0):(this.m_function=this.nextPoint_,!0))}}function Ja(r){return r===2?1:r===1?2:r===128?64:r===64?128:r}function jx(r,t,e){let s;if(r instanceof ci||r===null){const i=F.constructEmpty();i.setCoords({pt:t}),i.mergeEnvelope2D(e),s=Di(r,i,!1)}else s=r;return s}function E_(r,t,e){let s;if(r instanceof ci||r===null){const i=F.constructEmpty();i.setCoords({env2D:t}),i.mergeEnvelope2D(e),s=Di(r,i,!1)}else s=r;return s}function ti(r,t,e,s,i){if(r.isEmpty()||t.isEmpty())return s===4;ni(r),ni(t);let n=r.getGeometryType(),o=t.getGeometryType();if(n===T.enumEnvelope){if(o===T.enumEnvelope)return Zx(r,t,e,s);if(o===T.enumPoint)return Ju(t,r,e,Ja(s))}else if(n===T.enumPoint){if(o===T.enumEnvelope)return Ju(r,t,e,s);if(o===T.enumPoint)return Qx(r,t,e,s)}const a=F.constructEmpty();r.queryEnvelope(a);const h=F.constructEmpty();t.queryEnvelope(h);const m=E_(e,a,h);if($s(a,h,m))return s===4;let l=!1,u=null,c=null,g=null,_=null;switch(he(n)?(u=new Pt({vd:r.getDescription()}),u.addSegment(r,!0),g=u,n=T.enumPolyline):g=r,he(o)?(c=new Pt({vd:t.getDescription()}),c.addSegment(t,!0),_=c,o=T.enumPolyline):_=t,n!==T.enumEnvelope&&o!==T.enumEnvelope?(g.getDimension()<_.getDimension()||n===T.enumPoint&&o===T.enumMultiPoint)&&(s=Ja(s)):n!==T.enumPolygon&&o!==T.enumEnvelope&&(s=Ja(s)),n){case T.enumPolygon:switch(o){case T.enumPolygon:l=Kx(g,_,m,s,i);break;case T.enumPolyline:l=tc(g,_,m,s,i);break;case T.enumPoint:l=ec(g,_,m,s);break;case T.enumMultiPoint:l=sc(g,_,m,s);break;case T.enumEnvelope:l=ic(g,_,m,s,i)}break;case T.enumPolyline:switch(o){case T.enumPolygon:l=tc(_,g,m,s,i);break;case T.enumPolyline:l=Jx(g,_,m,s,i);break;case T.enumPoint:l=nc(g,_,m,s);break;case T.enumMultiPoint:l=rc(g,_,m,s);break;case T.enumEnvelope:l=oc(g,_,m,s,i)}break;case T.enumPoint:switch(o){case T.enumPolygon:l=ec(_,g,m,s);break;case T.enumPolyline:l=nc(_,g,m,s);break;case T.enumMultiPoint:l=ac(_,g,m,s)}break;case T.enumMultiPoint:switch(o){case T.enumPolygon:l=sc(_,g,m,s);break;case T.enumPolyline:l=rc(_,g,m,s);break;case T.enumMultiPoint:l=ty(g,_,m,s);break;case T.enumPoint:l=ac(g,_,m,s);break;case T.enumEnvelope:l=hc(g,_,m,s)}break;case T.enumEnvelope:switch(o){case T.enumPolygon:l=ic(_,g,m,s,i);break;case T.enumPolyline:l=oc(_,g,m,s,i);break;case T.enumMultiPoint:l=hc(_,g,m,s)}}return l}function Zx(r,t,e,s,i){if(r.isEmpty()||t.isEmpty())return s===4;const n=F.constructEmpty();r.queryEnvelope(n);const o=F.constructEmpty();t.queryEnvelope(o);const a=E_(e,n,o);switch(s){case 4:return $s(n,o,a);case 2:return ro(o,n,a,!1);case 128:return ro(o,n,a,!0);case 1:return ro(n,o,a,!1);case 64:return ro(n,o,a,!0);case 3:return ui(n,o,a);case 8:return Wy(n,o,a);case 32:return $y(n,o,a);case 16:return!1}return!1}function Ju(r,t,e,s,i){if(r.isEmpty()||t.isEmpty())return s===4;const n=r.getXY(),o=F.constructEmpty();t.queryEnvelope(o);const a=jx(e,n,o);switch(s){case 4:return Ca(n,o,a);case 2:case 128:return Oy(n,o,a);case 1:case 64:return!1;case 3:return zy(n,o,a);case 8:return Uy(n,o,a)}return!1}function Qx(r,t,e,s,i){if(r.isEmpty()||t.isEmpty())return s===4;const n=r.getXY(),o=t.getXY();let a;if(e instanceof ci||e===null){const h=F.constructEmpty();h.setCoords({pt:n}),h.merge(o),a=Di(e,h,!1)}else a=e;switch(s){case 4:return Hy(n,o,a);case 2:case 128:return xc(o,n,a);case 1:case 64:return xc(n,o,a);case 3:return w_(n,o,a)}return!1}function $s(r,t,e){const s=F.constructEmpty();return s.setCoords({env2D:t}),s.inflateCoords(e,e),!r.isIntersecting(s)}function vt(r,t,e,s=!1){const i=r.getGeometryType(),n=t.getGeometryType();if(We(i)){const o=r.getImpl().getAccelerators();if(o!==null){const a=o.getRasterizedGeometry();b(a===null)}}if(We(n)){const o=t.getImpl().getAccelerators();if(o!==null){const a=o.getRasterizedGeometry();b(a===null)}}return 0}function Ca(r,t,e,s){const i=F.constructEmpty();return i.setCoords({env2D:t}),i.inflateCoords(e,e),!i.contains(r)}function Kx(r,t,e,s,i){switch(s){case 4:return ey(r,t,e);case 2:return mc(t,r,e,i);case 128:return lc(t,r,e);case 1:return mc(r,t,e,i);case 64:return lc(r,t,e);case 3:return S_(r,t,e,i);case 8:return sy(r,t,e);case 32:return iy(r,t,e,i)}return!1}function tc(r,t,e,s,i){switch(s){case 4:return ny(r,t,e);case 1:return oy(r,t,e,i);case 64:return ay(r,t,e);case 8:return v_(r,t,e,i);case 16:return ry(r,t,e)}return!1}function ec(r,t,e,s,i){switch(s){case 4:return hy(r,t,e);case 1:case 64:return ly(r,t,e);case 8:return my(r,t,e)}return!1}function sc(r,t,e,s,i){switch(s){case 4:return uy(r,t,e);case 1:return uc(r,t,e,!1);case 64:return uc(r,t,e,!0);case 8:return cy(r,t,e);case 16:return gy(r,t,e)}return!1}function ic(r,t,e,s,i){if(dy(r,t,e))return s===4;if(s===4)return!1;switch(s){case 2:return cc(r,t,e,!1);case 128:return cc(r,t,e,!0);case 1:return gc(r,t,e,!1,i);case 64:return gc(r,t,e,!0,i);case 3:return _y(r,t,e,i);case 8:return py(r,t,e,i);case 32:return fy(r,t,e,i);case 16:return!1}return!1}function Jx(r,t,e,s,i){switch(s){case 4:return yy(r,t,e);case 2:return _c(t,r,e,i);case 128:return dc(t,r,e,i);case 1:return _c(r,t,e,i);case 64:return dc(r,t,e,i);case 3:return xy(r,t,e,i);case 8:return Py(r,t,e,i);case 32:return Ey(r,t,e,i);case 16:return Cy(r,t,e,i)}return!1}function nc(r,t,e,s,i){switch(s){case 4:return Sy(r,t,e);case 1:case 64:return by(r,t,e);case 8:return vy(r,t,e)}return!1}function rc(r,t,e,s,i){switch(s){case 4:return Iy(r,t,e);case 1:case 64:return Ty(r,t,e);case 8:return wy(r,t,e);case 16:return Dy(r,t,e)}return!1}function oc(r,t,e,s,i){if(Ay(r,t,e))return s===4;if(s===4)return!1;switch(s){case 2:return pc(r,t,e,!1);case 128:return pc(r,t,e,!0);case 1:case 64:case 32:return!1;case 3:return Ny(r,t,e);case 8:return qy(r,t,e,i);case 16:return Fy(r,t,e)}return!1}function ty(r,t,e,s,i){switch(s){case 4:return Gy(r,t,e);case 2:case 128:return Qi(t,r,e);case 1:case 64:return Qi(r,t,e);case 3:return My(r,t,e);case 32:return Vy(r,t,e)}return!1}function ac(r,t,e,s,i){switch(s){case 4:return I_(r,t,e);case 2:case 128:return Yy(r,t,e);case 1:case 64:return Xy(r,t,e);case 3:return b_(r,t,e)}return!1}function hc(r,t,e,s,i){switch(s){case 4:return ky(r,t,e);case 2:return fc(r,t,e,!1);case 128:return fc(r,t,e,!0);case 1:case 64:return!1;case 3:return Ry(r,t,e);case 8:return Ly(r,t,e);case 16:return By(r,t,e)}return!1}function S_(r,t,e,s){const i=F.constructEmpty(),n=F.constructEmpty();if(r.queryEnvelope(i),t.queryEnvelope(n),!ui(i,n,e))return!1;if(vt(r,t),T_(r,t,e))return!0;const o=r.calculateLength2D(),a=t.calculateLength2D(),h=Math.max(r.getPointCount(),t.getPointCount());return Math.abs(o-a)>4*h*e?!1:r.hasNonLinearSegments()||t.hasNonLinearSegments()?fs(r,t,e,"**F**FFF*",s,!1):N_(r,t,e,!0)}function ey(r,t,e,s){return vt(r,t,e,!0),Lr(r,t,e,!0)===1}function sy(r,t,e,s){return vt(r,t),G_(r,t,e,null)}function iy(r,t,e,s){return vt(r,t),V_(r,t,e,s)}function mc(r,t,e,s){const i=F.constructEmpty(),n=F.constructEmpty();return r.queryEnvelope(i),t.queryEnvelope(n),!!me(i,n,e)&&(vt(r,t),Y_(r,t,e,s))}function lc(r,t,e,s){const i=F.constructEmpty(),n=F.constructEmpty();return r.queryEnvelope(i),t.queryEnvelope(n),!!me(i,n,e)&&(vt(r,t),Lr(r,t,e,!1)===2)}function ny(r,t,e,s){return vt(r,t,e,!0),Lr(r,t,e,!0)===1}function v_(r,t,e,s){return vt(r,t),Ky(r,t,e,s)}function ry(r,t,e,s){return vt(r,t),Jy(r,t,e,null)}function oy(r,t,e,s){const i=F.constructEmpty(),n=F.constructEmpty();return r.queryEnvelope(i),t.queryEnvelope(n),!!me(i,n,e)&&(vt(r,t),tP(r,t,e,s))}function ay(r,t,e,s){const i=F.constructEmpty(),n=F.constructEmpty();return r.queryEnvelope(i),t.queryEnvelope(n),!!me(i,n,e)&&(vt(r,t),Lr(r,t,e,!1)===2)}function hy(r,t,e,s){return k_(r,t,e)===0}function my(r,t,e,s){return sP(r,t.getXY(),e)}function ly(r,t,e,s){return eP(r,t.getXY(),e)}function uy(r,t,e,s,i){return vt(r,t),jy(r,t,e)===1}function cy(r,t,e,s){vt(r,t);const i=F.constructEmpty();r.queryEnvelope(i),i.inflateCoords(e,e);const n=new y;let o=!1;const a=r.getImpl(),h=new ct;let m=r,l=!1;for(let u=0;u<t.getPointCount();u++){if(t.queryXY(u,n),i.contains(n)){const c=Ye(m,n,e);if(c===2)o=!0;else if(c===1)return!1}l||(!Ii(r,t.getPointCount()-1)||a.getAccelerators()!==null&&a.getAccelerators().getQuadTree()!==null?m=r:(r.copyTo(h),h.getImpl().buildQuadTreeAccelerator(1),m=h),l=!0)}return!!o}function gy(r,t,e,s){vt(r,t);const i=new F,n=new F,o=new F;r.queryEnvelope(i),t.queryEnvelope(o),n.setCoords({env2D:i}),n.inflateCoords(e,e);let a=!1,h=!1;const m=new y,l=r.getImpl(),u=new ct;let c=r,g=!1;for(let _=0;_<t.getPointCount();_++){if(t.queryXY(_,m),n.contains(m)){const d=Ye(c,m,e);d===0?h=!0:d===1&&(a=!0)}else h=!0;if(a&&h)return!0;g||(!Ii(r,t.getPointCount()-1)||l.getAccelerators()!==null&&l.getAccelerators().getQuadTree()!==null?c=r:(r.copyTo(u),u.getImpl().buildQuadTreeAccelerator(1),c=u),g=!0)}return!1}function uc(r,t,e,s,i){const n=F.constructEmpty(),o=F.constructEmpty();if(r.queryEnvelope(n),t.queryEnvelope(o),!me(n,o,e))return!1;vt(r,t);let a=!1;const h=new y,m=r.getImpl(),l=new ct;let u=r,c=!1;for(let g=0;g<t.getPointCount();g++){if(t.queryXY(g,h),!n.contains(h))return!1;const _=Ye(u,h,e);if(_===1)a=!0;else if(_===0)return!1;if(s&&_===2)return!1;c||(!Ii(r,t.getPointCount()-1)||m.getAccelerators()!==null&&m.getAccelerators().getQuadTree()!==null?u=r:(r.copyTo(l),l.getImpl().buildQuadTreeAccelerator(1),u=l),c=!0)}return a}function _y(r,t,e,s){const i=new F,n=new F;if(r.queryEnvelope(i),t.queryEnvelope(n),!ui(i,n,e))return!1;const o=new ct;return o.addEnvelope(t,!1),S_(r,o,e,s)}function dy(r,t,e,s){vt(r,t);const i=F.constructEmpty(),n=F.constructEmpty();return r.queryEnvelope(i),t.queryEnvelope(n),me(n,i,e)?!1:Ye(r,n.getLowerLeft(),0)===0&&!n.contains(r.getXY(0))&&!M_(r,n,e)}function py(r,t,e,s){vt(r,t);const i=new F,n=new F;if(r.queryEnvelope(i),t.queryEnvelope(n),me(n,i,e)||n.height()<=e||n.width()<=e)return!1;const o=new ct;return o.addEnvelope(t,!1),G_(r,o,e,s)}function fy(r,t,e,s){vt(r,t);const i=new F,n=new F;if(r.queryEnvelope(i),t.queryEnvelope(n),me(n,i,e)||n.height()<=e||n.width()<=e)return!1;const o=new ct;return o.addEnvelope(t,!1),V_(r,o,e,s)}function cc(r,t,e,s,i){const n=F.constructEmpty(),o=F.constructEmpty();return r.queryEnvelope(n),t.queryEnvelope(o),s?Ea(o,n,e):me(o,n,e)}function gc(r,t,e,s,i){const n=F.constructEmpty(),o=F.constructEmpty();if(r.queryEnvelope(n),t.queryEnvelope(o),!me(n,o,e))return!1;vt(r,t);const a=new ct;return a.addEnvelope(t,!1),s?Lr(r,a,e,!1)===2:Y_(r,a,e,i)}function xy(r,t,e,s){const i=F.constructEmpty(),n=F.constructEmpty();return r.queryEnvelope(i),t.queryEnvelope(n),ui(i,n,e)?(vt(r,t),T_(r,t,e)?!0:r.hasNonLinearSegments()||t.hasNonLinearSegments()?fs(r,t,e,"**F**FFF*",s,!1):N_(r,t,e,!1)):!1}function yy(r,t,e,s){vt(r,t);const i=r.getImpl(),n=t.getImpl();return!new os(i,n,e,!0).next()||!A_(r,t,e)}function Py(r,t,e,s){vt(r,t);const i=[],n=Wm(r,t,e,i);if(n===-2){const m=F.constructEmpty(),l=F.constructEmpty(),u=F.constructEmpty();let c,g;if(r.queryEnvelope(m),t.queryEnvelope(l),m.inflateCoords(1e3*e,1e3*e),l.inflateCoords(1e3*e,1e3*e),u.setCoords({env2D:m}),u.intersect(l),r.getPointCount()>10){if(c=Dt(r,u,e,0,s),c.isEmpty())return!1}else c=r;if(t.getPointCount()>10){if(g=Dt(t,u,e,0,s),g.isEmpty())return!1}else g=t;return fs(c,g,e,"F********",s,!1)}if(n!==0)return!1;const o=new Zt;for(let m=0;m<i.length;m+=2){const l=i[m],u=i[m+1];o.addXY(l,u)}const a=r.getBoundary(),h=t.getBoundary();return a.addPoints(h,0,h.getPointCount()),!a.isEmpty()&&Qi(a,o,e)}function Cy(r,t,e,s){vt(r,t);const i=[],n=Wm(r,t,e,i);if(n===-2){const m=F.constructEmpty(),l=F.constructEmpty(),u=F.constructEmpty();let c,g;if(r.queryEnvelope(m),t.queryEnvelope(l),m.inflateCoords(1e3*e,1e3*e),l.inflateCoords(1e3*e,1e3*e),u.setCoords({env2D:m}),u.intersect(l),r.getPointCount()>10){if(c=Dt(r,u,e,0,s),c.isEmpty())return!1}else c=r;if(t.getPointCount()>10){if(g=Dt(t,u,e,0,s),g.isEmpty())return!1}else g=t;return fs(c,g,e,"0********",s,!1)}if(n!==0)return!1;const o=new Zt;for(let m=0;m<i.length;m+=2){const l=i[m],u=i[m+1];o.addXY(l,u)}const a=r.getBoundary(),h=t.getBoundary();return a.addPoints(h,0,h.getPointCount()),!!a.isEmpty()||!Qi(a,o,e)}function Ey(r,t,e,s){vt(r,t);const i=F.constructEmpty(),n=F.constructEmpty();r.queryEnvelope(i),t.queryEnvelope(n);const o=Dr(i,n,e),a=Dr(n,i,e),h=r.hasNonLinearSegments(),m=t.hasNonLinearSegments(),l=Wm(r,t,e,null);if(l===-1)return!1;if(l===1){if(o&&a)return!0;if(!h&&!m)return o&&!a?!Vi(t,r,e,!1):a&&!o?!Vi(r,t,e,!1):!Vi(r,t,e,!1)&&!Vi(t,r,e,!1)}const u=F.constructEmpty(),c=F.constructEmpty(),g=F.constructEmpty();let _,d;u.setCoords({env2D:i}),u.inflateCoords(1e3*e,1e3*e),c.setCoords({env2D:n}),c.inflateCoords(1e3*e,1e3*e),g.setCoords({env2D:u}),g.intersect(c);let p="";if(p+="1*",o){if(t.getPointCount()>10){if(d=Dt(t,g,e,0,s),d.isEmpty())return!1}else d=t;p+="****"}else d=t,p+="T***";if(a){if(r.getPointCount()>10){if(_=Dt(r,g,e,0,s),_.isEmpty())return!1}else _=r;p+="***"}else _=r,p+="T**";return fs(_,d,e,p,s,!1)}function _c(r,t,e,s){const i=F.constructEmpty(),n=F.constructEmpty();return r.queryEnvelope(i),t.queryEnvelope(n),me(i,n,e)?(vt(r,t),r.hasNonLinearSegments()||t.hasNonLinearSegments()?fs(r,t,e,"******FF*",s,!1):Vi(t,r,e,!1)):!1}function dc(r,t,e,s){const i=F.constructEmpty(),n=F.constructEmpty();return r.queryEnvelope(i),t.queryEnvelope(n),me(i,n,e)?(vt(r,t),fs(r,t,e,"T**FF*FF*",s,!1)):!1}function Sy(r,t,e,s){return vt(r,t),!F_(r,t.getXY(),e)}function vy(r,t,e,s){return vt(r,t),R_(r,t.getXY(),e)}function by(r,t,e,s){return vt(r,t),Qy(r,t.getXY(),e)}function Iy(r,t,e,s){return vt(r,t),!q_(r,t,e,!1)}function wy(r,t,e,s){vt(r,t);const i=r.getImpl(),n=t.getImpl(),o=new Zt,a=new os(i,n,e,!1),h=i.querySegmentIterator();let m=!1;for(;a.next();){const u=a.getRedElement(),c=a.getBlueElement();h.resetToVertex(u,-1);const g=h.nextSegment(),_=n.getXY(c);g.isIntersectingPoint(_,e)&&(m=!0,o.addPoint2D(_))}if(!m)return!1;const l=r.getBoundary();return!l.isEmpty()&&Qi(l,o,e)}function Dy(r,t,e,s){vt(r,t);const i=r.getImpl(),n=t.getImpl(),o=n.getPointCount(),a=j(o,!1),h=new os(i,n,e,!1),m=i.querySegmentIterator();let l=!1;for(;h.next();){const _=h.getRedElement(),d=h.getBlueElement();m.resetToVertex(_,-1);const p=m.nextSegment(),f=n.getXY(d);p.isIntersectingPoint(f,e)&&(l=!0,a[d]=!0)}if(!l)return!1;let u=!1;for(let _=0;_<o;_++)if(!a[_]){u=!0;break}if(!u)return!1;const c=r.getBoundary();if(c.isEmpty())return!0;const g=new Zt;for(let _=0;_<o;_++)a[_]&&g.addPoint2D(n.getXY(_));return!Qi(c,g,e)}function Ty(r,t,e,s,i){const n=F.constructEmpty(),o=F.constructEmpty();if(r.queryEnvelope(n),t.queryEnvelope(o),!me(n,o,e))return!1;vt(r,t);const a=q_(r,t,e,!0);if(!a)return a;const h=r.getBoundary();return h.isEmpty()?a:!Qi(h,t,e)}function Ny(r,t,e,s){const i=new F,n=new F;return r.queryEnvelope(i),t.queryEnvelope(n),!(n.height()>e&&n.width()>e)&&ui(i,n,e)}function Ay(r,t,e,s){const i=F.constructEmpty(),n=F.constructEmpty();r.queryEnvelope(i),t.queryEnvelope(n);const o=iP(n,i,e);return o===0?!M_(r,n,e):o===4}function qy(r,t,e,s){const i=new F,n=new F;if(r.queryEnvelope(i),t.queryEnvelope(n),n.height()<=e||n.width()<=e)return!1;const o=new F,a=new F;if(o.setCoords({env2D:n}),a.setCoords({env2D:n}),o.inflateCoords(e,e),a.inflateCoords(-e,-e),a.containsEnvelope(i)||!i.isIntersecting(o))return!1;const h=r.getImpl().querySegmentIterator();h.stripAttributes();const m=r.getImpl().getAccelerators();let l=null,u=null;m!==null&&(l=m.getQuadTree(),l!==null&&(u=l.getIterator(n,e))),u||h.nextPath()||$("relational_operations");let c=!1,g=null;const _=new y,d=new y,p=r.hasNonLinearSegments();let f=!1;for(;;){if(u!==null){const E=u.next();if(E===-1)break;h.resetToVertex(l.getElement(E),-1),g=h.nextSegment()}else{for(;!h.hasNextSegment()&&h.nextPath(););if(!h.hasNextSegment())break;g=h.nextSegment()}if(p&&g.getGeometryType()!==T.enumLine){const E=new F;if(g.queryEnvelope(E),a.containsEnvelope(E))return!1;if(o.isIntersecting(E)){f=!0;break}}else{_.assign(g.getStartXY()),d.assign(g.getEndXY());let E=a.clipLine(_,d);if(E!==0)return!1;c||(E=o.clipLine(_,d),E!==0&&(c=!0))}}if(!f)return c;const x=new ct;return x.addEnvelope(n,!1),v_(x,r,e,s)}function pc(r,t,e,s,i){const n=F.constructEmpty(),o=F.constructEmpty();if(r.queryEnvelope(n),t.queryEnvelope(o),o.height()<=e||o.width()<=e)return!1;if(s)return Ea(o,n,e);if(!me(o,n,e))return!1;const a=F.constructEmpty();a.setCoords({env2D:o}),a.inflateCoords(-e,-e);const h=F.constructEmpty();if(h.setCoords({env2D:o}),h.inflateCoords(e,e),a.containsEnvelope(n))return!0;const m=r.getImpl().querySegmentIterator();m.stripAttributes(),m.nextPath()||$("relational_operations");let l,u,c,g,_,d,p=!1;const f=r.hasNonLinearSegments();for(f&&(c=new ht,g=new ht,_=new ht,d=new ht,a.querySide(0,c),a.querySide(1,g),a.querySide(2,_),a.querySide(3,d));;){for(;!m.hasNextSegment()&&m.nextPath(););if(!m.hasNextSegment())break;const x=m.nextSegment();if(f&&x.getGeometryType()!==T.enumLine){if(x.isIntersecting(c,e)){p=!0;break}if(x.isIntersecting(g,e)){p=!0;break}if(x.isIntersecting(_,e)){p=!0;break}if(x.isIntersecting(d,e)){p=!0;break}}else if(l=x.getStartXY(),u=x.getEndXY(),a.clipLine(l,u)!==0){p=!0;break}}return p}function Fy(r,t,e,s){const i=new F,n=new F;if(r.queryEnvelope(i),t.queryEnvelope(n),n.height()<=e||n.width()<=e)return!1;const o=new F;if(o.setCoords({env2D:n}),o.inflateCoords(e,e),o.containsEnvelope(i))return!1;const a=!0,h=new F;if(h.setCoords({env2D:n}),h.inflateCoords(-e,-e),!h.isIntersecting(i))return!1;const m=r.getImpl().querySegmentIterator();m.stripAttributes();const l=r.getImpl().getAccelerators();let u=null,c=null;if(l!==null&&(u=l.getQuadTree(),u!==null&&(c=u.getIterator(n,e))),!c){const C=m.nextPath();b(C)}let g=!1,_=null;const d=new y,p=new y;let f=null,x=null,E=null,P=null;for(r.hasNonLinearSegments()&&(f=new ht,x=new ht,E=new ht,P=new ht,h.querySide(0,f),h.querySide(1,x),h.querySide(2,E),h.querySide(3,P));;){if(c!==null){const C=c.next();if(C===-1)break;m.resetToVertex(u.getElement(C),-1),_=m.nextSegment()}else{for(;!m.hasNextSegment()&&m.nextPath(););if(!m.hasNextSegment())break;_=m.nextSegment()}if(_.getGeometryType()===T.enumLine){if(d.assign(_.getStartXY()),p.assign(_.getEndXY()),h.clipLine(d,p)!==0){g=!0;break}}else{if(f.isIntersecting(_,e)){g=!0;break}if(x.isIntersecting(_,e)){g=!0;break}if(E.isIntersecting(_,e)){g=!0;break}if(P.isIntersecting(_,e)){g=!0;break}}}return g&&a}function My(r,t,e,s){const i=F.constructEmpty(),n=F.constructEmpty();return r.queryEnvelope(i),t.queryEnvelope(n),!!ui(i,n,e)&&(!!Zy(r,t,e)||Om(r,t,e,!1,!0,!1))}function Gy(r,t,e,s){const i=r,n=t,o=new os(i,n,e,!1),a=e*e,h=new y,m=new y;for(;o.next();){const l=o.getRedElement(),u=o.getBlueElement();if(i.queryXY(l,h),n.queryXY(u,m),y.sqrDistance(h,m)<=a)return!1}return!0}function Vy(r,t,e,s){return Om(r,t,e,!1,!1,!0)}function Qi(r,t,e,s){const i=F.constructEmpty(),n=F.constructEmpty();return r.queryEnvelope(i),t.queryEnvelope(n),!!me(i,n,e)&&Om(t,r,e,!0,!1,!1)}function b_(r,t,e,s){const i=F.constructEmpty(),n=F.constructEmpty();return r.queryEnvelope(i),t.queryEnvelope(n),ui(i,n,e)}function I_(r,t,e,s){return X_(r,t.getXY(),e)}function Yy(r,t,e,s){return b_(r,t,e)}function Xy(r,t,e,s){return!I_(r,t,e)}function Ry(r,t,e,s){const i=new F,n=new F;return r.queryEnvelope(i),t.queryEnvelope(n),!(n.height()>e||n.width()>e)&&ui(i,n,e)}function ky(r,t,e,s){const i=F.constructEmpty(),n=F.constructEmpty();if(r.queryEnvelope(i),t.queryEnvelope(n),me(n,i,e))return!1;const o=F.constructEmpty();o.setCoords({env2D:n}),o.inflateCoords(e,e);const a=new y;for(let h=0;h<r.getPointCount();h++)if(r.queryXY(h,a),o.contains(a))return!1;return!0}function Ly(r,t,e,s){const i=new F,n=new F,o=new F;if(t.queryEnvelope(i),i.height()<=e||i.width()<=e)return!1;n.setCoords({env2D:i}),o.setCoords({env2D:i}),n.inflateCoords(e,e),o.inflateCoords(-e,-e);const a=new y;let h=!1;for(let m=0;m<r.getPointCount();m++)if(r.queryXY(m,a),n.contains(a)){if(o.containsExclusive(a))return!1;h=!0}return h}function fc(r,t,e,s,i){const n=F.constructEmpty(),o=F.constructEmpty();if(r.queryEnvelope(n),t.queryEnvelope(o),o.height()<=e||o.width()<=e)return!1;if(s)return Ea(o,n,e);if(!me(o,n,e))return!1;let a=!1;const h=F.constructEmpty(),m=F.constructEmpty();h.setCoords({env2D:o}),m.setCoords({env2D:o}),h.inflateCoords(-e,-e),m.inflateCoords(e,e);const l=new y;for(let u=0;u<r.getPointCount();u++){if(r.queryXY(u,l),!m.contains(l))return!1;h.containsExclusive(l)&&(a=!0)}return a}function By(r,t,e,s){const i=new F,n=new F;if(r.queryEnvelope(i),t.queryEnvelope(n),me(n,i,e)||n.height()<=e||n.width()<=e)return!1;const o=new F,a=new F;o.setCoords({env2D:n}),o.inflateCoords(-e,-e),a.setCoords({env2D:n}),a.inflateCoords(e,e);const h=new y;let m=!1,l=!1;for(let u=0;u<r.getPointCount();u++)if(r.queryXY(u,h),!m&&o.containsExclusive(h)&&(m=!0),l||a.contains(h)||(l=!0),m&&l)return!0;return!1}function w_(r,t,e,s){return y.sqrDistance(r,t)<=e*e}function Hy(r,t,e,s){return y.sqrDistance(r,t)>e*e}function xc(r,t,e,s){return w_(r,t,e)}function zy(r,t,e,s){const i=new F;return i.setCoords({pt:r}),ui(i,t,e)}function Uy(r,t,e,s){if(t.height()<=e||t.width()<=e)return!1;const i=new F,n=new F;return i.setCoords({env2D:t}),i.inflateCoords(e,e),!!i.contains(r)&&(n.setCoords({env2D:t}),n.inflateCoords(-e,-e),!n.containsExclusive(r))}function Oy(r,t,e,s){if(t.height()<=e||t.width()<=e)return!1;const i=F.constructEmpty();return i.setCoords({env2D:t}),i.inflateCoords(-e,-e),i.containsExclusive(r)}function ui(r,t,e,s){return me(r,t,e)&&me(t,r,e)}function Wy(r,t,e,s){if(r.height()<=e||r.width()<=e||t.height()<=e||t.width()<=e)return!1;const i=new F;return i.setCoords({env2D:r}),i.inflateCoords(-e,-e),i.intersect(t),!(!i.isEmpty()&&i.height()>e&&i.width()>e)&&(i.setCoords({env2D:r}),i.inflateCoords(e,e),i.intersect(t),!i.isEmpty())}function $y(r,t,e,s){if(r.height()<=e||r.width()<=e||t.height()<=e||t.width()<=e||me(r,t,e)||me(t,r,e))return!1;const i=new F;return i.setCoords({env2D:r}),i.inflateCoords(-e,-e),i.intersect(t),!i.isEmpty()&&(i.height()>e||i.width()>e)}function ro(r,t,e,s,i){if(r.height()<=e||r.width()<=e)return!1;if(s)return Ea(r,t,e);if(!me(r,t,e))return!1;const n=F.constructEmpty();return n.setCoords({env2D:r}),n.inflateCoords(-e,-e),n.intersect(t),!n.isEmpty()}function Lr(r,t,e,s,i){const n=new y,o=new y,a=F.constructEmpty(),h=F.constructEmpty(),m=r.getImpl(),l=t.getImpl(),u=l.getGeometryType(),c=new os(m,l,e,!0);if(!c.next())return 1;if(A_(r,t,e))return s?4:0;const g=new ct;let _=r;const d=new ct;let p=null;u===T.enumPolygon&&(p=t);const f=u===T.enumPolygon?j(m.getPathCount(),!1):[],x=j(l.getPathCount(),!1);let E=!1,P=!1,C=!1,S=!1,I=!1,w=!1;do{if(C&&I||S&&w||C&&S)break;const D=c.getRedElement(),N=c.getBlueElement();if(!x[N]&&(o.assign(t.getXY(t.getPathStart(N))),a.setCoords({env2D:c.getRedEnvelope()}),a.inflateCoords(e,e),a.contains(o))){if(Ye(_,o,0)!==0){if(S=!0,s)return 4}else w=!0;x[N]=!0}if(u===T.enumPolygon&&!f[D]&&(n.assign(r.getXY(r.getPathStart(D))),h.setCoords({env2D:c.getBlueEnvelope()}),h.inflateCoords(e,e),h.contains(n))){if(Ye(p,n,0)!==0){if(C=!0,s)return 4}else I=!0;f[D]=!0}if(E||(!Ii(r,t.getPathCount()-1)||m.getAccelerators()!==null&&m.getAccelerators().getQuadTree()!==null?_=r:(r.copyTo(g),g.getImpl().buildQuadTreeAccelerator(1),_=g),E=!0),u===T.enumPolygon&&!P){const A=t;!Ii(A,r.getPathCount()-1)||l.getAccelerators()!==null&&l.getAccelerators().getQuadTree()!==null?p=t:(A.copyTo(d),d.getImpl().buildQuadTreeAccelerator(1),p=d),P=!0}}while(c.next());if(!C&&!S)return 1;if(!I||!w){if(u===T.enumPolygon){for(let D=0,N=m.getPathCount();D<N;D++)if(!f[D]){I=!0;break}}for(let D=0,N=l.getPathCount();D<N;D++)if(!x[D]){w=!0;break}}return C&&I||S&&w||C&&S?4:S?2:3}function jy(r,t,e,s,i){const n=F.constructEmpty();r.queryEnvelope(n),n.inflateCoords(e,e);const o=new y,a=r.getImpl(),h=new ct;let m=r,l=!1,u=!1,c=!1;for(let g=0;g<t.getPointCount();g++){if(t.queryXY(g,o),n.contains(o)){const _=Ye(m,o,e);if(_===1)return u=!0,4;if(_===2)return 4;c=!0}else c=!0;l||(!Ii(r,t.getPointCount()-1)||a.getAccelerators()!==null&&a.getAccelerators().getQuadTree()!=null?m=r:(r.copyTo(h),h.getImpl().buildQuadTreeAccelerator(1),m=h),l=!0)}return u?c?4:2:1}function D_(r,t,e,s,i){s[0]=!1;const n=r.getImpl(),o=t.getImpl(),a=n.querySegmentIterator(),h=o.querySegmentIterator(),m=[0,0],l=[0,0],u=new os(n,o,e);let c=!1;for(;u.next();){const g=u.getRedElement(),_=u.getBlueElement();a.resetToVertex(g,-1),h.resetToVertex(_,-1);const d=a.nextSegment(),p=h.nextSegment();let f=0;if(Yn(d,p)?!c&&p.isIntersecting(d,e)&&(c=!0):f=p.intersect(d,null,l,m,e),f!==0&&(c=!0,f===1)){const x=m[0],E=l[0];if(x>0&&x<1&&E>0&&E<1)return s[0]=!0,!1}}if(!c){s[0]=!0;const g=F.constructEmpty();r.queryEnvelope(g),g.inflateCoords(e,e);const _=new ct;let d=r,p=!1;for(let S=0,I=t.getPathCount();S<I;S++)if(t.getPathSize(S)>0){const w=F.constructEmpty();if(t.queryPathEnvelope(S,w),!g.isIntersecting(w))return!1;{const D=$o(d,t.getXY(t.getPathStart(S)),0);if(b(D!==-1),D===0)return!1}p||(!Ii(r,t.getPathCount()-1)||n.getAccelerators()!==null&&n.getAccelerators().getQuadTree()!==null?d=r:(r.copyTo(_),_.getImpl().buildQuadTreeAccelerator(1),d=_),p=!0)}if(r.getPathCount()===1||t.getGeometryType()===T.enumPolyline)return!0;const f=t,x=F.constructEmpty();f.queryEnvelope(x),x.inflateCoords(e,e);const E=new ct;let P=f,C=!1;for(let S=0,I=r.getPathCount();S<I;S++)if(r.getPathSize(S)>0){const w=F.constructEmpty();if(r.queryPathEnvelope(S,w),x.isIntersecting(w)){const D=$o(P,r.getXY(r.getPathStart(S)),0);if(b(D!==-1),D===1)return!1}C||(!Ii(f,r.getPathCount()-1)||o.getAccelerators()!==null&&o.getAccelerators().getQuadTree()!==null?P=f:(f.copyTo(E),E.getImpl().buildQuadTreeAccelerator(1),P=E),C=!0)}return!0}return!1}function me(r,t,e){const s=F.constructEmpty();return s.setCoords({env2D:r}),s.inflateCoords(e,e),s.containsEnvelope(t)}function Ea(r,t,e){const s=F.constructEmpty();return s.setCoords({env2D:t}),s.inflateCoords(e,e),r.containsExclusiveEnvelope(s)}function Dr(r,t,e){const s=F.constructEmpty();return s.setCoords({env2D:t}),s.inflateCoords(e,e),!s.contains(r.getLowerLeft())||!s.contains(r.getLowerRight())||!s.contains(r.getUpperLeft())||!s.contains(r.getUpperRight())}function T_(r,t,e,s){if(r.getPathCount()!==t.getPathCount()||r.getPointCount()!==t.getPointCount())return!1;if(r.hasNonLinearSegments()||t.hasNonLinearSegments())return r.equals(t);const i=new y,n=new y;let o=!0;const a=e*e;for(let h=0;h<r.getPathCount();h++){if(r.getPathEnd(h)!==t.getPathEnd(h)){o=!1;break}for(let m=r.getPathStart(h);m<t.getPathEnd(h);m++)if(r.queryXY(m,i),t.queryXY(m,n),y.sqrDistance(i,n)>a){o=!1;break}if(!o)break}return!!o}function Zy(r,t,e,s){if(r.getPointCount()!==t.getPointCount())return!1;const i=new y,n=new y;let o=!0;const a=e*e;for(let h=0;h<r.getPointCount();h++)if(r.queryXY(h,i),t.queryXY(h,n),y.sqrDistance(i,n)>a){o=!1;break}return!!o}function Om(r,t,e,s,i,n,o){const a=r.getImpl(),h=t.getImpl(),m=a.getPointCount(),l=h.getPointCount(),u=j(m,!1),c=i||n?j(l,!1):[],g=e*e,_=new os(a,h,e);for(;_.next();){const E=_.getRedElement(),P=_.getBlueElement(),C=a.getXY(E),S=h.getXY(P);y.sqrDistance(C,S)<=g&&(u[E]=!0,(i||n)&&(c[P]=!0))}let d=!1,p=!1;for(let E=0;E<m;E++){const P=u[E];if(d||=!P,p||=P,(i||s)&&d)return!1}if(s)return!0;let f=!1,x=!1;for(let E=0;E<l;E++){const P=c[E];if(f||=!P,x||=P,i&&f)return!1}return!!i||d&&p&&f&&x}function N_(r,t,e,s){return Vi(r,t,e,s)&&Vi(t,r,e,s)}function Vi(r,t,e,s){if(ir(r),ir(t),t.isEmpty())return!1;let i=!0;const n=j(2,Number.NaN),o=j(2,Number.NaN),a=[],h=new rP;let m;const l=F.constructEmpty(),u=F.constructEmpty(),c=F.constructEmpty();r.queryEnvelope(l),t.queryEnvelope(u),l.inflateCoords(e,e),u.inflateCoords(e,e),c.setCoords({env2D:l}),c.intersect(u);const g=r.getImpl().querySegmentIterator(),_=t.getImpl().querySegmentIterator(),d=t.getImpl().getAccelerators();let p=null,f=null,x=null,E=null;if(d!==null&&(p=d.getQuadTree(),f=d.getQuadTreeForPaths(),f!==null&&(E=f.getIteratorForQT())),p===null){const P=r.getPointCount(),C=t.getPointCount();P>10&&C>10&&(p=Pn(t.getImpl(),c))}for(p!==null&&(x=p.getIteratorForQT());g.nextPath();)for(;g.hasNextSegment();){let P=g.nextSegment();if(P.queryEnvelope(l),!l.isIntersecting(c))return i=!1,!1;if(E!==null&&(E.resetIterator(l,e),E.next()===-1))continue;let C=0,S=null;if(x!=null)x.resetIterator(P,e);else if(_.resetToFirstPath(),!_.nextPath())return i=!1,!1;do if(C=0,x!==null){const q=x.next();if(q===-1)return i=!1,!1;_.resetToVertex(p.getElement(q),-1),S=_.nextSegment(),C=P.intersect(S,null,n,o,e)}else{for(;!_.hasNextSegment();)if(!_.nextPath())return i=!1,!1;S=_.nextSegment(),S.queryEnvelope(u),u.inflateCoords(e,e),l.isIntersecting(u)&&(C=P.intersect(S,null,n,o,e))}while(C!==2||n[0]!==0||s&&!(o[0]<=o[1]));let I=Number.NaN,w=!1;do{let q=!1;if(n[1]===1){if(!g.hasNextSegment()){w=!0;break}P=g.nextSegment(),q=!0}if(o[1]===1&&o[0]<=o[1]){if(I===-1||(I=1,!_.hasNextSegment()))break;S=_.nextSegment(),q=!0}if(o[1]===0&&o[0]>o[1]){if(I===1)break;if(Number.isNaN(I)){if(!_.hasPreviousSegment())break;_.previousSegment(),I=-1}if(!_.hasPreviousSegment())break;S=_.previousSegment(),q=!0}if(!q)break;C=P.intersect(S,null,n,o,e)}while(C===2&&(!s||o[0]<=o[1]));if(w)continue;const D=P.calculateLength2D();P.queryEnvelope(l),a.length=0,h.m_overlapEvents.length=0;let N=!1,A=!1,M=0;const G=Di(null,l,!0);for(x!==null?x.resetIterator(P,e):(_.resetToFirstPath(),_.nextPath()||$("relational_operations"));;){if(C=0,x!==null){const q=x.next();if(q===-1)break;_.resetToVertex(p.getElement(q),-1),S=_.nextSegment(),C=P.intersect(S,null,n,o,e)}else{for(;!_.hasNextSegment()&&_.nextPath(););if(!_.hasNextSegment())break;S=_.nextSegment(),S.queryEnvelope(u),u.inflateCoords(e,e),l.isIntersecting(u)&&(C=P.intersect(S,null,n,o,e))}if(C===2&&(!s||o[0]<=o[1])){const q=g.getStartPointIndex(),V=g.getPathIndex(),k=_.getStartPointIndex(),Y=_.getPathIndex();if(m=nP(q,V,n[0],n[1],k,Y,o[0],o[1]),h.m_overlapEvents.push(m),a.push(a.length),!(N||m.m_scalarA0<M&&m.m_scalarA1<M)){if(M===0&&D*(m.m_scalarA0-M)>e)N=!0;else if(M!==0&&D*(m.m_scalarA0-M)>G)N=!0;else if(M=m.m_scalarA1,D*(1-M)<=e||M===1){A=!0;break}}}}if(!A){if(!N)return i=!1,!1;a.length>1&&a.sort((q,V)=>h.compareOverlapEvents(q,V)),M=0;for(let q=0;q<h.m_overlapEvents.length;q++)if(m=h.m_overlapEvents[a[q]],!(m.m_scalarA0<M&&m.m_scalarA1<M)){if(M===0&&D*(m.m_scalarA0-M)>e||M!==0&&D*(m.m_scalarA0-M)>G)return i=!1,!1;if(M=m.m_scalarA1,D*(1-M)<=e||M===1)break}if(D*(1-M)>e)return i=!1,!1;a.length=0,h.m_overlapEvents.length=0}}return i}function A_(r,t,e){const s=r.getImpl(),i=t.getImpl(),n=s.querySegmentIterator(),o=i.querySegmentIterator(),a=new os(s,i,e);for(;a.next();){const h=a.getRedElement(),m=a.getBlueElement();n.resetToVertex(h,-1),o.resetToVertex(m,-1);const l=n.nextSegment();if(o.nextSegment().isIntersecting(l,e))return!0}return!1}function Wm(r,t,e,s){const i=r.getImpl(),n=t.getImpl(),o=i.querySegmentIterator(),a=n.querySegmentIterator(),h=j(2,Number.NaN),m=new os(i,n,e);let l=!1,u=-1;for(;m.next();){const c=m.getRedElement(),g=m.getBlueElement();o.resetToVertex(c,-1),a.resetToVertex(g,-1);const _=o.nextSegment(),d=a.nextSegment();let p=0;if(Yn(_,d)){if(d.isIntersecting(_,e))return-2}else p=_.intersect(d,null,h,null,e);if(p){if(p===2){const f=_.calculateLength2D(),x=h[0];if(f*(h[1]-x)>e)return u=1,u;l=!0}else if(u=0,s){const f=h[0],x=new y;_.queryCoord2D(f,x),s.push(x.x),s.push(x.y)}}}return l?-2:u}function q_(r,t,e,s){const i=r.getImpl(),n=t,o=n.getPointCount(),a=s?j(o,!1):[],h=new os(i,n,e,!1),m=i.querySegmentIterator();for(;h.next();){const l=h.getRedElement(),u=h.getBlueElement();m.resetToVertex(l,-1);const c=m.nextSegment(),g=n.getXY(u);if(c.isIntersectingPoint(g,e)){if(!s)return!0;a[u]=!0}}if(!s)return!1;for(let l=0;l<o;l++)if(!a[l])return!1;return!0}function F_(r,t,e){const s=new y,i=e*e,n=r.querySegmentIterator(),o=r.getImpl().getAccelerators();if(o!==null){const h=o.getQuadTree();if(h!==null){const m=F.constructEmpty();m.setCoords({pt:t});const l=h.getIterator(m,e);for(let u=l.next();u!==-1;u=l.next())if(n.resetToVertex(h.getElement(u),-1),n.hasNextSegment()){const c=n.nextSegment(),g=c.getClosestCoordinate(t,!1);if(c.queryCoord2D(g,s),y.sqrDistance(t,s)<=i)return!0}return!1}}const a=F.constructEmpty();for(;n.nextPath();)for(;n.hasNextSegment();){const h=n.nextSegment();if(h.queryEnvelope(a),a.inflateCoords(e,e),!a.contains(t))continue;const m=h.getClosestCoordinate(t,!1);if(h.queryCoord2D(m,s),y.sqrDistance(t,s)<=i)return!0}return!1}function Qy(r,t,e){return F_(r,t,e)&&!R_(r,t,e)}function M_(r,t,e,s){const i=r.querySegmentIterator(),n=r.getImpl().getAccelerators(),o=r.hasNonLinearSegments();let a=null,h=null,m=null,l=null;if(n!==null){const u=n.getQuadTree();if(u!==null){const c=u.getIterator(t,e);o&&(a=new ht,h=new ht,m=new ht,l=new ht,t.querySide(0,a),t.querySide(1,h),t.querySide(2,m),t.querySide(3,l));const g=F.constructEmpty();g.setCoords({env2D:t}),g.inflateCoords(e,e);for(let _=c.next();_!==-1;_=c.next())if(i.resetToVertex(u.getElement(_),-1),i.hasNextSegment()){const d=i.nextSegment();if(d.getGeometryType()===T.enumLine){const p=d.getStartXY(),f=d.getEndXY();if(g.clipLine(p,f))return!0;continue}if(t.contains(d.getStartXY())||t.contains(d.getEndXY())||d.isIntersecting(a,e)||d.isIntersecting(h,e)||d.isIntersecting(m,e)||d.isIntersecting(l,e))return!0}return!1}}if(o){a=new ht,h=new ht,m=new ht,l=new ht,t.querySide(0,a),t.querySide(1,h),t.querySide(2,m),t.querySide(3,l);const u=r.querySegmentIterator();for(;u.nextPath();)for(;u.hasNextSegment();){const c=u.nextSegment();if(t.contains(c.getStartXY())||t.contains(c.getEndXY())||c.isIntersecting(a,e)||c.isIntersecting(h,e)||c.isIntersecting(m,e)||c.isIntersecting(l,e))return!0}}else{const u=F.constructEmpty();u.setCoords({env2D:t}),u.inflateCoords(e,e);const c=r.getImpl(),g=c.getAttributeStreamRef(0),_=new y;for(let d=0,p=c.getPathCount();d<p;d++){let f=!0;const x=new y,E=new y,P=new y,C=c.getPathStart(d),S=new y;for(let I=C,w=c.getPathEnd(d);I<w;I++)if(f)g.queryPoint2D(2*I,x),S.assign(x),f=!1;else{if(g.queryPoint2D(2*I,_),E.setCoordsPoint2D(x),P.setCoordsPoint2D(_),u.clipLine(E,P))return!0;x.assign(_)}if(c.isClosedPath(d)&&!f&&(E.setCoordsPoint2D(x),P.setCoordsPoint2D(S),u.clipLine(E,P)))return!0}}return!1}function G_(r,t,e,s){const i=r.getImpl(),n=t.getImpl(),o=[0],a=Ws(i.getIsSimple(0,o))&&Ws(n.getIsSimple(0,o)),h=i.querySegmentIterator(),m=n.querySegmentIterator(),l=j(2,0),u=j(2,0),c=new os(i,n,e);let g=!1;for(;c.next();){const E=c.getRedElement(),P=c.getBlueElement();h.resetToVertex(E,-1),m.resetToVertex(P,-1);const C=h.nextSegment(),S=m.nextSegment();let I=0;if(Yn(C,S)){if(S.isIntersecting(C,e)){g=!0;break}}else I=S.intersect(C,null,u,l,e);if(I===2){const w=l[0],D=l[1],N=C.calculateLength2D();if(a&&(D-w)*N>e)return!1;g=!0}else if(I){const w=l[0],D=u[0];if(w>0&&w<1&&D>0&&D<1)return!1;g=!0}}if(!g)return!1;const _=F.constructEmpty(),d=F.constructEmpty(),p=F.constructEmpty();let f,x;if(r.queryEnvelope(_),t.queryEnvelope(d),_.inflateCoords(1e3*e,1e3*e),d.inflateCoords(1e3*e,1e3*e),p.setCoords({env2D:_}),p.intersect(d),r.getPointCount()>10){if(f=Dt(r,p,e,0,s),f.isEmpty())return!1}else f=r;if(t.getPointCount()>10){if(x=Dt(t,p,e,0,s),x.isEmpty())return!1}else x=t;return fs(f,x,e,"F********",s,!1)}function V_(r,t,e,s){const i=r.getImpl(),n=t.getImpl(),o=[0],a=Ws(i.getIsSimple(0,o))&&Ws(n.getIsSimple(0,o)),h=F.constructEmpty(),m=F.constructEmpty(),l=F.constructEmpty();r.queryEnvelope(h),t.queryEnvelope(m);let u=!1;const c=Dr(h,m,e),g=Dr(m,h,e),_=i.querySegmentIterator(),d=n.querySegmentIterator(),p=j(2,Number.NaN),f=j(2,Number.NaN),x=new os(i,n,e);for(;x.next();){const w=x.getRedElement(),D=x.getBlueElement();_.resetToVertex(w,-1),d.resetToVertex(D,-1);const N=_.nextSegment(),A=d.nextSegment();let M=0;if(Yn(N,A)){if(A.isIntersecting(N,e))break}else M=A.intersect(N,null,f,p,e);if(M===2){const G=p[0],q=p[1],V=N.calculateLength2D();if(a&&(q-G)*V>e&&(u=!0,c&&g))return!0}else if(M){const G=p[0],q=f[0];if(G>0&&G<1&&q>0&&q<1)return!0}}const E=F.constructEmpty(),P=F.constructEmpty();let C,S;E.setCoords({env2D:h}),E.inflateCoords(1e3*e,1e3*e),P.setCoords({env2D:m}),P.inflateCoords(1e3*e,1e3*e),l.setCoords({env2D:E}),l.intersect(P);let I="";if(I+=u?"**":"T*",c){if(t.getPointCount()>10){if(S=Dt(t,l,e,0,s),S.isEmpty())return!1}else S=t;I+="****"}else S=t,I+="T***";if(g){if(r.getPointCount()>10){if(C=Dt(r,l,e,0,s),C.isEmpty())return!1}else C=r;I+="***"}else C=r,I+="T**";return fs(C,S,e,I,s,!1)}function Y_(r,t,e,s){const i=[!1],n=D_(r,t,e,i);if(i[0])return n;const o=F.constructEmpty();let a;if(t.queryEnvelope(o),o.inflateCoords(1e3*e,1e3*e),r.getPointCount()>10){if(a=Dt(r,o,e,0,s),a.isEmpty())return!1}else a=r;return Mx(a,t,e,s)}function Ky(r,t,e,s){const i=r.getImpl(),n=t.getImpl(),o=i.querySegmentIterator(),a=n.querySegmentIterator(),h=j(2,Number.NaN),m=j(2,Number.NaN),l=new os(i,n,e);let u=!1;for(;l.next();){const f=l.getRedElement(),x=l.getBlueElement();o.resetToVertex(f,-1),a.resetToVertex(x,-1);const E=o.nextSegment(),P=a.nextSegment();let C=0;if(Yn(E,P)?!u&&P.isIntersecting(E,e)&&(u=!0):C=P.intersect(E,null,m,h,e),C===2)u=!0;else if(C){const S=h[0],I=m[0];if(S>0&&S<1&&I>0&&I<1)return!1;u=!0}}if(!u)return!1;const c=F.constructEmpty(),g=F.constructEmpty(),_=F.constructEmpty();let d,p;if(r.queryEnvelope(c),t.queryEnvelope(g),c.inflateCoords(1e3*e,1e3*e),g.inflateCoords(1e3*e,1e3*e),_.setCoords({env2D:c}),_.intersect(g),r.getPointCount()>10){if(d=Dt(r,_,e,0,s),d.isEmpty())return!1}else d=r;if(t.getPointCount()>10){if(p=Dt(t,_,e,0,s),p.isEmpty())return!1}else p=t;return fs(d,p,e,"F********",s,!1)}function Jy(r,t,e,s){const i=r.getImpl(),n=t.getImpl(),o=i.querySegmentIterator(),a=n.querySegmentIterator(),h=j(2,Number.NaN),m=j(2,Number.NaN),l=new os(i,n,e);let u=!1;for(;l.next();){const f=l.getRedElement(),x=l.getBlueElement();o.resetToVertex(f,-1),a.resetToVertex(x,-1);const E=o.nextSegment(),P=a.nextSegment();let C=0;if(Yn(E,P)?!u&&P.isIntersecting(E,e)&&(u=!0):C=P.intersect(E,null,m,h,e),C===2)u=!0;else if(C){const S=h[0],I=m[0];if(S>0&&S<1&&I>0&&I<1)return!0;u=!0}}if(!u)return!1;const c=F.constructEmpty(),g=F.constructEmpty(),_=F.constructEmpty(),d=F.constructEmpty(),p=F.constructEmpty();if(r.queryEnvelope(c),t.queryEnvelope(g),Dr(g,c,e)){let f,x;if(_.setCoords({env2D:c}),_.inflateCoords(1e3*e,1e3*e),d.setCoords({env2D:g}),d.inflateCoords(1e3*e,1e3*e),p.setCoords({env2D:_}),p.intersect(d),r.getPointCount()>10){if(f=Dt(r,p,e,0,s),f.isEmpty())return!1}else f=r;if(t.getPointCount()>10){if(x=Dt(t,p,e,0,s),x.isEmpty())return!1}else x=t;return fs(f,x,e,"T********",s,!1)}return fs(r,t,e,"T*****T**",s,!1)}function tP(r,t,e,s){const i=[!1],n=D_(r,t,e,i);if(i[0])return n;const o=F.constructEmpty();let a;if(t.queryEnvelope(o),o.inflateCoords(1e3*e,1e3*e),r.getPointCount()>10){if(a=Dt(r,o,e,0,s),a.isEmpty())return!1}else a=r;return Gx(a,t,e,s)}function eP(r,t,e,s){return Ye(r,t,e)===1}function sP(r,t,e,s){return Ye(r,t,e)===2}function X_(r,t,e,s){const i=new y,n=e*e;for(let o=0;o<r.getPointCount();o++)if(r.queryXY(o,i),y.sqrDistance(i,t)<=n)return!1;return!0}function R_(r,t,e){const s=r.getBoundary();return!s.isEmpty()&&!X_(s,t,e)}function iP(r,t,e){const s=F.constructEmpty();return s.setCoords({env2D:r}),s.inflateCoords(e,e),s.containsEnvelope(t)?1073741824:s.isIntersecting(t)?r.isIntersecting(t)?r.xmin<t.xmin&&t.xmax<r.xmax?t.ymin<r.ymin&&t.ymax>r.ymax?0:1073741824:r.ymin<t.ymin&&t.ymax<r.ymax?t.xmin<r.xmin&&t.xmax>r.xmax?0:1073741824:0:0:4}function Yn(r,t){return r.getGeometryType()!==T.enumLine||t.getGeometryType()!==T.enumLine}function nP(r,t,e,s,i,n,o,a){return{m_ivertexA:r,m_ipathA:t,m_scalarA0:e,m_scalarA1:s,m_ivertexB:i,m_ipathB:n,m_scalarB0:o,m_scalarB1:a}}class rP{constructor(){this.m_overlapEvents=[]}compareOverlapEvents(t,e){const s=this.m_overlapEvents[t],i=this.m_overlapEvents[e];return s.m_ipathA<i.m_ipathA||s.m_ipathA===i.m_ipathA&&(s.m_ivertexA<i.m_ivertexA||s.m_ivertexA===i.m_ivertexA&&(s.m_scalarA0<i.m_scalarA0||s.m_scalarA0===i.m_scalarA0&&(s.m_scalarA1<i.m_scalarA1||s.m_scalarA1===i.m_scalarA1&&s.m_ivertexB<i.m_ivertexB)))?-1:1}}function k_(r,t,e){const s=Dx(r,t,e);return s?s===1?1:2:0}function Ye(r,t,e){const s=$o(r,t,e);return s?s===1?1:2:0}function oP(r,t,e,s,i){for(let n=0;n<e;n++)i[n]=Ye(r,t[n],s)}function $m(r,t,e,s,i){if(r.getGeometryType()===T.enumPolygon)oP(r,t,e,s,i);else if(r.getGeometryType()===T.enumEnvelope){const n=F.constructEmpty();r.queryEnvelope(n),aP(n,t,e,s,i)}else Yt("")}function L_(r,t,e,s,i){const n=r.getGeometryType();n===T.enumPolyline?uP(r,t,e,s,i):he(n)?lP():Yt("")}function aP(r,t,e,s,i){if(r.isEmpty()){for(let a=0;a<e;a++)i[a]=0;return}const n=r.clone();n.inflateCoords(.5*-s,.5*-s);const o=r.clone();o.inflateCoords(.5*s,.5*s);for(let a=0;a<e;a++)n.contains(t[a])?i[a]=1:o.contains(t[a])?i[a]=2:i[a]=0}function hP(r){if(r.isEmpty())return 0;switch(r.getGeometryType()){case T.enumMultiPoint:return r.getImpl().getPointCount();case T.enumPolyline:return r.getImpl().getPathCount();case T.enumPolygon:return r.getImpl().getOGCPolygonCount();case T.enumGeometryCollection:return r.getGeometryCount()}return 1}function mP(r,t,e){if(e.reset(),t<3)return;const s=r[0].clone(),i=s.x,n=s.y,o=r[1].clone(),a=new y;for(let h=2;h<t;h++)a.assign(r[h]),e.pe((a.x-s.x)*(o.y-n)),s.assign(o),o.assign(a);e.pe((i-s.x)*(o.y-n))}function lP(r,t,e,s,i){b(0)}function uP(r,t,e,s,i){const n=r.getImpl(),o=n.getAccelerators();let a=null;o&&(a=o.getRasterizedGeometry());let h=e;for(let m=0;m<e;m++)i[m]=1,a&&b(0);if(h){if(o){let l=null;o!==null&&o.getQuadTree()!==null&&(l=o.getQuadTree());const u=n.getPointCount();if(l===null&&u>20&&u*e>4*u+Math.log(u)*e&&(l=Pn(n)),l){let c=null;const g=n.querySegmentIterator(),_=new F;for(let d=0;d<e&&h;d++)if(i[d]===1){_.setCoords(t[d]),c===null?c=l.getIterator(_,s):c.resetIterator(_,s);let p=-1;for(let f=c.next();f!==-1;f=c.next()){if(g.resetToVertex(l.getElement(f),p),p=g.getPathIndex(),g.nextSegment().isIntersectingPoint(t[d],s)){i[d]=2,h--;break}i[d]=0}}return}}const m=n.querySegmentIterator();for(;m.nextPath()&&h;)for(;m.hasNextSegment()&&h;){const l=m.nextSegment();for(let u=0;u<e&&h;u++)i[u]===1&&l.isIntersectingPoint(t[u],s)&&(i[u]=2,h--)}}for(let m=0;m<e;m++)i[m]===1&&(i[m]=0)}function cP(r,t,e,s,i){const n=si(t),o=Math.max(4*n,e);return new Zo(t,null,o,Number.NaN,i).approximateWithCirclesImpl(r,s)}function gP(){return Number.isNaN(this.radius.value())}function _P(){return{ptStart:new y,ptEnd:new y,center:new K,radius:new L,fcenter:new Et,fradius2:new J,maxError:Number.NaN,isLine:gP}}const dP=5,pP=1/8;function zn(r,t,e,s){return{pt:r.clone(),t,err:e,checkCount:s}}class Zo{constructor(t,e,s,i,n){this.m_left=t,this.m_tracker=n,this.m_eps=s,this.m_trackerCounter=0,this.m_tolerance=i,this.m_circleCheckCounter=0,this.m_bReversedLeft=!1,this.m_leftArc=_P()}closeToCircularArc(t,e,s,i,n,o){if(this.m_circleCheckCounter++,o.maxError=0,!Zo.checkSweepAngle(t,e))return!1;if(o.ptStart.setCoordsPoint2D(s),o.ptEnd.setCoordsPoint2D(n),t.isCircular()){const C=t;return o.fradius2=J.constructDouble(C.getSemiMajorAxis()).mulDouble(C.getSemiMajorAxis()),o.radius.set(C.getSemiMajorAxis()),o.fcenter.assignPoint2D(C.getCenter()),o.center.set(C.getCenter()),!0}const a=o.ptEnd.sub(o.ptStart).clone();if(a.leftPerpendicularThis(),a.normalize(),Math.abs(a.dotProduct(i.sub(o.ptStart)))<=this.m_eps)return!!this.confirmIsLine(o,a)&&(o.radius.set(Number.NaN),o.center.setCoords(0,0),!0);{const C=o.ptEnd.sub(o.ptStart),S=i.sub(o.ptStart),I=C.crossProduct(S);if(I===0)return!1;const w=.5*C.sqrLength(),D=.5*S.sqrLength();let N=w*S.y-D*C.y;N/=I;let A=C.x*D-S.x*w;A/=I;const M=Math.sqrt(N*N+A*A);if(4*Number.EPSILON*M>this.m_eps)return!1;const G=N+o.ptStart.x,q=A+o.ptStart.y;o.radius.set(M),o.center.setCoords(G,q);const V=this.maxCircleApproximationError(t,e,o);if(V>this.m_eps)return o.maxError=V,!1}const h=new Et().assignPoint2D(o.ptStart),m=new Et().assignPoint2D(o.ptEnd).sub(h),l=new Et().assignPoint2D(i).sub(h),u=m.crossProduct(l);if(u.isZero())return!1;const c=m.sqrLength().mulDouble(.5),g=l.sqrLength().mulDouble(.5),_=c.mul(l.y).sub(g.mul(m.y)),d=m.x.mul(g).sub(l.x.mul(c)),p=_.mul(_).add(d.mul(d)),f=u.clone();f.invertThis(),o.fradius2=p.mul(f).mul(f),o.fcenter.setCoords(_.mul(f).add(h.x),d.mul(f).add(h.y)),o.center.setWithEps(o.fcenter.asPoint2D()),o.radius.setWithEps(Math.sqrt(o.fradius2.toDouble()));const x=K.constructPoint2D(o.ptStart).subE(o.center),E=K.constructPoint2D(o.ptEnd).subE(o.center);if(!x.dotProduct(E).gt(qn))return!1;const P=this.maxCircleApproximationError(t,e,o);return o.maxError=P,P<=this.m_eps}static checkSweepAngle(t,e){if(t.getGeometryType()===T.enumEllipticArc){const s=t,i=Ss(s,e.vmin),n=Ss(s,e.vmax);return!(Math.abs(n-i)>.5*dt)}return!0}confirmIsLine(t,e){const s=t.ptEnd.sub(t.ptStart);return!(Math.abs(e.dotProduct(s.mul(.25)))>this.m_eps)&&!(Math.abs(e.dotProduct(s.mul(.75)))>this.m_eps)}maxCircleApproximationError(t,e,s){const i=[.25,.75],n=[.1,.25,.75,.9];let o,a;t.getGeometryType()===T.enumEllipticArc?(o=i,a=i.length):(o=n,a=n.length);let h=0;for(let m=0;m<a;++m){const l=new y;t.queryCoord2D(Ct(e.vmin,e.vmax,o[m]),l);const u=l.sub(s.center.value()).length(),c=Math.abs(u-s.radius.value());c>h&&(h=c)}return h}approximateWithCirclesImpl(t,e){let s=1;e&&e.push(0);const i=j(9,Number.NaN);let n;t?n=this.m_left.getMonotonicPartParams(i.length,i):(i[0]=0,i[1]=1,n=2);const o=[],a=[],h=new y(0,0);for(let m=1;m<n;m++){const l=new z(i[m-1],i[m]);for(this.m_bReversedLeft=!Zo.goodOrientation(this.m_left,l),this.m_bReversedLeft?(o.push(zn(h,l.vmin,0,0)),o.push(zn(h,l.vmax,0,0))):(o.push(zn(h,l.vmax,0,0)),o.push(zn(h,l.vmin,0,0))),o[0].pt=this.m_left.getCoord2D(o[0].t),o[1].pt=this.m_left.getCoord2D(o[1].t);o.length>1;){this.progress_();const u=o.at(-1);let c=u.checkCount,g=u.err;const _=u.pt.clone(),d=u.t,p=o[o.length-2].t,f=.5*(d+p),x=this.m_left.getCoord2D(f);if(g<=this.m_eps||c>=dP){const E=new z;if(E.setCoords(d,p),this.closeToCircularArc(this.m_left,E,_,x,o[o.length-2].pt,this.m_leftArc)){e&&(this.m_bReversedLeft?a.push(d):e.push(p)),s++,o.pop();continue}c=0,g=this.m_leftArc.maxError}u.t=f,u.pt.setCoordsPoint2D(x),g*=pP,c++,u.err=g,u.checkCount=c,o.push(zn(_,d,g,c))}this.m_bReversedLeft&&e&&(e.length=e.length+a.length,ne(e,a.reverse(),e.length-a.length,0,a.length),a.length=0),o.length=0}return s}approximateWithCirclesImplPolyline(t){const e=new Pt,s=[];if(!this.approximateWithCirclesImpl(!0,s))return e;let i=0;const n=this.m_left.getStartXY();e.startPath(n);for(let o=1;o<s.length;++o)if(t)e.lineTo(this.m_left.getCoord2D(s[o]));else{const a=new y;this.m_left.queryCoord2D(s[o],a);const h=new y;this.m_left.queryCoord2D(.5*(s[o]+i),h);const m=new Xs;m.constructCircularArcThreePoint(n,a,h),e.addSegment(m,!1),n.assign(a),i=s[o]}return e}static goodOrientation(t,e){const s=t.getCoord2D(e.vmin),i=t.getCoord2D(e.vmax);return s.compare(i)<0}progress_(t=!1){}}function _s(r,t,e,s,i,n,o){xP(r,t,e,i,n,o),z_(r,e,o)}function fP(r,t,e,s){if(!lt(r.getGeometryType()))return r;const i=r.getImpl();if(!i.hasNonLinearSegments())return r;const n=r.createInstance();n.getGeometryType()===T.enumPolygon&&n.setFillRule(r.getFillRule()),new Lt;const o=new st,a=new it,h=[],m=[],l=[],u=r.getDescription().getAttributeCount()>1,c=i.querySegmentIterator();for(;c.nextPath();){let g=!0;for(;c.hasNextSegment();){const _=c.isClosingSegment(),d=c.nextSegment();if(!d.isCurve()){n.addSegment(d,g,_),g=!1;continue}let p,f=!1;const x=!0,E=!0;switch(d.getGeometryType()){case T.enumEllipticArc:case T.enumRationalBezier2:p=zo(d,t,e,x,E,m,l,h),f=!0;break;default:p=Xm(d,t,e,!0,x,m,h)}const P=f?2:3;m[1].isNAN()?(a.createLine(),a.get().construct(m[0],m[P])):f?(a.createQuadraticRationalBezier(),a.get().constructArrayWeights(m,l)):(a.createCubicBezier(),a.get().constructPoints(m)),u&&g&&(d.queryCoord(h[0],o),a.get().setStart(o)),u&&(d.queryCoord(h[1],o),a.get().setEnd(o)),n.addSegment(a.get(),g,_&&p===1),g=!1;for(let C=1,S=p,I=P;C<S;++C,I+=P)m[I+1].isNAN()?(a.createLine(),a.get().construct(m[I],m[I+P])):f?(a.createQuadraticRationalBezier(),a.get().constructArrayWeights(m.slice(I),l.slice(I))):(a.createCubicBezier(),a.get().constructPoints(m.slice(I))),u&&(d.queryCoord(h[C+1],o),a.get().setEnd(o)),n.addSegment(a.get(),!1,_&&C+1===S)}}return n}function xP(r,t,e,s,i,n){r.hasCurves()?(r.setCurveStitcherPointer(s),s.m_impl=new Yi(n,!1,null),s.m_impl.buildMonotonicCurveParentage(r,t,e,i)):s.m_impl=null}function B_(r,t,e,s,i,n,o,a){r.hasCurves()?(r.setCurveStitcherPointer(n),n.m_impl=new Yi(a,!0,i),n.m_impl.buildMonotonicCurveParentage(r,t,e,o),z_(r,e,a)):n.m_impl=null}function H_(r){if(!r.hasSegmentParentage())return;const t=r.queryVertexIteratorOnSelection();for(let e=t.next();e!==v;e=t.next())if(!r.getSegmentParentageBreakVertex(e)){r.getPathFromVertex(e);const s=r.getPrevVertex(e),i=s!==v?r.getSegmentParentage(s):-1,n=r.getSegmentParentage(e);n!==-1&&i!==-1&&n!==i&&r.setSegmentParentageBreakVertex(e,!0)}}function yP(r){if(!r.hasSegmentParentage())return;H_(r);const t=new Xt(0),e=r.queryVertexIteratorOnSelection();for(let o=e.next();o!==v;o=e.next())t.add(o);if(t.size()===0)return;r.sortVerticesSimpleByY(t,0,t.size()),t.add(v);const s=y.getNAN();r.queryXY(t.read(0),s);let i=0;const n=y.getNAN();for(let o=1,a=t.size();o<a;o++){{const h=t.read(o);h!==v?r.queryXY(h,n):n.setNAN()}if(!n.isEqualPoint2D(s)){if(o-i>1){let h=!1;for(let m=i;m<o;++m){const l=t.read(m);if(r.getSegmentParentageBreakVertex(l)){h=!0;break}}if(!h){const m=(c,g,_)=>{const d=r.getPrevVertex(c),p=r.getNextVertex(c);d!==v?g.assign(r.getXY(d)):g.setNAN(),p!==v?_.assign(r.getXY(p)):_.setNAN()},l=new y,u=new y;m(t.read(i),l,u);for(let c=i+1;c<o;++c){const g=t.read(c);if(g===v)continue;const _=new y,d=new y;m(g,_,d);const p=(f,x)=>!!(f.equals(x)||f.isNAN()&&x.isNAN());if(!(p(_,l)&&p(d,u)||p(d,l)&&p(_,u))){h=!0;break}}}if(h)for(let m=i;m<o;++m)r.setSegmentParentageBreakVertex(t.read(m),!0)}s.setCoordsPoint2D(n),i=o}}}function PP(r,t){let e=t.isEmpty()?r:re(null,t,!0).total();return e>r&&(e=r),.125*e}function Je(r,t){return t||(t=F.constructEmpty()),PP(r,t)}function Fs(r,t){return .125*r}function Ms(r,t){return 3*r+3*t}class ts{constructor(){this.m_impl=null}stitchCurves(t,e,s,i){this.m_impl&&(this.m_impl.stitchCurves(t,e,s),i&&this.clearStitcher(t))}clearStitcher(t){this.m_impl&&(this.m_impl.clearStitcher(t),this.m_impl=null)}getOriginalVertexIndex(t,e){return this.m_impl.getOriginalVertexIndex(t,e)}getOriginalSegmentTypeInfo(t){return this.m_impl.getOriginalSegmentTypeInfo(t)}}class Yi{constructor(t,e,s){this.m_originalPlanarSegments=[],this.m_progressTracker=null,this.m_nsr=null,this.m_progressTracker=t,this.m_nsr=s,this.m_tolerance=0,this.m_originalVertexIndex=-1,this.m_type=1,this.m_progressCounter=0,this.m_bIsSimple=e,this.m_densificationDeviation=NaN,this.m_maxSegmentsPerCurve=-1}buildMonotonicCurveParentage(t,e,s,i){if(!t.hasCurves())return;b(!t.hasSegmentParentage()),this.m_originalPlanarSegments.length=0,this.m_bIsSimple&&(this.m_originalVertexIndex=t.createUserIndex()),this.m_tolerance=s;const a=new st,h=new it,m=[],l=[],u=[];for(let c=t.getFirstGeometry();c!==v;c=t.getNextGeometry(c))for(let g=t.getFirstPath(c);g!==v;g=t.getNextPath(g)){let _=t.getPathSize(g),d=t.getFirstVertex(g),p=0,f=-1;for(let x=0;x<_;x++){let E=t.getNextVertex(d);if(!t.querySegment(d,h,!0,!1)){d=E;continue}if(p===0){f=t.getVertexIndex(d);const D=Yi.regularizeCurve(t,h.get(),d,s);if(D>=0){this.m_nsr&&this.m_nsr.m_reason===0&&this.m_nsr.assign(new Tt(13,f,-1)),p=D,_=t.getPathSize(g),E=t.getNextVertex(d);const N=t.querySegment(d,h,!0,!1);b(N)}}else p--;const P=t.getVertexIndex(d);let C;this.m_originalVertexIndex!==-1&&t.setUserIndex(d,this.m_originalVertexIndex,f),t.setSegmentToIndex(P,null);let S=!1;switch(h.get().getGeometryType()){case T.enumEllipticArc:case T.enumRationalBezier2:C=zo(h.get(),e,s,!1,!0,l,u,m),S=!0;break;default:{const D=!this.m_bIsSimple||!h.get().isMonotoneQuickAndDirty();C=Xm(h.get(),e,s,D,!1,l,m)}}const I=this.m_originalPlanarSegments.length;if(t.setSegmentParentageAndBreak(d,I,!0),!l[1].isNAN()){let D=null;D=S?new Ge({points:l,weights:u}):new ws({cp:l}),D.snapControlPoints(s*s),t.setSegmentToIndex(P,D)}const w=S?2:3;for(let D=1,N=C,A=w;D<N;++D,A+=w){h.get().queryCoord(m[D],a);const M=t.insertVertex(g,E,a);if(this.m_originalVertexIndex!==-1&&t.setUserIndex(M,this.m_originalVertexIndex,f),!l[A+1].isNAN())if(S){const G=new Ge({points:l.slice(A),weights:u.slice(A)});G.snapControlPoints(s*s),t.setSegmentToIndex(t.getVertexIndex(M),G)}else{const G=new ws({cp:l.slice(A)});G.snapControlPoints(s*s),t.setSegmentToIndex(t.getVertexIndex(M),G)}t.setSegmentParentageAndBreak(M,I,!1)}C>1&&(x+=C-1,_=t.getPathSize(g)),this.m_originalPlanarSegments.push(h.releaseSegment()),d=E}}}buildLinearSegmentParentage(t,e,s,i,n){if(this.m_type=0,this.m_densificationDeviation=e,this.m_maxSegmentsPerCurve=i,!t.hasCurves())return;b(!t.hasSegmentParentage()),this.m_tolerance=s,this.m_originalPlanarSegments=[],this.m_bIsSimple&&(this.m_originalVertexIndex=t.createUserIndex());const o=new st,a=new it,h=new Rm(0,e,0,this.m_progressTracker,!1,i),m=[];for(let l=t.getFirstGeometry();l!==v;l=t.getNextGeometry(l))for(let u=t.getFirstPath(l);u!==v;u=t.getNextPath(u)){let c=t.getPathSize(u),g=t.getFirstVertex(u);for(let _=0;_<c;_++){let d=t.getNextVertex(g);if(!t.querySegment(g,a,!0,!1)){g=d;continue}if(Yi.regularizeCurve(t,a.get(),g,s)>=0){c=t.getPathSize(u),d=t.getNextVertex(g);const x=t.querySegment(g,a,!0,!1);b(x)}const p=t.getVertexIndex(g);this.m_originalVertexIndex!==-1&&t.setUserIndex(g,this.m_originalVertexIndex,p),t.setSegmentToIndex(p,null),m.length=0,h.densifySegment(a.get(),m),this.progress_();const f=this.m_originalPlanarSegments.length;t.setSegmentParentageAndBreak(g,f,!0);for(let x=1,E=m.length-1;x<E;++x){a.get().queryCoord(m[x],o);const P=t.insertVertex(u,d,o);t.setSegmentParentageAndBreak(P,f,!1),this.m_originalVertexIndex!==-1&&t.setUserIndex(P,this.m_originalVertexIndex,p)}this.m_originalPlanarSegments.push(a.releaseSegment()),g=d}}t.clearSegments()}stitchCurves(t,e,s){Yi.st_stitchCurvesImpl(this,t,e,s,!1)}clearStitcher(t){this.m_originalPlanarSegments.length=0,this.m_originalVertexIndex!==-1&&(t.removeUserIndex(this.m_originalVertexIndex),this.m_originalVertexIndex=-1),t.deleteSegmentParentage()}static st_verifyParentage(t){Yi.st_stitchCurvesImpl(null,t,v,0,!0)}getOriginalVertexIndex(t,e){return this.m_originalVertexIndex!==-1&&e!==v?t.getUserIndex(e,this.m_originalVertexIndex):-1}getOriginalSegmentTypeInfo(t){if(t!==-1){const e=this.m_originalPlanarSegments[t];switch(e.getGeometryType()){case T.enumEllipticArc:return e.projectionBehavior()===0?0:1;case T.enumBezier:return 2;case T.enumBezier2:return 3;case T.enumLine:return-1;case T.enumRationalBezier2:return 4;default:ft("")}}return-1}progress_(t=!1){this.m_progressCounter++}processSpanSmartTe_(t,e,s,i,n,o,a){if(e===s&&i===0)return b(t.getNextVertex(e)===v),t.setSegmentToIndex(t.getVertexIndex(e),null),void t.setSegmentParentageAndBreak(e,-1);const h=t.getNextVertex(e),m=t.getXY(e),l=t.getXY(s);let u,c=0;{let I=2,w=m;for(let D=h;D!==s;D=t.getNextVertex(D)){const N=t.getXY(D);c+=y.distance(N,w),w=N,I++}c+=y.distance(l,w),b(I===i)}if(n===null)return t.setSegmentToIndex(t.getVertexIndex(e),null),void t.removeVertices(h,s);const g=a;let _=n.getClosestCoordinate(m,!1),d=n.getClosestCoordinate(l,!1);const p=n.calculateLength2D();let f=n.tToLength(_),x=n.tToLength(d);const E=Math.abs(f)>10*g&&Math.abs(f-p)>10*g,P=Math.abs(x)>10*g&&Math.abs(x-p)>10*g,C=I=>{const w=I.calculateLength2D();return Math.abs(w-c)>Math.max(.2*c,4*g)?null:I};let S=n.isClosed();if(!S){const I=y.distance(n.getStartXY(),n.getEndXY());I<=g&&p>5*I&&(S=!0)}if(S){let I,w,D=new y;if(i===2)D=y.lerp(m,l,.5),I=n.getClosestCoordinate(D,!1),w=n.tToLength(I);else{let M=t.getNextNthVertex(e,(i-1)/2);D=t.getXY(M),I=n.getClosestCoordinate(D,!1),w=n.tToLength(I);let G=Math.abs(w)>10*g&&Math.abs(w-p)>10*g;if(!G&&(i-1>=4&&(M=t.getNextNthVertex(e,(i-1)/4),I=n.getClosestCoordinate(D,!1),w=n.tToLength(I),G=Math.abs(w)>10*g&&Math.abs(w-p)>10*g),!G))return}let N=!1;const A=f===x;if(A){let G=2,q=4;i-1<=4&&(G=1,q=2);const V=m,k=t.getXY(t.getNextNthVertex(e,G)),Y=t.getXY(t.getNextNthVertex(e,q));N=-y.orientationNonRobust(V,k,Y)*kt(n.calculateArea2DHelper())>0}else P?E?N=w>f:w<x?(f=0,_=0):(f=p,_=1):w>f?(x=p,d=1):(x=0,d=0);if(A)u=n.clone(),u.dropAllAttributes(),N||u.reverse(),b(m.equals(l));else{let M=!1;_>d&&(M=!0,[_,d]=[d,_]),u=n.cut(_,d,!0),u.getDescription().getAttributeCount(),M&&u.reverse()}u.setCoordsForIntersector(m,l,!1),u=C(u),u&&(this.removeSpanBetween(t,e,s),t.setSegmentToIndex(t.getVertexIndex(e),u))}else if(E||P){if((!E||!P)&&y.distance(n.getStartXY(),n.getEndXY())<10*g){const w=[te(_,d),te(_,d),te(_,d)];E?(w[1].second=0,w[2].second=1):(w[1].first=1,w[2].first=0);const D=[null,null,null],N=[0,0,0];let A=Number.MAX_VALUE,M=0;for(let G=0;G<3;G++){let q=!1;if(w[G].first>w[G].second){q=!0;const k=w[G].first;w[G].first=w[G].second,w[G].second=k}D[G]=n.cut(w[G].first,w[G].second,!0),D[G].dropAllAttributes(),q&&D[G].reverse(),D[G].setCoordsForIntersector(m,l,!1),N[G]=D[G].calculateLength2D();const V=Math.abs(c-N[G]);V<A&&(A=V,M=G)}return u=D[M],u=C(u),void(u&&(this.removeSpanBetween(t,e,s),t.setSegmentToIndex(t.getVertexIndex(e),u)))}let I=!1;_>d&&(I=!0,[_,d]=[d,_]),u=n.cut(_,d,!0),u.dropAllAttributes(),I&&u.reverse(),u.setCoordsForIntersector(m,l,!1),u=C(u),u&&(this.removeSpanBetween(t,e,s),t.setSegmentToIndex(t.getVertexIndex(e),u))}else{if(u=n.clone(),u.dropAllAttributes(),f>x&&u.reverse(),c<Math.max(.75*p,p-this.m_densificationDeviation*(i-1))){const I=_>d?d:_,w=u.tToLength(I)+c;let D=u.lengthToT(w);D=Nt(D,I,1),u=u.cut(I,D,!0)}u.setCoordsForIntersector(m,l,!1),u=C(u),u&&(this.removeSpanBetween(t,e,s),t.setSegmentToIndex(t.getVertexIndex(e),u))}}processSpanCurves_(t,e,s,i,n,o,a){if(e===s&&i===0)return b(t.getNextVertex(e)===v),t.setSegmentToIndex(t.getVertexIndex(e),null),void t.setSegmentParentageAndBreak(e,-1);const h=t.getNextVertex(e);{let u=2;for(let c=h;c!==s;c=t.getNextVertex(c))u++;b(u===i)}if(n===null)return t.setSegmentToIndex(t.getVertexIndex(e),null),void t.removeVertices(h,s);const m=t.getXY(e),l=t.getXY(s);if(n.isClosed()){if(m.isEqualPoint2D(l)&&m.isEqualPoint2D(n.getStartXY())){let u;if(u=this.verifySegmentFitnessCurves(t,e,s,i,n,o,a)){const c=n.clone();return c.dropAllAttributes(),u<0&&c.reverse(),this.removeSpanBetween(t,e,s),void t.setSegmentToIndex(t.getVertexIndex(e),c)}}}else if(m.isEqualPoint2D(n.getStartXY())){if(l.isEqualPoint2D(n.getEndXY())){const u=n.clone();u.dropAllAttributes();const c=this.verifySegmentFitnessCurves(t,e,s,i,u,o,a);if(c)return b(c>0),this.removeSpanBetween(t,e,s),void t.setSegmentToIndex(t.getVertexIndex(e),u)}}else if(l.isEqualPoint2D(n.getStartXY())&&m.isEqualPoint2D(n.getEndXY())){const u=n.getReversed();u.dropAllAttributes();const c=this.verifySegmentFitnessCurves(t,e,s,i,u,o,a);if(c)return b(c>0),this.removeSpanBetween(t,e,s),void t.setSegmentToIndex(t.getVertexIndex(e),u)}this.processSpanSplitSegmentCurves(t,e,s,i,n,o,a)}processSpan_(t,e,s,i,n,o,a){return this.m_type===0?void this.processSpanSmartTe_(t,e,s,i,n,o,a):void this.processSpanCurves_(t,e,s,i,n,o,a)}processSpanSplitSegmentCurves(t,e,s,i,n,o,a){if(n.isLine()||this.fitSegmentToSpanCurves(t,e,s,i,n,o,a))return;const h=a*a;let m=i,l=e;const u=t.getXY(e);let c=n.getClosestCoordinate(u,!1);const g=n.getCoord2D(c);let _=!1;const d=y.sqrDistance(u,g);if(d>h){const I=t.getNextVertex(e);if(this.approximateSpanSectionCurves(t,e,n,o,a),I===s)return;l=I,_=!0,m-=1}let p=s;const f=t.getXY(s);c=n.getClosestCoordinate(f,!1);const x=n.getCoord2D(c);let E=!1;const P=y.sqrDistance(f,x);if(P>h){const I=t.getPrevVertex(s);if(this.approximateSpanSectionCurves(t,I,n,o,a),I===l)return;p=I,E=!0,m-=1}if((_||E)&&this.fitSegmentToSpanCurves(t,l,p,m,n,o,a))return;let C=!1;if(!_&&d>0){const I=t.getNextVertex(e);if(this.approximateSpanSectionCurves(t,e,n,o,a),I===p)return;l=I,_=!0,C=!0,m-=1}if(!E&&P>0){const I=t.getPrevVertex(s);if(this.approximateSpanSectionCurves(t,I,n,o,a),I===l)return;p=I,E=!0,C=!0,m-=1}if(C&&this.fitSegmentToSpanCurves(t,l,p,m,n,o,a))return;let S=l;for(;;){const I=t.getNextVertex(S);if(this.approximateSpanSectionCurves(t,S,n,o,a),S=I,S===p)return}}fitSegmentToSpanCurves(t,e,s,i,n,o,a){const h=[];h.push(t.getXY(e));let m=e;const l=new it;for(;;){t.querySegment(m,l,!1,!0);const g=[.1,.25,.4,.5,.6,.75,.9,1];let _=0;for(const d of g)(i===2||1&_)&&h.push(l.get().getCoord2D(d)),_++;if(m=t.getNextVertex(m),m===s)break}const u=(()=>{let g=h[0].compare(h.at(-1));if(g===0){const _=new Ce(0);mP(h,h.length,_),g=_.getResult()>=0?-1:1}return g>0})();u&&h.reverse();const c=n.clone();if(c.dropAllAttributes(),u&&c.reverse(),c.setSegmentFromCoordsForStitcher(h,h.length),u&&c.reverse(),c.snapControlPoints(this.m_tolerance*this.m_tolerance),this.verifySegmentFitnessCurves(t,e,s,i,c,o,a)){this.removeSpanBetween(t,e,s);const g=t.getVertexIndex(e);return t.setSegmentToIndex(g,c),!0}return!1}approximateSpanSectionCurves(t,e,s,i,n){const o=new it;if(!t.querySegment(e,o,!0,!1))return;const a=s.getGeometryType();if(a!==o.get().getGeometryType()){if(a===T.enumEllipticArc){if(o.get().getGeometryType()!==T.enumRationalBezier2)return;if(s.projectionBehavior()===0){const h=[];cP(!1,o.get(),n,h,this.m_progressTracker);const m=t.getNextVertex(e),l=t.getPathFromVertex(e),u=new st;let c=e;for(let g=1,_=h.length;g<_;g++){const d=h[g],p=o.get().getCoord2D(h[g-1]),f=o.get().getCoord2D(Ct(h[g-1],d,.5));o.get().queryCoord(d,u);const x=u.getXY(),E=new Xs;E.constructCircularArcThreePoint(p,x,f);let P=v;d<1&&(P=t.insertVertex(l,m,u)),t.setSegmentToIndex(t.getVertexIndex(c),E),c=P}return}{const h=R(y,3);o.get().queryControlPoints(h);const m=[0,0,0];o.get().queryWeights(m);const l=Ds(m),u=new Xs;return b1(h,l*l,null,!1,u),void t.setSegmentToIndex(t.getVertexIndex(e),u)}}$("approximate_span_section_")}}verifySegmentFitnessCurves(t,e,s,i,n,o,a){const h=t.getXY(e),m=t.getXY(s);if(!h.isEqualPoint2D(n.getStartXY())||!m.isEqualPoint2D(n.getEndXY()))return 0;let l=0;if(n.isClosed()){const x=n.getCoord2D(.1).sub(h);l=n.getCoord2D(.7).sub(h).crossProduct(x)>=0?1:-1}const u=j(Xr.s_maxMonotonicPartParams,Number.NaN);let c=n.getMonotonicPartParams(u.length,u);c--;const g=new ht,_=[1,.5,.75,.25];let d=0,p=e;const f=h.clone();for(;;){const x=t.getNextVertex(p);let E=t.getSegment(p);E===null&&(t.queryLineConnector(p,g,!0),E=g);for(let P=x===s?1:0;P<_.length;P++){const C=E.getCoord2D(_[P]);if(!n.isCloserThanDistance(C,z.unit(),a))return 0}if(c>1)for(let P=1;P<c;){const C=n.getCoord2D(u[P]);E.isCloserThanDistance(C,z.unit(),a)?(u[c-1]=O(u[P],u[P]=u[c-1]),c--):P++}if(l){const P=E.getCoord2D(.25);d+=P.sub(h).crossProduct(f.sub(h)),f.assign(P),P.assign(E.getCoord2D(.75)),d+=P.sub(h).crossProduct(f.sub(h)),f.assign(P)}if(p=x,p===s)return c>1?0:l?d<0?-l:l:1}}removeSpanBetween(t,e,s){t.setSegmentToIndex(t.getVertexIndex(e),null);const i=t.getNextVertex(e);i!==s&&t.removeVertices(i,s)}static st_stitchCurvesImpl(t,e,s,i,n){if(!e.hasSegmentParentage())return;H_(e);let o=s===v?e.getFirstGeometry():s;for(;o!==v;)if(Pl(e.getGeometryType(o))){for(let a=e.getFirstPath(o);a!==v;a=e.getNextPath(a)){let h=e.getPathSize(a);const m=e.isClosedPath(a);m&&(h+=1);let l=e.getFirstVertex(a);const u=e.getSegmentParentage(l);if(m){if(u!==-1&&!e.getSegmentParentageBreakVertex(l)){let g=e.getPrevVertex(l);const _=l;for(let d=0;;d++){const p=e.getSegmentParentage(g);if(u!==p){b(p===-1);break}if(l=g,e.getSegmentParentageBreakVertex(g))break;if(g===_){l=_,e.setSegmentParentageBreakVertex(l,!0);break}g=e.getPrevVertex(g),b(d<h)}}}else b(u===-1||e.getSegmentParentageBreakVertex(l));let c=l;for(let g=0;g<h&&c!==v;){const _=e.getSegmentParentage(c);if(_===-1){if(g++,c=e.getNextVertex(c),c===l)break;continue}let d=0,p=v;const f=c;d=1;let x=e.getNextVertex(f);for(;g<h&&x!==v;){g++,p=x,d++;const E=e.getSegmentParentage(x);if(E===-1||e.getSegmentParentageBreakVertex(x))break;b(E===_),x=e.getNextVertex(x)}if(p===v){b(0);break}if(!n){const E=t.m_originalPlanarSegments[_];t.processSpan_(e,f,p,d,E,_,i)}if(c=p,c===l)break}}if(s!==v)break;o=e.getNextGeometry(o)}else o=s===v?e.getNextGeometry(o):v}static st_stitchCurvesFromLinesImpl(t,e,s,i,n){let o=s===v?e.getFirstGeometry():s;for(;o!==v;){for(let a=e.getFirstPath(o);a!==v;a=e.getNextPath(a)){let h=e.getPathSize(a);e.isClosedPath(a)&&(h+=1);let m=!0,l=!1;const u=e.getFirstVertex(a);let c=u;for(let g=0;g<h&&c!==v;){let _=e.getSegmentParentage(c);if(_===-1||m){m=!1,g++,c=e.getNextVertex(c),l=!0;continue}let d,p,f=0;if(l?(d=e.getPrevVertex(c),p=c,b(d!==v),b(p!==d),b(e.getSegmentParentage(d)===-1||u===d)):(d=c,p=e.getNextVertex(d),g++,b(p!==v),b(p!==d),_=e.getSegmentParentage(p)),f=2,l=!1,_===-1||e.getSegmentParentageBreakVertex(p)){c=p;continue}let x=e.getNextVertex(p);for(g++;g<h&&x!==v;){p=x,f++;const E=e.getSegmentParentage(x);if(E===-1||e.getSegmentParentageBreakVertex(x))break;b(E===_),g++,x=e.getNextVertex(x)}if(!n){const E=t.m_originalPlanarSegments[_];t.processSpan_(e,d,p,f,E,_,i)}c=p}}if(s!==v)break;o=e.getNextGeometry(o)}}static st_stitchCurvesFromCurvesImpl(t,e,s,i,n){let o=s===v?e.getFirstGeometry():s;for(;o!==v;)if(Pl(e.getGeometryType(o))){for(let a=e.getFirstPath(o);a!==v;a=e.getNextPath(a)){let h=e.getPathSize(a);const m=e.isClosedPath(a);m&&(h+=1);let l=e.getFirstVertex(a);if(m){if(e.getSegmentParentage(l)!==-1){let c=l;for(let g=0;!e.getSegmentParentageBreakVertex(c);g++){if(g===h){l=e.getFirstVertex(a),e.setSegmentParentageBreakVertex(c,!0);break}c=e.getPrevVertex(c)}}}else b(e.getSegmentParentage(l)===-1||e.getSegmentParentageBreakVertex(l));let u=l;for(let c=0;c<h&&u!==v;){const g=e.getSegmentParentage(u);if(g===-1){c++,u=e.getNextVertex(u);continue}let _=0,d=v;const p=u;_=1;let f=e.getNextVertex(p);for(;c<h&&f!==v;){c++,d=f,_++;const x=e.getSegmentParentage(f);if(x===-1||e.getSegmentParentageBreakVertex(f))break;b(x===g),f=e.getNextVertex(f)}if(d===v)break;if(!n){const x=t.m_originalPlanarSegments[g];t.processSpan_(e,p,d,_,x,g,i)}u=d}}if(s!==v)break;o=e.getNextGeometry(o)}else o=s===v?e.getNextGeometry(o):v}static regularizeCurve(t,e,s,i){let n=e.snapControlPoints(i*i);if(n){const o=t.getVertexIndex(s),a=e.clone();t.setSegmentToIndex(o,a)}if(e.getGeometryType()===ws.type){const o=[],a=e.calculateSpecialPointsForCracking(i,o);if(a>0){const h=[];if(a>1){for(let m=0;m<a;m++)if(h.push(e.getCoord2D(o[m])),m>0){const l=(Math.abs(h[m].x)+Math.abs(h[m].y))*ma(),u=y.distance(h[m-1],h[m]);if(u<l&&u>0){const c=new y;Qt(h[m-1],h[m],.5,c),h[m-1]=c,h[m]=c}}}t.splitSegment(s,o,a),n=t.snapControlPoints(s,a+1,i*i)||n;for(let m=0;m<a;m++)s=t.getNextVertex(s),t.setSegmentParentageBreakVertex(s,!0);return a}}return n?0:-1}}function Ns(r,t,e,s,i){return new Sa(r,e,t,s,i).do_()}function CP(r,t,e){const s=ss(r);return zm(t.getX(),t.getY(),e.getX(),e.getY(),yt(s))}function EP(r,t,e=1,s=1,i=1,n=1){if(s>n)return r;if(n>s)return t;const o=[0],a=[0],h=new st;return cx(r,t,e,s,i,n,h,a,o),h}function SP(r,t,e){const s=ss(t),i=vm(t);return!!gx(r,s,v,null,e)||Um(!0,r,i,null,e)}function z_(r,t,e){return Sa.fixCurveTwoPointLoops(r,t,e)}function U_(r){return ss(r)}class Sa{constructor(t,e,s,i,n){this.m_shape=t,this.m_progressTracker=e,this.m_tolerance=s,this.m_bFilterDegenerateSegments=i,this.m_bTrackChanges=n,this.m_progressCounter=0}do_(){const t=new Ve(this.m_tolerance.tolerance,this.m_tolerance.resolution),e=1e-5,s=1e-6,i=U_(t);let n=vm(t);const o=n*(1+e);n*=1+s;let a=!1;const h=this.m_shape.getTotalPointCount()+10>30?1e3:(this.m_shape.getTotalPointCount()+10)*(this.m_shape.getTotalPointCount()+10),m=this.m_shape.hasPointFeatures();for(let l=0;;l++){this.m_shape.dbgCheckSelection(),l>h&&$("crack_and_cluster_iteration_exceeded"),this.m_shape.dbgVerifyMonotone();let u=-1;l===0&&(u=this.firstCrack_(),a||=u>0);const c=this.cluster_(i);if(this.m_shape.dbgVerifyMonotone(),a||=c,this.m_bFilterDegenerateSegments){const d=this.m_shape.filterClosePoints(i,!0,!1,this.m_bTrackChanges,v)!==0;a||=d,this.m_shape.dbgVerifyMonotone()}const g=this.m_shape.snapControlPointsOnSelection(o*o);a||=g,this.m_shape.dbgCheckSelection();let _=!1;if((l===0&&u===-1||m||Um(!0,this.m_shape,n,null,this.m_progressTracker))&&(_=this.crack_(o),a||=_,this.m_shape.dbgVerifyMonotone()),!_&&!Sa.fixCurveTwoPointLoops(this.m_shape,i,this.m_progressTracker)){this.m_shape.dbgVerifyMonotone();break}}return a&&yP(this.m_shape),a}cluster_(t){return g_(this.m_shape,t,v,this.m_bTrackChanges,this.m_progressTracker)}crack_(t){return Sx(this.m_shape,t,this.m_bTrackChanges,this.m_progressTracker)}static fixCurveTwoPointLoops(t,e,s){if(!t.hasCurves())return!1;t.dbgVerifyCurves();const i=t.createUserIndexUninitialized(),n=new Xt(0),o=t.queryVertexIteratorOnSelection();for(let u=o.next();u!==v;u=o.next())n.add(u),t.setUserIndex(u,i,-1);if(n.size()===0)return!1;n.add(v),t.sortVerticesSimpleByY(n,0,n.size()-1);let a=0;const h=t.getXY(n.read(a)),m=new y(Number.NaN,Number.NaN),l=[];for(let u=1,c=n.size();u<c;++u){const g=n.read(u),_=g!==v?t.getXY(g):m;if(_.equals(h))continue;const d=[];for(let p=a;p<u;p++){const f=n.read(p),x=t.getPrevVertex(f);if(x!==v&&t.getUserIndex(x,i)===-1){const P=th(t.getXY(x),t.getSegment(x));y.sqrDistance(h,P.otherPt)!==0&&(P.vert=x,P.dir=-1,d.push(P)),t.setUserIndex(x,i,1)}const E=t.getNextVertex(f);if(E!==v&&t.getUserIndex(f,i)===-1){const P=th(t.getXY(E),t.getSegment(f));y.sqrDistance(h,P.otherPt)!==0&&(P.vert=f,P.dir=1,d.push(P)),t.setUserIndex(f,i,1)}}if(d.length>1){d.sort((x,E)=>IP(x,E));const p=th(m.clone(),null);d.push(p);let f=0;for(let x=1,E=d.length;x<E;x++)if(!d[x].otherPt.equals(d[x-1].otherPt)){if(x-f>1&&d[f].seg!==null){let P=!1;const C=f;for(let S=f+1;S<x;S++)if(!vP(d[C],d[S])){P=!0;break}if(P)for(let S=f;S<x&&d[S].seg!==null;S++)l.push(d[S].vert)}f=x}}a=u,h.setCoordsPoint2D(_)}for(const u of l){const c=t.getSegment(u);b(c!==null);const g=t.getXY(u),_=t.getXY(t.getNextVertex(u));if(y.distance(g,_)<3*e)t.setSegmentToIndex(t.getVertexIndex(u),null);else{const d=c.lengthToT(.5*c.calculateLength2D());t.splitSegment(u,[d],1)}}return t.removeUserIndex(i),l.length>0}firstCrack_(){const t=this.m_shape.getEnvelope2D(this.m_progressTracker),e=re(null,t,!0).total();if(4*e<this.m_tolerance.total()){let s=!1;const i=1.1*e,n=e,o=this.cluster_(i);s||=o;let a=0;this.m_bFilterDegenerateSegments&&(a=this.m_shape.filterClosePoints(0,!0,!1,this.m_bTrackChanges,v));const h=this.crack_(n);return s||=h,s?1:a?2:0}return-1}progress_(t=!1){this.m_progressCounter++,!t&&4095&this.m_progressCounter||(this.m_progressCounter=0)}}function th(r,t){return{otherPt:r,seg:t,vert:-1,dir:0}}function vP(r,t){if(b(r.otherPt.equals(t.otherPt)),r.seg===null)return t.seg===null;if(t.seg===null)return!1;const e=r.seg.getGeometryType();if(e!==t.seg.getGeometryType())return!1;if(e===T.enumBezier){const s=r.seg,i=t.seg;let n=s.getControlPoint1(),o=s.getControlPoint2();r.dir===-1&&(o=O(n,n=o));let a=i.getControlPoint1(),h=i.getControlPoint2();return t.dir===-1&&(h=O(a,a=h)),n.equals(a)&&o.equals(h)}if(e===T.enumRationalBezier2){const s=r.seg,i=t.seg,n=s.getControlPoint1(),o=i.getControlPoint1();if(!n.equals(o))return!1;const a=[0,0,0];s.queryWeights(a),r.dir===-1&&(a[2]=O(a[0],a[0]=a[2]));const h=[0,0,0];return i.queryWeights(h),t.dir===-1&&(h[2]=O(h[0],h[0]=h[2])),a[0]===h[0]&&a[1]===h[1]&&a[2]===h[2]}$("")}function bP(r,t){if(r.seg===null||t.seg===null)return r.seg!==null?-1:t.seg!==null?1:0;const e=r.seg.getGeometryType(),s=t.seg.getGeometryType();return e<s?-1:e>s?1:0}function IP(r,t){const e=r.otherPt.compare(t.otherPt);return e!==0?e:bP(r,t)}var va=lt,wP=he,oo=Be;function DP(r){switch(r){case 1:return 1;case 2:return 2;case 3:return 3;case 4:return 4;case 0:return 0;default:b(0,"unrecognized cut side")}return 3}function Ni(){return{unsplitBehavior:0,allCrossRoadsImpassable:!1,ogcRule:!1}}function TP(r,t,e,s){return new je(s).autoCompleteImpl(r,t,e)}function im(r,t,e,s,i,n,o){const a=new je(i);a.m_bOGCOutput=!0;const h=r.getGeometryType()===T.enumPolygon&&r.getFillRule()===1&&!Ws(s);return a.planarSimplifyImpl_(r,t,h,e,s,i,n,o)}function Qo(r,t,e,s,i,n,o,a){return new je(n).planarSimplifyImpl_(r,t,e,s,i,n,o,a)}function NP(r,t,e,s){const i=new je(s),n=new Lt,o=n.addGeometry(t),a=i.planarSimplifyNoCrackingAndCluster(r,n,o,e);return b(a,"planar_simplify_no_cracking_and_cluster"),n.getGeometry(o)}function AP(r,t,e,s,i,n,o){return b(0),{}}function qP(r,t,e,s){return b(0),{}}function yc(r,t,e){return kP(r,t,e)}function FP(r,t,e,s){if(r.isEmpty()||t.isEmpty()||r.getDimension()>t.getDimension())return es(ie(r),r,t,"-");const i=new F;r.queryEnvelope(i);const n=new F;t.queryEnvelope(n);const o=new F;o.setCoords({env2D:i}),o.mergeEnvelope2D(n);const a=re(e,o,!0),h=n.clone(),m=ss(a);if(h.inflateCoords(m,m),!i.isIntersecting(h))return es(ie(r),r,t,"-");const l=new je(s),u=new Lt,c=u.addGeometry(ie(r)),g=u.addGeometry(ie(t));let _=0,d=0,p=null;if(u.hasCurves()){p=new ts;const E=u.getEnvelope2D(s);d=Fs(a.total());const P=Je(a.total(),E);_=Ms(P,d),_s(u,P,a.total(),12e3,p,null,s)}l.setEditShapeCrackAndCluster(u,a.add(_));const f=l.difference(c,g);p!==null&&p.stitchCurves(u,f,d,!0);const x=es(u.getGeometry(f),r,t,"-");return va(x.getGeometryType())&&(x.getImpl().setIsSimple(4,a.total()),x.getGeometryType()===T.enumPolygon&&x.getImpl().updateOGCFlagsProtected()),x}function MP(r,t,e,s){if(r.getDimension()>t.getDimension())return es(ie(r),r,t,"^");if(r.getDimension()<t.getDimension()||r.isEmpty())return es(ie(t),r,t,"^");if(t.isEmpty())return es(ie(r),r,t,"^");const i=new F;r.queryEnvelope(i);const n=new F;t.queryEnvelope(n);const o=new F;o.setCoords({env2D:i}),o.mergeEnvelope2D(n);const a=re(e,o,!0),h=new je(s),m=new Lt,l=m.addGeometry(ie(r)),u=m.addGeometry(ie(t));let c=0,g=null;if(m.hasCurves()){g=new ts;const p=m.getEnvelope2D(s);c=Fs(a.total()),_s(m,Je(a.total(),p),a.total(),12e3,g,null,s)}h.setEditShapeCrackAndCluster(m,a);const _=h.symmetricDifference(l,u);g!==null&&g.stitchCurves(m,_,c,!0);const d=es(m.getGeometry(_),r,t,"^");return va(d.getGeometryType())&&(d.getImpl().setIsSimple(4,a.total()),d.getGeometryType()===T.enumPolygon&&d.getImpl().updateOGCFlagsProtected()),d}function Pc(r,t,e){return RP(r,t,e,!0)}function GP(r,t,e){return r.isEmpty()||t.isEmpty()?r.createInstance():CP(e,r,t)?new st({copy:EP(r,t)}):r.createInstance()}function VP(r,t,e,s){const i=F.constructEmpty();r.queryEnvelope(i);const n=F.constructEmpty();t.queryEnvelope(n);const o=F.constructEmpty();o.setCoords({env2D:i}),o.mergeEnvelope2D(n);const a=re(e,o,!0),h=new F(n),m=ss(a);if(h.inflateCoords(m,m),!i.isIntersecting(h)){if(r.getDimension()<=t.getDimension())return es(ie(r.createInstance()),r,t,"&");if(r.getDimension()>t.getDimension())return es(ie(t.createInstance()),r,t,"&")}const l=new je(s),u=new Lt,c=u.addGeometry(ie(r)),g=u.addGeometry(ie(t));let _=0,d=0,p=null;if(u.hasCurves()){p=new ts;const E=u.getEnvelope2D(s);d=Fs(a.total());const P=Je(a.total(),E);_=Ms(P,d),_s(u,P,a.total(),12e3,p,null,s)}l.setEditShapeCrackAndCluster(u,a.add(_));const f=l.intersection(c,g);p!==null&&p.stitchCurves(u,f,d,!0);const x=es(u.getGeometry(f),r,t,"&");return va(x.getGeometryType())&&(x.getImpl().setIsSimple(4,a.total()),x.getGeometryType()===T.enumPolygon&&x.getImpl().updateOGCFlagsProtected()),x}function YP(r,t,e,s){const i=new Array(3),n=F.constructEmpty();r.queryEnvelope(n);const o=F.constructEmpty();t.queryEnvelope(o);const a=F.constructEmpty();a.setCoords({env2D:n}),a.mergeEnvelope2D(o);const h=re(e,a,!0),m=new F(o),l=ss(h);if(m.inflateCoords(l,l),!n.isIntersecting(m)){if(r.getDimension()<=t.getDimension()){const E=es(ie(r.createInstance()),r,t,"&");return i[E.getDimension()]=E,i}if(r.getDimension()>t.getDimension()){const E=es(ie(t.createInstance()),r,t,"&");return i[E.getDimension()]=E,i}}const u=new je(s),c=new Lt,g=c.addGeometry(ie(r)),_=c.addGeometry(ie(t));let d=0,p=0,f=null;if(c.hasCurves()){f=new ts;const E=c.getEnvelope2D(s);p=Fs(h.total());const P=Je(h.total(),E);d=Ms(P,p),_s(c,P,h.total(),12e3,f,null,s)}u.setEditShapeCrackAndCluster(c,h.add(d)),c.dbgVerifyCurves();const x=u.intersectionEx(g,_);for(const E of x){f!==null&&f.stitchCurves(c,E,p,!1);const P=es(c.getGeometry(E),r,t,"&");va(P.getGeometryType())&&(P.getImpl().setIsSimple(4,h.total()),P.getGeometryType()===T.enumPolygon&&P.getImpl().updateOGCFlagsProtected()),i[P.getDimension()]=P}return f!==null&&f.clearStitcher(c),i}function eh(r,t,e,s,i,n=!1){t===0&&H("not enough geometries to dissolve");let o=0;for(let _=0,d=t;_<d;_++)o=Math.max(r[_].getDimension(),o);if(o===2||o===1)return new je(s).dissolveMultiPaths_(o,!1,r,t,e,i,n);let a=0,h=-1;for(let _=0,d=t;_<d;_++)r[_].getDimension()===o&&(h===-1&&(h=_),r[_].isEmpty()||(h=_,a++));if(a<2)return ie(r[h]);const m=ps.constructEmpty(),l=new Lt;let u=v;for(let _=0,d=t;_<d;_++)if(r[_].getDimension()===o&&!r[_].isEmpty()){u===v?u=l.addGeometry(ie(r[_])):l.appendGeometry(u,ie(r[_]));const p=ps.constructEmpty();r[_].queryLooseEnvelope(p),m.mergeEnv3D(p)}const c=re(e,m.getEnvelope2D(),!0),g=new je(s);if(n){const _=rr(e,m.getEnvelopeZs(),!0);return g.planarSimplify3DImpl_(l,c,_,0,!0)}return g.m_bOGCOutput=!0,g.planarSimplifyMultiPoints(l,c,!1,-1)}function XP(r,t,e,s,i,n=!1){t<2&&H("not enough geometries to dissolve");let o=0;for(let d=0,p=t;d<p;d++)o=Math.max(r[d].getDimension(),o);if(o===2||o===1)return new je(s).dissolveMultiPaths_(o,!0,r,t,e,i,n);const a=ps.constructEmpty(),h=new Lt;let m=v,l=0,u=-1;for(let d=0,p=t;d<p;d++)if(r[d].getDimension()===o&&(u===-1&&(u=d),!r[d].isEmpty())){u=d,m===v?m=h.addGeometry(ie(r[d])):h.appendGeometry(m,ie(r[d]));const f=ps.constructEmpty();r[d].queryLooseEnvelope(f),a.mergeEnv3D(f),l++}if(l<2)return ie(r[u]);const c=o===0?e:null,g=re(c,a.getEnvelope2D(),!0),_=new je(s);if(n){const d=rr(c,a.getEnvelopeZs(),!0);return _.m_bOGCOutput=!0,_.planarSimplify3DImpl_(h,g,d,0,!0)}return _.planarSimplifyMultiPoints(h,g,!0,-1)}class je{constructor(t){this.m_topoGraph=null,this.m_maskLookup=[],this.m_dummyPt1=y.getNAN(),this.m_dummyPt2=y.getNAN(),this.m_fromEdgeForPolylines=v,this.m_progressCounter=0,this.m_bOGCOutput=!1,this.m_progressTracker=t}linesToPolygonsImpl(t,e){let s=0,i=0,n=null;if(t.hasCurves()){n=new ts;const m=t.getEnvelope2D(this.m_progressTracker);i=Fs(e.total());const l=Je(e.total(),m);s=Ms(l,i),_s(t,l,e.total(),12e3,n,null,this.m_progressTracker)}this.setEditShapeCrackAndCluster(t,e.add(s));const o=this.m_topoGraph.createUserIndexForChains(),a=this.m_topoGraph.getFirstChain();this.m_topoGraph.setChainUserIndex(a,o,1);for(let m=this.m_topoGraph.getChainFirstIsland(a);m!==v;m=this.m_topoGraph.getChainNextInParent(m))this.m_topoGraph.setChainUserIndex(m,o,1);const h=[];for(let m=this.m_topoGraph.getFirstChain();m!==v;m=this.m_topoGraph.getChainNext(m)){if(this.m_topoGraph.getChainUserIndex(m,o)===1)continue;this.m_topoGraph.setChainUserIndex(m,o,1);for(let c=this.m_topoGraph.getChainFirstIsland(m);c!==v;c=this.m_topoGraph.getChainNextInParent(c))this.m_topoGraph.setChainUserIndex(c,o,1);if(this.m_topoGraph.getChainArea(m)===0)continue;const l=this.m_topoGraph.extractPolygonFromChainAndIslands(t,v,m,v);n?.stitchCurves(t,l,i,!1);const u=t.getGeometry(l);h.push(u)}return new oi(h)}autoCompleteImpl(t,e,s){let i=0,n=0,o=null;if(t.hasCurves()){o=new ts;const u=t.getEnvelope2D(this.m_progressTracker);n=Fs(s.total());const c=Je(s.total(),u);i=Ms(c,n),_s(t,c,s.total(),12e3,o,null,this.m_progressTracker)}this.setEditShapeCrackAndCluster(t,s.add(i));const a=this.m_topoGraph.getGeometryID(e),h=this.m_topoGraph.createUserIndexForChains(),m=this.m_topoGraph.getFirstChain();this.m_topoGraph.setChainUserIndex(m,h,1);for(let u=this.m_topoGraph.getChainFirstIsland(m);u!==v;u=this.m_topoGraph.getChainNextInParent(u))this.m_topoGraph.setChainUserIndex(u,h,1);const l=[];for(let u=this.m_topoGraph.getFirstChain();u!==v;u=this.m_topoGraph.getChainNext(u)){if(this.m_topoGraph.getChainUserIndex(u,h)===1)continue;this.m_topoGraph.setChainUserIndex(u,h,1);for(let f=this.m_topoGraph.getChainFirstIsland(u);f!==v;f=this.m_topoGraph.getChainNextInParent(f))this.m_topoGraph.setChainUserIndex(f,h,1);if(this.m_topoGraph.getChainParentage(u)!==0)continue;const c=this.m_topoGraph.getChainHalfEdge(u);let g=c,_=!1;do{const f=this.m_topoGraph.getHalfEdgeTwin(g);if(this.m_topoGraph.getHalfEdgeChain(f)!==u&&(this.m_topoGraph.getHalfEdgeParentage(g)&a)!==0){_=!0;break}g=this.m_topoGraph.getHalfEdgeNext(g)}while(g!==c);if(!_||this.m_topoGraph.getChainArea(u)===0)continue;const d=this.m_topoGraph.extractPolygonFromChainAndIslands(t,v,u,v);o!==null&&o.stitchCurves(t,d,n,!1);const p=t.getGeometry(d);l.push(p)}return new oi(l)}setEditShape(t,e=!1){this.m_topoGraph===null&&(this.m_topoGraph=new gs),this.m_topoGraph.setEditShape(t,this.m_progressTracker,!0,e)}setEditShapeCrackAndCluster(t,e){Ns(t,e,this.m_progressTracker,!0,!1);for(let s=t.getFirstGeometry();s!==v;s=t.getNextGeometry(s))t.getGeometryType(s)===T.enumPolygon&&ii(t,s,-1,this.m_bOGCOutput,v,this.m_progressTracker);this.setEditShape(t)}setHalfEdgeOrientations_(t,e){const s=this.m_topoGraph.getShape();for(let i=s.getFirstGeometry();i!==v;i=s.getNextGeometry(i))if(i===e)for(let n=s.getFirstPath(i);n!==v;n=s.getNextPath(n)){let o=s.getFirstVertex(n);if(o===v)continue;let a=s.getNextVertex(o);for(;a!==v;){const h=this.m_topoGraph.getClusterFromVertex(o),m=this.m_topoGraph.getClusterFromVertex(a),l=this.m_topoGraph.getHalfEdgeConnector(h,m);if(l!==v){const u=this.m_topoGraph.getHalfEdgeTwin(l);this.m_topoGraph.setHalfEdgeUserIndex(l,t,1),this.m_topoGraph.setHalfEdgeUserIndex(u,t,2)}o=a,a=s.getNextVertex(o)}}}flushVertices_(t,e){const s=this.m_topoGraph.getShape(),i=s.hasSegmentParentage(),n=new it,o=s.insertPath(t,v);e.push(e[0]);const a=e.length;let h=v;for(let m=0;m<a;m++){const l=e[m];if(h=s.addVertex(o,l),!i)continue;const u=this.m_topoGraph.getClusterFromVertex(l);if(m>0&&this.m_topoGraph.isBreakNode(u)&&s.setSegmentParentageBreakVertex(h,!0),m<a-1){const c=this.m_topoGraph.getHalfEdgeConnector(u,this.m_topoGraph.getClusterFromVertex(e[m+1])),g=this.m_topoGraph.getSegmentParentage(c);s.setSegmentParentageAndBreak(h,g,m>0||this.m_topoGraph.isBreakNode(u)),this.m_topoGraph.isHalfEdgeCurve(c)&&(this.m_topoGraph.querySegmentXY(c,n),s.setSegmentToIndex(s.getVertexIndex(h),n.get().clone()))}}if(i){const m=this.m_topoGraph.getClusterFromVertex(e[a-1]);this.m_topoGraph.isBreakNode(m)&&s.setSegmentParentageBreakVertex(h,!0)}s.setClosedPath(o,!0)}processPolygonCuts_(t,e,s,i){const n=this.m_topoGraph.getGeometryID(s),o=this.m_topoGraph.getGeometryID(i),a=[],h=this.m_topoGraph.getShape(),m=this.m_topoGraph.createUserIndexForHalfEdges();for(let l=this.m_topoGraph.getFirstCluster();l!==v;l=this.m_topoGraph.getNextCluster(l)){const u=this.m_topoGraph.getClusterHalfEdge(l);if(u===v)continue;let c=u;do{if(this.m_topoGraph.getHalfEdgeUserIndex(c,m)!==1){let g=c,_=c,d=!1,p=0;do{if(this.m_topoGraph.setHalfEdgeUserIndex(g,m,1),!d&&(this.m_topoGraph.getHalfEdgeParentage(g)&o)!==0&&(this.m_topoGraph.getHalfEdgeFaceParentage(g)&n)!==0&&(_=g,d=!0),d){const f=this.m_topoGraph.getHalfEdgeOrigin(g),x=this.m_topoGraph.getClusterVertexIterator(f),E=this.m_topoGraph.getVertexFromVertexIterator(x);a.push(E),t!==-1&&(this.m_topoGraph.getHalfEdgeParentage(g)&o)!==0&&(p|=this.m_topoGraph.getHalfEdgeUserIndex(g,t))}g=this.m_topoGraph.getHalfEdgeNext(g)}while(g!==_);if(d&&this.m_topoGraph.getChainArea(this.m_topoGraph.getHalfEdgeChain(_))>0){const f=h.createGeometry(T.enumPolygon);this.flushVertices_(f,a),e!==-1&&h.setGeometryUserIndex(f,e,p)}a.length=0}c=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(c))}while(c!==u)}this.m_topoGraph.deleteUserIndexForHalfEdges(m)}cutPolygonPolyline_(t,e,s,i){this.m_topoGraph.removeSpikes_();let n=-1;t!==-1&&(n=this.m_topoGraph.createUserIndexForHalfEdges(),this.setHalfEdgeOrientations_(n,s)),this.processPolygonCuts_(n,t,e,s),n!==-1&&(this.m_topoGraph.deleteUserIndexForHalfEdges(n),n=-1);const o=this.m_topoGraph.getShape();for(let a=o.getFirstGeometry();a!==v;a=o.getNextGeometry(a))a!==e&&a!==s&&i.push(a);i.sort((a,h)=>{const m=o.getFirstPath(a),l=o.getRingArea(m),u=o.getFirstPath(h),c=o.getRingArea(u);return l<c?-1:l>c?1:0})}cut(t,e,s,i,n){const o=this.m_topoGraph.getShape().getGeometryType(s),a=this.m_topoGraph.getShape().getGeometryType(i),h=Be(o),m=Be(a);h!==2||m!==1?h!==1||m!==1?$(""):new LP(this,t,e,s,i,n).Do():this.cutPolygonPolyline_(e,s,i,n)}progress_(t=!1){}isGoodParentage(t){return t>=0&&t<this.m_maskLookup.length&&this.m_maskLookup[t]}normalizeInputGeometry(t){const e=t.getGeometryType();if(e===T.enumEnvelope){const s=new ct({vd:t.getDescription()});return t.isEmpty()||s.addEnvelope(t,!1),s}if(e===T.enumPoint){const s=new Zt({vd:t.getDescription()});return t.isEmpty()||s.add(t),s}if(he(e)){const s=new Pt({vd:t.getDescription()});return t.isEmpty()||s.addSegment(t,!0),s}return e!==T.enumMultiPoint&&e!==T.enumPolyline&&e!==T.enumPolygon&&H("Unexpected geometry type"),t}dissolveNonSimplePolygons(t,e,s,i){b(e>0);const n=new Lt;let o=0,a=-1;for(let h=0,m=e;h<m;h++)t[h].getDimension()===2&&(a===-1&&(a=h),t[h].isEmpty()||(o++,n.addGeometry(t[h])));return o===0?(b(a>=0),this.normalizeInputGeometry(t[a])):this.planarSimplifyPolygons(n,s,!0,!1,-1,!0)}dissolveMultiPaths_(t,e,s,i,n,o,a){b(t>=1&&t<=2),b(i>0);const h=8&o?1:2,m=ps.constructEmpty();let l=0,u=-1,c=!0;for(let q=0,V=i;q<V;q++)if(s[q].getDimension()===t&&(u===-1&&(u=q),!s[q].isEmpty())){u=q,l++;const k=ps.constructEmpty();if(s[q].queryLooseEnvelope(k),m.mergeEnv3D(k),t===2&&c&&s[q].getGeometryType()===T.enumPolygon)if(16&o){const Y=[0],U=s[q].getImpl().getIsSimple(0,Y),X=this.m_bOGCOutput?U===5:yi(U);c&&=X}else{const Y=Cp(s[q],0);c&&=Y}}if(l<2&&(b(u>=0),l===0||!(16&o)))return this.normalizeInputGeometry(s[u]);if(!c){const q=re(e?null:n,m.getEnvelope2D(),!0);return this.dissolveNonSimplePolygons(s,i,q,o)}const g=s.slice(0,i),_=re(n,m.getEnvelope2D(),!0),d=10*ss(_);let p=new Ve(0,0);if(a&&(p=rr(n,m.getEnvelopeZs(),!0)),l===1&&t===1&&h===2&&!e)return a?AP():this.m_bOGCOutput?im(g[u],_,!1,-1,this.m_progressTracker,h,!1):Qo(g[u],_,!1,!1,-1,this.m_progressTracker,h,!1);const f=new Yr;f.startConstruction();let x=t===2?3:4,E=0;for(let q=0,V=i;q<V;q++){if(g[q].getDimension()!==t||g[q].isEmpty())continue;let k=g[q].getGeometryType();if(k!==T.enumEnvelope){if(he(k)?(g[q]=this.normalizeInputGeometry(g[q]),k=T.enumPolyline):b(lt(k)),t===1){b(k===T.enumPolyline);let U=-1;if(a)b(0,"3d not implemented yet");else{const X=[0];U=g[q].getImpl().getIsSimple(_.total(),X)}if(this.m_bOGCOutput?U!==5:!yi(U))if(e)x=-1;else{a?b(0,"3d not implemented yet"):this.m_bOGCOutput?g[q]=im(g[q],_,!1,-1,this.m_progressTracker,h,!1):g[q]=Qo(g[q],_,!1,!1,-1,this.m_progressTracker,h,!1);const X=[0];b(yi(g[q].getImpl().getIsSimple(_.total(),X)))}}else{b(k===T.enumPolygon);const U=[0],X=g[q].getImpl().getIsSimple(0,U);b(Ws(X))}const Y=g[q].getImpl();for(let U=0,X=Y.getPathCount();U<X;U++){const B=F.constructEmpty();Y.queryLoosePathEnvelope(U,B),B.inflateCoords(d,d),f.addEnvelope(E,B),E++}}else{b(k===T.enumEnvelope);const Y=F.constructEmpty();g[q].queryLooseEnvelope(Y),Y.inflateCoords(d,d),f.addEnvelope(E,Y),E++,x=-1}}f.endConstruction();const P=E,C=j(P,-2147483647),S=j(P,-1);let I=0;u=-1,E=0;for(let q=0,V=i;q<V;q++){if(g[q].getDimension()!==t||(u===-1&&(u=q),g[q].isEmpty()))continue;u=q,I++;const k=g[q].getGeometryType();if(lt(k))for(let Y=0,U=g[q].getPathCount();Y<U;Y++)S[E]=q,C[E]=-Y-1,E++;else b(k===T.enumEnvelope),S[E]=q,C[E]=-1,E++}if(I<2&&t===2)return b(u>=0),this.normalizeInputGeometry(g[u]);let w=P;for(;f.next()&&w>0;){this.progress_();const q=f.getHandleA(),V=f.getHandleB(),k=f.getElement(q),Y=f.getElement(V);S[k]!==S[Y]&&(C[k]<0&&(w--,C[k]=-(C[k]+1)),C[Y]<0&&(w--,C[Y]=-(C[Y]+1)))}const D=new Lt;let N=!1,A=0;for(let q=0,V=i;q<V;q++){if(g[q].getDimension()!==t||g[q].isEmpty())continue;const k=g[q].getGeometryType(),Y=A;let U=0,X=0;const B=lt(k)?g[q]:null;for(let W=Y,Z=C.length;W<Z&&S[W]===q;W++)C[W]>=0&&(U++,X+=B?B.getPathSize(C[W]):sr(g[q])),A++;if(X>.95*sr(g[q])){D.addGeometry(this.normalizeInputGeometry(g[q]));for(let W=Y;W<A;W++)C[W]<0&&(C[W]=-(C[W]+1))}else{if(U===0){N=!0;continue}{N=!0,b(lt(k)),b(B!=null);const W=new ct({vd:g[q].getDescription()}),Z=new Pt({vd:g[q].getDescription()}),gt=k===T.enumPolygon?W:Z;for(let at=Y;at<A;at++)C[at]>=0&&gt.addPath(B,C[at],!0);D.addGeometry(gt)}}}let M;if(D.getFirstGeometry()!==v){const q=t===2,V=e?re(null,m.getEnvelope2D(),!0):_;let k=new Ve(0,0);if(a&&(k=e?rr(null,m.getEnvelopeZs(),!0):p),t===2&&!(2&o)){D.collapseAllGeometriesToFirst();let Y=0,U=null;if(D.hasCurves()&&!D.hasSegmentParentage()){U=new ts;const X=D.getEnvelope2D(this.m_progressTracker);Y=Fs(V.total()),_s(D,Je(V.total(),X),V.total(),12e3,U,null,this.m_progressTracker)}Cx(D,D.getFirstGeometry(),V.total(),this.m_progressTracker),U!==null&&U.stitchCurves(D,v,Y,!0)}if(a)M=this.planarSimplify3DImpl_(D,V,k,h,!0);else if(t===2)M=this.planarSimplifyPolygons(D,V,q,e,-1,!1);else{const Y=Ni();Y.ogcRule=this.m_bOGCOutput,Y.allCrossRoadsImpassable=!0,Y.unsplitBehavior=h,M=this.planarSimplifyPolylines(D,V,e,Y,-1)}if(!N){const Y=[0];x=M.getImpl().getIsSimple(V.total(),Y)}}else b(N),b(u>=0),M=t===2?new ct({vd:g[u].getDescription()}):new Pt({vd:g[u].getDescription()});if(N){let q=0;for(let V=0,k=C.length;V<k;V++){const Y=S[V];if(!(Y<0)&&C[V]<0){const U=g[Y].getGeometryType(),X=lt(U)?g[Y]:null;if(X){const B=-(C[V]+1);q+=X.getPathSize(B)}else q+=4}}M.reserve(M.getPointCount()+q);for(let V=0,k=C.length;V<k;V++){const Y=S[V];if(!(Y<0)&&C[V]<0){const U=g[Y].getGeometryType(),X=lt(U)?g[Y]:null;if(X){const B=-(C[V]+1);M.addPath(X,B,!0)}else U===T.enumEnvelope?M.addEnvelope(g[Y],!1):(b(he(U)),M.addSegment(g[Y],!0))}}}let G=0;if(t===2?x!==-1&&(x=3,G=e?0:_.total()):(b(t===1),e||x===-1||(G=_.total())),a||M.getImpl().setIsSimple(x,G),!e&&N)if(t===2){if(!a)return new Us().execute(M,n,!1,this.m_progressTracker);b(0,"3d not yet implemented")}else t===1&&h!==1&&(M=a?qP():NP(this.m_bOGCOutput,M,h,this.m_progressTracker),M.getImpl().setIsSimple(x,G));return M}dissolveTopoGraphCommonEdges_(){const t=this.m_topoGraph.createUserIndexForHalfEdges(),e=[];for(let s=this.m_topoGraph.getFirstCluster();s!==v;s=this.m_topoGraph.getNextCluster(s)){const i=this.m_topoGraph.getClusterHalfEdge(s);let n=i;if(i!==v)do{if(this.progress_(),this.m_topoGraph.getHalfEdgeUserIndex(n,t)!==1){const o=this.m_topoGraph.getHalfEdgeTwin(n);this.m_topoGraph.setHalfEdgeUserIndex(o,t,1),this.m_topoGraph.setHalfEdgeUserIndex(n,t,1);const a=this.m_topoGraph.getHalfEdgeFaceParentage(n);if(this.isGoodParentage(a)){const h=this.m_topoGraph.getHalfEdgeFaceParentage(o);this.isGoodParentage(h)&&e.push(n)}}n=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(n))}while(n!==i)}this.m_topoGraph.deleteUserIndexForHalfEdges(t),this.m_topoGraph.deleteEdgesBreakFaces_(e)}chooseVertexByOrder(t,e,s,i){let n=we(),o=v;for(let h=this.m_topoGraph.getClusterVertexIterator(t);h!==v;h=this.m_topoGraph.incrementVertexIterator(h)){const m=this.m_topoGraph.getVertexFromVertexIterator(h),l=e.getUserIndex(m,s);l>=0&&l<n&&(n=l,o=m)}b(o!==v);let a=e.getUserIndex(o,i);return a>0&&(e.setUserIndex(o,i,--a),a===0&&e.setUserIndex(o,s,-1)),o}chooseVertexFromCluster_(t,e){return this.m_topoGraph.getVertexDominantFromCluster(t,e)}chooseVertexFromVertexCluster_(t,e){return this.m_topoGraph.getVertexDominant(t,e)}collectPolygonPathsPreservingFrom_(t,e,s,i,n){const o=this.m_topoGraph.getShape();if(o.getGeometryType(t)!==T.enumPolygon)return;const a=o.hasSegmentParentage(),h=new it;for(let m=o.getFirstPath(t);m!==v;m=o.getNextPath(m)){const l=o.getFirstVertex(m);this.m_topoGraph.getClusterFromVertex(l);const u=this.m_topoGraph.getHalfEdgeFromVertex(l);if(u===v)continue;const c=this.m_topoGraph.getHalfEdgeUserIndex(u,s);if(c===1||c===2)continue;const g=this.m_topoGraph.getHalfEdgeFaceParentage(u);if(!this.isGoodParentage(g)){this.m_topoGraph.setHalfEdgeUserIndex(u,s,2);continue}this.m_topoGraph.setHalfEdgeUserIndex(u,s,1);const _=o.insertPath(e,v);o.setClosedPath(_,!0);let d=u,p=l,f=this.m_topoGraph.getClusterFromVertex(p),x=1;do{this.progress_();const E=this.chooseVertexFromVertexCluster_(p,n),P=o.addVertex(_,E);if(this.m_topoGraph.isHalfEdgeCurve(d)&&(this.m_topoGraph.querySegmentXY(d,h),o.setSegmentToIndex(o.getVertexIndex(P),h.get().clone())),a){const w=this.m_topoGraph.getSegmentParentage(d);o.setSegmentParentageAndBreak(P,w,this.m_topoGraph.isBreakNode(f))}let C,S;i!==-1&&this.m_topoGraph.setClusterUserIndex(f,i,1),this.m_topoGraph.setHalfEdgeUserIndex(d,s,1),d=this.m_topoGraph.getHalfEdgeNext(d);do C=x===1?o.getNextVertex(p):o.getPrevVertex(p),S=C!==v?this.m_topoGraph.getClusterFromVertex(C):v;while(S===f);const I=this.m_topoGraph.getHalfEdgeOrigin(d);if(I!==S){do C=x===1?o.getPrevVertex(p):o.getNextVertex(p),S=C!==v?this.m_topoGraph.getClusterFromVertex(C):v;while(S===f);if(I!==S){S=I;const w=this.m_topoGraph.getClusterVertexIterator(S);C=this.m_topoGraph.getVertexFromVertexIterator(w)}else x=-x}f=S,p=C}while(d!==u)}}topoOperationPolygonPolygonHelper_(t,e,s,i,n,o){this.progress_(!0),t!==v&&this.collectPolygonPathsPreservingFrom_(t,s,n,o,i),e!==v&&this.collectPolygonPathsPreservingFrom_(e,s,n,o,i);const a=new it,h=this.m_topoGraph.getShape();h.dbgVerifyCurves();const m=h.hasSegmentParentage();for(let l=this.m_topoGraph.getFirstCluster();l!==v;l=this.m_topoGraph.getNextCluster(l)){const u=this.m_topoGraph.getClusterHalfEdge(l);if(u===v)continue;let c=u;do{this.progress_();const g=this.m_topoGraph.getHalfEdgeUserIndex(c,n);if(g!==1&&g!==2){const _=this.m_topoGraph.getHalfEdgeFaceParentage(c);if(this.isGoodParentage(_)){const d=h.insertPath(s,v);h.setClosedPath(d,!0);let p=c;do{const f=this.m_topoGraph.getHalfEdgeVertexIterator(p);let x=v;if(f!==v)x=this.m_topoGraph.getVertexFromVertexIterator(f);else{const C=this.m_topoGraph.getHalfEdgeVertexIterator(this.m_topoGraph.getHalfEdgeTwin(p));x=this.m_topoGraph.getVertexFromVertexIterator(C),x=h.getNextVertex(x)}const E=this.chooseVertexFromVertexCluster_(x,i),P=h.addVertex(d,E);if(m){const C=this.m_topoGraph.getSegmentParentage(p),S=this.m_topoGraph.getHalfEdgeOrigin(p);h.setSegmentParentageAndBreak(P,C,this.m_topoGraph.isBreakNode(S))}if(this.m_topoGraph.isHalfEdgeCurve(p)&&(this.m_topoGraph.querySegmentXY(p,a),h.setSegmentToIndex(h.getVertexIndex(P),a.get().clone())),this.m_topoGraph.setHalfEdgeUserIndex(p,n,1),o!==-1){const C=this.m_topoGraph.getClusterFromVertex(E);this.m_topoGraph.setClusterUserIndex(C,o,1)}p=this.m_topoGraph.getHalfEdgeNext(p)}while(p!==c)}else this.m_topoGraph.setHalfEdgeUserIndex(c,n,2)}c=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(c))}while(c!==u)}}topoOperationPolygonPolygon_(t,e,s,i=!1){this.dissolveTopoGraphCommonEdges_();const n=this.m_topoGraph.getShape(),o=n.createGeometry(T.enumPolygon),a=this.m_topoGraph.createUserIndexForHalfEdges();return this.topoOperationPolygonPolygonHelper_(t,e,o,s,a,-1),this.m_topoGraph.deleteUserIndexForHalfEdges(a),i||ii(n,o,3,this.m_bOGCOutput,v,this.m_progressTracker),o}topoOperationPolyline_(t,e){const s=Ni();return s.allCrossRoadsImpassable=!1,s.ogcRule=e,s.unsplitBehavior=0,this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(v,t,!1,s).first}topoOperationMultiPoint_(){const t=this.m_topoGraph.getShape(),e=t.createGeometry(T.enumMultiPoint),s=t.insertPath(e,v);for(let i=this.m_topoGraph.getFirstCluster();i!==v;i=this.m_topoGraph.getNextCluster(i)){const n=this.m_topoGraph.getClusterParentage(i);if(this.isGoodParentage(n)){let o=v;for(let a=this.m_topoGraph.getClusterVertexIterator(i);a!==v;a=this.m_topoGraph.incrementVertexIterator(a)){const h=this.m_topoGraph.getVertexFromVertexIterator(a);o===v&&(o=h);const m=t.getGeometryFromPath(t.getPathFromVertex(h)),l=this.m_topoGraph.getGeometryID(m);if(this.isGoodParentage(l)){o=h;break}}t.addVertex(s,o)}}return e}intersection(t,e){const s=this.m_topoGraph.getShape().getGeometryType(t),i=this.m_topoGraph.getShape().getGeometryType(e),n=Be(s),o=Be(i),a=this.m_topoGraph.getGeometryID(t),h=this.m_topoGraph.getGeometryID(e);b(a>=0),b(h>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=1+(a|h),this.m_maskLookup[a|h]=!0;let m=v;return this.m_topoGraph.getShape().getVertexDescription().getAttributeCount()>1&&(m=t),n===2&&o===2?this.topoOperationPolygonPolygon_(t,e,m):n===1&&o>0||o===1&&n>0?this.topoOperationPolyline_(m,this.m_bOGCOutput):n===0||o===0?this.topoOperationMultiPoint_():void $("")}topoOperationPolygonPolygonEx(t,e,s){const i=this.m_topoGraph.getShape(),n=i.createGeometry(T.enumPolygon),o=i.createGeometry(T.enumPolyline),a=i.createGeometry(T.enumMultiPoint);this.dissolveTopoGraphCommonEdges_();let h=v;const m=this.m_topoGraph.createUserIndexForHalfEdges(),l=this.m_topoGraph.createUserIndexForClusters();i.dbgVerifyCurves(),this.topoOperationPolygonPolygonHelper_(t,e,n,s,m,l),i.dbgVerifyCurves();const u=i.hasSegmentParentage(),c=new it;for(let _=this.m_topoGraph.getFirstCluster();_!==v;_=this.m_topoGraph.getNextCluster(_)){const d=this.m_topoGraph.getClusterHalfEdge(_);if(d===v)continue;let p=d;do{let f=this.m_topoGraph.getHalfEdgeUserIndex(p,m),x=this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(p),m),E=f|x;if(E===2){let P=this.m_topoGraph.getHalfEdgeParentage(p);if(this.isGoodParentage(P)){const C=i.insertPath(o,v);let S=p;const I=this.chooseVertexFromCluster_(_,s);let w=i.addVertex(C,I);if(u){const D=this.m_topoGraph.getSegmentParentage(p),N=this.m_topoGraph.getHalfEdgeOrigin(p);i.setSegmentParentageAndBreak(w,D,this.m_topoGraph.isBreakNode(N))}this.m_topoGraph.isHalfEdgeCurve(p)&&(this.m_topoGraph.querySegmentXY(p,c),i.setSegmentToIndex(i.getVertexIndex(w),c.get().clone())),this.m_topoGraph.setClusterUserIndex(_,l,1);do{this.progress_();const D=this.m_topoGraph.getHalfEdgeTo(S),N=this.chooseVertexFromCluster_(D,s);if(w=i.addVertex(C,N),u){const A=this.m_topoGraph.getSegmentParentage(p),M=this.m_topoGraph.getHalfEdgeOrigin(p);i.setSegmentParentageAndBreak(w,A,this.m_topoGraph.isBreakNode(M))}if(this.m_topoGraph.setHalfEdgeUserIndex(S,m,1),this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(S),m,1),this.m_topoGraph.setClusterUserIndex(D,l,1),S=this.m_topoGraph.getHalfEdgeNext(S),f=this.m_topoGraph.getHalfEdgeUserIndex(S,m),x=this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(S),m),E=f|x,E!==2)break;if(P=this.m_topoGraph.getHalfEdgeParentage(S),!this.isGoodParentage(P)){this.m_topoGraph.setHalfEdgeUserIndex(S,m,1),this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(S),m,1);break}this.m_topoGraph.isHalfEdgeCurve(p)&&S!==p&&(this.m_topoGraph.querySegmentXY(p,c),i.setSegmentToIndex(i.getVertexIndex(w),c.get().clone()))}while(S!==p)}else this.m_topoGraph.setHalfEdgeUserIndex(p,m,1),this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(p),m,1)}p=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(p))}while(p!==d)}for(let _=this.m_topoGraph.getFirstCluster();_!==v;_=this.m_topoGraph.getNextCluster(_)){if(this.progress_(),this.m_topoGraph.getClusterUserIndex(_,l)===1)continue;const d=this.m_topoGraph.getClusterParentage(_);if(this.isGoodParentage(d)){h===v&&(h=i.insertPath(a,v));const p=this.m_topoGraph.getClusterVertexIterator(_);let f=v;if(p!==v){f=this.m_topoGraph.getVertexFromVertexIterator(p);const x=this.chooseVertexFromVertexCluster_(f,s);i.addVertex(h,x)}}}this.m_topoGraph.deleteUserIndexForClusters(l),this.m_topoGraph.deleteUserIndexForHalfEdges(m),i.dbgVerifyCurves(),ii(i,n,3,this.m_bOGCOutput,v,this.m_progressTracker);const g=[v,v,v];return g[0]=a,g[1]=o,g[2]=n,g}topoOperationPolylinePolylineOrPolygonEx(t,e){const s=Ni();return s.allCrossRoadsImpassable=!1,s.ogcRule=e,s.unsplitBehavior=0,this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(v,t,!0,s)}topoOperationMultiPoint(){const t=this.m_topoGraph.getShape(),e=t.createGeometry(T.enumMultiPoint),s=t.insertPath(e,v);for(let i=this.m_topoGraph.getFirstCluster();i!==v;i=this.m_topoGraph.getNextCluster(i)){const n=this.m_topoGraph.getClusterParentage(i);if(this.isGoodParentage(n)){let o=v;for(let a=this.m_topoGraph.getClusterVertexIterator(i);a!==v;a=this.m_topoGraph.incrementVertexIterator(a)){const h=this.m_topoGraph.getVertexFromVertexIterator(a);o===v&&(o=h);const m=t.getGeometryFromPath(t.getPathFromVertex(h)),l=this.m_topoGraph.getGeometryID(m);if(this.isGoodParentage(l)){o=h;break}}t.addVertex(s,o)}}return e}intersectionEx(t,e){const s=this.m_topoGraph.getShape().getGeometryType(t),i=this.m_topoGraph.getShape().getGeometryType(e),n=oo(s),o=oo(i),a=this.m_topoGraph.getGeometryID(t),h=this.m_topoGraph.getGeometryID(e);b(a>=0),b(h>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=1+(a|h),this.m_maskLookup[a|h]=!0;let m=v;if(this.m_topoGraph.getShape().getVertexDescription().getAttributeCount()>1&&(m=t),n===2&&o===2)return this.topoOperationPolygonPolygonEx(t,e,m);if(n===1&&o>0||o===1&&n>0){const{first:l,second:u}=this.topoOperationPolylinePolylineOrPolygonEx(m,this.m_bOGCOutput);return[u,l]}if(n===0||o===0){const l=[];return l.push(this.topoOperationMultiPoint()),l}$("")}getCombinedHalfEdgeParentage(t){return this.m_topoGraph.getHalfEdgeParentage(t)|this.m_topoGraph.getHalfEdgeFaceParentage(t)|this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t))}prevailingDirection(t,e){const s=this.getCombinedHalfEdgeParentage(e),i=this.m_topoGraph.getHalfEdgeOrigin(e),n=this.m_topoGraph.getHalfEdgeTo(e);let o=0,a=0;for(let h=this.m_topoGraph.getClusterVertexIterator(i);h!==v;h=this.m_topoGraph.incrementVertexIterator(h)){const m=this.m_topoGraph.getVertexFromVertexIterator(h),l=t.getPathFromVertex(m),u=t.getGeometryFromPath(l),c=this.m_topoGraph.getGeometryID(u),g=t.getFirstVertex(l),_=(c&s)!==0;_&&g===m&&(this.m_fromEdgeForPolylines=e);const d=t.getNextVertex(m);if(d!==v&&this.m_topoGraph.getClusterFromVertex(d)===n){if(o++,_){if(this.m_fromEdgeForPolylines===v&&g===d){const p=this.m_topoGraph.getHalfEdgeNext(e);this.isGoodParentage(this.getCombinedHalfEdgeParentage(p))&&(this.m_fromEdgeForPolylines=p)}a++}}else{const p=t.getPrevVertex(m);if(p!==v&&this.m_topoGraph.getClusterFromVertex(p)===n&&(o--,_)){if(this.m_fromEdgeForPolylines===v&&g===p){const f=this.m_topoGraph.getHalfEdgeNext(e);this.isGoodParentage(this.getCombinedHalfEdgeParentage(f))&&(this.m_fromEdgeForPolylines=f)}a--}}}return this.m_topoGraph.queryXY(i,this.m_dummyPt1),this.m_topoGraph.queryXY(n,this.m_dummyPt2),(a!==0?a:o)*y.distance(this.m_dummyPt1,this.m_dummyPt2)}tryMoveThroughCrossroadBackwards(t,e){const s=this.m_topoGraph.getHalfEdgePrev(t),i=this.m_topoGraph.getHalfEdgeTwin(s);if(!e){if(this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(t)))return v;const a=this.m_topoGraph.getHalfEdgeTwin(t);if(i===this.m_topoGraph.getHalfEdgeNext(a))return s}let n=i,o=v;for(;n!==t;){const a=this.getCombinedHalfEdgeParentage(n);if(this.isGoodParentage(a)){if(o!==v)return v;o=this.m_topoGraph.getHalfEdgeTwin(n)}n=this.m_topoGraph.getHalfEdgeTwin(this.m_topoGraph.getHalfEdgePrev(n))}return o}tryMoveThroughCrossroadForward(t,e){const s=this.m_topoGraph.getHalfEdgeNext(t),i=this.m_topoGraph.getHalfEdgeTwin(s);if(!e){const a=this.m_topoGraph.getHalfEdgeTwin(t);if(this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(a)))return v;if(i===this.m_topoGraph.getHalfEdgePrev(a))return s}let n=i,o=v;for(;n!==t;){const a=this.getCombinedHalfEdgeParentage(n);if(this.isGoodParentage(a)){if(o!==v)return v;o=this.m_topoGraph.getHalfEdgeTwin(n)}n=this.m_topoGraph.getHalfEdgeTwin(this.m_topoGraph.getHalfEdgeNext(n))}return o}isOnALoop(t,e){let s=t;const i=2*this.m_topoGraph.getShape().getTotalPointCount()+10;for(let n=0;n<i;n++){if(this.m_topoGraph.getHalfEdgeUserIndex(s,e)===1)return!1;const o=this.m_topoGraph.getHalfEdgeNext(s);if(o===this.m_topoGraph.getHalfEdgeTwin(s))return!1;if(s=o,s===t)return!0}$("is_on_a_loop_")}restorePolylineParts(t,e,s,i,n,o,a,h,m,l){b(n===v&&o>=0&&a>=0||o===-1&&a===-1),b(h===-1&&l.unsplitBehavior!==1||h!==-1&&l.unsplitBehavior===1);const u=l.ogcRule,c=l.allCrossRoadsImpassable,g=l.unsplitBehavior===1,_=l.unsplitBehavior===0,d=this.m_topoGraph.getShape(),p=d.hasSegmentParentage();let f=t,x=this.m_topoGraph.getHalfEdgeTwin(f);const E=new it;this.m_fromEdgeForPolylines=v;let P=this.prevailingDirection(d,f),C=f,S=v,I=!1,w=!1,D=!1;if(!g)for(;;){const at=this.m_topoGraph.getHalfEdgePrev(f);if(at===x){D=!0;break}const Q=this.m_topoGraph.getHalfEdgeNext(x);if(this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(Q))){I=!0;break}if(this.m_topoGraph.getHalfEdgeTwin(at)!==Q){if(c){I=!0;break}if(f=this.tryMoveThroughCrossroadBackwards(f,!0),f===v){I=!0;break}x=this.m_topoGraph.getHalfEdgeTwin(f)}else f=at,x=Q;if(this.m_topoGraph.getHalfEdgeUserIndex(f,s)===1){D=!0;break}if(f===t){S=t,w=!0;break}const rt=this.getCombinedHalfEdgeParentage(f);if(!this.isGoodParentage(rt))break;C=f,P+=this.prevailingDirection(d,f)}if(S===v){for(f=t,x=this.m_topoGraph.getHalfEdgeTwin(f),S=f;;){const Q=this.m_topoGraph.getHalfEdgeNext(f),rt=this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(Q));if(rt){I=!0;break}if(Q===x){D=!0;break}if(h!==-1){const Gt=this.m_topoGraph.getHalfEdgeOrigin(x);if(this.m_topoGraph.getClusterUserIndex(Gt,h)===1){I=!0;break}}const nt=this.m_topoGraph.getHalfEdgePrev(x);if(this.m_topoGraph.getHalfEdgeTwin(Q)!==nt){if(rt||c){I=!0;break}if(f=this.tryMoveThroughCrossroadForward(f,!0),f===v){I=!0;break}x=this.m_topoGraph.getHalfEdgeTwin(f)}else f=Q,x=nt;if(this.m_topoGraph.getHalfEdgeUserIndex(f,s)===1){D=!0;break}const ot=this.getCombinedHalfEdgeParentage(f);if(!this.isGoodParentage(ot))break;S=f,P+=this.prevailingDirection(d,f)}const at=this.m_topoGraph.getHalfEdgeOrigin(C);w=this.m_topoGraph.getHalfEdgeTo(S)===at}else if(this.m_fromEdgeForPolylines!==v){C=t,S=this.tryMoveThroughCrossroadBackwards(C,!1),b(S!==v);const at=this.m_topoGraph.getHalfEdgeTwin(C);this.m_topoGraph.getHalfEdgeNext(at)}let N=w;w||D||m&&(N=this.isOnALoop(t,s),N||(N=this.isOnALoop(x,s)));const A=P>=0;let M=!1;N&&I&&(w?(M=u,A&&(M||g||_)&&C!==t&&(b(!g),C=t,M=!1)):(g||A&&_)&&(C=t));let G=0;for(f=C;x=this.m_topoGraph.getHalfEdgeTwin(f),this.m_topoGraph.setHalfEdgeUserIndex(f,s,1),this.m_topoGraph.setHalfEdgeUserIndex(x,s,1),G++,f!==S;)f=c?this.m_topoGraph.getHalfEdgeNext(f):this.tryMoveThroughCrossroadForward(f,!1);A||(S=O(C,C=S),S=this.m_topoGraph.getHalfEdgeTwin(S),C=this.m_topoGraph.getHalfEdgeTwin(C));let q=d.insertPath(e,v);f=C;const V=this.m_topoGraph.getHalfEdgeOrigin(C);let k;k=o!==-1?this.chooseVertexByOrder(V,d,o,a):this.chooseVertexFromCluster_(V,n),this.m_topoGraph.isStrongPathNode(V)&&d.setStrongPathStart(q,!0);let Y=d.addVertex(q,k),U=Y;i!==-1&&this.m_topoGraph.setClusterUserIndex(V,i,1);let X=0;const B=M?Math.trunc((G+1)/2):-1;let W=v,Z=!0,gt=v;for(;;){if(p){const nt=this.m_topoGraph.getSegmentParentage(f),ot=this.m_topoGraph.getHalfEdgeOrigin(f);d.setSegmentParentageAndBreak(U,nt,Z||this.m_topoGraph.isBreakNode(ot))}Z=!1,this.m_topoGraph.isHalfEdgeCurve(f)&&(this.m_topoGraph.querySegmentXY(f,E),d.setSegmentToIndex(d.getVertexIndex(U),E.get().clone())),W!==v&&a!==-1&&d.addToUserIndex(W,a,-1);const at=c?this.m_topoGraph.getHalfEdgeNext(f):this.tryMoveThroughCrossroadForward(f,!1),Q=this.m_topoGraph.getHalfEdgeTo(f);let rt;if(rt=o!==-1?this.chooseVertexByOrder(Q,d,o,a):this.chooseVertexFromCluster_(Q,n),Y=d.addVertex(q,rt),gt=Q,i!==-1&&this.m_topoGraph.setClusterUserIndex(Q,i,1),p&&this.m_topoGraph.isBreakNode(Q)&&d.setSegmentParentageBreakVertex(Y,!0),W=rt,X++,M&&X===B&&(q=d.insertPath(e,v),Y=d.addVertex(q,rt),Z=!0,a!==-1&&d.addToUserIndex(rt,a,-1),W=v),f===S)break;f=at,U=Y}gt!==v&&this.m_topoGraph.isStrongPathNode(gt)&&d.setStrongPathEnd(q,!0)}topoOperationPolylineSimplify_(t,e){return this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(t,v,!1,e).first}topoOperationPolylineSimplifyOrPolylineTopoHelper_(t,e,s,i){b(e===v||t===v);const n=this.m_topoGraph.getShape(),o=_=>_=t===v?_===v?n.getFirstGeometry():n.getNextGeometry(_):_===v?t:v,a=n.createGeometry(T.enumPolyline);let h=-1;s&&(h=this.m_topoGraph.createUserIndexForClusters());const m=this.m_topoGraph.createUserIndexForHalfEdges(),l=e===v?n.createUserIndex():-1,u=e===v?n.createUserIndex():-1;let c=-1;if(i.unsplitBehavior===1){c=this.m_topoGraph.createUserIndexForClusters();for(let _=o(v);_!==v;_=o(_))for(let d=n.getFirstPath(_);d!==v;d=n.getNextPath(d)){{const p=n.getFirstVertex(d),f=this.m_topoGraph.getClusterFromVertex(p);this.m_topoGraph.setClusterUserIndex(f,c,1)}if(!n.isClosedPath(d)){const p=n.getLastVertex(d),f=this.m_topoGraph.getClusterFromVertex(p);this.m_topoGraph.setClusterUserIndex(f,c,1)}}}if(e===v){let _=0;for(let d=o(v);d!==v;d=o(d))for(let p=n.getFirstPath(d);p!==v;p=n.getNextPath(p))if(n.isClosedPath(p)){let f=n.getFirstVertex(p);for(let x=0,E=n.getPathSize(p);x<E;x++,f=n.getNextVertex(f))n.setUserIndex(f,l,_++),n.setUserIndex(f,u,2)}else{const f=n.getFirstVertex(p);n.setUserIndex(f,l,_++),n.setUserIndex(f,u,1);let x=n.getNextVertex(f);for(let E=1,P=n.getPathSize(p)-1;E<P;++E)n.setUserIndex(x,l,_++),n.setUserIndex(x,u,2),x=n.getNextVertex(x);n.setUserIndex(x,l,_++),n.setUserIndex(x,u,1)}}for(let _=o(v);_!==v;_=o(_))for(let d=n.getFirstPath(_);d!==v;d=n.getNextPath(d)){let p=n.getFirstVertex(d);for(let f=0,x=n.getPathSize(d);f<x;f++,p=n.getNextVertex(p)){const E=this.m_topoGraph.getHalfEdgeFromVertex(p);if(E===v||this.m_topoGraph.getHalfEdgeUserIndex(E,m)===1)continue;const P=this.getCombinedHalfEdgeParentage(E);if(this.isGoodParentage(P)){const C=f===0;this.restorePolylineParts(E,a,m,h,e,l,u,c,C,i)}}}let g=v;if(s){g=n.createGeometry(T.enumMultiPoint);let _=v;for(let d=this.m_topoGraph.getFirstCluster();d!==v;d=this.m_topoGraph.getNextCluster(d))if(this.progress_(),this.m_topoGraph.getClusterUserIndex(d,h)!==1){const p=this.m_topoGraph.getClusterParentage(d);if(this.isGoodParentage(p)){_===v&&(_=n.insertPath(g,v));const f=this.m_topoGraph.getClusterVertexIterator(d);if(f!==v){let x;this.m_topoGraph.getVertexFromVertexIterator(f),x=l!==-1?this.chooseVertexByOrder(d,n,l,u):this.chooseVertexFromCluster_(d,e),n.addVertex(_,x)}}}}return u!==-1&&n.removeUserIndex(u),l!==-1&&n.removeUserIndex(l),h!==-1&&n.removeUserIndex(h),this.m_topoGraph.deleteUserIndexForHalfEdges(m),te(a,g)}difference(t,e){const s=this.m_topoGraph.getShape().getGeometryType(t),i=this.m_topoGraph.getShape().getGeometryType(e),n=Be(s),o=Be(i);if(n>o)return t;const a=this.m_topoGraph.getGeometryID(t),h=this.m_topoGraph.getGeometryID(e);if(this.m_maskLookup.length=0,this.m_maskLookup.length=1+(a|h),this.m_maskLookup[a]=!0,n===2&&o===2){let m=v;return this.m_topoGraph.getShape().getVertexDescription().getAttributeCount()>1&&(m=t),this.topoOperationPolygonPolygon_(t,e,m)}if(n===1&&o===2){const m=Ni();return m.allCrossRoadsImpassable=!1,m.ogcRule=this.m_bOGCOutput,m.unsplitBehavior=0,this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(t,v,!1,m).first}if(n===1&&o===1){const m=Ni();return m.allCrossRoadsImpassable=!0,m.ogcRule=this.m_bOGCOutput,m.unsplitBehavior=0,this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(t,v,!1,m).first}if(n===0)return this.topoOperationMultiPoint_();$("")}symmetricDifference(t,e){const s=this.m_topoGraph.getShape().getGeometryType(t),i=this.m_topoGraph.getShape().getGeometryType(e),n=oo(s),o=oo(i),a=this.m_topoGraph.getGeometryID(t),h=this.m_topoGraph.getGeometryID(e);return b(a>=0),b(h>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=1+(a|h),this.m_maskLookup[a]=!0,this.m_maskLookup[a]=!0,this.m_maskLookup[h]=!0,n===2&&o===2?this.topoOperationPolygonPolygon_(t,e,v):n===1&&o===1?this.topoOperationPolyline_(v,this.m_bOGCOutput):n===0&&o===0?this.topoOperationMultiPoint():void $("")}planarSimplifyNoCrackingAndCluster(t,e,s,i){this.m_bOGCOutput=t,this.m_topoGraph=new gs;const n=e.getFillRule(s),o=e.getGeometryType(s);if(n!==1||o===T.enumMultiPoint?this.m_topoGraph.setAndSimplifyEditShapeAlternate(e,s,this.m_progressTracker):this.m_topoGraph.setAndSimplifyEditShapeWinding(e,s,this.m_progressTracker),this.m_topoGraph.dirtyCheckFailed())return!1;this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);const a=this.m_topoGraph.getGeometryID(s);if(b(a>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=a+1,this.m_maskLookup[a]=!0,e.getGeometryType(s)===T.enumPolygon||n===1&&e.getGeometryType(s)!==T.enumMultiPoint){e.setFillRule(s,0);const h=this.topoOperationPolygonPolygon_(s,v,v);if(e.swapGeometry(h,s),e.removeGeometry(h),n===1&&this.m_bOGCOutput)return this.planarSimplifyNoCrackingAndCluster(t,e,s,i)}else if(e.getGeometryType(s)===T.enumPolyline){const h=Ni();h.ogcRule=this.m_bOGCOutput,h.allCrossRoadsImpassable=!0,h.unsplitBehavior=i;const m=this.topoOperationPolylineSimplify_(e.getFirstGeometry(),h);e.swapGeometry(m,s),e.removeGeometry(m)}else if(e.getGeometryType(s)===T.enumMultiPoint){const h=this.topoOperationMultiPoint_();e.swapGeometry(h,s),e.removeGeometry(h)}else $("");return!0}unsplitPolylineExact(t){return b(0),new Pt}planarSimplifyPolylines(t,e,s,i,n){for(let g=t.getFirstGeometry();g!==v;g=t.getNextGeometry(g)){const _=t.getGeometryType(g);b(_===T.enumPolyline)}let o=0,a=0,h=null;if(t.hasCurves()&&!t.hasSegmentParentage()){h=new ts;const g=t.getEnvelope2D(this.m_progressTracker);a=Fs(e.total());const _=Je(e.total(),g);o=Ms(_,a),_s(t,_,e.total(),12e3,h,null,this.m_progressTracker)}{const g=U_(e.add(o));t.filterClosePoints(g,!1,!1,!1,v)}if(this.m_topoGraph=new gs,n!==4&&n!==5)if(h===null&&s){const g=new sm(this.m_progressTracker,!1);g.sweepVertical(t,e.total()),g.hadComplications()?(Ns(t,e,this.m_progressTracker,!0,!1),s=!1):this.m_topoGraph.setCheckDirtyPlanesweepTolerance(e.total())}else Ns(t,e.add(o),this.m_progressTracker,!0,!1),s=!1;else s=!1;t.removeSelection(),t.collapseAllGeometriesToFirst();const m=t.getFirstGeometry();if(this.m_topoGraph.setAndSimplifyEditShapeAlternate(t,m,this.m_progressTracker),this.m_topoGraph.dirtyCheckFailed())return b(s&&h===null),this.m_topoGraph.removeShape(),this.m_topoGraph=null,this.planarSimplifyPolylines(t,e,!1,i,-1);this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);const l=this.m_topoGraph.getGeometryID(m);b(l>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=l+1,this.m_maskLookup[l]=!0;const u=this.topoOperationPolylineSimplify_(t.getFirstGeometry(),i);h!==null&&h.stitchCurves(t,u,a,!0);const c=t.getGeometry(u);return s||c.getImpl().setIsSimple(4,e.total()),c}planarSimplifyMultiPoints(t,e,s,i){for(let m=t.getFirstGeometry();m!==v;m=t.getNextGeometry(m)){const l=t.getGeometryType(m);b(l===T.enumMultiPoint)}this.m_topoGraph=new gs,i!==4&&i!==5&&Ns(t,e,this.m_progressTracker,!0,!1),s=!1,t.removeSelection(),t.collapseAllGeometriesToFirst();const n=t.getFirstGeometry();if(this.m_topoGraph.setAndSimplifyEditShapeAlternate(t,n,this.m_progressTracker),this.m_topoGraph.dirtyCheckFailed())return b(s),this.m_topoGraph.removeShape(),this.m_topoGraph=null,this.planarSimplifyMultiPoints(t,e,!1,-1);this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);const o=this.m_topoGraph.getGeometryID(n);b(o>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=o+1,this.m_maskLookup[o]=!0;const a=this.topoOperationMultiPoint(),h=t.getGeometry(a);return s||h.getImpl().setIsSimple(4,e.total()),h}planarSimplifyPolygons(t,e,s,i,n,o){for(let p=t.getFirstGeometry();p!==v;p=t.getNextGeometry(p)){const f=t.getGeometryType(p);b(f===T.enumPolygon||f===T.enumPolyline&&s)}let a=0,h=0,m=null;if(t.hasCurves()&&!t.hasSegmentParentage()){m=new ts;const p=t.getEnvelope2D(this.m_progressTracker);h=Fs(e.total());const f=Je(e.total(),p);a=Ms(f,h),_s(t,f,e.total(),12e3,m,null,this.m_progressTracker)}if(o){Ns(t,e.add(a),this.m_progressTracker,!0,!1);for(let p=t.getFirstGeometry();p!==v;p=t.getNextGeometry(p))t.getGeometryType(p)===T.enumPolygon&&ii(t,p,-1,!1,v,this.m_progressTracker)}if(this.m_topoGraph=new gs,o||n===4||n===5)i=!1;else if(m===null&&i){const p=new sm(this.m_progressTracker,!1);p.sweepVertical(t,e.total()),p.hadComplications()?(Ns(t,e,this.m_progressTracker,!0,!1),i=!1):this.m_topoGraph.setCheckDirtyPlanesweepTolerance(e.total())}else Ns(t,e.add(a),this.m_progressTracker,!0,!1),i=!1;t.removeSelection(),t.collapseAllGeometriesToFirst();const l=t.getFirstGeometry();if(s?this.m_topoGraph.setAndSimplifyEditShapeWinding(t,l,this.m_progressTracker):this.m_topoGraph.setAndSimplifyEditShapeAlternate(t,l,this.m_progressTracker),this.m_topoGraph.dirtyCheckFailed())return b(i&&m===null),this.m_topoGraph.removeShape(),this.m_topoGraph=null,this.planarSimplifyPolygons(t,e,s,!1,-1,!1);this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);const u=this.m_topoGraph.getGeometryID(l);b(u>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=u+1,this.m_maskLookup[u]=!0,t.setFillRule(l,0);const c=this.m_bOGCOutput&&s,g=c;let _=this.topoOperationPolygonPolygon_(l,v,v,g);c&&(this.m_topoGraph.removeShape(),this.m_topoGraph=null,t.removeGeometry(l),this.m_topoGraph=new gs,this.m_topoGraph.setAndSimplifyEditShapeAlternate(t,_,this.m_progressTracker),_=this.topoOperationPolygonPolygon_(_,v,v,!1)),m!==null&&m.stitchCurves(t,_,h,!0);const d=t.getGeometry(_);return d.setFillRule(0),i?d.getImpl().setIsSimple(3,0):(d.getImpl().setIsSimple(4,e.total()),d.getImpl().updateOGCFlagsProtected()),d}planarSimplify3DImpl_(t,e,s,i,n){return b(0),{}}planarSimplifyImpl_(t,e,s,i,n,o,a,h){if(t.isEmpty())return t.clone();const m=t.getGeometryType(),l=new Lt,u=l.addGeometry(t);if(Ws(n)&&m===T.enumPolygon&&(s=!1,l.setFillRule(u,0)),h&&(t.hasAttribute(1)&&l.replaceNaNs(1,0),l.removeNaNVertices()),m===T.enumPolygon||m===T.enumPolyline&&s)return this.planarSimplifyPolygons(l,e,s,i,n,!1);if(m===Pt.type){const c=Ni();return c.allCrossRoadsImpassable=!0,c.ogcRule=this.m_bOGCOutput,c.unsplitBehavior=a,this.planarSimplifyPolylines(l,e,i,c,n)}if(m===T.enumMultiPoint)return this.planarSimplifyMultiPoints(l,e,i,n);$("what else?")}}function RP(r,t,e,s){if(r.isEmpty())return r.createInstance();if(t.isEmpty())return s?r.createInstance():new st({copy:r});const i=[new y],n=[0],o=t.getDimension()===2;return t.getDimension()!==1&&t.getDimension()!==2&&$(""),i[0]=r.getXY(),o?$m(t,i,1,e.total(),n):L_(t,i,1,e.total(),n),n[0]===0?r.createInstance():r}function kP(r,t,e,s){const i=r.createInstance(),n=R(y,100),o=new Array(100),a=r.getPointCount();let h=!0;const m=t.getDimension()===2;t.getDimension()!==1&&t.getDimension()!==2&&$("");for(let l=0;l<a;){const u=r.queryCoordinates(n,n.length,l,-1)-l;m?$m(t,n,u,e.total(),o):L_(t,n,u,e.total(),o);let c=0;for(let g=0;g<u;g++)o[g]===0&&(h&&(h=!1,i.addPoints(r,0,l)),c!==g&&i.addPoints(r,l+c,l+g),c=g+1);h||c===u||i.addPoints(r,l+c,l+u),l+=u}return h?r:i}function es(r,t,e,s){const i=r.getGeometryType();if(i===T.enumEnvelope){const n=new ct({vd:r.getDescription()});return r.isEmpty()||n.addEnvelope(r,!1),n}if(i===T.enumPoint&&(s==="|"||s==="^")){const n=new Zt({vd:r.getDescription()});return r.isEmpty()||n.add(r),n}if(i===T.enumLine){const n=new Pt({vd:r.getDescription()});return r.isEmpty()||n.addSegment(r,!0),n}if(i===T.enumMultiPoint&&s==="-"&&t.getGeometryType()===T.enumPoint){const n=new st({vd:r.getDescription()});return r.isEmpty()||r.getPointByVal(0,n),n}if(i===T.enumMultiPoint&&s==="&"&&t.getGeometryType()===T.enumPoint){const n=new st({vd:r.getDescription()});return r.isEmpty()||r.getPointByVal(0,n),n}return r}function ie(r){const t=r.getGeometryType();if(t===T.enumEnvelope){const e=new ct({vd:r.getDescription()});return r.isEmpty()||e.addEnvelope(r,!1),e}if(t===T.enumPoint){const e=new Zt({vd:r.getDescription()});return r.isEmpty()||e.add(r),e}if(wP(t)){const e=new Pt({vd:r.getDescription()});return r.isEmpty()||e.addSegment(r,!0),e}return t!==T.enumMultiPoint&&t!==T.enumPolyline&&t!==T.enumPolygon&&H("Unexpected geometry type"),r}function sh(r,t,e,s){const i=e===v?r.getClusterHalfEdge(t):e;let n=i;b(r.getHalfEdgeOrigin(i)===t);do s(n),n=r.getHalfEdgeNext(r.getHalfEdgeTwin(n));while(n!==i)}class LP{constructor(t,e,s,i,n,o){this.m_rParent=t,this.m_rTopoGraph=t.m_topoGraph,this.m_rShape=this.m_rTopoGraph.getShape(),this.m_IDCuttee=this.m_rTopoGraph.getGeometryID(i),this.m_IDCutter=this.m_rTopoGraph.getGeometryID(n),this.m_IDBoth=this.m_IDCuttee|this.m_IDCutter,this.m_bConsiderTouch=e,this.m_sideIndex=s,this.m_cuttee=i,this.m_cutter=n,this.m_rCutHandles=o,this.m_cutteeBreadcrumbsIndex=this.m_rShape.createUserIndexUninitialized(),this.m_clusterParentageIndex=this.m_rShape.createUserIndexUninitialized();for(let a=this.m_rShape.getFirstPath(this.m_cuttee);a!==v;a=this.m_rShape.getNextPath(a)){let h=0;const m=this.m_rShape.getPathSize(a);for(let l=this.m_rShape.getFirstVertex(a);h<m;h++,l=this.m_rShape.getNextVertex(l))this.m_rShape.setUserIndex(l,this.m_clusterParentageIndex,this.m_rTopoGraph.getClusterParentage(this.m_rTopoGraph.getClusterFromVertex(l)))}}Do(){this.cutPolylinePolyline_(),this.m_rShape.removeUserIndex(this.m_cutteeBreadcrumbsIndex),this.m_rShape.removeUserIndex(this.m_clusterParentageIndex)}setTbd(t){return 8|t}classifyStandardCut(t,e,s,i){const n=this.m_rShape.getPrevVertex(t),o=this.m_rShape.getNextVertex(t),a=n===v?v:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(n)),h=o===v?v:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(o)),m=this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(s)),l=this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(i));let u=1,c=32,g=32;if(sh(this.m_rTopoGraph,e,l,_=>{_===m&&(u=2),_===a&&(c=u),_===h&&(g=u)}),this.m_bConsiderTouch)c!==32&&this.m_rShape.setUserIndex(n,this.m_cutteeBreadcrumbsIndex,this.m_rShape.getUserIndex(n,this.m_cutteeBreadcrumbsIndex)|c),g!==32&&this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex)|g);else{if(c===32||g===32||c===g&&!(a===m||a===l||h===m||h===l))return 1;this.m_rShape.setUserIndex(n,this.m_cutteeBreadcrumbsIndex,this.m_rShape.getUserIndex(n,this.m_cutteeBreadcrumbsIndex)|c),this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex)|g)}return 0}classifyTouchCut(t,e,s,i){const n=this.m_rShape.getPrevVertex(t),o=this.m_rShape.getNextVertex(t),a=n===v?v:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(n)),h=o===v?v:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(o)),m=s===v?v:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(s)),l=i===v?v:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(i));if(!this.m_bConsiderTouch){let u;return(u=m===a||l===a)?this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))):(u=m===h||l===h)&&this.m_rShape.setUserIndex(n,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(n,this.m_cutteeBreadcrumbsIndex))),u?0:1}if(a===v)return this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))),0;if(h===v)return this.m_rShape.setUserIndex(n,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(n,this.m_cutteeBreadcrumbsIndex))),0;if(a===h)return this.m_rShape.setUserIndex(n,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(n,this.m_cutteeBreadcrumbsIndex))),this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))),0;if(l!==v){if(a===l)return this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))),0;if(h===l)return this.m_rShape.setUserIndex(n,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(n,this.m_cutteeBreadcrumbsIndex))),0;let u=1;sh(this.m_rTopoGraph,e,l,c=>{if(c===a){const g=this.m_rShape.getUserIndex(n,this.m_cutteeBreadcrumbsIndex)|u;this.m_rShape.setUserIndex(n,this.m_cutteeBreadcrumbsIndex,g),u=2}else if(c===h){const g=this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex)|u;this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,g),u=2}})}else{if(a===m)return this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))),0;if(h===m)return this.m_rShape.setUserIndex(n,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(n,this.m_cutteeBreadcrumbsIndex))),0;let u=2;sh(this.m_rTopoGraph,e,m,c=>{if(c===a){const g=this.m_rShape.getUserIndex(n,this.m_cutteeBreadcrumbsIndex)|u;this.m_rShape.setUserIndex(n,this.m_cutteeBreadcrumbsIndex,g),u=1}else if(c===h){const g=this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex)|u;this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,g),u=1}})}return 0}classifyCutVertex(t,e){let s=0,i=0;for(let n=this.m_rTopoGraph.getClusterVertexIterator(e);n!==v;n=this.m_rTopoGraph.incrementVertexIterator(n)){const o=this.m_rTopoGraph.getVertexFromVertexIterator(n);if(this.m_rShape.getGeometryFromVertex(o)===this.m_cutter){i++;const a=this.m_rShape.getPrevVertex(o),h=this.m_rShape.getNextVertex(o);s+=a===v||h===v?this.classifyTouchCut(t,e,a,h):this.classifyStandardCut(t,e,a,h)}}i&&s===i&&!this.m_bConsiderTouch&&this.m_rShape.setUserIndex(t,this.m_clusterParentageIndex,this.m_IDCuttee)}cutPolylinePolyline_(){this.m_rShape.getGeometryType(this.m_cuttee),this.m_rShape.getGeometryType(this.m_cutter),this.m_rParent.m_maskLookup.length=0,this.m_rParent.m_maskLookup.length=this.m_IDBoth+1,this.m_rParent.m_maskLookup[this.m_IDBoth]=!0;for(let a=this.m_rShape.getFirstPath(this.m_cuttee);a!==v;a=this.m_rShape.getNextPath(a)){const h=this.m_rShape.getPathSize(a);let m=this.m_rShape.getFirstVertex(a);for(let l=0;l<h;++l,m=this.m_rShape.getNextVertex(m))this.m_rShape.setUserIndex(m,this.m_cutteeBreadcrumbsIndex,0);m=this.m_rShape.getFirstVertex(a);for(let l=0;l<h;++l,m=this.m_rShape.getNextVertex(m)){const u=this.m_rTopoGraph.getClusterFromVertex(m);this.m_rTopoGraph.getClusterParentage(u)===this.m_IDBoth&&this.classifyCutVertex(m,u)}}const t=(a,h)=>{let m=this.m_rShape.getUserIndex(a,this.m_cutteeBreadcrumbsIndex);const l=this.m_rTopoGraph.getHalfEdgeConnector(this.m_rTopoGraph.getClusterFromVertex(a),this.m_rTopoGraph.getClusterFromVertex(h));return(this.m_rTopoGraph.getHalfEdgeParentage(l)&this.m_IDBoth)===this.m_IDBoth&&(m|=4),m};for(let a=this.m_rShape.getFirstPath(this.m_cuttee);a!==v;a=this.m_rShape.getNextPath(a)){let h=this.m_rShape.getFirstVertex(a);const m=this.m_rShape.isClosedPath(a),l=this.m_rShape.getPathSize(a)+(m?1:0);let u=1,c=32;for(let _=this.m_rShape.getNextVertex(h);u<l;++u,h=_,_=this.m_rShape.getNextVertex(_)){const d=t(h,_);this.m_rShape.getUserIndex(h,this.m_clusterParentageIndex)===this.m_IDBoth&&(c=d),c!==32&&this.m_rShape.setUserIndex(h,this.m_cutteeBreadcrumbsIndex,c|d)}h=this.m_rShape.getLastVertex(a);let g=32;u=1;for(let _=this.m_rShape.getPrevVertex(h);u<l;++u,h=_,_=this.m_rShape.getPrevVertex(_)){const d=t(_,h);this.m_rShape.getUserIndex(h,this.m_clusterParentageIndex)===this.m_IDBoth&&(g=d),g!==32&&this.m_rShape.setUserIndex(_,this.m_cutteeBreadcrumbsIndex,g|d)}}let e=v,s=v,i=32;const n=this.m_rShape.hasSegmentParentage(),o=new it;for(let a=this.m_rShape.getFirstPath(this.m_cuttee);a!==v;a=this.m_rShape.getNextPath(a)){const h=this.m_rShape.isClosedPath(a),m=this.m_rShape.getPathSize(a)+(h?1:0);let l=1,u=this.m_rShape.getFirstVertex(a),c=v,g=!0;for(let _=this.m_rShape.getNextVertex(u);l<m;++l,_=this.m_rShape.getNextVertex(_)){let d=this.m_rShape.getUserIndex(u,this.m_cutteeBreadcrumbsIndex);d===8?d=3:(d&=-9,4&d?d=4:3&~d||(d=3)),d!==i?(e!==v&&(c=this.m_rShape.addVertex(s,u),n&&this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(u))&&this.m_rShape.setSegmentParentageBreakVertex(c,!0),this.m_rCutHandles.push(e),this.m_rShape.setGeometryUserIndex(e,this.m_sideIndex,i)),e=this.m_rShape.createGeometry(T.enumPolyline),s=this.m_rShape.insertPath(e,v),i=d,g=!0):this.m_rShape.getUserIndex(u,this.m_clusterParentageIndex)===this.m_IDBoth&&d!==4&&(c=this.m_rShape.addVertex(s,u),n&&this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(u))&&this.m_rShape.setSegmentParentageBreakVertex(c,!0),s=this.m_rShape.insertPath(e,v),g=!0),c=this.m_rShape.addVertex(s,u);const p=this.m_rTopoGraph.getClusterFromVertex(u);!g&&n&&this.m_rTopoGraph.isBreakNode(p)&&this.m_rShape.setSegmentParentageBreakVertex(c,!0);const f=this.m_rTopoGraph.getHalfEdgeFromVertex(u);if(n){const x=this.m_rTopoGraph.getSegmentParentage(f);this.m_rShape.setSegmentParentageAndBreak(c,x,g||this.m_rTopoGraph.isBreakNode(p))}this.m_rTopoGraph.isHalfEdgeCurve(f)&&(this.m_rTopoGraph.querySegmentXY(f,o),this.m_rShape.setSegmentToIndex(this.m_rShape.getVertexIndex(c),o.get().clone())),u=_,g=!1}c=this.m_rShape.addVertex(s,u),n&&this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(u))&&this.m_rShape.setSegmentParentageBreakVertex(c,!0),this.m_rCutHandles.push(e),this.m_rShape.setGeometryUserIndex(e,this.m_sideIndex,i),e=v,s=v,i=32}}}function BP(r,t,e){return new je(e).linesToPolygonsImpl(r,t)}function HP(r,t,e,s,i){if(s&&(s.m_reason=0,s.m_vertexIndex1=-1,s.m_vertexIndex2=-1),r.isEmpty())return 5;const n=r.getGeometryType();if(n===T.enumPoint)return Br(r,s);const o=Oe(t,r,!1).total();if(n===T.enumEnvelope){const u=r,c=new F;return u.queryEnvelope(c),c.isDegenerate(o)?(s&&(s.m_reason=4,s.m_vertexIndex1=-1,s.m_vertexIndex2=-1),0):5}if(he(n)){const u=r,c=new Pt({vd:u.getDescription()});return c.addSegment(u,!0),jm(c,t,e,s,i)}const a=[0],h=r.getImpl().getIsSimple(o,a);let m=e?-1:h;if(yi(m)||m===0)return m;const l=new vs(r,t,m,i,!1);return n===T.enumMultiPoint||n===T.enumPolyline||n===T.enumPolygon?m=l.isSimplePlanarImpl():$(""),r.getImpl().setIsSimple(m,o),s&&s.assign(l.m_nonSimpleResult),m}function O_(r,t,e,s,i){if(s&&(s.m_reason=0,s.m_vertexIndex1=-1,s.m_vertexIndex2=-1),r.isEmpty())return 5;const n=r.getGeometryType();if(n===T.enumPoint)return Br(r,s);const o=Oe(t,r,!1).total();if(n===T.enumEnvelope){const u=r,c=new F;return u.queryEnvelope(c),c.isDegenerate(o)?(s&&(s.m_reason=4,s.m_vertexIndex1=-1,s.m_vertexIndex2=-1),0):5}if(he(n)){const u=r,c=new Pt({vd:u.getDescription()});return c.addSegment(u,!0),O_(c,t,e,s,i)}Pm(n),We(n)||ft("OGC simplify is not implemented for this geometry type");const a=[0],h=r.getImpl().getIsSimple(o,a);let m=e?-1:h;if(m===5||m===0)return m;const l=new vs(r,t,m,i,!0);return n===T.enumMultiPoint||n===T.enumPolyline||n===T.enumPolygon?(m=l.isSimplePlanarImpl(),yi(m)&&(m=5)):$(""),r.getImpl().setIsSimple(m,o),s&&s.assign(l.m_nonSimpleResult),m}function jm(r,t,e,s,i){if(s&&(s.m_reason=0,s.m_vertexIndex1=-1,s.m_vertexIndex2=-1),r.isEmpty())return 5;const n=r.getGeometryType();if(n===T.enumPoint)return Br(r,s);const o=Oe(t,r,!1).total();if(n===T.enumEnvelope){const u=r,c=F.constructEmpty();return u.queryEnvelope(c),c.isDegenerate(o)?(s&&(s.m_reason=4,s.m_vertexIndex1=-1,s.m_vertexIndex2=-1),0):5}if(he(n)){const u=r,c=new Pt({vd:u.getDescription()});return c.addSegment(u,!0),jm(c,t,e,s,i)}const a=[0],h=r.getImpl().getIsSimple(o,a);let m=e?-1:h;if(m!==-1)return m;const l=new vs(r,t,m,i,!1);return n===T.enumMultiPoint?m=l.multipointIsSimpleAsFeature():n===T.enumPolyline?m=l.polylineIsSimpleAsFeature():n===T.enumPolygon?m=l.polygonIsSimpleAsFeature():$(""),r.getImpl().setIsSimple(m,o),s&&s.assign(l.m_nonSimpleResult),m}function W_(r,t,e,s){if(r.isEmpty())return r;const i=r.getGeometryType();if(i===T.enumPoint){const u=new Tt;if(Br(r,u),u.m_reason===3){const c=r.clone();return c.replaceNaNs(1,0),c}return u.m_reason===2?r.createInstance():r}if(i===T.enumEnvelope){const u=Oe(t,r,!0).total(),c=r,g=F.constructEmpty();return c.queryEnvelope(g),g.isDegenerate(u)?c.createInstance():r}if(he(i)){const u=r,c=new Pt({vd:u.getDescription()});return c.addSegment(u,!0),W_(c,t,e,s)}Pm(i);const n=Oe(t,r,!1).total(),o=[0],a=r.getImpl().getIsSimple(n,o),h=e?-1:a;if(yi(h)){if(i===T.enumPolygon&&r.getFillRule()!==0){const u=r.clone();return u.setFillRule(0),u}return r}if((i===T.enumMultiPoint||i===T.enumPolyline)&&h>=1)return r;const m=new vs(r,t,h,s,!1);let l;return i===T.enumMultiPoint?l=m.multipointSimplifyAsFeature():i===T.enumPolyline?l=m.polylineSimplifyAsFeature():i===T.enumPolygon?l=m.polygonSimplifyAsFeature():$(""),l}function $_(r,t,e,s){if(r.isEmpty())return r;const i=r.getGeometryType();if(i===T.enumPoint){const m=new Tt;if(Br(r,m),m.m_reason===3){const l=r.clone();return l.replaceNaNs(1,0),l}return m.m_reason===2?r.createInstance():r}if(i===T.enumEnvelope){const m=r,l=new F;m.queryEnvelope(l);const u=Oe(t,r,!0).total();return l.isDegenerate(u)?m.createInstance():r}if(he(i)){const m=r,l=new Pt({vd:m.getDescription()});return l.addSegment(m,!0),$_(l,t,e,s)}Pm(i),We(i)||ft("OGC simplify is not implemented for this geometry type");const n=Oe(t,r,!1).total(),o=[0],a=r.getImpl().getIsSimple(n,o),h=e?-1:a;if(h===5){if(i===T.enumPolygon&&r.getFillRule()!==0){const m=r.clone();return m.setFillRule(0),m}return r}return im(r,Oe(t,r,!0),!1,h,s,0,!0)}function Br(r,t){const e=r.getX(),s=r.getY();if(!Number.isFinite(e)||!Number.isFinite(s))return t&&(t.m_reason=2,t.m_vertexIndex1=-1,t.m_vertexIndex2=-1),0;if(r.hasAttribute(1)){const i=r.getZ();if(!Number.isFinite(i))return t&&(t.m_reason=Number.isNaN(i)?3:2,t.m_vertexIndex1=-1,t.m_vertexIndex2=-1),0}return 5}class Cc{constructor(){this.m_segment=null,this.m_vertexIndex=-1,this.m_pathIndex=-1,this.m_flags=0}setReversed(t){this.m_flags&=-2,this.m_flags=this.m_flags|(t?1:0)}getReversed(){return!!(1&this.m_flags)}getRightSide(){return this.getReversed()?0:1}}function zP(){return{x:-1,y:-1,ipath:-1,ivertex:-1,ipolygon:-1}}function UP(r,t,e,s,i){return{x:r,y:t,ipath:e,ivertex:s,ipolygon:i}}function OP(r,t){return r.x===t.x&&r.y===t.y&&r.ipath===t.ipath&&r.ivertex===t.ivertex&&r.ipolygon===t.ipolygon}function WP(r,t){r.x=t.x,r.y=t.y,r.ipath=t.ipath,r.ivertex=t.ivertex,r.ipolygon=t.ipolygon}function $P(){return{x:-1,y:-1,ipath:-1,ivertex:-1,bBoundary:!1,bEndPoint:!1}}function jP(r,t,e,s,i,n){return{x:r,y:t,ipath:e,ivertex:s,bBoundary:i,bEndPoint:n}}function ZP(r,t){r.x=t.x,r.y=t.y,r.ipath=t.ipath,r.ivertex=t.ivertex,r.bBoundary=t.bBoundary,r.bEndPoint=t.bEndPoint}class QP extends tn{constructor(t){super(),this.m_helper=t}compare(t,e,s){const i=t.getElement(s),n=this.m_helper.m_xy.read(2*e)-this.m_helper.m_xy.read(2*i);return n<0?-1:n>0?1:0}}class KP extends tn{constructor(t){super(),this.m_helper=t}compare(t,e,s){const i=t.getElement(s),n=this.m_helper.m_edges[e],o=this.m_helper.m_edges[i],a=n.getReversed(),h=o.getReversed();let m=n.m_segment.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0),l=o.m_segment.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0);if(m===l){const u=a?n.m_segment.getStartY():n.m_segment.getEndY(),c=h?o.m_segment.getStartY():o.m_segment.getEndY(),g=Math.min(u,c);let _=.5*(g-this.m_helper.m_yScanline)+this.m_helper.m_yScanline;_===this.m_helper.m_yScanline&&(_=g),m=n.m_segment.intersectionOfYMonotonicWithAxisX(_,0),l=o.m_segment.intersectionOfYMonotonicWithAxisX(_,0)}return m<l?-1:m>l?1:0}}class vs{constructor(t,e,s,i,n){this.m_multiVertexGeom=null,this.m_edges=[],this.m_freeEdges=[],this.m_lineEdgesRecycle=[],this.m_newEdges=[],this.m_recycledSegIter=null,this.m_crossOverHelperList=new ge,this.m_progressTracker=null,this.m_progressCounter=0,this.m_AET=new tt,this.m_xyToNode1=null,this.m_xyToNode2=null,this.m_pathOrientations=null,this.m_pathParentage=null,this.m_xy=null,this.m_pairs=[],this.m_pairIndices=null,this.m_pathsForOGCTests=[],this.m_curveStitcher=null,this.m_editShape=null,this.m_multiPathStitcher=null,this.m_nonSimpleResult=new Tt,this.m_progressCounter=0,this.m_progressTracker=i,this.m_geometry=t,this.m_knownSimpleResult=s,this.m_sr=e;const o=Oe(e,t,!1);this.m_toleranceIsSimple=o,this.m_toleranceIsSimpleClustering=ss(o),this.m_toleranceIsSimpleCracking=vm(o),this.m_toleranceSimplify=Oe(e,t,!0),this.m_description=this.m_geometry.getDescription(),this.m_attributeCount=this.m_description.getAttributeCount(),this.m_bOGCRestrictions=n,this.m_bPlanarSimplify=this.m_bOGCRestrictions,this.m_unknownOrientationPathCount=-1,this.m_yScanline=0,this.m_progressCounter=0}isSimplePlanarImpl(){if(this.m_bPlanarSimplify=!0,!this.checkStructure())return 0;const t=this.m_geometry.getGeometryType();return lt(t)&&!this.checkDegenerateSegments(!1)?0:this._CheckClustering()?lt(t)?this._CheckCracking()?this.m_geometry.getGeometryType()===T.enumPolyline?this.checkSelfIntersectionsPolylinePlanar()?4:0:this._CheckSelfIntersections()?this._CheckValidRingOrientation():0:0:5:0}isSimplePlanarImpl3D(){return b(0),7}generateSortedPairs(t){let e=null;lt(t.getGeometryType())&&(e=t);const s=(this.m_bPlanarSimplify||this.m_bOGCRestrictions)&&e!==null,i=t.getPointCount();this.m_xy=t.getAttributeStreamRef(0),this.m_pairs.length=0,this.m_pairIndices=new Xt(0),s&&(this.m_pathsForOGCTests.length=0);let n=0;for(let h=0;h<i;h++)if(this.m_pairs.push(2*h),this.m_pairs.push(2*h+1),this.m_pairIndices.add(2*h),this.m_pairIndices.add(2*h+1),s){for(;h>=e.getPathEnd(n);)n++;this.m_pathsForOGCTests.push(n)}const o=new Ys,a={parent:this,workPt:new y,userSort(h,m,l){l.sort(h,m,(u,c)=>this.parent.compareVerticesForPlanarClustering(u,c,s))},getValue(h){const m=this.parent.m_pairs[h],l=m>>1;return this.parent.m_xy.queryPoint2D(2*l,this.workPt),this.workPt.y+(1&m?this.parent.m_toleranceIsSimpleClustering:-this.parent.m_toleranceIsSimpleClustering)}};o.sort(this.m_pairIndices,0,2*i,a)}_TestToleranceDistancePlanar(t,e){const s=this.m_xy.read(2*t),i=this.m_xy.read(2*t+1),n=this.m_xy.read(2*e),o=this.m_xy.read(2*e+1);return zm(s,i,n,o,this.m_toleranceIsSimpleClustering*this.m_toleranceIsSimpleClustering)?this.m_geometry.getDimension()===0?!1:s===n&&i===o:!0}checkStructure(){const t=this.m_geometry.getGeometryType();if(lt(t)){const e=this.m_geometry.getImpl(),s=this.m_geometry.getGeometryType()===T.enumPolygon?3:2;for(let i=0,n=e.getPathCount();i<n;i++)if(e.getPathSize(i)<s){if(e.hasNonLinearSegments()&&e.hasNonLinearSegmentsPath(i)&&e.getPathSize(i)>0)continue;return this.m_nonSimpleResult=new Tt(1,i,0),!1}}if(We(t)){const e=this.m_geometry.getImpl(),s=e.getAttributeStreamRef(0);for(let i=0,n=e.getPointCount();i<n;i++)if(!s.readPoint2D(2*i).isFinite())return this.m_nonSimpleResult=new Tt(2,i,0),!1;if(this.m_geometry.hasAttribute(1)){const i=e.getAttributeStreamRef(1);for(let n=0,o=e.getPointCount();n<o;n++){const a=i.read(n);if(!Number.isFinite(a))return Number.isNaN(a)?this.m_nonSimpleResult=new Tt(3,n,0):this.m_nonSimpleResult=new Tt(2,n,0),!1}}}return!0}checkDegenerateSegments(t){const e=this.m_geometry.getImpl(),s=e.querySegmentIterator(),i=e.hasAttribute(1),n=i?Dl(this.m_sr,e,!1).total():0,o=e.hasNonLinearSegments(),a=this.m_toleranceIsSimple.total();for(;s.nextPath();)for(;s.hasNextSegment();){const h=s.nextSegment();let m=h.calculateLowerLength2D();if(!(m>a)&&!(o&&h.isCurve()&&(m=h.calculateLength2D(),m>a))){if(t&&i){const l=h.getStartAttributeAsDbl(1,0),u=h.getEndAttributeAsDbl(1,0);if(Math.abs(u-l)>n)continue}return this.m_nonSimpleResult=new Tt(4,s.getStartPointIndex(),-1),!1}}return!0}checkDegenerateSegments3D(){return b(0),!1}_CheckClustering(){const t=this.m_geometry.getImpl();this.generateSortedPairs(t);const e=t.getPointCount();this.m_AET.clear(),this.m_AET.setComparator(new QP(this)),this.m_AET.setCapacity(e);for(let s=0,i=2*e;s<i;s++){this.progress_();const n=this.m_pairIndices.read(s),o=this.m_pairs[n],a=o>>1;if(1&o){const h=this.m_AET.search(a),m=this.m_AET.getPrev(h),l=this.m_AET.getNext(h);if(this.m_AET.deleteNode(h),m!==tt.st_nullNode()&&l!==tt.st_nullNode()&&!this._TestToleranceDistancePlanar(this.m_AET.getElement(m),this.m_AET.getElement(l)))return this.m_nonSimpleResult=new Tt(5,this.m_AET.getElement(m),this.m_AET.getElement(l)),!1}else{const h=this.m_AET.addElement(a),m=this.m_AET.getPrev(h);if(m!==tt.st_nullNode()&&!this._TestToleranceDistancePlanar(this.m_AET.getElement(m),a))return this.m_nonSimpleResult=new Tt(5,a,this.m_AET.getElement(m)),!1;const l=this.m_AET.getNext(h);if(l!==tt.st_nullNode()&&!this._TestToleranceDistancePlanar(this.m_AET.getElement(l),a))return this.m_nonSimpleResult=new Tt(5,a,this.m_AET.getElement(l)),!1}}return!0}_CheckCracking(){const t=this.m_geometry.getImpl(),e=t.getPointCount();return!t.hasNonLinearSegments()&&e<10?this._CheckCrackingBrute():this._CheckCrackingPlanesweep()}_CheckCrackingPlanesweep(){if(this.m_editShape=new Lt,this.m_editShape.addGeometry(this.m_geometry),this.m_editShape.hasCurves()){this.m_curveStitcher=new ts;const e=F.constructEmpty();this.m_geometry.queryEnvelope(e);const s=Je(this.m_toleranceSimplify.total(),e),i=new Tt;if(B_(this.m_editShape,s,this.m_toleranceSimplify.total(),12e3,i,this.m_curveStitcher,null,this.m_progressTracker),i.m_reason!==0)return this.m_editShape=null,this.m_nonSimpleResult.assign(i),!1}const t=new Tt;return Um(!1,this.m_editShape,this.m_toleranceIsSimpleCracking,t,this.m_progressTracker)?(this.m_curveStitcher!=null?(t.m_vertexIndex1=this.m_curveStitcher.getOriginalVertexIndex(this.m_editShape,t.m_vertexIndex1),t.m_vertexIndex2=this.m_curveStitcher.getOriginalVertexIndex(this.m_editShape,t.m_vertexIndex2),this.m_curveStitcher=null):(t.m_vertexIndex1=this.m_editShape.getVertexIndex(t.m_vertexIndex1),t.m_vertexIndex2=this.m_editShape.getVertexIndex(t.m_vertexIndex2)),this.m_editShape=null,this.m_nonSimpleResult.assign(t),!1):(this.m_curveStitcher==null&&(this.m_editShape=null),!0)}_CheckCrackingBrute(){const t=this.m_geometry.getImpl(),e=t.querySegmentIterator(),s=t.querySegmentIterator();for(;e.nextPath();)for(;e.hasNextSegment();){const i=e.nextSegment();if(!e.isLastSegmentInPath()||!e.isLastPath()){s.resetTo(e);do for(;s.hasNextSegment();){const n=s.nextSegment(),o=Gn(!0,i,n,this.m_toleranceIsSimpleCracking,!0);if(o){const a=o===2?7:6;return this.m_nonSimpleResult=new Tt(a,e.getStartPointIndex(),s.getStartPointIndex()),!1}}while(s.nextPath())}}return!0}_CheckSelfIntersections(){let t=this.m_geometry.getImpl();this.m_curveStitcher!==null&&(this.m_multiPathStitcher=this.m_editShape.getGeometry(this.m_editShape.getFirstGeometry()),t=this.m_multiPathStitcher.getImpl(),this.generateSortedPairs(t)),this.m_edges.length=0,this.m_lineEdgesRecycle.length=0,this.m_recycledSegIter=t.querySegmentIterator(),this.m_recycledSegIter.setCirculator(!0);const e=[],s=t.getPointCount();let i=Number.NaN,n=0;for(let o=0,a=2*s;o<a;o++){this.progress_();const h=this.m_pairIndices.read(o),m=this.m_pairs[h];if(1&m)continue;const l=m>>1,u=this.m_xy.read(2*l),c=this.m_xy.read(2*l+1);if(e.length&&(u!==i||c!==n)){if(!this.processBunchForSelfIntersectionTest(e))return!1;e.length=0}e.push(l),i=u,n=c}return!!this.processBunchForSelfIntersectionTest(e)}checkSelfIntersectionsPolylinePlanar(){const t=this.m_geometry.getImpl(),e=[];for(let a=0,h=t.getPathCount();a<h;a++)e.push(t.isClosedPathInXYPlane(a));const s=$P();let i,n,o;{const a=this.m_pairIndices.read(0),h=this.m_pairs[a]>>1,m=this.m_xy.readPoint2D(2*h),l=this.m_pathsForOGCTests[h];i=e[l],n=t.getPathStart(l),o=t.getPathEnd(l)-1,s.bEndPoint=h===n||h===o,this.m_bOGCRestrictions?s.bBoundary=!i&&s.bEndPoint:s.bBoundary=s.bEndPoint,s.ipath=l,s.x=m.x,s.y=m.y,s.ivertex=h}for(let a=1,h=this.m_pairIndices.size();a<h;a++){const m=this.m_pairIndices.read(a),l=this.m_pairs[m];if(1&l)continue;const u=l>>1,c=this.m_xy.readPoint2D(2*u),g=this.m_pathsForOGCTests[u];let _;g!==s.ipath&&(i=e[g],n=t.getPathStart(g),o=t.getPathEnd(g)-1);const d=u===n||u===o;_=this.m_bOGCRestrictions?!i&&d:d;const p=jP(c.x,c.y,g,u,_,d);if(p.x===s.x&&p.y===s.y){if(this.m_bOGCRestrictions){if(!(p.bBoundary&&s.bBoundary||p.ipath===s.ipath&&p.bEndPoint&&s.bEndPoint))return this.m_nonSimpleResult=new Tt(10,p.ivertex,s.ivertex),!1}else if(!p.bEndPoint||!s.bEndPoint)return this.m_nonSimpleResult=new Tt(7,p.ivertex,s.ivertex),!1}ZP(s,p)}return!0}checkSelfIntersectionsPolylinePlanar3D(t){return b(0),!1}checkSelfIntersectionsPolygonsOGC(){const t=this.m_geometry.getImpl(),e=[];let s=-1,i=!1;for(let u=0,c=t.getPathCount();u<c;u++)t.isExteriorRingOGC(u)&&(i=!1,s++,u<c-1&&(t.isExteriorRingOGC(u+1)||(i=!0))),e.push(i?s:-1);const n=zP();{const u=this.m_pairIndices.read(0),c=this.m_pairs[u]>>1,g=this.m_xy.readPoint2D(2*c),_=this.m_pathsForOGCTests[c];n.ipath=_,n.x=g.x,n.y=g.y,n.ivertex=c,n.ipolygon=e[_]}const o=[];for(let u=1,c=this.m_pairIndices.size();u<c;u++){const g=this.m_pairIndices.read(u),_=this.m_pairs[g];if(1&_)continue;const d=_>>1,p=this.m_xy.readPoint2D(2*d),f=this.m_pathsForOGCTests[d],x=UP(p.x,p.y,f,d,e[f]);if(x.x===n.x&&x.y===n.y){if(x.ipath===n.ipath)return this.m_nonSimpleResult=new Tt(11,x.ivertex,n.ivertex),!1;e[x.ipath]>=0&&e[x.ipath]===e[n.ipath]&&(o.length!==0&&OP(o.at(-1),n)||o.push({...n}),o.push(x))}WP(n,x)}if(o.length===0)return!0;const a=new ge(!0);e.fill(-1);let h=-1;const m=new y;for(let u=0,c=o.length;u<c;u++){const g=o[u];g.x===m.x&&g.y===m.y||(h=a.createList(0),m.x=g.x,m.y=g.y);let _=e[g.ipath];_===-1&&(_=a.createList(2),e[g.ipath]=_),a.addElement(_,h),a.addElement(h,_)}const l=[];for(let u=a.getFirstList();u!==-1;u=a.getNextList(u)){const c=a.getListData(u);if(1&c||!(2&c))continue;let g=-1;for(l.push(u),l.push(-1);l.length;){const _=l.at(-1);l.pop();const d=l.at(-1);l.pop();const p=a.getListData(d);if(1&p){g=2&p?d:_;break}a.setListData(d,1|p);for(let f=a.getFirst(d);f!==-1;f=a.getNext(f)){const x=a.getData(f);x!==_&&(l.push(x),l.push(d))}}if(g!==-1){const _=e.indexOf(g);return this.m_nonSimpleResult=new Tt(12,_,-1),!1}}return!0}_CheckValidRingOrientation(){const t=this.m_multiPathStitcher!==null?this.m_multiPathStitcher.getImpl():this.m_geometry.getImpl();if(t.calculateArea2D()<=0)return this.m_nonSimpleResult=new Tt(8,t.getPathCount()===1?1:-1,-1),0;if(t.getPathCount()===1)return this.m_bOGCRestrictions&&!this.checkSelfIntersectionsPolygonsOGC()?0:4;this.m_pathOrientations=new yn(t.getPathCount(),0),this.m_pathParentage=new Xt(t.getPathCount(),-1);let e=-1,s=0;for(let o=0,a=t.getPathCount();o<a;o++){const h=t.calculateRingArea2D(o);if(this.m_pathOrientations.write(o,h<0?0:8),h>0)e=o,s=h;else{if(h===0)return this.m_nonSimpleResult=new Tt(8,o,-1),0;if((e<0||s<Math.abs(h))&&(this.m_nonSimpleResult=new Tt(9,o,-1),this.m_bOGCRestrictions))return 0;this.m_pathParentage.write(o,e)}}this.m_unknownOrientationPathCount=t.getPathCount(),this.m_newEdges.length=0;const i=t.getPointCount();this.m_yScanline=Number.NaN;const n=[];this.m_xyToNode1=new Xt(i,tt.st_nullNode()),this.m_xyToNode2=new Xt(i,tt.st_nullNode()),this.m_freeEdges.length=0,this.m_AET.clear(),this.m_AET.setComparator(new KP(this));for(let o=0,a=2*i;this.m_unknownOrientationPathCount>0&&o<a;o++){const h=this.m_pairIndices.read(o),m=this.m_pairs[h];if(1&m)continue;const l=m>>1,u=this.m_xy.read(2*l+1);if(u!==this.m_yScanline&&n.length){if(!this.processBunchForRingOrientationTest(n))return 0;n.length=0}n.push(l),this.m_yScanline=u}return this.m_unknownOrientationPathCount>0&&!this.processBunchForRingOrientationTest(n)?0:this.m_bOGCRestrictions?this.m_nonSimpleResult.m_reason!==0?0:this.checkSelfIntersectionsPolygonsOGC()?5:0:this.m_nonSimpleResult.m_reason===0?4:3}processBunchForSelfIntersectionTest(t){if(t.length===1)return!0;for(let a=0,h=t.length;a<h;a++){const m=t[a];this.m_recycledSegIter.resetToVertex(m,-1);const l=this.m_recycledSegIter.previousSegment();this.m_edges.push(this.createEdge(l,m,this.m_recycledSegIter.getPathIndex(),!0)),this.m_recycledSegIter.nextSegment();const u=this.m_recycledSegIter.nextSegment();this.m_edges.push(this.createEdge(u,m,this.m_recycledSegIter.getPathIndex(),!1))}this.m_edges.sort((a,h)=>this.edgeAngleCompare(a,h));let e=this.m_crossOverHelperList.getFirstList();e===-1&&(e=this.m_crossOverHelperList.createList(0)),this.m_crossOverHelperList.reserveNodes(this.m_edges.length);for(let a=0,h=this.m_edges.length;a<h;a++)this.m_crossOverHelperList.addElement(e,a);let s=!0,i=-1,n=-1;for(;s;){s=!1;let a=this.m_crossOverHelperList.getFirst(e);if(a===-1)break;let h=this.m_crossOverHelperList.getNext(a);for(;h!==-1;){const m=this.m_crossOverHelperList.getData(a),l=this.m_crossOverHelperList.getData(h);if(i=this.m_edges[m].m_vertexIndex,n=this.m_edges[l].m_vertexIndex,i!==n)a=h,h=this.m_crossOverHelperList.getNext(a);else if(s=!0,this.m_crossOverHelperList.deleteElement(e,a),a=this.m_crossOverHelperList.getPrev(h),h=this.m_crossOverHelperList.deleteElement(e,h),h===-1||a===-1)break}}const o=this.m_crossOverHelperList.getListSize(e);if(this.m_crossOverHelperList.clear(e),o>0)return this.m_nonSimpleResult=new Tt(7,i,n),!1;for(let a=0,h=t.length;a<h;a++)this.recycleEdge(this.m_edges[a]);return this.m_edges.length=0,!0}processBunchForRingOrientationTest(t){for(let e=0,s=t.length;e<s;e++){const i=t[e];let n=this.m_xyToNode1.read(i);if(n!==tt.st_nullNode()){const o=this.m_AET.getElement(n);this.m_freeEdges.push(o),this.m_AET.deleteNode(n),this.recycleEdge(this.m_edges[o]),this.m_edges[o]=null,this.m_xyToNode1.write(i,tt.st_nullNode())}if(n=this.m_xyToNode2.read(i),n!==tt.st_nullNode()){const o=this.m_AET.getElement(n);this.m_freeEdges.push(o),this.m_AET.deleteNode(n),this.recycleEdge(this.m_edges[o]),this.m_edges[o]=null,this.m_xyToNode2.write(i,tt.st_nullNode())}}for(let e=0,s=t.length;e<s;e++){const i=t[e];this.m_recycledSegIter.resetToVertex(i,-1);const n=this.m_recycledSegIter.previousSegment();if(n.getStartY()>n.getEndY()){const a=this.m_recycledSegIter.getStartPointIndex(),h=this.createEdge(n,i,this.m_recycledSegIter.getPathIndex(),!0);let m;this.m_freeEdges.length>0?(m=this.m_freeEdges.at(-1),this.m_freeEdges.pop(),this.m_edges[m]=h):(m=this.m_edges.length,this.m_edges.push(h));const l=this.m_AET.addElement(m);this.m_xyToNode1.read(a)===tt.st_nullNode()?this.m_xyToNode1.write(a,l):this.m_xyToNode2.write(a,l),3&this.m_pathOrientations.read(this.m_recycledSegIter.getPathIndex())||this.m_newEdges.push(l)}this.m_recycledSegIter.nextSegment();const o=this.m_recycledSegIter.nextSegment();if(o.getStartY()<o.getEndY()){const a=this.m_recycledSegIter.getEndPointIndex(),h=this.createEdge(o,i,this.m_recycledSegIter.getPathIndex(),!1);let m;this.m_freeEdges.length>0?(m=this.m_freeEdges.at(-1),this.m_freeEdges.pop(),this.m_edges[m]=h):(m=this.m_edges.length,this.m_edges.push(h));const l=this.m_AET.addElement(m);this.m_xyToNode1.read(a)===tt.st_nullNode()?this.m_xyToNode1.write(a,l):this.m_xyToNode2.write(a,l),3&this.m_pathOrientations.read(this.m_recycledSegIter.getPathIndex())||this.m_newEdges.push(l)}}for(let e=0,s=this.m_newEdges.length;e<s&&this.m_unknownOrientationPathCount>0;e++){const i=this.m_newEdges[e],n=this.m_AET.getElement(i),o=this.m_edges[n].m_pathIndex;if(!(3&this.m_pathOrientations.read(o))){let a=-1,h=this.m_AET.getPrev(i),m=i,l=0;{let u=-1,c=null,g=-1,_=0;for(;h!==tt.st_nullNode()&&(u=this.m_AET.getElement(h),c=this.m_edges[u],g=c.m_pathIndex,_=this.m_pathOrientations.read(g),!(3&_));)m=h,h=this.m_AET.getPrev(h);h===tt.st_nullNode()?(l=1,h=m):(a=(3&_)==1?g:this.m_pathParentage.read(g),l=c.getRightSide()?0:1,h=this.m_AET.getNext(h))}do{const u=this.m_AET.getElement(h),c=this.m_edges[u],g=c.m_pathIndex;let _=this.m_pathOrientations.read(g);if(!(3&_)){if(l!==c.getRightSide())return this.m_nonSimpleResult=new Tt(8,g,-1),!1;const d=l&&!c.getReversed()?1:2;if(_=-4&_|d,this.m_pathOrientations.write(g,_),d===2&&this.m_nonSimpleResult.m_reason===0){const p=this.m_pathParentage.read(g);if(p!==a&&(this.m_nonSimpleResult=new Tt(9,g,p),this.m_bOGCRestrictions))return!1}if(this.m_unknownOrientationPathCount--,!this.m_unknownOrientationPathCount)return!0}a=(3&_)==1?g:this.m_pathParentage.read(g),m=h,h=this.m_AET.getNext(h),l=l?0:1}while(m!==i)}}return this.m_newEdges.length=0,!0}createEdge(t,e,s,i){let n;return t.getGeometryType()===T.enumLine?n=this.createEdgeLine(t):(n=new Cc,n.m_segment=t.clone()),n.m_vertexIndex=e,n.m_pathIndex=s,n.m_flags=0,n.setReversed(i),n}createEdgeLine(t){let e;return this.m_lineEdgesRecycle.length>0?(e=this.m_lineEdgesRecycle.at(-1),this.m_lineEdgesRecycle.pop(),t.copyTo(e.m_segment)):(e=new Cc,e.m_segment=t.clone()),e}recycleEdge(t){t.m_segment.getGeometryType()===T.enumLine&&this.m_lineEdgesRecycle.push(t)}static isShortSegment(t,e,s,i){let n=t.calculateLowerLength2D();if(n<=s){let o=!0;if(t.isCurve()&&(n=t.calculateLength2D(),o=n<=s),o){if(e){let a=t.getEndAttributeAsDbl(1,0);Number.isNaN(a)&&(a=0);let h=t.getStartAttributeAsDbl(1,0);return Number.isNaN(h)&&(h=0),Math.abs(h-a)<=i}return!0}return!1}return!1}static isShortSegmentPoints(t,e,s,i,n){if(s){const o=t.getXYZ(),a=e.getXYZ();return Ep(o,a,i,n)}{const o=t.getXY(),a=e.getXY();return y.sqrDistance(o,a)<=i*i}}removeDegenerateSegmentsFromCurvedPath(t,e,s,i){const n=t.hasAttribute(1),o=t.querySegmentIterator();o.resetToPath(e),b(o.nextPath());const a=this.m_toleranceSimplify.total();let h=!1,m=!0;const l=new st,u=new st,c=new y;for(;o.hasNextSegment();){this.progress_();const d=o.nextSegment();if(vs.isShortSegment(d,n,a,s))if(h){if(d.queryEnd(u),vs.isShortSegmentPoints(l,u,n,a,s))continue;m&&(i.startPathPoint(l),m=!1),d.queryEnd(l),i.lineToPoint(l),h=!1}else c.assign(d.getStartXY()),d.queryStart(l),h=!0;else if(h)if(d.isCurve()){const p=d.clone();if(p.setCoordsForIntersector(c,d.getEndXY(),!1),p.setStart(l),vs.isShortSegment(p,n,a,s))continue;i.addSegment(p,m),m=!1,h=!1}else{if(d.queryEnd(u),vs.isShortSegmentPoints(l,u,n,a,s))continue;m&&(i.startPathPoint(l),m=!1),i.lineToPoint(u),h=!1}else i.addSegment(d,m),m=!1}if(m||!h)return;t.isClosedPath(e)?t.getPointByVal(t.getPathStart(e),l):t.getPointByVal(t.getPathEnd(e)-1,l);const g=i.querySegmentIterator();g.resetToLastPath(),g.resetToLastSegment();const _=i.getDescription().getAttributeCount()>1;for(b(g.previousPath());g.hasPreviousSegment();){const d=g.previousSegment();if(d.isCurve()){const p=d.clone();if(p.setCoordsForIntersector(d.getStartXY(),l.getXY(),!1),!vs.isShortSegment(p,n,a,s)){_&&p.setEnd(l);const f=g.getEndPointIndex();for(let x=i.getPointCount()-1;x>=f;x--)i.removePoint(x);return void i.addSegment(p,!1)}}else if(d.queryStart(u),!vs.isShortSegmentPoints(u,l,n,a,s)){const p=g.getEndPointIndex();for(let f=i.getPointCount()-1;f>=p;f--)i.removePoint(f);return void i.lineToPoint(l)}}i.removePath(i.getPathCount()-1)}multipointIsSimpleAsFeature(){if(!this.checkStructure())return 0;const t=this.m_geometry.getImpl();this.m_multiVertexGeom=t;const e=t.getPointCount(),s=j(e,0);for(let i=0;i<e;i++)s[i]=i;s.sort((i,n)=>this.compareVerticesMultiPoint(i,n));for(let i=1;i<e;i++)if(this.compareVerticesMultiPoint(s[i-1],s[i])===0)return this.m_nonSimpleResult=new Tt(5,s[i-1],s[i]),0;return 1}polylineIsSimpleAsFeature(){return this.checkStructure()&&this.checkDegenerateSegments(!0)?1:0}polygonIsSimpleAsFeature(){return this.isSimplePlanarImpl()}multipointSimplifyAsFeature(){let t=this.m_geometry.getImpl();const e=vs.hasNanZs(t);let s,i=this.m_geometry;e&&(s=this.m_geometry.clone(),t=s.getImpl(),s.replaceNaNs(1,Mt.getDefaultValue(1)),i=s),this.m_multiVertexGeom=t;const n=t.getPointCount(),o=j(n,0);for(let c=0;c<n;c++)o[c]=c;o.sort((c,g)=>this.compareVerticesMultiPoint(c,g));const a=new Array(n);a.fill(!1);let h=-1;for(let c=0;c<n;c++){const g=o[c];t.getXY(g).isFinite()&&((h<0||this.compareVerticesMultiPoint(h,g)!==0)&&(a[g]=!0),h=g)}const m=this.m_geometry.createInstance();let l=0,u=0;for(let c=0;c<n;c++)a[c]?u=c+1:(l<u&&m.addPoints(i,l,u),l=c+1);return l<u&&m.addPoints(i,l,u),m.getImpl().setIsSimple(1,this.m_toleranceSimplify.total()),m}polylineSimplifyAsFeature(){const t=this.m_geometry.getImpl(),e=t.querySegmentIterator(),s=t.querySegmentIterator(),i=this.m_geometry.createInstance(),n=this.m_geometry,o=t.hasAttribute(1),a=o?Dl(this.m_sr,t,!0).total():0,h=[],m=[];let l=null;o&&(l=t.getAttributeStreamRef(1));const u=new st,c=t.hasNonLinearSegments(),g=this.m_toleranceSimplify.total();for(;e.nextPath();){if(s.nextPath(),t.getPathSize(e.getPathIndex())<2)continue;if(c&&t.hasNonLinearSegmentsPath(e.getPathIndex())){this.removeDegenerateSegmentsFromCurvedPath(t,e.getPathIndex(),a,i);continue}s.resetToLastSegment();let _=0,d=0,p=!0,f=!0;for(;e.hasNextSegment();){this.progress_();const x=e.nextSegment(),E=s.previousSegment();if(e.getStartPointIndex()>s.getStartPointIndex())break;if(p){const P=e.getStartPointIndex();t.getXY(P).isNAN()||(p=!1,h.push(P))}if(f){const P=s.getEndPointIndex();t.getXY(P).isNAN()||(m.push(P),f=!1)}if(!p){const P=h.at(-1),C=e.getEndPointIndex();if(C-P>1){const S=new y;S.setSub(t.getXY(P),t.getXY(C)),_=S.length()}else _=x.calculateLength2D();if(_>g)h.push(C),_=0;else if(o){let S=l.read(P);Number.isNaN(S)&&(S=0);let I=l.read(C);Number.isNaN(I)&&(I=0),Math.abs(I-S)>a&&(h.push(C),_=0)}}if(!f){const P=m.at(-1),C=s.getStartPointIndex();if(C-P>1){const S=new y;S.setSub(t.getXY(P),t.getXY(C)),d=S.length()}else d=E.calculateLength2D();if(d>g)m.push(C),d=0;else if(o){let S=l.read(P);Number.isNaN(S)&&(S=0);let I=l.read(C);Number.isNaN(I)&&(I=0),Math.abs(I-S)>a&&(m.push(C),d=0)}}}if(h.length>0&&m.length>0&&(h.at(-1)<m.at(-1)?h.length>m.length?h.pop():m.pop():(h.at(-1)===m.at(-1)||m.pop(),m.pop())),m.length+h.length>=2){let x=!1;for(let E=0,P=h.length;E<P;E++)n.getPointByVal(h[E],u),x?i.lineToPoint(u):(i.startPathPoint(u),x=!0);for(let E=m.length-1;E>0;E--)n.getPointByVal(m[E],u),x?i.lineToPoint(u):(i.startPathPoint(u),x=!0);n.isClosedPath(e.getPathIndex())?i.closePathWithLine():m.length>0&&(n.getPointByVal(m[0],u),i.lineToPoint(u))}h.length=0,m.length=0}return o&&i.replaceNaNs(1,0),i.getImpl().setIsSimple(1,g),i}polygonSimplifyAsFeature(){return this.simplifyPlanar()}simplifyPlanar(){if(this.m_geometry.getFillRule()===1&&!Ws(this.m_knownSimpleResult))return Qo(this.m_geometry,this.m_toleranceSimplify,!0,!1,this.m_knownSimpleResult,this.m_progressTracker,0,!0);const t=new Lt;if(t.addGeometry(this.m_geometry),this.m_geometry.hasAttribute(1)&&t.replaceNaNs(1,0),t.removeNaNVertices(),t.getTotalPointCount()!==0){let s=null,i=0,n=0;if(t.hasCurves()){s=new ts;const o=F.constructEmpty();this.m_geometry.queryEnvelope(o);const a=Je(this.m_toleranceSimplify.total(),o);i=Fs(this.m_toleranceSimplify.total()),n=Ms(a,i),_s(t,a,this.m_toleranceSimplify.total(),12e3,s,null,this.m_progressTracker)}Ws(this.m_knownSimpleResult)||Ns(t,this.m_toleranceSimplify.add(n),this.m_progressTracker,!0,!1),this.m_geometry.getGeometryType()===T.enumPolygon&&ii(t,t.getFirstGeometry(),this.m_knownSimpleResult,!1,-1,this.m_progressTracker),s!==null&&s.stitchCurves(t,t.getFirstGeometry(),i,!0)}const e=t.getGeometry(t.getFirstGeometry());return e.getGeometryType()===T.enumPolygon&&(e.getImpl().updateOGCFlagsProtected(),e.setFillRule(0)),e.getImpl().setIsSimple(4,this.m_toleranceSimplify.total()),e}progress_(){}static hasNanZs(t){if(t.hasAttribute(1)){const e=t.getAttributeStreamRef(1);for(let s=0,i=t.getPointCount();s<i;s++){const n=e.read(s);if(Number.isNaN(n))return!0}}return!1}compareVerticesForPlanarClustering(t,e,s){if(t===e)return 0;const i=this.m_pairs[t],n=this.m_pairs[e],o=i>>1,a=n>>1,h=this.m_xy.readPoint2D(2*o);h.y+=1&i?this.m_toleranceIsSimpleClustering:-this.m_toleranceIsSimpleClustering;const m=this.m_xy.readPoint2D(2*a);m.y+=1&n?this.m_toleranceIsSimpleClustering:-this.m_toleranceIsSimpleClustering;const l=h.compare(m);if(l===0&&s){const u=this.m_pathsForOGCTests[o]-this.m_pathsForOGCTests[a];return kt(u)}return l}compareVerticesMultiPoint(t,e){if(t===e)return 0;const s=this.m_multiVertexGeom.getXY(t),i=this.m_multiVertexGeom.getXY(e),n=!s.isFinite(),o=!i.isFinite();if(n||o)return n<o?-1:n>o?1:0;if(s.y<i.y)return-1;if(s.y>i.y)return 1;if(s.x<i.x)return-1;if(s.x>i.x)return 1;for(let a=1;a<this.m_attributeCount;a++){const h=this.m_description.getSemantics(a),m=Mt.getComponentCount(h);for(let l=0;l<m;l++){const u=this.m_multiVertexGeom.getAttributeAsDbl(h,t,l),c=this.m_multiVertexGeom.getAttributeAsDbl(h,e,l),g=np(u,c);if(g!==0)return g}}return 0}edgeAngleCompare(t,e){if(t===e)return 0;const s=t.m_segment.getTangent(t.getReversed()?1:0);t.getReversed()&&s.negateThis();const i=e.m_segment.getTangent(e.getReversed()?1:0);e.getReversed()&&i.negateThis();const n=s.getQuarter(),o=i.getQuarter();if(o===n){const a=s.crossProduct(i);return a<0?1:a>0?-1:0}return n<o?-1:1}}class Us{getOperatorType(){return 10103}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}isSimpleAsFeature(t,e,s,i,n){const o=jm(t,e,s,i,n);return Sp(t.getGeometryType(),o)}isSimplePlanarDONOTUSE(t,e,s,i,n){const o=HP(t,e,s,i,n);return yi(o)}executeMany(t,e,s,i){return new JP(t,e,s,i)}execute(t,e,s,i){const n=new oi([t]),o=this.executeMany(n,e,s,i).next();return o||$("null geometry"),o}}class JP extends mi{constructor(t,e,s,i){super(),this.m_progressTracker=i,this.m_bForceSimplify=s,this.m_index=-1,this.m_inputGeometryCursor=t,this.m_spatialReference=e}next(){const t=this.m_inputGeometryCursor.next();return t?(this.m_index=this.m_inputGeometryCursor.getGeometryID(),this.simplify(t)):null}getGeometryID(){return this.m_index}tock(){return!1}getRank(){return 1}simplify(t){if(t||H(""),t.getGeometryType()===T.enumGeometryCollection){const e=Lp(t,-1),s=new Us().executeMany(e,this.m_spatialReference,this.m_bForceSimplify,this.m_progressTracker),i=t.createInstance();for(let n=s.next();n!=null;n=s.next())i.addGeometry(n);return i}return W_(t,this.m_spatialReference,this.m_bForceSimplify,this.m_progressTracker)}}function tC(r,t,e){const s=new F;r.queryEnvelope(s);const i=new F;t.queryEnvelope(i);const n=new F(i);if(n.inflate(2*e),!n.isIntersecting(s))return 4;const o=r.getGeometryType(),a=t.getGeometryType();if(o===T.enumEnvelope&&s.containsEnvelope(n))return 1;if(a===T.enumEnvelope){const h=new F(s);if(h.inflate(2*e),i.containsEnvelope(h))return 2}return 0}class Li{constructor(t,e,s,i){this.m_intersectorGeom=null,this.m_sr=null,this.m_dimensionMask=-1,this.m_progressTracker=null,this.m_intersectorGeomType=T.enumUnknown,this.m_geomIntersectorEmptyGeom=null,this.m_intersectorGeom=t,this.m_sr=e,this.m_dimensionMask=s,this.m_progressTracker=i,this.m_intersectorGeomType=t.getGeometryType()}intersect(t){const e=this.tryFastImplementation(t);if(e!==null)return e;const s=Ur(this.m_intersectorGeom,t),i=re(this.m_sr,s,!0).total(),n=F.constructEmpty();this.m_intersectorGeom.queryEnvelope(n);const o=F.constructEmpty();t.queryEnvelope(o),n.inflateCoords(2*i,2*i),n.intersect(o),n.inflateCoords(100*i,100*i);const a=0;let h=Dt(this.m_intersectorGeom,n,a,0,this.m_progressTracker),m=Dt(t,n,a,0,this.m_progressTracker);return t.getDimension()>this.m_intersectorGeom.getDimension()&&(h=O(m,m=h)),VP(m,h,this.m_sr,this.m_progressTracker)}intersectEx(t){const e=this.tryFastImplementation(t);if(e!==null){const u=[];return u.length=3,u[e.getDimension()]=e,this.prepareVector(t.getDescription(),this.m_dimensionMask,u)}const s=Ur(this.m_intersectorGeom,t),i=re(this.m_sr,s,!0).total(),n=F.constructEmpty();this.m_intersectorGeom.queryEnvelope(n);const o=F.constructEmpty();t.queryEnvelope(o),n.inflateCoords(2*i,2*i),n.intersect(o),n.inflateCoords(100*i,100*i);const a=0;let h=Dt(this.m_intersectorGeom,n,a,0,this.m_progressTracker),m=Dt(t,n,a,0,this.m_progressTracker);t.getDimension()>this.m_intersectorGeom.getDimension()&&(h=O(m,m=h));const l=YP(m,h,this.m_sr,this.m_progressTracker);return this.prepareVector(t.getDescription(),this.m_dimensionMask,l)}init(t,e,s,i=null){b(0)}static intersectPoints(t,e,s){const i=Ur(t,e);return GP(t,e,re(s,i,!0))}tryFastImplementation(t){const e=t.getGeometryType();if(this.m_intersectorGeomType===T.enumPoint&&e===T.enumPoint){const h=Li.intersectPoints(t,this.m_intersectorGeom,this.m_sr);if(this.m_dimensionMask!==-1){const m=new Zt({vd:h.getDescription()});return h.isEmpty()||m.add(h),m}return h}if(e===T.enumEnvelope&&this.m_intersectorGeomType===T.enumEnvelope&&(this.m_dimensionMask===-1||this.m_dimensionMask===4)){const h=t,m=this.m_intersectorGeom,l=new Ne({copy:h});return l.intersect(m),l}const s=Ur(t,this.m_intersectorGeom),i=re(this.m_sr,s,!0),n=t.isEmpty(),o=this.m_intersectorGeom.isEmpty();let a=n||o;if(!a){const h=tC(this.m_intersectorGeom,t,i.total());if(h===4)a=!0;else{if(2&h)return this.m_intersectorGeom;if(1&h)return t}}if(a){const h=Be(e),m=Be(this.m_intersectorGeomType);return h<m?Li.ReturnEmpty(t,n):h>m||h===0&&e===T.enumMultiPoint&&this.m_intersectorGeomType===T.enumPoint?this.ReturnEmptyIntersector():Li.ReturnEmpty(t,n)}if(e===T.enumEnvelope&&Be(this.m_intersectorGeomType)===0||this.m_intersectorGeomType===T.enumEnvelope&&Be(e)===0){const h=e===T.enumEnvelope?t:this.m_intersectorGeom,m=e===T.enumEnvelope?this.m_intersectorGeom:t,l=F.constructEmpty();return h.queryEnvelope(l),Dt(m,l,i.total(),0,this.m_progressTracker)}if(Be(e)===0&&Be(this.m_intersectorGeomType)>0||Be(e)>0&&Be(this.m_intersectorGeomType)===0){if(e===T.enumMultiPoint)return yc(t,this.m_intersectorGeom,i);if(e===T.enumPoint)return Pc(t,this.m_intersectorGeom,i);if(this.m_intersectorGeomType===T.enumMultiPoint)return yc(this.m_intersectorGeom,t,i);if(this.m_intersectorGeomType===T.enumPoint)return Pc(this.m_intersectorGeom,t,i);$("")}return null}ReturnEmptyIntersector(){return this.m_geomIntersectorEmptyGeom===null&&(this.m_geomIntersectorEmptyGeom=this.m_intersectorGeom.createInstance()),this.m_geomIntersectorEmptyGeom}static ReturnEmpty(t,e){return e?t:t.createInstance()}prepareVector(t,e,s){let i=0;return 1&e?(s[0]||(s[0]=new Zt({vd:t})),i++):s.shift(),2&e?(s[i]||(s[i]=new Pt({vd:t})),i++):s.splice(i,1),4&e?s[i]||(s[i]=new ct({vd:t})):s.splice(i,1),new oi(s)}}class eC extends mi{constructor(t,e,s,i,n){super(),this.m_smallCursor=null,this.m_progressTracker=i,this.m_geomIntersector=e.next(),this.m_intersector=new Li(this.m_geomIntersector,s,n,i),this.m_index=-1,this.m_inputGeoms=t,this.m_dimensionMask=n,this.m_dimensionMask!==-1&&(this.m_dimensionMask<=0||this.m_dimensionMask>7)&&H("bad dimension mask")}next(){if(!this.m_geomIntersector)return null;let t;if(this.m_smallCursor!==null){if(t=this.m_smallCursor.next(),t)return t;this.m_smallCursor=null}for(;t=this.m_inputGeoms.next();)return ni(t),this.m_index=this.m_inputGeoms.getGeometryID(),this.m_dimensionMask===-1?this.m_intersector.intersect(t):(this.m_smallCursor=this.m_intersector.intersectEx(t),this.m_smallCursor.next());return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}class Ki{getOperatorType(){return 1e4}accelerateGeometry(t,e,s){if(!this.canAccelerateGeometry(t))return!1;Oe(e,t,!0);let i=0;return t.getGeometryType()!==T.enumPolygon&&t.getGeometryType()!==T.enumPolyline||!Mo(t)||s===0||(i|=t.getImpl().buildQuadTreeAccelerator(s)?1:0),!!i}canAccelerateGeometry(t){return Mo(t)}supportsCurves(){return!0}executeMany(t,e,s,i,n=-1){return new eC(t,e,s,i,n)}execute(t,e,s,i){if(t.getGeometryType()===T.enumPoint&&e.getGeometryType()===T.enumPoint)return Li.intersectPoints(t,e,s);const n=new oi([t]),o=new oi([e]),a=this.executeMany(n,o,s,i,-1).next();return a||$("null output"),a}}function j_(r,t,e){return t.m_projector.project(r,e)}function sC(r,t,e,s,i){r.m_projector.transformInPlaceZ(t,null,e,s,null,i);const n=s.slice(0,e).filter(o=>!o.isNAN());for(let o=0,a=n.length;o<a;++o)s[o].assign(n[o]);return n.length}function Zm(r,t,e,s,i){return r.m_projector.transformInPlaceZ(t,null,e,s,null,i)}function nm(r,t,e,s){if(r&&t&&t.isPannable()||H("fold_into_360_range_geodetic"),r.isEmpty())return r;if(e===4)return Ko(r,t,s);let i=r;const n=i.getGeometryType();if(lt(n)){i=Xn(r,t);const o=new F;i.queryEnvelope(o);const a=re(t,o,!1).total(),h=t.getPannableExtent();let m=Math.floor((o.xmin-h.xmin)/h.width())*h.width()+h.xmin,l=i;for(;m<o.xmax;)m>o.xmin+a&&m<o.xmax-a&&(l=md(l,t,e,!0,m)),m+=h.width();i=l}else{if(n===T.enumEnvelope){const o=new ct({vd:i.getDescription()});return o.addEnvelope(i,!1),nm(o,t,e,s)}if(he(n)){const o=new Pt({vd:i.getDescription()});return o.addSegment(i,!0),nm(o,t,e,s)}}return Ko(i,t,s)}function Ko(r,t,e){if(r&&t&&t.isPannable()||H(""),r.isEmpty())return r;let s;const i=r.getGeometryType();if(i===T.enumEnvelope){const o=new ct({vd:r.getDescription()});o.addEnvelope(r,!1),s=o}else if(he(i)){const o=new Pt({vd:r.getDescription()});o.addSegment(r,!0),s=o}else s=r;const n=Xn(s,t);return n.isEmpty()?n:Tn(n,t,0,n!==r,0,e)}function iC(r,t,e){if(!t.isPannable()||r.isEmpty())return r;const s=t.getPannableExtent().width(),i=.5*s,n=r.queryInterval(0,0);if(n.width()<i||!We(r.getGeometryType())){if(Number.isNaN(e))return r;const f=n.getCenter();if(Math.abs(f-e)<=i)return r;{const x=new pt,E=Hi((e-f)/s)*s;x.setShiftCoords(E,0);const P=r.clone();return P.applyTransformation(x),P}}const o=r.getGeometryType(),a=r,h=a.getAttributeStreamRef(0),m=r.clone(),l=m.getAttributeStreamRef(0);let u=0,c=0,g=0,_=lt(o)?0:-1;const d=z.constructEmpty();let p=!1;for(let f=0,x=a.getPointCount();f<x;f++){const E=h.read(2*f);f===c&&(lt(o)?(_===0&&Number.isNaN(e)&&(p=!0),_>0&&Number.isNaN(e)&&(e=d.getCenter(),p=!1),c=a.getPathEnd(_),_++):c=a.getPointCount(),Number.isNaN(e)?g=E:(g=e,u=0));let P=E-g;Math.abs(P)>i&&(P=Hi(P/s)*s,u-=P,Math.abs(u)<.1*s&&(u=0));const C=E+u;l.write(2*f,C),p&&d.mergeCoordinate(C),g=E}return m.notifyModified(),m}const nC="missing implementation";function rC(r,t,e,s){const i=t.getCoordinateSystemType();if(i===0){const a=new Me;return t.queryPrecisionDescriptor(a),Ec(r,a,t,e)}let n=r;s!==2&&s!==3||!t.isPannable()||(n=Ko(n,t,e));const o=new Me;if(t.queryPrecisionDescriptor(o),n=Ec(n,o,t,e),s===0||n.isEmpty())return n;if(i===1){if(s===1){const a=new F;n.queryLooseEnvelope(a);const h=t.getPannableExtent(),m=.01*h.width();return h.xmin=a.xmin-m,h.xmax=a.xmax+m,new wn().execute(n,h,t,e)}return n}if(i===2){const a=t.getPCSHorizon();if(s===1||s===2){const h=new Ki().execute(n,a,t,e);return h===a?h.clone():h}return n}if(i===3)return n;$(nC)}function Ec(r,t,e,s){const i=t.getXYGridRange(),n=r.hasAttribute(1),o=r.hasAttribute(2);let a=new z,h=new z;n&&(a=t.getZGridRange()),o&&(h=t.getMGridRange());let m=new wn().execute(r,i,e,s);if(n){const l=m.queryInterval(1,0);a.contains(l)||(r===m&&(m=m.clone()),ph(m,a,1,0))}if(o){const l=m.queryInterval(2,0);h.contains(l)||(r===m&&(m=m.clone()),ph(m,h,2,0))}return m}class oC{constructor(t){this.m_inputPCSHorizonClipOption=0,this.m_outputPCSHorizonClipOption=0,this.m_bDontGeonormalizePolygon=!1,this.m_bClipOutCurvedPoles=!1,this.m_bNormalizeOutputGeometry=!1,this.m_bDontHackPolesInGeogToGeog=!1,this.m_centralMeridianOfOutputGCS=0,this.m_densificationStepInput=0,t||H(""),this.m_projTransform=t,this.m_bClipOutCurvedPoles=!1;const e=this.m_projTransform.getExtendedParamsImpl();this.m_bNormalizeOutputGeometry=e.normalizeResultGeometry,this.m_bNormalizeOutputGeometry&&(e.legacyHorizonClipping?this.m_bNormalizeOutputGeometry=!1:this.m_projTransform.getOutputSR().isPannable()||(this.m_bNormalizeOutputGeometry=!1)),e.clipWithInputHorizon?(this.m_inputPCSHorizonClipOption=0,!e.legacyHorizonClipping&&this.m_projTransform.getInputSR().isPannable()&&(this.m_inputPCSHorizonClipOption=this.m_bNormalizeOutputGeometry?4:2)):this.m_inputPCSHorizonClipOption=1,e.clipWithOutputHorizon?(this.m_outputPCSHorizonClipOption=0,!e.legacyHorizonClipping&&this.m_projTransform.getOutputSR().isPannable()&&(this.m_outputPCSHorizonClipOption=this.m_bNormalizeOutputGeometry?4:2)):this.m_outputPCSHorizonClipOption=1,this.m_centralMeridianOfOutputGCS=e.centralMeridianOfOutputGCS,this.m_densificationStepInput=e.densificationStep;const s=this.m_projTransform.getExtendedParamsInternal();this.m_bDontGeonormalizePolygon=s.hasFlag(2147483648),this.m_bDontHackPolesInGeogToGeog=s.hasFlag(1073741824),this.m_bClipOutCurvedPoles=s.hasFlag(536870912)}project(t,e){if(this.m_projTransform.isIdentity()||t.isEmpty())return t;const s=t.getGeometryType();if(s===T.enumPoint)return this.projectPoint(t,e);const i=this.m_projTransform.getInputSR().getCoordinateSystemType(),n=this.m_projTransform.getOutputSR().getCoordinateSystemType(),o=this.m_projTransform.getInputSR(),a=this.m_projTransform.getOutputSR();if(i===0&&i===n){const h=Sc(o,a),m=t.clone();return m.applyTransformation(h),m}switch(s){case T.enumPolyline:case T.enumPolygon:return this.projectMultiPath(t,e);case T.enumMultiPoint:return this.projectMultiPoint(t,e);case T.enumEnvelope:return this.projectEnvelope(t,e);case T.enumGeometryCollection:return this.projectGeometryCollection(t,e);default:$("")}}projectPoint(t,e){const s=[t.getXY()];let i,n=null;(i=t.hasAttribute(1))&&(n=[t.getZ()]),this.transformInPlaceZ(s,n,1,s,n,null);const o=t.clone();return o.setXY(s[0]),i&&o.setZ(n[0]),o}projectMultiPoint(t,e){let s=new Zt({copy:t});const i=this.m_projTransform.getInputSR(),n=this.m_projTransform.getOutputSR(),o=i.getCoordinateSystemType(),a=n.getCoordinateSystemType();if(o===3&&b(0),s=vo(s,i,this.m_inputPCSHorizonClipOption,e),s.isEmpty())return s;o===2&&cd(i,0,s),_d(this.m_projTransform,s,!1);let h=0;a===3&&b(0);const m=a===2;return m?h=n.getCentralMeridian():Number.isNaN(this.m_centralMeridianOfOutputGCS)||(h=this.m_centralMeridianOfOutputGCS),m&&this.m_outputPCSHorizonClipOption!==0||(s=Tn(s,Io(n),h,!1,0,e)),m&&(s=ih(s,n,this.m_outputPCSHorizonClipOption,e),ud(n,s,this.m_bNormalizeOutputGeometry),s.isEmpty()),s}projectMultiPath(t,e){const s=t.getGeometryType();return s===T.enumPolygon?this.projectPolygon(t,e):s===T.enumPolyline?this.projectPolyline(t,e):void $("project_multi_path_")}projectEnvelope(t,e){this.m_projTransform.getInputSR(),this.m_projTransform.getOutputSR();const s=this.m_projTransform.isVertical()&&t.hasAttribute(1);let i=z.constructEmpty();if(s&&(i=t.queryInterval(1,0)),i.width()>0){const n=t.clone();n.setInterval(1,0,i.vmin,i.vmin);const o=this.projectEnvelopeHelper(n,e);n.setInterval(1,0,i.vmax,i.vmax);const a=this.projectEnvelopeHelper(n,e);return o.merge(a),o}return this.projectEnvelopeHelper(t,e)}projectPolygon(t,e){b(t.getGeometryType()===T.enumPolygon),b(!this.m_projTransform.isIdentity()),b(!t.isEmpty());const s=this.m_projTransform.getInputSR(),i=this.m_projTransform.getOutputSR(),n=s.getCoordinateSystemType(),o=i.getCoordinateSystemType(),a=new ct({copy:t});n===3&&b(0),o===3&&b(0);const h=n===2,m=o===2,l=h?s.getGCS():s,u=m?i.getGCS():i,c=!m&&!this.m_bDontHackPolesInGeogToGeog;let g=!1,_=vo(a,s,this.m_inputPCSHorizonClipOption,e);if(_.isEmpty())return _;let d=this.m_densificationStepInput;const p=!Number.isNaN(d);let f;p&&(_=new Fi().execute(_,d,0,0,e));let x=m?i.getPCSInfo():null,E=Number.NaN;h&&(E=s.getCentralMeridian());const P=i.getGCSSplitLines()!==null;if(this.m_bDontGeonormalizePolygon){const C=_;if(h&&(ho(s,E,C),p)){const S=s.getUnitsPerMillimeter();d*=s.getGCS().getUnitsPerMillimeter()/S}if(mo(this.m_projTransform,C,c),p){const S=s.getGCS().getUnitsPerMillimeter();d*=i.getGCS().getUnitsPerMillimeter()/S}f=C}else{let C=new Pt({vd:_.getDescription()});if(C.addAndExplicitlyOpenAllPaths(_,!1),h){if(ho(s,E,C),p){const D=s.getUnitsPerMillimeter();d*=s.getGCS().getUnitsPerMillimeter()/D}if(this.m_bClipOutCurvedPoles){const D=s.getPCSInfo(),N=D.getSouthPoleGeometry()===de.PE_POLE_LINE_CURVED,A=D.getNorthPoleGeometry()===de.PE_POLE_LINE_CURVED;if(N||A){const M=F.constructEmpty();C.queryLooseEnvelope(M),M.inflateCoords(1,1);const G=89.9999*l.getOneDegreeGCSUnit();N&&(M.ymin=-G),A&&(M.ymax=G),C=q1(C,M,l,0,0,e)}}}if(mo(this.m_projTransform,C,c),p){const D=Io(s).getUnitsPerMillimeter();d*=Io(i).getUnitsPerMillimeter()/D}let S=Number.NaN;m?(x=i.getPCSInfo(),S=i.getCentralMeridian()):Number.isNaN(this.m_centralMeridianOfOutputGCS)||(S=this.m_centralMeridianOfOutputGCS);let I=ao(s)|ao(i),w=10*u.getTolerance(0);this.m_bDontHackPolesInGeogToGeog&&(I=3,w=10*u.getTolerance(0)),f=hE(_,s,C,u,S,e,I,w,this.m_bNormalizeOutputGeometry),I=0}if(P&&(b(!i.isPannable()),f=hm(f,i,e)),m){if(!g){const C=u.getPannableExtent().width();if(f.queryInterval(0,0).width()>=C-10*u.getTolerance(0)){const S=x.getNorthPoleLocation(),I=x.getSouthPoleLocation(),w=x.getNorthPoleGeometry(),D=x.getSouthPoleGeometry();let N=0;w===de.PE_POLE_POINT&&S!==de.PE_POLE_OUTSIDE_BOUNDARY&&(N=1),D===de.PE_POLE_POINT&&I!==de.PE_POLE_OUTSIDE_BOUNDARY&&(N|=2),g||=N!==0}}f=ih(f,i,this.m_outputPCSHorizonClipOption,e),p&&(f=new Fi().execute(f,d,0,0,e)),Mc(i,f,this.m_bNormalizeOutputGeometry)}return f.isEmpty()||g&&(f=new Us().execute(f,i,!1,e)),f}projectPolyline(t,e){b(t.getGeometryType()===T.enumPolyline),b(!this.m_projTransform.isIdentity()),b(!t.isEmpty());const s=this.m_projTransform.getInputSR(),i=this.m_projTransform.getOutputSR(),n=s.getCoordinateSystemType(),o=i.getCoordinateSystemType(),a=new Pt({copy:t});n===3&&b(0),o===3&&b(0);const h=n===2,m=o===2;h&&s.getGCS();const l=m?i.getGCS():i,u=!m&&!this.m_bDontHackPolesInGeogToGeog;let c=vo(a,s,this.m_inputPCSHorizonClipOption,e);if(c.isEmpty())return c;let g=Number.NaN;h&&(g=s.getCentralMeridian());const _=i.getGCSSplitLines()!==null;let d=this.m_densificationStepInput;const p=!Number.isNaN(d);let f;if(p&&(c=new Fi().execute(c,d,0,0,e)),this.m_bDontGeonormalizePolygon){if(h&&(ho(s,g,c),p)){const x=s.getUnitsPerMillimeter();d*=s.getGCS().getUnitsPerMillimeter()/x}if(mo(this.m_projTransform,c,u),p){const x=s.getGCS().getUnitsPerMillimeter();d*=i.getGCS().getUnitsPerMillimeter()/x}f=c}else{const x=new Pt({vd:c.getDescription()});if(x.addAndExplicitlyOpenAllPaths(c,!1),h&&(ho(s,g,x),p)){const S=s.getUnitsPerMillimeter();d*=s.getGCS().getUnitsPerMillimeter()/S}if(mo(this.m_projTransform,x,u),p){const S=s.getGCS().getUnitsPerMillimeter();d*=i.getGCS().getUnitsPerMillimeter()/S}let E=Number.NaN;m?E=i.getCentralMeridian():Number.isNaN(this.m_centralMeridianOfOutputGCS)||(E=this.m_centralMeridianOfOutputGCS);let P=ao(s)|ao(i),C=10*l.getTolerance(0);this.m_bDontHackPolesInGeogToGeog&&(P=3,C=0),f=mE(c,s,x,l,E,e,P,C,this.m_bNormalizeOutputGeometry),P=0}return _&&(b(!i.isPannable()),f=hm(f,i,e)),m&&(f=ih(f,i,this.m_outputPCSHorizonClipOption,e),p&&(f=new Fi().execute(f,d,0,0,e)),Mc(i,f,this.m_bNormalizeOutputGeometry)),f.isEmpty(),f}projectGeometryCollection(t,e){return b(0),{}}projectEnvelopeHelper(t,e){const s=(t.height()+t.width())/400;if(s!==0){const i=new Fi().execute(t,s,0,0,e),n=this.projectMultiPath(i,e),o=new Ne({vd:t.getDescription()});if(n.isEmpty()){const a=Math.min(t.height(),t.width()),h=Oe(this.m_projTransform.getInputSR(),t,!0).total();if(a>100*h){const _=F.constructEmpty(),d=re(this.m_projTransform.getOutputSR(),_,!0).total(),p=this.m_projTransform.getInputSR().getOneMeter()/this.m_projTransform.getOutputSR().getOneMeter();if(a>100*Math.max(h,d*p))return o}const m=new Pt;m.addAndExplicitlyOpenAllPaths(i,!1),this.projectMultiPath(m,e).queryEnvelope(o);const l=new Zt({vd:t.getDescription()});l.reserve(4);const u=new st;for(let _=0;_<4;_++)t.queryCornerByVal(_,u),l.add(u);const c=this.projectMultiPoint(l,e),g=new Ne;return c.queryEnvelope(g),o.merge(g),o}return n.queryEnvelope(o),o}{const i=t.getCenterXY(),n=new st(i),o=this.projectPoint(n,e),a=new Ne({vd:t.getDescription()});if(o.isEmpty())a.setEmpty();else{t.copyTo(a);const h=o.getXY();a.setCoords(h.x,h.y,h.x,h.y)}return a}}transformInPlace(t,e,s,i){return b(0),0}transformInPlaceZ(t,e,s,i,n,o){if(this.m_projTransform.isIdentity())return t!==i&&Ao(i,t,s),e!==n&&ne(n,e,0,0,s),s;const a=this.m_projTransform,h=a.getInputSR(),m=a.getOutputSR(),l=h.getCoordinateSystemType(),u=m.getCoordinateSystemType();if(l===0&&l===u)return Sc(h,m).transformPoints2D(t,s,i),a.isVertical()&&b(0),s;l===3&&ft("image: transform_in_place_"),u===3&&ft("image: transform_in_place_"),gE(t,s,i,h,this.m_inputPCSHorizonClipOption),n!==e&&ne(n,e,0,0,s),l===2&&Ta(h,0,i,s),Ji(this.m_projTransform,i,n,s,!1);let c=0;const g=u===2;if(g?c=m.getCentralMeridian():Number.isNaN(this.m_centralMeridianOfOutputGCS)||(c=this.m_centralMeridianOfOutputGCS),g&&this.m_outputPCSHorizonClipOption!==0||hd(i,s,m.getGCS(),c),g){if(!lm(i,s,m,this.m_outputPCSHorizonClipOption))for(let d=0;d<s;++d)i[d].setNAN();wa(m,i,s,!1)}let _=s;for(let d=0;d<s;++d)i[d].isNAN()&&(n&&(n[d]=Number.NaN),_--);return _}}function ao(r){if(r.getCoordinateSystemType()!==2)return 0;let t=0;const e=r.getPCSInfo(),s=e.getNorthPoleLocation(),i=e.getSouthPoleLocation(),n=e.getNorthPoleGeometry(),o=e.getSouthPoleGeometry();return n===de.PE_POLE_POINT&&s!==de.PE_POLE_OUTSIDE_BOUNDARY&&(t=1),o===de.PE_POLE_POINT&&i!==de.PE_POLE_OUTSIDE_BOUNDARY&&(t|=2),t}function Sc(r,t){const e=r.getHorzUnitFactor(),s=t.getHorzUnitFactor();let i=1,n=1;const o=20015077/180;r.getUnit().getUnitType()===1&&(i=o),t.getUnit().getUnitType()===1&&(n=o);const a=e/s*(i!==n?i/n:1),h=new pt;return h.setScaleCoords(a,a),h}let Rs=class{getOperatorType(){return 10300}supportsCurves(){return!0}accelerateGeometry(r,t,e){return!1}canAccelerateGeometry(r){return!1}executeMany(r,t,e){return!t||t.isIdentity()?r:new aC(r,t,e)}execute(r,t,e){return t.isIdentity()?r:j_(r,t,e)}transform(r,t,e,s,i=!0){return i?sC(r,t,e,s,null):Zm(r,t,e,s,null)}transform3D(r,t,e,s,i=!0){return b(0),0}foldInto360Range(r,t){return Ko(r,t,null)}foldInto360RangeGeodetic(r,t,e){return nm(r,t,e,null)}normalizeGeometryEx(r,t,e,s,i=0){return NC(r,t,e,s,i)}normalizeGeometry(r,t,e){return iC(r,t,e)}clipToSpatialReference(r,t,e,s=0){return rC(r,t,e,s)}};class aC extends mi{constructor(t,e,s){super(),this.m_projTrans=e,this.m_progressTracker=s,this.m_index=-1,t||H(""),this.m_inputGeoms=t}next(){const t=this.m_inputGeoms.next();return t!=null?(ir(t),ni(t),this.m_index=this.m_inputGeoms.getGeometryID(),j_(t,this.m_projTrans,this.m_progressTracker)):null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}function rm(r,t,e,s,i,n,o=!1){r||H("Geometry.Geodetic_densify.densify");let a=r.getGeometryType();if(ni(r),r.isEmpty()||xn(a))return r;const h=new mC;h.m_sr=t,h.m_gcs=t.getGCS(),h.m_transform=h.m_gcs!==t?t.getSRToGCSTransform():null,h.m_progressTracker=n;const m=sn();let l,u,c;if(h.m_gcs.querySpheroidData(m),h.m_a=m.majorSemiAxis,h.m_eSquared=m.e2,h.m_rpu=h.m_gcs.getUnit().getUnitToBaseFactor(),h.m_gcsTolerance=h.m_gcs.getTolerance(0),h.m_radTolerance=h.m_gcsTolerance*h.m_rpu,h.m_maxLength=s,h.m_maxDeviation=i,h.m_curveType=e,a===T.enumEnvelope){const g=new ct({vd:r.getDescription()});g.addEnvelope(r,!1),l=g,a=T.enumPolygon}else if(he(a)){const g=new Pt({vd:r.getDescription()});g.addSegment(r,!0),l=g,a=T.enumPolyline}else l=r;if(h.m_curveType!==4){if(b(lt(a)),u=h.replaceCurvesWithLinesAndProjectToGCSAsMultiPoint_(l),u.isEmpty())return u;u=Z_(h.m_rpu,u);let g=h.geodeticDensify(u);o||(g=new Rs().foldInto360RangeGeodetic(g,h.m_gcs,h.m_curveType)),c=h.m_transform&&!h.m_transform.isIdentity()?new Rs().execute(g,h.m_transform.getInverse(),n):g}else{let g;if(b(lt(a)),t.isPannable())g=Xn(l,t);else{const _=t.getPCSHorizon();g=new Ki().execute(l,_,t,n),g===_&&(g=_.clone())}if(u=g,u.isEmpty())return u;c=h.shapePreservingDensify(u)}return c}function Z_(r,t){const e=new F;if(t.queryLooseEnvelope(e),e.width()*r<Math.PI)return t;let s=!1;const i=t.querySegmentIterator(),n=new y,o=new y;for(;i.nextPath();)for(;i.hasNextSegment();){const _=i.nextSegment();if(n.setCoordsPoint2D(_.getStartXY()),o.setCoordsPoint2D(_.getEndXY()),n.scale(r),o.scale(r),Math.abs(n.x-o.x)>Math.PI){if(!om(n,o)){s=!0;break}if(Math.abs(n.x-o.x)>2*Math.PI){s=!0;break}}}if(!s)return t;const a=t.createInstance();a.reserve(t.getPointCount());const h=t.getDescription().getAttributeCount()>1,m=new y,l=new y,u=new y(0,0),c=new y(0,0),g=new st;for(i.resetToFirstPath();i.nextPath();){let _=Number.NaN,d=0;for(;i.hasNextSegment();){const p=i.nextSegment();if(n.setCoordsPoint2D(p.getStartXY()),o.setCoordsPoint2D(p.getEndXY()),n.scale(r),o.scale(r),Number.isNaN(_)?(d=Xi(n.x,Number.NaN,d),u.setCoordsPoint2D(n)):u.setCoordsPoint2D(c),_=u.x,om(n,o)){if(o.x-n.x>2*Math.PI)for(;o.x-n.x>2*Math.PI;)o.x-=2*Math.PI;else if(o.x-n.x<2*-Math.PI)for(;o.x-n.x<2*-Math.PI;)o.x+=2*Math.PI;d=Xi(o.x,Number.NaN,d),c.setCoordsPoint2D(o)}else m.setCoordsPoint2D(o),dC(m),d=Xi(m.x,_,d),c.setCoords(d+m.x,m.y);if(Math.abs(c.x-o.x)<.5&&c.setCoordsPoint2D(o),h)p.queryCoord(0,g),l.setCoordsPoint2D(u),l.scale(1/r),g.setXY(l),i.isFirstSegmentInPath()?a.startPathPoint(g):a.lineToPoint(g),i.isLastSegmentInPath()&&!i.isPathClosed()&&(p.queryCoord(1,g),l.setCoordsPoint2D(c),l.scale(1/r),g.setXY(l),a.lineToPoint(g));else{i.isFirstSegmentInPath()&&a.insertPath2D(-1,null,0,0,!0);const f=a.getPathCount()-1;l.setCoordsPoint2D(u),l.scale(1/r),a.insertPoint2D(f,-1,l),i.isLastSegmentInPath()&&!i.isPathClosed()&&(l.setCoordsPoint2D(c),l.scale(1/r),a.insertPoint2D(f,-1,l))}}}return a}function hC(r,t,e,s,i,n,o,a,h,m,l,u){const c=new y,g=new y,_=s.compare(i)>0;td(_,s,i,c,g);const d=J_(r,t,e,c,g,n,o,a,h,m,null,l,u);return _&&am(h,m,null,l),d}function om(r,t){return!(!bt(r.y,dt)||!bt(t.y,dt))||!(!bt(r.y,-dt)||!bt(t.y,-dt))}function Q_(r,t){return!(!bt(r.y,dt)||bt(t.y,dt))||!(!bt(r.y,-dt)||bt(t.y,-dt))}function K_(r,t){return!(!bt(t.y,dt)||bt(r.y,dt))||!(!bt(t.y,-dt)||bt(r.y,-dt))}class mC{constructor(){this.m_sr=null,this.m_gcs=null,this.m_transform=null,this.m_progressTracker=null,this.m_a=0,this.m_eSquared=0,this.m_rpu=0,this.m_gcsTolerance=0,this.m_radTolerance=0,this.m_maxLength=0,this.m_maxDeviation=0,this.m_curveType=0}geodeticDensify(t){const e=t.createInstance(),s=t.querySegmentIterator(),i=[],n=[],o=new it,a=t.getDescription().getAttributeCount()>1;for(;s.nextPath();){const h=[0];for(;s.hasNextSegment();){const m=s.nextSegment(),l=m.getStartXY(),u=m.getEndXY();l.scale(this.m_rpu),u.scale(this.m_rpu);const c=new y,g=new y,_=l.compare(u)>0;td(_,l,u,c,g),i.length=0,n.length=0,this.m_maxLength>0?J_(this.m_a,this.m_eSquared,this.m_curveType,c,g,this.m_maxLength,this.m_maxDeviation,this.m_radTolerance,null,null,a?n:null,i,h):lC(),_&&am(null,null,a?n:null,i),i[0].setCoordsPoint2D(m.getStartXY()),i.at(-1).setCoordsPoint2D(m.getEndXY());const d=1/this.m_rpu;for(let p=1,f=i.length-1;p<f;p++)i[p].scale(d);if(a){const p=wc(_,m,o);bc(s.isFirstSegmentInPath(),s.isLastSegmentInPath()&&!s.isPathClosed(),m,p,n,i,e)}else vc(s.isFirstSegmentInPath(),s.isLastSegmentInPath()&&!s.isPathClosed(),i,e)}}return e}shapePreservingDensify(t){const e=t.createInstance(),s=t.querySegmentIterator(),i=[],n=[],o=new it,a=t.getDescription().getAttributeCount()>1;for(;s.nextPath();)for(;s.hasNextSegment();){const h=s.nextSegment(),m=h.getStartXY(),l=h.getEndXY(),u=m.compare(l)>0,c=wc(u,h,o);i.length=0,n.length=0,gC(this.m_a,this.m_eSquared,this.m_rpu,c,this.m_sr,this.m_maxLength,this.m_maxDeviation,a?n:null,i),u&&am(null,null,a?n:null,i),a?bc(s.isFirstSegmentInPath(),s.isLastSegmentInPath()&&!s.isPathClosed(),h,c,n,i,e):vc(s.isFirstSegmentInPath(),s.isLastSegmentInPath()&&!s.isPathClosed(),i,e)}return e}replaceCurvesWithLinesAndProjectToGCSAsMultiPoint_(t){const e=t.hasNonLinearSegments();if((!this.m_transform||this.m_transform.isIdentity())&&(t=Xn(t,this.m_gcs),!e))return t;const s=t.createInstance();s.reserveParts(t.getPointCount(),t.getPathCount());for(let i=0,n=t.getPathCount();i<n;++i){let o=new Zt;const a=t.getPathStart(i),h=t.getPathEnd(i);o.addPoints(t,a,h);const m=t.isClosedPath(i);let l=!1;if(m&&h-a===1&&t.hasNonLinearSegmentsPath(i)){const u=new st;t.getPointByVal(a,u),o.add(u),l=!0}if(this.m_transform&&!this.m_transform.isIdentity()){if(m&&!l){const u=new st;t.getPointByVal(a,u),o.add(u)}if(o=new Rs().execute(o,this.m_transform,this.m_progressTracker),m&&o.getPointCount()>1){const u=o.getXY(0),c=o.getXY(o.getPointCount()-1);u.equals(c)&&o.removePoint(o.getPointCount()-1)}}o.getPointCount()>1&&(s.addPathMultiPoint(o,0,-1,!0),m&&s.closePathWithLine())}return s}}function vc(r,t,e,s){r&&s.insertPath2D(-1,null,0,0,!0);const i=s.getPathCount()-1;s.insertPointsFromPoints(i,-1,e,0,e.length-1,!0),t&&s.insertPoint2D(i,-1,e.at(-1))}function bc(r,t,e,s,i,n,o){o.reserve(o.getPointCount()+n.length-1);const a=new st;if(e.queryStart(a),r?o.startPathPoint(a):o.lineToPoint(a),n.length>2){const h=s.calculateLength2D();for(let m=1;m<n.length-1;m++){const l=s.lengthToT(i[m]*h);s.queryCoord(l,a),a.setXY(n[m]),o.lineToPoint(a)}}t&&(e.queryEnd(a),o.lineToPoint(a))}function J_(r,t,e,s,i,n,o,a,h,m,l,u,c){const g={stack:[],error:void 0,hasError:!1};try{const _=Te(g,new xe,!1),d=Te(g,new xe,!1),p=Te(g,new xe,!1);Ze.geodeticDistance(r,t,s.x,s.y,i.x,i.y,p,_,d,e);const f=p.val,x=_.val,E=d.val;let P=x,C=E;P<0&&(P+=2*Math.PI),C<0&&(C+=2*Math.PI),h&&(h[0]=P),m&&(m[0]=C);let S=Number.NaN,I=Number.NaN;if(l!==null){const B=qr.q90(r,t),W=qr.q(r,t,s.y);S=(B-W)/f,I=(B+W)/f}const w=Q_(s,i),D=K_(s,i),N=w||D,A=_C(s,i,a),M=Te(g,new ep(new xe,new xe),!1),G=new y,q=new y,V=new y;c[0]=Xi(s.x,Number.NaN,c[0]);let k=c[0];if(f<=n)return u.push(s.clone()),c[0]=Xi(i.x,Number.NaN,c[0]),l?.push(0),N?(w&&Dc(s,i,l,u),D&&Tc(s,i,l,u)):A?Nc(s,i,x,S,I,l,u):o>0&&(q.setCoords(s.x-k,s.y),G.setCoords(i.x-c[0],i.y),k=Ic()),u.push(i.clone()),f;const Y=1+Math.ceil(f/n),U=f/(Y-1),X=new y;u.push(s.clone()),X.setCoordsPoint2D(s),q.setCoords(s.x-c[0],s.y),l!==null&&l.push(0);for(let B=1;B<Y;B++){let W;if(B<Y-1){const Z=B*U;Ze.geodeticCoordinate(r,t,s.x,s.y,Z,x,M.at(0),M.at(1),e),G.setCoords(M.at(0).val,M.at(1).val),c[0]=Xi(G.x,X.x,c[0]),V.setCoords(c[0]+G.x,G.y),W=B/(Y-1)}else c[0]=Xi(i.x,Number.NaN,c[0]),G.setCoords(i.x-c[0],i.y),V.setCoordsPoint2D(i),W=1;N?(B===1&&w&&Dc(s,V,l,u),B===Y-1&&D&&Tc(X,i,l,u)):A?ed(X,V,a)&&(s.x<i.x?X.x>V.x&&(c[0]+=2*Math.PI,V.setCoords(c[0]+G.x,G.y)):X.x<V.x&&(c[0]-=2*Math.PI,V.setCoords(c[0]+G.x,G.y)),Nc(X,V,x,S,I,l,u)):o>0&&Ic(),u.push(V.clone()),l?.push(W),X.setCoordsPoint2D(V),q.setCoordsPoint2D(G),k=c[0]}return f}catch(_){g.error=_,g.hasError=!0}finally{li(g)}}function lC(r,t,e,s,i,n,o,a,h,m){b(0)}function Ic(r,t,e,s,i,n,o,a,h,m,l,u,c,g,_){return b(0),0}function uC(r,t,e,s){const i=ae(r,t,e),n=ae(r,t,s);return mt.distance(i,n)}function cC(r,t,e,s,i,n,o,a){const h=new Array,m=R(Array,8);let l=2,u=i.getCoord2D(n);m[0][0]=u.x,m[0][1]=u.y,u=i.getCoord2D(o),m[1][0]=u.x,m[1][1]=u.y;const c=d=>{if(e!==null){const p=pe.projToGeog(e,d,m);b(p===d)}for(const p of m)p[0]*=s,p[1]*=s};c(2),h.push(ae(r,t,new y(m[0][0],m[0][1]))),h.push(ae(r,t,new y(m[1][0],m[1][1])));let g=mt.distance(h[0],h[1]);if(g>a)return g;let _=0;for(l=3;l<=17;){const d=1/(l-1);let p=0;for(let P=1;P<l;++P)if(1&P){const C=Ct(n,o,P*d);i.queryCoord2D(C,u),m[p][0]=u.x,m[p][1]=u.y,p++}c(p);let f=1;for(let P=0;P<p;++P)h.splice(f,0,ae(r,t,new y(m[P][0],m[P][1]))),f++;f=0;let x=h[f];f++;let E=0;for(;f!==h.length;++f){const P=h[f];E+=mt.distance(x,P),x=P}if(E>a)return E;if(_=E-g,b(_>=0||Math.abs(_)<1e-14*E),_<0&&(_=0),g=E,E+_<=a)return E+_;l=2*l-1}return g+_}function gC(r,t,e,s,i,n,o,a,h){const m=s.isCurve(),l=J1(r,t)*Math.PI*179/180;let u=n;n>0&&!(n>l)||(u=l);const c=o,g=c>0;let _=Number.NaN;g&&(_=nx(r,t,c));const d=i.getCoordinateSystemType()===1;let p=null;d||(p=i.getPECoordSys());const f=i.getTolerance(0),x=s.getStartXY(),E=s.getEndXY(),P=new y,C=new y;if(d)P.setCoordsPoint2D(x),P.scale(e),C.setCoordsPoint2D(E),C.scale(e);else{const k=[x.x,x.y,E.x,E.y];pe.projToGeog(p,2,k),P.setCoords(k[0],k[1]),P.scale(e),C.setCoords(k[2],k[3]),C.scale(e)}let S=0,I=0;const w=[],D=[],N=[];w.push(E.clone()),D.push(C.clone()),N.push(1),h.push(x.clone()),a!==null&&a.push(I);const A=i.isPannable(),M=x.clone(),G=[.5,.33333333333333337,.6666666666666666,.16666666666666669,.8333333333333333];let q=5;m||(g?(G[0]=.5,G[1]=.25,G[2]=.75,q=3):q=1),b(u>0);const V=k=>{if(k=k.clone(),p!==null){const Y=[k.x,k.y];pe.projToGeog(p,1,Y),k.setCoords(Y[0],Y[1])}return k.scale(e),k};for(;D.length>0;){const k=w.at(-1).clone();C.assign(D.at(-1));const Y=N.at(-1);let U=!1,X=Number.NaN;const B=cC(r,t,p,e,s,I,Y,u);let W=u>=B&&Math.abs(P.y-C.y)<.9*Math.PI;d&&W&&(W=Math.abs(P.x-C.x)<.9*Math.PI);const Z=new y,gt=new y;let at=!1;if(!g&&W&&W&&(at=!0),s.calculateSubLength(I,Y)<=f&&(at=!0),!at)for(let Q=0;Q<q;Q++){const rt=Ct(I,Y,G[Q]),nt=new y;s.queryCoord2D(rt,nt);const ot=V(nt);if(Q===0&&(X=rt,Z.setCoordsPoint2D(nt),gt.setCoordsPoint2D(ot),!W)){U=!0;break}if(b(g),d&&Math.abs(P.x-ot.x)>=Math.PI){U=!0;break}let Gt=new y,Ot=new y;m?(Gt=y.lerp(M,k,G[Q]),Ot=V(Gt)):(Gt=nt.clone(),Ot=ot.clone());const Ht=O1(r,t,P,C,G[Q]),It=Ht.clone();if(d?(It.x/=e,It.y/=e):(It.x/=e,It.y/=e,Zm(i.getGCSToSRTransform(),[It],1,[It],null)),It.isNAN()){const Jt=ae(r,t,ot),Wt=ae(r,t,P),Re=ae(r,t,C),{second:$t}=jn(r,t,Jt,Wt,Re,2,null);if($t>_){U=!0;break}}else{if(A){const $t=i.getPannableExtent().width(),qe=Ct(s.getStartX(),s.getEndX(),.5);for(;It.x<qe-.5*$t;)It.x+=$t;for(;It.x>=qe+.5*$t;)It.x-=$t}const Jt=s.getClosestCoordinateOnInterval(It,new z(I,Y),-1);let Wt=s.getCoord2D(Jt);Wt=V(Wt);let Re=uC(r,t,Wt,Ht);if(Re>_){if(Re<4*_){const $t=ae(r,t,Wt),qe=ae(r,t,P),as=ae(r,t,C),{second:Ke}=jn(r,t,$t,qe,as,2,null);Re=Ke}if(Re>_){U=!0;break}}else if(m){let $t=ae(r,t,ot);const qe=ae(r,t,P),as=ae(r,t,C);let{second:Ke}=jn(r,t,$t,qe,as,3,null);if(Ke<=_){$t=ae(r,t,Ot);const{second:js}=jn(r,t,$t,qe,as,3,null);Ke=js}if(Ke>_){U=!0;break}}}}U?(w.push(Z.clone()),D.push(gt.clone()),N.push(X)):(w.pop(),D.pop(),N.pop(),h.push(k.clone()),S+=B,a!==null&&a.push(S),M.setCoordsPoint2D(k),P.setCoordsPoint2D(C),I=Y)}if(a!==null){const k=1/S;for(let Y=0;Y<a.length;Y++)a[Y]*=k}}function am(r,t,e,s){if(s.reverse(),e!==null&&e.reverse(),r){const i=r[0],n=t[0];r[0]=n,t[0]=i}}function td(r,t,e,s,i){r?(s.setCoordsPoint2D(e),i.setCoordsPoint2D(t)):(s.setCoordsPoint2D(t),i.setCoordsPoint2D(e))}function wc(r,t,e){return r?(e.create(t.getGeometryType()),t.copyTo(e.get()),e.get().reverse(),e.get()):t}function Xi(r,t,e){if(Number.isNaN(t)){for(;e-r>Math.PI;)e-=2*Math.PI;for(;r-e>Math.PI;)e+=2*Math.PI;return e}return e+r-t>Math.PI?e-=2*Math.PI:t-(e+r)>Math.PI&&(e+=2*Math.PI),e}function Dc(r,t,e,s){if(r.y>0){const i=new y;i.setCoords(t.x,dt),bt(r.x,i.x)||bt(t.y,i.y)||(s.push(i),e!==null&&e.push(0))}else{const i=new y;i.setCoords(t.x,-dt),bt(r.x,i.x)||bt(t.y,i.y)||(s.push(i),e!==null&&e.push(0))}}function Tc(r,t,e,s){if(t.y>0){const i=new y;i.setCoords(r.x,dt),bt(t.x,i.x)||bt(r.y,i.y)||(s.push(i),e!==null&&e.push(1))}else{const i=new y;i.setCoords(r.x,-dt),bt(t.x,i.x)||bt(r.y,i.y)||(s.push(i),e!==null&&e.push(1))}}function Nc(r,t,e,s,i,n,o){if(cS(e)){if(dt-r.y>0){const a=new y;a.setCoords(r.x,dt),o.push(a),n!==null&&n.push(s)}if(dt-t.y>0){const a=new y;a.setCoords(t.x,dt),o.push(a),n!==null&&n.push(s)}}else{if(dt+r.y>0){const a=new y;a.setCoords(r.x,-dt),o.push(a),n!==null&&n.push(i)}if(dt+t.y>0){const a=new y;a.setCoords(t.x,-dt),o.push(a),n!==null&&n.push(i)}}}function _C(r,t,e){return!(!ed(r,t,e)||bt(r.y,dt)||bt(r.y,-dt)||bt(t.y,dt)||bt(t.y,-dt))}function ed(r,t,e){return Math.abs(Math.abs(r.x-t.x)-Math.PI)<=e}function dC(r){if(r.x<-Math.PI)for(;r.x<-Math.PI;)r.x+=2*Math.PI;else if(r.x>Math.PI)for(;r.x>Math.PI;)r.x-=2*Math.PI}function pC(r,t,e,s){const i={stack:[],error:void 0,hasError:!1};try{const n=[e.x],o=[e.y-s],a=[e.x],h=[e.y+s];Vu(n,o),Vu(a,h);const m=Te(i,new xe,!1),l=Te(i,new xe,!1);return Ze.greatEllipticDistance(r,t,e.x,e.y,n[0],o[0],m,null,null),Ze.greatEllipticDistance(r,t,e.x,e.y,a[0],h[0],l,null,null),Math.min(m.val,l.val)}catch(n){i.error=n,i.hasError=!0}finally{li(i)}}function sd(r,t,e,s,i){const n=new F;e.queryEnvelope(n);const o=Oe(null,e,!0).total();if(t.xmin-n.xmin<=o&&n.xmax-t.xmax<=o)return e;const a=t.width();let h=0;for(;t.xmin+h*a<n.xmin;)h++;for(;t.xmin+h*a>n.xmin;)h--;const m=h*a,l=new pt;l.setShiftCoords(-m,0);const u=e;u.applyTransformation(l);const c=new F;u.queryEnvelope(c);let g=null;if(c.xmax>t.xmax){let _=0;const d=new F;d.setCoords({env2D:t}),d.ymin-=1,d.ymax+=1;let p=u;for(;d.xmin<c.xmax;){c.xmax>d.xmax&&(p=md(p,r,2,!0,d.xmax));const f=Sm(p,d),x=re(null,f,!0).total(),E=Dt(p,d,x,Number.NaN,i);g===null?g=E===p?E.clone():E:(l.setShiftCoords(-_*a,0),E.applyTransformation(l),g.add(E,!1)),_++,d.xmin=d.xmax,d.xmax=t.xmax+_*a}}else g=u;return g}class id{constructor(t,e){this.m_basisX=new mt,this.m_basisY=new mt,this.m_normal=new mt,b(t.getCoordinateSystemType()===1),this.m_gcs=t;const s=sn();t.querySpheroidData(s),this.m_a=s.majorSemiAxis,this.m_e2=s.e2,this.m_rpu=t.getUnit().getUnitToBaseFactor(),this.m_curvCenterRad=e.mul(this.m_rpu);const i=this.m_curvCenterRad.x,n=this.m_curvCenterRad.y,o=Math.cos(i),a=Math.sin(i),h=Math.cos(n),m=Math.sin(n);this.m_cartCenter3D=U1(this.m_a,this.m_e2,o,a,h,m),this.m_normal.setCoordsPoint3D(this.m_cartCenter3D),this.m_d=this.m_cartCenter3D.length(),this.m_normal.divThis(this.m_d),mt.selectRightHandedBasisFromNormal(this.m_normal,this.m_basisX,this.m_basisY),this.m_northPolePcs=this.projectPoint(y.construct(0,.5*Math.PI/this.m_rpu)),this.m_southPolePcs=this.projectPoint(y.construct(0,.5*-Math.PI/this.m_rpu))}project(t){const e=t.getGeometryType();if(We(e)){ir(t);const s=t;return this.projectMultiVertex(s)}H("Gnomonic.project")}unproject(t,e,s){const i=t.getGeometryType();if(We(i)){ir(t);let n=t;const o=[];if(i===T.enumPolygon){const a=n.getPathCount();for(let h=0;h<a;h++){const m=n.calculateRingArea2D(h);o.push(m)}}return this.unprojectMultiVertex(e,n),lt(i)?(bC(this.m_gcs,0,n),fC(o,this.m_gcs,0,n,s)):n=Tn(n,this.m_gcs,0,!0,0,s),n}H("Gnomonic.unproject")}projectPoint(t){const e=t.mul(this.m_rpu),s=ae(this.m_a,this.m_e2,e),i=this.m_normal.dotProduct(s);if(i<=0)return y.construct(Number.NaN,Number.NaN);const n=this.m_d/i,o=s.mul(n).sub(this.m_cartCenter3D),a=new y;return a.x=this.m_basisX.dotProduct(o),a.y=this.m_basisY.dotProduct(o),a}unprojectPoint(t){const e=this.m_cartCenter3D.add(this.m_basisX.mul(t.x).add(this.m_basisY.mul(t.y)));return Dn(this.m_a,this.m_e2,e).divide(this.m_rpu)}projectMultiVertex(t){const e=t.getImpl();let s=!0;const i=new y,n=new y;for(let o=0,a=e.getPointCount();o<a;o++)e.queryXY(o,i),i.y*this.m_rpu>.5*Math.PI?n.assign(this.m_northPolePcs):i.y*this.m_rpu<.5*-Math.PI?n.assign(this.m_southPolePcs):n.assign(this.projectPoint(i)),e.setXYNoCurves(o,n),n.isNAN()&&(s=!1);return e.notifyModifiedFlags(2001),s}unprojectMultiVertex(t,e){const s=e.getImpl(),i=t*t,n=!this.m_northPolePcs.isNAN(),o=!this.m_southPolePcs.isNAN();for(let a=0,h=s.getPointCount();a<h;a++){const m=s.getXY(a);let l=new y;n&&y.sqrDistance(m,this.m_northPolePcs)<=i?(l.setCoords(this.m_curvCenterRad.x,.5*Math.PI),l.scale(1/this.m_rpu)):o&&y.sqrDistance(m,this.m_southPolePcs)<=i?(l.setCoords(this.m_curvCenterRad.x,.5*-Math.PI),l.scale(1/this.m_rpu)):l=this.unprojectPoint(m),s.setXYNoCurves(a,l)}s.notifyModifiedFlags(2001)}}function fC(r,t,e,s,i){const n=s.getGeometryType(),o=t.getPannableExtent();let a=s,h=!1,m=!1;if(n===T.enumPolygon){const l=new F,u=y.construct(e,0);l.setCoords({env2D:o}),l.centerAt(u),h=xC(r,t,l,a,i);const c=vC(t,l,a,i);c!==a&&(m=!0),a=c}else a=new Rs().foldInto360RangeGeodetic(a,t,2);n===T.enumPolygon&&(h||m)&&(a=new Us().execute(a,t,!1,i)),a!==s&&(s.setEmpty(),s.add(a,!1))}function xC(r,t,e,s,i){const n=yC(e,s),o=PC(r,t,e,s,i);return n||o}function yC(r,t){const e=new F;t.queryEnvelope(e);const s=bt(r.ymax,e.ymax),i=bt(r.ymin,e.ymin),n=s||i;return!!n&&(CC(r,t),n)}function PC(r,t,e,s,i){const n=[],o=[],a=.5*e.width();for(let u=0;u<s.getPathCount();u++){const c=s.getXY(s.getPathStart(u)),g=s.getXY(s.getPathEnd(u)-1),_=r[u]<0;if(Math.abs(c.x-g.x)>a){const d=EC(_,t,e,u,s,i);n.push(d),o.push(u)}else if(!_&&s.calculateRingArea2D(u)<0){const d=SC(t,e,u,s,i);n.push(d),o.push(u)}}if(n.length===0)return!1;const h=new ct({vd:s.getDescription()});let m=0,l=o[m];for(let u=0;u<s.getPathCount();u++)u===l?(h.add(n[m],!1),m++,m<o.length&&(l=o[m])):h.addPath(s,u,!0);return s.setEmpty(),s.add(h,!1),!0}function CC(r,t){const e=new ct,s=new F;for(let i=0;i<t.getPathCount();i++){t.queryPathEnvelope(i,s);let n=bt(r.ymax,s.ymax),o=bt(r.ymin,s.ymin);if(!(n||o)){e.addPath(t,i,!0);continue}e.insertPath2D(-1,null,0,0,!0);const a=t.getPathStart(i),h=t.getPathEnd(i),m=h-a;let l=-1;for(l=a;l<h;l++){const _=t.getXY(l);if(n=bt(r.ymax,_.y),o=bt(r.ymin,_.y),!n&&!o)break}let u=l,c=!1,g=Number.NaN;do{const _=t.getXY(u);n=bt(r.ymax,_.y),o=bt(r.ymin,_.y);const d=a+(u+1-a)%m;if(n||o){let p=y.construct(g,_.y);e.insertPoint2D(i,-1,p);const f=t.getXY(d),x=bt(r.ymax,f.y),E=bt(r.ymin,f.y);x||E||(p=y.construct(f.x,_.y),c?e.setXYNoCurves(e.getPointCount()-1,p):e.insertPoint2D(i,-1,p)),c=!0}else e.insertPoint2D(i,-1,_),g=_.x,c=!1;u=d}while(u!==l)}t.setEmpty(),t.add(e,!1)}function EC(r,t,e,s,i,n){const o=new ct,a=new ct,h=new pt,m=i.getXY(i.getPathStart(s)),l=i.getXY(i.getPathEnd(s)-1),u=e.width(),c=.5*u,g=new F;i.queryEnvelope(g);const _=Math.ceil(g.width()/u)+1;let d,p;m.x>l.x?(d=-u,p=r?e.ymin:e.ymax):(d=u,p=r?e.ymax:e.ymin),h.setShiftCoords(d,0),o.addPath(i,s,!0),a.add(o,!1);const f=new st;for(let q=0;q<_;q++)a.applyTransformation(h),a.getPointByVal(0,f),o.lineToPoint(f),o.addSegmentsFromPath(a,0,0,a.getSegmentCount()-1,!1);const x=o.getXY(0),E=o.getXY(o.getPointCount()-1);x.y=p,E.y=p,o.lineTo(E);const P=new y;for(P.setCoordsPoint2D(E),P.x-=.5*d;Math.abs(P.x-x.x)>c;)o.lineTo(P),P.x-=.5*d;o.lineTo(x);const C=e.getCenter().x,S=new F;o.queryEnvelope(S);let I=0;const w=S.getCenter().x;w-C>c?I=-Math.ceil((w-C-c)/u):C-w>c&&(I=Math.ceil((C-w-c)/u)),I!==0&&(h.setShiftCoords(I*u,0),o.applyTransformation(h));const D=new Lt,N=D.addGeometry(o);Nn(D,N,t,0,2,!0,e.xmin),Nn(D,N,t,0,2,!0,e.xmax);const A=D.getGeometry(N),M=Sm(A,e);M.inflateCoords(0,1);const G=re(null,M,!0);return Dt(A,e,G.total(),Number.NaN,n)}function SC(r,t,e,s,i){const n=t.width(),o=.5*n,a=t.getCenter().x,h=new F;s.queryPathEnvelope(e,h);let m,l=0,u=h.getCenter().x;if(u-a>o?l=-Math.ceil((u-a-o)/n):a-u>o&&(l=Math.ceil((a-u-o)/n)),l!==0){const d=new pt;d.setShiftCoords(l*n,0),s.getImpl().applyTransformationToPath(d,e),s.queryPathEnvelope(e,h),u=h.getCenter().x}const c=new F;t.containsExclusiveEnvelope(h)?(m=!1,c.setCoords({env2D:t})):(m=!0,c.setCoords({env2D:t}),c.xmin-=n,c.xmax+=n);let g=s.createInstance();g.addPathPoint2D(null,0,!0);const _=new y;if(_.setCoords(c.xmin,c.ymin),g.insertPoint2D(0,-1,_),_.setCoords(c.xmin,c.ymax),g.insertPoint2D(0,-1,_),_.setCoords(.5*(c.xmin+c.xmax),c.ymax),g.insertPoint2D(0,-1,_),_.setCoords(c.xmax,c.ymax),g.insertPoint2D(0,-1,_),_.setCoords(c.xmax,c.ymin),g.insertPoint2D(0,-1,_),_.setCoords(.5*(c.xmin+c.xmax),c.ymin),g.insertPoint2D(0,-1,_),m){g.addPath(s,e,!0);const d=new pt;u<a?d.setShiftCoords(n,0):d.setShiftCoords(-n,0),s.getImpl().applyTransformationToPath(d,e),g.addPath(s,e,!0);const p=new Lt,f=p.addGeometry(g);Nn(p,f,r,0,2,!0,t.xmin),Nn(p,f,r,0,2,!0,t.xmax),g=p.getGeometry(f);const x=Sm(g,t);x.inflateCoords(0,1);const E=re(null,x,!0).total();g=Dt(g,t,E,Number.NaN,i)}else g.addPath(s,e,!0);return g}function vC(r,t,e,s){const i=new F;e.queryEnvelope(i);const n=Oe(null,e,!0).total();if(t.xmin-i.xmin<=n&&i.xmax-t.xmax<=n)return e;const o=e.createInstance();let a=e.createInstance();const h=new F,m=e.getPathCount();for(let l=0;l<m;l++)e.queryPathEnvelope(l,h),t.xmin-h.xmin<=n&&h.xmax-t.xmax<=n?o.addPath(e,l,!0):(a.setEmpty(),a.addPath(e,l,!0),a=sd(r,t,a,!0,s),o.add(a,!0));return o}function bC(r,t,e){const s=r.getPannableExtent(),i=y.construct(t,0);s.centerAt(i);const n=s.width(),o=.5*n,a=new y;a.setNAN();let h=Number.NaN;for(let m=0;m<e.getPathCount();m++)for(let l=e.getPathStart(m);l<e.getPathEnd(m);l++){const u=e.getXY(l),c=bt(u.y,s.ymax)||bt(s.ymin,u.y);l===e.getPathStart(m)?(a.setNAN(),h=0):a.isNAN()||c||(h=IC(u.x,a.x,o,n,h)),u.x+=h,e.setXYNoCurves(l,u),c||a.setCoordsPoint2D(u)}e.getImpl().notifyModifiedFlags(2001)}function IC(r,t,e,s,i){return i+r-t>e?i-=s:t-(i+r)>e&&(i+=s),i}function Ac(r,t,e,s,i,n){const o=t.getAttributeStreamRef(0),a=t.getPointCount();let h=!1;const m=new y;for(let P=0;P<a;++P){if(o.queryPoint2D(2*P,m),1&n&&m.y>=e){h=!0;break}if(2&n&&m.y<=-e){h=!0;break}}if(!h)return!1;let l=!1;r&&(l=t.getImpl().isClosedPathInXYPlane(0));const u=new Lt,c=u.addGeometry(t),g=u.getFirstPath(c);let _=-1,d=!0;const p=new y,f=new st;let x=v;const E=nd*i/360;for(let P=u.getFirstVertex(g);P!==v;P=u.getNextVertex(P)){u.queryXY(P,m);let C=1&n&&m.y>=e?1:0;if(C|=2&n&&m.y<=-e?2:0,_>0&&_!==C){if(p.x!==m.x){const S=u.getPrevVertex(P);u.queryPoint(S,f);const I=u.insertVertex(g,P,f);p.x=m.x,u.setXY(I,p)}if(l){let S=x!==v?u.getNextVertex(x):u.getFirstVertex(g);const I=u.getPrevVertex(P);for(;S!==I;)S=u.removeVertex(S,!1);if(x!==v){const w=u.getXY(x),D=u.getXY(I);if(Math.abs(w.x-D.x)>E){u.queryPoint(x,f);const N=u.insertVertex(g,I,f);w.x=Ct(w.x,D.x,.5),u.setXY(N,w)}}}x=v}if(C&&(m.y=ri(s,m.y),u.setXY(P,m),!d&&_!==C))if(m.x!==p.x){u.queryPoint(P,f);const S=u.insertVertex(g,P,f);u.setXYCoords(S,p.x,m.y),x=S}else x=P;_=C,p.assign(m),d=!1}if(l){if(x!==v){let w=u.getNextVertex(x);for(;w!==v;)w=u.removeVertex(w,!1)}const P=u.getFirstVertex(g);let C=u.getLastVertex(g);const S=u.getXY(P),I=u.getXY(C);if(!S.equals(I)&&(u.queryPoint(P,f),C=u.insertVertex(g,v,f),Math.abs(S.x-I.x)>E)){const w=u.insertVertex(g,C,f);S.x=Ct(S.x,I.x,.5),u.setXY(w,S)}}return t.assignCopy(u.getGeometry(c)),!0}function wC(r,t){let e=new ct({vd:r});e.addEnvelope(t,!1);const s=t.width()/180;return e=new Fi().execute(e,s,0,0,null),e}function DC(r,t){const e=r.getPannableExtent();return Number.isNaN(t)||e.centerAtCoords(t,0),e}function TC(r,t,e){const s=sn();t.querySpheroidData(s);const i=t.getGCS()!==t?t.getSRToGCSTransform():null,n=R(y,100),o=new mt(0,0,0),a=r.getPointCount(),h=t.getGCS().getUnit().getUnitToBaseFactor();for(let c=0,g=a;c<g;){const _=Math.min(100,g-c);r.queryCoordinates(n,_,c,c+_),i&&new Rs().transform(i,n,_,n,!1);for(let d=0;d<_;d++){if(n[d].isNAN())continue;n[d].scale(h);const p=ae(s.majorSemiAxis,s.e2,n[d]);o.addThis(p)}c+=_}const m=Dn(s.majorSemiAxis,s.e2,o);m.scale(1/h);const l=r;if(!new id(t.getGCS(),m).project(l))return 0;e.length=r.getPathCount();const u=l.calculateArea2D()<0;for(let c=0,g=r.getPathCount();c<g;c++){const _=l.calculateRingArea2D(c),d=u?_<0:_>0;e[c]=d}return u?-1:1}function NC(r,t,e,s,i){if(!t.isPannable()||r.isEmpty())return r;const n=r.getGeometryType();n===T.enumGeometryCollection&&ft("not yet impl for geometry collection");const o=t.getPannableExtent();Number.isNaN(e)&&(e=o.getCenterX());const a=o.width(),h=.5*a,m=i>0,l=r.queryInterval(0,0);if(!m&&l.width()<h||!We(r.getGeometryType())){const u=l.getCenter();if(Math.abs(u-e)<=h)return r;{const c=new pt,g=Hi((e-u)/a)*a;c.setShiftCoords(g,0);const _=r.clone();return _.applyTransformation(c),_}}if(n===T.enumPolygon){let u=new Pt({vd:r.getDescription()});u.addAndExplicitlyOpenAllPaths(r,!1),m&&(u=rm(u,t,2,i,Number.NaN,null,!0));const c=[];if(!s){{let g=r;m&&(g=new ct,g.add(u,!1));const _=TC(r,t,c);if(_)_<0&&u.reverseAllPaths();else{const d=g.getPathCount();for(let p=0;p<d;p++)c.push(g.calculateRingArea2D(p)>0)}}s=c}return new Jo(null,s,u,null,t,e,3,0,null).geoNormalizePolygonGeometry(!0)}if(n===T.enumPolyline){let u=new Pt({vd:r.getDescription()});return u.addAndExplicitlyOpenAllPaths(r,!1),m&&(u=rm(u,t,2,i,Number.NaN,null,!0)),new Jo(null,null,u,null,t,e,3,0,null).geoNormalizePolylineGeometry(!0)}if(n===T.enumMultiPoint){const u=r,c=u.getAttributeStreamRef(0);let g,_=null,d=e,p=0;const f=.1*a;for(let x=0,E=u.getPointCount();x<E;x++){const P=c.read(2*x);let C=P-d;if(Math.abs(C)>h&&(C=Hi(C/a)*a,p-=C,Math.abs(p)<f&&(p=0)),p!==0){_||(g=r.clone(),_=g.getAttributeStreamRef(0));const S=P+p;_.write(2*x,S)}d=P}return _?(g.notifyModified(),g):r}$("")}const nd=210;class Jo{constructor(t,e,s,i,n,o,a,h,m){this.m_bAdjustedAtPoles=0,this.m_inputPoly=s,this.m_progressTracker=m,this.m_originalGeometry=t,this.m_originalSR=i,this.m_polygonRingFlags=e,this.m_pannableSR=n,this.m_poleSnappingTolerance=h,this.m_poleFlags=a,this.m_bAdjustedAtPoles=0,this.m_pannableExtent=DC(this.m_pannableSR,o),this.m_centralLongitude=Number.isNaN(o)?this.m_pannableExtent.getCenterX():o,this.m_width360=this.m_pannableExtent.width(),this.m_degree=this.m_width360/360,this.m_GCSLargeDelta=nd*this.m_degree,b(this.m_originalGeometry===null&&this.m_originalSR===null||this.m_originalGeometry!==null&&this.m_originalSR!==null)}geonormalizeRing(t,e,s,i,n,o,a){let h=s;const m=new Pt({vd:this.m_inputPoly.getDescription()});m.addPath(this.m_inputPoly,t,!0),this.m_poleFlags!==0&&(this.m_bAdjustedAtPoles|=Ac(!0,m,this.m_pannableExtent.ymax-this.m_poleSnappingTolerance,this.m_pannableExtent.ymax,this.m_pannableExtent.width(),this.m_poleFlags)?1:0,this.m_bAdjustedAtPoles&&(h=!1));let l=-1;h&&(l=this.m_originalGeometry.getPathStart(t));const u=m.getAttributeStreamRef(0),c=m.getPointCount();let g=0,_=u.read(0),d=0;const p=3*this.m_pannableSR.getTolerance(0);let f=!1;const x=new y,E=new y;let P=!1;const C=m.hasNonLinearSegments(),S=new y;for(let D=1;D<c;++D){u.queryPoint2D(2*D,S);const N=S.x;let A=N+g;const M=A-_;if(S.x=A,Math.abs(M)>this.m_GCSLargeDelta){if(h){const G=l+D-1,q=l+(D+1<c?D:0),V=o.read(2*G),k=(o.read(2*q)-V)*i;Math.abs(M-k)>1*this.m_degree&&(h=!1)}h||(g-=ri(this.m_width360,A-_),A=N+g,++d,P=g!==0,S.x=A)}else f||Pp(x,E,S,p)&&(f=!0);P&&(C&&$("error in geonormalize_ring_ for curves"),u.write(2*D,A)),_=A,x.setCoordsPoint2D(E),E.setCoordsPoint2D(S)}d&&m.notifyModified();const I=m.getXY(0),w=m.getXY(c-1);if(y.distance(I,w)<p){const D=this.finalizeGeoNormalizeClosedRing(m,f,n);a.add(D,!1)}else{e<0&&(this.m_originalGeometry!==null?(b(this.m_originalGeometry!==null),e=this.m_originalGeometry.calculateRingArea2D(t)>0?1:0):e=1);const D=this.finalizeGeoNormalizeOpenedRing(e>0,m);a.add(D,!1)}}geoNormalizePolygonGeometry(t){b(this.m_originalSR&&this.m_originalGeometry||!this.m_originalGeometry&&!this.m_originalSR),b(this.m_pannableSR.isPannable());let e=null,s=Number.NaN;const i=!!this.m_originalSR&&this.m_originalSR.isPannable();i&&(e=this.m_originalGeometry.getAttributeStreamRef(0),s=this.m_width360/this.m_originalSR.getPannableExtent().width()),this.m_bAdjustedAtPoles=0;const n=new ct({vd:this.m_inputPoly.getDescription()});for(let _=0,d=this.m_inputPoly.getPathCount();_<d;++_){const p=this.m_polygonRingFlags?this.m_polygonRingFlags[_]?1:0:-1;this.geonormalizeRing(_,p,i,s,t,e,n)}const o=this.m_pannableSR.getTolerance(0),a=this.m_pannableExtent.width()/180;ia(n,this.m_pannableExtent,.1*o,!1);const h=F.constructEmpty();if(h.setCoords({env2D:this.m_pannableExtent}),t){let _=!0;for(let d=0;d<2;d++){_=!0;const p=F.constructEmpty();for(let f=0,x=n.getPathCount();f<x;f++)if(n.queryPathEnvelope(f,p),!(h.xmin<=p.xmin&&h.xmax>=p.xmax||p.xmin>=h.xmax||p.xmax<=h.xmin)){_=!1;break}if(_)break;h.move(.5*this.m_width360,0)}_||h.setCoords({env2D:this.m_pannableExtent})}let m=Dt(n,h,o,a,this.m_progressTracker),l=n!==m;const u=this.m_originalGeometry?this.m_originalGeometry.calculateArea2D():1,c=m.calculateArea2D();let g=0;if(c>0&&u<0)g=1;else if(c<=0&&u>0)if(c===0){if(this.m_originalSR){let _=Number.NaN;this.m_originalSR.getCoordinateSystemType()===2?_=this.m_originalSR.getPCSHorizon().calculateArea2D():this.m_originalSR.getCoordinateSystemType()===1&&(_=this.m_originalSR.getPannableExtent().getArea()),u>.99*_&&(g=-1)}}else g=-1;if(g!==0){const _=wC(m.getDescription(),h);_.add(m,!1),l=!0,m=_}return l&&(m=new Us().execute(m,this.m_pannableSR,!1,this.m_progressTracker)),m}geoNormalizePolylineGeometry(t){b(this.m_pannableSR.isPannable());let e=null;const s=this.m_originalSR&&this.m_originalSR.isPannable();let i=1;s&&(b(this.m_originalGeometry),i=this.m_width360/this.m_originalSR.getPannableExtent().width(),e=this.m_originalGeometry.getAttributeStreamRef(0));const n=this.m_pannableExtent.width(),o=n*jt()*4;let a=t,h=Number.NaN;const m=z.constructEmpty();this.m_bAdjustedAtPoles=0;let l=new Pt({vd:this.m_inputPoly.getDescription()});for(let g=0,_=this.m_inputPoly.getPathCount();g<_;++g){let d=s;const p=new Pt({vd:this.m_inputPoly.getDescription()});p.addPath(this.m_inputPoly,g,!0);const f=this.m_inputPoly.isClosedPath(g);this.m_poleFlags!==0&&(this.m_bAdjustedAtPoles|=Ac(f,p,this.m_pannableExtent.ymax-this.m_poleSnappingTolerance,this.m_pannableExtent.ymax,n,this.m_poleFlags)?1:0,this.m_bAdjustedAtPoles&&(d=!1));let x=-1;const E=p.getPointCount();let P=!1;d&&(x=this.m_originalGeometry.getPathStart(g),P=this.m_originalGeometry.isClosedPath(g));const C=p.getAttributeStreamRef(0);let S=0,I=C.read(0),w=0;const D=new y,N=new y;let A=!1;const M=p.hasNonLinearSegments(),G=new y;for(let q=1;q<E;++q){C.queryPoint2D(2*q,G);const V=G.x;let k=V+S;const Y=k-I;if(G.x=k,Math.abs(Y)>this.m_GCSLargeDelta){if(d){const U=x+q-1;let X=x;(!P||q+1<E)&&(X+=q);const B=e.read(2*U),W=(e.read(2*X)-B)*i;Math.abs(Y-W)>1*this.m_degree&&(d=!1)}d||(S-=ri(this.m_width360,k-I),k=V+S,++w,A=S!==0,G.x=k)}A&&(M&&$("error in geonormalize_ring_ for curves"),C.write(2*q,k)),I=k,D.setCoordsPoint2D(N),N.setCoordsPoint2D(G)}if(w&&p.notifyModified(),a){let q=!1;if(!p.isEmpty()){const V=F.constructEmpty();if(p.queryEnvelope(V),V.width()>=n||V.ymin<=this.m_pannableExtent.ymin||V.ymax>=this.m_pannableExtent.ymax)q=!0;else{if(Number.isNaN(h)){const Y=this.m_centralLongitude-.5*n;h=V.xmin,h+=Math.round((Y-V.xmin)/n)*n,h>Y&&(h-=n),b(h<=Y),h<Y&&(h+=n),b(h>=Y)}let k=Math.round((h-V.xmin)/n)*n;if(V.xmin+k>h+o&&(k-=n),V.xmin+k<h-o&&(k+=n),m.mergeCoordinate(V.xmin+k),m.mergeCoordinate(V.xmax+k),q=m.width()>=n,!q){const Y=new pt;Y.setShiftCoords(k,0),p.applyTransformation(Y)}}}l.add(p,!1),q&&(l=(()=>{const V=new Pt({vd:l.getDescription()});for(let k=0,Y=l.getPathCount();k<Y;++k){const U=new Pt({vd:l.getDescription()});U.addPath(l,k,!0);const X=Tn(U,this.m_pannableSR,this.m_centralLongitude,!0,0,this.m_progressTracker);V.add(X,!1)}return V})(),a=!1)}else{const q=Tn(p,this.m_pannableSR,this.m_centralLongitude,!0,0,this.m_progressTracker);l.add(q,!1)}}if(a)return l;const u=this.m_pannableSR.getTolerance(0),c=this.m_pannableExtent.width()/180;return ia(l,this.m_pannableExtent,.1*u,!1),Dt(l,this.m_pannableExtent,u,c,this.m_progressTracker)}finalizeGeoNormalizeOpenedRing(t,e){const s=e.getPointCount(),i=e.getXY(0),n=e.getXY(s-1);{const D=Math.abs(n.x-i.x),N=Math.round(D/this.m_width360)*this.m_width360;b(Math.abs(D-N)<this.m_pannableSR.getTolerance(0))}const o=kt(n.x-i.x),a=F.constructEmpty();e.queryLooseEnvelope(a);const h=this.m_pannableExtent.getCenterX();let m=0,l=h-this.m_width360,u=h+this.m_width360;if(o>=0){let D=Math.ceil((l-a.xmin)/this.m_width360);for(D*=this.m_width360;l>a.xmin+D;)D+=this.m_width360;for(;l<a.xmax+D;)D-=this.m_width360;for(m=D,a.width()>720&&(u=l+360*Math.ceil(a.width()/360));u<a.xmax;)u+=this.m_width360}else{let D=Math.ceil((u-a.xmax)/this.m_width360);for(D*=this.m_width360;u<a.xmax+D;)D-=this.m_width360;for(;u>a.xmin+D;)D+=this.m_width360;for(m=D,a.width()>720&&(l=u-360*Math.ceil(a.width()/360));l>a.xmin;)l-=this.m_width360}const c=Math.round(Math.abs(n.x-i.x)/this.m_width360)*this.m_width360,g=o*c,_=a.clone();_.move(m,0);const d=new y(0,0),p=new pt;p.setShiftCoords(m,0),e.applyTransformation(p);const f=new Pt({vd:e.getDescription()});f.add(e,!1),d.assign(e.getXY(s-1));let x=0,E=f.getXY(0).x;for(;o>0?_.xmax<u:_.xmin>l;)_.move(g,0),p.xd=g,e.applyTransformation(p),E+=g,this.m_pannableExtent.xmin<=E&&this.m_pannableExtent.xmax>=E&&(x=f.getPointCount()-1),e.setXY(0,d),d.assign(e.getXY(s-1)),f.addSegmentsFromPath(e,0,0,s-1,!1);const P=new ct({vd:f.getDescription()});P.add(f,!1);const C=f.getXY(0),S=f.getXY(f.getPointCount()-1),I=o<0?t:!t,w=P.getPointCount()-1;if(I){const D=new y(S.x,this.m_pannableExtent.ymax);P.lineTo(D);const N=new y(this.m_pannableExtent.getCenterX(),this.m_pannableExtent.ymax);P.lineTo(N);const A=new y(C.x,this.m_pannableExtent.ymax);P.lineTo(A)}else{const D=new y(S.x,this.m_pannableExtent.ymin);P.lineTo(D);const N=new y(this.m_pannableExtent.getCenterX(),this.m_pannableExtent.ymin);P.lineTo(N);const A=new y(C.x,this.m_pannableExtent.ymin);P.lineTo(A)}if(P.interpolateAttributesPath(0,w,0),P.getImpl().changeRingStartPoint(x),c>this.m_width360){const D=new ct({copy:P});p.setShiftCoords(this.m_width360,0),D.applyTransformation(p),P.add(D,!1)}return P}finalizeGeoNormalizeClosedRing(t,e,s){const i=new ct({vd:t.getDescription()});i.add(t,!1);const n=()=>{const l=i.getPointCount()-2;return i.getSegmentType(l)!==T.enumLine};if(i.hasNonLinearSegments()&&n()){const l=new it,u=i.getPointCount()-2;i.getSegmentBuffer(u,l,!1),i.removePointFromPath(0,u+1),i.closeLastPathWithSegment(l.get())}else i.removePointFromPath(0,i.getPointCount()-1);const o=F.constructEmpty();i.queryLooseEnvelope(o);let a=Math.ceil((this.m_pannableExtent.xmin-o.xmin)/this.m_width360);for(a*=this.m_width360;this.m_pannableExtent.xmin>o.xmin+a;)a+=this.m_width360;for(;this.m_pannableExtent.xmin<o.xmax+a;)a-=this.m_width360;if(a+=this.m_width360,a!==0){o.move(a,0);const l=new pt;l.setShiftCoords(a,0),i.applyTransformation(l)}if(this.m_pannableExtent.xmin<=o.xmin&&this.m_pannableExtent.xmax>=o.xmax){if(e){const u=i.calculateArea2D(),c=new Us().execute(i,this.m_pannableSR,!0,this.m_progressTracker);if(c!==i){const g=c.calculateArea2D();kt(u)!==kt(g)&&c.reverseAllPaths(),i.assignMove(c)}}let l;if(l=new ct(s?{copy:i}:{move:i}),s)for(;o.xmin<this.m_pannableExtent.xmax;){o.move(this.m_width360,0);const u=new pt;u.setShiftCoords(this.m_width360,0),i.applyTransformation(u),l.add(i,!1)}return l}let h=new ct({vd:t.getDescription()});h.add(i,!1);const m=e||o.width()>this.m_width360-10*this.m_pannableSR.getTolerance(0);for(;o.xmin<this.m_pannableExtent.xmax;){o.move(this.m_width360,0);const l=new pt;l.setShiftCoords(this.m_width360,0),i.applyTransformation(l),h.add(i,!1)}if(m){const l=h.calculateArea2D();h.setFillRule(1),h=new Us().execute(h,this.m_pannableSR,!0,this.m_progressTracker);const u=h.calculateArea2D();kt(l)!==kt(u)&&h.reverseAllPaths()}return h}geonormalize_ring_(t,e,s,i,n,o,a){b(0)}}function qc(r){b(0);const t=WE(r),e=new FC;return e.setVertProj_(t),e}function AC(r,t=!0){return b(0),{}}function qC(r){return iS()}class FC{constructor(){this.m_hashCode=0,this.m_peVertSysVal=null,this.m_verticalUnit=new hi,this.m_verticalShift=0,this.m_userVerticalWKID=0,this.m_bIsDepth=!1}getType(){return b(0),0}getID(){return b(0),0}getLatestID(){return this.m_peVertSysVal?this.m_peVertSysVal.getLatestID():0}getOldID(){return this.m_peVertSysVal?this.m_peVertSysVal.getOldID():0}getText(){return b(0),""}getTextExtended(t){return b(0),""}getText2(t){return b(0),""}getUnit(){return b(0),{}}equals(t){return b(0),!1}equalForProjection(t){return b(0),!1}getPeVertcsCopy(){return b(0),{}}getOneMeter(){return 1/this.m_verticalUnit.getUnitToBaseFactor()}getUnitToBaseFactor(){return b(0),0}isDepth(){return b(0),!1}getVerticalShift(){return b(0),0}isCustomWkid(){return!!this.m_peVertSysVal&&this.m_peVertSysVal.isCustomWkid()}getHashCode(){return this.m_hashCode}setVertProj_(t){this.m_peVertSysVal=t}getPEVerticalCoordSys(){return this.m_peVertSysVal?this.m_peVertSysVal.m_peVertcs:null}}function ba(r,t,e,s,i){if(r.equals(t))return!1;if(s){let a=1,h=0,m=1,l=1,u=0,c=1;Number.isNaN(r.m_heightMetersPerUnit)||(a=r.m_heightMetersPerUnit,h=r.m_heightZ0,m=r.m_heightSign,l=t.m_heightMetersPerUnit,u=t.m_heightZ0,c=t.m_heightSign);const g=m*c*a/l;for(let _=0;_<i;_++)s[_]=(s[_]-h)*g+u}let n=1,o=0;if(Number.isNaN(r.m_XYToRadians)||(n=r.m_XYToRadians/t.m_XYToRadians,o=r.m_PrimeMeridianDegrees-t.m_PrimeMeridianDegrees,o!==0&&(o=Zg(o),o/=t.m_XYToRadians)),Array.isArray(e)){const a=e;for(let h=0;h<i;h++)a[h][0]=a[h][0]*n+o,a[h][1]=a[h][1]*n}else{const a=e;for(let h=0;h<i;h++){const m=h<<1;a[m]=a[m]*n+o,a[m+1]=a[m+1]*n}}return!0}function ks(){return{m_heightMetersPerUnit:0,m_heightSign:0,m_heightZ0:0,m_XYToRadians:0,m_PrimeMeridianDegrees:0,assign(r){this.m_heightMetersPerUnit=r.m_heightMetersPerUnit,this.m_heightSign=r.m_heightSign,this.m_heightZ0=r.m_heightZ0,this.m_XYToRadians=r.m_XYToRadians,this.m_PrimeMeridianDegrees=r.m_PrimeMeridianDegrees},equals(r){return ze(this.m_heightSign,r.m_heightSign)&&ze(this.m_heightMetersPerUnit,r.m_heightMetersPerUnit)&&ze(this.m_heightZ0,r.m_heightZ0)&&ze(this.m_XYToRadians,r.m_XYToRadians)&&ze(this.m_PrimeMeridianDegrees,r.m_PrimeMeridianDegrees)},initFromGcsAndVcsPe(r,t){this.m_heightSign=1,this.m_heightMetersPerUnit=Number.NaN,this.m_heightZ0=0,this.m_XYToRadians=Number.NaN,this.m_PrimeMeridianDegrees=Number.NaN,t&&b(0),r&&(this.m_XYToRadians=r.getUnit().getUnitFactor(),this.m_PrimeMeridianDegrees=r.getPrimem().getLongitude())},initFromGcsAndVcs(r,t){const e=r?r.getPECoordSys():null,s=t?t.getPEVerticalCoordSys():null;this.initFromGcsAndVcsPe(e,s)},processUnitParams(r){Number.isNaN(this.m_heightMetersPerUnit)&&(this.m_heightMetersPerUnit=r.m_heightMetersPerUnit,this.m_heightSign=r.m_heightSign,this.m_heightZ0=r.m_heightZ0),Number.isNaN(this.m_XYToRadians)&&(this.m_XYToRadians=r.m_XYToRadians,this.m_PrimeMeridianDegrees=r.m_PrimeMeridianDegrees)}}}class MC{constructor(t){this.m_constantsLoaded=-1,this.m_isUsable=-1,this.m_inputSR=null,this.m_outputSR=null,this.m_inputSRHorz=null,this.m_outputSRHorz=null,this.m_inputVCS=null,this.m_outputVCS=null,this.m_hashCode=0,this.m_areaOfUse=new Ne,this.m_inputUnitParams=ks(),this.m_outputUnitParams=ks(),b(t),this.m_geogTran=t,this.m_vertTran=null,this.m_latestID=oe.getCode(this.m_geogTran),this.m_latestID<0&&(this.m_latestID=0);const e=this.m_geogTran.getGeogcs1();oe.getCode(e);const s=this.m_geogTran.getGeogcs2();oe.getCode(s),this.initUnitParams()}getLatestId(){return this.m_latestID}getText(){return this.m_geogTran?this.m_geogTran.toString():(b(0),"")}getGeogtran(){return this.m_geogTran}getVerttran(){return null}loadConstants(t){let e=this.m_constantsLoaded;if(e===-1){if(!t){this.m_geogTran||$("vcs not impl");const s=this.m_geogTran.getParameters();s[et.PE_PARM_ND]!==null&&(t=s[et.PE_PARM_ND].getValue()===0)}e=this.m_geogTran.loadConstants()?1:0,this.m_constantsLoaded=e}return e!==0}isUsable(){let t=this.m_isUsable;return t===-1&&(this.m_geogTran?this.m_isUsable=t=this.m_geogTran?1:0:this.m_isUsable=t=this.m_vertTran?1:0),t===1}getInputSr(t){return this.updateSrs(),t?this.m_inputSR:this.m_inputSRHorz}getOutputSr(t){return this.updateSrs(),t?this.m_outputSR:this.m_outputSRHorz}getHashCode(){let t=this.m_hashCode;return t===0&&(t=this.m_latestID>0?qs(this.m_latestID):jc(this.getText()),t===0&&(t=345),this.m_hashCode=t),t}isGeogtran(){return this.m_geogTran!==null}prepareOrThrow(){}getName(){return this.isGeogtran()?this.getGeogtran().getName():(ft("vcs not impl"),"")}updateSrs(){if(this.m_inputSR||this.m_inputVCS)return;let t,e,s,i,n,o;if(this.m_geogTran){const a=this.m_geogTran.getGeogcs1(),h=na(a),m=this.m_geogTran.getGeogcs2(),l=na(m);let u=-1,c=-1;u=h.getVcsCode(),c=l.getVcsCode(),s=Ar(a,null,null,1),i=Ar(m,null,null,1),u>0&&c>0?(n=qc(u),o=qc(c),t=pm(),e=pm()):(t=s,e=i)}else b(0);this.m_inputSR||this.m_inputVCS||(this.m_inputSR=t,this.m_outputSR=e,this.m_inputSRHorz=s,this.m_outputSRHorz=i,this.m_inputVCS=n,this.m_outputVCS=o)}initUnitParams(){if(this.m_inputUnitParams.m_heightSign=1,this.m_inputUnitParams.m_heightMetersPerUnit=Number.NaN,this.m_inputUnitParams.m_heightZ0=0,this.m_outputUnitParams.m_heightSign=1,this.m_outputUnitParams.m_heightMetersPerUnit=Number.NaN,this.m_outputUnitParams.m_heightZ0=0,this.m_inputUnitParams.m_XYToRadians=Number.NaN,this.m_inputUnitParams.m_PrimeMeridianDegrees=Number.NaN,this.m_outputUnitParams.m_XYToRadians=Number.NaN,this.m_outputUnitParams.m_PrimeMeridianDegrees=Number.NaN,this.m_vertTran)b(0);else if(this.m_geogTran){const t=this.m_geogTran;let e=t.getGeogcs1();this.m_inputUnitParams.m_XYToRadians=e.getUnit().getUnitFactor(),this.m_inputUnitParams.m_PrimeMeridianDegrees=e.getPrimem().getLongitude(),e=t.getGeogcs2(),this.m_outputUnitParams.m_XYToRadians=e.getUnit().getUnitFactor(),this.m_outputUnitParams.m_PrimeMeridianDegrees=e.getPrimem().getLongitude()}}}function rd(r,t,e,s,i,n,o){let a=null;t&&(a=t.getPEVerticalCoordSys());let h=null;r&&(h=r.getPECoordSys());let m=null;s&&(m=s.getPEVerticalCoordSys());let l=null;if(e&&(l=e.getPECoordSys()),!(h||a||l||m))return!1;const u=ks();u.initFromGcsAndVcsPe(h,a);const c=ks();return c.initFromGcsAndVcsPe(l,m),ba(u,c,i,n,o)}function GC(r,t,e,s,i,n,o,a){const h=t,m=r,l=ks();l.initFromGcsAndVcsPe(m,h),a.assign(s?e.m_outputUnitParams:e.m_inputUnitParams),a.processUnitParams(l),l.processUnitParams(a),o>0&&ba(l,a,i,n,o)}function VC(r,t,e,s,i,n,o,a){const h=ks();h.assign(e?t.m_inputUnitParams:t.m_outputUnitParams),h.processUnitParams(r);let m=null,l=null;s&&(l=s.getPECoordSys());const u=ks();u.initFromGcsAndVcsPe(l,m),u.processUnitParams(h),h.processUnitParams(u),a>0&&ba(h,u,n,o,a)}function YC(r,t,e,s,i,n,o,a,h){const m=ks(),l=ks();m.assign(e?t.m_inputUnitParams:t.m_outputUnitParams),l.assign(i?s.m_outputUnitParams:s.m_inputUnitParams),m.processUnitParams(r),l.processUnitParams(m),m.processUnitParams(l),a>0&&ba(m,l,n,o,a),h.assign(l)}function XC(r,t,e,s,i,n,o){const a=t.getVerttran(),h=t.getGeogtran();if(o.assign(e?t.m_inputUnitParams:t.m_outputUnitParams),o.processUnitParams(r),n>0){t.prepareOrThrow();const m=e?et.PE_TRANSFORM_2_TO_1:et.PE_TRANSFORM_1_TO_2;a?dd():pd(h,n,s,i,m)}}function RC(r,t,e,s,i){const n=r.getVerttran(),o=r.getGeogtran();if(i>0){r.prepareOrThrow();const a=t?et.PE_TRANSFORM_2_TO_1:et.PE_TRANSFORM_1_TO_2;n?dd():pd(o,i,e,s,a)}}class Qm{supportsCurves(){return!0}accelerateGeometry(t,e,s){return od(t,e,s)}canAccelerateGeometry(t){return Km(t)}}function od(r,t,e){if(!Km(r))return!1;or(t,r,!1);let s=0;const i=r.getGeometryType();return lt(i)&&Mo(r)&&e!==0&&(s|=r.getImpl().buildQuadTreeAccelerator(e)?1:0),lt(i)&&mg(r)&&e!==0&&(s|=r.getImpl().buildQuadTreeForPathsAccelerator(e)?1:0),s>0}function Km(r){return Mo(r)||mg(r)}class ad extends Qm{getOperatorType(){return 8}execute(t,e,s,i){return ti(t,e,s,1,i)}}function kC(r,t,e,s){if(r.isEmpty()||t.isEmpty())return r;const i=r.getDimension(),n=t.getDimension();if(i>n)return r;const o=r.getGeometryType(),a=t.getGeometryType(),h=new F,m=new F,l=new F;r.queryEnvelope(h),t.queryEnvelope(m),l.setCoords({env2D:h}),l.mergeEnvelope2D(m);const u=re(e,l,!0),c=ss(u),g=new F;if(g.setCoords({env2D:h}),g.inflateCoords(c,c),!g.isIntersecting(m))return r;if(i===1&&n===2){const d=ZC(r,t,a,e,s);if(d)return d}if(o===T.enumPoint){let d;switch(he(a)?(d=new Pt({vd:t.getDescription()}),d.addSegment(t,!0)):d=t,a){case T.enumPolygon:return BC(r,d,u);case T.enumPolyline:return HC(r,d,u);case T.enumMultiPoint:return zC(r,d,u);case T.enumEnvelope:return UC(r,d,u);case T.enumPoint:return OC(r,d,u);default:H("invalid shape type")}}else if(o===T.enumMultiPoint)switch(a){case T.enumPolygon:return WC(r,t,u);case T.enumEnvelope:return $C(r,t,u);case T.enumPoint:return jC(r,t,u)}const _=new F(h);return _.inflate(100*u.total()),FP(r,Dt(t,_,0,0,s),e,s)}class Ia{getOperatorType(){return 10002}supportsCurves(){return!0}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,s,i){return new LC(t,e,s,i)}execute(t,e,s,i){return this.executeMany(new oi([t]),new oi([e]),s,i).next()}}class LC extends mi{constructor(t,e,s,i){super(),this.m_progressTracker=i,this.m_index=-1,this.m_inputGeoms=t,this.m_spatialReference=s;const n=e.next();this.m_geomSubtractor=n||new ct}next(){const t=this.m_inputGeoms.next();return t?(ni(t),Jd(t),this.m_index=this.m_inputGeoms.getGeometryID(),kC(t,this.m_geomSubtractor,this.m_spatialReference,this.m_progressTracker)):null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}function BC(r,t,e,s){return k_(t,r,e.total())===0?r:r.createInstance()}function HC(r,t,e,s){const i=r.getXY(),n=t.querySegmentIterator(),o=ss(e),a=o*o;for(;n.nextPath();)for(;n.hasNextSegment();){const h=n.nextSegment(),m=new F;if(h.queryEnvelope(m),m.inflateCoords(o,o),!m.contains(i))continue;if(h.isIntersectingPoint(i,e.total()))return r.createInstance();let l=h.getStartXY();if(y.sqrDistance(i,l)<=a||(l=h.getEndXY(),y.sqrDistance(i,l)<=a))return r.createInstance()}return r}function zC(r,t,e,s){const i=t.getImpl().getAttributeStreamRef(0),n=t.getPointCount(),o=r.getXY(),a=ss(e),h=a*a,m=new y;for(let l=0;l<n;l++)if(i.queryPoint2D(2*l,m),y.sqrDistance(m,o)<=h)return r.createInstance();return r}function UC(r,t,e,s){const i=new F;t.queryEnvelope(i),i.inflate(e.total());const n=r.getXY();return i.contains(n)?r.createInstance():r}function OC(r,t,e,s){const i=ss(e),n=i*i,o=r.getXY(),a=t.getXY();return y.sqrDistance(o,a)<=n?r.createInstance():r}function WC(r,t,e,s){const i=new F;t.queryEnvelope(i),i.inflate(e.total());const n=r.getPointCount();let o=!1;const a=j(n,!1),h=new y;for(let l=0;l<n;l++)r.queryXY(l,h),i.contains(h)&&Ye(t,h,e.total())!==0&&(o=!0,a[l]=!0);if(!o)return r;const m=r.createInstance();for(let l=0;l<n;l++)a[l]||m.addPoints(r,l,l+1);return m}function $C(r,t,e,s){const i=new F;t.queryEnvelope(i),i.inflate(e.total());const n=r.getPointCount();let o=!1;const a=j(n,!1),h=new y;for(let l=0;l<n;l++)r.queryXY(l,h),i.contains(h)&&(o=!0,a[l]=!0);if(!o)return r;const m=r.createInstance();for(let l=0;l<n;l++)a[l]||m.addPoints(r,l,l+1);return m}function jC(r,t,e,s){const i=r.getImpl().getAttributeStreamRef(0),n=r.getPointCount(),o=t.getXY();let a=!1;const h=j(n,!1),m=ss(e),l=m*m,u=new y;for(let g=0;g<n;g++)i.queryPoint2D(2*g,u),y.sqrDistance(u,o)<=l&&(a=!0,h[g]=!0);if(!a)return r;const c=r.createInstance();for(let g=0;g<n;g++)h[g]||c.addPoints(r,g,g+1);return c}function ZC(r,t,e,s,i){const n=new Ne;r.queryEnvelope(n);const o=new F;t.queryEnvelope(o),n.merge(o);const a=.1*n.width(),h=.1*n.height();n.inflateCoords(a,h);const m=new ct;m.addEnvelope(n,!1);const l=m.getImpl();if(e===T.enumPolygon){const u=t.getImpl();l.add(u,!0)}else l.addEnvelope(t,!0);return new Li(m,s,-1,i).tryFastImplementation(r)}class ta{getOperatorType(){return 10001}supportsCurves(){return!0}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,s,i=0){return new ea(t,e,s,i)}execute(t,e,s,i){const n=new oi([t,e]),o=new ea(n,s,i,0).next();return o||$("null output"),o}}function QC(){return{geom:null,vertexCount:-1,bUnioned:!1,location:new y}}function KC(r,t){return y.compareZorder(r.location,t.location)?-1:r.location.equals(t.location)?0:1}class JC{constructor(){this.binVertexCount=0,this.geometries=[]}addPair(t){this.binVertexCount+=t.vertexCount,this.geometries.push(t)}sort(){this.geometries.sort((t,e)=>KC(t,e))}geomCount(){return this.geometries.length}geomPairs(){return this.geometries}clear(){this.binVertexCount=0,this.geometries.length=0}getBinVertexCount(){return this.binVertexCount}}class ea extends mi{constructor(t,e,s,i,n=!1){super(),this.m_index=-1,this.m_currentDim=-1,this.m_bDone=!1,this.m_unionBins=[],this.m_readyGeoms=Kn(4),this.m_dimGeomCounts=j(4,0),this.m_addedGeoms=0,this.m_maxDimension=-1,this.m_bHadGeometry=j(4,!1),this.m_complexUnionGeoms=Kn(4),this.m_totalNonEmptyGeomCounters=j(4,0),this.m_progressTracker=s,this.m_bUnionAllDimensions=!!(4&i),this.m_bPreserveAllPathEnds=!!(8&i),this.m_inputGeoms=t,this.m_spatialReference=e,this.m_options=i,this.m_bIs3D=n}next(){if(this.m_bDone&&this.m_currentDim===this.m_maxDimension)return null;for(;!this.step_(););if(this.m_maxDimension===-1)return null;if(this.m_bUnionAllDimensions){if(this.m_currentDim===-1){for(let t=0;t<=this.m_maxDimension;t++)if(this.m_bHadGeometry[t]){this.m_complexUnionGeoms[t]=this.getResultGeometry(t);for(let e=t+1;e<=this.m_maxDimension;e++)this.m_complexUnionGeoms[e]=this.getResultGeometry(e),this.m_bHadGeometry[e]&&!this.m_complexUnionGeoms[e].isEmpty()&&(this.m_bIs3D?b(0):this.m_complexUnionGeoms[t]=new Ia().execute(this.m_complexUnionGeoms[t],this.m_complexUnionGeoms[e],this.m_spatialReference,this.m_progressTracker))}}for(;this.m_currentDim++,(this.m_currentDim>this.m_maxDimension||this.m_currentDim<0)&&$(""),!this.m_bHadGeometry[this.m_currentDim];);if(this.m_index++,this.m_currentDim===0&&this.m_complexUnionGeoms[this.m_currentDim].getGeometryType()===T.enumPoint){const t=new Zt({vd:this.m_complexUnionGeoms[this.m_currentDim].getDescription()});return this.m_complexUnionGeoms[this.m_currentDim].isEmpty()||t.add(this.m_complexUnionGeoms[this.m_currentDim]),t}return this.m_complexUnionGeoms[this.m_currentDim]}return this.m_index=0,this.m_currentDim=this.m_maxDimension,this.getResultGeometry(this.m_maxDimension)}getGeometryID(){return this.m_index}getRank(){return 1}tock(){return this.step_()}getResultGeometry(t){return this.m_readyGeoms[t]}finishDim(t,e,s){let i=e;if(!s)return 16&this.m_options&&(i=eh([i],1,this.m_spatialReference,this.m_progressTracker,this.m_options,this.m_bIs3D)),i;if(1&this.m_options)return i;if(t===1)if(!(8&this.m_options)&&(16&this.m_options||this.m_totalNonEmptyGeomCounters[t]>1)){i=eh([i],1,this.m_spatialReference,this.m_progressTracker,16|this.m_options,this.m_bIs3D);const n=[0],o=i.getImpl().getIsSimple(0,n);b(this.m_bIs3D||yi(o))}else this.m_totalNonEmptyGeomCounters[t]===1&&(this.m_bIs3D?b(0):i=new Us().execute(i,this.m_spatialReference,!1,this.m_progressTracker));else this.m_bIs3D?b(0):i=new Us().execute(i,this.m_spatialReference,!1,this.m_progressTracker);if(t===0&&i.getGeometryType()===T.enumPoint){const n=new Zt({vd:i.getDescription()});i.isEmpty()||n.add(i),i=n}return i}static getLevel(t){const s=sr(t);let i=s>0?(Math.log(s)-Math.log(32))/Math.log(4):0;return i<0&&(i=0),Math.floor(i)}step_(){if(this.m_bDone)return!0;let t;if(this.m_inputGeoms?(t=this.m_inputGeoms.next(),t===null?(this.m_bDone=!0,this.m_inputGeoms=null):(this.checkAndThrow(t),t.isEmpty()||this.m_totalNonEmptyGeomCounters[t.getDimension()]++)):t=null,t!==null){const e=t.getDimension();this.m_bHadGeometry[e]=!0,(e>=this.m_maxDimension||this.m_bUnionAllDimensions)&&(this.addGeom(e,!1,t),e>this.m_maxDimension&&!this.m_bUnionAllDimensions&&this.removeAllBinsWithLowerDimension(e))}if(this.m_addedGeoms>0)for(let e=0;e<=this.m_maxDimension;e++){for(;this.m_dimGeomCounts[e]>1;){const s=this.collectGeometriesToUnion(e);if(s===null)break;{let i;i=1&this.m_options?eh(s,s.length,this.m_spatialReference,this.m_progressTracker,this.m_options,this.m_bIs3D):XP(s,s.length,this.m_spatialReference,this.m_progressTracker,8|this.m_options,this.m_bIs3D),this.addGeom(e,!0,i)}}if(this.m_bDone&&(b(this.m_dimGeomCounts[e]<=1),this.m_dimGeomCounts[e]!==0)){const s=this.m_unionBins[e].entries().next().value,i=s[1].geomPairs()[0].geom,n=s[1].geomPairs()[0].bUnioned;this.m_unionBins[e].clear(),this.m_readyGeoms[e]=this.finishDim(e,i,n)}}return this.m_bDone}addGeom(t,e,s){const i=QC();i.geom=s;const n=sr(s);i.vertexCount=n;const o=F.constructEmpty();s.queryEnvelope(o),i.location=n>0?o.getCenter():new y(0,0);const a=ea.getLevel(s);if(t+1>this.m_unionBins.length)for(;this.m_unionBins.length<Math.max(2,t+1);)this.m_unionBins.push(new Map);let h=null;const m=this.m_unionBins[t].get(a);m&&(h=m),h===null&&(h=new JC,this.m_unionBins[t].set(a,h)),i.bUnioned=e,h.addPair(i),this.m_dimGeomCounts[t]++,this.m_addedGeoms++,this.m_maxDimension=Math.max(this.m_maxDimension,t)}removeAllBinsWithLowerDimension(t){for(let e=0;e<t;e++)this.m_unionBins[e].clear(),this.m_addedGeoms-=this.m_dimGeomCounts[e],this.m_dimGeomCounts[e]=0}collectGeometriesToUnion(t){if(1&this.m_options&&!this.m_bDone)return null;let e=null;const s=[];for(const i of this.m_unionBins[t].keys())s.push(i);Mr(s);for(let i=0;i<s.length;i++){if(s[i]===-1)continue;const n=this.m_unionBins[t].get(s[i]);{const h=n.getBinVertexCount()>5e3&&n.geomCount()>=4;if(this.m_bDone||h){for(let m=0;m<i;m++){if(s[m]===-1)continue;const l=this.m_unionBins[t].get(s[m]);l.sort(),this.m_dimGeomCounts[t]-=l.geomCount(),this.m_addedGeoms-=l.geomCount();for(const u of l.geomPairs())e||(e=new Array),e.push(u.geom);l.clear(),this.m_unionBins[t].delete(s[m]),s[m]=-1}n.sort(),this.m_dimGeomCounts[t]-=n.geomCount(),this.m_addedGeoms-=n.geomCount();for(const m of n.geomPairs())e||(e=new Array),e.push(m.geom);if(n.clear(),this.m_unionBins[t].delete(s[i]),s[i]=-1,!this.m_bDone)break}}}return e}checkAndThrow(t){this.m_bIs3D&&(t.getDimension()>1&&tp(),t.hasAttribute(1)||H("Geometry must have Zs")),ni(t)}}class Jm extends Qm{getOperatorType(){return 3}execute(t,e,s,i=null){return ti(t,e,s,4,i)}}function hm(r,t,e){const s=t.getGCSSplitLines();if(s===null)return r;const i=t.getGCS(),n=i.getPannableExtent().width(),o=F.constructEmpty();r.queryLooseEnvelope(o);const a=z.constructEmpty();o.queryIntervalX(a);const h=s.querySegmentIterator();let m=null;const l=new pt;for(;h.nextPath();)for(;h.hasNextSegment();){const u=h.nextSegment(),c=u.queryInterval(0,0),g=z.constructEmpty();g.setCoordsFromEnvelope(c);let _=0;for(;g.vmax>a.vmin;)g.move(-n),_--;for(;g.vmin<=a.vmax;){if(g.isIntersecting(a)){m===null&&(m=new Pt);const d=new ht({start:u.getStartXY(),end:u.getEndXY()});_!==0&&(l.setShiftCoords(_*n,0),d.applyTransformation(l)),m.addSegment(d,!0)}g.move(n),++_}}if(m!==null){const u=Oe(i,m,!0);return vx(r,m,ss(u),e)}return r}function tl(r,t,e){let s=r.getName();return Nd(s)||(e||t>0?(s=r.toString(et.PE_STR_NAME_CANON|et.PE_STR_AUTH_NONE),s=iE(s)):s=r.toString(et.PE_STR_AUTH_TOP)),s}function tE(r,t,e,s){return b(0),""}function Fc(r,t=-1){if((t>1||t<-1)&&H("verbosity"),t===-1)return r.toString();{const e=t===0?et.PE_STR_AUTH_TOP:et.PE_STR_AUTH_ALL;return r.toString(e)}}function eE(r,t){(t>1||t<-1)&&H("verbosity");let e=et.PE_STR_FMT_WKT2;return t!==-1&&(e|=t===0?et.PE_STR_AUTH_TOP:et.PE_STR_AUTH_ALL),r.toString(e)}function sE(r){return b(0),""}function iE(r){return r.toLocaleUpperCase("en-US")}function nE(r,t,e){const s=r.getPCSHorizon();if(s.getGeometryType()!==T.enumPolygon)if(s.getGeometryType()!==T.enumEnvelope)H("");else{const i=s;for(let n=0;n<e;n++)i.contains(t[n])||t[n].setNAN()}else{const i=r.getDefaultPrecisionSR().getTolerance(0),n=s;for(let o=0;o<e;o++)Ye(n,t[o],i)!==1&&t[o].setNAN()}}function rE(r,t,e,s){for(let i=0;i<t;i++){if(r[i].y<e.ymin||r[i].y>e.ymax){r[i].setNAN();continue}const n=r[i].x;r[i].x=Mi(n,e,s)}}function ih(r,t,e,s){if(r.isEmpty()||e===1)return r;const i=r.getGeometryType();if(i===T.enumPoint){const P=r,C=P.getXY();return lm([C],1,t,e)===0||C.isNAN()?P.setEmpty():P.setXY(C),r}if(i===T.enumMultiPoint){const P=r,C=r.createInstance(),S=P.getPointCount();C.reserve(S);const I=P.getAttributeStreamRef(0),w=P.getDescription().getAttributeCount()>1,D=new st,N=Float64Array.from(I.getArray());if(lm(N,S,t,e)>0)for(let A=0,M=2*S;A<M;A+=2)Number.isNaN(N[A])||(w?(P.getPointByVal(A>>1,D),D.setXYCoords(N[A],N[A+1]),C.add(D)):C.addXY(N[A],N[A+1]));return C}let n=r;const o=t.getOneDegreeGCSUnit(),a=90*o,h=180*o,m=360*o,l=t.getCentralMeridian(),u=.5*o,c=F.constructEmpty();n.queryEnvelope(c);const g=t.getGCSHorizon(),_=t.getGCSHorisonIsInclusive(),d=g.getGeometryType()===T.enumEnvelope,p=F.constructEmpty();g.queryEnvelope(p);const f=t.getGCS();if(e!==2&&e!==4||(p.xmin=l-h,p.xmax=p.xmin+m),e===4){if(!(c.width()>m-o)){const P=F.constructEmpty();P.setCoords({xmin:c.xmin-o,ymin:p.ymin,xmax:c.xmax+o,ymax:p.ymax}),n=new wn().execute(n,P,f,s);let C=Math.floor((l-c.getCenterX())/m);for(c.move(C*m,0);c.xmin>p.xmax;)C-=1,c.move(-m,0);for(;c.xmin<p.xmin;)C+=1,c.move(m,0);if(C!==0){const S=new pt;S.setShiftCoords(C*m,0),n.applyTransformation(S)}return n}e=2}if(e===2&&(p.xmin=l-h,p.xmax=p.xmin+m),c.ymin<-a||c.ymax>a){const P=F.constructEmpty();if(P.setCoords({xmin:c.xmin-o,ymin:-a,xmax:c.xmax+o,ymax:a}),n=new wn().execute(n,P,f,s),n.isEmpty())return n;n.queryEnvelope(c)}if(_&&(p.ymax<c.ymin||p.ymin>c.ymax))return n.createInstance();c.width()>m&&(n=Tr(n,l-h,m,f,!0,0,!0,s),n.queryEnvelope(c));let x=lE(c.xmin,c.xmax,p.xmin,p.xmax,m);if(x!==0&&c.move(x,0),c.xmax>p.xmax||c.xmin<p.xmin){if(c.xmax>p.xmax)for(;c.xmin>=p.xmax;)c.move(-m,0),x-=m;for(;c.xmin<p.xmax-m;)c.move(m,0),x+=m}const E=or(f,g,!1);if(x!==0){const P=new pt;P.setShiftCoords(x,0),n.applyTransformation(P),x=0}if(_){if(d&&p.containsEnvelope(c))return n;const P=new Array(2);for(let C=0;C<2;C++){let S;if(d?S=lt(i)?Dt(n,p,E,u,s):Dt(n,p,E,0,s):(S=new Ki().execute(n,g,f,s),S===g&&(S=S.clone())),p.xmin<=c.xmin&&p.xmax>=c.xmax||p.xmin>=c.xmin&&p.xmax<=c.xmax)return S;if(P[C]=S,C===0){c.move(-m,0);const I=new pt;I.setShiftCoords(-m,0),n.applyTransformation(I)}}return lt(i)?P[0].add(P[1],!1):$("intersect_with_GCS_horizon: unexpected geometry type"),P[0]}{if(p.ymax<c.ymin||p.ymin>c.ymax)return n;let P=0;for(;!n.isEmpty()&&c.xmax>p.xmin;){if(P!==0){const C=new pt;C.setShiftCoords(P,0),n.applyTransformation(C)}if(new Jm().execute(n,g,f,s)||(n=new Ia().execute(n,g,f,s),g===n&&(n=n.clone())),P!==0){const C=new pt;C.setShiftCoords(-P,0),n.applyTransformation(C)}P-=m,c.move(-m,0)}return n}}function oE(r,t,e,s,i,n){const o={stack:[],error:void 0,hasError:!1};try{if(n===2)return K1(r,t,e,s,i);if(Math.abs(e.x-s.x)>=Math.PI||!nh(e.x,s.x,i))return Number.NaN;e.x>s.x&&(s=O(e,e=s));const a=Te(o,new xe,!1),h=Te(o,new xe,!1),m=Te(o,new xe,!1),l=e.clone();Ze.geodeticDistance(r,t,e.x,e.y,s.x,s.y,h,a,null,n);const u=h.val;let c=0,g=1;for(;u*(g-c)>1e-12*r;){const _=.5*(c+g);if(Ze.geodeticCoordinate(r,t,e.x,e.y,u*_,a.val,h,m,n),l.x=h.val,l.y=m.val,l.x===i)return l.y;if(nh(e.x,l.x,i))g=_;else{if(!nh(s.x,l.x,i))return Number.NaN;c=_}}return l.y}catch(a){o.error=a,o.hasError=!0}finally{li(o)}}function aE(r,t){let e;if(Array.isArray(r)){const s=r;e=new Float64Array(2*t);for(let i=0,n=0;i<t;i++,n+=2)e[n]=s[i].x,e[n+1]=s[i].y}else e=r;return e}function mm(r,t,e,s){for(let i=0,n=0;i<s;i++,n+=2)t[e+i].x=r[n],t[e+i].y=r[n+1]}function lm(r,t,e,s){if(t===0||s===1)return t;const i=aE(r,t);if(s===2){const d=e.getPannableExtentInGCS();let p=t;for(let f=0,x=2*t;f<x;f+=2)(i[f+1]>d.ymax||i[f+1]<d.ymin)&&(i[f]=Number.NaN,p--);return p?(So(i,t,d.xmin,d.width(),!0),r!==i&&mm(i,r,0,t),p):0}const n=e.getOneDegreeGCSUnit(),o=90*n,a=180*n,h=360*n;let m=t;for(let d=0,p=2*t;d<p;d+=2)(i[d+1]>o||i[d+1]<-o)&&(i[d]=Number.NaN,m--);if(!m)return 0;const l=F.constructEmpty();l.setFromPoints(i,t);const u=e.getGCSHorizon(),c=e.getGCSHorisonIsInclusive(),g=u.getGeometryType()===T.enumEnvelope,_=F.constructEmpty();if(u.queryEnvelope(_),c&&(_.ymax<l.ymin||_.ymin>l.ymax))return 0;if(c)if(So(i,t,_.getCenterX()-a,h,!0),m=t,g)for(let d=0,p=2*t;d<p;d+=2)_.containsCoords(i[d],i[d+1])||(i[d]=Number.NaN,m--);else{const d=or(e.getGCS(),u,!1),p=new y;for(let f=0,x=2*t;f<x;f+=2)p.setCoords(i[f],i[f+1]),Ye(u,p,d)!==0||(i[f]=Number.NaN,m--)}else{So(i,t,-a,h,!0),m=t;const d=or(e.getGCS(),u,!1),p=new y;for(let f=0,x=2*t;f<x;f+=2){p.setCoords(i[f],i[f+1]),p.isNAN()&&m--;const E=ld(p.x,_.xmin,_.xmax,h);p.x+=E,Ye(u,p,d)!==0&&(i[f]=Number.NaN,m--)}}return m>0&&Array.isArray(r)&&mm(i,r,0,t),m}function Tn(r,t,e,s,i,n){if(t.isPannable()||H("fold_into_360_degree_range"),r.isEmpty())return r;let o,a;if(t.getCoordinateSystemType()===2){const h=t.getPannableExtent();a=h.xmin,o=h.width()}else{const h=t.getOneDegreeGCSUnit();o=360*h,a=e-180*h}return Tr(r,a,o,t,s,i,!0,n)}function hd(r,t,e,s){let i,n;if(e.getCoordinateSystemType()===2){const o=e.getPannableExtent();i=o.xmin,n=o.width()}else{const o=e.getOneDegreeGCSUnit();n=360*o,i=s-180*o}So(r,t,i,n)}function Eo(r,t){const e=t.width();let s=Ci(r-t.vmin,e);return s<0&&(s+=e),t.snapClip(s+t.vmin)}function Mi(r,t,e){return r>t.xmax&&r-t.xmax<e?t.xmax:r<t.xmin&&t.xmin-r<e?t.xmin:r}function sa(r,t,e){if(r[0]<t.vmin||r[0]>t.vmax||e&&r[0]===t.vmax){const s=t.width();return r[0]+=Math.ceil((t.vmin-r[0])/s)*s,r[0]=t.snapClip(r[0]),!0}return!1}function hE(r,t,e,s,i,n,o,a,h){return new Jo(r,null,e,t,s,i,o,a,n).geoNormalizePolygonGeometry(h)}function mE(r,t,e,s,i,n,o,a,h){return new Jo(r,null,e,t,s,i,o,a,n).geoNormalizePolylineGeometry(h)}function md(r,t,e,s,i){const n=new Lt,o=n.addGeometry(r);return Nn(n,o,t,or(t,r,!1),e,s,i),n.getGeometry(o)}function Nn(r,t,e,s,i,n,o){const a={stack:[],error:void 0,hasError:!1};try{b(xs()),e.isPannable()||Yt("insert_geodetic_points");const h=e.getPannableExtent(),m=e.getGCS(),l=sn();m.querySpheroidData(l);const u=m.getUnit().getUnitToBaseFactor(),c=l.majorSemiAxis,g=l.e2;let _=0;const d=new z;h.queryIntervalX(d);let p=null;const f=j(4,Number.NaN);e.getCoordinateSystemType()===2?(p=e.getPECoordSys(),n?(f[0]=Eo(o,d),f[1]=h.getCenterY(),pe.projToGeog(p,1,f),_=f[0]*u):(f[0]=h.getCenterX(),f[1]=o,pe.projToGeog(p,1,f),_=f[1]*u)):_=o*u,n||_===0||i===2||Yt("insert_geodetic_points: 1");const x=Te(a,new xe,!1),E=new y,P=new y,C=new y,S=new y,I=new y,w=new y;for(let D=r.getFirstPath(t);D!==v;D=r.getNextPath(D)){const N=r.getFirstVertex(D);r.queryXY(N,C);let A=!1;const M=r.getNextVertex(N);for(let G=M;G!==v;G=r.getNextVertex(G)){if(G===M){if(A)break;A=!0}if(r.queryXY(G,S),n&&(s<o-C.x&&S.x-o>s||s<o-S.x&&C.x-o>s)||!n&&(o!==0||s<-C.y&&S.y>s||s<-S.y&&C.y>s))do{if(Math.abs(C.x-S.x)>=.5*d.width())break;e.getCoordinateSystemType()===2?(f[0]=Eo(C.x,d),f[1]=C.y,f[2]=Eo(S.x,d),f[3]=S.y,Da(p,2,f,0),I.x=f[0]*u,I.y=f[1]*u,w.y=f[3]*u):(I.x=C.x*u,I.y=C.y*u,w.y=S.y*u),w.x=(S.x-C.x)*Math.PI*2/d.width()+I.x;let q=0;const V=R(y,2);if(n){if(P.x=_,P.y=oE(c,g,I,w,_,i),Number.isNaN(P.y))break;V[0]=P,q=1}else if(i===2){const Y=[0,0];if(q=h_(c,g,I,w,_,Y),!q)break;V[0].x=Y[0],V[0].y=_,q===2&&(V[1].x=Y[1],V[1].y=_)}else{if(P.x=XE(c,g,I,w,i),Number.isNaN(P.x))break;P.y=0,V[0]=P,q=1}let k=-1;for(let Y=0;Y<q;Y++){Ze.geodeticDistance(c,g,I.x,I.y,w.x,w.y,x,null,null,i);const U=x.val;Ze.geodeticDistance(c,g,I.x,I.y,V[Y].x,V[Y].y,x,null,null,i);const X=x.val;e.getCoordinateSystemType()===2?(f[0]=V[Y].x/u,f[1]=V[Y].y/u,pe.geogToProj(p,1,f),n?(E.y=f[1],E.x=o):(E.x=Vc(f[0],C.x,S.x,d),E.y=o)):n?(E.x=o,E.y=V[Y].y/u):(E.x=Vc(V[Y].x/u,C.x,S.x,d),E.y=o);const B=U>0?Nt(X/U,0,1):.5;if(B===0||B===1||k>B)continue;const W=r.getPrevVertex(G);r.splitSegment(W,[B],1);const Z=r.getNextVertex(W);r.setXYCoords(Z,E.x,E.y),k=B}}while(!1);C.setCoordsPoint2D(S)}}}catch(h){a.error=h,a.hasError=!0}finally{li(a)}}function Xn(r,t){b(t.isPannable());const e=t.getPannableExtent();if(r.getGeometryType()===T.enumPoint){const a=r.getY();return e.ymin<=a&&a<=e.ymax?r:r.createInstance()}const s=F.constructEmpty();r.queryEnvelope(s);const i=F.constructEmpty();i.setCoords({env2D:e}),i.xmin=s.xmin,i.xmax=s.xmax,i.inflateCoords(.01*i.height(),0);const n=Di(t,s,!1);let o;return o=i.containsEnvelope(s)?r:Dt(r,i,n,0,null),o}function ld(r,t,e,s){return Hi((.5*(e+t)-r)/s)*s}function lE(r,t,e,s,i){return r>=e&&t<=s?0:ld(.5*(t+r),e,s,i)}function Tr(r,t,e,s,i,n,o,a){const h=r.getGeometryType(),m=z.constructEmpty();m.setCoords(t,t+e);const l=[0];if(h===T.enumPoint){const I=r;if(l[0]=I.getX(),sa(l,m,o)){const w=i?r:r.clone();return w.setX(l[0]),w}return r}const u=F.constructEmpty();if(r.queryEnvelope(u),u.isEmpty())return r;if(h===T.enumMultiPoint){const I=i?r:r.clone(),w=I.getImpl(),D=w.getAttributeStreamRef(0),N=2*w.getPointCount();let A=!1;for(let M=0;M<N;M+=2)l[0]=D.read(M),sa(l,m,o)&&(D.write(M,l[0]),A=!0);return A&&w.notifyModifiedFlags(2001),I}const c=z.constructEmpty();if(u.queryIntervalX(c),m.contains(c))return m.vmax,c.vmax,r;const g=F.constructEmpty();if(g.setCoords({env2D:u}),c.width()===0){let I=c.vmin;I+=Math.ceil((m.vmin-I)/e)*e,I=m.snapClip(I);const w=i?r:r.clone();return w.setAttributeBasic(0,0,I),w}if(h===T.enumEnvelope){const I=i?r:r.clone();return u.intersect(g),I.setEnvelope(u),I}const _=.1*Math.max(u.height(),u.width())*1;g.inflateCoords(0,_);let d=r;const p=s.getTolerance(0),f=new pt;for(;;){const I=Math.floor((c.vmin-t)/e),w=Math.ceil((c.vmax-t)/e);if(!(w-I>3))break;{const D=Math.floor(.5*(w+I));g.xmin=u.xmin-_,g.xmax=t+e*D;const N=Dt(d,g,p,n,a);g.xmin=g.xmax,g.xmax=u.xmax+_;const A=Dt(d,g,p,n,a);f.setShiftCoords((D-w)*e,0),A.applyTransformation(f),h===T.enumPolygon?d=new ta().execute(N,A,s,a):(d=N,d.add(A,!1)),d.queryEnvelope(u),u.queryIntervalX(c)}}g.xmin=t,g.xmax=t+e;const x=F.constructEmpty();x.setCoords({env2D:g}),x.inflateCoords(p,0);const E=Math.floor((u.xmin-g.xmin)/e)*e;let P;E?(g.move(E,0),f.setShiftCoords(-E,0)):f.setIdentity(),P=h===T.enumPolyline?new Pt({vd:d.getDescription()}):new ct({vd:d.getDescription()});const C=F.constructEmpty(),S=F.constructEmpty();for(;u.xmax>g.xmin;){const I=Dt(d,g,p,0,a);I.queryEnvelope(S);let w=!1;w=h===T.enumPolyline?!I.isEmpty()&&(S.width()>p||S.height()>p):!I.isEmpty()&&(h!==T.enumPolygon||S.width()>p),w&&(I.applyTransformation(f),I.queryEnvelope(S),P.queryEnvelope(C),C.inflateCoords(p,p),C.isIntersecting(S)&&h===T.enumPolygon?P=new ta().execute(P,I,s,a):P.add(I,!1)),g.move(e,0),f.shiftCoords(-e,0)}return P}function So(r,t,e,s,i=!0){const n=new z;n.setCoords(e,e+s);const o=[0];if(Array.isArray(r)){const a=r;for(let h=0;h<t;h++)n.containsRightExclusive(a[h].x)||(o[0]=a[h].x,sa(o,n,i),a[h].x=o[0])}else{const a=r;for(let h=0;h<t;h++){const m=h<<1;n.containsRightExclusive(a[m])||(o[0]=a[m],sa(o,n,i),a[m]=o[0])}}}function ia(r,t,e,s=!0){if(r.isEmpty())return;const i=r.getGeometryType();if(!s||i!==T.enumPolygon)if(We(i)){let n=!1;if(lt(i)&&r.hasNonLinearSegments()){const o=r.getImpl(),a=o.getAttributeStreamRef(0),h=o.getSegmentFlagsStreamRef();b(h!==null);for(let m=0,l=o.getPathCount();m<l;m++){let u=!0;const c=o.isClosedPath(m),g=o.getPathEnd(m);c&&o.getPathSize(m)>0&&(u=(31&h.read(g-1))===1);for(let _=o.getPathStart(m);_<g;_++)if((31&h.read(_))===1){if(u){const d=a.read(2*_),p=Mi(d,t,e);p!==d&&(n=!0,a.write(2*_,p))}u=!0}else u=!1}}else{const o=r.getImpl(),a=o.getAttributeStreamRef(0);for(let h=0,m=o.getPointCount();h<m;h++){const l=a.read(2*h),u=Mi(l,t,e);u!==l&&(n=!0,a.write(2*h,u))}}n&&r.getImpl().notifyModifiedFlags(2001)}else if(i===T.enumEnvelope){const n=r,o=F.constructEmpty();n.queryEnvelope(o),o.xmin=Mi(o.xmin,t,e),o.xmax=Mi(o.xmax,t,e),n.setEnvelope(o)}else if(i===T.enumPoint){const n=r;n.setX(Mi(n.getX(),t,e))}else $("")}function uE(r,t,e){const s=new y;return s.x=Mi(r.x,t,e),s.y=r.y,s}function cE(r,t){if(t.isEmpty())return 0;const e=r.getPECoordSys();if(e.getProjection().getCode()===et.PE_PRJ_AZIMUTHAL_EQUIDISTANT){const s=sn();r.querySpheroidData(s);const i=e.getParameters();if(i[et.PE_PARM_LAM0]===null||i[et.PE_PARM_PHI0]===null)return 0;const n=[i[et.PE_PARM_LAM0].getValue(),i[et.PE_PARM_PHI0].getValue()];pe.geogToProj(e,1,n);const o=new y(n[0],n[1]),a=F.constructEmpty();t.queryEnvelope(a);const h=R(y,4);a.queryCorners(h);let m=0;const l=r.getOneMeter();let u=Math.max(s.majorSemiAxis,s.minorSemiAxis)*Math.PI,c=Math.min(s.majorSemiAxis,s.minorSemiAxis)*Math.PI;c-=u/180,u*=l,c*=l;for(let g=0;g<4;g++){const _=y.distance(h[g],o);if(_>u)m++;else if(_>c)return-1}if(m===0)return 1;if(m===4){const g=F.constructEmpty();return g.setCoords({center:o,width:u,height:u}),a.isIntersectingNe(g)?-1:0}return-1}return-1}function vo(r,t,e,s){const i=r.getGeometryType();b(i===T.enumPolygon||i===T.enumPolyline||i===T.enumMultiPoint);const n=t.getCoordinateSystemType();if(n===2){let o=r;if(e===0){const a=cE(t,r);if(a===0)return r.createInstance();if(a===1)return r;const h=t.getPCSHorizon(),m=h.getGeometryType(),l=t.getDefaultPrecisionSR();if(m===T.enumEnvelope){const u=F.constructEmpty();h.queryEnvelope(u);const c=Di(l,u,!1);o=Dt(r,u,c,5e4*t.getOneMeterPCSUnit(),s)}else new ad().execute(h,r,l,s)||(o=new Ki().execute(o,h,l,s),o===h&&(o=o.clone()))}else if(t.isPannable()){const a=F.constructEmpty();o.queryEnvelope(a);const h=t.getPannableExtent();h.containsEnvelope(a)||(ia(o,h,t.getTolerance(0)),e!==2&&e!==4||(o=Xn(o,t)),e!==4?o=Tn(o,t,0,!0,1e5*t.getOneMeterPCSUnit(),s):i===T.enumPolygon&&a.width()>2*h.width()&&(o=Tr(o,-2*h.width(),2*h.width(),t,!0,0,!0,s)))}return o}if(b(n===1),i===T.enumMultiPoint)return ia(r,t.getPannableExtent(),t.getTolerance(0)),r;{const o=F.constructEmpty();r.queryEnvelope(o);let a=r;const h=t.getPannableExtent();if(o.ymin<h.ymin||o.ymax>h.ymax){const m=Math.max(1,o.calculateToleranceFromEnvelope()),l=new F(o.xmin-m,h.ymin,o.xmax+m,h.ymax);if(a=new wn().execute(a,l,t,s),a.isEmpty())return a}return i===T.enumPolygon&&o.width()>2*h.width()&&(a=Tr(a,-2*h.width(),2*h.width(),t,!0,0,!0,s)),a}}function gE(r,t,e,s,i,n){const o=s.getCoordinateSystemType();if(o===2){if(i===0)e!==r&&Ao(e,r,t),nE(s,e,t);else if(e!==r&&Ao(e,r,t),s.isPannable()){const a=s.getTolerance(0);rE(e,t,s.getPannableExtent(),a),hd(e,t,s,0)}}else{b(o===1);const a=s.getTolerance(0),h=s.getPannableExtent();for(let m=0;m<t;m++)e[m].assign(uE(r[m],h,a))}}function _E(r,t){const e=t.getPointCount();if(!e)return;const s=t.getImpl(),i=s.getAttributeStreamRef(0),n=r;pe.geogToProj(n,e,i.getArray()),s.notifyModifiedFlags(2001)}function wa(r,t,e,s){if(!e)return;const i=r.getPECoordSys();if(e===1){const u=[t[0].x,t[0].y];if(pe.geogToProj(i,1,u),s){const{first:c,second:g}=r.m_peCoordSysVal.getGeogToProjFactors();u[0]=c*(t[0].x-r.getCentralMeridian())+g}return void t[0].setCoords(u[0],u[1])}const n=r.isPannable(),o=n?r.getPannableExtent().width():0,a=179*o/360;let h=0;n&&(h=r.getCentralMeridian());const m=256,l=new Float64Array(2*m);for(let u=0;u<e;){for(let g=u;g<e&&t[g].isNAN();++g)u++;let c=Math.min(m,e-u);if(c>0){for(let g=1,_=u+1;g<c;++g,++_)if(t[_].isNAN()){c=g;break}for(let g=0;g<c;++g){const _=g<<1;l[_]=t[u+g].x,l[_+1]=t[u+g].y}if(pe.geogToProj(i,c,l),s){const{first:g,second:_}=r.m_peCoordSysVal.getGeogToProjFactors();for(let d=0;d<c;++d)l[d<<1]=g*(t[u+d].x-h)+_}if(n)for(let g=0,_=u;g<c;g++,_++){const d=g<<1,p=l[d],f=kt(p),x=t[_].x-h;f*kt(x)<0&&Math.abs(p)>a&&(l[d]-=f*o)}mm(l,t,u,c),u+=c}}}function dE(r,t,e,s){const i=r.getSRToGCSTransform();return new Rs().transform(i,t,e,s,!1)}function pE(r,t,e,s){const i=new Zt({vd:t.getDescription()});let n;i.addPoints(t,0,-1),n=new Rs().execute(i,r,s);const o=t.getPointCount();if(e.setEmpty(),r.getInputSR().isPannable()){if(o!==n.getPointCount())return!1;const a=new F;t.queryEnvelope(a);const h=new F;n.queryEnvelope(h);const m=a.width(),l=h.width();if(m!==0&&l!==0){const u=l/m,c=r.getOutputSR().getPannableExtent().width()/r.getInputSR().getPannableExtent().width();if(Math.abs(u/c-1)>1e-10)return!1}else if(m!==0||l!==0)return!1;e.add(t,!1);for(let u=0;u<o;u++){const c=n.getXY(u);e.setXY(u,c)}return!0}return!1}function ud(r,t,e){b(!e||r.isPannable());const s=t.getPointCount();if(!s)return;const i=t.getImpl(),n=i.getAttributeStreamRef(0),o=r.getPECoordSys();let a=0;const h=n.readRange(0,2*s);let m=()=>{pe.geogToProj(o,s,h)};const l=r.isPannable()&&!e,u=l?r.getPannableExtent().width():0,c=179*u/360;if(r.isPannable()&&(a=r.getCentralMeridian(),e)){const g=r.m_peCoordSysVal.getGeogToProjFactors(),_=g.first,d=g.second;m=()=>{pe.geogToProj(o,s,h);for(let p=0;p<s;p++){const f=p<<1,x=n.read(f),E=_*(x-a)+d;h[f]=E}}}if(m(),l)for(let g=0;g<s;g++){const _=g<<1,d=h[_],p=kt(d),f=n.read(_)-a;p*kt(f)<0&&Math.abs(d)>c&&(h[_]+=-p*u)}n.writeRangeFromArray(0,2*s,h,!0,1),i.notifyModifiedFlags(2001)}function fE(r,t,e){switch(t.getGeometryType()){case T.enumLine:return void qE(r,t,e);case T.enumBezier:return void GE(r,t,e);case T.enumEllipticArc:return void FE(r,t,e);case T.enumBezier2:return void VE();case T.enumRationalBezier2:return void YE();default:$("")}}function Mc(r,t,e){if(!t.hasNonLinearSegments())return void ud(r,t,e);if(b(!e||r.isPannable()),t.isEmpty())return;const s=0,i=r.getPECoordSys(),n=r.isPannable(),o=n?r.getPannableExtent().width():0,a=179*o/360;let h=0;n&&(h=r.getCentralMeridian());const m=t.createInstance();m.reserveParts(t.getPointCount(),t.getPathCount());const l=t.getImpl(),u=new it;for(let c=0,g=t.getPathCount();c<g;++c)if(l.hasNonLinearSegmentsPath(c)){let _=!0,d=-1;const p=l.getPathStart(c),f=p+l.getSegmentCountPath(c);l.isClosedPath(c)&&(d=f-1);const x=new y;for(let E=p;E<f;++E){if(l.getSegmentBuffer(E,u,!1),fE(r,u.get(),e),!_&&(u.get().getStartXY().equals(x)||u.get().moveTo(x)),E!==d)m.addSegment(u.get(),_);else{if(_){const P=new st;u.get().queryStart(P),m.startPathPoint(P)}m.closeLastPathWithSegment(u.get())}x.assign(u.get().getEndXY()),_=!1}}else{let d,p=l.getPathSize(c),f=Math.min(p,1024);m.insertPath(-1,t,c,!0);const x=l.getAttributeStreamRef(0),E=m.getAttributeStreamRef(0);for(let P=l.getPathStart(c),C=l.getPathEnd(c);P<C;){if(d=x.readRange(P,f),pe.geogToProj(i,f,d),n)for(let S=0;S<f;S++){const I=S<<1,w=d[I],D=kt(w),N=x.read(2*(s+S))-h;D*kt(N)<0&&Math.abs(w)>a&&(d[I]+=-D*o)}E.writeRangeFromArray(P,f,d,!0,1),P+=f,p-=f,f=Math.min(p,1024)}}t.assignMove(m)}function cd(r,t,e){let i=e.getPointCount();if(!i)return;const n=e.getImpl(),o=n.getAttributeStreamRef(0);let a=Math.min(i,1e3),h=0;const m=r.getPECoordSys();Number.isNaN(t)&&(t=0);const l=r.isPannable(),u=r.getOneDegreeGCSUnit(),c=360*u,g=179*u;let _;for(;i;){if(_=o.readRange(2*h,2*a),Da(m,a,_,t),l)for(let d=0;d<a;d++){const p=d<<1,f=_[p]-t,x=kt(f),E=o.read(2*(h+d));x*kt(E)<0&&Math.abs(f)>g&&(_[p]+=-x*c)}o.writeRangeFromArray(2*h,2*a,_,!0,1),h+=a,i-=a,a=Math.min(i,1e3)}n.notifyModifiedFlags(2001)}function xE(r,t,e){switch(e.getGeometryType()){case T.enumLine:return void yE(r,t,e);case T.enumBezier:return void EE(r,t,e);case T.enumEllipticArc:return void PE(r,t,e);case T.enumBezier2:return void SE();case T.enumRationalBezier2:return void vE();default:$("")}}function yE(r,t,e){const s=[e.getStartXY(),e.getEndXY()];Ta(r,t,s,2),e.setStartXY(s[0]),e.setEndXY(s[1]),e.normalizeAfterEndpointChange()}function PE(r,t,e){if(e.projectionBehavior()===0)CE(r,t,e);else{const s=e.isClosed()&&e.isMajor(),i=[e.getStartXY(),s?e.getCenter():e.getEndXY()],n=[i[0].clone(),i[1].clone()];sl(r,t,n,2);const o=new pt;o.initializeFromTwoPointsArray(i,n),e.applyTransformation(o);const a=s?0:1;e.setCoordsForIntersector(n[0],n[a],!1)}}function CE(r,t,e){fd(!1,r,t,e,!1)}function EE(r,t,e){const s=R(y,4);e.queryControlPoints(s),sl(r,t,s,4),e.setControlPoints(s)}function SE(r,t,e){b(0)}function vE(r,t,e){b(0)}function Da(r,t,e,s){const i=pe.projToGeogCenter(r,t,e,s);for(let n=0;n<t;++n){const o=n<<1;b(Number.isFinite(e[o]+e[o+1]))}return i}function ho(r,t,e){if(!e.hasNonLinearSegments())return void cd(r,t,e);if(e.isEmpty())return;const s=r.getPECoordSys();Number.isNaN(t)&&(t=0);const i=r.isPannable(),n=r.getOneDegreeGCSUnit(),o=360*n,a=179*n,h=e.createInstance();h.reserveParts(e.getPointCount(),e.getPathCount());const m=e.getImpl(),l=new it;for(let u=0,c=e.getPathCount();u<c;++u)if(m.hasNonLinearSegmentsPath(u)){let g=!0,_=-1;const d=m.getPathStart(u),p=d+m.getSegmentCountPath(u);m.isClosedPath(u)&&(_=p-1);const f=new y;for(let x=d;x<p;++x){if(m.getSegmentBuffer(x,l,!1),xE(r,t,l.get()),!g&&(l.get().getStartXY().equals(f)||l.get().moveTo(f)),x!==_)h.addSegment(l.get(),g);else{if(g){const E=new st;l.get().queryStart(E),h.startPathPoint(E)}h.closeLastPathWithSegment(l.get())}f.assign(l.get().getEndXY()),g=!1}}else{let _,d=m.getPathSize(u),p=Math.min(d,1e3);h.insertPath(-1,e,u,!0);const f=m.getAttributeStreamRef(0),x=h.getAttributeStreamRef(0);for(let E=m.getPathStart(u),P=m.getPathEnd(u);E<P;){if(_=f.readRange(2*E,2*p),Da(s,p,_,t),i)for(let C=0;C<p;C++){const S=C<<1,I=_[S]-t,w=kt(I),D=f.read(2*E);w*kt(D)<0&&Math.abs(I)>a&&(_[S]+=-w*o)}x.writeRangeFromArray(2*E,2*p,_,!0,1),E+=p,d-=p,p=Math.min(d,1e3)}}e.assignMove(h)}function Ta(r,t,e,s){const i=r.getPECoordSys();Number.isNaN(t)&&(t=0);const n=r.isPannable(),o=r.getOneDegreeGCSUnit(),a=360*o,h=179*o,m=256,l=new Float64Array(2*m);for(let u=0;u<s;){for(let g=u;g<s&&e[g].isNAN();++g)u++;let c=Math.min(m,s-u);if(c>0){for(let g=1,_=u+1;g<c;++g,++_)if(e[_].isNAN()){c=g;break}for(let g=0;g<c;g++){const _=g<<1;l[_]=e[u+g].x,l[_+1]=e[u+g].y}if(Da(i,c,l,t),n)for(let g=0,_=u;g<c;++g,++_){const d=g<<1,p=e[_].x,f=l[d]-t,x=kt(f);x*kt(p)<0&&Math.abs(f)>h&&(l[d]-=x*a)}for(let g=0;g<c;g++){const _=g<<1;e[u+g].x=l[_],e[u+g].y=l[_+1]}u+=c}}}function gd(r,t,e,s){b(0)}function _d(r,t,e){let s=t.getPointCount();if(!s)return!1;const i=t.getImpl(),n=i.getAttributeStreamRef(0);let o=null;const a=r.getInputSR(),h=r.getOutputSR();a.getVCS(),h.getVCS();const m=a.getOneDegreeGCSUnit(),l=h.getOneDegreeGCSUnit(),u=r.isVertical();u&&t.hasAttribute(1)&&(o=i.getAttributeStreamRef(1));const c=r.getDatumTransformation(),g=!!c&&c.getType()===1;if(g||o===null||(gd(o.getArray()),o=null),!c||c.count()===0){const N=a.getGcsUnitFactor()/h.getGcsUnitFactor(),A=(a.getPrimeMeridian()-h.getPrimeMeridian())*l,M=-90*m,G=90*m;let q=0;const V=n.getArray(),k=[0];for(let Y=1,U=2*s;Y<U;)k[0]=V[Y],q|=dh(k,M,G)?1:0,V[Y]=k[0],Y+=2;if(A!==0||N!==1){q=1;const Y=n.getArray();for(let U=0,X=2*s;U<X;){let B=Y[U];B*=N,B+=A,Y[U]=B,Y[U+1]*=N,U+=2}}return q!==0&&i.notifyModifiedFlags(2001),!!q}const _=1e3;let d=Math.min(s,_);const p=j(d,Number.NaN),f=j(d,Number.NaN);let x=null;o!==null&&(x=new Float64Array(d));let E=0,P=Number.NaN,C=Number.NaN;const S=360*l,I=l/m;e&&(C=90*l,P=89.9*m,f.fill(0));let w=!0,D=0;for(;s;){let N=!1;const A=n.readRange(2*E,2*d);for(let G=0;G<d;G++)p[G]=A[G<<1];if(e)for(let G=0;G<d;G++){const q=1+(G<<1),V=Math.abs(A[q])-P;if(V>0){const k=A[q];A[q]=ri(P,k),f[G]=ri(V,k),N=!0}}const M=A[0];if(g){const G=c;x&&o.queryRange(E,d,x,!0,1),G.transform(!1,A,x,d),x&&o.writeRangeFromArray(E,d,x,!0,1)}else c.transform(!1,A,d);w&&(D=A[0]-I*M,w=!1);for(let G=0;G<d;G++){const q=G<<1,V=A[q]-p[G]*I-D;Math.abs(V)>200&&(A[q]+=V>0?-S:S)}if(N){for(let G=0;G<d;G++)if(f[G]){const q=1+(G<<1);A[q]+=I*f[G],A[q]>C?A[q]=C:A[q]<-C&&(A[q]=-C)}f.fill(0)}n.writeRangeFromArray(2*E,2*d,A,!0,1),u&&o&&o.writeRangeFromArray(E,d,x,!0,1),E+=d,s-=d,d=Math.min(s,_)}return i.notifyModifiedFlags(2001),!0}function bE(r,t,e){switch(t.getGeometryType()){case T.enumLine:return IE(r,t,e);case T.enumBezier:return TE(r,t,e);case T.enumEllipticArc:return wE(r,t,e);case T.enumBezier2:return NE();case T.enumRationalBezier2:return AE();default:$("")}}function mo(r,t,e){if(!t.hasNonLinearSegments())return _d(r,t,e);if(t.isEmpty())return!1;const s=t.createInstance();s.reserveParts(t.getPointCount(),t.getPathCount());const i=t.getImpl(),n=new it;for(let o=0,a=t.getPathCount();o<a;++o){let h=!0,m=-1;const l=i.getPathStart(o),u=l+i.getSegmentCountPath(o);i.isClosedPath(o)&&(m=u-1);const c=new y;for(let g=l;g<u;++g){if(i.getSegmentBuffer(g,n,!1),bE(r,n.get(),e),!h&&(n.get().getStartXY().equals(c)||n.get().moveTo(c)),g!==m)s.addSegment(n.get(),h);else{if(h){const _=new st;n.get().queryStart(_),s.startPathPoint(_)}s.closeLastPathWithSegment(n.get())}c.assign(n.get().getEndXY()),h=!1}}return t.assignMove(s),!0}function Gc(r,t,e,s,i,n){if(r.isIdentityGeogToGeog()){const M=90*r.getInputSR().getOneDegreeGCSUnit();let G=0;const q=[0];for(let V=0;V<s;V++)q[0]=t[V].y,G|=dh(q,-M,M)?1:0,t[V].y=q[0];return G}const o=r.getInputSR(),a=r.getOutputSR(),h=o.getVCS(),m=a.getVCS(),l=o.getOneDegreeGCSUnit(),u=90*l,c=a.getOneDegreeGCSUnit(),g=r.isVertical(),_=r.getDatumTransformation(),d=!!_&&_.getType()===1;if(g||(e=null),!_||_.count()===0){let M=0;const G=[0];for(let q=0;q<s;q++)G[0]=t[q].y,M|=dh(G,-u,u)?1:0,t[q].y=G[0];return M|=rd(o.getGCS(),h,a.getGCS(),m,t,e,s)?1:0,M}d||e===null||gd();const p=1024;let f=Math.min(s,p);const x=j(f,Number.NaN),E=j(f,Number.NaN);let P=0,C=Number.NaN,S=Number.NaN;const I=360*c,w=c/l;i&&(S=90*c,C=89.9*l);let D=!0,N=0,A=s;for(;A;){let M=!1;for(let q=0;q<f;q++)x[q]=t[q+P].x;if(i)for(let q=0;q<f;q++){const V=Math.abs(t[q+P].y)-C;if(V>0){const k=t[q+P].y;t[q+P].y=ri(C,k),E[q]=ri(V,k),M=!0}}const G=t[0].x;d?_.transform(!1,t,e,f):_.transform(!1,t,f),D&&(N=t[0].x-w*G,D=!1);for(let q=0;q<f;q++){const V=t[P+q].x-x[q]*w-N;Math.abs(V)>200&&(V>0?t[P+q].x-=I:t[P+q].x+=I)}if(M){for(let q=0;q<f;q++)E[q]&&(t[P+q].y+=w*E[q],t[P+q].y>S?t[P+q].y=S:t[P+q].y<-S&&(t[P+q].y=-S));E.fill(0,0,f)}P+=f,A-=f,f=Math.min(A,p)}return 1}function dd(r,t,e,s,i){return b(0),0}function pd(r,t,e,s,i){b(s===null),b(t<2147483647);const n=Array.isArray(e);let o;o=n?op(e):e;const a=fm.geogToGeog(r,t,o,null,i);return n&&ap(o,e),a}function Ji(r,t,e,s,i,n){let o=0,a=!0,h=0;for(let m=0;m<s;++m)t[m].isNAN()?a||(o|=Gc(r,t.slice(h,m-h),e?e.slice(h,m-h):null,m-h,i),h=m,a=!0):a&&(h=m,a=!1);return a||(o|=Gc(r,h===0?t:t.slice(h),e?h===0?e:e.slice(h):null,s-h,i)),o!==0}function IE(r,t,e){const s=[t.getStartXY(),t.getEndXY()],i=[0,0];let n=null;t.hasAttribute(1)&&(n=i,n[0]=t.getAttributeAsDbl(0,1,0),n[1]=t.getAttributeAsDbl(1,1,0));const o=Ji(r,s,n,2,e);return t.setStartXY(s[0]),t.setEndXY(s[1]),n&&(t.setStartAttribute(1,0,n[0]),t.setEndAttribute(1,0,n[1])),t.normalizeAfterEndpointChange(),o}function wE(r,t,e){if(t.projectionBehavior()===0)return DE(r,t,e);const s=t.getStartXY().equals(t.getEndXY()),i=R(y,3),n=R(y,3),o=[0,0,0];let a=null;i[0].assign(t.getStartXY()),i[1].assign(s?t.getCenter():t.getEndXY());let h=!1;t.hasAttribute(1)&&(a=o,a[0]=t.getAttributeAsDbl(0,1,0),a[1]=t.getAttributeAsDbl(1,1,0),a[2]=Ct(a[0],a[1],.5),s&&(a[1]=a[2])),n[0].setCoordsPoint2D(i[0]),n[1].setCoordsPoint2D(i[1]);const m=new pt;if(s||t.isDegenerateToLine())h=Ji(r,n,a,2,e),m.initializeFromTwoPoints(i[0],i[1],n[0],n[1]);else{const l=new y;t.queryCoord2D(.5,l),i[2].setCoordsPoint2D(l),n[2].setCoordsPoint2D(l),h=Ji(r,n,a,3,e),m.setFromTwoTriangles(i,n)}return m.isIdentity()||(t.applyTransformation(m),t.setStartXY(n[0]),t.setEndXY(s?n[0]:n[1]),t.normalizeAfterEndpointChange()),a&&(t.setStartAttribute(1,0,a[0]),t.setEndAttribute(1,0,s?a[0]:a[1])),h}function DE(r,t,e){const s=[t.getStartXY(),t.getEndXY(),t.getInteriorPoint(),t.getCenter()];let i=4;t.isDegenerateToLine()&&(i=2);const n=[0,0,0,0];let o=null;if(t.hasAttribute(1)){o=n,o[0]=t.getAttributeAsDbl(0,1,0),o[1]=t.getAttributeAsDbl(1,1,0);const m=Ct(o[0],o[1],.5);o[2]=m,o[3]=m}const a=t.getStartXY().equals(t.getEndXY())&&!t.isDegenerateToLine(),h=Ji(r,s,o,i,e);return a?t.constructCircleCenterAndPoint(s[3],s[0],!t.isClockwise()):t.isDegenerateToLine()?t.constructLineCircularArc(s[0],s[1]):t.constructCircularArcThreePoint(s[0],s[1],s[2]),o&&(t.setStartAttribute(1,0,o[0]),t.setEndAttribute(1,0,o[1])),h}function TE(r,t,e){const s=R(y,4);t.queryControlPoints(s);const i=[0,0,0,0];let n=null;t.hasAttribute(1)&&(n=i,n[0]=t.getAttributeAsDbl(0,1,0),n[3]=t.getAttributeAsDbl(1,1,0),n[1]=Ct(n[0],n[3],.5),n[2]=n[1]);const o=Ji(r,s,n||null,s.length,e);return t.setControlPoints(s),n&&(t.setStartAttribute(1,0,n[0]),t.setEndAttribute(1,0,n[3])),t.normalizeAfterEndpointChange(),o}function NE(r,t,e){return b(0),!1}function AE(r,t,e){return b(0),!1}function qE(r,t,e){const s=[t.getStartXY(),t.getEndXY()];wa(r,s,2,e),t.setStartXY(s[0]),t.setEndXY(s[1]),t.normalizeAfterEndpointChange()}function el(r,t,e,s){wa(r,t,e,s)}function FE(r,t,e){if(t.projectionBehavior()===0)ME(r,t,e);else{const s=t.isClosed()&&t.isMajor(),i=[t.getStartXY(),s?t.getCenter():t.getEndXY()],n=[i[0].clone(),i[1].clone()];el(r,n,2,e);const o=new pt;o.initializeFromTwoPointsArray(i,n),t.applyTransformation(o);const a=s?0:1;t.setCoordsForIntersector(n[0],n[a],!1)}}function sl(r,t,e,s){Ta(r,t,e,s);const i=new F;i.setFromPoints(e,s);const n=r.getOneDegreeGCSUnit(),o=360*n,a=180*n;if(i.width()>a){for(let h=0;h<s;h++)for(;e[h].x<t;)e[h].x+=o;if(i.setFromPoints(e,s),i.xmax>a+t)for(let h=0;h<s;h++)e[h].x-=o}}function fd(r,t,e,s,i){const n=R(y,3);let o=0,a=!1,h=!1;const m=s.isDegenerateToLine();m?(n[0].assign(s.getStartXY()),n[1].assign(s.getEndXY()),n[2].setCoords(0,0),o=2):s.isClosed()&&s.isMajor()?(a=!0,h=!s.isClockwise(),n[0].assign(s.getStartXY()),n[1].assign(s.getCenter()),n[2].setCoords(0,0),o=2):(n[0].assign(s.getStartXY()),n[1].assign(s.getEndXY()),n[2].assign(s.getInteriorPoint()),o=3),r?el(t,n,o,i):sl(t,e,n,o),m?s.constructLineCircularArc(n[0],n[1]):a?s.constructCircleCenterAndPoint(n[1],n[0],h):s.constructCircularArcThreePoint(n[0],n[1],n[2])}function ME(r,t,e){fd(!0,r,0,t,e)}function GE(r,t,e){const s=R(y,4);t.queryControlPoints(s),el(r,s,4,e),t.setControlPoints(s)}function VE(r,t,e){b(0)}function YE(r,t,e){b(0)}function nh(r,t,e){const s=fo(r),i=fo(t),n=Su(s,i),o=Su(s,fo(e));return o===0||n>0&&o>0&&o<=n||n<0&&o<0&&o>=n}function XE(r,t,e,s,i){const n={stack:[],error:void 0,hasError:!1};try{const o=e.clone(),a=s.clone();if(i===2){const p=[0,0];return h_(r,t,o,a,0,p),p[0]}if(o.y>a.y){const p=new y;p.assign(o),o.assign(a),a.assign(p)}const h=Te(n,new xe,!1),m=Te(n,new xe,!1),l=Te(n,new xe,!1),u=new z;if(u.setCoords(o.y,a.y),!u.containsCoordinate(0)||Math.abs(o.x-a.x)>=Math.PI)return Number.NaN;if(o.x===a.x)return o.x;Ze.geodeticDistance(r,t,o.x,o.y,a.x,a.y,m,h,null,i);const c=m.val;let g=0,_=1;const d=o.clone();for(;c*(_-g)>1e-12*r;){const p=.5*(g+_);if(Ze.geodeticCoordinate(r,t,o.x,o.y,c*p,h.val,m,l,i),d.x=m.val,d.y=l.val,u.setCoords(o.y,d.y),d.y===0)return d.x;if(u.containsCoordinate(0))_=p;else{if(u.setCoords(a.y,d.y),!u.containsCoordinate(0))return b(!1),Number.NaN;g=p}}return d.x}catch(o){n.error=o,n.hasError=!0}finally{li(n)}}function Vc(r,t,e,s){const i=new z;i.setCoords(t,e);const n=s.width();let o=Math.floor((r-t)/n)*n+r;const a=i.getCenter();for(;Math.abs(o-a)>Math.abs(o+n-a);)o+=n;return o}class xd extends mi{constructor(){super(),this.m_geometryDeque=[],this.m_index=-1}next(){if(this.m_geometryDeque.length>0){this.m_index++;const t=this.m_geometryDeque[0];return this.m_geometryDeque.shift(),t}return null}getGeometryID(){return this.m_index}tick(t){this.m_geometryDeque.push(t)}tock(){return!0}getRank(){return 1}}function RE(r,t){return r===t||r!==null&&t!==null&&r.m_csType===t.m_csType&&(r.m_WKID===0&&t.m_WKID===0?r.m_hashCode===t.m_hashCode&&r.m_canonicalWkt===t.m_canonicalWkt:r.m_WKID===t.m_WKID)}function kE(r,t){return r===t||r!==null&&t!==null&&r.m_csType===t.m_csType&&(r.m_WKID===0&&t.m_WKID===0?r.m_csType===1?r.m_peCoordSys.isEqual(t.m_peCoordSys):r.m_peCoordSys===t.m_peCoordSys:r.m_WKID===t.m_WKID)}class il{constructor(t,e=!0){this.m_PCSHorizon=null,this.m_GCSHorizon=null,this.m_GCSSplitLines=null,this.m_bGCSHorisonIsInclusive=!1,this.m_oneMeterPCS=0,this.m_oneDegreeGCS=0,this.m_gcsUnitFactor=0,this.m_northPole=y.getNAN(),this.m_southPole=y.getNAN(),this.m_polesUpdated=0,this.m_domain=F.constructEmpty(),this.m_primeMeridian=Number.NaN,this.m_geogToProjFactor=1,this.m_geogToProjOffset=0,this.m_geogToProjFactorsUpdated=0,this.m_oneMillimeter=0,this.m_centralMeridian=0,this.m_pPCSInfoNoDomain=null,this.m_oldWKID=-1973,this.m_vcsWKID=-1,this.m_bIsPannable=!1,this.m_bCached=!1,this.m_pannableExtent=F.constructEmpty(),this.m_pannableExtentGCS=F.constructEmpty(),this.m_areaOfUse=null,this.m_canonicalWkt="",this.m_peCoordSys=t,this.m_WKID=oe.getCode(t),this.m_WKID<=0?(this.m_WKID=0,this.m_canonicalWkt=tl(t,0,!0),this.m_hashCode=jc(this.m_canonicalWkt)):this.m_hashCode=dn(this.m_WKID);const s=this.m_peCoordSys.getType();this.m_csType=s===et.PE_TYPE_PROJCS?2:1,b(s===et.PE_TYPE_PROJCS||s===et.PE_TYPE_GEOGCS),s===et.PE_TYPE_PROJCS&&(t.loadConstants()||H("PeProjcs.loadConstants failed"));const i=s===et.PE_TYPE_GEOGCS?this.m_peCoordSys:this.m_peCoordSys.getGeogcs();s!==et.PE_TYPE_GEOGCS&&oe.getCode(i),this.m_unit=L1(t),this.m_primeMeridian=i.getPrimem().getLongitude();{const n=i.getUnit().getUnitFactor();this.m_gcsUnitFactor=n;let o=Math.PI/(180*n);Math.abs(o-1)<1e-10&&(o=1),this.m_oneDegreeGCS=o}if(s===et.PE_TYPE_PROJCS){const n=this.m_peCoordSys,o=n.getUnit().getUnitFactor();this.m_oneMeterPCS=1/o,this.m_oneMillimeter=.001/o,this.m_pPCSInfoNoDomain=de.generate(n,de.PE_PCSINFO_OPTION_NONE),this.m_pPCSInfoNoDomain||$("cannot create pcs info"),this.m_bIsPannable=this.m_pPCSInfoNoDomain.isPannableRectangle(),this.m_centralMeridian=this.m_pPCSInfoNoDomain.getCentralMeridian()}else{this.m_bIsPannable=!0,this.m_polesUpdated=1,this.m_oneMeterPCS=0;const n=1/i.getUnit().getUnitFactor(),o=i.getDatum().getSpheroid().getAxis();this.m_oneMillimeter=.001/o*n,this.m_centralMeridian=0}this.m_bIsPannable&&(this.updateGCSHorizon(),this.updatePCSHorizon(),this.updatePoles(),this.updateDomain(),this.updatePannableExtent(),this.updatePannableExtentGCS())}[Symbol.dispose](){}getHashCode(){return this.m_hashCode}getPCSHorizonPannable(){return this.m_PCSHorizon}getGCSHorizonPannable(){return this.m_GCSHorizon}getPCSInfo(){return b(this.m_pPCSInfoNoDomain),this.m_pPCSInfoNoDomain}getCentralMeridian(){return this.m_centralMeridian}updateGCSHorizon(){if(this.m_peCoordSys.getType()!==et.PE_TYPE_PROJCS)return;let t=!0;const e=this.m_peCoordSys,s=e.getGeogcs(),i=e.horizonGcsGenerate();if(!i)return;b(i.length>0);const n=i[0].getNump(),o=i[0].getKind();let a,h;t=i[0].getInclusive()>0;const m=this.getOneDegreeGCSUnit(),l=90*m,u=360*m,c=370*m,g=180*m*et.PE_HORIZON_DELTA/Math.PI,_=F.constructEmpty();let d=null;if(n>1){for(let p=1;p<n;p++)if(i[p].getKind()===et.PE_HORIZON_LINE){d||(d=new Pt);const f=i[p].getCoord();d.startPathCoords(f[0][0],f[0][1]),d.lineToCoords(f[1][0],f[1][1])}}if(o===et.PE_HORIZON_RECT){const p=i[0].getCoord();if(_.setFromPoints([new y(p[0][0],p[0][1]),new y(p[1][0],p[1][1])],2),Math.abs(_.ymax-l)<1e-7*g&&(_.ymax=l),Math.abs(_.ymin+l)<1e-7*g&&(_.ymin=-l),_.width()>c){const x=-400*m,E=x+5*u;_.setCoords({xmin:x,ymin:_.ymin,xmax:E,ymax:_.ymax})}const f=new Ne({env2D:_});this.m_GCSHorizon||(this.m_GCSHorizon=f,this.m_bGCSHorisonIsInclusive=t)}else{let p=this.getPCSInfo().isGcsHorizonMultiOverlap();const f=Ar(s,null,null,1),x=[],E=new z;for(let w=0;w<n;w++){if(i[w].getKind()!==et.PE_HORIZON_POLY)continue;a=i[w].getSize();const D=i[w].getCoord(),N=F.constructEmpty();N.setFromPoints(nn(D),a),x.push(new z(N.xmin,N.xmax)),N.width(),E.merge(x.at(-1))}let P=!1;const C=new z;E.width()>u&&x.length>1?(C.vmin=this.getCentralMeridian()-u,C.vmax=C.vmin+2*u,P=!0,p=!0):(C.vmin=E.vmin,C.vmax=C.vmin+u);const S=w=>{let D=0;for(;x[w].vmin+D<C.vmin;)D+=u;for(;x[w].vmax+D-u>C.vmin;)D-=u;return D};let I=new ct;if(p){const w=new xd,D=new ta().executeMany(w,f,null);for(let N=0;N<n;N++){if(i[N].getKind()!==et.PE_HORIZON_POLY)continue;a=i[N].getSize();const A=i[N].getCoord();h=i[N].getInclusive()>0;const M=new ct;if(M.addPathPoint2D(nn(A),a-1,!0),P){const G=S(N),q=x[N].clone();q.move(G);let V=G;const k=new pt;do{k.setShiftCoords(V,0);const Y=M.clone();Y.applyTransformation(k),w.tick(Y),w.tock(),V+=u,q.move(u)}while(q.vmin<C.vmax)}else w.tick(M),D.tock()}I=D.next()}else{I=new ct;for(let w=0;w<n;w++){if(i[w].getKind()!==et.PE_HORIZON_POLY)continue;a=i[w].getSize();const D=i[w].getCoord();if(h=i[w].getInclusive()>0,b(h===t),P){const N=new ct;N.addPathPoint2D(nn(D),a-1,!0);const A=S(w),M=x[w].clone();M.move(A);let G=A;const q=new pt;do{if(G!==0){q.setShiftCoords(G,0);const V=new ct({copy:N});V.applyTransformation(q),I.addPath(V,0,!0)}else I.addPath(N,0,!0);G+=u,M.move(u)}while(M.vmin<C.vmax)}else I.addPathPoint2D(nn(D),a-1,!0)}}P&&(I=new wn().execute(I,new F(C.vmin,-l-m,C.vmax,l+m),f,null)),t?new Ki().accelerateGeometry(I,f,1):new Ia().accelerateGeometry(I,f,1),new Jm().accelerateGeometry(I,f,1),this.m_GCSHorizon===null&&(this.m_GCSHorizon=I,this.m_bGCSHorisonIsInclusive=t,this.m_GCSSplitLines=d)}}updateAreaOfUse(){return null}updatePCSHorizon(){if(this.m_peCoordSys.getType()!==et.PE_TYPE_PROJCS)return;const t=this.m_peCoordSys.horizonPcsGenerate();if(!t)return;let e;this.getPCSInfo();const s=t[0].getKind();t[0].getInclusive();const i=F.constructEmpty(),n=t[0].getNump();let o=!1;if(s===et.PE_HORIZON_RECT){const a=t[0].getCoord();i.setFromPoints(nn(a),2),e=new Ne({env2D:i})}else{let a=-1;for(let u=0;u<n;u++)t[u].getKind()===et.PE_HORIZON_POLY&&(a=u);b(a>=0);const h=t[a].getSize()-1,m=t[a].getCoord(),l=new ct;e=l,l.addPathPoint2D(nn(m),h,!0),o=!0}if(this.getPCSInfo().isDensificationNeeded()){b(s!==et.PE_HORIZON_RECT);const a=1e5*this.getOneMeterPCSUnit();e=new Fi().execute(e,a,0,0,null)}if(o){{const a=new Ne;e.queryEnvelope(a),e.calculateArea2D(),e.calculateLength2D(),e.getExteriorRingCount()}new Ki().accelerateGeometry(e,null,1)}this.m_PCSHorizon===null&&(this.m_PCSHorizon=e)}updatePannableExtent(){const t=this.m_peCoordSys.getType();if(t===et.PE_TYPE_PROJCS){const e=this.m_peCoordSys,s=this.getPCSInfo().getCentralMeridian(),i=e.getGeogcs();i||$("");const n=[s+1/i.getUnit().getUnitFactor()*Math.PI,0];pe.geogToProj(e,1,n);const o=n[0],a=e.getParameters()[et.PE_PARM_X0].getValue(),h=this.getPCSHorizon(),m=F.constructEmpty();h.queryEnvelope(m);const l=Math.abs(o-a),u=l+a,c=-1*l+a,g=m.ymax,_=m.ymin;this.m_pannableExtent.setCoords({xmin:c,ymin:_,xmax:u,ymax:g})}else if(t===et.PE_TYPE_GEOGCS){const e=1/this.m_peCoordSys.getUnit().getUnitFactor()*Math.PI;this.m_pannableExtent.setCoords({xmin:-e,ymin:-e/2,xmax:e,ymax:e/2})}else $("")}updatePannableExtentGCS(){const t=this.m_peCoordSys.getType();if(t===et.PE_TYPE_PROJCS){const e=this.m_peCoordSys,s=this.m_centralMeridian,i=e.getGeogcs();i||$("");const n=1/i.getUnit().getUnitFactor()*Math.PI,o=this.getGCSHorizon(),a=F.constructEmpty();o.queryEnvelope(a),this.m_pannableExtentGCS.setCoords({xmin:s-n,ymin:a.ymin,xmax:s+n,ymax:a.ymax})}else if(t===et.PE_TYPE_GEOGCS){const e=1/this.m_peCoordSys.getUnit().getUnitFactor()*Math.PI;this.m_pannableExtentGCS.setCoords({xmin:-e,ymin:-e/2,xmax:e,ymax:e/2})}else $("")}updateDomain(){if(this.m_csType===1){const t=400*this.getOneDegreeGCSUnit();this.m_domain=F.construct(-t,-t,t,t)}else{b(this.m_csType===2);const t=de.generate(this.m_peCoordSys,de.PE_PCSINFO_OPTION_DOMAIN);t||$("generate pcs info failed");const e=new F(t.getDomainMinx(),t.getDomainMiny(),t.getDomainMaxx(),t.getDomainMaxy());this.m_domain.isEmpty()&&this.m_domain.setCoords({env2D:e})}}updatePoles(){if(this.m_peCoordSys.getType()===et.PE_TYPE_PROJCS){const t=90*this.getOneDegreeGCSUnit(),e=[[0,t],[0,-t]];pe.geogToProj(this.m_peCoordSys,2,e);const s=this.getPCSInfo().getNorthPoleLocation()!==de.PE_POLE_OUTSIDE_BOUNDARY,i=this.getPCSInfo().getSouthPoleLocation()!==de.PE_POLE_OUTSIDE_BOUNDARY;this.m_polesUpdated||(s&&this.m_northPole.setCoords(e[0][0],e[0][1]),i&&this.m_southPole.setCoords(e[1][0],e[1][1]),this.m_polesUpdated=1)}else this.m_polesUpdated=1}updateGeogToProjFactors(){if(this.m_peCoordSys.getType()===et.PE_TYPE_PROJCS){const t=this.getOneDegreeGCSUnit(),e=this.m_pPCSInfoNoDomain.getCentralMeridian(),s=[0,0,0,0];s[0]=e,s[1]=0,s[2]=e+t,s[3]=0;const i=pe.geogToProj(this.m_peCoordSys,2,s);b(i===2);const n=(s[2]-s[0])/t,o=s[0];this.m_geogToProjFactorsUpdated===0&&(this.m_geogToProjFactor=n,this.m_geogToProjOffset=o,this.m_geogToProjFactorsUpdated=1)}else this.m_geogToProjFactorsUpdated=1}getOneMeterPCSUnit(){return this.m_oneMeterPCS}getOneDegreeGCSUnit(){return this.m_oneDegreeGCS}getGcsUnitFactor(){return this.m_gcsUnitFactor}getUnitsPerMillimeter(){return this.m_oneMillimeter}getGCSSplitLines(){return this.m_bIsPannable?null:(this.m_GCSHorizon||this.updateGCSHorizon(),this.m_GCSSplitLines)}getGCSHorizon(){return this.m_bIsPannable?this.getGCSHorizonPannable():(this.m_GCSHorizon!==null||this.updateGCSHorizon(),this.m_GCSHorizon)}getGCSHorisonIsInclusive(){return this.m_bIsPannable||this.getGCSHorizon(),this.m_bGCSHorisonIsInclusive}getPCSHorizon(){return this.m_bIsPannable?this.getPCSHorizonPannable():(this.m_PCSHorizon!==null||this.updatePCSHorizon(),this.m_PCSHorizon)}getPole(t){return this.m_bIsPannable||this.m_polesUpdated!==0||this.updatePoles(),t?this.m_southPole:this.m_northPole}getGeogToProjFactors(){return this.m_geogToProjFactorsUpdated===0&&this.updateGeogToProjFactors(),te(this.m_geogToProjFactor,this.m_geogToProjOffset)}getDomainXY(){if(this.m_bIsPannable)return this.m_domain.clone();let t=!1;return t=this.m_domain.isEmpty(),t&&this.updateDomain(),this.m_domain.clone()}getPrimeMeridian(){return this.m_primeMeridian}getLatestID(){return this.m_WKID}getOldID(){let t=this.m_oldWKID;if(t<0){if(t=0,this.m_WKID>0){const e=[0],s=[0];dS(this.m_peCoordSys.getType(),this.m_WKID,e,s)||$("query_code_change"),t=e[0]}this.m_oldWKID=t}return t}isCustomWkid(){return!1}isPannable(){return this.m_bIsPannable}getPannableExtent(){return this.m_pannableExtent.clone()}getPannableExtentGCS(){return this.m_pannableExtentGCS.clone()}getAreaOfUse(){return this.m_areaOfUse!==null?this.m_areaOfUse:this.updateAreaOfUse()}getVcsCode(){return 0}saveMemory(){}getCSType(){return this.m_csType}getUnit(){return this.m_unit}setCached(){this.m_bCached=!0}getCached(){return this.m_bCached}static equal(t,e){return!1}static equal_for_projection(t,e){return!1}}class LE{constructor(t,e=!0){this.m_oneMeter=0,this.m_WKID=-1,this.m_oldWKID=-1,this.m_canonicalWkt="not yet implemented",this.m_model=0,this.m_unit=new hi,this.m_cached=!1}setCached(t=!0){this.m_cached=t}getCached(){return this.m_cached}getOneMeterUnit(){return 0}getLatestID(){return this.m_WKID}getOldID(){let t=this.m_oldWKID;return t<0&&(t=0,this.m_WKID>0&&(t=this.m_WKID),this.m_oldWKID=t),t}getModel(){return 0}isCustomWkid(){return!1}getVerticalUnit(){return this.m_unit}static equal(t,e){return!1}static equal_for_projection(t,e){return!1}}function BE(r,t,e){return yd(r,t,F.constructEmpty(),e)}function yd(r,t,e,s){return HE(!0,r,t,e,s)}function Bi(r,t,e,s){return nl(!0,r,t,e,s)}function HE(r,t,e,s,i){return xs()||la("cannot create projection transformation"),t.hasVCS()&&e.hasVCS()?zE():UE(t,e,s,i)}function nl(r,t,e,s,i,n){return xs()||la("cannot create projection transformation"),new al(r?2:1,t,e,s,i,n)}function Pd(r,t,e,s,i,n=!1){if(t&&e||H(""),xs()||la("cannot obtain geotransformation list"),r===1&&t.hasVCS()&&e.hasVCS())return ft("hv xform not impl"),[];{const o=Vd(t,e,s,i,n),a=[];for(const h of o)a.push(h);return a}}function rl(){return{centralMeridianOfOutputGCS:Number.NaN,densificationStep:Number.NaN,clipWithInputHorizon:!0,clipWithOutputHorizon:!0,legacyHorizonClipping:!1,normalizeResultGeometry:!1,equals(r){return ze(this.centralMeridianOfOutputGCS,r.centralMeridianOfOutputGCS)&&ze(this.densificationStep,r.densificationStep)&&this.clipWithInputHorizon===r.clipWithInputHorizon&&this.clipWithOutputHorizon===r.clipWithOutputHorizon&&this.legacyHorizonClipping===r.legacyHorizonClipping&&this.normalizeResultGeometry===r.normalizeResultGeometry}}}function zE(r,t,e,s){return b(0),{}}function UE(r,t,e,s){r&&t||H("!inputSR || !outputSR");const i=r.getLatestID(),n=t.getLatestID();if(i===3857&&n===4326){if(r.m_bDefaultDescriptor&&t.m_bDefaultDescriptor)return Ed()}else if(i===4326&&n===3857&&r.m_bDefaultDescriptor&&t.m_bDefaultDescriptor)return JE();const o=F.constructEmpty();o.setCoords({env2D:e});const a=r.getCoordinateSystemType(),h=t.getCoordinateSystemType();if(a===0||h===0)return lo(r,t);if(s){const g=s.find(0,r.getGCS(),t.getGCS());if(g)return lo(r,t,g)}const m=r.getGCS().getLatestID(),l=t.getGCS().getLatestID();if(m>0&&m===l)return lo(r,t);const u=new ZE(r,t,e);{const g=QE(u);if(g)return g}const c=Pd(0,r,t,o,1,!0);return KE(u,lo(r,t,c.length?c[0]:void 0))}function lo(r,t,e,s,i){return new al(1,r,t,e,s,i)}function ol(){return{flagsMask:0,setFlag(r,t){t?this.flagsMask|=r:this.flagsMask&=~r},hasFlag(r){return(this.flagsMask&r)!==0}}}function um(){return{m_extendedParams:rl(),m_extendedParamsInternal:ol()}}function rh(){return um()}let al=class Cd{constructor(t,e,s,i,n,o){let a,h;this.m_datumTran=null,this.m_bIdentity=!0,this.m_bIdentityGeogToGeog=!0,this.m_bVertical=!1,this.m_bNormalize=!1,e&&s||H("!inputSR || !outputSR"),i&&i.getType()===0&&(i.m_bReadOnly=!0),this.m_bNormalize=!1,t!==1&&(a=e.getVCS(),h=s.getVCS(),this.m_bVertical=a!=null&&h!=null),this.m_inputSR=e,this.m_outputSR=s,this.m_bIdentity=!1,this.m_bIdentityGeogToGeog=!1,b(!this.m_params),n&&(this.m_params=um(),this.m_params.m_extendedParams=n),o&&(this.m_params||(this.m_params=um()),this.m_params.m_extendedParamsInternal=o);let m=!1;const l=i!=null,u=e.getCoordinateSystemType(),c=s.getCoordinateSystemType();if(s.isPannable()&&u!==0&&n){const d=n.centralMeridianOfOutputGCS;if(!Number.isNaN(d)&&s.isPannable()){const p=s.getPannableExtent(),f=p.getCenterX();if(f!==d){const x=Math.ceil(p.width());d+x!==f+x&&(m=!0)}}}const g=n&&n.normalizeResultGeometry;if(e.equals(s))return this.m_bIdentity=!m,this.m_bIdentityGeogToGeog=!0,void this.updateProjector();const _=!l&&e.equalForProjection(s,this.m_bVertical);this.m_bIdentity=_&&!m,this.m_bIdentity?this.m_bIdentityGeogToGeog=!0:u!==0&&c!==0&&(g&&this.m_outputSR.isPannable()&&(this.m_bNormalize=g),this.m_datumTran=i||null,this.m_bIdentityGeogToGeog=(!this.m_datumTran||this.m_datumTran.count()===0)&&this.m_inputSR.getGCS().equalForProjection(this.m_outputSR.getGCS(),this.m_bVertical)),this.updateProjector()}getInputSR(){return this.m_inputSR}getOutputSR(){return this.m_outputSR}getDatumTransformation(){return this.m_datumTran}getInverse(){const t=new Cd(1,this.m_outputSR,this.m_inputSR,this.m_datumTran?.createInverse());return t.m_bIdentity=this.m_bIdentity,t.m_bVertical=this.m_bVertical,t.m_bIdentityGeogToGeog=this.m_bIdentityGeogToGeog,t.updateProjector(),t}isIdentity(){return this.m_bIdentity}getExtendedParams(){return this.m_params?this.m_params.m_extendedParams:rh().m_extendedParams}equals(t){return b(0),!1}isVertical(){return this.m_bVertical}isMatchingTransformation(t,e){return b(0),!1}getGeographicTransformations(){return this.m_datumTran}getExtendedParamsImpl(){return this.m_params?this.m_params.m_extendedParams:rh().m_extendedParams}getExtendedParamsInternal(){return this.m_params?this.m_params.m_extendedParamsInternal:rh().m_extendedParamsInternal}isIdentityGeogToGeog(){return this.m_bIdentityGeogToGeog}normalizeOutput(){return this.m_bNormalize}updateProjector(){this.m_projector=new oC(this)}};const hl=new Map,Nr=new Map,cm=new Map;function na(r){let t=r.getCode();if(t>0)return ml(t)||_m(oe.coordsys(t));const e=r.getName();if(Nr.has(e)){const s=Nr.get(e);if(s&&s.deref()){const i=s.deref();if(i.m_peCoordSys.isEqual(r))return i}}return t=oe.getCode(r),_m(t>0?oe.coordsys(t):r)}function OE(r){r<=0&&_h(r);{const s=ml(r);if(s)return s}const t=Rn(oe.coordsys(r));t.get()||_h(r);const e=_m(t.release());return e.getLatestID()!==r&&hl.set(r,new WeakRef(e)),e}function WE(r){const t=new LE({},!0);return t.m_WKID=r,t}function $E(r){const t=Rn(oe.fromString(et.PE_TYPE_COORDSYS,r));return t.get()||Wc(r),na(t.release())}function jE(r){Nr.delete(r.m_peCoordSys.getName()),cm.delete(tl(r.m_peCoordSys,0,!1))}class ZE{constructor(t,e,s){this.m_hashCode=-1,t&&(this.m_inputSR=t,this.m_outputSR=e,this.m_env=s.clone(),this.m_hashCode=this.m_inputSR.getHashCode(),this.m_hashCode=le(this.m_hashCode,this.m_outputSR.getHashCode()),this.m_env.isEmpty()||(this.m_hashCode=le(this.m_hashCode,Hr(this.m_env.xmin)),this.m_hashCode=le(this.m_hashCode,Hr(this.m_env.xmax)),this.m_hashCode=le(this.m_hashCode,Hr(this.m_env.ymin)),this.m_hashCode=le(this.m_hashCode,Hr(this.m_env.ymax))))}getHashCode(){return this.m_hashCode}equals(t){return!(this.m_inputSR&&!t.m_inputSR||!this.m_inputSR&&t.m_inputSR)&&this.m_env.equals(t.m_env)&&this.m_inputSR.equals(t.m_inputSR)&&this.m_outputSR.equals(t.m_outputSR)}clear(){this.m_inputSR=void 0,this.m_outputSR=void 0,this.m_hashCode=-1,this.m_env=void 0}}const gm=new Map;function QE(r){if(gm.has(r.getHashCode()))return gm.get(r.getHashCode())}function KE(r,t){return gm.set(r.getHashCode(),t),t}let oh,ah,hh;function Ed(){return oh||(oh=Bi(Aa(),qa())),oh}function JE(){return ah||(ah=Ed().getInverse()),ah}function tS(){return hh||(hh=oe.unit(9001)),hh}function eS(r){return Rn(oe.coordsys(r)).get()!==null}const mh=new Map;function sS(r){if(mh.has(r))return mh.get(r);{const t=eS(r);return mh.set(r,t),t}}function iS(r){return!1}function _m(r){const t=Rn(r),e=r.getCode();if(e>0){const a=ml(e);if(a)return a}const s=r.getName();let i=Nr.get(s);if(i){const a=i.deref();if(a&&a.m_peCoordSys.isEqual(r))return a}const n=new il(t.release());if(e>0)return n.setCached(),hl.set(e,new WeakRef(n)),Nr.set(s,new WeakRef(n)),n;const o=tl(r,0,!1);if(i=cm.get(o),i){const a=i.deref();if(a)return a}return n.setCached(),cm.set(o,new WeakRef(n)),n}function ml(r){const t=hl.get(r);if(t)return t.deref()}class hi extends o_{constructor(t){return t===void 0?(super(),this.m_wkid=9001,void(this.m_peUnit=null)):typeof t=="number"?(super(),this.m_factor=t,void(this.m_wkid=0)):(super(t),void(t||(this.m_factor=1,this.m_wkid=9001,this.m_peUnit=tS())))}getUnitType(){return 0}convertFromMeters(t){return t/this.getUnitToBaseFactor()}convertToMeters(t){return t*this.getUnitToBaseFactor()}}const nS=["0","1","2","3","4","5","6","7","8","9","b","c","d","e","f","g","h","j","k","m","n","p","q","r","s","t","u","v","w","x","y","z"];function rS(r,t,e){const s=j(t,"R");let i=0,n=0;for(let o=0;o<t;o++){let a=r[i]>>n&31;if(n+=5,n>31){const m=37-n;a&=(1<<m)-1,n-=32,i++,a|=(r[i]&(1<<n)-1)<<m}const h=nS[a];s[t-1-o]=h}return e>t?s.push(..."0".repeat(e-t)):e<t&&(s.length=e),s.join("")}function Yc(r,t,e,s,i){b(s>>5<i.length);let n=t,o=e;for(let a=s;a>=0;a-=2){const h=31&a,m=.5*(o+n);r>=m?(i[a>>5]|=1<<h,n=m):o=m}}let ra=new Set;const dm=2147483645n,bo=9007199254740990n,lh="operation is not supported for unknown coordinate systems";var Xc;function sn(){return{majorSemiAxis:0,e2:0,minorSemiAxis:0,flattening:0,isSphere(){return this.e2===0}}}function oS(r,t,e){r.majorSemiAxis=t,r.minorSemiAxis=t*(1-e),r.e2=e*(2-e),r.flattening=e}function aS(r){if(oe)return;_S(r);const t=ra;ra=null,t.forEach(e=>{const s=e.deref();s&&s.attachToPe()})}function Sd(r){gS(r)}function xs(){return!!oe}function ll(){return!!wi}function Na(){return!!oe||!!wi}function oa(r,t,e){return b(Na()),Ma(r,t===void 0?0:t,null,!1)}function ul(r,t){b(Na());const e=new ci;let s;return xs()?(s=$E(r),e.setHorzProj_(s),e.m_vertcs=null,e.m_userWKID=s.getLatestID()):(s=Ga(r),e.m_unit=s.isPCS?new hi(s.metersOrRadiansPerUnit):new wr(s.metersOrRadiansPerUnit)),Fa(e.m_precisionDescriptor,s,null,1),e.m_bDefaultDescriptor=!0,e.m_userWKT=r,e.calculateHashCode(),e.initDbgName(),e}function Ar(r,t,e,s,i=!0){let n=null;return t&&(n=AC(t,i)),hS(r,n,e,s,i)}function hS(r,t,e,s,i){r||H("!PE_coord_sys");const n=new ci;let o;return o=i?na(r):new il(r,!1),Fa(n.m_precisionDescriptor,o,t,s),n.m_bDefaultDescriptor=!0,n.setHorzProj_(o),n.m_vertcs=t,n.m_userWKID=o.getLatestID(),n.calculateHashCode(),n.initDbgName(),n}function cl(r,t,e=!1){r.getCoordinateSystemType()===3&&H("image spatial reference cannot be altered");const s=new ci,i=r;return s.m_peCoordSysVal=i.m_peCoordSysVal,s.m_vertcs=i.m_vertcs,s.m_unit=i.m_unit,s.m_precisionDescriptor.assign(t),s.m_localZToXYFactor=i.m_localZToXYFactor,(Number.isNaN(s.m_precisionDescriptor.m_falseX)||Number.isNaN(s.m_precisionDescriptor.m_falseY))&&(s.m_precisionDescriptor.m_falseX=i.m_precisionDescriptor.m_falseX,s.m_precisionDescriptor.m_falseY=i.m_precisionDescriptor.m_falseY),s.m_precisionDescriptor.snapPrecision(),s.m_precisionDescriptor.fixTolerance(),s.m_userWKID=i.m_userWKID,s.m_precisionDescriptor.equals(i.m_precisionDescriptor)?s.m_bDefaultDescriptor=i.m_bDefaultDescriptor:s.m_bDefaultDescriptor=!1,e&&(s.m_bDefaultDescriptor=!0),s.calculateHashCode(),s.initDbgName(),s}function pm(r,t,e){return{}}function vd(r,t,e){t===void 0&&(t=1),(t<=0||!Number.isFinite(t))&&H(""),r||t===1||H("null Unit has to have z_to_xy_factor equal to 1");const s=new ci;s.m_unit=r;const i=r||new hi(9001);return qd(s.m_precisionDescriptor,i,null,1),s.m_bDefaultDescriptor=!0,Number.isNaN(s.m_precisionDescriptor.m_falseX)&&H("NAN false X/Y are not allowed here"),s.m_localZToXYFactor=t,s.calculateHashCode(),s.initDbgName(),s}function bd(r,t){return r.snapGeometry(t)}function Io(r){const t=r.getCoordinateSystemType();return t===1?r:(t===3&&b(0),r.getGCS())}function Id(r){return b(Na()),ll()?pS(r):sS(r)}function wd(r){if(xs())return Rn(oe.fromString(et.PE_TYPE_COORDSYS,r)).get()!==null;try{return Ga(r),!0}catch{}return!1}let uh;function Dd(){return uh||(uh=(()=>{const r=Math.trunc(Math.random()*Ie()),t=Date.now();return`|abba_000|${r.toString(16)}|${t.toString(16)}|`})()),uh}(function(r){r[r.utmDefault=0]="utmDefault",r[r.utmNorthSouth=1]="utmNorthSouth"})(Xc||(Xc={}));let mS=0;function Td(r=""){let t=`${Dd()}${mS++}`;return r!==""&&(t+=`|${r}`),t}function Nd(r){return r.startsWith(Dd())}let uo,co,go,ci=class Zn{destroy(){jE(this.m_peCoordSysVal),this.getCoordinateSystemType()===1||this.getCoordinateSystemType()===2?this.getPECoordSys().destroy():$("SpatialReference.destroy")}constructor(){this.m_vertcs=null,this.m_peCoordSysVal=null,this.m_userWKID=0,this.m_userWKT=null,this.m_geogSpatialReference=null,this.m_srToGcs=null,this.m_gcsToSr=null,this.m_defaultPrecisionSR=null,this.m_localZToXYFactor=-1,this.m_precisionDescriptor=new Me,this.m_hashCode=0,this.m_bDefaultDescriptor=!1,_l(this.m_precisionDescriptor),ra&&ra.add(new WeakRef(this))}attachToPe(){(this.m_userWKID>0?oa(this.m_userWKID):ul(this.m_userWKT)).copyTo(this,!1)}copyTo(t,e=!0){(e||t.m_bDefaultDescriptor)&&(t.m_bDefaultDescriptor=this.m_bDefaultDescriptor,t.m_precisionDescriptor.assign(this.m_precisionDescriptor)),t.m_defaultPrecisionSR=null,t.m_gcsToSr=this.m_gcsToSr,t.m_geogSpatialReference=this.m_geogSpatialReference,t.m_hashCode=this.m_hashCode,t.m_localZToXYFactor=this.m_localZToXYFactor,t.m_peCoordSysVal=this.m_peCoordSysVal,t.m_srToGcs=this.m_srToGcs,t.m_userWKID=this.m_userWKID,t.m_userWKT=this.m_userWKT,t.m_vertcs=this.m_vertcs,t.m_unit=this.m_unit}getHashCode(){return this.m_hashCode}getHashCodeHorizontal(){let t=0;return t=this.m_peCoordSysVal?this.m_peCoordSysVal.getHashCode():this.m_unit?this.m_unit.getHashCode():305419891,t}updateTransform(t){if(this.getCoordinateSystemType()===1)return Bi(this,this,null);let e=t?this.m_srToGcs:this.m_gcsToSr;if(e)return e;const s=this.getGCS(),i=this;e=t?Bi(i,s,null):Bi(s,i,null);const n=e;return(t?this.m_srToGcs:this.m_gcsToSr)||(t?this.m_srToGcs=n:this.m_gcsToSr=n,e)}getHashCodeVertical(){return this.m_vertcs?this.m_vertcs.getHashCode():0}calculateHashCode(){let t=this.getHashCodeHorizontal();const e=this.getHashCodeVertical(),s=this.m_precisionDescriptor.getHashCode();t=le(t,e),this.m_hashCode=le(t,s)}initDbgName(){}setHorzProj_(t){this.m_peCoordSysVal=t,this.m_unit=this.m_peCoordSysVal.getUnit()}getTolerance(t=0){return this.m_precisionDescriptor.getTolerance(t)}getResolution(t=0){return this.m_precisionDescriptor.getResolution(t)}getPECoordSys(){return this.m_peCoordSysVal?this.m_peCoordSysVal.m_peCoordSys:null}getPCSInfo(){return this.throwIfNotGCSOrPCS(),b(this.m_peCoordSysVal),this.m_peCoordSysVal.getPCSInfo()}getCentralMeridian(){return this.throwIfNotGCSOrPCS(),this.getCoordinateSystemType()===1?0:this.getPCSInfo().getCentralMeridian()}getCoordinateSystemType(){const t=this.getPECoordSys();if(t)switch(t.getType()){case et.PE_TYPE_GEOGCS:return 1;case et.PE_TYPE_PROJCS:return 2;default:return 0}else{if((this.m_userWKID>0||this.m_userWKT)&&this.m_unit instanceof hi)return 2;if(this.m_unit instanceof wr)return 1}return 0}getID(){return this.m_userWKID}getLatestID(){return this.m_peCoordSysVal?this.m_peCoordSysVal.getLatestID():this.m_userWKID}getOldID(){return this.m_peCoordSysVal?this.m_peCoordSysVal.getOldID():this.m_userWKID}getVerticalID(){return ft("vcs not implemented"),0}getLatestVerticalID(){return this.m_vertcs?this.m_vertcs.getLatestID():0}getOldVerticalID(){return ft("vcs not implemented"),0}getPEVerticalCoordSys(){return null}getPole(t){return this.throwIfNotGCSOrPCS(),b(this.m_peCoordSysVal),this.m_peCoordSysVal.getPole(t)}getText(){const t=this.getPECoordSys();return t?Fc(t):this.m_userWKT??""}getTextExtended(t){const e=this.getPECoordSys();return e?this.getPEVerticalCoordSys()?tE(null,e,this.getPEVerticalCoordSys()):Fc(e,t):this.m_userWKT??""}getText2(t=-1){const e=this.getPECoordSys();return e?eE(e,t):this.m_userWKT??""}getUnit(){return this.m_unit}getUnitsPerMillimeter(){return this.m_peCoordSysVal?this.m_peCoordSysVal.getUnitsPerMillimeter():this.m_unit instanceof hi?.001/this.m_unit.getUnitToBaseFactor():this.m_unit instanceof wr?.001/(Ga(this.m_userWKT??this.m_userWKID).semiMajor*this.m_unit.getUnitToBaseFactor()):(Yt("sr object not in valid state"),0)}getAuthorityName(){return this.getPECoordSys()?sE():""}getVerticalUnit(){return ft("vcs not implemented"),{}}getVCS(){return this.m_vertcs}hasVCS(){return!1}getGCSHorisonIsInclusive(){return this.throwIfNotGCSOrPCS(),b(this.m_peCoordSysVal),this.m_peCoordSysVal.getGCSHorisonIsInclusive()}getGCSHorizon(){return this.throwIfNotGCSOrPCS(),b(this.m_peCoordSysVal),this.m_peCoordSysVal.getGCSHorizon()}getGCS(){const t=this.getCoordinateSystemType();if(t===0)Yt(lh);else{if(t===1)return this;t===3&&Yt("image cs not supported")}if(this.m_geogSpatialReference)return this.m_geogSpatialReference;let e;if(this===Aa()||this===gl())e=qa();else{b(this.m_peCoordSysVal);const s=this.m_peCoordSysVal.m_peCoordSys.getGeogcs();s||$(""),e=Ar(s,this.m_vertcs,null,this.m_precisionDescriptor.getPrecision(),this.m_peCoordSysVal.getCached())}return this.m_geogSpatialReference?e=this.m_geogSpatialReference:this.m_geogSpatialReference=e,e}getGCSSplitLines(){return this.throwIfNotGCSOrPCS(),b(this.m_peCoordSysVal),this.m_peCoordSysVal.getGCSSplitLines()}toGCS(t,e){if(t.length===0)return 0;t.length>e.length&&H("coordsSrc.size() > coordsDst.size()");const s=this.getCoordinateSystemType();if(s===0&&Yt(lh),s===1)return Ao(e,t,t.length),t.length;b(this.m_peCoordSysVal);const i=this.getSRToGCSTransform();return new Rs().transform(i,t,t.length,e)}toGeohash(t,e=8){const s=t.clone();s.scale(this.getGCS().getUnit().getID()===9102?1:this.getGCS().getUnit().getUnitToBaseFactor()/Math.PI*180),s.x<-180?(s.x=Ci(s.x,360),s.x<-180&&(s.x+=360)):s.x>180&&(s.x=Ci(s.x,360),s.x>180&&(s.x-=360)),s.y>90&&(s.y=90),s.y<-90&&(s.y=-90);const i=5*e,n=new Uint32Array(4);return Yc(s.x,-180,180,i-1,n),Yc(s.y,-90,90,i-2,n),rS(n,e,e)}isPannable(){const t=this.getCoordinateSystemType();return t!==0&&t!==3&&(b(this.m_peCoordSysVal),this.m_peCoordSysVal.isPannable())}getPannableExtent(){return this.isPannable()||H("!is_pannable"),b(this.m_peCoordSysVal),this.m_peCoordSysVal.getPannableExtent()}getPannableExtentInGCS(){return this.isPannable()||H("!is_pannable"),b(this.m_peCoordSysVal),this.m_peCoordSysVal.getPannableExtentGCS()}throwIfNotGCSOrPCS(){const t=this.getCoordinateSystemType();t!==1&&t!==2&&H("Not a GCS or PCS")}getDomainXY(){return this.throwIfNotGCSOrPCS(),b(this.m_peCoordSysVal),this.m_peCoordSysVal.getDomainXY()}getFullWorldExtent(){return this.throwIfNotGCSOrPCS(),this.isPannable()?this.getPannableExtent():this.getDomainXY()}queryPrecisionDescriptor(t){if(t.assign(this.m_precisionDescriptor),Number.isNaN(t.m_falseX))if(xs()||la("cannot query precision descriptor"),b(this.m_peCoordSysVal!==null),this.m_precisionDescriptor.m_precision!==2){const e=this.m_peCoordSysVal.getDomainXY();t.m_falseX=e.xmin,t.m_falseY=e.ymin}else t.m_falseX=-Number.MAX_VALUE,t.m_falseY=-Number.MAX_VALUE}queryPrecisionDescriptorWithoutFalseXY(t){t.assign(this.m_precisionDescriptor),t.m_falseX=Number.NaN,t.m_falseY=Number.NaN}queryDefaultPrecisionDescriptorWithoutFalseXY(t){if(this.m_bDefaultDescriptor)t.assign(this.m_precisionDescriptor);else{const e=this.getCoordinateSystemType();e===0?qd(t,this.m_unit,this.m_vertcs,this.m_precisionDescriptor.getPrecision()):e===3?ft("image cs"):Fa(t,this.m_peCoordSysVal,this.m_vertcs,this.m_precisionDescriptor.getPrecision())}t.m_falseX=Number.NaN,t.m_falseY=Number.NaN}horizontalEqual(t){return RE(this.m_peCoordSysVal,t.m_peCoordSysVal)}verticalEqual(t){return this.m_vertcs!==null==(t.m_vertcs!==null)&&(!this.m_vertcs||this.m_vertcs.equals(t.m_vertcs))}equals(t){const e=t;if(this===e)return!0;if(!this.horizontalEqual(e)||!this.verticalEqual(e)||!e.m_peCoordSysVal&&(b(!this.m_peCoordSysVal),this.m_unit!==null!=(e.m_unit!==null)||this.m_unit&&!this.m_unit.equals(e.m_unit)||this.m_localZToXYFactor!==e.m_localZToXYFactor))return!1;if(!this.m_bDefaultDescriptor||!e.m_bDefaultDescriptor){if(this.m_peCoordSysVal){if(!this.m_precisionDescriptor.equalsWithoutFalseXY(e.m_precisionDescriptor))return!1;b(e.m_peCoordSysVal);let s=this.m_precisionDescriptor.m_falseX,i=this.m_precisionDescriptor.m_falseY;if(Number.isNaN(s)){const a=this.m_peCoordSysVal.getDomainXY();s=a.xmin,i=a.ymin}let n=e.m_precisionDescriptor.m_falseX,o=e.m_precisionDescriptor.m_falseY;if(Number.isNaN(n)){const a=e.m_peCoordSysVal.getDomainXY();n=a.xmin,o=a.ymin}return s===n&&i===o}return this.m_precisionDescriptor.equals(e.m_precisionDescriptor)}return!0}equalForProjection(t,e){if(this===t)return!0;const s=this.getCoordinateSystemType(),i=t.getCoordinateSystemType();if(s===0||i===0)return s===0&&i===0?(!e||this.getZToXYFactor()===t.getZToXYFactor())&&(!this.getUnit()||!t.getUnit()||this.getUnit().equals(t.getUnit())):s!==3&&i!==3&&(this.getUnit()===null||t.getUnit()===null||(!e||this.getZToXYFactor()===t.getZToXYFactor())&&this.getUnit().equals(t.getUnit()));if(s!==i)return!1;if(s===3)return this.equals(t);if(kE(this.m_peCoordSysVal,t.m_peCoordSysVal)){if(!e)return!0;if(this.m_vertcs!==null==(t.m_vertcs!==null))return!this.m_vertcs||this.m_vertcs.equalForProjection(t.m_vertcs)}return!1}equalHorizontal(t){return this.horizontalEqual(t)}equalVertical(t){return b(0),!1}equalVerticalVCS(t){return b(0),!1}convergenceAngle(t){return b(0),0}getPeCoordsysCopy(){if(this.m_peCoordSysVal){const t=this.m_peCoordSysVal.m_peCoordSys;return t||$("cannot clone coord sys"),t}return null}getPeVertcsCopy(){return b(0),0}throwIfLocal(){this.getCoordinateSystemType()===0&&H(lh)}getPrimeMeridian(){return this.throwIfLocal(),b(this.m_peCoordSysVal),this.m_peCoordSysVal.getPrimeMeridian()}getSRToGCSTransform(){return this.updateTransform(!0)}getGCSToSRTransform(){return this.updateTransform(!1)}getOneMeter(){return 1e3*this.getUnitsPerMillimeter()}getOneMeterPCSUnit(){return this.throwIfNotGCSOrPCS(),b(this.m_peCoordSysVal),this.m_peCoordSysVal.getOneMeterPCSUnit()}getDefaultPrecisionSR(){if(this.m_bDefaultDescriptor)return this;if(this.m_defaultPrecisionSR===null){const t=new Me;this.queryDefaultPrecisionDescriptorWithoutFalseXY(t),this.m_defaultPrecisionSR=cl(this,t,!0)}return this.m_defaultPrecisionSR}getPCSHorizon(){return this.throwIfNotGCSOrPCS(),b(this.m_peCoordSysVal),this.m_peCoordSysVal.getPCSHorizon()}getHorzUnitFactor(){return this.m_unit?this.m_unit.getUnitToBaseFactor():1}querySpheroidData(t){this.throwIfNotGCSOrPCS(),b(this.m_peCoordSysVal);const e=this.getGCS().getPECoordSys().getDatum().getSpheroid(),s=e.getFlattening();oS(t,e.getAxis(),s)}getAreaOfUse(){this.getCoordinateSystemType()===0&&Yt(""),b(this.m_peCoordSysVal);const t=this.m_peCoordSysVal.getAreaOfUse();return t===null?new Ir:new Ir({geom:t.clone(),sr:oa(4326)})}getZToXYFactor(){return 1}isCustomWkid(){return!1}getOneDegreeGCSUnit(){return this.throwIfNotGCSOrPCS(),b(this.m_peCoordSysVal),this.m_peCoordSysVal.getOneDegreeGCSUnit()}getGcsUnitFactor(){return this.throwIfNotGCSOrPCS(),b(this.m_peCoordSysVal),this.m_peCoordSysVal.getGcsUnitFactor()}snapGeometry(t){if(t.isEmpty()||this.m_precisionDescriptor.getPrecision()===2)return!1;const e=t.getGeometryType();if(We(e))return this.snapMultiVertex_(t);if(e===T.enumPoint)return this.snapPoint_(t);if(e===T.enumEnvelope)return this.snapEnvelope_(t);if(he(e))return this.snapSegment_(t);if(e===T.enumGeometryCollection){const s=t;let i=!1;for(let n=0,o=s.getGeometryCount();n<o;++n)i=this.snapGeometry(s.getGeometry(n))||i;return i}$("what else?")}snapMultiVertex_(t){if(b(!t.isEmpty()),b(this.m_precisionDescriptor.getPrecision()!==2),lt(t.getGeometryType())){const n=t;if(n.hasNonLinearSegments())return this.snapGeometryWithCurves_(n)}const e=t.getImpl(),s=e.getDescription();let i=!1;for(let n=0,o=s.getAttributeCount();n<o;n++){const a=s.getSemantics(n),h=e.getAttributeStreamRef(a);i=this.snapAttributes(a,h,0,e.getPointCount())||i}return i&&e.notifyModifiedFlags(2001),i}snapPoint_(t){return!1}snapEnvelope_(t){return!1}snapSegment_(t){b(!t.isEmpty()),b(this.m_precisionDescriptor.getPrecision()!==2);const e=new Me;this.queryPrecisionDescriptor(e);const s=t.getStartXY(),i=new y;i.x=hn(s.x,e.getFalseX(),e.getGridUnitsXY()),i.y=hn(s.y,e.getFalseY(),e.getGridUnitsXY());let n=!i.equals(s);const o=t.getEndXY(),a=new y;a.x=hn(o.x,e.getFalseX(),e.getGridUnitsXY()),a.y=hn(o.y,e.getFalseY(),e.getGridUnitsXY()),n||=!a.equals(o),n&&t.changeEndPoints2D(i,a);const h=(l,u,c)=>{let g=!1;{const _=t.getStartAttributeAsDbl(l,0),d=hn(_,u,c),p=!ze(d,_);g||=p,p&&t.setStartAttribute(l,0,d)}{const _=t.getEndAttributeAsDbl(l,0),d=hn(_,u,c),p=!ze(d,_);g||=p,p&&t.setEndAttribute(l,0,d)}return g};let m=n?1:0;return t.hasAttribute(1)&&(m|=h(1,e.getFalseZ(),e.getGridUnitsZ())?1:0),t.hasAttribute(2)&&(m|=h(2,e.getFalseM(),e.getGridUnitsM())?1:0),!!m}snapGeometryWithCurves_(t){b(!t.isEmpty()),b(this.m_precisionDescriptor.getPrecision()!==2);const e=t.createInstance(),s=new it;let i=0;for(let n=0,o=t.getPathCount();n<o;++n){const a=t.getSegmentCountPath(n);if(a===0){if(e.addPath(t,n,!0),e.getPathSize(n)===1){const m=new st;e.getPointByVal(e.getPointCount()-1,m),i|=this.snapGeometry(m)?1:0,e.setPointByVal(e.getPointCount()-1,m)}continue}const h=t.isClosedPath(n);for(let m=0,l=h?a-1:a;m<l;++m)t.getSegmentFromPath(n,m,s,!1),i|=this.snapGeometry(s.get())?1:0,e.addSegment(s.get(),m===0);h&&(t.getSegmentFromPath(n,a-1,s,!1),i|=this.snapGeometry(s.get())?1:0,a===1?e.addPathFromClosedSegment(s.get(),!1):e.closeLastPathWithSegment(s.get()))}return i&&e.copyTo(t),!!i}snapAttributes(t,e,s,i){let n=!1;const o=new Me;if(this.queryPrecisionDescriptor(o),t===0){const a=e;for(let h=s;h<i;h++){const m=a.read(2*h),l=Zn.s_SnapValue(m,o.getFalseX(),o.getGridUnitsXY()),u=a.read(2*h+1),c=Zn.s_SnapValue(u,o.getFalseY(),o.getGridUnitsXY());n=n||l!==m||c!==u,n&&(a.write(2*h,l),a.write(2*h+1,c))}}else if(t===1){const a=e;for(let h=s;h<i;h++){const m=a.read(h),l=Zn.s_SnapValue(m,o.getFalseZ(),o.getGridUnitsZ());n=n||!ze(l,m),n&&a.write(h,l)}}else if(t===2){const a=e;for(let h=s;h<i;h++){const m=a.read(h),l=Zn.s_SnapValue(m,o.getFalseM(),o.getGridUnitsM());n=n||!ze(l,m),n&&a.write(h,l)}}return n}static s_SnapValue(t,e,s){return Hi((t-e)*s)/s+e}};class Me{constructor(){const t=bo,e=1e-4,s=.001,i=e*Number(t)*.5;this.m_precision=1,this.m_falseX=-i,this.m_falseY=-i,this.m_unitsXY=Number(t)/(2*i),this.m_falseM=-1e5,this.m_unitsM=1/e,this.m_falseZ=-1e5,this.m_unitsZ=1/e,this.m_toleranceXY=s,this.m_toleranceM=s,this.m_toleranceZ=s}getHashCode(){let t=7777,e=7777;return e=le(e,this.m_falseM),e=le(e,this.m_unitsM),t=le(t,this.m_unitsXY),e=le(e,this.m_toleranceXY),t=le(t,this.m_falseZ),e=le(e,this.m_toleranceZ),t=le(t,this.m_unitsZ),e=le(e,this.m_toleranceM),t=le(t,this.m_precision),le(t,e)}clone(){const t=new Me;return t.m_falseX=this.m_falseX,t.m_falseY=this.m_falseY,t.m_unitsXY=this.m_unitsXY,t.m_falseZ=this.m_falseZ,t.m_unitsZ=this.m_unitsZ,t.m_falseM=this.m_falseM,t.m_unitsM=this.m_unitsM,t.m_toleranceXY=this.m_toleranceXY,t.m_toleranceZ=this.m_toleranceZ,t.m_toleranceM=this.m_toleranceM,t.m_precision=this.m_precision,t}assign(t){return this.m_falseX=t.m_falseX,this.m_falseY=t.m_falseY,this.m_unitsXY=t.m_unitsXY,this.m_falseZ=t.m_falseZ,this.m_unitsZ=t.m_unitsZ,this.m_falseM=t.m_falseM,this.m_unitsM=t.m_unitsM,this.m_toleranceXY=t.m_toleranceXY,this.m_toleranceZ=t.m_toleranceZ,this.m_toleranceM=t.m_toleranceM,this.m_precision=t.m_precision,this}initialize2D(t,e){}getTolerance(t){switch(t){case 0:return this.m_toleranceXY;case 1:return this.m_toleranceZ;case 2:return this.m_toleranceM;default:return 0}}getResolution(t){if(this.m_precision===2)return 0;switch(t){case 0:return 1/this.m_unitsXY;case 1:return 1/this.m_unitsZ;case 2:return 1/this.m_unitsM;default:return 0}}getFalseX(){return this.m_falseX}getFalseY(){return this.m_falseY}getFalseZ(){return this.m_falseZ}getFalseM(){return this.m_falseM}getGridUnitsXY(){return this.m_unitsXY}getGridUnitsZ(){return this.m_unitsZ}getGridUnitsM(){return this.m_unitsM}getPrecision(){return this.m_precision}static getLimit32(){return 2147483645}static getLimit64(){return 9007199254740990n}static getLimitFloat(){return 0}getXYGridRange(){const t=new F;switch(this.m_precision){case 0:{const e=Me.getLimit32()/this.getGridUnitsXY();t.setCoords({xmin:this.getFalseX(),ymin:this.getFalseY(),xmax:this.getFalseX()+e,ymax:this.getFalseY()+e})}break;case 1:{const e=Number(Me.getLimit64())/this.getGridUnitsXY();t.setCoords({xmin:this.getFalseX(),ymin:this.getFalseY(),xmax:this.getFalseX()+e,ymax:this.getFalseY()+e})}break;case 2:t.setCoords({xmin:-Number.MAX_VALUE,ymin:-Number.MAX_VALUE,xmax:Number.MAX_VALUE,ymax:Number.MAX_VALUE});break;default:t.setEmpty(),$("")}return t}getZGridRange(){const t=new z;switch(this.m_precision){case 0:{const e=Me.getLimit32()/this.getGridUnitsZ();t.setCoords(this.getFalseZ(),this.getFalseZ()+e)}break;case 1:{const e=Number(Me.getLimit64())/this.getGridUnitsZ();t.setCoords(this.getFalseZ(),this.getFalseZ()+e)}break;case 2:t.setCoords(-Number.MAX_VALUE,Number.MAX_VALUE);break;default:t.setEmpty(),$("")}return t}getMGridRange(){const t=new z;switch(this.m_precision){case 0:{const e=Me.getLimit32()/this.getGridUnitsM();t.setCoords(this.getFalseM(),this.getFalseM()+e)}break;case 1:{const e=Number(Me.getLimit64())/this.getGridUnitsM();t.setCoords(this.getFalseM(),this.getFalseM()+e)}break;case 2:t.setCoords(-Number.MAX_VALUE,Number.MAX_VALUE);break;default:t.setEmpty(),$("")}return t}setTolerance(t,e){switch(e<0&&H("tol < 0"),Number.isFinite(e)||H("tol is not finite"),t){case 0:this.m_toleranceXY=e;break;case 1:this.m_toleranceZ=e;break;case 2:this.m_toleranceM=e;break;default:H("cannot set tolerance for this attribute")}}setGridParams(t,e,s){Number.isFinite(t)&&Number.isFinite(e)&&Number.isFinite(s)||H("grid params are not finite"),s<1&&H("grid units cannot be smaller than 1.0"),this.m_falseX=t,this.m_falseY=e,this.m_unitsXY=s}setZParams(t,e){Number.isFinite(t)&&Number.isFinite(e)||H("grid params are not finite"),e<1&&H("grid units cannot be smaller than 1.0"),this.m_falseZ=t,this.m_unitsZ=e}setMParams(t,e){Number.isFinite(t)&&Number.isFinite(e)||H("grid params are not finite"),e<1&&H("grid units cannot be smaller than 1.0"),this.m_falseM=t,this.m_unitsM=e}setPrecision(t){}equals(t){return this===t||ze(this.m_falseX,t.m_falseX)&&ze(this.m_falseY,t.m_falseY)&&this.equalsWithoutFalseXY(t)}snapPrecision(){if(this.m_precision===2)return;const t=(s,i,n,o)=>{if(!Number.isFinite(i)||!Number.isFinite(n))return n;if(n<1)return 1;if(!o)return n;const a=Number(s)/n;return Math.trunc((i+a-i)*n)>s&&(n=s/(i+a-i)),Math.max(1,n)},e=Number(this.m_precision===0?dm:bo);this.m_unitsXY=t(e,this.m_falseX,this.m_unitsXY,!0),this.m_unitsXY=t(e,this.m_falseY,this.m_unitsXY,!0),this.m_unitsZ=t(e,this.m_falseZ,this.m_unitsZ,!1),this.m_unitsM=t(e,this.m_falseM,this.m_unitsM,!1)}verifyPrecision(){if(this.m_precision===2)return!0;const t=(s,i,n,o)=>{if(n<1||!Number.isFinite(i)||!Number.isFinite(n))return!1;if(!o)return!0;const a=Number(s)/n;return!(BigInt((i+a-i)*n)>s)},e=this.m_precision===0?dm:bo;return!!t(e,this.m_falseX,this.m_unitsXY,!0)&&!!t(e,this.m_falseY,this.m_unitsXY,!0)&&!!t(e,this.m_falseZ,this.m_unitsZ,!1)&&!!t(e,this.m_falseM,this.m_unitsM,!1)}fixTolerance(){this.m_precision!==2&&(this.m_toleranceXY=Math.max(2/this.m_unitsXY,this.m_toleranceXY),this.m_toleranceZ=Math.max(2/this.m_unitsZ,this.m_toleranceZ),this.m_toleranceM=Math.max(2/this.m_unitsM,this.m_toleranceM),(Number.isNaN(this.m_falseX)||Number.isNaN(this.m_falseY))&&(this.m_falseX=this.m_falseY=Number.NaN))}equalsWithoutFalseXY(t){return this===t||this.m_unitsXY===t.m_unitsXY&&this.m_falseZ===t.m_falseZ&&this.m_unitsZ===t.m_unitsZ&&this.m_falseM===t.m_falseM&&this.m_unitsM===t.m_unitsM&&this.m_toleranceXY===t.m_toleranceXY&&this.m_toleranceZ===t.m_toleranceZ&&this.m_toleranceM===t.m_toleranceM&&this.m_precision===t.m_precision}setBestXyDomainFromEnvelope(t,e){}setBestZDomainFromZRange(t,e,s){}setBestMDomainFromMRange(t,e,s){}}function Aa(){return(!uo||xs()&&uo.getPECoordSys()===null)&&(uo=Ma(3857,0,null,!0)),uo}function gl(){return(!co||xs()&&co.getPECoordSys()===null)&&(co=Ma(102100,0,null,!0)),co}function qa(){return(!go||xs()&&go.getPECoordSys()===null)&&(go=Ma(4326,0,null,!0)),go}function _l(r){r.m_falseX=0,r.m_falseY=0,r.m_unitsXY=1,r.m_falseZ=0,r.m_unitsZ=1,r.m_falseM=0,r.m_unitsM=1,r.m_toleranceXY=100*jt(),r.m_toleranceZ=100*jt(),r.m_toleranceM=100*jt(),r.m_precision=2}function Fa(r,t,e,s){const i=t instanceof il;_l(r),r.m_precision=s,r.m_falseX=Number.NaN,r.m_falseY=Number.NaN;const n=1e-4,o=.001,a=i?t.m_csType:t.isPCS?2:1;if(a===1){const l=(s===0?5555555555555555e-22:1e-9)*(i?t.getOneDegreeGCSUnit():Math.PI/t.metersOrRadiansPerUnit/180);r.m_unitsXY=1/l}else if(a===2){const l=(s===0?o:n)*(i?t.getOneMeterPCSUnit():1/t.metersOrRadiansPerUnit);r.m_unitsXY=1/l}else H("unrecognized cs type");r.m_falseM=-1e5,r.m_unitsM=1/(s===0?o:n),r.m_unitsM=Math.max(1,r.m_unitsM),r.m_unitsXY=Math.max(1,r.m_unitsXY);let h=0,m=0;s!==0&&s!==1||(h=2/r.m_unitsXY,m=2/r.m_unitsM),r.m_toleranceXY=Math.max(h,i?t.getUnitsPerMillimeter():a===2?.001/t.metersOrRadiansPerUnit:.001/(t.semiMajor*t.metersOrRadiansPerUnit)),r.m_toleranceM=Math.max(o,m),Ad(r,e)}function Ad(r,t){if(r.m_falseZ=-1e5,t){const n=(r.m_precision===0?.001:1e-4)*t.getOneMeter();r.m_unitsZ=1/n}else r.m_unitsZ=1/(r.m_precision===0?.001:1e-4);r.m_unitsZ=Math.max(1,r.m_unitsZ);let i=0;r.m_precision!==0&&r.m_precision!==1||(i=2/r.m_unitsZ),r.m_toleranceZ=Math.max(t?t.getOneMeter()*.001:.001,i)}function qd(r,t,e,s){_l(r),r.m_precision=s;const i=s===0?dm:bo,n=1e-4,o=.001;let a=1,h=1,m=.001;t&&(h=t.getUnitToBaseFactor()),t&&t.getUnitType()===1?(a=400*Math.PI/180,m=8983152841195215e-24*Math.PI/180/h):(a=(s===0?o:n)*Number(i)*.5,m=o/h),a/=h,r.m_falseX=-a,r.m_falseY=-a,r.m_unitsXY=Number(i)/(2*a),r.m_falseM=-1e5,r.m_unitsM=1/(s===0?o:n),r.m_unitsM=Math.max(1,r.m_unitsM),r.snapPrecision();let l=0,u=0;r.m_precision!==0&&r.m_precision!==1||(u=2/r.m_unitsM,l=2/r.m_unitsXY),r.m_toleranceXY=Math.max(l,m),r.m_toleranceM=Math.max(o,u),Ad(r,e)}function Ma(r,t,e,s){if(!s&&t<=0){if(r===3857)return Aa();if(r===102100)return gl();if(r===4326)return qa()}const i=new ci;let n,o=null;return xs()?(n=OE(r),t>0?o=null:t=0,i.setHorzProj_(n),i.m_vertcs=o):(n=Ga(r),i.m_unit=n.isPCS?new hi(n.metersOrRadiansPerUnit):new wr(n.metersOrRadiansPerUnit)),Fa(i.m_precisionDescriptor,n,o,1),i.m_bDefaultDescriptor=!0,i.m_userWKID=r,i.calculateHashCode(),i.initDbgName(),i}function hn(r,t,e){return Hi((r-t)*e)/e+t}let Pi=null;const Fd=3552713678800501e-30;function lS(r,t,e){return r===t||Math.abs(r-t)<=e*(1+(Math.abs(r)+Math.abs(t))/2)}function bt(r,t){return lS(r,t,Fd)}function uS(r,t){return r===0||Math.abs(r)<=t}function cS(r){return uS(r,Fd)}let xe,oe,et,pe,fm,de,fn,Rc,Ze,qr,xm;function Rn(r){return{_this:r,get(){return this._this},reset(t){this._this=t},release(){const t=this._this;return this._this=null,t}}}let wi=null;function Ga(r){b(wi);const t=wi(r);return t.semiMajor=t.isPCS?Number.NaN:yS(r),t}function gS(r){wi=r,b(wi)}function _S(r){const t=r;oe=t.PeFactory,b(oe),xm=t.PeGCSExtent,b(xm),Ze=t.PeLineType,b(Ze),qr=t.PeMath,b(qr),xe=t.PeDouble,b(xe),et=t.PeDefs,b(et),pe=t.PeCSTransformations,b(pe),fm=t.PeGTTransformations,b(fm),de=t.PePCSInfo,b(de),fn=t.PeGTlistExtended,b(fn),oe.initialize(),Rc=t.PeGTlistExtendedEntry,b(Rc),et.PE_TYPE_ANGUNIT=512,et.PE_STR_AUTH_ALL=2,de.PE_POLE_LINE_STRAIGHT=2,de.PE_POLE_LINE_CURVED=3,et.PE_PARM_LAM0=2,et.PE_PARM_PHI0=6,et.PE_PRJ_AZIMUTHAL_EQUIDISTANT=43032,et.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA=43033,et.PE_PRJ_ALBERS=43007,et.PE_PRJ_CYLINDRICAL_EQAREA=43034,et.PE_TYPE_VERTCS=8,et.PE_LINETYPE_GEODESIC=0,et.PE_LINETYPE_LOXODROME=1,et.PE_LINETYPE_GREAT_ELLIPTIC=2,et.PE_LINETYPE_NORMAL_SECTION=3,fn.PE_GTLIST_OPTS_USABLE=1,wi=null}function dS(r,t,e,s){return t<=0?(e[0]=0,s[0]=0,!1):(e[0]=t,s[0]=t,!0)}function pS(r){return b(ll()),!!wi(r).isPCS||fS(r)}function fS(r){return oe&&Yt("pe has been loaded. no-pe methods should not be used at this point."),Pi||Md(),Pi.has(r)}const xS=/(?:ELLIPSOID|SPHEROID)\["(?:\w|[-()])+",(\d+\.\d+)/;function yS(r){if(oe&&Yt("pe has been loaded. no-pe methods should not be used at this point."),typeof r=="string"){const t=r.match(xS);t&&t.length===2||H("bad gcs wkt");const e=Number.parseFloat(t[1]);return Number.isFinite(e)||H("bad gcs wkt"),e}return Pi||Md(),Pi.has(r)||Yt("gcs wkid not found"),Pi.get(r)}function Md(){Pi=new Map;for(const r in Uo){const t=Number.parseFloat(r),e=Uo[r];if(Array.isArray(e))for(const s of e)Pi.set(s,t);else Pi.set(e,t)}X1()}function PS(r,t){const e=oe.geogtran(r);return e||_h(r),new Va(e,t)}function CS(r,t){const e=oe.fromString(et.PE_TYPE_GEOGTRAN,r);return e||Wc(r),new Va(e,t)}function Gd(r,t){return new Va(r,t)}const kc=qs(0),Lc=qs(1);let Va=class ym{constructor(t,e){if(t instanceof ym)return this.m_geogTranWrapper=t.m_geogTranWrapper,this.m_bInverted=e?!t.m_bInverted:t.m_bInverted,void(this.m_hashCode=le(this.m_geogTranWrapper.getHashCode(),this.m_bInverted?Lc:kc));this.m_geogTranWrapper=new MC(t),this.m_bInverted=e,this.m_hashCode=le(this.m_geogTranWrapper.getHashCode(),this.m_bInverted?Lc:kc)}getID(){return this.m_geogTranWrapper.getLatestId()}getLatestID(){return this.m_geogTranWrapper.getLatestId()}getText(){return this.m_geogTranWrapper.getText()}getTextExtended(t){if(!this.m_geogTranWrapper.getGeogtran())return"";if(t===-1)return this.m_geogTranWrapper.getGeogtran().toString();{const e=t===0?et.PE_STR_AUTH_TOP:et.PE_STR_AUTH_ALL;return this.m_geogTranWrapper.getGeogtran().toString(e)}}getText2(t=-1){let e=et.PE_STR_FMT_WKT2;return t!==-1&&(e|=t===0?et.PE_STR_AUTH_TOP:et.PE_STR_AUTH_ALL),this.m_geogTranWrapper.getGeogtran().toString(e)}getName(){return this.m_geogTranWrapper&&this.m_geogTranWrapper.getGeogtran()?this.m_geogTranWrapper.getGeogtran().getName():""}getInputSpatialReference(){return this.m_bInverted?this.m_geogTranWrapper.getOutputSr(!1):this.m_geogTranWrapper.getInputSr(!1)}getOutputSpatialReference(){return this.m_bInverted?this.m_geogTranWrapper.getInputSr(!1):this.m_geogTranWrapper.getOutputSr(!1)}getInverse(){return new ym(this,!0)}isInverted(){return this.m_bInverted}getHashCode(){return this.m_hashCode}GetPeGeogtran(){return this.m_geogTranWrapper.getGeogtran()}equals(t){const e=t;return e===this||this.m_bInverted===e.m_bInverted&&(this.GetPeGeogtran()===e.GetPeGeogtran()||this.getID()===e.getID()&&!(this.getID()===0&&!this.GetPeGeogtran().isEqual(e.GetPeGeogtran())))}referencesMissingData(){return!!this.m_geogTranWrapper&&!this.m_geogTranWrapper.isUsable()}getWrapper(){return this.m_geogTranWrapper}};function Vd(r,t,e,s,i){const n=r.getGCS(),o=t.getGCS(),a=n.getPECoordSys(),h=o.getPECoordSys();let m=null;if(!e.isEmpty()){const g=e.clone();if(!g.isEmpty()&&r.getCoordinateSystemType()===2){let _=new Ne({env2D:g});const d=Bi(r,n,null);_=new Rs().execute(_,d,null),_.queryEnvelope(g)}if(!g.isEmpty()){const _=a.getPrimem().getLongitude(),d=a.getUnit().getUnitFactor();m=new xm(g.xmin,g.ymin,g.xmax,g.ymax,_,d)}}let l=s;l>=Ie()&&(l=0);const u=[];let c=fn.PE_GTLIST_OPTS_COMMON;i||(c&=~fn.PE_GTLIST_OPTS_USABLE);for(let g=0;g<2;g++){u.length=0;const _=l,d=fn.getGTlist(a,h,2,c,m,_);let p=!1;if(d&&d.length>0)for(let f=0,x=d.length;f<x;f++){const E=Yd([d[f]]);if(b(E),i&&E.referencesMissingData())p=!0;else if(u.push(E),s>0&&u.length===s)break}if(!p)break;l===0||(l=0)}return m&&m.destroy(),u}function Yd(r){b(r!==null);const t=new dl,e=r[0].getSteps();if(e){const s=r[0].getEntries();for(let i=0;i<e;i++){const n=s[i].getDirection()!==0,o=Gd(s[i].getGeogtran(),n);t.add(o)}return t.create()}return null}let Xd=class{constructor(r,t,e,s){this.m_bReadOnly=!0,this.m_name="",this.m_fastTrack=-1,this.m_bNameIsSet=!1,this.m_transforms=r,t&&(this.m_name=t,this.m_bNameIsSet=!0),this.m_inputSr=e,this.m_outputSr=s}getType(){return 0}getName(){if(this.m_bNameIsSet)return this.m_name;if(this.m_transforms.length===0)return"";let r="";for(const t of this.m_transforms)r.length>0&&(r+=" + "),t.isInverted()&&(r+="~"),r+=t.getName();return r}count(){return this.m_transforms.length}createInverse(){return this.getInverse()}getHashCode(){let r=1973;for(let t=0;t<this.m_transforms.length;t++)r=le(r,this.m_transforms[t].getHashCode());return r}equals(r){return b(0),!1}referencesMissingData(){if(this.m_transforms.length===0)return!1;for(const r of this.m_transforms)if(r.referencesMissingData())return!0;return!1}isMatchingTransformation(r,t){return b(0),!1}validateTransformation(r,t){return b(0),!1}nameIsSet(){return b(0),!1}getInputSpatialReference(){return this.m_inputSr}getOutputSpatialReference(){return this.m_outputSr}getStep(r){return(r<0||r>this.count())&&ut(""),this.m_transforms[r]}getInverse(){const r=new dl;return r.addSteps(this,!0),r.setInputSpatialReference(this.m_outputSr),r.setOutputSpatialReference(this.m_inputSr),r.create()}transform(r,t,e){if(this.count()===0)return;let s=this.m_inputSr,i=this.m_outputSr;if(r&&(i=O(s,s=i)),this.m_transforms.length===0)return void rd(s,null,i,null,t,null,e);let n=this.m_fastTrack;if(n===1)return void Np(r,this.m_transforms,u=>{RC(u.getWrapper(),r!==u.isInverted(),t,null,e)});const o=ks();n===-1&&o.initFromGcsAndVcs(s,null);const a=ks();let h=r?this.m_transforms.length-1:0;const m=r?-1:1;for(let u=0,c=this.m_transforms.length;u<c;u++,h+=m){if(u===0){const _=this.m_transforms[h];GC(s.getPECoordSys(),null,_.getWrapper(),r!==_.isInverted(),t,null,e,a),n===-1&&(o.equals(a)||(n=0)),o.assign(a)}else{const _=this.m_transforms[h-m],d=this.m_transforms[h];YC(o,_.getWrapper(),r!==_.isInverted(),d.getWrapper(),r!==d.isInverted(),t,null,e,a),n===-1&&(o.equals(a)||(n=0)),o.assign(a)}const g=this.m_transforms[h];XC(o,g.getWrapper(),r!==g.isInverted(),t,null,e,a),o.assign(a)}const l=this.m_transforms[h-m];VC(o,l.getWrapper(),r!==l.isInverted(),i,null,t,null,e),n===-1&&(a.initFromGcsAndVcs(i,null),o.equals(a)||(n=0)),this.m_fastTrack=n===0?0:1}};class dl{constructor(){this.m_transforms=[],this.m_inputGCS=null,this.m_outputGCS=null,this.m_name="",this.m_bNameIsSet=!1}getInputSpatialReference(){return this.m_inputGCS!==null?this.m_inputGCS:this.count()>0?this.m_transforms[0].getInputSpatialReference():null}setInputSpatialReference(t){this.m_inputGCS=t?t.getGCS():null}getOutputSpatialReference(){return this.m_outputGCS!==null?this.m_outputGCS:this.count()>0?this.m_transforms.at(-1).getOutputSpatialReference():null}setOutputSpatialReference(t){this.m_outputGCS=t?t.getGCS():null}getName(){if(this.m_bNameIsSet)return this.m_name;if(this.m_transforms.length===0)return"";let t="";for(const e of this.m_transforms)t.length>0&&(t+=" + "),e.isInverted()&&(t+="~"),t+=e.getName();return t}count(){return this.m_transforms.length}getStep(t){return(t<0||t>this.count())&&ut(""),this.m_transforms[t]}setStep(t,e){b(0)}add(t){this.m_transforms.push(t)}addSteps(t,e){if(e)for(let s=t.count()-1;s>=0;--s)this.add(t.getStep(s).getInverse());else for(let s=0;s<t.count();++s)this.add(t.getStep(s))}clear(){this.m_transforms=[],this.m_name="",this.m_bNameIsSet=!1,this.m_inputGCS=null,this.m_outputGCS=null}remove(t){b(0)}create(){const t=this.getInputSpatialReference(),e=this.getOutputSpatialReference(),s=new Xd(this.m_transforms,this.m_bNameIsSet?this.m_name:null,t,e);return s.m_bReadOnly=!0,this.clear(),s}}const ES=Object.freeze(Object.defineProperty({__proto__:null,SpatialReference:ci,SpatialReferencePrecisionDescriptor:Me,create:oa,createFromWKT:ul,createImplFromPe:Ar,createLocal:vd,createWithNewPrecision:cl,createWithNewVCS:pm,getGCS:Io,getTempName:Td,hasNoPe:ll,hasPe:xs,injectNoPe:Sd,injectPe:aS,isInitialized:Na,isTempName:Nd,isValidWkid:Id,isValidWkt:wd,makeSpheroidData:sn,snapGeometry:bd,webMercator:Aa,webMercator102100:gl,wgs84:qa},Symbol.toStringTag,{value:"Module"})),SS=Object.freeze(Object.defineProperty({__proto__:null,OperatorProject:Rs},Symbol.toStringTag,{value:"Module"})),vS=Object.freeze(Object.defineProperty({__proto__:null,CompositeGeographicTransformation:Xd,CompositeGeographicTransformationEditor:dl,createImpl:Yd,queryGtListImpl:Vd},Symbol.toStringTag,{value:"Module"})),bS=Object.freeze(Object.defineProperty({__proto__:null,GeographicTransformation:Va,create:PS,createFromPe:Gd,createFromWKT:CS},Symbol.toStringTag,{value:"Module"})),IS=Object.freeze(Object.defineProperty({__proto__:null,ProjectionTransformation:al,create:BE,createEx:Bi,createFromAoi:yd,createImplEx:nl,makeExtendedParams:rl,makeExtendedParamsInternal:ol,queryTransformationList:Pd},Symbol.toStringTag,{value:"Module"})),a2=Object.freeze(Object.defineProperty({__proto__:null,$:hC,A:Rs,B:Bi,C:ts,D:wa,E:Hm,F:vo,G:Tr,H:Xn,I:$m,get J(){return qr},get K(){return pe},L:rm,M:Eo,N:pE,O:Us,get P(){return xe},Q:Z_,R:vd,S:R1,T:je,U:xd,V:sd,W:Nn,X:bt,Y:pC,Z:Q_,_:K_,a:ul,a0:om,a1:id,a2:m_,a3:W1,a4:jn,a5:Zm,a6:ix,a7:em,a8:dE,get a9(){return et},aA:wd,aB:Id,aC:qC,aD:Me,aE:cl,aF:Ir,aG:ES,aH:SS,aI:vS,aJ:bS,aK:IS,aa:ol,ab:rl,ac:nl,ad:hm,ae:Ji,af:fs,ag:P_,ah:od,ai:Km,aj:fP,ak:MP,al:TP,am:xs,an:ii,ao:bd,ap:SP,aq:Ns,ar:Ms,as:BP,at:gs,au:wt,av:kr,aw:Td,get ax(){return oe},ay:_E,az:ex,b:ad,c:oa,d:Jm,e:Qm,f:Ia,g:Ki,h:Ye,i:Sd,j:ta,k:O_,l:Fs,m:Je,n:_s,o:DP,p:Qo,q:B_,r:ti,s:$_,t:Nx,u:hP,v:sn,w:ae,x:Ta,y:Dn,get z(){return Ze}},Symbol.toStringTag,{value:"Module"}));export{bt as $,Xn as A,Oe as B,xe as C,Ze as D,Zt as E,ss as F,xd as G,sn as H,wn as I,Ia as J,Gs as K,Qm as L,Qo as M,Sm as N,oa as O,Dt as P,sd as Q,Bi as R,KS as S,Eo as T,Lt as U,qr as V,vd as W,mt as X,ul as Y,pE as Z,Nn as _,Us as a,pC as a0,Q_ as a1,K_ as a2,hC as a3,om as a4,Cp as a5,GS as a6,id as a7,Sd as a8,Ir as a9,oe as aA,_E as aB,ex as aC,Td as aD,et as aE,Hm as aF,Cn as aG,fs as aH,P_ as aI,od as aJ,Km as aK,MP as aL,Ur as aM,Fs as aN,Je as aO,_s as aP,je as aQ,DP as aR,ts as aS,Ap as aT,fP as aU,a2 as aV,Gi as aa,FS as ab,wd as ac,Id as ad,qC as ae,it as af,Qc as ag,Me as ah,be as ai,_i as aj,MS as ak,Zc as al,ws as am,t_ as an,yo as ao,E1 as ap,d1 as aq,cl as ar,Ps as as,Ve as at,Rm as au,v as av,Ye as aw,Di as ax,Ta as ay,Dn as az,Pt as b,Ki as c,ae as d,st as e,Lp as f,Fm as g,ta as h,O_ as i,$_ as j,ti as k,Jm as l,Fi as m,ad as n,rm as o,ht as p,Rs as q,Ne as r,re as s,Z_ as t,ct as u,QS as v,pe as w,R1 as x,ZS as y,l1 as z};
