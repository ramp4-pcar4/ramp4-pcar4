import{cR as v,s as f,i as Y,hL as V,hM as X,hN as Z,hO as $,f as H}from"./main-6eEsl9OJ.js";import{e as C}from"./VertexAttribute-BfkzOMLV.js";function N(e){return Array.isArray(e)?e.length<v?e:new Uint8Array(e):e.length<v?Array.from(e):e}function R(e){return Array.isArray(e)?e.length<v?e:new Uint16Array(e):e.length<v?Array.from(e):e}const d=!0,m={identifierOffset:0,identifierLength:10,versionOffset:10,checksumOffset:12,byteCount:16};function B(e,t,r){return{identifier:String.fromCharCode.apply(null,new Uint8Array(e,r+m.identifierOffset,m.identifierLength)),version:t.getUint16(r+m.versionOffset,d),checksum:t.getUint32(r+m.checksumOffset,d)}}const y={sizeLo:0,sizeHi:4,minX:8,minY:16,minZ:24,maxX:32,maxY:40,maxZ:48,errorX:56,errorY:64,errorZ:72,count:80,reserved:84,byteCount:88};function j(e,t){return{sizeLo:e.getUint32(t+y.sizeLo,d),sizeHi:e.getUint32(t+y.sizeHi,d),minX:e.getFloat64(t+y.minX,d),minY:e.getFloat64(t+y.minY,d),minZ:e.getFloat64(t+y.minZ,d),maxX:e.getFloat64(t+y.maxX,d),maxY:e.getFloat64(t+y.maxY,d),maxZ:e.getFloat64(t+y.maxZ,d),errorX:e.getFloat64(t+y.errorX,d),errorY:e.getFloat64(t+y.errorY,d),errorZ:e.getFloat64(t+y.errorZ,d),count:e.getUint32(t+y.count,d),reserved:e.getUint32(t+y.reserved,d)}}function ie(e){const t=new DataView(e,0);let r=0;const{identifier:c,version:o}=B(e,t,r);if(r+=m.byteCount,c!=="LEPCC     ")throw new f("lepcc-decode-error","Bad identifier");if(o>1)throw new f("lepcc-decode-error","Unknown version");const n=j(t,r);if(r+=y.byteCount,n.sizeHi*2**32+n.sizeLo!==e.byteLength)throw new f("lepcc-decode-error","Bad size");const u=new Float64Array(3*n.count),a=[],i=[],s=[],l=[];if(r=I(e,r,a),r=I(e,r,i),r=I(e,r,s),r=I(e,r,l),r!==e.byteLength)throw new f("lepcc-decode-error","Bad length");let g=0,w=0;for(let h=0;h<a.length;h++){w+=a[h];let A=0;for(let U=0;U<i[h];U++){A+=s[g];const k=l[g];u[3*g]=Math.min(n.maxX,n.minX+2*n.errorX*A),u[3*g+1]=Math.min(n.maxY,n.minY+2*n.errorY*w),u[3*g+2]=Math.min(n.maxZ,n.minZ+2*n.errorZ*k),g++}}return{errorX:n.errorX,errorY:n.errorY,errorZ:n.errorZ,result:u}}function I(e,t,r){const c=[];t=L(e,t,c);const o=[];for(let n=0;n<c.length;n++){o.length=0,t=L(e,t,o);for(let u=0;u<o.length;u++)r.push(o[u]+c[n])}return t}function L(e,t,r){const c=new DataView(e,t),o=c.getUint8(0),n=31&o,u=!!(32&o),a=(192&o)>>6;let i=0;if(a===0)i=c.getUint32(1,d),t+=5;else if(a===1)i=c.getUint16(1,d),t+=3;else{if(a!==2)throw new f("lepcc-decode-error","Bad count type");i=c.getUint8(1),t+=2}if(u)throw new f("lepcc-decode-error","LUT not implemented");const s=Math.ceil(i*n/8),l=new Uint8Array(e,t,s);let g=0,w=0,h=0;const A=-1>>>32-n;for(let U=0;U<i;U++){for(;w<n;)g|=l[h]<<w,w+=8,h+=1;r[U]=g&A,g>>>=n,w-=n,w+n>32&&(g|=l[h-1]>>8-w)}return t+h}const b={sizeLo:0,sizeHi:4,count:8,colorMapCount:12,lookupMethod:14,compressionMethod:15,byteCount:16};function _(e,t){return{sizeLo:e.getUint32(t+b.sizeLo,d),sizeHi:e.getUint32(t+b.sizeHi,d),count:e.getUint32(t+b.count,d),colorMapCount:e.getUint16(t+b.colorMapCount,d),lookupMethod:e.getUint8(t+b.lookupMethod),compressionMethod:e.getUint8(t+b.compressionMethod)}}function T(e){const t=new DataView(e,0);let r=0;const{identifier:c,version:o}=B(e,t,r);if(r+=m.byteCount,c!=="ClusterRGB")throw new f("lepcc-decode-error","Bad identifier");if(o>1)throw new f("lepcc-decode-error","Unknown version");const n=_(t,r);if(r+=b.byteCount,n.sizeHi*2**32+n.sizeLo!==e.byteLength)throw new f("lepcc-decode-error","Bad size");if((n.lookupMethod===2||n.lookupMethod===1)&&n.compressionMethod===0){if(3*n.colorMapCount+n.count+r!==e.byteLength||n.colorMapCount>256)throw new f("lepcc-decode-error","Bad count");const u=new Uint8Array(e,r,3*n.colorMapCount),a=new Uint8Array(e,r+3*n.colorMapCount,n.count),i=new Uint8Array(3*n.count);for(let s=0;s<n.count;s++){const l=a[s];i[3*s]=u[3*l],i[3*s+1]=u[3*l+1],i[3*s+2]=u[3*l+2]}return i}if(n.lookupMethod===0&&n.compressionMethod===0){if(3*n.count+r!==e.byteLength||n.colorMapCount!==0)throw new f("lepcc-decode-error","Bad count");return new Uint8Array(e,r).slice()}if(n.lookupMethod<=2&&n.compressionMethod===1){if(r+3!==e.byteLength||n.colorMapCount!==1)throw new f("lepcc-decode-error","Bad count");const u=t.getUint8(r),a=t.getUint8(r+1),i=t.getUint8(r+2),s=new Uint8Array(3*n.count);for(let l=0;l<n.count;l++)s[3*l]=u,s[3*l+1]=a,s[3*l+2]=i;return s}throw new f("lepcc-decode-error","Bad method "+n.lookupMethod+","+n.compressionMethod)}const p={sizeLo:0,sizeHi:4,count:8,scaleFactor:12,bitsPerPoint:14,reserved:15,byteCount:16};function G(e,t){return{sizeLo:e.getUint32(t+p.sizeLo,d),sizeHi:e.getUint32(t+p.sizeHi,d),count:e.getUint32(t+p.count,d),scaleFactor:e.getUint16(t+p.scaleFactor,d),bitsPerPoint:e.getUint8(t+p.bitsPerPoint),reserved:e.getUint8(t+p.reserved)}}function E(e){const t=new DataView(e,0);let r=0;const{identifier:c,version:o}=B(e,t,r);if(r+=m.byteCount,c!=="Intensity ")throw new f("lepcc-decode-error","Bad identifier");if(o>1)throw new f("lepcc-decode-error","Unknown version");const n=G(t,r);if(r+=p.byteCount,n.sizeHi*2**32+n.sizeLo!==e.byteLength)throw new f("lepcc-decode-error","Bad size");const u=new Uint16Array(n.count);if(n.bitsPerPoint===8){if(n.count+r!==e.byteLength)throw new f("lepcc-decode-error","Bad size");const a=new Uint8Array(e,r,n.count);for(let i=0;i<n.count;i++)u[i]=a[i]*n.scaleFactor}else if(n.bitsPerPoint===16){if(2*n.count+r!==e.byteLength)throw new f("lepcc-decode-error","Bad size");const a=new Uint16Array(e,r,n.count);for(let i=0;i<n.count;i++)u[i]=a[i]*n.scaleFactor}else{const a=[];if(L(e,r,a)!==e.byteLength)throw new f("lepcc-decode-error","Bad size");for(let i=0;i<n.count;i++)u[i]=a[i]*n.scaleFactor}return u}const z=()=>Y.getLogger("esri.views.3d.layers.i3s.I3SBinaryReader");function W(e,t,r){let c="",o=0;for(;o<r;){const n=e[t+o];if(n<128)c+=String.fromCharCode(n),o++;else if(n>=192&&n<224){if(o+1>=r)throw new f("utf8-decode-error","UTF-8 Decode failed. Two byte character was truncated.");const u=(31&n)<<6|63&e[t+o+1];c+=String.fromCharCode(u),o+=2}else if(n>=224&&n<240){if(o+2>=r)throw new f("utf8-decode-error","UTF-8 Decode failed. Multi byte character was truncated.");const u=(15&n)<<12|(63&e[t+o+1])<<6|63&e[t+o+2];c+=String.fromCharCode(u),o+=3}else{if(!(n>=240&&n<248))throw new f("utf8-decode-error","UTF-8 Decode failed. Invalid multi byte sequence.");{if(o+3>=r)throw new f("utf8-decode-error","UTF-8 Decode failed. Multi byte character was truncated.");const u=(7&n)<<18|(63&e[t+o+1])<<12|(63&e[t+o+2])<<6|63&e[t+o+3];if(u>=65536){const a=55296+(u-65536>>10),i=56320+(1023&u);c+=String.fromCharCode(a,i)}else c+=String.fromCharCode(u);o+=4}}}return c}function x(e,t){const r={byteOffset:0,byteCount:0,fields:Object.create(null)};let c=0;for(let o=0;o<t.length;o++){const n=t[o],u=n.valueType||n.type,a=ne[u];r.fields[n.property]=a(e,c),c+=O[u].BYTES_PER_ELEMENT}return r.byteCount=c,r}function q(e,t,r){return P(e,t,r).map(c=>{const o=c?Date.parse(c):null;return o==null||Number.isNaN(o)?null:o})}function P(e,t,r){const c=[];let o,n,u=0;for(n=0;n<e;n+=1){if(o=t[n],o>0){if(c.push(W(r,u,o-1)),r[u+o-1]!==0)throw new f("string-array-error","Invalid string array: missing null termination.")}else c.push(null);u+=o}return c}function F(e,t){return new O[t.valueType](e,t.byteOffset,t.count*t.valuesPerElement)}function J(e,t){const r=F(e,t);if(r.length>=v)return r;const c=new Array;return r.forEach((o,n)=>c.push(K(r,n))),c}function K(e,t){if(!e)return null;const r=e[t];return V(e)?r===X?null:r:Z(e)?r===$?null:r:r!=r?null:r}function Q(e,t){return new Uint8Array(e,t.byteOffset,t.byteCount)}function ee(e,t,r){const c=t.header!=null?x(e,t.header):{byteOffset:0,byteCount:0,fields:{count:r}},o={header:c,byteOffset:c.byteCount,byteCount:0,entries:Object.create(null)};let n=c.byteCount;for(let u=0;u<t.ordering.length;u++){const a=t.ordering[u],i=H(t[a]);if(i.count=c.fields.count??0,i.valueType==="String"){if(i.byteOffset=n,i.byteCount=c.fields[a+"ByteCount"],i.encoding!=="UTF-8")throw new f("unsupported-encoding","Unsupported String encoding.",{encoding:i.encoding});if(i.timeEncoding&&i.timeEncoding!=="ECMA_ISO8601")throw new f("unsupported-time-encoding","Unsupported time encoding.",{timeEncoding:i.timeEncoding})}else{if(!S(i.valueType))throw new f("unsupported-value-type","Unsupported binary valueType",{valueType:i.valueType});{const s=M(i.valueType);n+=n%s!==0?s-n%s:0,i.byteOffset=n,i.byteCount=s*i.valuesPerElement*i.count}}n+=i.byteCount??0,o.entries[a]=i}return o.byteCount=n-o.byteOffset,o}function D(e,t,r){if(t!==e&&z().error(`Invalid ${r} buffer size
 expected: ${e}, actual: ${t})`),t<e)throw new f("buffer-too-small","Binary buffer is too small",{expectedSize:e,actualSize:t})}function ce(e,t){const r=x(e,t&&t.header);let c=r.byteCount;const o={isDraco:!1,header:r,byteOffset:r.byteCount,byteCount:0,vertexAttributes:{}},n=r.fields,u=n.vertexCount!=null?n.vertexCount:n.count;for(const s of t.ordering){if(!t.vertexAttributes[s])continue;const l={...t.vertexAttributes[s],byteOffset:c,count:u},g=te[s]||"_"+s;o.vertexAttributes[g]=l,c+=M(l.valueType)*l.valuesPerElement*u}const a=n.faceCount;if(t.faces&&a){o.faces={};for(const s of t.ordering){if(!t.faces[s])continue;const l={...t.faces[s],byteOffset:c,count:a};o.faces[s]=l,c+=M(l.valueType)*l.valuesPerElement*a}}const i=n.featureCount;if(t.featureAttributes&&t.featureAttributeOrder&&i){o.featureAttributes={};for(const s of t.featureAttributeOrder){if(!t.featureAttributes[s])continue;const l={...t.featureAttributes[s],byteOffset:c,count:i};o.featureAttributes[s]=l,c+=(l.valueType==="UInt64"?8:M(l.valueType))*l.valuesPerElement*i}}return D(c,e.byteLength,"geometry"),o.byteCount=c-o.byteOffset,o}const te={position:C.POSITION,normal:C.NORMAL,color:C.COLOR,uv0:C.UV0,region:C.UVREGION};function ue(e,t,r,c=!1){if(e.encoding==="lepcc-rgb")return c?T(t):N(T(t));if(e.encoding==="lepcc-intensity")return c?E(t):R(E(t));if(e.encoding!=null&&e.encoding!=="")throw new f("unknown-attribute-storage-info-encoding","Unknown Attribute Storage Info Encoding");e["attributeByteCounts "]&&!e.attributeByteCounts&&(z().warn("Warning: Trailing space in 'attributeByteCounts '."),e.attributeByteCounts=e["attributeByteCounts "]),e.ordering[0]==="ObjectIds"&&e.hasOwnProperty("objectIds")&&(z().warn("Warning: Case error in objectIds"),e.ordering[0]="objectIds");const o=ee(t,e,r);D(o.byteOffset+o.byteCount,t.byteLength,"attribute");const n=o.entries.attributeValues||o.entries.objectIds;if(n){if(n.valueType==="String"){const u=o.entries.attributeByteCounts,a=F(t,u),i=Q(t,n);return n.timeEncoding?q(u.count,a,i):P(u.count,a,i)}return c?F(t,n):J(t,n)}throw new f("bad-attribute-storage-info","Bad attributeStorageInfo specification.")}const O={Float32:Float32Array,Float64:Float64Array,UInt8:Uint8Array,Int8:Int8Array,UInt16:Uint16Array,Int16:Int16Array,UInt32:Uint32Array,Int32:Int32Array},ne={Float32:(e,t)=>new DataView(e,0).getFloat32(t,!0),Float64:(e,t)=>new DataView(e,0).getFloat64(t,!0),UInt8:(e,t)=>new DataView(e,0).getUint8(t),Int8:(e,t)=>new DataView(e,0).getInt8(t),UInt16:(e,t)=>new DataView(e,0).getUint16(t,!0),Int16:(e,t)=>new DataView(e,0).getInt16(t,!0),UInt32:(e,t)=>new DataView(e,0).getUint32(t,!0),Int32:(e,t)=>new DataView(e,0).getInt32(t,!0)};function S(e){return O.hasOwnProperty(e)}function M(e){return S(e)?O[e].BYTES_PER_ELEMENT:0}export{K as C,ue as D,ce as U,ie as c,F as w};
