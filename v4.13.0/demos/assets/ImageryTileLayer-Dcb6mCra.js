const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./imageryUtils-I21bTHSP.js","./utils-CEAqrH5t.js","./main-6eEsl9OJ.js","./preload-helper-B76NpbEU.js","./main-B_8sIZOq.css","./originUtils-CPX8CCAY.js","./multiOriginJSONSupportUtils-C0wm8_Yw.js","./PortalItem-8NBch2N-.js","./jsonContext-CcSVT7S_.js","./portalItemUtils-DES5WVek.js","./projectionUtils-BoGsVCso.js","./saveUtils-CS2Yf8a3.js","./datasetUtils-CTEfKVKj.js","./Field-CzUupKXc.js","./fieldType-B4FIlvI-.js"])))=>i.map(i=>d[i]);
import{_ as De}from"./preload-helper-B76NpbEU.js";import{I as D,c1 as H,bj as Ae,eA as Be,q as T,v as O,x as Y,h as Ce,s as C,br as ve,jU as Le,aq as Je,u as ze,aH as Ue,a$ as je,c4 as V,i as de,bp as He,b_ as Ge,o as We,am as qe,ad as Ve,bA as Ye}from"./main-6eEsl9OJ.js";import{S as Xe}from"./MultiOriginJSONSupport-Co5qTMH7.js";import{h as Ke}from"./Layer-DzZVuRQg.js";import{l as Ze}from"./ArcGISService-B_5_Lp9I.js";import{p as Qe}from"./BlendLayer-Ck8n336O.js";import{e as et}from"./CustomParametersMixin-DtqTEY_r.js";import{$ as Z,i as ce,t as J,n as Fe,e as B,o as q,u as se,X as tt,m as st}from"./xmlUtilities-Bxjr2FJ2.js";import{b as it,d as rt}from"./OperationalLayer-DPy11VYP.js";import{j as at}from"./PortalLayer-CNZn_9Ud.js";import{d as nt,N as ke}from"./RasterJobHandlerMixin-BmcXvPGs.js";import{c as ot,f as lt,o as ut}from"./RasterPresetRendererMixin-BpynIXQw.js";import{f as ct}from"./RefreshableLayer-WBFfTNo4.js";import{t as ft}from"./ScaleRangeLayer-BjLqqFXw.js";import{c as pt}from"./TemporalLayer-CkjYEXTj.js";import{m as Se}from"./Field-CzUupKXc.js";import{p as ht,N as mt,o as dt,c as gt,e as yt,j as wt,$ as xt,b as It,k as bt,l as vt,r as St,t as Tt}from"./datasetUtils-CTEfKVKj.js";import{c as ae,R as Rt,I as _t,B as Ot}from"./dataUtils-CHnwz3lm.js";import{i as Ct}from"./pixelRangeUtils-BvOub3JO.js";import{m as le,p as Ft,h as Me,g as ye,P as kt,l as we,r as Mt,b as Te,W as Pt,C as $t,G as Nt,e as Re,H as Et,t as Dt,N as _e,k as At,U as Bt}from"./RasterSymbolizer-DhOHpdT9.js";import{g as Pe}from"./FeatureSet-Brpa8p2L.js";import{m as xe,n as Lt}from"./PolynomialTransform-BIrwjNWf.js";import{j as ne}from"./TileInfo-CVYxyTVq.js";import{T as Jt}from"./TilemapCache-bJMEnJAM.js";import{w as zt,T as Ut}from"./rasterFunctionHelper-Bra6T0gy.js";import{p as jt}from"./popupUtils-BUD8sQLV.js";import{A as ie}from"./interfaces-CL2NbQte.js";import"./TimeExtent-DG27ZQvz.js";import"./layerContainerType-C5CzMsLd.js";import"./jsonUtils-DIh9yTg7.js";import"./parser-C27q64z5.js";import"./mat4f32-Djp3mnm5.js";import"./mat4-DL3nuHcq.js";import"./common-DQOJ18NT.js";import"./QueueProcessor-DVTsDrMX.js";import"./Queue-DXtZaugk.js";import"./ReactiveMap-DhgVMKBI.js";import"./RawBlockCache-BW4FRLIX.js";import"./rasterProjectionHelper-BQzX2t6v.js";import"./projectionUtils-BoGsVCso.js";import"./clipUtils-BNc4qJ2F.js";import"./ElevationInfo-Dh54MbB6.js";import"./lengthUtils-DL53yBUT.js";import"./asyncUtils-SHsCTXd3.js";import"./PortalItem-8NBch2N-.js";import"./portalItemUtils-DES5WVek.js";import"./ClassBreaksRenderer-CFWq_Bnc.js";import"./commonProperties-ClpAoODy.js";import"./colorRamps-CKB7alIQ.js";import"./ColorStop-i4pxY5LE.js";import"./visualVariableUtils-Q9XaDxnO.js";import"./RendererLegendOptions-BVVQbSEI.js";import"./UniqueValueRenderer-C4s1PHAc.js";import"./diffUtils-BBoLSBHW.js";import"./styleUtils-DkahzbXB.js";import"./workers-m_rvw_QY.js";import"./intl-Dk1N7wZP.js";import"./normalizeUtils-DQMkRVRF.js";import"./normalizeUtilsCommon-BOEKY1VU.js";import"./utils-DSziZ_FA.js";import"./utils-B8Gjy-VD.js";import"./utils-8sNkJo3w.js";import"./cimSymbolUtils-B04pXcN-.js";import"./utils-BV7DBUkI.js";import"./defaultCIMValues-CQAn2izL.js";import"./enums-_AFKM9Yk.js";import"./LRUCache-BB1cebTv.js";import"./MemCache-BSBM3Sy1.js";import"./ClassBreaksDefinition-DhnWoBKB.js";import"./TimeInfo-CmpDscoM.js";import"./timeZoneUtils-DmTpvLBr.js";import"./fieldType-B4FIlvI-.js";import"./_commonjsHelpers-DCkdB7M8.js";import"./colorUtils-D1om_hYv.js";import"./vec42-CKs01hkn.js";import"./vec4f64-DPb6J-GU.js";import"./TileKey-DZd6gJy7.js";import"./ByteSizeUnit-BsxeN7wM.js";import"./memoryEstimations-5hBnZCeh.js";function $e(i){return["x","e","east","long","longitude"].includes(i.toLowerCase())}function Ne(i){return["y","n","west","lat","latitude"].includes(i.toLowerCase())}function Ht(i){const{axes:e}=i.domain,t=Object.keys(e),s=[],r=[];let a=-1,n=-1,c=[];for(let w=0;w<t.length;w++){const F=t[w];$e(F)?a=w:Ne(F)&&(n=w);const S=e[F],x=[];if("values"in S){S.values.forEach(g=>x.push(typeof g=="string"?new Date(g).getTime():g));const b=x[1]-x[0];s.push([x[0]-.5*b,x[x.length-1]+.5*b]),r.push(b)}else{const{start:b,stop:g,num:v}=S,R=(g-b)/(v-1);s.push([b-.5*R,g+.5*R]),r.push(R);for(let k=0;k<v;k++)x.push(b+R*k)}c.push({name:F,values:x,extent:[x[0],x[x.length-1]]})}a>-1&&n===-1?n=a===0?1:0:n>-1&&a===-1?a=n===0?1:0:n===-1&&a===-1&&(a=0,n=1),c=c.filter((w,F)=>!(F===a||F===n));const{referencing:l}=i.domain,o=l.find(w=>w.coordinates.includes(t[a])).system.id,u=o?.slice(o.lastIndexOf("/")+1),p=u==null||u==="CRS84"?4326:Number(u),f=new D({wkid:p}),[h,I]=s[a],[y,m]=s[n],d=new H({xmin:h,xmax:I,ymin:y,ymax:m,spatialReference:f});return{width:Math.round(d.width/r[a]),height:Math.round(d.height/r[n]),extent:d,dimensions:c}}function fe(i){const e=Be()?.language;return e?i[e]??Object.values(i)[0]:Object.values(i)[0]}function pe(){return Math.round(255*Math.random())}function Gt(i){const e={},{parameters:t}=i;if(!t)return e;for(const[s,r]of Object.entries(t)){const{type:a,description:n,unit:c,categoryEncoding:l,observedProperty:o}=r;if(a==="Parameter"&&(e[s]={},n&&(e[s].description=fe(n)),c&&(e[s].unit=c.label?fe(c.label):null,e[s].symbol=c.symbol?.value),l)){const u=Object.entries(l).map((h,I)=>({OID:I,Value:Number(h[1]),ClassName:h[0].slice(h[0].lastIndexOf("/")+1),Count:1}));let p=!1;o?.categories?.length&&(o.categories.forEach(h=>{if(!h.id)return;const I=h.id.slice(h.id.lastIndexOf("/")+1),y=u.find(d=>d.ClassName===I);if(!y)return;const m=h.label?fe(h.label):null;if(y.Label=m,h.preferredColor){const d=Ae.fromHex(h.preferredColor);d&&(p=!0,y.Red=d.r,y.Green=d.g,y.Blue=d.b)}}),p&&u.forEach(h=>{h.Red==null&&(h.Red=pe(),h.Green=pe(),h.Blue=pe())}));const f={objectIdFieldName:"",fields:[{name:"OID",type:"esriFieldTypeOID",alias:"OID",domain:null},{name:"Value",type:"esriFieldTypeInteger",alias:"Value",domain:null},{name:"Count",type:"esriFieldTypeDouble",alias:"Count",domain:null},{name:"ClassName",type:"esriFieldTypeString",alias:"ClassName",domain:null,length:50},{name:"Label",type:"esriFieldTypeString",alias:"Label",domain:null,length:50}],features:u.map(h=>({attributes:h}))};p&&f.fields.push({name:"Red",type:"esriFieldTypeInteger",alias:"Red",domain:null},{name:"Green",type:"esriFieldTypeInteger",alias:"Green",domain:null},{name:"Blue",type:"esriFieldTypeInteger",alias:"Blue",domain:null}),e[s].attributeTable=f}}return e}function Wt(i){let e=Number.MAX_VALUE,t=-Number.MAX_VALUE;for(let s=0;s<i.length;s++){const r=i[s];r!=null&&(r<e&&(e=r),r>t&&(t=r))}return Ct(e,t)}function qt(i,e,t){const s=i.map((l,o)=>({name:l,count:e[o]})).sort((l,o)=>l.name>o.name?-1:1),r=(a=1,l=>a*=l.count);var a;const n=[...s.slice(1),{name:"",count:1}].reverse().map(r).reverse();let c=0;for(let l=i.length-1;l>=0;l--)c+=n[s.findIndex(({name:o})=>o===i[l])]*(t%e[l]),t=Math.floor(t/e[l]);return c}function Vt(i){const{width:e,height:t,extent:s,dimensions:r}=Ht(i),{ranges:a}=i,n=Object.keys(a).sort((f,h)=>f<h?-1:1),c=[];for(let f=0;f<n.length;f++){const h=n[f];r?.length&&c.push({name:h,dimensions:r})}const l=Gt(i);c.forEach(f=>l[f.name]&&Object.assign(f,l[f.name]));const o=c.length?{variables:c}:void 0,u=[];for(let f=0;f<n.length;f++){const h=n[f],{values:I,dataType:y,axisNames:m,shape:d}=a[h],w=d.length>2?f*d.slice(0,-2).reduce((v,R)=>v*R):0,F=m.slice(0,-2),S=d.slice(0,-2),x=y==="float"?"f32":Wt(I),b=e*t,g=I.length/b;for(let v=0;v<g;v++){const R=ae.createEmptyBand(x,b),k=new Uint8Array(b).fill(255);let _=!1;const P=v*b;for(let M=0;M<b;M++){const N=I[P+M];N==null?(k[M]=0,_=!0):R[M]=N}if(f===0||r?.length){const M=new ae({width:e,height:t,mask:_?k:null,pixels:[R],pixelType:x});M.updateStatistics(),r?.length?u[qt(F,S,v)+w]=M:u.push(M)}else{const M=u[v];M.pixels.push(R),_?M.mask&&(M.mask=ae.combineBandMasks([M.mask,k])):M.mask=_?k:null}}}const p=Object.values(l).find(f=>f.attributeTable)?.attributeTable;return{extent:s,pixelBlocks:u,multidimensionalInfo:o,attributeTable:p,bandNames:o?void 0:n}}let X=class extends Z{constructor(){super(...arguments),this.datasetFormat="MEMORY",this.source=null}get url(){return""}fetchRawTile(i,e,t,s={}){if(!this._pixelBlockTiles){const{rasterInfo:a}=this,[n,c]=a.storageInfo.tileInfo.size,{sliceId:l}=s,{pixelBlocks:o}=this.source,u={pixelBlock:l==null?o[0]:o[l],useBilinear:a.dataType!=="thematic",tileSize:{width:n,height:c},level:i,row:e,col:t},p=this.rasterJobHandler?this.rasterJobHandler.clipTile(u,s):Rt(u);return Promise.resolve(p)}const r=this._pixelBlockTiles.get(`${i}/${e}/${t}`);return Promise.resolve(r)}async _open(i){const e=this.source,{pixelBlocks:t,attributeTable:s,statistics:r,histograms:a,name:n,nativeExtent:c,transform:l}=e,o=t[0],{width:u,height:p,pixelType:f}=o,h=e.extent??new H({xmin:-.5,ymin:.5,xmax:u-.5,ymax:p-.5,spatialReference:new D({wkid:3857})}),I=e.isPseudoSpatialReference??!e.extent,y={x:h.width/u,y:h.height/p},m={...e.keyProperties};s&&(m.DataType="Thematic");const d=new le({width:u,height:p,pixelType:f,extent:h,nativeExtent:c,attributeTable:s,transform:l,pixelSize:y,spatialReference:h.spatialReference,bandCount:o.pixels.length,keyProperties:m,multidimensionalInfo:e.multidimensionalInfo,statistics:r,isPseudoSpatialReference:I,histograms:a});this.ioConfig.skipMapInfo&&this.updateImageSpaceRasterInfo(d),this.createRemoteDatasetStorageInfo(d,512,512),this._set("rasterInfo",d),this.updateTileInfo(),d.multidimensionalInfo?await this._buildMDimStats(e.pixelBlocks,d.multidimensionalInfo):await this._buildInMemoryRaster(o,{width:512,height:512},i),d.multidimensionalInfo||(this.source=null),this.datasetName=n}async _buildInMemoryRaster(i,e,t){const{rasterInfo:s}=this,r=s.storageInfo.maximumPyramidLevel??0,a=s.dataType!=="thematic",n=this.rasterJobHandler?this.rasterJobHandler.split({pixelBlock:i,tileSize:e,maximumPyramidLevel:r,useBilinear:a},t):Promise.resolve(_t(i,e,r,a)),c=s.statistics!=null,l=s.histograms!=null,o=this.ioConfig.skipStatistics||c?Promise.resolve({statistics:null,histograms:null}):this.rasterJobHandler?this.rasterJobHandler.estimateStatisticsHistograms({pixelBlock:i},t):Promise.resolve(Ft(i)),u=await Ce([n,o]);if(!u[0].value&&u[1].value)throw new C("inmemory-raster:open","failed to build in memory raster");this._pixelBlockTiles=u[0].value,c||(s.statistics=u[1].value?.statistics),l||(s.histograms=u[1].value?.histograms)}async _buildMDimStats(i,e,t){for(let s=0;s<e.variables.length;s++){const r=e.variables[s];if(r.statistics)continue;const a=r.dimensions.map(o=>new ht({variableName:r.name,dimensionName:o.name,values:[o.values?.[0]??o.extent?.[0]],isSlice:!0})),n=mt(a,e),c=n==null?null:i[n];if(c==null)continue;const l=this.rasterJobHandler?await this.rasterJobHandler.computeStatisticsHistograms({pixelBlock:c},t):Me(c);r.statistics=l.statistics,r.histograms||(r.histograms=l.histograms)}}};T([O({type:String,json:{write:!0}})],X.prototype,"datasetFormat",void 0),T([O()],X.prototype,"source",void 0),T([O()],X.prototype,"url",null),X=T([Y("esri.layers.support.rasterDatasets.InMemoryRaster")],X);const Ie=X;let Q=class extends Z{constructor(){super(...arguments),this.datasetFormat="CovJSON"}fetchRawTile(e,t,s,r={}){return this._inMemoryRaster.fetchRawTile(e,t,s,r)}async _open(e){const{extent:t,pixelBlocks:s,multidimensionalInfo:r,attributeTable:a,bandNames:n}=await this._fetchData(e),{statistics:c,histograms:l}=Me(s[0]),o=n?.map(h=>({BandName:h})),u={DataType:a?"Thematic":r?"Scientific":"Generic",BandProperties:o},p=new Ie({source:{extent:t,pixelBlocks:s,attributeTable:a?Pe.fromJSON(a):null,multidimensionalInfo:r,statistics:c,histograms:l,keyProperties:u,isPseudoSpatialReference:!1}});await p.open(),this._inMemoryRaster=p;const f=this.source?"":this.url.slice(this.url.lastIndexOf("/")+1);this._set("datasetName",f.slice(0,f.indexOf("."))),this._set("rasterInfo",p.rasterInfo)}async _fetchData(e){const t=this.source??(await this.request(this.url,{signal:e?.signal})).data,s="imagery-tile-layer:open-coverage-json";if(t.type?.toLowerCase()!=="coverage"||t.domain?.domainType?.toLowerCase()!=="grid")throw new C(s,"Only coverage with Grid domain type is supported");if(!t.ranges)throw new C(s,"Missing ranges in the grid coverage data");if(!t.domain.referencing?.length)throw new C(s,"Missing domain referencing in the grid coverage data");const r=Object.values(t.ranges);for(let a=0;a<r.length;a++){const{axisNames:n,shape:c,type:l,values:o}=r[a];if(!(l.toLowerCase()==="ndarray"&&o?.length&&n?.length&&c?.length))throw new C(s,"Only ranges with valid NdArray, axisNames, shape, and inline values are supported");if(!($e(n[n.length-1])&&Ne(n[n.length-2])))throw new C(s,"Only row-major ordered pixel values are supported. X axis must be the last axis.")}return Vt(t)}};T([O({type:String,json:{write:!0}})],Q.prototype,"datasetFormat",void 0),T([O({constructOnly:!0})],Q.prototype,"source",void 0),Q=T([Y("esri.layers.support.rasterDatasets.CovJSONRaster")],Q);const Yt=Q;function Oe(i,e){if(!i||!e)return null;const t=[];for(let s=0;s<i.length;s++)t.push(i[s]),t.push(e[s]);return t}function Xt(i){const e=B(i,"GeodataXform"),t=ue(q(e,"SpatialReference/WKID")||J(e,"SpatialReference/WKT"));if(e.getAttribute("xsi:type")!=="typens:PolynomialXform")return{spatialReference:t,transform:null};const s=q(e,"PolynomialOrder")??1,r=se(e,"CoeffX/Double"),a=se(e,"CoeffY/Double"),n=se(e,"InverseCoeffX/Double"),c=se(e,"InverseCoeffY/Double"),l=Oe(r,a),o=Oe(n,c);return{spatialReference:t,transform:l&&o&&l.length&&o.length?new xe({spatialReference:t,polynomialOrder:s,forwardCoefficients:l,inverseCoefficients:o}):null}}function Kt(i){const e=q(i,"NoDataValue"),t=B(i,"Histograms/HistItem"),s=q(t,"HistMin"),r=q(t,"HistMax"),a=q(t,"BucketCount"),n=J(t,"HistCounts")?.split("|").map(f=>Number(f));let c,l,o,u;Fe(i,"Metadata/MDI").forEach(f=>{const h=Number(f.textContent??f.nodeValue);switch(f.getAttribute("key").toUpperCase()){case"STATISTICS_MINIMUM":c=h;break;case"STATISTICS_MAXIMUM":l=h;break;case"STATISTICS_MEAN":o=h;break;case"STATISTICS_STDDEV":u=h}});const p=q(i,"Metadata/SourceBandIndex");return{noDataValue:e,histogram:n?.length&&s!=null&&r!=null?{min:s,max:r,size:a||n.length,counts:n}:null,sourceBandIndex:p,statistics:c!=null&&l!=null?{min:c,max:l,avg:o,stddev:u}:null}}function ue(i){if(!i)return null;let e=Number(i);if(!isNaN(e)&&e!==0)return new D({wkid:e});if(i=String(i).trim(),Le(i))return new D({wkt2:i});const t=i.toUpperCase();if(t.startsWith("COMPD_CS")){if(!t.includes("VERTCS")||!t.includes("GEOGCS")&&!t.startsWith("PROJCS"))return null;const s=t.indexOf("VERTCS"),r=t.indexOf("PROJCS"),a=r>-1?r:t.indexOf("GEOGCS");if(a===-1)return null;const n=i.slice(a,i.lastIndexOf("]",s)+1).trim(),c=i.slice(s,i.lastIndexOf("]")).trim();e=he(n);const l=new D(e?{wkid:e}:{wkt:n}),o=he(c);return o&&(l.vcsWkid=o),l}return t.startsWith("GEOGCS")||t.startsWith("PROJCS")?(e=he(i),new D(e!==0?{wkid:e}:{wkt:i})):null}function he(i){const e=i.replaceAll("]","[").replaceAll('"',"").split("[").map(r=>r.trim()).filter(r=>r!==""),t=e[e.length-1].split(","),s=t[0]?.toLowerCase();if((s==="epsg"||s==="esri")&&i.endsWith('"]]')){const r=Number(t[1]);if(!isNaN(r)&&r!==0)return r}return 0}function be(i){if(i?.documentElement.tagName?.toLowerCase()!=="pamdataset")return{};const e={spatialReference:null,transform:null,metadata:{},rasterBands:[],statistics:null,histograms:null};i.documentElement.childNodes.forEach(s=>{if(s.nodeType===1){if(ce(s,"SRS")){if(!e.spatialReference){const r=J(s);e.spatialReference=ue(r)}}else if(ce(s,"Metadata"))if(s.getAttribute("domain")==="xml:ESRI"){const{spatialReference:r,transform:a}=Xt(s);e.transform=a,e.spatialReference||(e.spatialReference=r)}else Fe(s,"MDI").forEach(r=>e.metadata[r.getAttribute("key")]=J(r));else if(ce(s,"PAMRasterBand")){const r=Kt(s);r.sourceBandIndex!=null&&e.rasterBands[r.sourceBandIndex]==null?e.rasterBands[r.sourceBandIndex]=r:e.rasterBands.push(r)}}});const t=e.rasterBands;if(t.length){const s=!!t[0].statistics;e.statistics=s?t.map(a=>a.statistics).filter(ve):null;const r=!!t[0].histogram;e.histograms=r?t.map(a=>a.histogram).filter(ve):null}return e}let oe=class extends Z{fetchRawTile(i,e,t,s={}){return this._inMemoryRaster.fetchRawTile(i,e,t,s)}async _open(i){const e=await this._fetchData(i);let{spatialReference:t,statistics:s,histograms:r,transform:a}=await this._fetchAuxiliaryData(i);const n=!t;n&&(t=new D({wkid:3857})),r?.length&&s==null&&(s=ye(r));const{width:c,height:l}=e;let o=new H({xmin:-.5,ymin:.5-l,xmax:c-.5,ymax:.5,spatialReference:t});const u=a?a.forwardTransform(o):o;let p=!0;if(a){const h=a.forwardCoefficients;p=h&&h[1]===0&&h[2]===0,p&&(a=null,o=u)}const f=new Ie({source:{extent:u,nativeExtent:o,transform:a,pixelBlocks:[e],statistics:s,histograms:r,keyProperties:{DateType:"Processed"},isPseudoSpatialReference:n},ioConfig:{sampling:"closest",skipStatistics:!0}});this.ioConfig.skipMapInfo&&(f.ioConfig.skipMapInfo=!0),await f.open(),f.source=null,this._set("rasterInfo",f.rasterInfo),this._inMemoryRaster=f}async _fetchData(i){const{data:e}=await this.request(this.url,{responseType:"array-buffer",signal:i?.signal}),t=kt(e).toUpperCase();if(t!=="JPG"&&t!=="PNG"&&t!=="GIF"&&t!=="BMP")throw new C("image-aux-raster:open","the data is not a supported format");this._set("datasetFormat",t);const s=t.toLowerCase(),r=s==="gif"||s==="bmp"||!Je("ios"),a=await this.decodePixelBlock(e,{format:s,useCanvas:r,hasNoZlibMask:!0});if(a==null)throw new C("image-aux-raster:open","the data cannot be decoded");return a}async _fetchAuxiliaryData(i){const e=i?.signal,{skipExtensions:t=[],skipMapInfo:s}=this.ioConfig,r=s||t.includes("aux.xml")?null:this.request(this.url+".aux.xml",{responseType:"xml",signal:e}),a=this.datasetFormat,n=a==="JPG"?"jgw":a==="PNG"?"pgw":a==="BMP"?"bpw":null,c=n&&t.includes(n)?null:this.request(this.url.slice(0,this.url.lastIndexOf("."))+"."+n,{responseType:"text",signal:e}),l=await Ce([r,c]);if(e?.aborted)throw ze();const o=be(l[0].value?.data);if(!o.transform){const u=l[1].value?l[1].value.data.split(`
`).slice(0,6).map(p=>Number(p)):null;o.transform=u?.length===6?new xe({forwardCoefficients:[u[4],u[5],u[0],-u[1],u[2],-u[3]]}):null}return o}};T([O({type:String,json:{write:!0}})],oe.prototype,"datasetFormat",void 0),oe=T([Y("esri.layers.support.rasterDatasets.ImageAuxRaster")],oe);const re=oe;let ee=class extends Z{constructor(){super(...arguments),this._levelOffset=0,this._tilemapCache=null,this._slices=null,this.datasetFormat="RasterTileServer",this.tileType=null}async fetchRawTile(i,e,t,s={}){const{storageInfo:r,extent:a}=this.rasterInfo,{transposeInfo:n}=r,c=n!=null&&!!s.transposedVariableName;if(this._slices&&!c&&s.sliceId==null)return null;const l=c?0:r.maximumPyramidLevel-i+this._levelOffset,o=`${this.url}/tile/${l}/${e}/${t}`,u=this._slices?c?{variable:s.transposedVariableName}:{sliceId:s.sliceId||0}:null;let p,f;if(r.isBsqTile){const M=(s.bandIds?.length?s.bandIds:[0,1,2]).map(z=>this.request(o,{query:{...u,bandId:z},responseType:"array-buffer",signal:s.signal})),N=await Promise.all(M),L=N.map(z=>z.data.byteLength).reduce((z,Ee)=>z+Ee),G=new Uint8Array(L);f=[];let W=0;for(const{data:z}of N)f.push(W),G.set(new Uint8Array(z),W),W+=z.byteLength;p=G.buffer}else p=(await this.request(o,{query:u,responseType:"array-buffer",signal:s.signal})).data;if(!p)return null;const h=c?n.tileSize:r.tileInfo.size,I=await this.decodePixelBlock(p,{width:h[0],height:h[1],planes:f?.length,offsets:f,pixelType:null,isPoint:this.tileType==="Elevation",returnInterleaved:c,noDataValue:this.rasterInfo.noDataValue});if(I==null)return null;const y=r.blockBoundary[i];if(r.compression!=="jpg"||t>y.minCol&&t<y.maxCol&&e>y.minRow&&e<y.maxRow)return I;const{origin:m,blockWidth:d,blockHeight:w}=r,{x:F,y:S}=this.getPyramidPixelSize(i),x=Math.round((a.xmin-m.x)/F)%d,b=Math.round((a.xmax-m.x)/F)%d||d,g=Math.round((m.y-a.ymax)/S)%w,v=Math.round((m.y-a.ymin)/S)%w||w,R=t===y.minCol?x:0,k=e===y.minRow?g:0,_=t===y.maxCol?b:d,P=e===y.maxRow?v:w;return Ot(I,{x:R,y:k},{width:_-R,height:P-k}),I}getSliceIndex(i){if(!this._slices||i==null||i.length===0)return null;const e=i;for(let t=0;t<this._slices.length;t++){const s=this._slices[t].multidimensionalDefinition;if(s.length===e.length&&!s.some(r=>{const a=e.find(n=>r.variableName===n.variableName&&n.dimensionName===r.dimensionName);return a?(Array.isArray(r.values[0])?`${r.values[0][0]}-${r.values[0][1]}`:r.values[0])!==(Array.isArray(a.values[0])?`${a.values[0][0]}-${a.values[0][1]}`:a.values[0]):!0}))return t}return null}async fetchVariableStatisticsHistograms(i,e){const t=this.request(this.url+"/statistics",{query:{variable:i,f:"json"},signal:e}).then(a=>a.data?.statistics),s=this.request(this.url+"/histograms",{query:{variable:i,f:"json"},signal:e}).then(a=>a.data?.histograms),r=await Promise.all([t,s]);return r[0]&&r[0].forEach(a=>{a.avg=a.mean,a.stddev=a.standardDeviation}),r[1]?.[0]?.counts?.length||(r[1]=null),{statistics:r[0]||null,histograms:r[1]||null}}async computeBestPyramidLevelForLocation(i,e={}){if(!this._tilemapCache)return 0;let t=this.identifyPixelLocation(i,0,e.datumTransformation);if(t===null)return null;let s=0;const{maximumPyramidLevel:r}=this.rasterInfo.storageInfo;let a=r-s+this._levelOffset;const n=t.srcLocation;for(;a>=0;){try{if(await this._tilemapCache.fetchAvailability(a,t.row,t.col,e)==="available")break}catch{}if(a--,s++,t=this.identifyPixelLocation(n,s,e.datumTransformation),t===null)return null}return a===-1||t==null?null:s}async _open(i){const e=i?.signal,t=this.sourceJSON?{data:this.sourceJSON}:await this.request(this.url,{query:{f:"json"},signal:e});t.ssl&&(this.url=this.url.replace(/^http:/i,"https:"));const s=t.data;if(this.sourceJSON=s,!s)throw new C("imageserverraster:open","cannot initialize tiled image service, missing service info");if(!s.tileInfo)throw new C("imageserverraster:open","use ImageryLayer to open non-tiled image services");this._fixScaleInServiceInfo();const r=["jpg","jpeg","png","png8","png24","png32","mixed"];this.tileType=s.cacheType,this.tileType==null&&(r.includes(s.tileInfo.format.toLowerCase())?this.tileType="Map":s.tileInfo.format.toLowerCase()==="lerc"?this.tileType="Elevation":this.tileType="Raster"),this.datasetName=s.name?.slice(s.name.indexOf("/")+1)??"";const a=await this._fetchRasterInfo({signal:e});if(a==null)throw new C("image-server-raster:open","cannot initialize image service");ot(a,s);const n=this.tileType==="Map"?Zt(s.tileInfo,s):ne.fromJSON(s.tileInfo);Ue(n);const[c,l]=this._computeMinMaxLOD(a,n),{extent:o,pixelSize:u}=a,p=.5/a.width*u.x,f=Math.max(u.x,u.y),{lods:h}=n;(this.tileType!=="Map"&&s.maxScale!==0||Math.abs(u.x-u.y)>p||!h.some(g=>Math.abs(g.resolution-f)<p))&&(u.x=u.y=c.resolution,a.width=Math.ceil((o.xmax-o.xmin)/u.x-.1),a.height=Math.ceil((o.ymax-o.ymin)/u.y-.1));const I=c.level-l.level,[y,m]=n.size,d=[],w=[];h.forEach((g,v)=>{g.level>=l.level&&g.level<=c.level&&d.push({x:g.resolution,y:g.resolution}),v<h.length-1&&w.push(Math.round(10*g.resolution/h[v+1].resolution)/10)}),d.sort((g,v)=>g.x-v.x);const F=this.computeBlockBoundary(o,y,m,n.origin,d,I),S=d.length>1?d.slice(1):null;let x;s.transposeInfo&&(x={tileSize:[s.transposeInfo.rows,s.transposeInfo.cols],packetSize:a.keyProperties?._yxs.PacketSize??0});const b=w.length<=1||w.length>=3&&w.slice(0,-1).every(g=>g===w[0])?w[0]??2:Math.round(10/(l.resolution/c.resolution)**(-1/I))/10;if(a.storageInfo=new we({blockWidth:n.size[0],blockHeight:n.size[1],pyramidBlockWidth:n.size[0],pyramidBlockHeight:n.size[1],pyramidResolutions:S,pyramidScalingFactor:b,compression:n.format,origin:n.origin,firstPyramidLevel:1,maximumPyramidLevel:I,tileInfo:n,isBsqTile:!!s.bsq,transposeInfo:x,blockBoundary:F}),Qt(a),this._set("rasterInfo",a),s.capabilities.toLowerCase().includes("tilemap")){const g={tileInfo:a.storageInfo.tileInfo,parsedUrl:je(this.url),url:this.url,tileServers:[]};this._tilemapCache=new Jt({layer:g})}}async _fetchRasterInfo(i){const e=this.sourceJSON;if(this.tileType==="Map"){const n=e.fullExtent||e.extent,c=Math.ceil((n.xmax-n.xmin)/e.pixelSizeX-.1),l=Math.ceil((n.ymax-n.ymin)/e.pixelSizeY-.1),o=D.fromJSON(e.spatialReference||n.spatialReference),u=new V({x:e.pixelSizeX,y:e.pixelSizeY,spatialReference:o});return new le({width:c,height:l,bandCount:3,extent:H.fromJSON(n),spatialReference:o,pixelSize:u,pixelType:"u8",statistics:null,keyProperties:{DataType:"processed"}})}const{signal:t}=i,s=lt(this.url,this.sourceJSON,{signal:t,query:this.ioConfig.customFetchParameters}),r=e.hasMultidimensions?this.request(`${this.url}/slices`,{query:{f:"json"},signal:t}).then(n=>n.data?.slices).catch(()=>null):null,a=await Promise.all([s,r]);return this._slices=a[1],a[0]}_fixScaleInServiceInfo(){const{sourceJSON:i}=this;i.minScale&&i.minScale<0&&(i.minScale=0),i.maxScale&&i.maxScale<0&&(i.maxScale=0)}_computeMinMaxLOD(i,e){const{pixelSize:t}=i,s=.5/i.width*t.x,{lods:r}=e,a=e.lodAt(Math.max.apply(null,r.map(f=>f.level))),n=e.lodAt(Math.min.apply(null,r.map(f=>f.level))),{tileType:c}=this;if(c==="Map")return this._levelOffset=r[0].level,[a,n];if(c==="Raster")return[r.find(f=>f.resolution===t.x)??a,n];const{minScale:l,maxScale:o}=this.sourceJSON;let u=a;o>0&&(u=r.find(f=>Math.abs(f.scale-o)<s),u||(u=r.filter(f=>f.scale>o).sort((f,h)=>f.scale>h.scale?1:-1)[0]??a));let p=n;return l>0&&(p=r.find(f=>Math.abs(f.scale-l)<s)??n,this._levelOffset=p.level-n.level),[u,p]}};function Zt(i,e){if(!i)return null;const{minScale:t,maxScale:s,minLOD:r,maxLOD:a}=e;if(r!=null&&a!=null)return ne.fromJSON({...i,lods:i.lods.filter(({level:n})=>n!=null&&n>=r&&n<=a)});if(t!==0&&s!==0){const n=o=>Math.round(1e4*o)/1e4,c=t?n(t):1/0,l=s?n(s):-1/0;return ne.fromJSON({...i,lods:i.lods.filter(o=>{const u=n(o.scale);return u<=c&&u>=l})})}return ne.fromJSON(i)}function Qt(i){const{extent:e,spatialReference:t}=i;e.xmin>-1&&e.xmax>181&&t?.wkid&&t.isGeographic&&(i.nativeExtent=i.extent,i.transform=new Lt,i.extent=i.transform.forwardTransform(e))}T([O({type:String,json:{write:!0}})],ee.prototype,"datasetFormat",void 0),T([O()],ee.prototype,"tileType",void 0),ee=T([Y("esri.layers.support.rasterDatasets.ImageServerRaster")],ee);const es=ee,A=new Map;A.set("Int8","s8"),A.set("UInt8","u8"),A.set("Int16","s16"),A.set("UInt16","u16"),A.set("Int32","s32"),A.set("UInt32","u32"),A.set("Float32","f32"),A.set("Float64","f32"),A.set("Double64","f32");const j=new Map;j.set("none",{blobExtension:".til",isOneSegment:!0,decoderFormat:"bip"}),j.set("lerc",{blobExtension:".lrc",isOneSegment:!1,decoderFormat:"lerc"}),j.set("deflate",{blobExtension:".pzp",isOneSegment:!0,decoderFormat:"deflate"}),j.set("jpeg",{blobExtension:".pjg",isOneSegment:!0,decoderFormat:"jpg"});let K=class extends Z{constructor(){super(...arguments),this._files=null,this._storageIndex=null,this.datasetFormat="MRF"}async fetchRawTile(i,e,t,s={}){const{blockWidth:r,blockHeight:a,blockBoundary:n}=this.rasterInfo.storageInfo,c=n[i];if(!c||c.maxRow<e||c.maxCol<t||c.minRow>e||c.minCol>t)return null;const{bandCount:l,pixelType:o}=this.rasterInfo,{ranges:u,actualTileWidth:p,actualTileHeight:f}=this._getTileLocation(i,e,t);if(!u||u.length===0)return null;if(u[0].from===0&&u[0].to===0){const _=new Uint8Array(r*a);return new ae({width:r,height:a,pixels:void 0,mask:_,validPixelCount:0})}const{bandIds:h}=this.ioConfig,I=this._getBandSegmentCount(),y=[];let m=0;for(m=0;m<I;m++)h&&!h.includes(m)||y.push(this.request(this._files.data,{range:{from:u[m].from,to:u[m].to},responseType:"array-buffer",signal:s.signal}));const d=await Promise.all(y),w=d.map(_=>_.data.byteLength).reduce((_,P)=>_+P),F=new Uint8Array(w),S=[];let x=0;for(m=0;m<I;m++)S.push(x),F.set(new Uint8Array(d[m].data),x),x+=d[m].data.byteLength;const b=j.get(this.rasterInfo.storageInfo.compression).decoderFormat,g=await this.decodePixelBlock(F.buffer,{width:r,height:a,format:b,planes:h?.length||l,offsets:S,pixelType:o});if(g==null)return null;let{noDataValue:v}=this.rasterInfo;if(v!=null&&b!=="lerc"&&!g.mask&&(v=v[0],v!=null)){const _=g.width*g.height,P=new Uint8Array(_);if(Math.abs(v)>1e24)for(m=0;m<_;m++)Math.abs((g.pixels[0][m]-v)/v)>1e-6&&(P[m]=1);else for(m=0;m<_;m++)g.pixels[0][m]!==v&&(P[m]=1);g.mask=P}let R=0,k=0;if(p!==r||f!==a){let _=g.mask;if(_)for(m=0;m<a;m++)if(k=m*r,m<f)for(R=p;R<r;R++)_[k+R]=0;else for(R=0;R<r;R++)_[k+R]=0;else for(_=new Uint8Array(r*a),g.mask=_,m=0;m<f;m++)for(k=m*r,R=0;R<p;R++)_[k+R]=1}return g}async _open(i){this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const e=i?i.signal:null,t=await this.request(this.url,{responseType:"xml",signal:e}),{rasterInfo:s,files:r}=this._parseHeader(t.data),{skipMapInfo:a,skipExtensions:n=[]}=this.ioConfig;if(!n.includes("aux.xml")&&!a){const d=await this._fetchAuxiliaryData(i);d!=null&&(s.statistics=d.statistics??s.statistics,s.histograms=d.histograms,d.histograms&&s.statistics==null&&(s.statistics=ye(d.histograms)))}a&&this.updateImageSpaceRasterInfo(s),this._set("rasterInfo",s),this._files=r;const c=await this.request(r.index,{responseType:"array-buffer",signal:e});this._storageIndex=ts(c.data);const{blockWidth:l,blockHeight:o}=this.rasterInfo.storageInfo,u=this.rasterInfo.storageInfo.pyramidScalingFactor,{width:p,height:f}=this.rasterInfo,h=[],I=this._getBandSegmentCount();let y=0,m=-1;for(;y<this._storageIndex.length;){m++;const d=Math.ceil(p/l/u**m)-1,w=Math.ceil(f/o/u**m)-1;y+=(d+1)*(w+1)*I*4,h.push({maxRow:w,maxCol:d,minCol:0,minRow:0})}this.rasterInfo.storageInfo.blockBoundary=h,m>0&&(this.rasterInfo.storageInfo.firstPyramidLevel=1,this.rasterInfo.storageInfo.maximumPyramidLevel=m),this.updateTileInfo()}_getBandSegmentCount(){return j.get(this.rasterInfo.storageInfo.compression).isOneSegment?1:this.rasterInfo.bandCount}_getTileLocation(i,e,t){const{blockWidth:s,blockHeight:r,pyramidScalingFactor:a}=this.rasterInfo.storageInfo,{width:n,height:c}=this.rasterInfo,l=this._getBandSegmentCount();let o,u,p,f=0,h=0;for(p=0;p<i;p++)h=a**p,o=Math.ceil(n/s/h),u=Math.ceil(c/r/h),f+=o*u;h=a**i,o=Math.ceil(n/s/h),u=Math.ceil(c/r/h),f+=e*o+t,f*=4*l;const I=this._storageIndex.subarray(f,f+4*l);let y=0,m=0;const d=[];for(let w=0;w<l;w++)y=I[4*w]*2**32+I[4*w+1],m=y+I[4*w+2]*2**32+I[4*w+3],d.push({from:y,to:m});return{ranges:d,actualTileWidth:t<o-1?s:Math.ceil(n/h)-s*(o-1),actualTileHeight:e<u-1?r:Math.ceil(c/h)-r*(u-1)}}_parseHeader(i){const e=B(i,"MRF_META/Raster");if(!e)throw new C("mrf:open","not a valid MRF format");const t=B(e,"Size"),s=parseInt(t.getAttribute("x"),10),r=parseInt(t.getAttribute("y"),10),a=parseInt(t.getAttribute("c"),10),n=(J(e,"Compression")||"none").toLowerCase();if(!j.has(n))throw new C("mrf:open","currently does not support compression "+n);const c=J(e,"DataType")||"UInt8",l=A.get(c);if(l==null)throw new C("mrf:open","currently does not support pixel type "+c);const o=B(e,"PageSize"),u=parseInt(o.getAttribute("x"),10),p=parseInt(o.getAttribute("y"),10),f=B(e,"DataValues");let h,I;if(f&&(I=f.getAttribute("NoData"),I!=null&&(h=I.trim().split(" ").map(_=>parseFloat(_)))),B(i,"MRF_META/CachedSource"))throw new C("mrf:open","currently does not support MRF referencing other data files");const y=B(i,"MRF_META/GeoTags"),m=B(y,"BoundingBox");let d,w=!1;if(m!=null){const _=parseFloat(m.getAttribute("minx")),P=parseFloat(m.getAttribute("miny")),M=parseFloat(m.getAttribute("maxx")),N=parseFloat(m.getAttribute("maxy")),L=J(y,"Projection")||"";let G=D.WGS84;if(L!=="LOCAL_CS[]")if(L.toLowerCase().startsWith("epsg:")){const W=Number(L.slice(5));isNaN(W)||W===0||(G=new D({wkid:W}))}else G=ue(L)??D.WGS84;else w=!0,G=new D({wkid:3857});d=new H(_,P,M,N),d.spatialReference=G}else w=!0,d=new H({xmin:-.5,ymin:.5-r,xmax:s-.5,ymax:.5,spatialReference:new D({wkid:3857})});const F=B(i,"MRF_META/Rsets"),S=parseInt(F?.getAttribute("scale")||"2",10),x=d.spatialReference,b=new we({origin:new V({x:d.xmin,y:d.ymax,spatialReference:x}),blockWidth:u,blockHeight:p,pyramidBlockWidth:u,pyramidBlockHeight:p,compression:n,pyramidScalingFactor:S}),g=new V({x:d.width/s,y:d.height/r,spatialReference:x}),v=new le({width:s,height:r,extent:d,isPseudoSpatialReference:w,spatialReference:x,bandCount:a,pixelType:l,pixelSize:g,noDataValue:h,storageInfo:b}),R=J(i,"datafile"),k=J(i,"IndexFile");return{rasterInfo:v,files:{mrf:this.url,index:k||this.url.replace(".mrf",".idx"),data:R||this.url.replace(".mrf",j.get(n).blobExtension)}}}async _fetchAuxiliaryData(i){try{const{data:e}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:i?.signal});return be(e)}catch{return null}}};function ts(i){if(i.byteLength%16>0)throw new Error("invalid array buffer must be multiples of 16");let e,t,s,r,a,n;if(Mt){for(t=new Uint8Array(i),r=new ArrayBuffer(i.byteLength),s=new Uint8Array(r),a=0;a<i.byteLength/4;a++)for(n=0;n<4;n++)s[4*a+n]=t[4*a+3-n];e=new Uint32Array(r)}else e=new Uint32Array(i);return e}T([O()],K.prototype,"_files",void 0),T([O()],K.prototype,"_storageIndex",void 0),T([O({type:String,json:{write:!0}})],K.prototype,"datasetFormat",void 0),K=T([Y("esri.layers.support.rasterDatasets.MRFRaster")],K);const ss=K;function is(i){const e=i.fields,t=i.records,s=e.some(o=>o.name.toLowerCase()==="oid")?"OBJECTID":"OID",r=[{name:s,type:"esriFieldTypeOID",alias:"OID"}].concat(e.map(o=>({name:o.name,type:"esriFieldType"+o.typeName,alias:o.name}))),a=r.map(o=>o.name),n=[];let c=0,l=0;return t.forEach(o=>{const u={};for(u[s]=c++,l=1;l<a.length;l++)u[a[l]]=o[l-1];n.push({attributes:u})}),{displayFieldName:"",fields:r,features:n}}class rs{static get supportedVersions(){return[5]}static parse(e){const t=new DataView(e),s=3&t.getUint8(0);if(s!==3)return{header:{version:s},recordSet:null};const r=t.getUint32(4,!0),a=t.getUint16(8,!0),n=t.getUint16(10,!0),c={version:s,recordCount:r,headerByteCount:a,recordByteCount:n};let l=32;const o=[],u=[];let p;if(s===3){for(;t.getUint8(l)!==13;)p=String.fromCharCode(t.getUint8(l+11)).trim(),o.push({name:Te(new Uint8Array(e,l,11)),type:p,typeName:["String","Date","Double","Boolean","String","Integer"][["C","D","F","L","M","N"].indexOf(p)],length:t.getUint8(l+16)}),l+=32;if(l+=1,o.length>0)for(;u.length<r&&e.byteLength-l>n;){const f=[];t.getUint8(l)===32?(l+=1,o.forEach(h=>{if(h.type==="C")f.push(Te(new Uint8Array(e,l,h.length)).trim());else if(h.type==="N")f.push(parseInt(String.fromCharCode.apply(null,new Uint8Array(e,l,h.length)).trim(),10));else if(h.type==="F")f.push(parseFloat(String.fromCharCode.apply(null,new Uint8Array(e,l,h.length)).trim()));else if(h.type==="D"){const I=String.fromCharCode.apply(null,new Uint8Array(e,l,h.length)).trim();f.push(new Date(parseInt(I.slice(0,4),10),parseInt(I.slice(4,6),10)-1,parseInt(I.slice(6,8),10)))}l+=h.length}),u.push(f)):l+=n}}return{header:c,fields:o,records:u,recordSet:is({fields:o,records:u})}}}const ge=(i,e)=>i.get(e)?.values,te=(i,e)=>i.get(e)?.values?.[0];let U=class extends Z{constructor(){super(...arguments),this._files=null,this._headerInfo=null,this._bufferSize=1048576,this._chunkSize=10485760,this.datasetFormat="TIFF"}async fetchRawTile(e,t,s,r={}){if(!this._headerInfo?.isSupported||this.isBlockOutside(e,t,s))return null;const a=await this._fetchRawTiffTile(e,t,s,!1,r);if(a!=null&&this._headerInfo.hasMaskBand){const n=await this._fetchRawTiffTile(e,t,s,!0,r);n!=null&&n.pixels[0]instanceof Uint8Array&&(a.mask=n.pixels[0])}return a}async _open(e){const t=e?e.signal:null,{data:s}=await this.request(this.url,{range:{from:0,to:this._bufferSize},responseType:"array-buffer",signal:t});if(!s)throw new C("tiffraster:open","failed to open url "+this.url);this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1,this.url.lastIndexOf("."));const{littleEndian:r,firstIFDPos:a,isBigTiff:n}=Pt(s),c=[],l={fileChunk:s,posIFD:a,fileOffset:0};await this._readIFDs(c,l,r,n?8:4,t);const{imageInfo:o,rasterInfo:u}=as(c),p=$t(c),f=Nt(c);if(this._headerInfo={littleEndian:r,isBigTiff:n,ifds:c,pyramidIFDs:p,maskIFDs:f,...o},this._set("rasterInfo",u),!o.isSupported)throw new C("tiffraster:open","this tiff is not supported: "+o.message);if(!o.tileWidth)throw new C("tiffraster:open","none-tiled tiff is not optimized for access, convert to COG and retry.");u.isPseudoSpatialReference&&de.getLogger(this).warn("The spatial reference for this tiff is unsupported. Only EPSG spatial reference codes and Esri WKTs are supported.");const h=c[0].get("PREDICTOR")?.values?.[0];if(c[0].get("SAMPLEFORMAT")?.values?.[0]===3&&h===2)throw new C("tiffraster:open","unsupported horizontal difference encoding. Predictor=3 is supported for floating point data");const{skipMapInfo:y,skipExtensions:m=[]}=this.ioConfig;if(!m.includes("aux.xml")&&!y){const d=await this._fetchAuxiliaryMetaData(e);d!=null&&ns(d,u)}m.includes("vat.dbf")||u.bandCount!==1||u.pixelType!=="u8"||y||(u.attributeTable=await this._fetchAuxiliaryTable(e),u.attributeTable!=null&&(u.keyProperties.DataType="thematic")),y&&this.updateImageSpaceRasterInfo(u),this.updateTileInfo()}async _validateOrFetchHeaderBuffer(e,t){let{fileChunk:s,fileOffset:r,posIFD:a}=e;return(a+8>=s.byteLength||a<0)&&(r=a+r,s=(await this.request(this.url,{range:{from:r,to:r+this._bufferSize},responseType:"array-buffer",signal:t})).data,a=0),{fileChunk:s,fileOffset:r,posIFD:a}}async _readIFDs(e,t,s,r=4,a){if(!t.posIFD)return null;t=await this._validateOrFetchHeaderBuffer(t,a);const n=await this._readIFD(t,s,Re,r,a);if(!n?.ifd)throw new C("tiffraster:open","cannot parse tiff header. failed to open url "+this.url);if(e.push(n.ifd),!n.nextIFD)return null;t.posIFD=n.nextIFD-t.fileOffset,await this._readIFDs(e,t,s,r,a)}async _readIFD(e,t,s=Re,r=4,a){let{fileChunk:n,posIFD:c,fileOffset:l}=e;if(!e.fileChunk)return null;const o=Et(n,t,c,l,s,r);if(o.success){const u=[];if(o.ifd?.forEach(p=>{p.values||u.push(p)}),u.length>0&&await this._fillOffsets(u,t,o.nextIFD,a),o.ifd?.has("GEOKEYDIRECTORY")){const p=o.ifd.get("GEOKEYDIRECTORY"),f=p?.values;if(f&&f.length>4){const h=f[0]+"."+f[1]+"."+f[2];c=p.valueOffset+6-l;const I=await this._validateOrFetchHeaderBuffer({fileChunk:n,posIFD:c,fileOffset:l},a),y=await this._readIFD(I,t,Dt,2,a);p.data=y?.ifd,p.data&&p.data.set("GEOTIFFVersion",{id:0,type:2,valueCount:1,valueOffset:null,values:[h]})}}return o}return o.requiredBufferSize?(n=(await this.request(this.url,{range:{from:l,to:l+c+o.requiredBufferSize+8},responseType:"array-buffer",signal:a})).data,n.byteLength<c+o.requiredBufferSize?null:(e.fileChunk=n,e.fileOffset=l,this._readIFD(e,t,s,r,a))):null}async _fillOffsets(e,t,s,r){const a=e.filter(p=>p.offlineOffsetSize!=null);if(a.length===0)return;const n=a.map(p=>p.offlineOffsetSize),c=Math.min.apply(null,n.map(p=>p[0])),l=Math.max.apply(null,n.map(p=>p[0]+p[1]));let o=n.length===1||l-c<=this._bufferSize;if(!o&&n.length>1&&(n.sort((p,f)=>p[0]-f[0]),o=n.reduce((p,f)=>p===f[0]?f[0]+f[1]:0,n[0][0])===l),o){const p=await this._fetchOffsets(c,Math.max(l,c+this._bufferSize),r);return void a.forEach(f=>_e(p,t,f,c))}const u=a.map(async p=>{const f=p.offlineOffsetSize,h=await this._fetchOffsets(f[0],f[1]+f[0],r);_e(h,t,p,f[0])});await Promise.all(u)}async _fetchOffsets(e,t,s){const r=[],a=this._chunkSize,n=Math.ceil((t-e)/a);let c=e;for(let u=0;u<n;u++)r.push(this.request(this.url,{range:{from:c,to:u===n-1?t:c+a-1},responseType:"array-buffer",signal:s})),c+=a;const l=await Promise.all(r);if(n===1)return l[0].data;const o=new Uint8Array(t-e+1);for(let u=0;u<n;u++)o.set(new Uint8Array(l[u].data),u*a);return o.buffer}async _fetchRawTiffTile(e,t,s,r,a={}){const n=this._getTileLocation(e,t,s,r);if(!n)return null;const{ranges:c,actualTileWidth:l,actualTileHeight:o,ifd:u}=n,p=c.map(g=>this.request(this.url,{range:g,responseType:"array-buffer",signal:a.signal})),f=await Promise.all(p),h=f.map(g=>g.data.byteLength).reduce((g,v)=>g+v),I=f.length===1?f[0].data:new ArrayBuffer(h),y=[0],m=[0];if(f.length>1){const g=new Uint8Array(I);for(let v=0,R=0;v<f.length;v++){const k=f[v].data;g.set(new Uint8Array(k),R),y[v]=R,R+=k.byteLength,m[v]=k.byteLength}}const{blockWidth:d,blockHeight:w}=this.getBlockWidthHeight(e),F=await this.decodePixelBlock(I,{format:"tiff",customOptions:{headerInfo:this._headerInfo,ifd:u,offsets:y,sizes:m},width:d,height:w,planes:null,pixelType:null});if(F==null)return null;let S,x,b;if(l!==d||o!==w){let g=F.mask;if(g)for(S=0;S<w;S++)if(b=S*d,S<o)for(x=l;x<d;x++)g[b+x]=0;else for(x=0;x<d;x++)g[b+x]=0;else for(g=new Uint8Array(d*w),F.mask=g,S=0;S<o;S++)for(b=S*d,x=0;x<l;x++)g[b+x]=1}return F}_getTileLocation(e,t,s,r=!1){const{firstPyramidLevel:a,blockBoundary:n}=this.rasterInfo.storageInfo,c=e===0?0:e-(a-1),{_headerInfo:l}=this;if(!l)return null;const o=r?l.maskIFDs[c]:c===0?l?.ifds[0]:l?.pyramidIFDs[c-1];if(!o)return null;const u=At(o,l),p=ge(o,"TILEOFFSETS");if(p===void 0)return null;const f=ge(o,"TILEBYTECOUNTS"),{minRow:h,minCol:I,maxRow:y,maxCol:m}=n[c];if(t>y||s>m||t<h||s<I)return null;const d=te(o,"IMAGEWIDTH"),w=te(o,"IMAGELENGTH"),F=te(o,"TILEWIDTH"),S=te(o,"TILELENGTH"),x=[];if(u){const{bandCount:b}=this.rasterInfo;for(let g=0;g<b;g++){const v=g*(y+1)*(m+1)+t*(m+1)+s;x[g]={from:p[v],to:p[v]+f[v]-1}}}else{const b=t*(m+1)+s;x.push({from:p[b],to:p[b]+f[b]-1})}for(let b=0;b<x.length;b++)if(x[b].from==null||!x[b].to||x[b].to<0)return null;return{ranges:x,ifd:o,actualTileWidth:s===m&&d%F||F,actualTileHeight:t===y&&w%S||S}}async _fetchAuxiliaryMetaData(e){try{const{data:t}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:e?.signal});return be(t)}catch{return null}}async _fetchAuxiliaryTable(e){try{const{data:t}=await this.request(this.url+".vat.dbf",{responseType:"array-buffer",signal:e?.signal}),s=rs.parse(t);return s?.recordSet?Pe.fromJSON(s.recordSet):null}catch{return null}}};function as(i){const e=Bt(i),{width:t,height:s,tileWidth:r,tileHeight:a,planes:n,pixelType:c,compression:l,firstPyramidLevel:o,maximumPyramidLevel:u,pyramidBlockWidth:p,pyramidBlockHeight:f,pyramidResolutions:h,tileBoundary:I,affine:y,metadata:m}=e,d=e.extent.spatialReference?.wkt||e.extent.spatialReference?.wkid;let w=ue(d),F=!!e.isPseudoGeographic;w==null&&(F=!0,w=new D({wkid:3857}));const S=new H({...e.extent,spatialReference:w}),x=new V(S?{x:S.xmin,y:S.ymax,spatialReference:w}:{x:0,y:0}),b=new we({blockWidth:r,blockHeight:a,pyramidBlockWidth:p,pyramidBlockHeight:f,compression:l,origin:x,firstPyramidLevel:o,maximumPyramidLevel:u,pyramidResolutions:h,blockBoundary:I}),g=new V({x:(S.xmax-S.xmin)/t,y:(S.ymax-S.ymin)/s,spatialReference:w}),v=m?{BandProperties:m.bandProperties,DataType:m.dataType}:{};let R=null;const k=te(i[0],"PHOTOMETRICINTERPRETATION"),_=ge(i[0],"COLORMAP");if(k<=3&&_?.length>3&&_.length%3==0){R=[];const M=_.length/3;for(let N=0;N<M;N++)R.push([N,_[N]>>>8,_[N+M]>>>8,_[N+2*M]>>>8])}const P=new le({width:t,height:s,bandCount:n,pixelType:c,pixelSize:g,storageInfo:b,spatialReference:w,isPseudoSpatialReference:F,keyProperties:v,extent:S,colormap:R,statistics:m?m.statistics:null});if(y?.length&&(P.nativeExtent=new H({xmin:-.5,ymin:.5-s,xmax:t-.5,ymax:.5,spatialReference:w}),P.transform=new xe({polynomialOrder:1,forwardCoefficients:[y[2]+y[0]/2,y[5]-y[3]/2,y[0],y[3],-y[1],-y[4]]}),P.extent=P.transform.forwardTransform(P.nativeExtent),P.pixelSize=new V({x:(S.xmax-S.xmin)/t,y:(S.ymax-S.ymin)/s,spatialReference:w}),b.origin.x=-.5,b.origin.y=.5),h){const{x:M,y:N}=P.pixelSize;h.forEach(L=>{L.x*=M,L.y*=N})}return{imageInfo:e,rasterInfo:P}}function ns(i,e){if(e.statistics=i.statistics??e.statistics,e.histograms=i.histograms,i.histograms&&e.statistics==null&&(e.statistics=ye(i.histograms)),i.transform&&e.transform==null){e.transform=i.transform,e.nativeExtent=e.extent;const t=e.transform.forwardTransform(e.nativeExtent);e.pixelSize=new V({x:(t.xmax-t.xmin)/e.width,y:(t.ymax-t.ymin)/e.height,spatialReference:e.spatialReference}),e.extent=t}e.isPseudoSpatialReference&&i.spatialReference&&(e.spatialReference=i.spatialReference,e.extent.spatialReference=e.nativeExtent.spatialReference=e.storageInfo.origin.spatialReference=e.spatialReference)}T([O()],U.prototype,"_files",void 0),T([O()],U.prototype,"_headerInfo",void 0),T([O()],U.prototype,"_bufferSize",void 0),T([O()],U.prototype,"_chunkSize",void 0),T([O({type:String,json:{write:!0}})],U.prototype,"datasetFormat",void 0),U=T([Y("esri.layers.support.rasterDatasets.TIFFRaster")],U);const os=U,E=new Map;E.set("MRF",{desc:"Meta Raster Format",constructor:ss}),E.set("TIFF",{desc:"GeoTIFF",constructor:os}),E.set("RasterTileServer",{desc:"Raster Tile Server",constructor:es}),E.set("JPG",{desc:"JPG Raster Format",constructor:re}),E.set("PNG",{desc:"PNG Raster Format",constructor:re}),E.set("GIF",{desc:"GIF Raster Format",constructor:re}),E.set("BMP",{desc:"BMP Raster Format",constructor:re}),E.set("CovJSON",{desc:"COVJSON Raster Format",constructor:Yt}),E.set("MEMORY",{desc:"In Memory Raster Format",constructor:Ie});class me{static get supportedFormats(){const e=new Set;return E.forEach((t,s)=>e.add(s)),e}static async open(e){const{url:t,ioConfig:s,source:r,sourceJSON:a}=e;let n=e.datasetFormat??s?.datasetFormat;n==null&&(t.includes(".")?n=t.slice(t.lastIndexOf(".")+1).toUpperCase():r?.type?.toLowerCase()==="coverage"?n="CovJSON":r?.extent&&r.pixelblocks&&(n="MEMORY")),n==="OVR"||n==="TIF"?n="TIFF":n==="JPG"||n==="JPEG"||n==="JFIF"?n="JPG":n==="COVJSON"&&(n="CovJSON"),t.toLowerCase().includes("/imageserver")&&!t.toLowerCase().includes("/wcsserver")&&(n="RasterTileServer");const c={url:t,source:r,sourceJSON:a,datasetFormat:n,ioConfig:s??{bandIds:null,sampling:null}};if(Object.keys(c).forEach(p=>{c[p]==null&&delete c[p]}),n){if(!this.supportedFormats.has(n))throw new C("rasterfactory:open","not a supported format "+n);if(n==="CRF")throw new C("rasterfactory:open",`cannot open raster: ${t}`);const p=new(E.get(n)).constructor(c);return await p.open({signal:e.signal}),p}const l=Array.from(E.keys()).filter(p=>p!=="CovJSON"&&p!=="Memory");let o=0;const u=()=>{if(n=l[o++],!n||n==="CRF")return null;const p=new(E.get(n)).constructor(c);return p.open({signal:e.signal}).then(()=>p).catch(()=>u())};return u()}static register(e,t,s){E.has(e.toUpperCase())||E.set(e.toUpperCase(),{desc:t,constructor:s})}}let $=class extends Qe(ft(it(at(ut(et(tt(nt(pt(Ze(ct(Xe(He.ClonableMixin(Ke))))))))))))){constructor(...i){super(...i),this._primaryRasters=[],this.legendEnabled=!0,this.isReference=null,this.listMode="show",this.sourceJSON=null,this.version=null,this.type="imagery-tile",this.operationalLayerType="ArcGISTiledImageServiceLayer",this.popupEnabled=!0,this.popupTemplate=null,this.fields=null,this.source=void 0,this._debouncedSaveOperations=Ge(async(e,t,s)=>{const{save:r,saveAs:a}=await De(()=>import("./imageryUtils-I21bTHSP.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]),import.meta.url);switch(e){case ie.SAVE:return r(this,t);case ie.SAVE_AS:return a(this,s,t)}})}normalizeCtorArgs(i,e){return typeof i=="string"?{url:i,...e}:i}load(i){const e=i!=null?i.signal:null;return this.addResolvingPromise(this.loadFromPortal({supportedTypes:["Image Service"]},i).catch(We).then(()=>this._openRaster(e))),Promise.resolve(this)}get defaultPopupTemplate(){return this.createPopupTemplate()}get rasterFields(){const i=[dt("Pixel Value"),gt("Raw Pixel Value")],e=this.raster?.rasterInfo??this.serviceRasterInfo,t=e?.attributeTable;if(t){const a=yt(t);i.push(...a)}const s=e?.dataType,r=e?.multidimensionalInfo;if((s==="vector-magdir"||s==="vector-uv")&&r!=null){const a=r.variables[0].unit?.trim(),n=wt(a),c=xt();i.push(n,c)}if(r){const a=It(r);i.push(...a)}return i}createPopupTemplate(i){const{rasterFields:e}=this,t=i?.visibleFieldNames??new Set(e.map(({name:a})=>a).filter(a=>a!==bt.rawServicePixelValue)),s=jt({fields:e,title:this.title},{...i,visibleFieldNames:t}),{rasterInfo:r}=this.raster;return s?.fieldInfos&&r&&vt(s.fieldInfos,r),s}async generateRasterInfo(i,e){if(i=qe(ke,i),await this.load(),!i||i.functionName?.toLowerCase()==="none")return this.serviceRasterInfo;try{const{rasterInfo:t}=await this._openFunctionRaster(i,e);return t}catch(t){throw t instanceof C?t:new C("imagery-tile-layer","the given raster function is not supported")}}async save(i){return this._debouncedSaveOperations(ie.SAVE,i)}async saveAs(i,e){return this._debouncedSaveOperations(ie.SAVE_AS,e,i)}write(i,e){const t=this._primaryRasters[0]??this.raster;if(this.loaded?t.datasetFormat==="RasterTileServer"&&(t.tileType==="Raster"||t.tileType==="Map"):this.url&&/\/ImageServer(\/|\/?$)/i.test(this.url))return super.write(i,e);if(e?.messages){const s=`${e.origin}/${e.layerContainerType||"operational-layers"}`;e.messages.push(new C("layer:unsupported",`Layers (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${s}'`,{layer:this}))}return null}async _openRaster(i){let e=!1;if(this.raster)await this._openFromRaster(this.raster,i),e=St(this.raster),!e&&this.rasterFunction&&(this._primaryRasters=[this.raster],await this._initializeWithFunctionRaster(this.rasterFunction));else{const{url:s,rasterFunction:r,source:a}=this;if(!s&&!a)throw new C("imagery-tile-layer:open","missing url or source parameter");a?await this._openFromSource(a,i):r?await this._openFromUrlWithRasterFunction(s,r,i):await this._openFromUrl(s,i)}const t=this.raster.rasterInfo;if(!t)throw new C("imagery-tile-layer:load","cannot load resources on "+this.url);if(this._set("serviceRasterInfo",e?t:this._primaryRasters[0].rasterInfo),this._set("spatialReference",t.spatialReference),this.sourceJSON=this.sourceJSON||this.raster.sourceJSON,this.sourceJSON!=null){const s=this.raster.tileType==="Map"&&this.sourceJSON.minLOD!=null&&this.sourceJSON.maxLOD!=null?this.sourceJSON:{...this.sourceJSON,minScale:0,maxScale:0};this.read(s,{origin:"service"})}else this.read({tileInfo:this.serviceRasterInfo?.storageInfo.tileInfo.toJSON()},{origin:"service"});this.title||(this.title=this.raster.datasetName),this.raster.tileType==="Map"&&(this.popupEnabled=!1),this._configDefaultSettings(),this.addHandles(Ve(()=>this.customParameters,s=>{this.raster&&(this.raster.ioConfig.customFetchParameters=s)}))}async _openFromRaster(i,e){i.rasterInfo||await i.open({signal:e}),this._primaryRasters=Tt(i),this.url||(this.url=this._primaryRasters[0].url)}async _openFromUrlWithRasterFunction(i,e,t){const s=[i];e&&zt(e.toJSON(),s);const r=await Promise.all(s.map(n=>me.open({url:n,sourceJSON:this.sourceJSON,ioConfig:{sampling:"closest",...this.ioConfig,customFetchParameters:this.customParameters},signal:t}))),a=r.findIndex(n=>n==null);if(a>-1)throw new C("imagery-tile-layer:open",`cannot open raster: ${s[a]}`);return this._primaryRasters=r,this._initializeWithFunctionRaster(e)}async _openFromUrl(i,e){const t=await me.open({url:i,sourceJSON:this.sourceJSON,ioConfig:{sampling:"closest",...this.ioConfig,customFetchParameters:this.customParameters},signal:e});if(t==null)throw new C("imagery-tile-layer:open",`cannot open raster: ${i}`);this._primaryRasters=[t],this.raster=t}async _openFromSource(i,e){const t="the tiled imagery data source is not supported",s=i.type?.toLowerCase()==="coverage"?"CovJSON":i.extent&&i.pixelBlock?"MEMORY":null;if(!s)throw new C("imagery-tile-layer:open",t);s==="MEMORY"&&(i={...i,pixelBlock:void 0,pixelBlocks:[i.pixelBlock]});const r=await me.open({url:"",source:i,datasetFormat:s,ioConfig:{sampling:"closest",...this.ioConfig,customFetchParameters:this.customParameters},signal:e});if(r==null)throw new C("imagery-tile-layer:open",t);this._primaryRasters=[r],this.rasterFunction?await this._initializeWithFunctionRaster(this.rasterFunction):this.raster=r}async _openFunctionRaster(i,e){const t={raster:this._primaryRasters[0]};this._primaryRasters.length>1&&this._primaryRasters.forEach(a=>t[a.url]=a);const s=Ut(i.functionDefinition?.toJSON()??i.toJSON(),t),r=new st({rasterFunction:s});return await r.open(e),r}async _initializeWithFunctionRaster(i,e){try{this.raster=await this._openFunctionRaster(i,e)}catch(t){t instanceof C&&de.getLogger(this).error("imagery-tile-layer:open",t.message),de.getLogger(this).warn("imagery-tile-layer:open","the raster function cannot be applied and is removed"),this._set("rasterFunction",null),this.raster=this._primaryRasters[0]}}};T([O({clonable:!1})],$.prototype,"_primaryRasters",void 0),T([O(rt)],$.prototype,"legendEnabled",void 0),T([O({type:Boolean,json:{read:!1,write:{enabled:!0,overridePolicy:()=>({enabled:!1})}}})],$.prototype,"isReference",void 0),T([O({type:["show","hide"]})],$.prototype,"listMode",void 0),T([O({json:{read:!0,write:!0}})],$.prototype,"blendMode",void 0),T([O({type:ke,json:{name:"renderingRule",write:!0}})],$.prototype,"rasterFunction",void 0),T([O()],$.prototype,"sourceJSON",void 0),T([O({readOnly:!0,json:{origins:{service:{read:{source:"currentVersion"}}}}})],$.prototype,"version",void 0),T([O({readOnly:!0,json:{read:!1}})],$.prototype,"type",void 0),T([O({type:["ArcGISTiledImageServiceLayer"]})],$.prototype,"operationalLayerType",void 0),T([O({type:Boolean,value:!0,json:{read:{source:"disablePopup",reader:(i,e)=>!e.disablePopup},write:{target:"disablePopup",overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"}},writer(i,e,t){e[t]=!i}}}})],$.prototype,"popupEnabled",void 0),T([O({type:Ye,json:{read:{source:"popupInfo"},write:{target:"popupInfo",overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"}}}}})],$.prototype,"popupTemplate",void 0),T([O({readOnly:!0})],$.prototype,"defaultPopupTemplate",null),T([O({readOnly:!0,type:[Se]})],$.prototype,"fields",void 0),T([O({readOnly:!0,type:[Se]})],$.prototype,"rasterFields",null),T([O({constructOnly:!0})],$.prototype,"source",void 0),$=T([Y("esri.layers.ImageryTileLayer")],$);const Ei=$;export{Ei as default};
