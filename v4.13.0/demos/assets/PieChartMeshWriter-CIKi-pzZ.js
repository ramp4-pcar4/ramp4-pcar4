const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./geometryEngineJSON-jmZ-ASIo.js","./geometryEngineBase-C-7zg03I.js","./_commonjsHelpers-DCkdB7M8.js","./json-Wa8cmqdu.js"])))=>i.map(i=>d[i]);
import{s as st,t as b,a as lt,R as Pe,c as ut,i as ve,l as we,G as Te,A as Me}from"./definitions-CASyCajO.js";import{bj as jt,i as Jt,s as $e,kS as Ee,gO as Ae,bU as y,aq as ze,dC as Ie,ah as Ot}from"./main-6eEsl9OJ.js";import{o as E,y as B,r as yt,e as Yt,a as gt}from"./UpdateTracking2D-DDb-IRK6.js";import{O as u}from"./enums-UBzvFP7O.js";import{c as Kt,i as te,l as De}from"./GeometryUtils-VYshlWMq.js";import{C as Le,q as ee,B as se,M as Fe,K as ht,L as Rt,F as Ne,H as Oe,D as Ye,E as Re}from"./constants-BFLErLYb.js";import{w as H,e as _t,G as kt,a as St,n as pt,i as ie}from"./enums-_AFKM9Yk.js";import{S as Be,Z as Bt,R as Ct,s as Gt,b as I,O as Ce,g as Ge,j as Ue,k as We}from"./CIMSymbolHelper-bvW1zimp.js";import{a as He,c as Xe,i as Ve}from"./libtess-WLRQrdls.js";import{t as Ze,e as qe,f as Qe,g as re}from"./Utils-DTf8bb9E.js";import{D as ne}from"./utils-BV7DBUkI.js";import"./earcut-D9gy186-.js";import{e as je}from"./OptimizedGeometry-OYT6ACAY.js";import{a as Je,i as Ke,s as ts}from"./mat2d-D9DBP-jx.js";import{n as es}from"./mat2df32-Dpt2CT5P.js";import{S as rt}from"./vec2-ChnYg_BJ.js";import{r as nt}from"./rasterizingUtils-SjltlEdr.js";import{_ as ss}from"./preload-helper-B76NpbEU.js";let oe=class{static getPlacement(t,e,r,i,n,o){const a=Be(r);return a?(e===-1&&t.invertY(),a.execute(t,r,i,n,o)):null}};const is=()=>Jt.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.meshWriterUtils"),rs=0,ns=100;function Z(s,t){return[!!s?.minScale&&t.scaleToZoom(s.minScale)||rs,!!s?.maxScale&&t.scaleToZoom(s.maxScale)||ns]}function w(s){return 1<<s}function q(s){let t=0;for(const[e,r]of s)r&&(t|=1<<e);return t}function _(s){let t;if(!s)return[0,0,0,0];if(typeof s=="string"){const o=jt.fromString(s);if(!o)return is().errorOnce(new $e("mapview:mesh-processing","Unable to parse string into color",{color:s})),[0,0,0,0];t=o.toArray()}else t=s;const[e,r,i,n]=t;return[e*(n/255),r*(n/255),i*(n/255),n]}function os(s){switch(s){case"butt":case H.Butt:return _t.BUTT;case"round":case H.Round:return _t.ROUND;case"square":case H.Square:return _t.SQUARE}}function as(s){switch(s){case"bevel":case kt.Bevel:return St.BEVEL;case"miter":case kt.Miter:return St.MITER;case"round":case kt.Round:return St.ROUND}}function bt(s,t){return Math.round(Math.min(Math.sqrt(s*t),255))}function ot(s,t){return Math.round(s*t)/t}const cs=96/72;let ls=class{static executeEffects(t,e,r,i,n){const o=cs,a=Bt(t);let c=new Gt(e);for(const h of t){const l=Ct(h);l&&(c=l.execute(c,h,o,r,i,a,n))}return c}static applyEffects(t,e,r){if(!t)return e;const i=Bt(t);let n,o=new Gt(I.fromJSONCIM(e));for(const h of t){const l=Ct(h);l&&(o=l.execute(o,h,1,null,r,i,!1))}const a=[];let c=null;for(;n=o.next();)a.push(...Ee(n)),c=n.geometryType;return a.length===0||c===null?null:c==="esriGeometryPolygon"?{rings:a}:{paths:a}}},ae=null;function zt(){return ae}async function us(){ae=await ss(()=>import("./geometryEngineJSON-jmZ-ASIo.js").then(s=>s.g),__vite__mapDeps([0,1,2,3]),import.meta.url)}function ce(s){switch(s){case u.BYTE:case u.UNSIGNED_BYTE:return 1;case u.SHORT:case u.UNSIGNED_SHORT:case u.HALF_FLOAT:return 2;case u.FLOAT:case u.INT:case u.UNSIGNED_INT:return 4}}function hs(s){const t=[],e=[],r=[];for(const i of s){const n=ce(i.type)*i.count;switch(n%2||n%4||4){case 4:t.push(i);continue;case 2:e.push(i);continue;case 1:r.push(i);continue;default:throw new Error("Found unexpected dataType byte count")}}return t.push(...e),t.push(...r),t}let ps=class le{static fromVertexSpec(t,e){const{attributes:r,optionalAttributes:i}=t;let n,o,a;const c=[];for(const x in r){if(r[x].otherSource)continue;const g=r[x];g.pack==="position"?n={...g,name:x,offset:0}:g.pack==="id"?o={...g,name:x,offset:4}:x==="bitset"?a={...g,name:x,offset:7}:c.push({...g,name:x})}for(const x in i)if(e[x]===!0){const g=i[x];c.push({...g,name:x})}const h=hs(c),l=[];let d=8,m=1;for(const x of h)l.push({...x,offset:d}),d+=ce(x.type)*x.count,x.packAlternating&&(m=Math.max(x.packAlternating.count,m));const p=Uint32Array.BYTES_PER_ELEMENT,f=d%p;return new le(n,o,a,l,d+(f?p-f:0),m)}constructor(t,e,r,i,n,o){this.position=t,this.id=e,this.bitset=r,this.standardAttributes=i,this.stride=n,this.packVertexCount=o,i.push(r),this._attributes=[t,e,r,...i]}get attributeLayout(){if(!this._attributeLayout){const t=Ze(this._attributes),e=this._attributes.map(r=>({name:r.name,count:r.count,offset:r.offset,type:r.type,packPrecisionFactor:r.packPrecisionFactor,normalized:r.normalized??!1}));this._attributeLayout={attributes:e,hash:t,stride:this.stride}}return this._attributeLayout}},fs=class ue{static fromVertexSpec(t,e){const r=ps.fromVertexSpec(t,e);return new ue(r)}constructor(t){this._spec=t,this._packed=new Uint8Array(this._spec.stride*this._spec.packVertexCount),this._packedU32View=new Uint32Array(this._packed.buffer),this._dataView=new DataView(this._packed.buffer)}get attributeLayout(){return this._spec.attributeLayout}get stride(){return this._spec.stride}writeVertex(t,e,r,i,n,o){for(let a=0;a<this._spec.packVertexCount;a++){const c=a*this._spec.stride;this._packPosition(r,i,c),this._packId(e,c);const h=this._spec.bitset;if(o){if(h.packTessellation){const l=h.packTessellation(o,n,r,i);this._pack(l,h,c)}for(const l of this._spec.standardAttributes)if(l.packTessellation!=null){const d=l.packTessellation(o,n,r,i);this._pack(d,l,c)}else if(l.packAlternating?.packTessellation){const d=l.packAlternating.packTessellation(o,n,r,i);for(let m=0;m<this._spec.packVertexCount;m++){const p=d[m];this._pack(p,l,m*this._spec.stride)}}}}t.vertexWriteRegion(this._packedU32View)}pack(t,e){for(const r of this._spec.standardAttributes)if(r.pack&&typeof r.pack!="string"){const i=r.pack(t,e);for(let n=0;n<this._spec.packVertexCount;n++)this._pack(i,r,n*this._spec.stride)}else if(r.packAlternating?.pack){const i=r.packAlternating.pack(t,e);for(let n=0;n<this._spec.packVertexCount;n++){const o=i[n];this._pack(o,r,n*this._spec.stride)}}}_packPosition(t,e,r){const{offset:i}=this._spec.position,n=this._spec.position.packPrecisionFactor??1,o=qe(t*n,e*n);this._dataView.setUint32(r+i,o,!0)}_packId(t,e){const r=t*(this._spec.id.packPrecisionFactor??1),i=4278190080&this._dataView.getUint32(e+this._spec.id.offset,!0);this._dataView.setUint32(e+this._spec.id.offset,r|i,!0)}_pack(t,e,r){Qe(this._dataView,t,e,r)}};function ds(s){if(!s)return!1;for(const t of s)switch(t.effect.type){case"CIMGeometricEffectBuffer":case"CIMGeometricEffectDonut":case"CIMGeometricEffectOffset":case"CIMGeometricEffectTaperedPolygon":case"CIMGeometricEffectEnclosingPolygon":return!0}return!1}let G=class{constructor(t,e,r,i){this._instanceId=t,this._evaluator=e,this._enabledOptionalAttributes=r,this._viewParams=i,this._evaluator.evaluator=n=>this.vertexSpec.createComputedParams(n)}get _vertexPack(){if(!this._cachedVertexPack){const t=fs.fromVertexSpec(this.vertexSpec,this._enabledOptionalAttributes);this._evaluator.hasDynamicProperties||t.pack(this._evaluator.evaluatedMeshParams,this._viewParams),this._cachedVertexPack=t}return this._cachedVertexPack}get evaluatedMeshParams(){return this._evaluator.evaluatedMeshParams}get hasEffects(){return!!this.evaluatedMeshParams.effects}get effectInfos(){return this._evaluator.inputMeshParams.effects?.effectInfos}get instanceId(){return this._instanceId}get attributeLayout(){return this._vertexPack.attributeLayout}get _preventEffectClipping(){return!1}setReferences(t){this._references=t}getBoundsInfo(){return null}getTileInfo(){return this._viewParams.tileInfo}async loadDependencies(){ds(this.effectInfos)&&await us()}enqueueRequest(t,e,r){this._evaluator.hasDynamicProperties&&this._evaluator.enqueueRequest(t,e,r)}write(t,e,r,i,n){this.ensurePacked(e,r,i);const o=this.evaluatedMeshParams.effects;if(!o||o.length===0)return void this._write(t,r,void 0,n);const a=this.getEffectCursor(t,r,o);if(!a)return;let c;for(;c=a.next();)c.invertY(),this._write(t,r,c,n)}ensurePacked(t,e,r){if(!this._evaluator.hasDynamicProperties)return;const i=this._evaluator.evaluateMeshParams(t,e,r);this._vertexPack.pack(i,this._viewParams)}hasArcadeDependency(t){return this._evaluator.hasArcadeDependency(t)}_writeVertex(t,e,r,i,n){const o=this.evaluatedMeshParams;this._vertexPack.writeVertex(t,e,r,i,o,n)}getEffectCursor(t,e,r){const i=e.readGeometryForDisplay()?.clone();if(!i)return;const n=I.fromOptimizedCIM(i,e.geometryType),o=zt();n.invertY();const a=t.id||"";return ls.executeEffects(r,n,a,o,this._preventEffectClipping)}},Ki=class extends G{};function ms(s){const{sprite:t,isMapAligned:e,colorLocked:r,scaleSymbolsProportionally:i,isStroke:n}=s;let o=0;return e&&(o|=w(E.bitset.isMapAligned)),r&&(o|=w(E.bitset.colorLocked)),t.sdf&&(o|=w(E.bitset.isSDF)),i&&(o|=w(E.bitset.scaleSymbolsProportionally)),n&&(o|=w(E.bitset.isStroke)),o}function he(s,t){let e;if(typeof s=="string")e=Ae(s+`-seed(${t})`);else{let r=12;e=s^t;do e=107*(e>>8^e)+r|0;while(--r!==0)}return(1+e/(1<<31))/2}function xs(s){return Math.floor(he(s,ys)*gs)}const ys=53290320,gs=10;function xt(s){return s instanceof it?s:typeof s=="object"&&"type"in s?bs[s.type].hydrate(s):new X(s)}let it=class{constructor(t){this.inputs=t}encode(){const t=[];for(const e of this.inputs)t.push(...e.encode());return t.push(...this.instructions),t}},X=class extends it{constructor(t){super([]),this.value=t}simplify(){return this}get instructions(){if(Array.isArray(this.value)){const[t,e,r,i]=this.value;return i!=null?B.vector4.encode([t,e||0,r||0,i]):B.vector3.encode([t,e||0,r||0])}return B.scalar.encode(this.value)}},_s=class Pt extends it{constructor(t,e){super([e]),this._config=t,this._parent=e}static hydrate(t){return new Pt(t,xt(t.parent))}simplify(){if(this._config.relativeTranslation||this._config.absoluteScale)return this;const t=this._parent.simplify();if(!(t instanceof X))return this;const[e,r,i,n]=t.value,o=this._config.translation.from[0],a=this._config.translation.from[1],c=this._config.rotation.from,h=this._config.scale.from;if(o===this._config.translation.to[0]&&a===this._config.translation.to[1]&&c===this._config.rotation.to&&h===this._config.scale.to){const l=i+c,d=n*h,m=Math.sin(i),p=Math.cos(i);return new X([p*n*o-m*n*a+e,m*n*o+p*n*a+r,l,d])}return new Pt(this._config,t)}get instructions(){return B.animatedTransform.encode(this._config)}},ks=class vt extends it{constructor(t,e){super([e]),this._config=t,this._parent=e}static hydrate(t){return new vt(t,xt(t.parent))}simplify(){const t=this._parent.simplify();if(!(t instanceof X))return this;const[e,r,i,n]=t.value,o=this._config.color.from[0],a=this._config.color.from[1],c=this._config.color.from[2];let h=this._config.color.from[3];const l=this._config.opacity.from;return o===this._config.color.to[0]&&a===this._config.color.to[1]&&c===this._config.color.to[2]&&h===this._config.color.to[3]&&l===this._config.opacity.to?(h*=l,new X([e*o,r*a,i*c,n*h])):new vt(this._config,t)}get instructions(){return B.animatedColor.encode(this._config)}},Ss=class wt extends it{constructor(t,e){super([e]),this._config=t,this._parent=e}static hydrate(t){return new wt(t,xt(t.parent))}simplify(){const t=this._parent.simplify();return t instanceof X?new wt(this._config,t):this}get instructions(){return B.animatedShift.encode(this._config)}};const bs={AnimatedTransform:_s,AnimatedColor:ks,AnimatedShift:Ss};function ir(s){return Ps(s.map(t=>S(t)).map(t=>xt(t).simplify()))}function rr(s){const t=[];return t.push(s.transform),t.push(s.fromColor),t.push(s.toColor),t.push(s.colorMix),t.push(s.toOpacity),t.push(s.opacityMix),s?.shift?t.push(s?.shift):t.push([1,1,1,1]),t}function Ps(s){const t=[],e=[];let r=0;for(const i of s){const n=[...i.encode(),...B.ret.encode()];t.push([r+s.length,0,0,0]),e.push(...n),r+=n.length}return[...t,...e]}async function Ut(s,t){const e=s;let r;if(typeof e=="number"||typeof e=="string"||typeof e=="boolean")r=e;else if(Array.isArray(e))r=await Promise.all(e.map(i=>Ut(i,t)));else if(typeof e=="object")if("valueExpressionInfo"in e){const{valueExpressionInfo:i}=e,{expression:n}=i;r={...e,computed:await t.createComputedField({expression:n})}}else{r={};for(const i in e)r[i]=await Ut(e[i],t)}return r}function S(s,t,e){function r(o){if(!("computed"in o))return o;let a=o.computed.readWithDefault(t,e,[255*o.defaultValue[0],255*o.defaultValue[1],255*o.defaultValue[2],o.defaultValue[3]]);if(typeof a=="string"){const c=jt.fromString(a);c&&(a=[c.r,c.g,c.b,c.a])}return a}const i=s;let n;if(typeof i=="number"||typeof i=="string"||typeof i=="boolean")n=i;else if(Array.isArray(i))n=i.map(o=>S(o,t,e));else if(typeof i=="object")if("type"in i&&i.type!=null&&i.type==="Process")switch(i.op){case"ArcadeColor":{const o=S(i.value,t,e);Q(Array.isArray(o)&&o.length===4),n=[o[0]/255,o[1]/255,o[2]/255,o[3]]}break;case"Transparency":{const o=S(i.value,t,e);Q(typeof o=="number"),n=1-o/100}break;case"Divide":case"Multiply":case"Add":{const o=S(i.left,t,e);Q(typeof o=="number");const a=S(i.right,t,e);switch(Q(typeof a=="number"),i.op){case"Divide":n=o/a;break;case"Multiply":n=o*a;break;case"Add":n=o+a}}break;case"Random":{const o=S(i.seed,t,e),a=S(i.min,t,e),c=S(i.max,t,e),h=t.getObjectId(),l=xs(h||0);n=a+he(l,o)*(c-a)}break;case"Cond":{const o=S(i.condition,t,e),a=S(i.ifTrue,t,e),c=S(i.ifFalse,t,e);n=o?a:c}break;case"MatchWinding":{const o=S(i.sign,t,e);let a=S(i.angle,t,e);if(o>0)for(;a<0;)a+=2*Math.PI;else for(;a>0;)a-=2*Math.PI;n=a}}else if("computed"in i)n=r(i);else{n={};for(const o in i)n[o]=S(i[o],t,e)}return n}function*v(s){const t=s;if(Array.isArray(t))for(const e of t)yield*v(e);else if(typeof t=="object")if("type"in t&&t.type!=null&&t.type==="Process")switch(t.op){case"ArcadeColor":case"Transparency":yield*v(t.value);break;case"Divide":case"Multiply":case"Add":yield*v(t.left),yield*v(t.right);break;case"Random":yield*v(t.seed),yield*v(t.min),yield*v(t.max);break;case"Cond":yield*v(t.condition),yield*v(t.ifTrue),yield*v(t.ifFalse);break;case"MatchWinding":yield*v(t.sign),yield*v(t.angle)}else if("computed"in t)yield t.computed;else for(const e in t)yield*v(t[e])}function Q(s){if(!s)throw new Error("Assertion failed.")}const nr={type:u.SHORT,count:2,packPrecisionFactor:st,pack:({scaleInfo:s},{tileInfo:t})=>Z(s,t)},or={type:u.FLOAT,count:4,packPrecisionFactor:1,packTessellation:({value1Position2Value2:s})=>(Q(s),s)},ar={type:u.FLOAT,count:4,packPrecisionFactor:1,packTessellation:()=>[0,0,0,1]},cr={type:u.FLOAT,count:1,packPrecisionFactor:1,pack:()=>0},lr={type:u.FLOAT,count:1,packPrecisionFactor:1,packTessellation:({lineLength:s})=>s},ur={type:u.UNSIGNED_SHORT,count:1,packTessellation:({distance:s})=>s},hr={type:u.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:s,directionY:t})=>[s,t]},pr={type:u.FLOAT,count:2,packPrecisionFactor:16,packTessellation:({normalX:s,normalY:t})=>[s,t]},fr={type:u.UNSIGNED_BYTE,count:3,pack:"id"},dr={type:u.UNSIGNED_BYTE,count:1,pack:ms},mr={type:u.SHORT,count:2,pack:"position",packPrecisionFactor:1},xr={marker:{type:u.FLOAT,count:2,packAlternating:{count:4,pack:({texelDimensions:s})=>[[-.5*s[0],-.5*s[1]],[.5*s[0],-.5*s[1]],[-.5*s[0],.5*s[1]],[.5*s[0],.5*s[1]]]}},line:{type:u.FLOAT,count:2,packTessellation:({extrusionOffsetX:s,extrusionOffsetY:t},{baseSize:e})=>[s*e/2,t*e/2]},fill:{type:u.FLOAT,count:2,packTessellation:()=>[0,0]}},yr={marker:{type:u.SHORT,count:2,packPrecisionFactor:1,packAlternating:{count:4,packTessellation:({texXmax:s,texXmin:t,texYmax:e,texYmin:r})=>[[t,r],[s,r],[t,e],[s,e]]}}},gr={type:u.UNSIGNED_SHORT,count:4,pack:({sprite:s})=>{const{rect:t,width:e,height:r}=s,i=t.x+b,n=t.y+b;return[i+1,n+1,i+e-1,n+r-1]}},_r={type:u.UNSIGNED_SHORT,count:4,packPrecisionFactor:4,pack:({animations:s,baseSize:t,referenceSize:e})=>[s.dataColumn,s.dataRow,t,e]},kr={type:u.UNSIGNED_SHORT,count:4,packPrecisionFactor:8,pack:({strokeWidth:s,pixelDimensions:t,baseSize:e,sprite:r,sizeRatio:i})=>{const n=Math.max(e*r.width/r.height,e),o=r.sdfDecodeCoeff*n*i;return[t[0],t[1],s,o]}},Sr={type:u.BYTE,count:1,packTessellation:({angle:s})=>s};function vs(s,t,e,r,i,n,o){$t=0;const a=(r-e)*n,c=i&&i.length,h=c?(i[0]-e)*n:a;let l,d,m,p,f,x=pe(t,e,r,0,h,n,!0);if(x&&x.next!==x.prev){if(c&&(x=$s(t,e,r,i,x,n)),a>80*n){l=m=t[0+e*n],d=p=t[1+e*n];for(let g=n;g<h;g+=n){const P=t[g+e*n],M=t[g+1+e*n];l=Math.min(l,P),d=Math.min(d,M),m=Math.max(m,P),p=Math.max(p,M)}f=Math.max(m-l,p-d),f=f!==0?1/f:0}J(x,s,n,l,d,f,o,0)}}function pe(s,t,e,r,i,n,o){let a;if(o===Ds(s,t,e,r,i,n)>0)for(let c=r;c<i;c+=n)a=Wt(c+t*n,s[c+t*n],s[c+1+t*n],a);else for(let c=i-n;c>=r;c-=n)a=Wt(c+t*n,s[c+t*n],s[c+1+t*n],a);return a&&R(a,a.next)&&(K(a),a=a.next),a}function j(s,t=s){if(!s)return s;let e,r=s;do if(e=!1,r.steiner||!R(r,r.next)&&k(r.prev,r,r.next)!==0)r=r.next;else{if(K(r),r=t=r.prev,r===r.next)break;e=!0}while(e||r!==t);return t}function J(s,t,e,r,i,n,o,a){if(!s)return;!a&&n&&(s=fe(s,r,i,n));let c=s;for(;s.prev!==s.next;){const h=s.prev,l=s.next;if(n?Ts(s,r,i,n):ws(s))t.push(h.index/e+o),t.push(s.index/e+o),t.push(l.index/e+o),K(s),s=l.next,c=l.next;else if((s=l)===c){a?a===1?J(s=Fs(s,t,e,o),t,e,r,i,n,o,2):a===2&&Ns(s,t,e,r,i,n,o):J(j(s),t,e,r,i,n,o,1);break}}}function ws(s){const t=s.prev,e=s,r=s.next;if(k(t,e,r)>=0)return!1;let i=s.next.next;const n=i;let o=0;for(;i!==s.prev&&(o===0||i!==n);){if(o++,W(t.x,t.y,e.x,e.y,r.x,r.y,i.x,i.y)&&k(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function Ts(s,t,e,r){const i=s.prev,n=s,o=s.next;if(k(i,n,o)>=0)return!1;const a=i.x<n.x?i.x<o.x?i.x:o.x:n.x<o.x?n.x:o.x,c=i.y<n.y?i.y<o.y?i.y:o.y:n.y<o.y?n.y:o.y,h=i.x>n.x?i.x>o.x?i.x:o.x:n.x>o.x?n.x:o.x,l=i.y>n.y?i.y>o.y?i.y:o.y:n.y>o.y?n.y:o.y,d=Tt(a,c,t,e,r),m=Tt(h,l,t,e,r);let p=s.prevZ,f=s.nextZ;for(;p&&p.z>=d&&f&&f.z<=m;){if(p!==s.prev&&p!==s.next&&W(i.x,i.y,n.x,n.y,o.x,o.y,p.x,p.y)&&k(p.prev,p,p.next)>=0||(p=p.prevZ,f!==s.prev&&f!==s.next&&W(i.x,i.y,n.x,n.y,o.x,o.y,f.x,f.y)&&k(f.prev,f,f.next)>=0))return!1;f=f.nextZ}for(;p&&p.z>=d;){if(p!==s.prev&&p!==s.next&&W(i.x,i.y,n.x,n.y,o.x,o.y,p.x,p.y)&&k(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;f&&f.z<=m;){if(f!==s.prev&&f!==s.next&&W(i.x,i.y,n.x,n.y,o.x,o.y,f.x,f.y)&&k(f.prev,f,f.next)>=0)return!1;f=f.nextZ}return!0}function Wt(s,t,e,r){const i=V.create(s,t,e);return r?(i.next=r.next,i.prev=r,r.next.prev=i,r.next=i):(i.prev=i,i.next=i),i}function K(s){s.next.prev=s.prev,s.prev.next=s.next,s.prevZ&&(s.prevZ.nextZ=s.nextZ),s.nextZ&&(s.nextZ.prevZ=s.prevZ)}function Ms(s){let t=s,e=s;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==s);return e}function $s(s,t,e,r,i,n){const o=new Array;for(let a=0,c=r.length;a<c;a++){const h=pe(s,t,e,r[a]*n,a<c-1?r[a+1]*n:e*n,n,!1);h===h.next&&(h.steiner=!0),o.push(Ms(h))}o.sort(Ls);for(const a of o)i=Es(a,i);return i}function Es(s,t){const e=As(s,t);if(!e)return t;const r=me(e,s);return j(r,r.next),j(e,e.next)}function As(s,t){let e=t;const r=s.x,i=s.y;let n,o=-1/0;do{if(i<=e.y&&i>=e.next.y&&e.next.y!==e.y){const m=e.x+(i-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(m<=r&&m>o){if(o=m,m===r){if(i===e.y)return e;if(i===e.next.y)return e.next}n=e.x<e.next.x?e:e.next}}e=e.next}while(e!==t);if(!n)return null;if(r===o)return n.prev;const a=n,c=n.x,h=n.y;let l,d=1/0;for(e=n.next;e!==a;)r>=e.x&&e.x>=c&&r!==e.x&&W(i<h?r:o,i,c,h,i<h?o:r,i,e.x,e.y)&&(l=Math.abs(i-e.y)/(r-e.x),(l<d||l===d&&e.x>n.x)&&tt(e,s)&&(n=e,d=l)),e=e.next;return n}function fe(s,t,e,r){let i;for(;i!==s;i=i.next){if(i=i||s,i.z===null&&(i.z=Tt(i.x,i.y,t,e,r)),i.prev.next!==i||i.next.prev!==i)return i.prev.next=i,i.next.prev=i,fe(s,t,e,r);i.prevZ=i.prev,i.nextZ=i.next}return s.prevZ.nextZ=null,s.prevZ=null,zs(s)}function zs(s){let t,e=1;for(;;){let r,i=s;s=null,t=null;let n=0;for(;i;){n++,r=i;let o=0;for(;o<e&&r;o++)r=r.nextZ;let a=e;for(;o>0||a>0&&r;){let c;o===0?(c=r,r=r.nextZ,a--):a!==0&&r?i.z<=r.z?(c=i,i=i.nextZ,o--):(c=r,r=r.nextZ,a--):(c=i,i=i.nextZ,o--),t?t.nextZ=c:s=c,c.prevZ=t,t=c}i=r}if(t.nextZ=null,e*=2,n<2)return s}}function k(s,t,e){return(t.y-s.y)*(e.x-t.x)-(t.x-s.x)*(e.y-t.y)}function de(s,t,e,r){return!!(R(s,t)&&R(e,r)||R(s,r)&&R(e,t))||k(s,t,e)>0!=k(s,t,r)>0&&k(e,r,s)>0!=k(e,r,t)>0}function Is(s,t){let e=s;do{if(e.index!==s.index&&e.next.index!==s.index&&e.index!==t.index&&e.next.index!==t.index&&de(e,e.next,s,t))return!0;e=e.next}while(e!==s);return!1}function Ds(s,t,e,r,i,n){let o=0;for(let a=r,c=i-n;a<i;a+=n)o+=(s[c+t*n]-s[a+t*n])*(s[a+1+t*n]+s[c+1+t*n]),c=a;return o}function W(s,t,e,r,i,n,o,a){return(i-o)*(t-a)-(s-o)*(n-a)>=0&&(s-o)*(r-a)-(e-o)*(t-a)>=0&&(e-o)*(n-a)-(i-o)*(r-a)>=0}function tt(s,t){return k(s.prev,s,s.next)<0?k(s,t,s.next)>=0&&k(s,s.prev,t)>=0:k(s,t,s.prev)<0||k(s,s.next,t)<0}function Tt(s,t,e,r,i){return(s=1431655765&((s=858993459&((s=252645135&((s=16711935&((s=32767*(s-e)*i)|s<<8))|s<<4))|s<<2))|s<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-r)*i)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function R(s,t){return s.x===t.x&&s.y===t.y}function Ls(s,t){return s.x-t.x}function Fs(s,t,e,r){let i=s;do{const n=i.prev,o=i.next.next;!R(n,o)&&de(n,i,i.next,o)&&tt(n,o)&&tt(o,n)&&(t.push(n.index/e+r),t.push(i.index/e+r),t.push(o.index/e+r),K(i),K(i.next),i=s=o),i=i.next}while(i!==s);return i}function Ns(s,t,e,r,i,n,o){let a=s;do{let c=a.next.next;for(;c!==a.prev;){if(a.index!==c.index&&Os(a,c)){let h=me(a,c);return a=j(a,a.next),h=j(h,h.next),J(a,t,e,r,i,n,o,0),void J(h,t,e,r,i,n,o,0)}c=c.next}a=a.next}while(a!==s)}function Os(s,t){return s.next.index!==t.index&&s.prev.index!==t.index&&!Is(s,t)&&tt(s,t)&&tt(t,s)&&Ys(s,t)}function Ys(s,t){let e=s,r=!1;const i=(s.x+t.x)/2,n=(s.y+t.y)/2;do e.y>n!=e.next.y>n&&e.next.y!==e.y&&i<(e.next.x-e.x)*(n-e.y)/(e.next.y-e.y)+e.x&&(r=!r),e=e.next;while(e!==s);return r}function me(s,t){const e=V.create(s.index,s.x,s.y),r=V.create(t.index,t.x,t.y),i=s.next,n=t.prev;return s.next=t,t.prev=s,e.next=i,i.prev=e,r.next=e,e.prev=r,n.next=r,r.prev=n,r}class V{constructor(){this.index=0,this.x=0,this.y=0,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}static create(t,e,r){const i=$t<Mt.length?Mt[$t++]:new V;return i.index=t,i.x=e,i.y=r,i.prev=null,i.next=null,i.z=null,i.prevZ=null,i.nextZ=null,i.steiner=!1,i}}const Mt=[],Rs=8096;let $t=0;for(let s=0;s<Rs;s++)Mt.push(new V);const Bs=1e-5,Y=new Kt(0,0,0,1,0),Et=new Kt(0,0,0,1,0);function Ht(s,t,e){let r=0;for(let i=1;i<e;i++){const n=s[2*(t+i-1)],o=s[2*(t+i-1)+1];r+=(s[2*(t+i)]-n)*(s[2*(t+i)+1]+o)}return r}function Cs(s,t,e,r,i){let n=0;const o=2;for(let a=e;a<r;a+=3){const c=(s[a]-i)*o,h=(s[a+1]-i)*o,l=(s[a+2]-i)*o;n+=Math.abs((t[c]-t[l])*(t[h+1]-t[c+1])-(t[c]-t[h])*(t[l+1]-t[c+1]))}return n}function Gs(s,t){const{coords:e,lengths:r}=t,i=0,n=s;let o=0;for(let a=0;a<r.length;){let c=a,h=r[a],l=Ht(e,o,h);const d=[];for(;++c<r.length;){const x=r[c],g=Ht(e,o+h,x);if(!(g>0))break;l+=g,d.push(o+h),h+=x}const m=n.length;vs(n,e,o,o+h,d,2,i);const p=Cs(n,e,m,n.length,i),f=Math.abs(l);if(Math.abs((p-f)/Math.max(1e-7,f))>Bs)return n.length=0,!1;a=c,o+=h}return!0}function Us(s){const{coords:t,lengths:e}=s,{buffer:r}=He(t,e);return r}function Ws(s,t,e){let r=0;for(let i=0;i<s.lengths.length;i++){const n=s.lengths[i];for(let o=0;o<n;o++){const a=s.coords[2*(o+r)],c=s.coords[2*(o+r)+1];if(a<t||a>e||c<t||c>e)return!0}r+=n}return!1}function xe(s,t){if(s==null)return null;if(!Ws(s,-128,lt+128))return s;Y.setPixelMargin(t),Y.reset(te.Polygon);let e=0;for(let o=0;o<s.lengths.length;o++){const a=s.lengths[o];let c=s.coords[2*(0+e)],h=s.coords[2*(0+e)+1];Y.moveTo(c,h);for(let l=1;l<a;l++)c=s.coords[2*(l+e)],h=s.coords[2*(l+e)+1],Y.lineTo(c,h);Y.close(),e+=a}const r=Y.result(!1);if(!r)return null;const i=[],n=[];for(const o of r){let a=0;for(const c of o)n.push(c.x),n.push(c.y),a++;i.push(a)}return new je(i,n)}function Hs(s,t){Et.setPixelMargin(t);const e=Et,r=-t,i=lt+t;let n=[],o=!1;if(!s.nextPath())return null;let a=s.pathLength(),c=!0;for(;c;){s.seekPathStart();const h=[];if(!s.pathSize)return null;e.reset(te.LineString),s.nextPoint();let l=s.x,d=s.y;if(o)e.moveTo(l,d);else{if(l<r||l>i||d<r||d>i){o=!0;continue}h.push({x:l,y:d})}let m=!1;for(;s.nextPoint();)if(l=s.x,d=s.y,o)e.lineTo(l,d);else{if(l<r||l>i||d<r||d>i){m=!0;break}h.push({x:l,y:d})}if(m)o=!0;else{if(o){const p=e.resultWithStarts();if(p)for(const f of p)n.push({...f,pathLength:a})}else n.push({line:h,start:0,pathLength:a});c=s.nextPath(),a=c?s.pathLength():0,o=!1}}return n=n.filter(h=>h.line.length>1),n.length===0?null:n}Y.setExtent(lt),Et.setExtent(lt);let Xs=class{constructor(){this.extrusionOffsetX=0,this.extrusionOffsetY=0,this.normalX=0,this.normalY=0,this.directionX=0,this.directionY=0,this.distance=0,this.pathLength=0,this.distanceOffset=0,this.lineLength=0}};const D={createComputedParams:s=>s,optionalAttributes:{zoomRange:{type:u.SHORT,count:2,packPrecisionFactor:st,pack:({scaleInfo:s},{tileInfo:t})=>Z(s,t)}},attributes:{id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},bitset:{type:u.UNSIGNED_BYTE,count:1},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:s})=>_(s)},offset:{type:u.BYTE,count:2,packPrecisionFactor:16,packTessellation:({extrusionOffsetX:s,extrusionOffsetY:t})=>[ot(s,16),ot(t,16)]},normal:{type:u.BYTE,count:2,packPrecisionFactor:16,packTessellation:({normalX:s,normalY:t})=>[ot(s,16),ot(t,16)]},halfWidth:{type:u.HALF_FLOAT,count:1,pack:({width:s})=>y(.5*s)},referenceHalfWidth:{type:u.HALF_FLOAT,count:1,pack:({referenceWidth:s})=>y(.5*s)}}};let Vs=class{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0,this.distanceOffset=0}};const at=65535;let It=class extends G{constructor(t,e,r,i){super(t,e,r,i),this.vertexSpec=D,this._currentWrite=new Vs,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:at,textured:!1},this._tessParams=new Xs,this._initializeTessellator()}writeLineVertices(t,e,r){const i=this._getLines(e);i!=null&&this._writeVertices(t,r,i)}_initializeTessellator(){this._lineTessellator=new Xe(this._writeTesselatedVertex.bind(this),this._writeTriangle.bind(this),!0)}_write(t,e,r){const i=r??I.fromFeatureSetReaderCIM(e);i&&this._writeGeometry(t,e,i)}_writeGeometry(t,e,r,i){t.recordStart(this.instanceId,this.attributeLayout,i),this.writeLineVertices(t,r,e),t.recordEnd()}_getLines(t){return Hs(t,re(this.evaluatedMeshParams))}_writeVertices(t,e,r){const{_currentWrite:i,_tessellationOptions:n,evaluatedMeshParams:o}=this,{width:a,capType:c,joinType:h,miterLimit:l,hasSizeVV:d}=o,m=y(.5*a);n.halfWidth=m,n.capType=os(c),n.joinType=as(h),n.miterLimit=l;const p=!d;i.out=t,i.id=e.getDisplayId(),i.vertexCount=0,i.indexCount=0,i.vertexFrom=t.vertexCount(),i.vertexBounds=p&&m<Pe?0:1;for(const{line:f,start:x,pathLength:g}of r)n.initialDistance=x%at,i.pathLength=g,i.distanceOffset=Math.floor(x/at)*at,this._lineTessellator.tessellate(f,n,p)}_writeTesselatedVertex(t,e,r,i,n,o,a,c,h,l,d){const{out:m,id:p,vertexBounds:f,pathLength:x,distanceOffset:g}=this._currentWrite;return this.hasEffects&&m.recordBounds(t,e,f,f),this._tessParams.extrusionOffsetX=a,this._tessParams.extrusionOffsetY=c,this._tessParams.normalX=h,this._tessParams.normalY=l,this._tessParams.directionX=n,this._tessParams.directionY=o,this._tessParams.distance=d,this._tessParams.pathLength=x,this._tessParams.distanceOffset=g,this._writeVertex(m,p,t,e,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(t,e,r){const{out:i}=this._currentWrite;i.indexEnsureSize(3),i.indexWrite(t),i.indexWrite(e),i.indexWrite(r),this._currentWrite.indexCount+=3}};const Zs=100,qs=ze("featurelayer-fast-triangulation-enabled");let Dt=class extends G{async loadDependencies(){await Promise.all([super.loadDependencies(),Ve()])}_write(t,e,r){const i=r?.asOptimized()??e.readGeometryForDisplay(),n=this._clip(i);n&&(t.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(t,e,n),t.recordEnd())}_clip(t){if(!t)return null;const e=this.hasEffects;return xe(t,e?256:8)}_writeGeometry(t,e,r){const i=r.maxLength>Zs,n=[],o=this.createTesselationParams(e);if(!i&&qs&&Gs(n,r))return void(n.length&&this._writeVertices(t,e,r.coords,o,n));const a=Us(r);this._writeVertices(t,e,a,o)}_writeVertices(t,e,r,i,n){const o=e.getDisplayId(),a=t.vertexCount(),c=this.hasEffects;let h=0;if(n)for(const l of n){const d=r[2*l],m=r[2*l+1];c&&t.recordBounds(d,m,0,0),this._writeVertex(t,o,d,m,i),h++}else for(let l=0;l<r.length;l+=2){const d=Math.round(r[l]),m=Math.round(r[l+1]);c&&t.recordBounds(d,m,0,0),this._writeVertex(t,o,d,m,i),h++}t.indexEnsureSize(h);for(let l=0;l<h;l++)t.indexWrite(l+a)}};const Qs={createComputedParams:s=>s,optionalAttributes:{},attributes:{id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1},pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},inverseArea:{type:u.FLOAT,count:1,packTessellation:({inverseArea:s})=>s}}};let Tr=class extends Dt{constructor(){super(...arguments),this.vertexSpec=Qs}createTesselationParams(t){return{inverseArea:1/t.readGeometryArea()}}};const et={createComputedParams:s=>s,optionalAttributes:{zoomRange:{type:u.SHORT,count:2,packPrecisionFactor:st,pack:({scaleInfo:s},{tileInfo:t})=>Z(s,t)}},attributes:{id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1},pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:s})=>_(s)}}};let ye=class extends Dt{constructor(){super(...arguments),this.vertexSpec=et}createTesselationParams(t){return null}};const C={createComputedParams:s=>s,optionalAttributes:et.optionalAttributes,attributes:{...et.attributes,tlbr:{count:4,type:u.UNSIGNED_SHORT,pack:({sprite:s})=>{const{rect:t,width:e,height:r}=s,i=t.x+b,n=t.y+b;return[i,n,i+e,n+r]}},inverseRasterizationScale:{count:1,type:u.BYTE,packPrecisionFactor:16,pack:({sprite:s})=>1/s.rasterizationScale}}};let js=class extends ye{constructor(){super(...arguments),this.vertexSpec=C}_write(t,e,r){const i=r?.asOptimized()??e.readGeometryForDisplay(),n=this._clip(i);if(!n)return;const o=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,o),this._writeGeometry(t,e,n),t.recordEnd()}};function ft(s){const{sprite:t,aspectRatio:e,scaleProportionally:r}=s,i=y(s.height),n=i>0?i:t.height;let o=i*e;return o<=0?o=t.width:r&&(o*=t.width/t.height),{width:o,height:n}}function ge(s){const{applyRandomOffset:t,sampleAlphaOnly:e}=s;return q([[Le,t],[ee,e]])}const _e={createComputedParams:s=>s,optionalAttributes:C.optionalAttributes,attributes:{...C.attributes,bitset:{count:1,type:u.UNSIGNED_BYTE,pack:ge},width:{count:1,type:u.HALF_FLOAT,pack:s=>ft(s).width},height:{count:1,type:u.HALF_FLOAT,pack:s=>ft(s).height},offset:{count:2,type:u.HALF_FLOAT,pack:({offsetX:s,offsetY:t})=>[y(s),-y(t)]},scale:{count:2,type:u.UNSIGNED_BYTE,packPrecisionFactor:16,pack:({scaleX:s,scaleY:t})=>[s,t]},angle:{count:1,type:u.UNSIGNED_BYTE,pack:({angle:s})=>De(s)}}};let Ar=class extends js{constructor(){super(...arguments),this.vertexSpec=_e}};const ke={createComputedParams:s=>s,optionalAttributes:D.optionalAttributes,attributes:{...D.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:s=>0},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:s})=>_(s)}}},Lt={createComputedParams:s=>s,optionalAttributes:D.optionalAttributes,attributes:{...D.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:s=>q([[se,!0],[Fe,s.outlineUsesColorVV]])},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:s})=>_(s)}}};let Ft=class extends It{constructor(){super(...arguments),this.vertexSpec=Lt}},Se=class extends ye{constructor(t,e,r,i){super(t,e,r,i),this.vertexSpec=ke,this._lineMeshWriter=this._createOutlineWriter(t,e,r,i)}_createOutlineWriter(t,e,r,i){return new Ft(t,e,r,i)}_write(t,e){const r=this.evaluatedMeshParams.effects,i=this.evaluatedMeshParams.outlineEffects;if(r?.length||i?.length){if(r?.length){const n=this.getEffectCursor(t,e,r);if(n){let o;for(;o=n?.next();)o.invertY(),this._writeFill(t,e,o)}}else this._writeFill(t,e);if(i?.length){const n=this.getEffectCursor(t,e,i);if(n){let o;for(;o=n?.next();)o.invertY(),this._writeOutline(t,e,o)}}else this._writeOutline(t,e)}else this._writeSimpleOutlineFill(t,e)}_writeSimpleOutlineFill(t,e){const r=e.readGeometryForDisplay(),i=this._clip(r);i&&(this._writeGeometry(t,e,i),this._lineMeshWriter.writeLineVertices(t,I.fromOptimizedCIM(i,"esriGeometryPolyline"),e))}_writeFill(t,e,r){const i=r?.asOptimized()??e.readGeometryForDisplay(),n=this._clip(i);n&&this._writeGeometry(t,e,n)}_writeOutline(t,e,r){const i=r?.asOptimized()??e.readGeometryForDisplay(),n=this._clip(i);n&&this._lineMeshWriter.writeLineVertices(t,I.fromOptimizedCIM(n,"esriGeometryPolyline"),e)}_clip(t){return t?xe(t,re(this.evaluatedMeshParams)):null}get effectInfos(){return[...this._evaluator.inputMeshParams.effects?.effectInfos??[],...this._evaluator.inputMeshParams.outlineEffects?.effectInfos??[]]}write(t,e,r,i,n){this.ensurePacked(e,r,i),t.recordStart(this.instanceId,this.attributeLayout),this._write(t,r),t.recordEnd()}ensurePacked(t,e,r){super.ensurePacked(t,e,r),this._lineMeshWriter.ensurePacked(t,e,r)}enqueueRequest(t,e,r){super.enqueueRequest(t,e,r),this._lineMeshWriter.enqueueRequest(t,e,r)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}get hasEffects(){return!!this.evaluatedMeshParams.outlineEffects}};const dt=_e,Js=Lt,Ks={createComputedParams:s=>s,optionalAttributes:dt.optionalAttributes,attributes:{...dt.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:s=>ge(s)},aux1:{count:1,type:u.HALF_FLOAT,pack:s=>ft(s).width},aux2:{count:1,type:u.HALF_FLOAT,pack:s=>ft(s).height},aux3:{count:2,type:u.HALF_FLOAT,pack:({offsetX:s,offsetY:t})=>[y(s),y(t)]},aux4:{count:2,type:u.UNSIGNED_BYTE,pack:({scaleX:s,scaleY:t})=>[s*ht,t*ht]}}},ti={createComputedParams:s=>s,optionalAttributes:dt.optionalAttributes,attributes:{...dt.attributes,color:Js.attributes.color,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:s=>q([[se,!0]])},aux1:{count:1,type:u.HALF_FLOAT,pack:s=>y(.5*s.width)},aux2:{count:1,type:u.HALF_FLOAT,pack:s=>y(.5*s.referenceWidth)},aux3:{count:2,type:u.HALF_FLOAT,packTessellation:({extrusionOffsetX:s,extrusionOffsetY:t})=>[s,t]},aux4:{count:2,type:u.UNSIGNED_BYTE,packTessellation:({normalX:s,normalY:t})=>[s*ht+Rt,t*ht+Rt]}}};let ei=class extends Ft{constructor(){super(...arguments),this.vertexSpec=ti}};class Fr extends Se{constructor(){super(...arguments),this.vertexSpec=Ks}_createOutlineWriter(t,e,r,i){return new ei(t,e,r,i)}write(t,e,r,i,n){this.ensurePacked(e,r,i);const o=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,o),this._write(t,r),t.recordEnd()}ensurePacked(t,e,r){super.ensurePacked(t,e,r),this._lineMeshWriter.ensurePacked(t,e,r)}enqueueRequest(t,e,r){super.enqueueRequest(t,e,r),this._lineMeshWriter.enqueueRequest(t,e,r)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const si=()=>Jt.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.fill.GradientSizeHelper");let ii=class{constructor(t,e){this._size=t,this._sizeUnits=e,this._relativeSize=null}get relativeSize(){return this._relativeSize??=this.calculateRelativeSize(),this._relativeSize}calculateRelativeSize(){if(this._sizeUnits===pt.Relative){const t=Math.min(this._size/100,1);return[t,t]}return this.calculateRelativeSizeFromAbsolute()}},Nt=class extends ii{constructor(t,e,r,i){super(e,r),this.rotationMatrix00=1,this.rotationMatrix01=0,this.rotationMatrix10=0,this.rotationMatrix11=1,this.bounds={xmin:1/0,ymin:1/0,xmax:-1/0,ymax:-1/0},this.rotationMatrix00=Math.cos(i),this.rotationMatrix01=-Math.sin(i),this.rotationMatrix10=-this.rotationMatrix01,this.rotationMatrix11=this.rotationMatrix00;const{bounds:n,rotationMatrix00:o,rotationMatrix01:a,rotationMatrix10:c,rotationMatrix11:h}=this;t.forEachVertex((l,d)=>{const m=l*o+d*a,p=l*c+d*h;n.xmin=Math.min(n.xmin,m),n.ymin=Math.min(n.ymin,p),n.xmax=Math.max(n.xmax,m),n.ymax=Math.max(n.ymax,p)}),this.center=[(n.xmin+n.xmax)/2,(n.ymin+n.ymax)/2]}},ri=class extends Nt{constructor(t,e,r,i){super(t,e,r,i),this.method="linear"}getRelativePosition(t,e){const{rotationMatrix00:r,rotationMatrix01:i,bounds:n}=this,{xmin:o,xmax:a}=n;return[(t*r+e*i-o)/(a-o),0]}calculateRelativeSizeFromAbsolute(){const{_size:t,bounds:e}=this,{xmin:r,xmax:i}=e;return[y(t)/(i-r),0]}};class ni extends Nt{constructor(t,e,r,i){super(t,e,r,i),this.method="rectangular"}getRelativePosition(t,e){const{bounds:r,center:i,rotationMatrix00:n,rotationMatrix01:o,rotationMatrix10:a,rotationMatrix11:c}=this,h=t*a+e*c,l=t*n+e*o-i[0],d=h-i[1];return[l*(2/(r.xmax-r.xmin)),-d*(2/(r.ymax-r.ymin))]}calculateRelativeSizeFromAbsolute(){const{_size:t,bounds:e}=this,{xmin:r,ymin:i,xmax:n,ymax:o}=e;return[y(2*t)/(n-r),y(2*t)/(o-i)]}}class oi extends Nt{constructor(t,e,r){super(t,e,r,0),this.method="circular";const{xmin:i,xmax:n,ymin:o,ymax:a}=this.bounds,c=n-i,h=a-o;this.radius=Math.sqrt(c*c+h*h)/2}getRelativePosition(t,e){const{center:r,radius:i}=this;return[(t-r[0])/i,-((e-r[1])/i)]}calculateRelativeSizeFromAbsolute(){const{_size:t}=this;return[y(t)/this.radius,0]}}function ai(s,t){if(s==null)return null;const e=Ie(t.angle),r=t.gradientSize,i=t.gradientSizeUnits;switch(t.gradientMethod.toLowerCase()){case"linear":return new ri(s,r,i,e);case"rectangular":return new ni(s,r,i,e);case"circular":return new oi(s,r,i);default:return si().errorOnce(`Gradient fill method "${t.gradientMethod}" currently unsupported.`),null}}const ci={createComputedParams:s=>s,optionalAttributes:et.optionalAttributes,attributes:{...et.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:({gradientSizeUnits:s,gradientType:t})=>{let e=0;return s===pt.Absolute&&(e|=w(Yt.isAbsolute)),t.toLowerCase()==="discrete"&&(e|=w(Yt.isDiscrete)),e}},tlbr:{count:4,type:u.UNSIGNED_SHORT,pack:({sprite:s})=>{const{rect:t,width:e,height:r}=s,i=t.x+b+ut,n=t.y+b;return[i,n,i+e-2*ut,n+r]}},relativePosition:{count:2,type:u.HALF_FLOAT,packTessellation:({gradientStats:s},t,e,r)=>s?.getRelativePosition(e,r)??[0,0]},relativeGradientSize:{count:2,type:u.HALF_FLOAT,packTessellation:({gradientStats:s})=>s?.relativeSize??[1,1]},gradientMethod:{count:1,type:u.UNSIGNED_BYTE,pack:({gradientMethod:s})=>{switch(s.toLowerCase()){case"rectangular":return yt.rectangular;case"circular":return yt.circular;default:return yt.linear}}}}};let Rr=class extends Dt{constructor(){super(...arguments),this.vertexSpec=ci}get _preventEffectClipping(){return!0}createTesselationParams(t){return{gradientStats:ai(this._unclippedGeometry,this.evaluatedMeshParams)}}_write(t,e,r){const i=r?.asOptimized()??e.readGeometryForDisplay();this._unclippedGeometry=i;const n=this._clip(i);if(!n)return void(this._unclippedGeometry=null);const o=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,o),this._writeGeometry(t,e,n),this._unclippedGeometry=null,t.recordEnd()}};const li={optionalAttributes:C.optionalAttributes,createComputedParams:s=>s,attributes:{...C.attributes,...ke.attributes}},ui={optionalAttributes:C.optionalAttributes,createComputedParams:s=>s,attributes:{...C.attributes,...Lt.attributes}};class hi extends Ft{constructor(){super(...arguments),this.vertexSpec=ui}}let Cr=class extends Se{constructor(){super(...arguments),this.vertexSpec=li}_createOutlineWriter(t,e,r,i){return new hi(t,e,r,i)}write(t,e,r,i,n){this.ensurePacked(e,r,i);const o=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,o),this._write(t,r),t.recordEnd()}ensurePacked(t,e,r){super.ensurePacked(t,e,r),this._lineMeshWriter.ensurePacked(t,e,r)}enqueueRequest(t,e,r){super.enqueueRequest(t,e,r),this._lineMeshWriter.enqueueRequest(t,e,r)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}};const pi={createComputedParams:s=>s,optionalAttributes:{},attributes:{pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1},offset:{type:u.BYTE,count:2,packAlternating:{count:4,pack:()=>[[-1,-1],[1,-1],[-1,1],[1,1]]}}}};let Ur=class extends G{constructor(){super(...arguments),this.vertexSpec=pi}_write(t,e){t.recordStart(this.instanceId,this.attributeLayout);const r=e.getDisplayId();if(e.geometryType==="esriGeometryPoint"){const i=e.readXForDisplay(),n=e.readYForDisplay();this._writeQuad(t,r,i,n)}else e.geometryType==="esriGeometryMultipoint"&&e.readGeometryForDisplay()?.forEachVertex((n,o)=>{n>=0&&n<=512&&o>=0&&o<=512&&this._writeQuad(t,r,n,o)});t.recordEnd()}_writeQuad(t,e,r,i){const n=t.vertexCount();this._writeVertex(t,e,r,i),t.indexWrite(n+0),t.indexWrite(n+1),t.indexWrite(n+2),t.indexWrite(n+1),t.indexWrite(n+3),t.indexWrite(n+2)}};const Xt=96;class fi{constructor(t){const{offsetX:e,offsetY:r,postAngle:i,fontSize:n,haloSize:o,outlineSize:a,scaleFactor:c,transforms:h}=t;if(this.offsetX=e,this.offsetY=r,this.postAngle=i,this.fontSize=Math.min(n,Xt),this.haloSize=o??0,this.outlineSize=a??0,this.transforms=h,h&&h.infos.length>1){const l=ne(n,i,!1,e,r,h,!1);this.fontSize=Math.min(l.size,Xt);const d=l.size/n;this.haloSize*=d,this.outlineSize*=d,this.postAngle=l.rotation,this.offsetX=l.offsetX,this.offsetY=l.offsetY}c&&(this.fontSize*=c,this.offsetX*=c,this.offsetY*=c)}}const di=28,F=[4,4],ct=[16,4],mi={topLeft:ct,topRight:ct,bottomLeft:ct,bottomRight:ct},mt=[4,2],T=[4,6],Vt={topLeft:mt,topRight:mt,bottomLeft:T,bottomRight:T},Zt={topLeft:mt,topRight:T,bottomLeft:mt,bottomRight:T},xi={topLeft:T,topRight:T,bottomLeft:F,bottomRight:F},yi={topLeft:F,topRight:F,bottomLeft:T,bottomRight:T},gi={topLeft:T,topRight:F,bottomLeft:T,bottomRight:F},_i={topLeft:F,topRight:T,bottomLeft:F,bottomRight:T},ki={createComputedParams:s=>s,optionalAttributes:{zoomRange:{type:u.UNSIGNED_SHORT,count:2,packPrecisionFactor:st,packTessellation:({minZoom:s,maxZoom:t})=>[s||0,t||di]},clipAngle:{type:u.UNSIGNED_BYTE,count:1,packTessellation:({clipAngle:s})=>Si(s||0)},referenceSymbol:{type:u.BYTE,count:4,packPrecisionFactor:1,packTessellation:(s,t)=>{const e=s.isLineLabel||!s.referenceBounds,r=Ge(e?"center":t.horizontalAlignment),i=Ue(e?"middle":t.verticalAlignment),{offsetX:n,offsetY:o,size:a}=e?{offsetX:0,offsetY:0,size:0}:s.referenceBounds;return[y(n),-y(o),Math.round(y(a)),r+1<<2|i+1]}},visibility:{type:u.FLOAT,count:1,otherSource:!0}},attributes:{pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1,packTessellation:({isBackground:s,mapAligned:t})=>q([[Ne,s],[Oe,!!t]])},offset:{type:u.SHORT,count:2,packPrecisionFactor:8,packAlternating:{count:4,packTessellation:({offsets:s})=>{const{bottomLeft:t,bottomRight:e,topLeft:r,topRight:i}=s;return[r,i,t,e]}}},textureUV:{type:u.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,packTessellation:({texcoords:s})=>{const{bottomLeft:t,bottomRight:e,topLeft:r,topRight:i}=s;return[r,i,t,e]}}},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,packTessellation:({color:s})=>s},fontAndReferenceSize:{type:u.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({fontSize:s},{referenceSize:t})=>[Math.round(y(s)),Math.round(y(t??s))]},outlineColor:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:s})=>_(s)},haloColor:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({haloColor:s})=>_(s)},outlineAndHaloSize:{type:u.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({outlineSize:s,haloSize:t})=>[Math.round(y(s)),Math.round(y(t))]}}};class Hr extends G{constructor(){super(...arguments),this.vertexSpec=ki,this._textMeshParamsPropsInitialized=!1}ensurePacked(t,e,r){super.ensurePacked(t,e,r),this._textMeshParamsPropsInitialized&&!this._evaluator.hasDynamicProperties||(this._textMeshTransformProps=new fi(this.evaluatedMeshParams),this._textMeshParamsPropsInitialized=!0)}_write(t,e,r){const i=this._getShaping();if(!i)return;const n=e.getDisplayId();if(this.evaluatedMeshParams.placement!=null)return this._writePlacedTextMarkers(t,e,i,r);if(r?.nextPath())return r.nextPoint(),this._writeGlyphs(t,n,r.x,r.y,i,0);if(e.geometryType==="esriGeometryPolygon"){const c=e.readCentroidForDisplay();if(!c)return;const[h,l]=c.coords;return this._writeGlyphs(t,n,h,l,i,0)}if(e.geometryType==="esriGeometryMultipoint")return void e.readGeometryForDisplay()?.forEachVertex((h,l)=>this._writeGlyphs(t,n,h,l,i,0));const o=e.readXForDisplay(),a=e.readYForDisplay();return this._writeGlyphs(t,n,o,a,i,0)}_writePlacedTextMarkers(t,e,r,i){const n=i??I.fromFeatureSetReaderCIM(e);if(!n)return;const o=-1,a=oe.getPlacement(n,o,this.evaluatedMeshParams.placement,y(1),t.id,zt());if(!a)return;const c=e.getDisplayId();let h=a.next();for(;h!=null;){const l=h.tx,d=-h.ty,m=-h.getAngle();this._writeGlyphs(t,c,l,d,r,m),h=a.next()}}_getShaping(t){const e=this._textMeshTransformProps,r=this.evaluatedMeshParams;if(!r.glyphs?.glyphs.length)return null;const i=y(e.fontSize),n=y(e.offsetX),o=y(e.offsetY),a=Ot(y(r.lineWidth),we,ve),c=Te*Ot(r.lineHeightRatio,.25,4);return Ce(r.glyphs,{scale:i/Me,angle:e.postAngle,xOffset:n,yOffset:o,horizontalAlignment:r.horizontalAlignment,verticalAlignment:t||r.verticalAlignment,maxLineWidth:a,lineHeight:c,decoration:r.decoration,borderLineSizePx:y(r.boxBorderLineSize),hasBackground:!!r.boxBackgroundColor,useCIMAngleBehavior:r.useCIMAngleBehavior})}_writeGlyphs(t,e,r,i,n,o,a,c,h=!0){const l=this.evaluatedMeshParams,d=this._textMeshTransformProps,m=y(d.fontSize),p=d.haloSize,f=d.outlineSize,x=y(d.offsetX),g=y(d.offsetY),[P,M]=Z(l.scaleInfo,this.getTileInfo());o!==0&&n.setRotation(o);const A=n.bounds,z=r+A.x+x,N=i+A.y-g,L=2*(l.minPixelBuffer?l.minPixelBuffer/m:1),$=Math.max(A.width,A.height)*L;n.textBox&&(t.recordStart(this.instanceId,this.attributeLayout,n.glyphs[0].textureBinding),h&&t.recordBounds(z,N,$,$),this._writeTextBox(t,e,r,i,n.textBox,a,c),t.recordEnd());for(const O of n.glyphs){t.recordStart(this.instanceId,this.attributeLayout,O.textureBinding),h&&t.recordBounds(z,N,$,$);const{texcoords:U,offsets:be}=O;this._writeQuad(t,e,r,i,{texcoords:U,offsets:be,fontSize:m,haloSize:p,outlineSize:f,color:_(l.color),isBackground:!1,referenceBounds:a,minZoom:P,maxZoom:M,...c}),t.recordEnd()}o!==0&&n.setRotation(-o)}_writeTextBox(t,e,r,i,n,o,a){const c=this.evaluatedMeshParams,{fontSize:h,haloSize:l,outlineSize:d}=this._textMeshTransformProps,{boxBackgroundColor:m,boxBorderLineColor:p}=c,f={isBackground:!0,fontSize:h,haloSize:l,outlineSize:d,referenceBounds:o,...a};m&&(this._writeQuad(t,e,r,i,{texcoords:mi,offsets:n.main,color:_(m),...f}),p||(this._writeQuad(t,e,r,i,{texcoords:xi,offsets:n.top,color:_(m),...f}),this._writeQuad(t,e,r,i,{texcoords:yi,offsets:n.bot,color:_(m),...f}),this._writeQuad(t,e,r,i,{texcoords:gi,offsets:n.left,color:_(m),...f}),this._writeQuad(t,e,r,i,{texcoords:_i,offsets:n.right,color:_(m),...f}))),p&&(this._writeQuad(t,e,r,i,{texcoords:Vt,offsets:n.top,color:_(p),...f}),this._writeQuad(t,e,r,i,{texcoords:Vt,offsets:n.bot,color:_(p),...f}),this._writeQuad(t,e,r,i,{texcoords:Zt,offsets:n.left,color:_(p),...f}),this._writeQuad(t,e,r,i,{texcoords:Zt,offsets:n.right,color:_(p),...f}))}_writeQuad(t,e,r,i,n){const o=t.vertexCount();this._writeVertex(t,e,r,i,n),t.indexWrite(o+0),t.indexWrite(o+1),t.indexWrite(o+2),t.indexWrite(o+1),t.indexWrite(o+3),t.indexWrite(o+2)}}const Si=s=>Math.round(s*(254/360)),bi={createComputedParams:s=>s,optionalAttributes:D.optionalAttributes,attributes:{...D.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:({gradientMethod:s,gradientSizeUnits:t,gradientType:e})=>q([[gt.isAlongLine,s.toLowerCase()==="alongline"],[gt.isAbsoluteSize,t===pt.Absolute],[gt.isDiscrete,e.toLowerCase()==="discrete"]])},tlbr:{type:u.UNSIGNED_SHORT,count:4,pack:({sprite:s})=>{const{rect:t,width:e,height:r}=s,i=t.x+b+ut,n=t.y+b;return[i,n,i+e-2*ut,n+r]}},accumulatedDistance:{type:u.HALF_FLOAT,count:1,packTessellation:({distance:s,pathLength:t,distanceOffset:e})=>(e+s)/t},gradientSize:{type:u.HALF_FLOAT,count:1,pack:({gradientSize:s,gradientSizeUnits:t})=>t===pt.Relative?s/100:y(s)},totalLength:{type:u.HALF_FLOAT,count:1,packTessellation:({pathLength:s})=>s},segmentDirection:{type:u.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:s,directionY:t})=>[s,t]}}};let Xr=class extends It{get _preventEffectClipping(){return!0}constructor(t,e,r,i){super(t,e,r,i),this.vertexSpec=bi,this._tessellationOptions.textured=!0}_write(t,e,r){const i=r??I.fromFeatureSetReaderCIM(e);if(!i)return;const{sprite:n}=this.evaluatedMeshParams;this._writeGeometry(t,e,i,n?.textureBinding)}};const Pi={createComputedParams:s=>s,optionalAttributes:D.optionalAttributes,attributes:{...D.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:({shouldSampleAlphaOnly:s,shouldScaleDash:t,isSDF:e})=>q([[ee,s],[Ye,t],[Re,e]])},tlbr:{type:u.UNSIGNED_SHORT,count:4,pack:({sprite:s})=>{const{rect:t,width:e,height:r}=s,i=t.x+b,n=t.y+b;return[i,n,i+e,n+r]}},accumulatedDistance:{type:u.UNSIGNED_SHORT,count:1,packTessellation:({distance:s})=>s},segmentDirection:{type:u.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:s,directionY:t})=>[s,t]},offsetAlongLine:{type:u.HALF_FLOAT,count:1,pack:({offsetAlongLine:s})=>y(s)},capType:{type:u.UNSIGNED_BYTE,count:1,pack:({capType:s})=>{switch(s){case H.Butt:case"butt":return 0;case H.Square:case"square":return 1;case H.Round:case"round":return 2;default:return 0}}}}};class Zr extends It{constructor(t,e,r,i){super(t,e,r,i),this.vertexSpec=Pi,this._tessellationOptions.textured=!0}_write(t,e,r){const i=r??I.fromFeatureSetReaderCIM(e);if(!i)return;const{sprite:n}=this.evaluatedMeshParams;this._writeGeometry(t,e,i,n?.textureBinding)}}let vi=class At{static from(t){return"width"in t?this.fromSimpleMeshParams(t):this.fromComplexMeshParams(t)}static fromSimpleMeshParams(t){const e=new At(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects),{type:r,width:i,height:n,angle:o,alignment:a,outlineSize:c,referenceSize:h,sprite:l,overrideOutlineColor:d}=t;return e.rawWidth=y(i),e.rawHeight=y(n),e.angle=o,e.alignment=a,e.outlineSize=y(c),e.referenceSize=y(h),e.overrideOutlineColor=d,e.offsetX=y(t.offsetX),e.offsetY=y(t.offsetY),r!=="simple"||l.sdf||(e.rawWidth=l.width,e.rawHeight=l.height),e._computeSize(t,!1),e}static fromComplexMeshParams(t){const e=new At(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects);let{alignment:r,transforms:i,size:n,scaleX:o,anchorX:a,anchorY:c,angle:h,colorLocked:l,frameHeight:d,widthRatio:m,offsetX:p,offsetY:f,outlineSize:x,referenceSize:g,scaleFactor:P,sizeRatio:M,isAbsoluteAnchorPoint:A,rotateClockwise:z,scaleSymbolsProportionally:N,sprite:L}=t;if(i&&i.infos.length>0){const U=ne(n,h,z,p,f,i);n=U.size,h=U.rotation,p=U.offsetX,f=U.offsetY,z=!1}P&&(n*=P,p*=P,f*=P);const $=o*(L.width/L.height);e.alignment=r,e.rawHeight=y(n),e.rawWidth=e.rawHeight*$,e.referenceSize=y(g),e.sizeRatio=M,e.sdfDecodeCoeff=(L.sdfDecodeCoeff??1)*M,e.angle=h,e.rotateClockwise=z,e.anchorX=a,e.anchorY=c,e.offsetX=y(p),e.offsetY=y(f),A&&n&&(L.sdf?e.anchorX=a/(n*m):e.anchorX=a/(n*$),e.anchorY=c/n);const O=N&&d?n/d:1;return e.outlineSize=x===0||isNaN(x)?0:y(x)*O,e.scaleSymbolsProportionally=N,e.colorLocked=l,e._computeSize(t,!0),e}constructor(t,e,r,i,n,o,a){this.sprite=t,this.color=e,this.outlineColor=r,this.minPixelBuffer=i,this.placement=n,this.scaleInfo=o,this.effects=a,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.sdfDecodeCoeff=1,this.alignment=ie.SCREEN,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize(t,e){const{sprite:r,hasSizeVV:i}=t,n=!!r.sdf,o=r.sdfPaddingRatio??.5,{rawWidth:a,rawHeight:c,sizeRatio:h,outlineSize:l}=this,d=r.rect;let m=a*h,p=c*h,f=0,x=0;if(n){const z=1/(1-o);if(m*=z,p*=z,i)this.computedWidth=m,this.computedHeight=p;else{const N=e&&a>c?m:a,L=c,$=l+2;this.computedWidth=Math.min(N+$,m),this.computedHeight=Math.min(L+$,p);const O=Math.max(r.width,r.height)/Math.max(m,p);f=(this.computedWidth-m)*O,x=(this.computedHeight-p)*O}}else this.computedWidth=m*(d.width/r.width),this.computedHeight=p*(d.height/r.height),f=2*b,x=2*b;const g=d.x+b-f/2,P=d.y+b-x/2,M=g+r.width+f,A=P+r.height+x;this.texXmin=qt(g),this.texYmin=qt(P),this.texXmax=Qt(M),this.texYmax=Qt(A),this.computedWidth*=(this.texXmax-this.texXmin)/(M-g),this.computedHeight*=(this.texYmax-this.texYmin)/(A-P),this.anchorX*=m/this.computedWidth,this.anchorY*=p/this.computedHeight}};function qt(s,t=1e-7){const e=Math.ceil(s);return e-s<t?e:Math.floor(s)}function Qt(s,t=1e-7){const e=Math.floor(s);return s-e<t?e:Math.ceil(s)}const wi=3.14159265359/180,Ti=128/Math.PI;function Mi(s,t){return s%=t,Math.abs(s>=0?s:s+t)}function $i(s){return Mi(s*Ti,256)}function Ei(s,t,e,r,i=!1){const n=es(),o=i?1:-1;return Je(n),(t||e)&&Ke(n,n,[t,-e]),r&&ts(n,n,o*wi*-r),n}const Ai={createComputedParams:s=>vi.from(s),optionalAttributes:{zoomRange:{type:u.SHORT,count:2,packPrecisionFactor:st,pack:({scaleInfo:s},{tileInfo:t})=>Z(s,t)}},attributes:{pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1,pack:({sprite:s,alignment:t,scaleSymbolsProportionally:e,overrideOutlineColor:r,colorLocked:i})=>{let n=0;return s.sdf&&(n|=w(E.bitset.isSDF)),t===ie.MAP&&(n|=w(E.bitset.isMapAligned)),e&&(n|=w(E.bitset.scaleSymbolsProportionally)),r&&(n|=w(E.bitset.overrideOutlineColor)),i&&(n|=w(E.bitset.colorLocked)),n}},offset:{type:u.HALF_FLOAT,count:2,packAlternating:{count:4,pack:({angle:s,computedWidth:t,computedHeight:e,anchorX:r,anchorY:i,offsetX:n,offsetY:o,rotateClockwise:a})=>{const c=Ei(0,n,o,-s,a),h=-(.5+r)*t,l=-(.5-i)*e,d=[h,l],m=[h+t,l],p=[h,l+e],f=[h+t,l+e];return rt(d,d,c),rt(m,m,c),rt(p,p,c),rt(f,f,c),[d,m,p,f]}}},textureUV:{type:u.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({texXmax:s,texXmin:t,texYmax:e,texYmin:r})=>[[t,r],[s,r],[t,e],[s,e]]}},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:s})=>_(s)},outlineColor:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:s})=>_(s)},sizing:{type:u.UNSIGNED_BYTE,count:4,pack:({rawWidth:s,rawHeight:t,outlineSize:e,referenceSize:r})=>{const i=Math.max(s,t);return[bt(i,128),bt(e,128),bt(r,128),0]}},placementAngle:{type:u.UNSIGNED_BYTE,count:1,packTessellation:({placementAngle:s})=>$i(s)},sdfDecodeCoeff:{type:u.UNSIGNED_SHORT,count:1,packPrecisionFactor:64,pack:({sdfDecodeCoeff:s})=>s}}};class qr extends G{constructor(){super(...arguments),this.vertexSpec=Ai}getBoundsInfo(){return this.evaluatedMeshParams.boundsInfo}_write(t,e,r){const i=this.evaluatedMeshParams.sprite?.textureBinding,n=e.getDisplayId();t.recordStart(this.instanceId,this.attributeLayout,i);const o=this.evaluatedMeshParams.minPixelBuffer,a=Math.max(this.evaluatedMeshParams.computedWidth,o),c=Math.max(this.evaluatedMeshParams.computedHeight,o),h=-this.evaluatedMeshParams.anchorX*this.evaluatedMeshParams.computedWidth,l=this.evaluatedMeshParams.anchorY*this.evaluatedMeshParams.computedHeight,d=this.evaluatedMeshParams.offsetX+h,m=-this.evaluatedMeshParams.offsetY+l;if(this.evaluatedMeshParams.placement!=null){let p=null;if(r!=null){const f=Math.max(this.evaluatedMeshParams.computedWidth,this.evaluatedMeshParams.computedHeight);if(p=We(r,2*f,!1),p===null)return}this._writePlacedMarkers(t,e,p,a,c)}else if(r?.nextPath()){r.nextPoint();const p=r.x,f=r.y;t.recordBounds(p+d,f+m,a,c),this._writeQuad(t,n,p,f)}else if(e.geometryType==="esriGeometryPolygon"){const p=e.readCentroidForDisplay();if(!p)return;const[f,x]=p.coords;t.recordBounds(f+d,x+m,a,c),this._writeQuad(t,n,f,x)}else if(e.geometryType==="esriGeometryPoint"){const p=e.readXForDisplay(),f=e.readYForDisplay();t.recordBounds(p+d,f+m,a,c),this._writeQuad(t,n,p,f)}else e.readGeometryForDisplay()?.forEachVertex((f,x)=>{t.recordBounds(f+d,x+m,a,c),Math.abs(f)>nt||Math.abs(x)>nt||this._writeQuad(t,n,f,x)});t.recordEnd()}_writePlacedMarkers(t,e,r,i,n){const o=r??I.fromFeatureSetReaderCIM(e);if(!o)return;const a=-1,c=oe.getPlacement(o,a,this.evaluatedMeshParams.placement,y(1),t.id,zt());if(!c)return;const h=e.getDisplayId();let l=c.next();const d=this.evaluatedMeshParams.offsetX,m=-this.evaluatedMeshParams.offsetY;for(;l!=null;){const p=l.tx,f=-l.ty;if(Math.abs(p)>nt||Math.abs(f)>nt){l=c.next();continue}const x=-l.getAngle();t.recordBounds(p+d,f+m,i,n),this._writeQuad(t,h,p,f,x),l=c.next()}}_writeQuad(t,e,r,i,n){const o=t.vertexCount(),a=n==null?null:{placementAngle:n};this._writeVertex(t,e,r,i,a),t.indexWrite(o+0),t.indexWrite(o+1),t.indexWrite(o+2),t.indexWrite(o+1),t.indexWrite(o+3),t.indexWrite(o+2)}}const zi={createComputedParams:s=>s,optionalAttributes:{},attributes:{pos:{type:u.SHORT,count:2,packPrecisionFactor:10,pack:"position"},id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1,pack:s=>0},offset:{type:u.SHORT,count:2,packPrecisionFactor:16,packAlternating:{count:4,pack:({size:s})=>{const t=y(s),e=-t/2,r=-t/2;return[[e,r],[e+t,r],[e,r+t],[e+t,r+t]]}}},texCoords:{type:u.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:()=>[[0,1],[1,1],[0,0],[1,0]]}},size:{type:u.UNSIGNED_BYTE,count:2,pack:({size:s})=>[s,s]},referenceSize:{type:u.UNSIGNED_BYTE,count:1,pack:({size:s})=>y(s)},zoomRange:{type:u.UNSIGNED_BYTE,count:2,pack:({scaleInfo:s},{tileInfo:t})=>Z(s,t)}}};class Qr extends G{constructor(){super(...arguments),this.vertexSpec=zi}_write(t,e){const r=e.getDisplayId(),i=this.evaluatedMeshParams.minPixelBuffer,n=Math.max(y(this.evaluatedMeshParams.size),i);let o,a;if(e.geometryType==="esriGeometryPoint")o=e.readXForDisplay(),a=e.readYForDisplay();else{const h=e.readCentroidForDisplay();if(!h)return;o=h?.coords[0],a=h?.coords[1]}t.recordStart(this.instanceId,this.attributeLayout),t.recordBounds(o,a,n,n);const c=t.vertexCount();this._writeVertex(t,r,o,a),t.indexWrite(c+0),t.indexWrite(c+1),t.indexWrite(c+2),t.indexWrite(c+1),t.indexWrite(c+3),t.indexWrite(c+2),t.recordEnd()}}export{Hr as A,xs as B,S as C,xt as D,Ps as E,mr as F,v as G,Ur as H,Xr as I,Zr as J,It as K,Qr as L,qr as M,Sr as N,yr as O,di as P,Fr as Q,Cr as R,gr as S,pr as T,Se as U,Rr as V,js as W,Ar as X,Tr as Y,ye as Z,ls as _,nr as a,oe as b,Xs as c,_r as d,he as e,xr as f,Hs as g,os as h,as as i,Gs as j,ur as k,lr as l,fr as m,Z as n,Ki as o,ar as p,_ as q,cr as r,or as s,zt as t,hr as u,rr as v,Ut as w,kr as x,dr as y,ir as z};
