import{aq as K,i as y,s as E,n as j,N as L,O as q}from"./main-6eEsl9OJ.js";import{a as b,l as R,B as o,H as G,n as P,M as _,V as Z,N as J,G as f,X as C,L as u,P as Q,F as v,o as X,U as ee}from"./enums-UBzvFP7O.js";import{s as te}from"./getDataTypeBytes-D2DiHx_d.js";const re=()=>y.getLogger("esri.views.webgl.checkWebGLError");function ie(r){switch(r){case b.INVALID_ENUM:return"Invalid Enum. An unacceptable value has been specified for an enumerated argument.";case b.INVALID_VALUE:return"Invalid Value. A numeric argument is out of range.";case b.INVALID_OPERATION:return"Invalid Operation. The specified command is not allowed for the current state.";case b.INVALID_FRAMEBUFFER_OPERATION:return"Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";case b.OUT_OF_MEMORY:return"Out of memory. Not enough memory is left to execute the command.";case b.CONTEXT_LOST_WEBGL:return"WebGL context has been lost";default:return"Unknown error"}}const $=!!K("enable-feature:webgl-debug");function V(){return $}function _e(){return $}function I(r,e=V()){if(e){const t=r.getError();if(t){const i=ie(t),s=new Error().stack;re().error(new E("webgl-error","WebGL error occurred",{message:i,stack:s}))}}}var O;(function(r){r[r.TextureDescriptor=0]="TextureDescriptor",r[r.Texture=1]="Texture",r[r.Renderbuffer=2]="Renderbuffer"})(O||(O={}));function se(r){const e=r.gl;switch(e.getError()){case e.NO_ERROR:return null;case e.INVALID_ENUM:return"An unacceptable value has been specified for an enumerated argument";case e.INVALID_VALUE:return"An unacceptable value has been specified for an argument";case e.INVALID_OPERATION:return"The specified command is not allowed for the current state";case e.INVALID_FRAMEBUFFER_OPERATION:return"The currently bound framebuffer is not framebuffer complete";case e.OUT_OF_MEMORY:return"Not enough memory is left to execute the command";case e.CONTEXT_LOST_WEBGL:return"WebGL context is lost"}return"Unknown error"}function Ee(r,e,t,i,s=0){const n=r.gl;r.bindBuffer(t);for(const a of i){const c=e.get(a.name);if(c==null){console.warn(`There is no location for vertex attribute '${a.name}' defined.`);continue}const l=s*a.stride;if(a.count<=4)n.vertexAttribPointer(c,a.count,a.type,a.normalized,a.stride,a.offset+l),n.enableVertexAttribArray(c),a.divisor>0&&r.gl.vertexAttribDivisor(c,a.divisor);else if(a.count===9)for(let h=0;h<3;h++)n.vertexAttribPointer(c+h,3,a.type,a.normalized,a.stride,a.offset+12*h+l),n.enableVertexAttribArray(c+h),a.divisor>0&&r.gl.vertexAttribDivisor(c+h,a.divisor);else if(a.count===16)for(let h=0;h<4;h++)n.vertexAttribPointer(c+h,4,a.type,a.normalized,a.stride,a.offset+16*h+l),n.enableVertexAttribArray(c+h),a.divisor>0&&r.gl?.vertexAttribDivisor(c+h,a.divisor);else console.error("Unsupported vertex attribute element count: "+a.count);if(V()){const h=se(r),p=te(a.type),d=a.offset,m=Math.round(p/d)!==p/d?`. Offset not a multiple of stride. DataType requires ${p} bytes, but descriptor has an offset of ${d}`:"";h&&console.error(`Unable to bind vertex attribute "${a.name}" with baseInstanceOffset ${l}${m}:`,h,a)}}}function Te(r,e,t,i){const s=r.gl;r.bindBuffer(t);for(const n of i){const a=e.get(n.name);if(n.count<=4)s.disableVertexAttribArray(a),n.divisor&&n.divisor>0&&r.gl?.vertexAttribDivisor(a,0);else if(n.count===9)for(let c=0;c<3;c++)s.disableVertexAttribArray(a+c),n.divisor&&n.divisor>0&&r.gl?.vertexAttribDivisor(a+c,0);else if(n.count===16)for(let c=0;c<4;c++)s.disableVertexAttribArray(a+c),n.divisor&&n.divisor>0&&r.gl?.vertexAttribDivisor(a+c,0);else console.error("Unsupported vertex attribute element count: "+n.count)}r.unbindBuffer(J.ARRAY_BUFFER)}function ae(r){switch(r){case _.ALPHA:case _.LUMINANCE:case _.RED:case _.RED_INTEGER:case o.R8:case o.R8I:case o.R8UI:case o.R8_SNORM:case Z.STENCIL_INDEX8:return 1;case _.LUMINANCE_ALPHA:case _.RG:case _.RG_INTEGER:case o.RGBA4:case o.R16F:case o.R16I:case o.R16UI:case o.RG8:case o.RG8I:case o.RG8UI:case o.RG8_SNORM:case o.RGB565:case o.RGB5_A1:case P.DEPTH_COMPONENT16:return 2;case _.RGB:case _.RGB_INTEGER:case o.RGB8:case o.RGB8I:case o.RGB8UI:case o.RGB8_SNORM:case o.SRGB8:case P.DEPTH_COMPONENT24:return 3;case _.RGBA:case _.RGBA_INTEGER:case o.RGBA8:case o.R32F:case o.R11F_G11F_B10F:case o.RG16F:case o.R32I:case o.R32UI:case o.RG16I:case o.RG16UI:case o.RGBA8I:case o.RGBA8UI:case o.RGBA8_SNORM:case o.SRGB8_ALPHA8:case o.RGB9_E5:case o.RGB10_A2UI:case o.RGB10_A2:case P.DEPTH_COMPONENT32F:case G.DEPTH24_STENCIL8:return 4;case G.DEPTH32F_STENCIL8:return 5;case o.RGB16F:case o.RGB16I:case o.RGB16UI:return 6;case o.RG32F:case o.RG32I:case o.RG32UI:case o.RGBA16F:case o.RGBA16I:case o.RGBA16UI:return 8;case o.RGB32F:case o.RGB32I:case o.RGB32UI:return 12;case o.RGBA32F:case o.RGBA32I:case o.RGBA32UI:return 16;case R.COMPRESSED_RGB_S3TC_DXT1_EXT:case R.COMPRESSED_RGBA_S3TC_DXT1_EXT:return .5;case R.COMPRESSED_RGBA_S3TC_DXT3_EXT:case R.COMPRESSED_RGBA_S3TC_DXT5_EXT:return 1;case R.COMPRESSED_R11_EAC:case R.COMPRESSED_SIGNED_R11_EAC:case R.COMPRESSED_RGB8_ETC2:case R.COMPRESSED_SRGB8_ETC2:case R.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case R.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:return .5;case R.COMPRESSED_RG11_EAC:case R.COMPRESSED_SIGNED_RG11_EAC:case R.COMPRESSED_RGBA8_ETC2_EAC:case R.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return 1}return 0}let oe=class{constructor(e=0,t=e){this.width=e,this.height=t,this.type=O.TextureDescriptor,this.target=f.TEXTURE_2D,this.pixelFormat=_.RGBA,this.dataType=C.UNSIGNED_BYTE,this.samplingMode=u.LINEAR,this.wrapMode=Q.REPEAT,this.maxAnisotropy=1,this.flipped=!1,this.hasMipmap=!1,this.isOpaque=!1,this.unpackAlignment=4,this.preMultiplyAlpha=!1,this.compareEnabled=!1,this.linearFilterDepth=!1,this.depth=1,this.isImmutable=!1}};function ne(r){return r.width<=0||r.height<=0||r.depth<=0?0:Math.round(r.width*r.height*r.depth*(r.hasMipmap?4/3:1)*(r.internalFormat==null?4:ae(r.internalFormat))*(r.target===f.TEXTURE_CUBE_MAP?6:1))}const N=()=>y.getLogger("esri/views/webgl/textureUtils");function w(r){const{width:e,height:t,depth:i}=r;(e!=null&&e<0||t!=null&&t<0||i!=null&&i<0)&&N().error("Negative dimension parameters are not allowed!");const{internalFormat:s}=r;if(s&&(k(s)||z(s))){const{linearFilterDepth:n,compareEnabled:a,samplingMode:c,hasMipmap:l}=r;l&&N().error("Depth textures cannot have mipmaps"),n?c!==u.LINEAR&&c!==u.NEAREST&&N().error("Depth textures cannot sample mipmaps"):(c!==u.NEAREST&&N().error("Depth textures without filtering must use NEAREST filtering"),a&&N().error("Depth textures without filtering cannot use compare function"))}}function ce(r){return r in o}function k(r){return r in P}function z(r){return r in G}function le(r){return r!=null&&r in R}function S(r){return r!=null&&"type"in r&&r.type==="compressed"}function he(r){return r!=null&&"byteLength"in r}function W(r){return r!=null&&!S(r)&&!he(r)}function D(r){return r===f.TEXTURE_3D||r===f.TEXTURE_2D_ARRAY}function H(r,e,t,i=1){let s=Math.max(e,t);return r===f.TEXTURE_3D&&(s=Math.max(s,i)),Math.floor(Math.log2(s))+1}function F(r){if(r.internalFormat!=null)return r.internalFormat;switch(r.dataType){case C.FLOAT:switch(r.pixelFormat){case _.RGBA:return o.RGBA32F;case _.RGB:return o.RGB32F;default:throw new E("texture:unknown-format","Unable to derive format")}case C.UNSIGNED_BYTE:switch(r.pixelFormat){case _.RGBA:return o.RGBA8;case _.RGB:return o.RGB8}}const{pixelFormat:e}=r;return r.internalFormat=e===v.DEPTH_STENCIL?G.DEPTH24_STENCIL8:e===v.DEPTH_COMPONENT?P.DEPTH_COMPONENT24:e,r.internalFormat}function pe(r){let e="width"in r?r.width:r.codedWidth,t="height"in r?r.height:r.codedHeight;return r instanceof HTMLVideoElement&&(e=r.videoWidth,t=r.videoHeight),{width:e,height:t,depth:1}}class B extends oe{constructor(e,t){switch(super(),this.context=e,Object.assign(this,t),this.internalFormat){case o.R16F:case o.R32F:case o.R8_SNORM:case o.R8:this.pixelFormat=_.RED;break;case o.R8I:case o.R8UI:case o.R16I:case o.R16UI:case o.R32I:case o.R32UI:this.pixelFormat=_.RED_INTEGER}}static validate(e,t){return new B(e,t)}}const M=()=>y.getLogger("esri/views/webgl/Texture");let ge=class A{static{this.TEXTURE_UNIT_FOR_UPDATES=0}static{this.compressionWorkerHandle=null}constructor(e,t=null,i=null){if(this.type=O.Texture,this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._shadowFilterDirty=!1,this._wasImmutablyAllocated=!1,"context"in e)this._descriptor=e,i=t;else{const s=B.validate(e,t);if(!s)throw new E("texture:invalid-descriptor","Texture descriptor invalid");this._descriptor=s}this._descriptor.target===f.TEXTURE_CUBE_MAP?this._setDataCubeMap(i):this.setData(i)}get glName(){return this._glName}get descriptor(){return this._descriptor}get usedMemory(){return ne(this._descriptor)}get cachedMemory(){return this.usedMemory}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty||this._shadowFilterDirty}get hasWebGLTextureObject(){return!!this._glName}dispose(){this.abortCompression(),this._descriptor.context.gl&&this.hasWebGLTextureObject&&(this._descriptor.context.instanceCounter.decrement(X.Texture,this),this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null)}release(){this.dispose()}resize(e,t){const i=this._descriptor;if(i.width!==e||i.height!==t){if(this._wasImmutablyAllocated)throw new E("texture:immutable-resize","Immutable textures can't be resized!");i.width=e,i.height=t,this._descriptor.target===f.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}enableCompression(e){this._descriptor.compress=e}disableCompression(){this._descriptor.compress=void 0}setData(e){this.abortCompression(),!S(e)&&this._descriptor.internalFormat&&this._descriptor.internalFormat in R&&(this._descriptor.internalFormat=void 0),this._setData(e),!S(e)&&this._descriptor.compress&&this._compressOnWorker(e)}updateData(e,t,i,s,n,a,c=0){a||M().error("An attempt to use uninitialized data!"),this.hasWebGLTextureObject||M().error("An attempt to update uninitialized texture!");const l=this._descriptor;l.internalFormat=F(l);const{context:h,pixelFormat:p,dataType:d,target:m,isImmutable:T}=l;if(T&&!this._wasImmutablyAllocated)throw new E("texture:uninitialized","Cannot update immutable texture before allocation!");const x=h.bindTexture(this,A.TEXTURE_UNIT_FOR_UPDATES,!0);(t<0||i<0||t+s>l.width||i+n>l.height)&&M().error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:g}=h;c&&(s&&n||M().warn("Must pass width and height if `UNPACK_SKIP_ROWS` is used"),g.pixelStorei(g.UNPACK_SKIP_ROWS,c)),W(a)?g.texSubImage2D(m,e,t,i,s,n,p,d,a):S(a)?g.compressedTexSubImage2D(m,e,t,i,s,n,l.internalFormat,a.levels[e]):g.texSubImage2D(m,e,t,i,s,n,p,d,a),c&&g.pixelStorei(g.UNPACK_SKIP_ROWS,0),h.bindTexture(x,A.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(e,t,i,s,n,a,c,l){l||M().error("An attempt to use uninitialized data!"),this.hasWebGLTextureObject||M().error("An attempt to update an uninitialized texture!");const h=this._descriptor;h.internalFormat=F(h);const{context:p,pixelFormat:d,dataType:m,isImmutable:T,target:x}=h;if(T&&!this._wasImmutablyAllocated)throw new E("texture:uninitialized","Cannot update immutable texture before allocation!");D(x)||M().warn("Attempting to set 3D texture data on a non-3D texture");const g=p.bindTexture(this,A.TEXTURE_UNIT_FOR_UPDATES);p.setActiveTexture(A.TEXTURE_UNIT_FOR_UPDATES),(t<0||i<0||s<0||t+n>h.width||i+a>h.height||s+c>h.depth)&&M().error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:U}=p;if(S(l))l=l.levels[e],U.compressedTexSubImage3D(x,e,t,i,s,n,a,c,h.internalFormat,l);else{const Y=l;U.texSubImage3D(x,e,t,i,s,n,a,c,d,m,Y)}p.bindTexture(g,A.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const e=this._descriptor;if(e.width===0||e.height===0)return;if(!e.hasMipmap){if(this._wasImmutablyAllocated)throw new E("texture:immutable-change","Cannot add mipmaps to immutable texture after allocation");e.hasMipmap=!0,this._samplingModeDirty=!0,w(e)}e.samplingMode===u.LINEAR?(this._samplingModeDirty=!0,e.samplingMode=u.LINEAR_MIPMAP_NEAREST):e.samplingMode===u.NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=u.NEAREST_MIPMAP_NEAREST);const t=this._descriptor.context.bindTexture(this,A.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(A.TEXTURE_UNIT_FOR_UPDATES),this._descriptor.context.gl.generateMipmap(e.target),this._descriptor.context.bindTexture(t,A.TEXTURE_UNIT_FOR_UPDATES)}clearMipmap(){const e=this._descriptor;if(e.hasMipmap){if(this._wasImmutablyAllocated)throw new E("texture:immutable-change","Cannot delete mipmaps to immutable texture after allocation");e.hasMipmap=!1,this._samplingModeDirty=!0,w(e)}e.samplingMode===u.LINEAR_MIPMAP_NEAREST?(this._samplingModeDirty=!0,e.samplingMode=u.LINEAR):e.samplingMode===u.NEAREST_MIPMAP_NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=u.NEAREST)}setSamplingMode(e){e!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=e,this._samplingModeDirty=!0)}setWrapMode(e){e!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=e,w(this._descriptor),this._wrapModeDirty=!0)}setShadowFiltering(e){e!==this._descriptor.linearFilterDepth&&(this._descriptor.linearFilterDepth=this._descriptor.compareEnabled=e,this.setSamplingMode(e?u.LINEAR:u.NEAREST),w(this._descriptor),this._shadowFilterDirty=!0)}applyChanges(){this._samplingModeDirty&&(this._applySamplingMode(),this._samplingModeDirty=!1),this._wrapModeDirty&&(this._applyWrapMode(),this._wrapModeDirty=!1),this._shadowFilterDirty&&(this._applyShadowMode(),this._shadowFilterDirty=!1)}abortCompression(){this._compressionAbortController=j(this._compressionAbortController)}_setData(e,t){const i=this._descriptor,s=i.context?.gl;if(!s)return;I(s),this.hasWebGLTextureObject||(this._glName=s.createTexture(),i.context.instanceCounter.increment(X.Texture,this)),w(i);const n=i.context.bindTexture(this,A.TEXTURE_UNIT_FOR_UPDATES);i.context.setActiveTexture(A.TEXTURE_UNIT_FOR_UPDATES),this._configurePixelStorage(),I(s);const a=t??i.target,c=D(a);if(W(e))this._setDataFromTexImageSource(e,a);else{const{width:l,height:h,depth:p}=i;if(l==null||h==null)throw new E("texture:missing-size","Width and height must be specified!");if(c&&p==null)throw new E("texture:missing-depth","Depth must be specified!");if(i.internalFormat=F(i),i.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(a,i.internalFormat,i.hasMipmap,l,h,p),S(e)){if(!le(i.internalFormat))throw new E("texture:format-mismatch","Attempting to use compressed data with an uncompressed format!");this._setDataFromCompressedSource(e,i.internalFormat,a)}else this._texImage(a,0,i.internalFormat,l,h,p,e),I(s),i.hasMipmap&&this.generateMipmap()}this._applySamplingMode(),this._applyWrapMode(),this._applyAnisotropicFilteringParameters(),this._applyShadowMode(),I(s),i.context.bindTexture(n,A.TEXTURE_UNIT_FOR_UPDATES)}_setDataCubeMap(e=null){for(let t=f.TEXTURE_CUBE_MAP_POSITIVE_X;t<=f.TEXTURE_CUBE_MAP_NEGATIVE_Z;t++)this._setData(e,t)}_configurePixelStorage(){const e=this._descriptor.context.gl,{unpackAlignment:t,flipped:i,preMultiplyAlpha:s}=this._descriptor;e.pixelStorei(e.UNPACK_ALIGNMENT,t),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,i?1:0),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,s?1:0)}_setDataFromTexImageSource(e,t){const{gl:i}=this._descriptor.context,s=this._descriptor;s.internalFormat=F(s);const n=D(t),{width:a,height:c,depth:l}=pe(e);s.width&&s.height,s.width||(s.width=a),s.height||(s.height=c),n&&s.depth,n&&(s.depth=l),s.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(t,s.internalFormat,s.hasMipmap,a,c,l),this._texImage(t,0,s.internalFormat,a,c,l,e),I(i),s.hasMipmap&&(this.generateMipmap(),I(i))}_setDataFromCompressedSource(e,t,i){const s=this._descriptor,{width:n,height:a,depth:c}=s,l=e.levels,h=H(i,n,a,c),p=Math.min(h,l.length)-1;this._descriptor.context.gl.texParameteri(s.target,ee.MAX_LEVEL,p),this._forEachMipmapLevel((d,m,T,x)=>{const g=l[Math.min(d,l.length-1)];this._compressedTexImage(i,d,t,m,T,x,g)},p)}_texStorage(e,t,i,s,n,a){const{gl:c}=this._descriptor.context;if(!ce(t)&&!k(t)&&!z(t))throw new E("texture:missing-format","Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const l=i?H(e,s,n,a):1;if(D(e)){if(a==null)throw new E("texture:missing-depth","Missing depth dimension for 3D texture upload");c.texStorage3D(e,l,t,s,n,a)}else c.texStorage2D(e,l,t,s,n);this._wasImmutablyAllocated=!0}_texImage(e,t,i,s,n,a,c){const l=this._descriptor.context.gl,h=D(e),{isImmutable:p,pixelFormat:d,dataType:m}=this._descriptor;if(p){if(c!=null){const T=c;if(h){if(a==null)throw new E("texture:missing-depth","Missing depth dimension for 3D texture upload");l.texSubImage3D(e,t,0,0,0,s,n,a,d,m,T)}else l.texSubImage2D(e,t,0,0,s,n,d,m,T)}}else{const T=c;if(h){if(a==null)throw new E("texture:missing-depth","Missing depth dimension for 3D texture upload");l.texImage3D(e,t,i,s,n,a,0,d,m,T)}else l.texImage2D(e,t,i,s,n,0,d,m,T)}}_compressedTexImage(e,t,i,s,n,a,c){const l=this._descriptor.context.gl,h=D(e);if(this._descriptor.isImmutable){if(c!=null)if(h){if(a==null)throw new E("texture:missing-depth","Missing depth dimension for 3D texture upload");l.compressedTexSubImage3D(e,t,0,0,0,s,n,a,i,c)}else l.compressedTexSubImage2D(e,t,0,0,s,n,i,c)}else if(h){if(a==null)throw new E("texture:missing-depth","Missing depth dimension for 3D texture upload");l.compressedTexImage3D(e,t,i,s,n,a,0,c)}else l.compressedTexImage2D(e,t,i,s,n,0,c)}async _compressOnWorker(e){const{width:t,height:i,context:s,flipped:n,preMultiplyAlpha:a,hasMipmap:c}=this._descriptor,l=this._descriptor.compress?.compressionTracker,h=this._descriptor.compress?.compressionCallback,{compressedTextureETC:p,compressedTextureS3TC:d}=s.capabilities;if(!A.compressionWorkerHandle?.isCompressible(e,this._descriptor)||!p&&!d)return;this.abortCompression();const m=new AbortController;this._compressionAbortController=m,l?.increment();try{let T;e instanceof Uint8Array?T=e.buffer:(T=await createImageBitmap(e,{imageOrientation:n?"flipY":"none"}),L(m));const x={data:T,width:t,height:i,needsFlip:e instanceof Uint8Array&&this.descriptor.flipped,components:this._descriptor.pixelFormat===_.RGBA?4:3,preMultiplyAlpha:a,hasMipmap:c,hasETC:!!p,hasS3TC:!!d},g=await A.compressionWorkerHandle.invoke(x,m.signal,"low");if(L(m),g.compressedTexture&&this.hasWebGLTextureObject){const U=this.usedMemory;this._descriptor.internalFormat=g.internalFormat,this._setData(g.compressedTexture),h?.(U-this.usedMemory)}}catch(T){q(T)||M().error("Texture compression failed!")}finally{l?.decrement(),this._compressionAbortController?.signal.aborted&&(this._compressionAbortController=null)}}_forEachMipmapLevel(e,t=1/0){let{width:i,height:s,depth:n,hasMipmap:a,target:c}=this._descriptor;const l=c===f.TEXTURE_3D;if(i==null||s==null||l&&n==null)throw new E("texture:missing-size","Missing texture dimensions for mipmap calculation");for(let h=0;e(h,i,s,n),a&&(i!==1||s!==1||l&&n!==1)&&!(h>=t);++h)i=Math.max(1,i>>1),s=Math.max(1,s>>1),l&&(n=Math.max(1,n>>1))}_applySamplingMode(){const e=this._descriptor,t=e.context?.gl;let i=e.samplingMode,s=e.samplingMode;i===u.LINEAR_MIPMAP_NEAREST||i===u.LINEAR_MIPMAP_LINEAR?(i=u.LINEAR,e.hasMipmap||(s=u.LINEAR)):i!==u.NEAREST_MIPMAP_NEAREST&&i!==u.NEAREST_MIPMAP_LINEAR||(i=u.NEAREST,e.hasMipmap||(s=u.NEAREST)),t.texParameteri(e.target,t.TEXTURE_MAG_FILTER,i),t.texParameteri(e.target,t.TEXTURE_MIN_FILTER,s)}_applyWrapMode(){const e=this._descriptor,t=e.context?.gl;typeof e.wrapMode=="number"?(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode)):(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode.s),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode.t))}_applyShadowMode(){const e=this._descriptor,t=e.context?.gl,i=e.compareEnabled?t.COMPARE_REF_TO_TEXTURE:t.NONE;t.texParameteri(e.target,t.TEXTURE_COMPARE_MODE,i),e.compareEnabled&&t.texParameteri(e.target,t.TEXTURE_COMPARE_FUNC,t.GREATER),I(t)}_applyAnisotropicFilteringParameters(){const e=this._descriptor,t=e.context.capabilities.textureFilterAnisotropic;t&&e.context.gl.texParameterf(e.target,t.TEXTURE_MAX_ANISOTROPY,e.maxAnisotropy??1)}};export{Te as A,ae as G,se as R,ge as S,oe as a,_e as b,V as c,B as d,O as e,k as f,I as s,Ee as u};
