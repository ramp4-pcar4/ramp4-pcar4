import{e as gt}from"./deduplicate-CH3lCj3p.js";import{O as F}from"./InterleavedLayout-BZ1aEhNI.js";import{e as c}from"./VertexAttribute-BfkzOMLV.js";import{t as Q}from"./glUtil-DBmLLAE9.js";import{aj as w,cM as Y,dl as Nt,dC as lt,ij as mt}from"./main-6eEsl9OJ.js";import{p as It,o as j,s as nt,P as G,c as st,_ as ut,A as ft,K as Ot,u as St}from"./vec32-BvrGiqaM.js";import{e as J}from"./Normals-Cn5ncajV.js";const At=F().vec3f(c.POSITION).u16(c.COMPONENTINDEX).freeze(),Et=F().vec2u8(c.SIDENESS).freeze();Q(Et);const k=F().vec3f(c.POSITION0).vec3f(c.POSITION1).vec2i16(c.NORMALCOMPRESSED).u16(c.COMPONENTINDEX).u8(c.VARIANTOFFSET,{glNormalized:!0}).u8(c.VARIANTSTROKE).u8(c.VARIANTEXTENSION,{glNormalized:!0}).freeze(),K=F().vec3f(c.POSITION0).vec3f(c.POSITION1).vec2i16(c.NORMALCOMPRESSED).vec2i16(c.NORMAL2COMPRESSED).u16(c.COMPONENTINDEX).u8(c.VARIANTOFFSET,{glNormalized:!0}).u8(c.VARIANTSTROKE).u8(c.VARIANTEXTENSION,{glNormalized:!0}).freeze();c.POSITION0,c.POSITION1,c.COMPONENTINDEX,c.VARIANTOFFSET,c.VARIANTSTROKE,c.VARIANTEXTENSION,c.NORMALCOMPRESSED,c.NORMAL2COMPRESSED,c.SIDENESS;class wt{constructor(){this.position0=w(),this.position1=w(),this.faceNormal0=w(),this.faceNormal1=w(),this.componentIndex=0,this.cosAngle=0}}const W=-1;function Tt(t,n,s){const r=t.vertices.position,a=t.vertices.componentIndex,f=m.position0,h=m.position1,g=m.faceNormal0,S=m.faceNormal1,{edges:i,normals:p}=Mt(t),I=i.length/4,A=n.allocate(I);let R=0;const b=I,T=s?.allocate(b);let B=0,e=0,o=0;z.length=0;for(let d=0;d<I;++d){const $=4*d;r.getVec(i.data[$],f),r.getVec(i.data[$+1],h);const x=z.pushNew();x.index=4*d,x.length=It(f,h)}z.sort((d,$)=>$.length-d.length);const u=new Array,l=new Array;z.forAll(({length:d,index:$})=>{const x=i.data[$],ht=i.data[$+1],Z=i.data[$+2],tt=i.data[$+3],et=tt===W;if(r.getVec(x,f),r.getVec(ht,h),et){const E=3*Z;j(g,p.data[E],p.data[E+1],p.data[E+2]),nt(S,g),m.componentIndex=a.get(x),m.cosAngle=G(g,S)}else{let E=3*Z;if(j(g,p.data[E],p.data[E+1],p.data[E+2]),E=3*tt,j(S,p.data[E],p.data[E+1],p.data[E+2]),m.componentIndex=a.get(x),m.cosAngle=G(g,S),$t(m,Vt))return;m.cosAngle<-.9999&&nt(S,g)}e+=d,o++,et||vt(m,Dt)?(n.write(A,R++,m),u.push(d)):yt(m,pt)&&(T&&s&&s.write(T,B++,m),l.push(d))});const O=new Float32Array(u.reverse()),v=new Float32Array(l.reverse()),y=T&&s?{instancesData:T.slice(0,B),lodInfo:{lengths:v}}:void 0;return{regular:{instancesData:A.slice(0,R),lodInfo:{lengths:O}},silhouette:y,averageEdgeLength:e/o}}function vt(t,n){return t.cosAngle<n}function $t(t,n){return t.cosAngle>n}function yt(t,n){const s=Nt(t.cosAngle);return Ot(ot,t.position1,t.position0),s*(G(ut(Rt,t.faceNormal0,t.faceNormal1),ot)>0?-1:1)>n}function Mt(t){const n=t.faces.length/3,s=t.faces,r=t.neighbors,a=t.vertices.position;N.length=q.length=0;for(let f=0;f<n;f++){const h=3*f,g=r[h],S=r[h+1],i=r[h+2],p=s[h],I=s[h+1],A=s[h+2];a.getVec(p,V),a.getVec(I,_),a.getVec(A,X),st(_,_,V),st(X,X,V),ut(V,_,X),ft(V,V),q.pushArray(V),(g===W||p<I)&&(N.push(p),N.push(I),N.push(f),N.push(g)),(S===W||I<A)&&(N.push(I),N.push(A),N.push(f),N.push(S)),(i===W||A<p)&&(N.push(A),N.push(p),N.push(f),N.push(i))}return{edges:N,normals:q}}class Pt{constructor(){this.index=0,this.length=0}}const z=new Y({allocator:t=>t||new Pt,deallocator:null}),N=new Y({deallocator:null}),q=new Y({deallocator:null}),m=new wt,Rt=w(),ot=w(),V=w(),_=w(),X=w(),pt=lt(4),Vt=Math.cos(pt),xt=lt(35),Dt=Math.cos(xt);function rt(t,n,s){const r=n/3,a=new Uint32Array(s+1),f=new Uint32Array(s+1),h=(e,o)=>{e<o?a[e+1]++:f[o+1]++};for(let e=0;e<r;e++){const o=t[3*e],u=t[3*e+1],l=t[3*e+2];h(o,u),h(u,l),h(l,o)}let g=0,S=0;for(let e=0;e<s;e++){const o=a[e+1],u=f[e+1];a[e+1]=g,f[e+1]=S,g+=o,S+=u}const i=new Uint32Array(6*r),p=a[s],I=(e,o,u)=>{if(e<o){const l=a[e+1]++;i[2*l]=o,i[2*l+1]=u}else{const l=f[o+1]++;i[2*p+2*l]=e,i[2*p+2*l+1]=u}};for(let e=0;e<r;e++){const o=t[3*e],u=t[3*e+1],l=t[3*e+2];I(o,u,e),I(u,l,e),I(l,o,e)}const A=(e,o)=>{const u=2*e,l=o-e;for(let O=1;O<l;O++){const v=i[u+2*O],y=i[u+2*O+1];let d=O-1;for(;d>=0&&i[u+2*d]>v;d--)i[u+2*d+2]=i[u+2*d],i[u+2*d+3]=i[u+2*d+1];i[u+2*d+2]=v,i[u+2*d+3]=y}};for(let e=0;e<s;e++)A(a[e],a[e+1]),A(p+f[e],p+f[e+1]);const R=new Int32Array(3*r),b=(e,o)=>e===t[3*o]?0:e===t[3*o+1]?1:e===t[3*o+2]?2:-1,T=(e,o)=>{const u=b(e,o);R[3*o+u]=-1},B=(e,o,u,l)=>{const O=b(e,o);R[3*o+O]=l;const v=b(u,l);R[3*l+v]=o};for(let e=0;e<s;e++){let o=a[e];const u=a[e+1];let l=f[e];const O=f[e+1];for(;o<u&&l<O;){const v=i[2*o],y=i[2*p+2*l];v===y?(B(e,i[2*o+1],y,i[2*p+2*l+1]),o++,l++):v<y?(T(e,i[2*o+1]),o++):(T(y,i[2*p+2*l+1]),l++)}for(;o<u;)T(e,i[2*o+1]),o++;for(;l<O;)T(i[2*p+2*l],i[2*p+2*l+1]),l++}return R}const H=.7;let dt=class{updateSettings(n){this.settings=n,this._edgeHashFunction=n.reducedPrecision?Lt:Ct}write(n,s,r){U.seed=this._edgeHashFunction(r);const a=U.getIntRange(0,255),f=U.getIntRange(0,this.settings.variants-1),h=U.getFloat(),g=255*(.5*Ft(-(1-Math.min(h/H,1))+Math.max(0,h-H)/(1-H),1.2)+.5);n.position0.setVec(s,r.position0),n.position1.setVec(s,r.position1),n.componentIndex.set(s,r.componentIndex),n.variantOffset.set(s,a),n.variantStroke.set(s,f),n.variantExtension.set(s,g)}};const M=new Float32Array(6),P=new Uint32Array(M.buffer),L=new Uint32Array(1);function Ct(t){return M[0]=t.position0[0],M[1]=t.position0[1],M[2]=t.position0[2],M[3]=t.position1[0],M[4]=t.position1[1],M[5]=t.position1[2],L[0]=31*(31*(31*(31*(31*(166811+P[0])+P[1])+P[2])+P[3])+P[4])+P[5],L[0]}function Lt(t){const n=M;n[0]=D(t.position0[0]),n[1]=D(t.position0[1]),n[2]=D(t.position0[2]),n[3]=D(t.position1[0]),n[4]=D(t.position1[1]),n[5]=D(t.position1[2]),L[0]=5381;for(let s=0;s<P.length;s++)L[0]=31*L[0]+P[s];return L[0]}const it=1e4;function D(t){return Math.round(t*it)/it}function Ft(t,n){return Math.abs(t)**n*Math.sign(t)}class bt{constructor(){this._commonWriter=new dt}updateSettings(n){this._commonWriter.updateSettings(n)}allocate(n){return k.createBuffer(n)}write(n,s,r){this._commonWriter.write(n,s,r),St(C,r.faceNormal0,r.faceNormal1),ft(C,C);const{typedBuffer:a,typedBufferStride:f}=n.normalCompressed;J(a,s,C[0],C[1],C[2],f)}static{this.Layout=k}static{this.glLayout=Q(k,1)}}class Bt{constructor(){this._commonWriter=new dt}updateSettings(n){this._commonWriter.updateSettings(n)}allocate(n){return K.createBuffer(n)}write(n,s,r){this._commonWriter.write(n,s,r);{const{typedBuffer:a,typedBufferStride:f}=n.normalCompressed;J(a,s,r.faceNormal0[0],r.faceNormal0[1],r.faceNormal0[2],f)}{const{typedBuffer:a,typedBufferStride:f}=n.normal2Compressed;J(a,s,r.faceNormal1[0],r.faceNormal1[1],r.faceNormal1[2],f)}}static{this.Layout=K}static{this.glLayout=Q(K,1)}}const C=w(),U=new mt;function Gt(t){const n=zt(t.data,t.skipDeduplicate,t.indices,t.indicesLength);return at.updateSettings(t.writerSettings),ct.updateSettings(t.writerSettings),Tt(n,at,ct)}function zt(t,n,s,r){if(n){const h=rt(s,r,t.count);return new _t(s,r,h,t)}const a=gt(t.buffer,t.stride/4,{originalIndices:s}),f=rt(a.indices,r,a.uniqueCount);return{faces:a.indices,facesLength:a.indices.length,neighbors:f,vertices:At.createView(a.buffer)}}class _t{constructor(n,s,r,a){this.faces=n,this.facesLength=s,this.neighbors=r,this.vertices=a}}const at=new bt,ct=new Bt,Jt=F().vec3f(c.POSITION0).vec3f(c.POSITION1),Qt=F().vec3f(c.POSITION0).vec3f(c.POSITION1).u16(c.COMPONENTINDEX);export{At as E,Jt as d,Gt as f,Qt as g,Tt as p,zt as u};
