function hs(e){switch(e){case 1:return"Unknown error";case 2:return"Corrupted geometry";case 3:return"Empty geometry";case 4:return"Math singularity";case 5:return"Buffer is too small";case 6:return"Invalid shape type";case 7:return"Projection out of supported range";case 8:return"Non simple geometry";case 9:return"Cannot calculate geodesic";case 10:return"Notation conversion";case 11:return"Missing grid file";case 12:return"Invalid call";case 13:return"Internal error";case 14:return"Not implemented";case 15:return"IO error";case 16:return"Invalid 3D";case 17:return"An ambiguous geography edge with antipodal points";case 18:return"Geocentric coordinates require ellipsoidal height";case 19:return"Geography cannot be projected into a gnomonic plane or a result of an operation cannot fit into a gnomonic plane";case 20:return"Geometry is too large to be exported in to a given format";case 22:return"Operation is canceled by the user";case 21:return"The operation, such as projection or geodetic computation, cannot be performed without pe-wasm loaded";default:return"unknown error"}}function p(e,t){try{if(!e)throw new Error(t)}catch(s){throw s}}class C extends Error{constructor(t,s){super(s),this.m_AdditionalMessage=s,this.m_ErrorType=t,this.name="GeometryError"}what(){return hs(this.m_ErrorType)}additionalMessage(){return this.m_AdditionalMessage?this.m_AdditionalMessage:""}code(){return this.m_ErrorType}}let os=class extends C{constructor(t){super(2,t),this.name="CorruptedGeometryError"}},as=class extends C{constructor(t){super(3,t),this.name="EmptyGeometryError"}};class ls extends C{constructor(t){super(4,t),this.name="MathSingularityError"}}let ms=class extends C{constructor(t){super(21,t),this.name="ProjectionEngineNotLoadedError"}};class cs extends C{constructor(t){super(8,t),this.name="NonSimpleGeometryError"}}var B;(function(e){e[e.enumUnknown=0]="enumUnknown",e[e.enumPoint=513]="enumPoint",e[e.enumLine=5122]="enumLine",e[e.enumBezier=5123]="enumBezier",e[e.enumEllipticArc=5124]="enumEllipticArc",e[e.enumEnvelope=3077]="enumEnvelope",e[e.enumMultiPoint=8710]="enumMultiPoint",e[e.enumPolyline=25607]="enumPolyline",e[e.enumPolygon=27656]="enumPolygon",e[e.enumMultipatch=40969]="enumMultipatch",e[e.enumGeometryCollection=3594]="enumGeometryCollection",e[e.enumRationalBezier2=5134]="enumRationalBezier2",e[e.enumBezier2=5135]="enumBezier2",e[e.enumRationalBezier23d=5392]="enumRationalBezier23d",e[e.enumGreatArc3d=5393]="enumGreatArc3d"})(B||(B={}));const fs=[0,0,1,1,1,2,0,1,2,3,-1,-1,-1,-1,1,1];function ve(e){return fs[15&e]}function de(e){return!!(512&e)}function _e(e){return!!(1024&e)}function xe(e){return!!(2048&e)}function Vt(e){return!!(4096&e)}function bs(e){return!!(8192&e)}function vs(e){return!!(16384&e)}function ds(e){return!!(32768&e)}function Ne(e){const t=e.getGeometryType();return bs(t)?e.getPointCount():e.isEmpty()?0:t===B.enumEnvelope?4:t===B.enumPoint?1:Vt(t)?2:void _s("missing type")}function jt(e){const t=e.getGeometryType();if(vs(t))return e.hasNonLinearSegments();if(t===B.enumGeometryCollection){const s=e;for(let n=0,i=s.getGeometryCount();n<i;n++)if(jt(s.getGeometry(n)))return!0;return!1}return!!Vt(t)&&t!==B.enumLine}function pe(e){throw new ms(e)}function ye(e){throw new os(e)}function F(e){throw new Error(e)}function Te(e){throw new ls(e)}function ge(){F("Geometry type is not supported for 3D operations.")}function Ee(e){throw new C(12,e)}function Me(e){throw new as(e)}function L(e){throw new C(14,e)}function Yt(e){throw new Error(e)}function _s(e){throw new C(13,e)}function we(e){throw new Error(e)}function Ie(e){throw new cs(e)}function xs(){L("Operation does not support curves.")}function De(e){e&&jt(e)&&xs()}function Pe(e){e&&ds(e.getGeometryType())&&L("Unsupported geometry type.")}function Ns(e){e===B.enumGeometryCollection&&F("Geometry_collection instances are not supported in this operation")}function Ae(e){Ns(e.getGeometryType())}function qe(e){F(`bad wkid: ${e}`)}function ze(e){let t="bad wkt: ";t+=e,t+="...",F(t)}function Ce(e,t){e||F(t)}class k{constructor(t){this.sum=t,this.compensation=0}assign(t){return this.compensation=t.compensation,this.sum=t.sum,this}reset(){this.sum=this.compensation=0}resetToStart(t){this.sum=t,this.compensation=0}normalize(){const t=[Number.NaN];this.sum=Q(this.sum,this.compensation,t),this.compensation=t[0]}add(t){const s=this.sum+t;let n;if(Math.abs(this.sum)>=Math.abs(t)){const i=this.sum-s+t;n=this.compensation+i}else{const i=t-s+this.sum;n=this.compensation+i}this.sum=s,this.compensation=n}sub(t){this.add(-t)}addProduct(t,s){const n=[0],i=Y(t,s,n);this.add(i),this.add(n[0])}mul(t){const s=new k(0);s.addProduct(this.sum,t),s.addProduct(this.compensation,t),this.assign(s)}getResult(){return this.sum+this.compensation}pe(t){return this.add(t),this}me(t){return this.add(-t),this}}const ps=0x00000000ffffffffn,ys=0x0000ffffn,Ts=0x000000ffn,gs=0x0fn,Es=0xffff0000n,Ms=0xff00n,ws=0xf0n,Is=[5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1],Ds=[-1,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3];function et(e){let t=0;return e&ys||(t+=16,e>>=16n),e&Ts||(t+=8,e>>=8n),e&gs||(t+=4,e>>=4n),t+Is[Number(BigInt.asUintN(4,e))]}function Ps(e){let t=0;return e&Es&&(t+=16,e>>=16n),e&Ms&&(t+=8,e>>=8n),e&ws&&(t+=4,e>>=4n),t+Ds[Number(BigInt.asUintN(4,e))]+1}function qt(e){let t=0;return e&ps||(t=32,e>>=32n),t+et(BigInt.asUintN(32,e))}function As(e){let t=0;return 0xffffffff00000000n&e&&(t=32,e>>=32n),t+Ps(e)}class R{constructor(t,s){if(this.m_EnvelopeType=1,t!==void 0){if(t instanceof R)return this.vmin=t.vmin,void(this.vmax=t.vmax);this.vmin=t,this.vmax=s,this.normalize()}else this.setEmpty()}static construct(t,s){return new R(t,s)}static constructEmpty(){return new R}setCoords(t,s){this.vmin=t,this.vmax=s,this.normalize()}setCoordsFromEnvelope(t){this.vmin=t.vmin,this.vmax=t.vmax}setEmpty(){this.vmin=Number.NaN,this.vmax=Number.NaN}getCenter(){return .5*(this.vmin+this.vmax)}equalsRange(t,s){return Ft(this.vmin,t)&&Ft(this.vmax,s)}equals(t,s){return!(!this.isEmpty()||!t.isEmpty())||(s!==void 0?Math.abs(this.vmin-t.vmin)<=s&&Math.abs(this.vmax-t.vmax)<=s:this.vmin===t.vmin&&this.vmax===t.vmax)}width(){return this.vmax-this.vmin}isEmpty(){return Number.isNaN(this.vmin)||Number.isNaN(this.vmax)}isZero(){return this.vmin===this.vmax}setInfinite(){this.vmin=Number.NEGATIVE_INFINITY,this.vmax=Number.POSITIVE_INFINITY}move(t){this.isEmpty()||(this.vmin+=t,this.vmax+=t)}contains(t){return t.vmin>=this.vmin&&t.vmax<=this.vmax}containsCoordinate(t){return t>=this.vmin&&t<=this.vmax}containsRightExclusive(t){return t>=this.vmin&&t<this.vmax}containsExclusiveCoordinate(t){return t>this.vmin&&t<this.vmax}containsExclusive(t){return t.vmin>this.vmin&&t.vmax<this.vmax}isIntersecting(t){return this.vmin<=t.vmin?this.vmax>=t.vmin:t.vmax>=this.vmin}mergeCoordinate(t){if(this.isEmpty())return this.vmin=t,void(this.vmax=t);this.mergeNeCoordinate(t)}merge(t){if(t.isEmpty())return;const s=t.vmin,n=t.vmax;this.mergeCoordinate(s),this.mergeCoordinate(n)}mergeNe(t){const s=t.vmin,n=t.vmax;this.mergeNeCoordinate(s),this.mergeNeCoordinate(n)}mergeNeCoordinate(t){t<this.vmin?this.vmin=t:t>this.vmax&&(this.vmax=t)}intersect(t){this.isEmpty()||t.isEmpty()?this.setEmpty():(this.vmin<t.vmin&&(this.vmin=t.vmin),this.vmax>t.vmax&&(this.vmax=t.vmax),this.vmin>this.vmax&&this.setEmpty())}inflate(t){this.isEmpty()||(this.vmin-=t,this.vmax+=t,this.vmax<this.vmin&&this.setEmpty())}normalize(){this.vmin<=this.vmax||(this.vmin>this.vmax?this.vmax=W(this.vmin,this.vmin=this.vmax):this.setEmpty())}isValid(){return this.isEmpty()||this.vmin<=this.vmax}snapClip(t){return us(t,this.vmin,this.vmax)}calculateToleranceFromEnvelope(){return this.isEmpty()?Ot():(Math.abs(this.vmin)+Math.abs(this.vmax)+1)*Ot()}static unit(){return qs}normalizeNoNAN(){this.vmin>this.vmax&&(this.vmax=W(this.vmin,this.vmin=this.vmax))}setCoordsNoNAN(t,s){this.vmin=t,this.vmax=s,this.normalizeNoNAN()}clone(){return new R(this.vmin,this.vmax)}}const qs=new R(0,1);class b{static getNAN(){return new b(Number.NaN)}constructor(t,s){this.m_value=t??0,this.m_eps=s??0}[Symbol.toPrimitive](t){return this}clone(){return new b(this.m_value,this.m_eps)}assign(t){return this.m_value=t.m_value,this.m_eps=t.m_eps,this}scaleError(t){this.m_eps*=t}setError(t){this.m_eps=t}set(t,s){return this.m_value=t,this.m_eps=s??0,this}setWithEps(t,s){return s===void 0&&(s=1),this.m_value=t,this.m_eps=b.ulp(t)*s,this}setE(t){return this.m_value=t.m_value,this.m_eps=t.m_eps,this}precise(){return new b(this.m_value)}value(){return this.m_value}toDouble(){return this.m_value}eps(){return this.m_eps}resetError(){return this.m_eps=0,this}absThis(){return this.m_value=Math.abs(this.m_value),this}add(t){return this.clone().addThis(t)}addE(t){return this.clone().addThisE(t)}addThisE(t){const s=this.m_value+t.m_value,n=this.m_eps+t.m_eps+b.ulp(s);return this.m_value=s,this.m_eps=n,this}addThis(t){const s=this.m_value+t,n=this.m_eps+b.ulp(s);return this.m_value=s,this.m_eps=n,this}subE(t){return this.clone().subThisE(t)}sub(t){return this.clone().subThis(t)}subThisE(t){const s=this.m_value-t.m_value,n=this.m_eps+t.m_eps+b.ulp(s);return this.m_value=s,this.m_eps=n,this}subThis(t){const s=this.m_value-t,n=this.m_eps+b.ulp(s);return this.m_value=s,this.m_eps=n,this}setAddE(t,s){return this.m_value=t.m_value+s.m_value,this.m_eps=t.m_eps+s.m_eps+b.ulp(this.m_value),this}setAdd(t,s){return this.m_value=t+s,this.m_eps=b.ulp(this.m_value),this}setAddEN(t,s){return this.m_value=t.m_value+s,this.m_eps=t.m_eps+b.ulp(this.m_value),this}setAddNE(t,s){return this.m_value=t+s.m_value,this.m_eps=s.m_eps+b.ulp(this.m_value),this}setSubE(t,s){return this.m_value=t.m_value-s.m_value,this.m_eps=t.m_eps+s.m_eps+b.ulp(this.m_value),this}setSub(t,s){return this.m_value=t-s,this.m_eps=b.ulp(this.m_value),this}setSubEN(t,s){return this.m_value=t.m_value-s,this.m_eps=t.m_eps+b.ulp(this.m_value),this}setSubNE(t,s){return this.m_value=t-s.m_value,this.m_eps=s.m_eps+b.ulp(this.m_value),this}mulThisE(t){const s=this.m_value*t.m_value;return this.m_eps=this.m_eps*Math.abs(t.m_value)+t.m_eps*Math.abs(this.m_value)+this.m_eps*t.m_eps+b.ulp(s),this.m_value=s,this}mulThis(t){const s=this.m_value*t;return this.m_eps=this.m_eps*Math.abs(t)+b.ulp(s),this.m_value=s,this}mul(t){return this.clone().mulThis(t)}mulE(t){return this.clone().mulThisE(t)}setMulE(t,s){const n=t.m_value*s.m_value;return this.m_eps=t.m_eps*Math.abs(s.m_value)+s.m_eps*Math.abs(t.m_value)+t.m_eps*s.m_eps+b.ulp(n),this.m_value=n,this}setMul(t,s){return this.m_value=t*s,this.m_eps=b.ulp(this.m_value),this}setMulEN(t,s){return this.setE(t),this.mulThis(s)}setMulNE(t,s){return this.setE(s),this.mulThis(t)}mulThisByPower2(t){return this.m_value*=t,this.m_eps*=Math.abs(t),this}static st_mulByPower2(t,s){return new b(t.m_value,t.m_eps).mulThisByPower2(s)}divE(t){return this.clone().divThisE(t)}divThisE(t){const s=Math.abs(t.m_value),n=this.m_value/t.m_value;let i=(this.m_eps+Math.abs(n)*t.m_eps)/s;if(t.m_eps>.01*s){const r=t.m_eps/s;i*=1+(1+r)*r}return this.m_value=n,this.m_eps=i+b.ulp(n),this}divThis(t){const s=Math.abs(t);return this.m_value/=t,this.m_eps=this.m_eps/s+b.ulp(this.m_value),this}setDivE(t,s){return this.setE(t),this.divThisE(s)}setDiv(t,s){return this.m_value=t/s,this.m_eps=b.ulp(this.m_value),this}setDivEN(t,s){return this.setE(t),this.divThis(s)}setDivNE(t,s){return this.set(t),this.divThisE(s)}divThisByPower2(t){return this.m_value/=t,this.m_eps/=Math.abs(t),this}invThis(){return this.setE(j.clone().divThisE(this)),this}sqrt(){return this.clone().sqrtThis()}sqrtThis(){let t,s;return this.m_value>=0?(t=Math.sqrt(this.m_value),s=this.m_value>10*this.m_eps?.5*this.m_eps/t:this.m_value>this.m_eps?t-Math.sqrt(this.m_value-this.m_eps):Math.max(t,Math.sqrt(this.m_value+this.m_eps)-t),s+=b.ulp(t)):this.m_value<-this.m_eps?(t=Number.NaN,s=Number.NaN):(t=0,s=Math.sqrt(this.m_eps)),this.m_value=t,this.m_eps=s,this}sqr(){return this.clone().sqrThis()}sqrThis(){const t=this.m_value*this.m_value;return this.m_eps=2*this.m_eps*Math.abs(this.m_value)+this.m_eps*this.m_eps+b.ulp(t),this.m_value=t,this}setSin(t){const s=Math.sin(t.m_value),n=Math.cos(t.m_value);this.m_value=s;const i=Math.abs(s),r=Math.abs(t.value());return this.m_eps=(Math.abs(n)+.5*i*t.m_eps)*t.m_eps+b.ulp(i+r),this}static ulp(t){let s=U(t);const n=((0x7ff0000000000000n&s)>>52n)-1075n;return n>-1023n?(s=n+0x3ffn<<52n,Ws(s)):t===0?0:Number.MIN_VALUE}setCos(t){const s=Math.sin(t.m_value),n=Math.cos(t.m_value);this.m_value=n;const i=Math.abs(n),r=Math.abs(t.value());return this.m_eps=(Math.abs(s)+.5*i*t.m_eps)*t.m_eps+b.ulp(i+r),this}static st_cosAndSin(t,s,n){const i=Math.sin(t.m_value),r=Math.cos(t.m_value);n.m_value=i,s.m_value=r;const u=Math.abs(i),o=Math.abs(r),h=Math.abs(t.value());n.m_eps=(Math.abs(r)+.5*u*t.m_eps)*t.m_eps+b.ulp(u+h),s.m_eps=(Math.abs(i)+.5*o*t.m_eps)*t.m_eps+b.ulp(o+h)}negate(){return this.clone().negateThis()}negateThis(){return this.m_value=-this.m_value,this}setAbs(){return this.m_value=Math.abs(this.m_value),this}isInInterval(t){return R.construct(this.m_value-this.m_eps,this.m_value+this.m_eps).isIntersecting(t)}eq(t){return Math.abs(this.m_value-t.m_value)<=this.m_eps+t.m_eps}ne(t){return!this.eq(t)}gt(t){return this.m_value-t.m_value>this.m_eps+t.m_eps}lt(t){return t.m_value-this.m_value>this.m_eps+t.m_eps}ge(t){return!this.lt(t)}le(t){return!this.gt(t)}tolEQ(t,s){return Math.abs(this.m_value-t.m_value)<=s||this.eq(t)}tolNE(t,s){return!this.tolEQ(t,s)}tolGT(t,s){return this.m_value-t.m_value>s&&this.gt(t)}tolLT(t,s){return t.m_value-this.m_value>s&&this.lt(t)}tolGE(t,s){return!this.tolLT(t,s)}tolLE(t,s){return!this.tolGT(t,s)}isZero(){return Math.abs(this.m_value)<=this.m_eps}isFuzzyZero(){return this.isZero()&&this.m_eps!==0}tolIsZero(t){return Math.abs(this.m_value)<=Math.max(this.m_eps,t)}setPi(){this.setE(zs)}setEuler(){this.set(2.718281828459045,rt())}static size(){return 1}}function T(e,t){const s=X(e),n=X(t),i=53-qt(s),r=53-qt(n);return(i>=0?i:0)+(r>=0?r:0)<=52}function V(e,t){const s=e+t;return s-e===t&&s-t===e}function M(e,t){const s=e-t;return e-s===t&&t+s===e}function rt(){return S()}b.dimensions=1;const zs=new b(Math.PI,.5*rt()),Ze=new b(0,0),j=new b(1,0),$e=new b(4,0);function Re(e,t,s){return e.addE(t.subE(e).mulE(s))}function Be(e,t,s){return t.subE(t.subE(e).mulE(j.subE(s)))}function Cs(e){return Math.atanh(e)}function Ge(e){let t;if(e===0)t=1;else if(Math.abs(e)>.01)t=Cs(e)/e;else{let s;const n=-36.841361487904734;t=0;const i=e*e;for(let r=2*Math.trunc(n/Math.log(i)+2.5)-1;r>1;r-=2)s=1/r,t=(t+s)*i;t+=1}return t}function nt(e){const t=Math.PI*Math.PI/6;let s;if(e===1)s=t;else if(e>1)s=t;else if(e===0)s=e;else if(e<0){const n=1+(e=Math.abs(e)),i=Math.log(n);s=i*i/-2-nt(e/n)}else if(e>.5){const n=1-e,i=Math.log(e)*Math.log(n);s=t-nt(n)-i}else{s=0;const n=1+Math.trunc(-16*Math.log(10)/Math.log(e)+1.5);let i=n;for(let r=n;r>0;r--,i-=1)s*=e,s+=1/(i*i);s*=e}return s}function ke(e,t){const s=t*e;if(Math.abs(t)<.1){let n=0;for(let i=60;i>=1;i--)n*=s,n+=1/i/i;return n*=e,n}return nt(s)/t}function Se(e,t){return e<t?St(e,t):St(t,e)}function Le(e,t){const s=Math.abs(e);return t>=0?s:-s}function Fe(e){return Math.round(e)}function Zs(e,t,s,n,i){i[0]=t[0]+(s[0]-t[0])*n,i[1]=t[1]+(s[1]-t[1])*n,e===3&&(i[2]=t[2]+(s[2]-t[2])*n)}function $s(e,t,s,n,i){i[0]=s[0]-(s[0]-t[0])*(1-n),i[1]=s[1]-(s[1]-t[1])*(1-n),e===3&&(i[2]=s[2]-(s[2]-t[2])*(1-n))}function Oe(e,t,s,n,i){n<=.5?Zs(e,t,s,n,i):$s(e,t,s,n,i)}function Qe(e,t,s,n,i){i[0]=t[0].addE(s[0].subE(t[0]).mulE(n)),i[1]=t[1].addE(s[1].subE(t[1]).mulE(n))}function Ue(e,t,s,n,i){i[0]=s[0].subE(s[0].subE(t[0]).mulE(j.subE(n))),i[1]=s[1].subE(s[1].subE(t[1]).mulE(j.subE(n)))}function it(e,t,s){let n;return n=s<=.5?e+(t-e)*s:t-(t-e)*(1-s),n}function Ve(e,t,s){return e+(t-e)*s}function je(e,t,s){return t-(t-e)*(1-s)}function zt(e,t,s,n){s<=.5?(n.x=e.x+(t.x-e.x)*s,n.y=e.y+(t.y-e.y)*s):(n.x=t.x-(t.x-e.x)*(1-s),n.y=t.y-(t.y-e.y)*(1-s))}function Ye(e,t,s,n){s<=.5?(n.x=e.x+(t.x-e.x)*s,n.y=e.y+(t.y-e.y)*s,n.z=e.z+(t.z-e.z)*s):(n.x=t.x-(t.x-e.x)*(1-s),n.y=t.y-(t.y-e.y)*(1-s),n.z=t.z-(t.z-e.z)*(1-s))}function Ct(e){return e*e}function We(e){return e*e*e}function Xe(e){return 1/Math.sqrt(e)}function He(e){return e<0?-1:e>0?1:0}function Je(e,t,s,n){const i=[0],r=[0],u=[0];return Q(Y(e,s,i),Y(t,n,r),u)+(i[0]+r[0]+u[0])}const Zt=[0],Rs=[0];function Ke(e,t,s){return Bs(Y(e,t,Zt),s,Zt[0],Rs)}const J=[0],K=[0],tt=[0],st=[0];function Y(e,t,s){const n=e*t;return $t(e,J,K),$t(t,tt,st),s[0]=K[0]*st[0]-(n-J[0]*tt[0]-K[0]*tt[0]-J[0]*st[0]),n}function $t(e,t,s){const n=134217729*e;t[0]=n-(n-e),s[0]=e-t[0]}const Rt=[0],Bt=[0];function Bs(e,t,s,n){const i=Q(e,t,Rt),r=Q(i,s,Bt);return Q(r,Rt[0]+Bt[0],n)}function Q(e,t,s){const n=e+t;return Math.abs(e)>Math.abs(t)?s[0]=e-n+t:s[0]=t-n+e,n}function tn(e,t){return e%t}function Wt(e){const t=1-e;if(t===0)return 1;let s;if(t<=.01){const n=t,i=Math.log(n);s=1+n*(.4431471805599453-.25*i+n*(.05680519270997949-.09375*i+n*(.02183137044373718-.05859375*i+n*(.011544521417308362-.042724609375*i+n*(.00714200031339596-.0336456298828125*i+n*(.004854743337164948-.027757644653320312*i+n*(.003514687963781376-.023627042770385742*i)))))))}else{if(e<.016){const n=e;return P()*(1-n*(.25+n*(.046875+n*(.01953125+n*(.01068115234375+n*(.0067291259765625+n*(.004626274108886719+n*(.0033752918243408203+n*.0025710230693221092))))))))}s=Xt(0,t,1)-e*Ht(0,t,1)/3}return us(s,1,P())}function Gs(e,t,s=Number.NaN){if(p(t>=0&&t<=1),t===0)return e;let n=1,i=e;if(i<0&&(i=-i,n=-1),t===1){const l=Math.round(i/Qt()),c=i-l*Qt();return n*(2*l+Math.sin(c))}const r=P(),u=Math.floor(i/r);1&u?i=(u+1)*r-i:i-=u*r;const o=Math.sin(i),h=Number.isNaN(s)?Wt(t):s;let a;if(o===1)a=h+Math.sqrt(1-t)*(i-r);else{const l=i*i;if(.01424*Math.pow(l,4)<=2*S())a=i*(1+l*t*(-1/6+l*((4-3*t)/120-(16+(45*t-60)*t)/5040*l)));else if(t<=.01){const c=Math.sin(2*i),v=Math.sin(4*i),d=Math.sin(6*i),x=Math.sin(8*i),_=Math.sin(10*i);a=i+t*((2*-i+c)/8+t*((-3*i+2*c-.25*v)/64+t*((-20*i+15*c-3*v+d/3)/1024+t*(5*(-140*i+112*c-28*v+16/3*d-.5*x)/65536+7*t*((-63*i+52.5*c-15*v+3.75*d-.625*x+.05*_)/65536+t*(-693*i+594*c-185.625*v+1.375*d-12.375*x+1.8*_-.125*Math.sin(12*i))/1048576)))))}else{const c=o*o,v=Math.cos(i),d=v*v,x=Jt(o,v,t);a=o*(Xt(d,x,1)-t*c*Ht(d,x,1)/3)}}return 1&u?a=h*(u+1)-a:a+=h*u,n*a}function sn(e,t,s=Number.NaN){if(e===0)return 0;let n=1,i=e;e<0&&(i=-i,n=-1);const r=Number.isNaN(s)?Wt(t):s,u=Math.floor(i/r);1&u?i=(u+1)*r-i:i-=u*r;let o=i<=0?0:i>=r?P():ks(i,t,r);return 1&u?o=P()*(u+1)-o:o+=P()*u,n*o}function Xt(e,t,s){p((e!==0?1:0)+(t!==0?1:0)+1>1);let n=e,i=t,r=s;for(;;){const u=Math.sqrt(n*i)+Math.sqrt(i*r)+Math.sqrt(r*n);n=.25*(n+u),i=.25*(i+u),r=.25*(r+u);const o=(n+i+r)/3,h=(o-n)/o,a=(o-i)/o,l=(o-r)/o;if(Math.abs(h)<=.0024&&Math.abs(a)<=.0024&&Math.abs(l)<=.0024){const c=h*a-l*l,v=h*a*l;return(1+(1/24*c-.1-3/44*v-5*c*c/208+c*v/16)*c+(1/14+3*v/104)*v)/Math.sqrt(o)}}}function Ht(e,t,s){p(e!==0||t!==0);let n=e,i=t,r=s;const u=new k(0);let o=1;for(;;){const h=.2*(n+i+3*r),a=(h-n)/h,l=(h-i)/h,c=(h-r)/h;if(Math.abs(a)<=.0015&&Math.abs(l)<=.0015&&Math.abs(c)<=.0015){const N=a*l,y=c*c,E=N-y,A=N-6*y,w=A+E+E,g=3/26,I=A*(.25*(9/22)*A-.21428571428571427-1.5*g*c*w),D=c*(1/6*w+c*(-.4090909090909091*E+c*g*N));return 3*u.getResult()+o*(1+I+D)/(h*Math.sqrt(h))}const v=Math.sqrt(n),d=Math.sqrt(i),x=Math.sqrt(r),_=v*(d+x)+d*x;u.add(o/(x*(r+_))),o*=.25,n=.25*(n+_),i=.25*(i+_),r=.25*(r+_)}}function Jt(e,t,s){return e<.999?1-s*Ct(e):1-s+s*Ct(t)}function ks(e,t,s){if(t===0)return e;if(t===1)return Math.asin(e);let n=0,i=!0;if(e<.2){const u=e*e,o=e*(1+u*t*(1/6+u*((13*t-4)/120+(16-284*t+493*t*t)/5040*u))),h=Math.abs(t*(4944*t-64-31224*t*t+37369*t*t*t)/362880*Math.pow(e,9));if(h<Math.abs(o)*S())return o;n=o,i=h>.1*o}if(i){const u=1-t,o=1-e/s,h=Math.sqrt(o*o+u*u),a=Math.atan2(u,e+S());n=P()+Math.sqrt(h)*(a-P())}let r=0;for(let u=0;u<7;u++){r=Gs(n,t,s);const o=Jt(Math.sin(n),Math.cos(n),t);if(n-=(r-e)/Math.sqrt(o),u>0&&Math.abs(r-e)<=4*S()*e)break}return n}class Ss{constructor(t){for(this.values=[[1]];this.values.length<t+1;){const s=this.values.at(-1),n=ts(s.length+1,1);for(let i=1;i<s.length;++i)n[i]=s[i-1]+s[i];this.values.push(n)}}get(t,s){return this.values[t][s]}}function Ls(e,t){return p(0),0}const Gt=new Ss(32);function kt(e,t){if(e<Gt.values.length)return Gt.get(e,t);const s=Math.exp(Ls());return s+.01>ut()&&Yt("The result value of n choose k is out of range"),s+.01}function Kt(e,t){if(e.isZero())return e.clone();const s=e.clone().divThis(e);if(t<0)return s.divThis(Kt(e,-t));for(e=e.clone(),t=Math.trunc(t);1&t&&s.mulThis(e),t>>=1;)e.mulThis(e);return s}function en(e,t){if(t===0)return[];const s=e[0].clone().mulDoubleThis(0),n=[];n.length=t;const i=t-1;for(let r=0;r<=i;++r){n[r]=s.clone();for(let u=0;u<=r;++u)n[r].addThis(e[u].clone().mulDoubleThis(kt(r,u)/kt(i,u)))}return n}function nn(e,t,s,n,i){return e===0?n===0?t:n===1?s:i:e===1?n===0?t:n===1?s:it(t,s,n):(e===2&&L("angular interpolation"),void L(""))}function rn(e,t,s,n,i,r,u,o){if(e===0)for(let h=0;h<r;++h)n[h+i]=u===0?t[h]:u===1?s[h]:o;else if(e===1)if(u===0)G(n,t,i,0,r);else if(u===1)G(n,s,i,0,r);else for(let h=0;h<r;++h)n[h+i]=it(t[h],s[h],u);else if(e===2)if(u===0)G(n,t,i,0,r);else if(u===1)G(n,s,i,0,r);else{let h=0;for(let a=0,l=i;a<r;++a,++l)n[l]=it(t[a],s[a],u),h+=n[l]*n[l];if(h>0){h=Math.sqrt(h);for(let a=i;a<i+r;++a)n[a]/=h}else{for(let a=i;a<i+r;++a)n[a]=0;n[i]=1}}else L("")}function G(e,t,s,n,i){if(i===0)return;let r=0,u=s,o=n;for(;r++<i;)e[u++]=t[o++]}function un(e,t,s){let n=0;for(let i=0;!n&&i<s;++i)n=e[i]-t[i];return n}function W(e,t){return e}function Fs(e){e.sort((t,s)=>t<s?-1:t>s?1:0)}function hn(e,t){const s=e.slice(0,t);Fs(s),G(e,s,0,0,t)}function on(e,t,s,n){const i=e.slice(t,t+s);i.sort(n),G(e,i,t,0,s)}function an(e,t){return e<t?-1:e>t?1:0}function ln(e,t,s,n){return e<s?-1:e>s?1:t<n?-1:t>n?1:0}function mn(e,t){if(e.length<2)return e.length;let s=0;for(let n=1;n<e.length;++n)t(e[n],e[s])||(s++,e[n]=W(e[s],e[s]=e[n]));return 1+s}function cn(e,t){e[t]=e.at(-1),e.pop()}function fn(e,t=!1){return{[Symbol.dispose](){this.bForget||e()},bForget:t}}function bn(e,t,s){e.length=t,e.fill(s)}function vn(e,t,s){e.length=s;for(let n=0;n<s;++n)e[n]=new t}function Os(e,t){const s=new Array(t);for(let n=0;n<t;++n)s[n]=new e;return s}function dn(e,t,s){for(let n=0;n<s;++n)e[n].assign(t[n]);return s}function _n(e,t){const s=e.slice(0,t);for(let n=0;n<t;++n)s[n]=s[n].clone();return s}function xn(e){return Array.from({length:e},()=>null)}function Nn(e,t){return Array.from({length:t},()=>e())}function ts(e,t){const s=new Array(e);return s.fill(t),s}function pn(e,t){return t in e&&Object.getOwnPropertyNames(e).length===1}class yn{constructor(...t){this.m_elts=t}get length(){return this.m_elts.length}at(t){return this.m_elts[t]}[Symbol.dispose](){for(const t of this.m_elts)t[Symbol.dispose]()}}function St(e,t){return{first:e,second:t}}const Qs=Math.PI,Us=2*Math.PI,Vs=.5*Math.PI;class Tn{constructor(t,s){this.m_cr=t,this.m_cc=s,this.m_v=ts(t*s,0)}get(t,s){return this.m_v[t*this.m_cc+s]}set(t,s,n){this.m_v[t*this.m_cc+s]=n}inc(t,s){return++this.m_v[t*this.m_cc+s]}}const ss=new ArrayBuffer(8),es=new Float64Array(ss),ns=new BigUint64Array(ss),js=0x0fffffffffffffn,Ys=0x7ff0000000000000n;function gn(){return Number.EPSILON*ie}function U(e){return es[0]=e,ns[0]}function Ws(e){return ns[0]=e,es[0]}function X(e){return U(e)&js}function Lt(e){return Number((U(e)&Ys)>>52n)}function Z(e){if(e===0n)return-1n;if(e===1n||-1n===e)return 0n;e<0n&&(e=-e);let t=0n,s=512n,n=1n<<t+s;for(;e>=n;)t+=s,s<<=1n,n<<=s;let i=t;s>>=1n;let r=i+s;for(;s>0n;)e<1n<<r||(i=r),s>>=1n,r=i+s;return i}function Ft(e,t){return e===t||Number.isNaN(e)&&Number.isNaN(t)}function En(e,t,s){return e===t||Math.abs(e-t)<=s||Number.isNaN(e)&&Number.isNaN(t)}function Mn(e,t){return e<t?-1:e>t?1:0}function wn(e,t){if(e<t)return-1;if(e>t)return 1;if(e===t)return 0;{const s=Number.isNaN(e),n=Number.isNaN(t);return s<n?-1:s>n?1:0}}function In(){return 2147483647}function Dn(){return 32767}function ut(){return 2147483647}function Pn(){return-2147483648}const H=ut(),Xs=BigInt(H),is=2166136261,O=16777619;function Hs(e){let t=is,s=e;return t=(t^255&s)*O,s>>=8,t=(t^255&s)*O,s>>=8,t=(t^255&s)*O,s>>=8,t=(t^255&s)*O,t&H}const Js=14695981039346656037n,$=1099511628211n;function Ks(e){let t=Js,s=e;return t=(t^0xffn&s)*$,s>>=8n,t=(t^0xffn&s)*$,s>>=8n,t=(t^0xffn&s)*$,s>>=8n,t=(t^0xffn&s)*$,s>>=8n,t=(t^0xffn&s)*$,s>>=8n,t=(t^0xffn&s)*$,s>>=8n,t=(t^0xffn&s)*$,t&Xs}function te(e){return 1103515245*e+12345&2147483647}function An(e){let t=is;for(let s=0,n=e.length;s<n;++s)t=(t^e.charCodeAt(s))*O;return t&H}function ht(e,t){return t+2654435769+(e<<6)+(e>>2)&H}function qn(e,t){return ht(e,rs(t))}function se(e){return ht(3735928559,e)}function zn(e,t){return ht(e,se(t))}function Cn(e){return Hs(e)}function rs(e){return Number(Ks(e))}function ee(e){return ue(e)}function Zn(e){return rs(U(ee(e)))}function $n(e){return te(e)}const ne=100,ie=100;function Ot(){return Number.EPSILON*ne}function Rn(){return .38196601125010515}function Bn(){return 1.4142135623730951}function S(){return Number.EPSILON}function Gn(e,t,s){return e===t||e===s}function us(e,t,s){return e>=t?e<=s?e:s:t}function kn(e,t,s){const n=e[0];if(n>=t){if(n<=s)return!1;e[0]=s}else e[0]=t;return!0}function Sn(e,t){return e>=t?t:e<-t?-t:e}function Qt(){return Qs}function Ln(){return Us}function P(){return Vs}const re=3*P();function Fn(){return re}function ue(e){return e+0}function Ut(e){return{v:e}}class m{constructor(){this.m_rn=Ut(0n),this.m_rd=Ut(1n),this.m_bNaN=!1,this.m_bNormalized=!1,this.m_power=0,this.m_sign=0}static constructAssign(t,s){const n=t.clone();return s!==void 0&&n.limitPrecisionThis(s),n}static constructDouble(t){return new m().setDouble(t)}static constructInt64(t){return new m().setInt64(t)}static constructRational(t,s){return new m().setRational(t,s)}static constructInt32(t){return this.constructInt64(BigInt(Math.trunc(t)))}[Symbol.toPrimitive](t){return this}compare(t){return this.lt(t)?-1:this.gt(t)?1:0}assignCopy(t){return this.setThis(t)}abs(){return this.clone().absThis()}absThis(){return this.isNAN()||(this.m_sign*=this.m_sign),this}clone(){return new m().setThis(this)}setThis(t){return this.m_bNaN=t.m_bNaN,this.m_bNormalized=t.m_bNormalized,this.m_rn.v=t.m_rn.v,this.m_rd.v=t.m_rd.v,this.m_power=t.m_power,this.m_sign=t.m_sign,this}setZero(){return this.m_rn.v=0n,this.m_rd.v=1n,this.m_bNaN=!1,this.m_power=0,this.m_bNormalized=!0,this.m_sign=0,this}setDouble(t){if(this.setZero(),t===0)return this;if(Number.isInteger(t)&&Math.abs(t)<ut())return this.setInt32(t);const s=U(t),n=(s&m.s_em)>>52n,i=!!(s&m.s_sm),r=s&m.s_fm;if(n===m.s_emax)return r?(this.m_rn.v=this.m_rd.v=0n,this.m_bNaN=!0,this):(this.m_rn.v=i?-1n:1n,this.m_rd.v=0n,this);n===0n&&L("denormalized numbers not yet implemented");const u=n-1023n,o=u>=0n?u:0n,h=u<0n?-u:0n;return this.m_rn.v=(1n<<52n|r)<<o,this.m_rd.v=1n<<52n+h,this.m_sign=i?-1:1,this.m_bNormalized=!1,this.normalizeThis()}setInt64(t){return t===0n?this.setZero():(this.m_bNaN=!1,this.m_sign=t>0n?1:-1,this.m_rn.v=t>0n?t:-t,this.m_rd.v=1n,this.m_power=0,this.m_bNormalized=!1,this.normalizeThis())}setRational(t,s){return t===0n?s===0n?this.setNAN():this.setZero():s===0n?t>0n?this.setPositiveInf():this.setNegativeInf():(this.m_sign=(t>0n?1:-1)*(s>0n?1:-1),this.m_rn.v=t>0n?t:-t,this.m_rd.v=s>0n?s:-s,this.m_power=0,this.m_bNormalized=!1,this.normalizeThis())}setInt32(t){return this.setInt64(BigInt(Math.trunc(t)))}getDouble(){return this.convertToDouble()}toDouble(){return this.convertToDouble()}value(){return this.convertToDouble()}isNAN(){return this.m_bNaN}isPositiveInf(){return!this.isNAN()&&this.m_rd.v===0n&&this.m_sign===1}isNegativeInf(){return!this.isNAN()&&this.m_rd.v===0n&&this.m_sign===-1}isFinite(){return!this.isNAN()&&this.m_rd.v!==0n}setNAN(){return this.m_bNaN=!0,this.m_rn.v=0n,this.m_rd.v=0n,this.m_power=0,this.m_bNormalized=!0,this}setPositiveInf(){return this.m_rn.v=1n,this.m_rd.v=0n,this.m_bNaN=!1,this.m_bNormalized=!0,this.m_sign=1,this.m_power=0,this}setNegativeInf(){return this.m_rn.v=1n,this.m_rd.v=0n,this.m_bNaN=!1,this.m_bNormalized=!0,this.m_sign=-1,this.m_power=0,this}subThis(t){if(t.isNAN()&&this.setNAN(),this.isPositiveInf()&&t.isPositiveInf())this.setNAN();else{if(this.isPositiveInf()&&t.isNegativeInf())return this.setPositiveInf(),this;if(this.isNegativeInf()&&t.isNegativeInf())this.setNAN();else if(this.isNegativeInf()&&t.isPositiveInf())return this.setNegativeInf(),this}return this.isNAN()?this:this.opPlusMinus(t,!1)}thisSubAbs(t){return p(0),this}mulThis(t){return t.isNAN()&&this.setNAN(),this.isNAN()?this:(this.m_sign*=t.m_sign,this.m_sign===0?this.setZero():(this.m_rn.v*=t.m_rn.v,this.m_rd.v*=t.m_rd.v,this.m_power+=t.m_power,this.m_bNormalized=!1,this.normalizeThis(),this))}mulDoubleThis(t){return this.mulThis(m.constructDouble(t))}thisMulInt64(t){return p(0),this}thisMulInt32(t){return p(0),this}divThis(t){return this.mulThis(t.clone().invertThis())}divDoubleThis(t){return this.divThis(m.constructDouble(t))}addDoubleThis(t){return this.addThis(m.constructDouble(t))}subDoubleThis(t){return this.subThis(m.constructDouble(t))}mul(t){return this.clone().mulThis(t)}mulBigIntThis(t){return this.mulThis(m.constructInt64(t))}mulDouble(t){return this.clone().mulThis(m.constructDouble(t))}div(t){return this.clone().divThis(t)}divDouble(t){return this.clone().divDoubleThis(t)}add(t){return this.clone().addThis(t)}fmSubThis(t,s){return this.subThis(t.clone().mulThis(s))}fmAddThis(t,s){return this.addThis(t.clone().mulThis(s))}addThis(t){if(t.isNAN()&&this.setNAN(),this.isPositiveInf()&&t.isPositiveInf())return this.setPositiveInf(),this;if(this.isPositiveInf()&&t.isNegativeInf())this.setNAN();else{if(this.isNegativeInf()&&t.isNegativeInf())return this.setNegativeInf(),this;this.isNegativeInf()&&t.isPositiveInf()&&this.setNAN()}return this.isNAN()?this:this.opPlusMinus(t,!0)}addDouble(t){return this.clone().addThis(m.constructDouble(t))}sub(t){return this.clone().subThis(t)}subDouble(t){return this.clone().subThis(m.constructDouble(t))}isZero(){return this.m_sign===0}equals(t){return this.clone().subThis(t).isZero()}lt(t){return!this.isNAN()&&!t.isNAN()&&!(this.isPositiveInf()&&t.isPositiveInf()||this.isNegativeInf()&&t.isNegativeInf())&&!this.isPositiveInf()&&(!!t.isPositiveInf()||this.clone().sub(t).LZ())}absLessAbs(t){return this.abs().lt(t.abs())}gt(t){return this.clone().sub(t).GZ()}lte(t){return this.sub(t).LEZ()}gte(t){return this.sub(t).GEZ()}normalizeThis(){if(this.m_bNormalized)return this;if(this.m_rn.v===0n)return this.setZero();let t=0,s=0xffffffffn;for(;(this.m_rn.v&s)===0n&&s<=this.m_rn.v;)s<<=32n,t+=32;s&=this.m_rn.v,s>>=BigInt(t),t+=et(BigInt.asUintN(32,s))-1;let n=0;for(s=0xffffffffn;(this.m_rd.v&s)===0n&&s<=this.m_rd.v;)s<<=32n,n+=32;return s&=this.m_rd.v,s>>=BigInt(n),n+=et(BigInt.asUintN(32,s))-1,this.m_rn.v>>=BigInt(t),this.m_rd.v>>=BigInt(n),this.m_power+=t-n,this.m_rn.v>1n&&this.m_rd.v>1n&&(this.m_rn.v%this.m_rd.v===0n?(this.m_rn.v/=this.m_rd.v,this.m_rd.v=1n):this.m_rd.v%this.m_rn.v===0n&&(this.m_rd.v/=this.m_rn.v,this.m_rn.v=1n)),this.m_bNormalized=!0,this}negateThis(){return this.isNAN()||(this.m_sign*=-1),this}negate(){return this.clone().negateThis()}invertThis(){return this.isNAN()?this:this.isPositiveInf()||this.isNegativeInf()?(this.setZero(),this):this.m_rn.v===0n?(this.setPositiveInf(),this):(this.m_rd=W(this.m_rn,this.m_rn=this.m_rd),this.m_power=-this.m_power,this)}limitPrecisionThis(t){if(t===0)return this;if(this.isZero())return this.setZero();if(!this.isFinite())return this;this.normalizeThis();let s=Number(Z(this.m_rn.v));if(s>t){const n=s-t;this.m_rn.v>>=BigInt(s-t),this.m_power+=n}if(s=Number(Z(this.m_rd.v)),s>t){const n=s-t;this.m_rd.v>>=BigInt(s-t),this.m_power-=n}return this}hiBitIndex(){return Math.max(Number(Z(this.m_rn.v)),Number(Z(this.m_rd.v)))}ldexp(t){return this.clone().ldexpThis(t)}ldexpThis(t){return t&&(this.m_bNormalized=!1,this.m_power+=t,this.normalizeThis()),this}static lerp(t,s,n){return m.lerpLo(s,s,n)}static lerpLo(t,s,n){return s.sub(t).mulThis(n).addThis(t)}static lerpHi(t,s,n){return s.sub(t).mulThis(he.sub(n)).addThis(t)}LZ(){return!this.isNAN()&&this.m_sign===-1}GZ(){return!this.isNAN()&&this.m_sign===1}LEZ(){return!this.isNAN()&&this.m_sign<=0}GEZ(){return!this.isNAN()&&this.m_sign>=0}toString(){return this.toDouble().toString()}sqr(){return this.clone().sqrThis()}sqrThis(){return this.mulThis(this.clone())}static sqrt(t,s){if(t.m_sign<0n&&Yt("MP_value: sqrt(-1)"),t.isZero())return t.clone();let n=52,i=2220446049250313e-31;for(;n<s;)2*n<=s?(i*=i,n*=2):(i*=2220446049250313e-31,n+=52);n+=52;const r=Z(t.m_rn.v),u=Z(t.m_rd.v);let o,h=t.m_power+Number(r-u);const a=new m;Math.abs(h)>200?(1&Math.abs(h)&&(h+=1),o=m.constructAssign(t,53).ldexpThis(-h).value(),a.setThis(t).ldexpThis(-h),p(Number.isFinite(o))):(a.setThis(t),o=a.value(),p(Number.isFinite(o)),h=0),o=Math.sqrt(o);const l=m.constructDouble(o),c=m.constructDouble(i);c.mulThis(l).ldexpThis(1);const v=i*o*2,d=l.clone(),x=new m;let _;for(let N=0;N<10;++N){d.mulThis(l),x.setThis(a).subThis(d).absThis();let y=x.value();if(_=1,y<.9)for(;y>v;)y*=y,++_;else _=4;if(x.lte(c))break;for(let E=0;E<_;E++)d.setThis(l).divThis(a).invertThis().addThis(l).ldexpThis(-1).limitPrecisionThis(n),l.setThis(d)}return l.ldexpThis(h/2)}static cubicRoot(t,s){if(t.isZero())return t.clone();let n=52,i=2220446049250313e-31;for(;n<s;)2*n<=s?(i*=i,n*=2):(i*=2220446049250313e-31,n+=52);n+=52;const r=Math.pow(Math.abs(t.value()),1/3),u=m.constructDouble(r),o=u.clone();o.sqrThis().mulDoubleThis(3).mulDoubleThis(i),o.limitPrecisionThis(32),t.LZ()&&u.negateThis();for(let h=0;h<10;++h){const a=u.clone();a.sqrThis().mulThis(u);const l=a.clone();if(l.subThis(t),l.absThis().limitPrecisionThis(32),l.lte(o))break;l.setThis(t),l.ldexpThis(1),l.addThis(a);const c=a.clone();c.ldexpThis(1),c.addThis(t),l.divThis(c),u.mulThis(l),u.limitPrecisionThis(n)}return u}isInTheRangeOfDouble(){return p(0),!1}sign(){return this.m_sign}cosAndSin(t,s){p(0)}pow(t){return Kt(this,t)}static nan(){return p(0),new m}convertToDouble(){if(this.m_bNaN)return Number.NaN;if(this.isZero())return 0;if(this.m_rd.v===0n)return this.m_sign===1?Number.POSITIVE_INFINITY:Number.NEGATIVE_INFINITY;const t=this.m_sign===-1,s=this.m_rn.v<<(this.m_power>=0?BigInt(this.m_power):0n);let n=this.m_rd.v<<(this.m_power<0?BigInt(-this.m_power):0n);const i=s/n;let r=Number(i);if(BigInt(r)!==i)return t?-r:r;let u=s-i*n;if(u){let o=Z(n)-1023n;o>0n&&(n>>=o,u<<=52n,u>>=o);let h=Number(u);Number.isFinite(h)||(u>>=52n,h=Number(u),o=0n),o>0n&&(h/=Math.pow(2,52)),r+=h/Number(n)}return t?-r:r}signVal(){return this.m_sign===1?1n:this.m_sign===-1?-1n:0n}opPlusMinus(t,s){const n=Math.min(this.m_power,t.m_power);let i,r;this.m_power>n?(i=BigInt(this.m_power-n),r=0n):(i=0n,r=BigInt(t.m_power-n));const u=this.signVal()*this.m_rn.v*t.m_rd.v<<i,o=t.signVal()*t.m_rn.v*this.m_rd.v<<r;return this.m_rn.v=s?u+o:u-o,this.m_rd.v*=t.m_rd.v,this.m_power=n,this.m_sign=1,this.m_rn.v<0n&&(this.m_sign=-1,this.m_rn.v=-this.m_rn.v),this.m_bNormalized=!1,this.normalizeThis(),this}}m.s_sm=0x8000000000000000n,m.s_em=0x7ff0000000000000n,m.s_fm=0x000fffffffffffffn,m.s_emax=0x7ffn;const he=m.constructInt32(1),On=m.constructInt32(0),Qn=m.constructDouble(.5);function oe(e,t){return As(e^t)}function ae(e,t){let s=Lt(e);const n=Lt(t);return s===n?(s-=53-oe(X(e),X(t)),s):s>n?s:n}function Un(e,t){for(let s=0,n=0,i=e.length;s<i;s+=2,n++)t[n].x=e[s],t[n].y=e[s+1]}function Vn(e){const t=new Float64Array(2*e.length);for(let s=0,n=e.length;s<n;++s){const i=s<<1;t[i]=e[s].x,t[i+1]=e[s].y}return t}function jn(e){const t=Os(f,e.length);for(let s=0,n=e.length;s<n;++s)t[s].setCoords(e[s][0],e[s][1]);return t}class f{static construct(t,s){return new f(t,s)}constructor(t,s){t!==void 0?(this.x=t,this.y=s):this.x=this.y=Number.NaN}clone(){return new f(this.x,this.y)}assign(t){this.setCoordsPoint2D(t)}setCoords(t,s){return this.x=t,this.y=s,this}setCoordsPoint2D(t){this.x=t.x,this.y=t.y}isEqualPoint2D(t,s){return s!==void 0?Math.abs(this.x-t.x)<=s&&Math.abs(this.y-t.y)<=s:this.x===t.x&&this.y===t.y}isEqual(t,s,n){return n!==void 0?Math.abs(this.x-t)<=n&&Math.abs(this.y-s)<=n:this.x===t&&this.y===s}equalsPoint2D(t,s){return this.isEqualPoint2D(t,s)}setSub(t,s){this.x=t.x-s.x,this.y=t.y-s.y}addThis(t){return this.x+=t.x,this.y+=t.y,this}setAdd(t,s){return this.x=t.x+s.x,this.y=t.y+s.y,this}absoluteOther(t){}absolute(){return p(0),this}setNegate(){this.x=-this.x,this.y=-this.y}setNegateOther(t){this.x=-t.x,this.y=-t.y}interpolateThis(t,s){}interpolate(t,s,n){p(0)}scaleAddThis(t,s){this.x=this.x*t+s.x,this.y=this.y*t+s.y}setScaleAdd(t,s,n){this.x=s.x*t+n.x,this.y=s.y*t+n.y}scaleOther(t,s){p(0)}scale(t){this.x*=t,this.y*=t}compare(t){return this.y<t.y?-1:this.y>t.y?1:this.x<t.x?-1:this.x>t.x?1:0}compareX(t){return this.x<t.x?-1:this.x>t.x?1:this.y<t.y?-1:this.y>t.y?1:0}normalizeOther(t){p(0)}normalize(){const t=this.length();return t?(this.x/=t,this.y/=t):(this.x=1,this.y=0),this}getUnitVector(){return this.clone().normalize()}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}sqrLength(){return this.x*this.x+this.y*this.y}static averageFast(t,s){return p(0),{}}static average(t,s){const n=new f;if(s===0)return n.setNAN(),n;if(s===1)return n.assign(t[0]),n;const i=new k(t[0].x),r=new k(t[0].y);for(let u=1;u<s;u++)i.add(t[u].x),r.add(t[u].y),255&u||(i.normalize(),r.normalize());return n.x=i.getResult()/s,n.y=r.getResult()/s,n}static calculateLength(t,s){const n=new k(0);for(let i=1;i<s;i++)n.add(f.distance(t[i],t[i-1]));return n.getResult()}offset(t,s){const n=f.distance(t,s),i=f.construct(this.x,this.y);if(n===0)return f.distance(i,t);const r=s.clone();return r.subThis(t),i.subThis(t),i.crossProduct(r)/n}side(t,s){return t.equals(s)?this.equals(t)?0:1:f.orientationRobust(s,t,this)}static sqrDistance(t,s){const n=t.x-s.x,i=t.y-s.y;return n*n+i*i}static sqrDistanceCoords(t,s,n,i){const r=n-t,u=i-s;return r*r+u*u}static distance(t,s){return Math.sqrt(f.sqrDistance(t,s))}dotProduct(t){return this.x*t.x+this.y*t.y}dotProductAbs(t){return Math.abs(this.x*t.x)+Math.abs(this.y*t.y)}crossProduct(t){return this.x*t.y-this.y*t.x}crossProductAbs(t){return p(0),0}rotateDirect(t,s){const n=this.x*t-this.y*s,i=this.x*s+this.y*t;this.x=n,this.y=i}rotateReverse(t,s){const n=this.x*t+this.y*s,i=-this.x*s+this.y*t;this.x=n,this.y=i}leftPerpendicularThis(){const t=this.x;this.x=-this.y,this.y=t}leftPerpendicularOther(t){const s=t.x;this.x=-t.y,this.y=s}rightPerpendicularThis(){const t=this.x;this.x=this.y,this.y=-t}rightPerpendicularOther(t){const s=t.x;this.x=t.y,this.y=-s}equals(t){return this.x===t.x&&this.y===t.y}notequals(t){return this.x!==t.x||this.y!==t.y}not(){return!this.x&&!this.y}gt(t){return this.y>t.y||this.y===t.y&&this.x>t.x}gte(t){return!this.lt(t)}lt(t){return this.y<t.y||this.y===t.y&&this.x<t.x}lte(t){return!this.gt(t)}subThis(t){return this.x-=t.x,this.y-=t.y,this}divThis(t){return this.x/=t,this.y/=t,this}add(t){return new f(this.x+t.x,this.y+t.y)}sub(t){return new f(this.x-t.x,this.y-t.y)}negateThis(){return this.x=-this.x,this.y=-this.y,this}negate(){return new f(-this.x,-this.y)}mul(t){return new f(this.x*t,this.y*t)}mulThis(t){return this.x*=t,this.y*=t,this}divide(t){return new f(this.x/t,this.y/t)}setNAN(){this.x=this.y=Number.NaN}isNAN(){return Number.isNaN(this.x)||Number.isNaN(this.y)}static getNAN(){return new f(Number.NaN,Number.NaN)}isFinite(){return Number.isFinite(this.x)&&Number.isFinite(this.y)}isZero(){return this.x===0&&this.y===0}norm(t){switch(t){case 0:{const s=Math.abs(this.x),n=Math.abs(this.y),i=s-n;return i>=0?s:i<=0?n:Number.NaN}case 1:return Math.abs(this.x)+Math.abs(this.y);case 2:return Math.sqrt(this.x*this.x+this.y*this.y);default:F("norm")}}getQuarter(){return f.getQuarterCoords(this.x,this.y)}static getQuarterCoords(t,s){return t>0?s>=0?1:4:s>0?2:t===0?4:3}static compareVectors(t,s){const n=t.getQuarter(),i=s.getQuarter();return i===n?f.orientationRobustImpl(f.construct(0,0),s,t,!0):n<i?-1:1}static compareVectorsOrigin(t,s,n){const i=s.sub(t),r=n.sub(t),u=i.getQuarter(),o=r.getQuarter();return o===u?f.orientationRobustImpl(t,n,s,!0):u<o?-1:1}static orientationRobust(t,s,n){return f.orientationRobustImpl(t,s,n,!1)}static orientationRobustEx(t,s,n,i){if(t.equals(s)||n.equals(i))return 0;const r=s.x-t.x,u=s.y-t.y,o=i.x-n.x,h=i.y-n.y;{const d=f.getQuarterCoords(r,u)-1,x=f.getQuarterCoords(o,h)-1,_=f.d[d][x];if(_!==0)return _}const a=r*h,l=u*o,c=4*S()*(Math.abs(a)+Math.abs(l)),v=a-l;return Math.abs(v)>=c?v<0?-1:v>0?1:0:f.orientationRobustExMp(t,s,n,i)}static orientationRobustExMp(t,s,n,i){const r=m.constructDouble(s.x),u=m.constructDouble(i.x);r.subThis(m.constructDouble(t.x)),u.subThis(m.constructDouble(n.x));const o=m.constructDouble(s.y),h=m.constructDouble(i.y);return o.subThis(m.constructDouble(t.y)),h.subThis(m.constructDouble(n.y)),r.mulThis(h),o.mulThis(u),r.subThis(o),r.LZ()?-1:r.GZ()?1:0}static orientationNonRobust(t,s,n){const i=s.sub(t).crossProduct(n.sub(t));return i<0?-1:i>0?1:0}static orientationRobustImpl(t,s,n,i){if(s.isEqualPoint2D(t)||n.isEqualPoint2D(t)||s.isEqualPoint2D(n))return 0;const r=s.x-t.x,u=s.y-t.y,o=n.x-t.x,h=n.y-t.y;if(!i){const c=f.getQuarterCoords(r,u)-1,v=f.getQuarterCoords(o,h)-1,d=f.d[c][v];if(d!==0)return d}const a=(Math.abs(r)+Math.abs(u)+Math.abs(o)+Math.abs(h))*(Math.abs(s.x)+Math.abs(s.y)+Math.abs(n.x)+Math.abs(n.y))*8*rt(),l=r*h-u*o;if(Math.abs(l)>a)return l<0?-1:1;if(M(s.x,t.x)&&M(n.y,t.y)&&M(s.y,t.y)&&M(n.x,t.x)&&T(r,h)&&T(u,o)){const c=r*h,v=u*o;if(M(c,v)){const d=c-v;return d<0?-1:d>0?1:0}}return f.orientationRobustMp(t,s,n)}static orientationRobustMp(t,s,n){const i=m.constructDouble(s.x),r=m.constructDouble(n.x);{const h=m.constructDouble(t.x);i.subThis(h),r.subThis(h)}const u=m.constructDouble(n.y),o=m.constructDouble(s.y);{const h=m.constructDouble(t.y);u.subThis(h),o.subThis(h)}return i.mulThis(u),o.mulThis(r),i.subThis(o),i.LZ()?-1:i.GZ()?1:0}static inCircleRobust(t,s,n,i){const r=new b,u=new b;r.set(t.x),r.subThis(i.x),u.set(t.y),u.subThis(i.y);const o=new b,h=new b;o.set(s.x),o.subThis(i.x),h.set(s.y),h.subThis(i.y);const a=new b,l=new b;a.set(n.x),a.subThis(i.x),l.set(n.y),l.subThis(i.y);const c=r.mulE(h).subE(u.mulE(o)),v=o.mulE(l).subE(h.mulE(a)),d=r.mulE(l).subE(u.mulE(a)),x=r.mulE(r).addE(u.mulE(u)),_=o.mulE(o).addE(h.mulE(h)),N=a.mulE(a).addE(l.mulE(l)),y=x.mulE(v).subE(_.mulE(d)).addE(N.mulE(c));if(!y.isFuzzyZero()){const E=y.value();return E<0?-1:E>0?1:0}return f.inCircleRobustMp(t,s,n,i)}static inCircleRobustMp(t,s,n,i){do{if(!M(t.x,i.x)||!M(t.y,i.y)||!M(s.x,i.x)||!M(s.y,i.y)||!M(n.x,i.x)||!M(n.y,i.y))break;const w=t.x-i.x,g=t.y-i.y,I=s.x-i.x,D=s.y-i.y,q=n.x-i.x,z=n.y-i.y;if(!T(w,D)||!T(g,I)||!T(I,z)||!T(D,q)||!T(w,z)||!T(g,q)||!T(w,w)||!T(g,g)||!T(I,I)||!T(D,D)||!T(q,q)||!T(z,z))break;const ot=w*D,at=g*I,lt=I*z,mt=D*q,ct=w*z,ft=g*q,bt=w*w,vt=g*g,dt=I*I,_t=D*D,xt=q*q,Nt=z*z;if(!M(ot,at)||!M(lt,mt)||!M(ct,ft)||!V(bt,vt)||!V(dt,_t)||!V(xt,Nt))break;const pt=ot-at,yt=lt-mt,Tt=ct-ft,gt=bt+vt,Et=dt+_t,Mt=xt+Nt;if(!T(gt,yt)||!T(Et,Tt)||!T(Mt,pt))break;const wt=gt*yt,It=Et*Tt,Dt=Mt*pt;if(!M(wt,It))break;const Pt=wt-It;if(!V(Pt,Dt))break;const At=Pt+Dt;return At<0?-1:At>0?1:0}while(!1);const r=m.constructDouble(i.x),u=m.constructDouble(i.y),o=m.constructDouble(t.x),h=m.constructDouble(t.y);o.subThis(r),h.subThis(u);const a=m.constructDouble(s.x),l=m.constructDouble(s.y);a.subThis(r),l.subThis(u);const c=m.constructDouble(n.x),v=m.constructDouble(n.y);c.subThis(r),v.subThis(u);const d=o.mul(l).sub(h.mul(a)),x=a.mul(v).sub(l.mul(c)),_=o.mul(v).sub(h.mul(c)),N=o.mul(o).add(h.mul(h)),y=a.mul(a).add(l.mul(l)),E=c.mul(c).add(v.mul(v)),A=N.mul(x).sub(y.mul(_)).add(E.mul(d));return A.LZ()?-1:A.GZ()?1:0}static inCircleRobustMp3Point(t,s,n){const i=m.constructDouble(t.x),r=m.constructDouble(t.y),u=m.constructDouble(s.x),o=m.constructDouble(s.y),h=m.constructDouble(n.x),a=m.constructDouble(n.y),l=h.mul(h).add(a.mul(a)).sub(h.mul(i).add(a.mul(r)).add(h.mul(u)).add(a.mul(o))).add(i.mul(u).add(r.mul(o)));return l.LZ()?-1:l.GZ()?1:0}static inCircleRobust3Point(t,s,n){const i=new b(t.x),r=new b(t.y),u=new b(s.x),o=new b(s.y),h=new b(n.x),a=new b(n.y),l=h.mulE(h).addE(a.mulE(a)).subE(h.mulE(i).addE(a.mulE(r)).addE(h.mulE(u)).addE(a.mulE(o))).addE(i.mulE(u).addE(r.mulE(o)));if(!l.isFuzzyZero()){const c=l.value();return c<0?-1:c>0?1:0}return f.inCircleRobustMp3Point(t,s,n)}static calculateCircleCenterFromThreePoints(t,s,n){if(t.equals(n)||t.equals(s)||n.equals(s))return f.getNAN();const i=le(t,s,n);return i.isNAN()?me(t,s,n):i}static calculateAngle(t,s){return Math.atan2(t.crossProduct(s),t.dotProduct(s))}static isBisectorRobust(t,s,n){return p(0),!1}static size(){return 2}get 0(){return this.x}get 1(){return this.y}set 0(t){this.x=t}set 1(t){this.y=t}static compareZorder(t,s){const n=f.c_compare_zorder_xx[t.x<0?1:0]|f.c_compare_zorder_yy[t.y<0?1:0],i=f.c_compare_zorder_xx[s.x<0?1:0]|f.c_compare_zorder_yy[s.y<0?1:0];if(n===i){let r=0,u=0;for(let o=0;o<2;++o){const h=ae(t[o],s[o]);h>r&&(r=h,u=o)}return t[u]<s[u]}return n<i}static lerp(t,s,n){const i=new f;return zt(t,s,n,i),i}static getClosestCoordinate(t,s,n,i=!1){const r=f.getNAN();r.setSub(s,t);const u=r.sqrLength();if(u===0)return .5;if(s.isEqualPoint2D(n))return 1;const o=f.getNAN();o.setSub(n,t);let h=o.dotProduct(r)/u;return i||(h<0?h=0:h>1&&(h=1)),h}static intersectLinesAtOnePoint(t,s,n,i){if(t.equals(s)||n.equals(i))return f.getNAN();const r=s.x-t.x,u=n.x-i.x,o=s.y-t.y,h=n.y-i.y,a=r*h-u*o;if(!a)return f.getNAN();const l=a;if(l===0)return f.getNAN();let c=(n.x-t.x)*h-(n.y-t.y)*u;c/=l;const v=new f;return zt(t,s,c,v),v.isFinite()?v:f.getNAN()}toString(){return`[${this.x},${this.y}]`}}function le(e,t,s){const n=new b(t.x);n.subThis(e.x);const i=new b(t.y);i.subThis(e.y);const r=new b(s.x);r.subThis(e.x);const u=new b(s.y);u.subThis(e.y);const o=n.clone();o.mulThisE(u);let h=i.clone();if(h.mulThisE(r),o.subThisE(h),o.value()===0)return f.getNAN();o.mulThis(2);const a=n.clone();a.mulThisE(n);const l=i.clone();l.mulThisE(i);const c=a.clone();c.addThisE(l);const v=r.clone();v.mulThisE(r);const d=u.clone();d.mulThisE(u);const x=v.clone();x.addThisE(d);const _=i.clone();_.mulThisE(x),h=u.clone(),h.mulThisE(c),_.subThisE(h),_.divThisE(o);const N=n.clone();N.mulThisE(x),h=r.clone(),h.mulThisE(c),N.subThisE(h),N.divThisE(o);const y=f.construct(e.x-_.value(),e.y+N.value()),E=e.sub(y).length(),A=t.sub(y).length(),w=s.sub(y).length(),g=1e-15*(E+Math.abs(e.x)+Math.abs(t.x)+Math.abs(s.x)+Math.abs(e.y)+Math.abs(t.y)+Math.abs(s.y));return Math.abs(E-A)<=g&&Math.abs(E-w)<=g&&_.eps()<g&&N.eps()<g?y:f.getNAN()}function me(e,t,s){const n=m.constructDouble(t.x);n.subDoubleThis(e.x);const i=m.constructDouble(t.y);i.subDoubleThis(e.y);const r=m.constructDouble(s.x);r.subDoubleThis(e.x);const u=m.constructDouble(s.y);u.subDoubleThis(e.y);const o=n.clone();o.mulThis(u);let h=i.clone();if(h.mulThis(r),o.subThis(h),o.isZero())return f.getNAN();o.mulDoubleThis(2);const a=n.clone();a.mulThis(n);const l=i.clone();l.mulThis(i);const c=a.clone();c.addThis(l);const v=r.clone();v.mulThis(r);const d=u.clone();d.mulThis(u);const x=v.clone();x.addThis(d);const _=i.clone();_.mulThis(x),h=u.clone(),h.mulThis(c),_.subThis(h),_.divThis(o);const N=n.clone();return N.mulThis(x),h=r.clone(),h.mulThis(c),N.subThis(h),N.divThis(o),f.construct(e.x-_.value(),e.y+N.value())}f.dimensions=2,f.d=[[0,1,0,-1],[-1,0,1,0],[0,-1,0,1],[1,0,-1,0]],f.c_compare_zorder_xx=[2,0],f.c_compare_zorder_yy=[1,0];export{St as $,un as A,Le as B,Ee as C,G as D,jt as E,Ye as F,Ge as G,Ct as H,ke as I,En as J,Us as K,Ot as L,Te as M,De as N,Os as O,F as P,Me as Q,rn as R,bn as S,$n as T,us as U,In as V,Vs as W,Ft as X,ts as Y,nn as Z,Ie as _,B as a,qe as a$,we as a0,Tn as a1,P as a2,Ce as a3,zt as a4,pn as a5,b as a6,on as a7,Ve as a8,je as a9,Wt as aA,Qs as aB,On as aC,he as aD,en as aE,mn as aF,ln as aG,_n as aH,Bn as aI,ue as aJ,Ke as aK,We as aL,kt as aM,Xe as aN,Rn as aO,Ne as aP,ht as aQ,pe as aR,Ns as aS,Ae as aT,ve as aU,xn as aV,ge as aW,dn as aX,Fe as aY,cn as aZ,ze as a_,hn as aa,Oe as ab,it as ac,Qt as ad,Sn as ae,Fn as af,Gn as ag,j as ah,Ze as ai,Qe as aj,Ue as ak,S as al,Mn as am,Zs as an,$s as ao,$e as ap,Qn as aq,an as ar,Ln as as,tn as at,Fs as au,Gs as av,sn as aw,vn as ax,Re as ay,Be as az,W as b,kn as b0,qn as b1,Cn as b2,wn as b3,Se as b4,An as b5,jn as b6,Dn as b7,Vn as b8,Un as b9,zn as ba,Zn as bb,se as bc,gn as bd,Nn as c,_s as d,k as e,Vt as f,Je as g,He as h,vs as i,Pe as j,fn as k,de as l,f as m,p as n,yn as o,Pn as p,ut as q,Yt as r,m as s,ds as t,xe as u,ye as v,_e as w,R as x,bs as y,L as z};
