import{e as v}from"./TechniqueType-CFPo0AVB.js";import{bU as M,iZ as we,gO as O,br as E,f as Ie,i as $e,s as ze}from"./main-6eEsl9OJ.js";import{b as W,l as G,c as V}from"./CIMSymbolHelper-bvW1zimp.js";import{r as re}from"./rasterizingUtils-SjltlEdr.js";import{o as j,w as Le,G as Ae}from"./enums-_AFKM9Yk.js";import{o as pe,N as Se,x as N,d as Q,O as De,f as H,F as J,y as U,m as K,l as _e,s as Ee,a as ee,b as ke,t as Re,p as ge,u as Ce,T as Te,k as Be,S as ye,c as Fe,g as Oe,h as We,i as Ge,r as Ve,j as je,A as xe,n as Ze,P as S,q as qe,v as Xe,w as Ye,z as Ne,B as Qe,C as He,D as Je,E as Ue,G as Ke,H as et,I as tt,J as st,K as rt,L as it,M as at,Q as nt,R as ot,U as ct,V as lt,W as ht,X as ut,Y as mt,Z as dt}from"./PieChartMeshWriter-CIKi-pzZ.js";import{t as k,a as R,s as ie}from"./definitions-CASyCajO.js";import{c as ft}from"./constants-BFLErLYb.js";import{c as pt}from"./libtess-WLRQrdls.js";import{M as Z,i as ae}from"./mat2d-D9DBP-jx.js";import{n as A}from"./mat2df32-Dpt2CT5P.js";import{S as ne,o as b,B as oe,v as q,u as _t,l as ce}from"./vec2-ChnYg_BJ.js";import{r as C}from"./vec2f32-CaVKkSa6.js";import{n as $}from"./vec2f64-Cgb6qxNH.js";import{d as gt,l as le}from"./featureConversionUtils-qJGwMYPr.js";import{e as X}from"./OptimizedGeometry-OYT6ACAY.js";import{i as he}from"./BoundingBox-BSOANoLO.js";import{a as ue,r as yt}from"./Utils-DTf8bb9E.js";import{d as xt}from"./ArcadeExpression-CYMFQJdI.js";import{s as Pt}from"./AttributeStore-o3LbcW-m.js";function te(d){let{pixelDimensions:e,texelDimensions:t,baseSize:a,referenceSize:r,strokeWidth:s,sizeRatio:n}=d;if(e||(e=d.sprite.sdf?[0,0]:[d.sprite.width,d.sprite.height]),t||(t=d.sprite.sdf?[0,0]:e),d.patternHeight!=null){const o=d.patternHeight/e[1];e[1]*=o,e[0]*=o}a===-1&&(a=e[1]),a=M(a),r=M(r),s=M(s);const i=(d.sprite.sdfDecodeCoeff??1)*n;return{...d,pixelDimensions:e,texelDimensions:t,baseSize:a,referenceSize:r,strokeWidth:s,sdfDecodeCoeff:i}}const Y=64,vt=64,Mt=2;let Pe=class extends pe{get vertexSpec(){return{createComputedParams:te,optionalAttributes:{zoomRange:ee,value1Position2Value2:Ee,lineLength:_e},attributes:{id:K,bitset:U,pos:J,offset:H.marker,uv:De.marker,animationPointerAndBaseSizeAndReferenceSize:Q,sizing:N,angle:Se}}}_write(e,t){const a=this.evaluatedMeshParams.sprite,{textureBinding:r}=a;e.recordStart(this.instanceId,this.attributeLayout,r);const s=t.getDisplayId();if(this.shift&&t.geometryType==="esriGeometryPolyline")this._writeParticles(e,t);else if(this.evaluatedMeshParams.placement!=null)this._writePlacedMarkers(e,t);else if(t.geometryType==="esriGeometryPolygon"){const n=t.readCentroidForDisplay();if(!n)return;const[i,o]=n.coords;this._writeQuad(e,s,i,o)}else if(t.geometryType==="esriGeometryPoint"){const n=t.readXForDisplay(),i=t.readYForDisplay();this._writeQuad(e,s,n,i)}else{const n=t.readGeometryForDisplay();n&&n.forEachVertex((i,o)=>{this._writeQuad(e,s,i,o)})}e.recordEnd()}_writePlacedMarkers(e,t){const a=W.fromFeatureSetReaderCIM(t)?.clone();if(!a)return;const r=-1,s=ke.getPlacement(a,r,this.evaluatedMeshParams.placement,M(1),e.id,Re());if(!s)return;const n=t.getDisplayId();let i=s.next(),o=null;for(;i!=null;){const l=i.tx,c=-i.ty;if(Math.abs(l)>re||Math.abs(c)>re){i=s.next();continue}const p=-i.getAngle();e.recordBounds(l,c,Y,vt),this.shift?o&&this._writeQuad(e,n,o[0],o[1],void 0,p):this._writeQuad(e,n,l,c,void 0,p),o=[l,c],i=s.next()}}_writeParticles(e,t){const a=t.getDisplayId(),r=t.readGeometryForDisplay();if(!r)return;const s=[];r.forEachVertex((c,p)=>{s.push([c,p])});const n=bt(s);let i=0;for(let c=1;c<s.length;c++){const p=s[c][0]-s[c-1][0],u=s[c][1]-s[c-1][1],h=Math.sqrt(p*p+u*u);i+=h}const o=c=>{for(const p of n){const{a:u,b:h}=p;this._writeQuad(e,a,u.position[0],u.position[1],[u.distance-c,h.position[0],h.position[1],h.distance-c],this.evaluatedMeshParams.angleToLine?Math.atan2(u.direction[1],u.direction[0]):0,i,!0)}},{placement:l}=this.evaluatedMeshParams;if(!l||"placementTemplate"in l||l.type==="CIMMarkerPlacementOnVertices"){let c;if(l&&l.type!=="CIMMarkerPlacementOnVertices")c=l.placementTemplate;else{c=[0];for(const u of n){const{a:h,b:f}=u,m=h.position[0]-f.position[0],_=h.position[1]-f.position[1],g=Math.sqrt(m*m+_*_);c.push(g)}}let p=-1*i;for(;p<(1+Mt/2)*i;)for(const u of c)p+=u,o(p)}else l.type==="CIMMarkerPlacementAtExtremities"?l.extremityPlacement===j.JustBegin?o(1):l.extremityPlacement===j.JustEnd?(o(i-1),o(-1)):l.extremityPlacement===j.Both&&(o(1),o(i-1)):l.type==="CIMMarkerPlacementOnLine"&&o(i/2)}_writeQuad(e,t,a,r,s,n=0,i=0,o=!1){const l=this.evaluatedMeshParams.sprite,{rect:c}=l,p=c.x+k,u=c.y+k,h=c.x+c.width-k,f=c.y+c.height-k,m=e.vertexCount();o||e.recordBounds(a,r,Y,Y);const _={texXmin:p,texYmin:u,texXmax:h,texYmax:f,value1Position2Value2:s,angle:n/ft,lineLength:i};for(let g=0;g<4;g++)this._writeVertex(e,t,a,r,_);e.indexEnsureSize(6),e.indexWrite(m),e.indexWrite(m+1),e.indexWrite(m+2),e.indexWrite(m+1),e.indexWrite(m+3),e.indexWrite(m+2)}};function bt(d){const e=[];let t=0;for(let a=1;a<d.length;a++){const r=d[a-1],s=d[a],n=s[0]-r[0],i=s[1]-r[1],o=Math.sqrt(n*n+i*i),l=n/o,c=i/o;e.push({a:{position:r,distance:t,direction:[l,c]},b:{position:s,distance:t+o,direction:[l,c]}}),t+=o}return e}let wt=class extends Pe{constructor(){super(...arguments),this.shift=!1}},It=class extends Pe{constructor(){super(...arguments),this.shift=!0}},ve=class extends pe{_write(e,t,a){const r=a??W.fromFeatureSetReaderCIM(t);if(!r)return;const s=this.evaluatedMeshParams.sprite,{textureBinding:n}=s;e.recordStart(this.instanceId,this.attributeLayout,n);const i=t.getDisplayId();this._writePoly(e,i,r.asOptimized()),e.recordEnd()}},$t=class extends ve{constructor(){super(...arguments),this.vertexSpec={createComputedParams:te,attributes:{id:K,bitset:U,pos:J,offset:H.fill,tlbr:ye,animationPointerAndBaseSizeAndReferenceSize:Q,sizing:N},optionalAttributes:{zoomRange:ee,value1Position2Value2:ge,lineLength:Ve}}}_writePoly(e,t,a){const r=[];if(!je(r,a))return;const s=e.vertexCount();a.forEachVertex((n,i)=>{this._writeVertex(e,t,n,i)}),e.indexEnsureSize(r.length);for(const n of r)e.indexWrite(s+n)}},zt=class{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0}};const me=65535;class Lt extends ve{constructor(){super(...arguments),this.vertexSpec={createComputedParams:te,attributes:{id:K,bitset:U,pos:J,offset:H.line,tlbr:ye,animationPointerAndBaseSizeAndReferenceSize:Q,sizing:N,accumulatedDistance:Be,normal:Te,segmentDirection:Ce},optionalAttributes:{zoomRange:ee,value1Position2Value2:ge,lineLength:_e}},this._tessParams=new Fe,this._currentWrite=new zt,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:me,textured:!1},this._lineLength=0,this._lineTessellator=new pt((e,t,a,r,s,n,i,o,l,c,p)=>this._writeTesselatedVertex(e,t,a,r,s,n,i,o,l,c,p,this._lineLength),this._writeTriangle.bind(this),!1)}_writePoly(e,t,a){const n=Oe(W.fromOptimized(a,"esriGeometryPolyline"),64);if(n==null)return;const{_currentWrite:i,_tessellationOptions:o}=this,{baseSize:l,capType:c,joinType:p,miterLimit:u}=this.evaluatedMeshParams,h=M(.5*l);o.halfWidth=h,o.capType=We(c||Le.Round),o.joinType=Ge(p||Ae.Round),o.miterLimit=u||2,i.out=e,i.id=t,i.vertexCount=0,i.indexCount=0,i.vertexFrom=e.vertexCount(),i.vertexBounds=1;for(const{line:f,start:m,pathLength:_}of n){o.initialDistance=m%me,i.pathLength=_,this._lineLength=0;for(let g=1;g<f.length;g++){const y=f[g].x-f[g-1].x,x=f[g].y-f[g-1].y;this._lineLength+=Math.sqrt(y*y+x*x)}this._lineTessellator.tessellate(f,o,!1)}}_writeTesselatedVertex(e,t,a,r,s,n,i,o,l,c,p,u){const{out:h,id:f,vertexBounds:m,pathLength:_}=this._currentWrite;return this.hasEffects&&h.recordBounds(e,t,m,m),this._tessParams.extrusionOffsetX=i,this._tessParams.extrusionOffsetY=o,this._tessParams.normalX=l,this._tessParams.normalY=c,this._tessParams.directionX=s,this._tessParams.directionY=n,this._tessParams.distance=p,this._tessParams.pathLength=_,this._tessParams.lineLength=u,this._writeVertex(h,f,e,t,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(e,t,a){const{out:r}=this._currentWrite;r.indexEnsureSize(3),r.indexWrite(e),r.indexWrite(t),r.indexWrite(a),this._currentWrite.indexCount+=3}}const T=1,z=0,At=128;function St(d,e){return O(`${d}${e}`)}function Dt(d,e,t){return O(`${d}${e}${t}`)}function Et(d,e,t,a){return O(`${d}${e}${t*2**(S-a)}`)}function kt(d,e,t,a,r){return O(`${d}${r}${e}${t*2**(S-a)}`)}const Rt=we(d=>{let e=0;if(d===0)return 1/0;for(;!(d%2);)e++,d/=2;return e});class Ct extends xe{constructor(){super(...arguments),this._zoomLevel=0}_write(e,t,a,r){if(this._zoomLevel=r||0,a!=null)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(t.geometryType){case"esriGeometryPoint":{const s=t.readXForDisplay(),n=t.readYForDisplay();this._writePoint(e,s,n,0,t);break}case"esriGeometryEnvelope":case"esriGeometryPolygon":{const s=t.readCentroidForDisplay();if(!s)return;const[n,i]=s.coords;this._writePoint(e,n,i,0,t);break}case"esriGeometryMultipoint":{let s=0;const n=W.fromFeatureSetReader(t);if(n?.nextPath())for(;n.nextPoint();)this._writePoint(e,n.x,n.y,s++,t);break}case"esriGeometryPolyline":this._writeLines(e,t)}}_getMetricDir(){const{horizontalAlignment:e,verticalAlignment:t}=this.evaluatedMeshParams;return[e==="center"?0:e==="right"?-1:1,t==="middle"?0:t==="bottom"?-1:1]}_createLineLabelMetric(e,t,a,r,s,n){const[i,o]=this._getMetricDir(),l=this.evaluatedMeshParams.scaleInfo?.maxScale??0,c=this.evaluatedMeshParams.scaleInfo?.minScale??0,p=this.evaluatedMeshParams.labelClassId;return new ue(e,p,t,a,r,s,i,o,l,c,n)}_writePoint(e,t,a,r,s){if(t<0||t>R||a<0||a>R)return;const n=this._getShaping();if(!n)return;const i=s.getDisplayId(),o=this.evaluatedMeshParams.labelClassId,l=St(s.getObjectId(),r),c=Dt(s.getObjectId(),o,r),[p,u]=this._getMetricDir(),h=this.evaluatedMeshParams.scaleInfo?.maxScale??0,f=this.evaluatedMeshParams.scaleInfo?.minScale??0,m=this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0};e.metricStart(new ue(i,o,l,c,t,a,p,u,h,f,m)),this._writeGlyphs(e,i,t,a,n,0,m,void 0,!1),e.metricBoxWrite(n.boundsT),e.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const e of this._references){const t=e.getBoundsInfo();if(t)return t}return null}_writeLines(e,t){const{scaleInfo:a,verticalAlignment:r}=this.evaluatedMeshParams,s=this.evaluatedMeshParams.repeatLabelDistance||128,n=this._getShaping("middle");if(!n)return;const i=(l,c,p,u)=>this._placeSubdivGlyphs(l,c,p,u),o=(n.bounds.width+s)/(1<<T);this._current={out:e,id:t.getDisplayId(),objId:t.getObjectId(),shaping:n,zoomRange:Ze(a,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null,pathIndex:0},this._verticalPlacement=r==="bottom"?"above":r==="top"?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(t,i,o):this._writeCenterAlong(t,i,o)}_writeAboveAndBelowAlong(e,t,a){const{repeatLabel:r}=this.evaluatedMeshParams,{shaping:s}=this._current,n=s.bounds.halfHeight,i=e.readGeometryForDisplay();if(!i)return;const o=new X;gt(o,i,!1,!1,"esriGeometryPolyline",1);const l=de(new X,o,n),c=de(new X,o,-n),p=le(c,"esriGeometryPolyline",!1,!1),u=le(l,"esriGeometryPolyline",!1,!1),h=G(u.paths,s.bounds.width),f=G(p.paths,s.bounds.width);this._current.offsetDirection="above";for(let m=0;m<h.length;m++)this._current.pathIndex=m,V(h[m],a,t,!!r);this._current.offsetDirection="below";for(let m=0;m<f.length;m++)this._current.pathIndex=m,V(f[m],a,t,!!r)}_writeCenterAlong(e,t,a){const{repeatLabel:r}=this.evaluatedMeshParams,{shaping:s}=this._current,n=G(e.readLegacyGeometryForDisplay().paths,s.bounds.width);for(let i=0;i<n.length;i++)this._current.pathIndex=i,V(n[i],a,t,!!r)}_placeSubdivGlyphs(e,t,a,r){const{allowOverrun:s,labelPosition:n,repeatLabelDistance:i}=this.evaluatedMeshParams,o=this._current.zoomRange[0],l=Rt(t),c=this._current.shaping.bounds.width/(1<<T),p=Math.sqrt(i||At)/(1<<T),u=Math.min(a,r-a),h=this._current.shaping.isMultiline?S:Math.log2(u/(p+c/2)),f=t===0?h:Math.min(l,h),m=Math.max(o,this._zoomLevel+T-f),_=this._zoomLevel-m,g=this._current.shaping.bounds.width/2*2**_,y=Et(this._current.objId,this._current.pathIndex,t,this._zoomLevel),x=kt(this._current.objId,this._current.pathIndex,t,this._zoomLevel,this.evaluatedMeshParams.labelClassId);this._current.shaping.isMultiline?t===0&&this._placeStraight(e,m,y,x):s&&_<0?this._placeStraightAlong(e,o,y,x):n==="parallel"?this._placeStraightAlong(e,m,y,x):n==="curved"&&this._placeCurved(e,m,g,y,x)}_placeStraight(e,t,a,r){const{out:s,id:n,shaping:i,referenceBounds:o}=this._current,{x:l,y:c}=e;s.metricStart(this._createLineLabelMetric(n,a,r,l,c)),s.metricBoxWrite(i.boundsT);const p=e.angle*(180/Math.PI)%360,u=(e.angle*(180/Math.PI)+180)%360,h={clipAngle:p,mapAligned:!0,isLineLabel:!0,minZoom:t};this._writeGlyphs(s,n,l,c,i,0,o,h,!1);const f={clipAngle:u,mapAligned:!0,isLineLabel:!0,minZoom:t};this._writeGlyphs(s,n,l,c,i,0,o,f,!1),s.metricEnd()}_placeCurved(e,t,a,r,s){const{out:n,id:i}=this._current;n.metricStart(this._createLineLabelMetric(i,r,s,e.x,e.y));const o=e.clone(),l=e.angle*(180/Math.PI)%360,c=(e.angle*(180/Math.PI)+180)%360;this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(o,t,1,l),this._placeBack(e,o,t,a,1,l),this._placeForward(e,o,t,a,1,l)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(o,t,0,c),this._placeBack(e,o,t,a,0,c),this._placeForward(e,o,t,a,0,c)),n.metricEnd()}_placeStraightAlong(e,t,a,r){const{out:s,id:n,shaping:i,zoomRange:o,referenceBounds:l}=this._current,{boxBorderLineColor:c,boxBackgroundColor:p}=this.evaluatedMeshParams,u=e.clone(),h=e.angle*(180/Math.PI)%360,f=(e.angle*(180/Math.PI)+180)%360,m=i.glyphs.length>0&&!(!c&&!p);if(s.metricStart(this._createLineLabelMetric(n,a,r,e.x,e.y)),m){const _=Math.max(t,o[0],0),g=Math.min(S,o[1]),y=Z(A(),-e.angle),x={minZoom:_,maxZoom:g,clipAngle:h,mapAligned:!0,isLineLabel:!0},P=M(this.evaluatedMeshParams.offsetX),I=M(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const w=C(P,-1*I),[D,L]=i.shapeBackground(ae(A(),y,w));s.recordStart(this.instanceId,this.attributeLayout,i.glyphs[0].textureBinding),this._writeTextBox(s,n,e.x,e.y,L,l,x),s.recordEnd()}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const w=C(P,I),[D,L]=i.shapeBackground(ae(A(),y,w));x.clipAngle=f,s.recordStart(this.instanceId,this.attributeLayout,i.glyphs[0].textureBinding),this._writeTextBox(s,n,e.x,e.y,L,l,x),s.recordEnd()}}this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(u,t,1,h,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(u,t,0,f,!0),s.metricEnd()}_placeBack(e,t,a,r,s,n){const i=e.clone();let o=e.backwardLength+z;for(;i.prev()&&!(o>=r);)this._placeOnSegment(i,t,o,a,-1,s,n),o+=i.length+z}_placeForward(e,t,a,r,s,n){const i=e.clone();let o=e.remainingLength+z;for(;i.next()&&!(o>=r);)this._placeOnSegment(i,t,o,a,1,s,n),o+=i.length+z}_placeFirst(e,t,a,r,s=!1){const{out:n,id:i,shaping:o,zoomRange:l,referenceBounds:c}=this._current,p=o.glyphs,u=M(this.evaluatedMeshParams.offsetX),h=M(this.evaluatedMeshParams.offsetY),f=C(u,h),m=Z(A(),-e.angle);ne(f,f,m);for(const _ of p){const g=_.x>o.bounds.x?a:1-a,y=g*e.remainingLength+(1-g)*e.backwardLength,x=Math.abs(_.x+_.width/2-o.bounds.x),P=Math.max(0,this._zoomLevel+Math.log2(x/(y+z))),I=Math.max(t,s?0:P);if(_.maxZoom=Math.min(l[1],S),_.angle=e.angle+(1-a)*Math.PI,_.minZoom=Math.max(l[0],I),this._writeLineGlyph(n,i,e.x,e.y,_,r,c,!0),(a||this._current.offsetDirection)&&this._isVisible(_.minZoom,_.maxZoom)){const w=new he(_.bounds.x+f[0],_.bounds.y+f[1],_.bounds.width,_.bounds.height);n.metricBoxWrite(w)}}}_placeOnSegment(e,t,a,r,s,n,i){const{out:o,id:l,shaping:c,referenceBounds:p}=this._current,u=c.glyphs,h=e.dx/e.length,f=e.dy/e.length,m={x:e.x+a*-s*h,y:e.y+a*-s*f},_=M(this.evaluatedMeshParams.offsetX),g=M(this.evaluatedMeshParams.offsetY),y=C(_,g),x=Z(A(),-e.angle);ne(y,y,x);for(const P of u){const I=P.x>c.bounds.x?n:1-n;if(!(I&&s===1||!I&&s===-1))continue;const w=Math.abs(P.x+P.width/2-c.bounds.x),D=Math.max(0,this._zoomLevel+Math.log2(w/a)-.1),L=Math.max(r,this._zoomLevel+Math.log2(w/(a+e.length+z)));if(D!==0&&(P.angle=e.angle+(1-n)*Math.PI,P.minZoom=L,P.maxZoom=D,this._writeLineGlyph(o,l,m.x,m.y,P,i,p,!0),(n||this._current.offsetDirection)&&this._isVisible(P.minZoom,P.maxZoom))){const be=new he(P.bounds.x+y[0],P.bounds.y+y[1],P.bounds.width,P.bounds.height);o.metricBoxWrite(be)}}}_writeLineGlyph(e,t,a,r,s,n,i,o){if(a<0||a>R||r<0||r>R)return;e.recordStart(this.instanceId,this.attributeLayout,s.textureBinding);const{texcoords:l,offsets:c}=s,{fontSize:p,haloSize:u,outlineSize:h}=this._textMeshTransformProps;this._writeQuad(e,t,a,r,{texcoords:l,offsets:c,fontSize:p,haloSize:u,outlineSize:h,color:qe(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:i,minZoom:Math.max(this._current.zoomRange[0],s.minZoom),maxZoom:Math.min(this._current.zoomRange[1],s.maxZoom),clipAngle:n,mapAligned:o,isLineLabel:!0}),e.recordEnd()}_packedZoom(e){return Math.floor(e*ie)/ie}_isVisible(e,t){let a=Math.max(this._current.zoomRange[0],e),r=Math.min(this._current.zoomRange[1],t);a=this._packedZoom(a),r=this._packedZoom(r);const s=this._packedZoom(this._zoomLevel);return a<=s&&s<=r}}function de(d,e,t){const{coords:a,lengths:r}=e,s=$(),n=$(),i=$(),o=$(),l=$(),c=$(),p=2;let u=0;for(let h=0;h<r.length;h++){const f=r[h];for(let m=0;m<f;m++){const _=p*(m+u-1),g=p*(m+u),y=p*(m+u+1);m>0?b(s,a[_],a[_+1]):b(s,0,0),b(n,a[g],a[g+1]),m<f-1?b(i,a[y],a[y+1]):b(i,0,0),m===0?b(o,0,0):(oe(o,n,s),q(o,o),b(o,o[1],-o[0])),m===f-1?b(l,0,0):(oe(l,i,n),q(l,l),b(l,l[1],-l[0])),_t(c,o,l),q(c,c);const x=c[0]*l[0]+c[1]*l[1];x!==0&&ce(c,c,x),ce(c,c,t),d.coords.push(n[0]+c[0],n[1]+c[1])}d.lengths.push(f),u+=f}return d}class Tt extends Pt{constructor(e){super(),this._value=e}resize(e){}read(e,t){return this._value}readWithDefault(e,t,a){return this._value}hasArcadeDependency(e){return!1}}const Bt=()=>$e.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator");async function B(d,e,t,a){const{defaultValue:r,valueExpressionInfo:s,value:n}=e;if(s){if(s.type==="dictionary-template")return{...e,computed:d.createDictionaryTemplateField(s,t),defaultValue:r};const{expression:i}=s,o=await d.createComputedField({expression:i},a);return o?{...e,computed:o,defaultValue:r}:null}return{...e,computed:new Tt(n),defaultValue:r}}async function fe(d,e,t){const{valueExpressionInfo:a}=e,r=a.type==="dictionary-template"?d.createDictionaryTemplateField(a,t):await d.createComputedField({expression:a.expression});return r?{...e,computed:r}:null}function Me(d){return typeof d=="object"&&d!=null&&(!(!("valueExpressionInfo"in d)||!d.valueExpressionInfo)||"type"in d&&d.type==="Process"&&"op"in d&&d.op==="Random")}function F(d){if(Array.isArray(d)){for(const e of d)if(F(e))return!0}if(typeof d=="object"){if(Me(d))return!0;for(const e in d)if(F(d[e]))return!0}return!1}class se{static async create(e,t,a,r){const s={},n=new Map,i=new Map,o=new Map,l=new Map,c=new Map,p=new Map;for(const u in a){const h=a[u];if(h!=null&&typeof h=="object")if(Array.isArray(h)){if(typeof h[0]=="object")throw new Error(`InternalError: Cannot handle ${u}. Nested array params are not supported`);s[u]=h}else if("valueExpressionInfo"in h){if(h.value){s[u]=h.value;continue}const f=await fe(e,h,r);if(!f){s[u]=h.defaultValue;continue}n.set(u,f),s[u]=null}else switch(h.type){case"cim-effect-infos":if(h.effectInfos.some(f=>f.overrides.length)){i.set(u,{effects:await Promise.all(h.effectInfos.map(async f=>{const m=f.overrides.map(_=>B(e,_,r,!1));return{effect:f.effect,compiledOverrides:(await Promise.all(m)).filter(E)}}))});break}s[u]=h.effectInfos.map(f=>f.effect);break;case"cim-marker-placement-param":h.overrides.length&&o.set(u,{placementInfo:h,compiledOverrides:(await Promise.all(h.overrides.map(f=>B(e,f,r,!1)))).filter(E)}),s[u]=h.placement;break;case"text-rasterization-param":{if(h.overrides.length){const m=h.overrides.map(_=>B(e,_,r,h.useLegacyLabelEvaluationRules??!1));l.set(u,{compiledOverrides:(await Promise.all(m)).filter(E),rasterizationParam:h,objectIdToResourceId:new Map});continue}const f={type:"cim-rasterization-info",resource:h.resource};s[u]=await t.fetchResourceImmediate(f)??null;break}case"sprite-rasterization-param":{if(h.overrides.length){const m=h.overrides.map(_=>B(e,_,r,!1));l.set(u,{compiledOverrides:(await Promise.all(m)).filter(E),rasterizationParam:h,objectIdToResourceId:new Map});continue}if(h.resource.type==="animated"){l.set(u,{compiledOverrides:[],rasterizationParam:h,objectIdToResourceId:new Map});continue}const f={type:"cim-rasterization-info",resource:h.resource};s[u]=await t.fetchResourceImmediate(f)??null;break}case"cim-marker-transform-param":{const{params:f}=h;if(F(f)){const m={compiledMarkerInfos:[]};await Promise.all(f.map(async _=>{const g={props:{}};for(const y in _)if(Me(_[y])){const x=await fe(e,_[y],r);g.compiledExpressionMap||(g.compiledExpressionMap=new Map);const P=g.compiledExpressionMap;x&&P.set(y,x)}else g.props[y]=_[y];m.compiledMarkerInfos.push(g)})),c.set(u,m)}else s[u]={type:"cim-marker-transform-info",infos:f};break}case"animation-params":{const{params:f}=h,m=Xe(f);if(F(m)){const _=await Promise.all(m.map(g=>Ye(g,e)));p.set(u,{params:_,propertyIdToResourceId:new Map,key:u})}else{const _=Ne(m),g=await t.fetchResourceImmediate({type:"animation-info",resource:_});g!=null&&g.type==="sprite"&&(s[u]={dataRow:g.rect.y,dataColumn:g.rect.x})}break}default:s[u]=h}else s[u]=h}return new se(a,s,n,i,o,l,c,p)}constructor(e,t,a,r,s,n,i,o){this.inputMeshParams=e,this._resolvedMeshParams=t,this._dynamicProperties=a,this._dynamicEffectProperties=r,this._dynamicPlacementProperties=s,this._dynamicAsyncProperties=n,this._dynamicTransformProperties=i,this._dynamicAsyncAnimations=o,this.evaluator=l=>l,this._arcadeDependencies=new Set;for(const l of this._expressions())xt(this._arcadeDependencies,l)}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size||this._dynamicAsyncAnimations.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(e,t,a){for(const r of this._dynamicAsyncProperties.values()){const s=Ie(r.rasterizationParam.resource);r.rasterizationParam.resource.type==="animated"&&r.rasterizationParam.resource.randomizeStartTime&&(s.primitiveName="__RESERVED__PRIMITIVE__NAME__",s.startGroup=Qe(t.getObjectId()||0));for(const{primitiveName:i,propertyName:o,computed:l,defaultValue:c,valueExpressionInfo:p}of r.compiledOverrides)try{const u=r.rasterizationParam.resource.type==="animated"?s.primitiveName:i;yt(s,u,o,l,t,a,c)}catch(u){Bt().errorOnce(new ze("invalid-arcade-expression","Encountered an error when evaluating the arcade expression",{error:u,valueExpressionInfo:p}))}const n=e.enqueueRequest({type:"cim-rasterization-info",resource:s});r.objectIdToResourceId.set(t.getObjectId(),n)}for(const r of this._dynamicAsyncAnimations.values()){const s=r.params.map(o=>He(o,t,a)).map(Je).map(o=>o.simplify()),n=Ue(s),i=e.enqueueRequest({type:"animation-info",resource:n});r.propertyIdToResourceId.set(t.getObjectId()+"."+r.key,i)}}evaluateMeshParams(e,t,a){for(const[r,s]of this._dynamicProperties.entries())this._resolvedMeshParams[r]=s.computed.readWithDefault(t,a,s.defaultValue);for(const[r,s]of this._dynamicPlacementProperties.entries())for(const{computed:n,defaultValue:i,propertyName:o}of s.compiledOverrides){const l=n.readWithDefault(t,a,i);s.placementInfo.placement[o]=l,this._resolvedMeshParams[r]=s.placementInfo.placement}for(const[r,s]of this._dynamicEffectProperties.entries())for(const n of s.effects){for(const{computed:i,defaultValue:o,propertyName:l}of n.compiledOverrides){const c=i.readWithDefault(t,a,o);n.effect[l]=c}this._resolvedMeshParams[r]=s.effects.map(i=>i.effect)}for(const[r,s]of this._dynamicTransformProperties.entries()){const n={type:"cim-marker-transform-info",infos:[]};for(const i of s.compiledMarkerInfos){const o={...i.props};if(i.compiledExpressionMap)for(const[l,c]of i.compiledExpressionMap){const p=c.computed.readWithDefault(t,a,c.defaultValue);o[l]=typeof p=="number"||typeof p=="boolean"?p:c.defaultValue}n.infos.push(o)}this._resolvedMeshParams[r]=n}for(const[r,s]of this._dynamicAsyncProperties.entries()){const n=s.objectIdToResourceId.get(t.getObjectId());if(n==null)continue;const i=e.getResource(n);this._resolvedMeshParams[r]=i}for(const[r,s]of this._dynamicAsyncAnimations.entries()){const n=s.propertyIdToResourceId.get(t.getObjectId()+"."+r);if(n==null)continue;const i=e.getResource(n);this._resolvedMeshParams[r]={dataRow:i.rect.y,dataColumn:i.rect.x}}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}hasArcadeDependency(e){return this._arcadeDependencies.has(e)}*_expressions(){for(const e of this._dynamicProperties.values())yield e.computed;for(const e of this._dynamicEffectProperties.values())for(const t of e.effects)for(const a of t.compiledOverrides)yield a.computed;for(const e of this._dynamicPlacementProperties.values())for(const t of e.compiledOverrides)yield t.computed;for(const e of this._dynamicAsyncProperties.values())for(const t of e.compiledOverrides)yield t.computed;for(const e of this._dynamicTransformProperties.values())for(const t of e.compiledMarkerInfos)if(t.compiledExpressionMap!=null)for(const a of t.compiledExpressionMap.values())yield a.computed;for(const e of this._dynamicAsyncAnimations.values())for(const t of e.params)yield*Ke(t)}}class hs{async createMeshWriter(e,t,a,r,s){const n=this._getMeshWriter(r.techniqueType),i=await se.create(e,t,r.inputParams,s),o=new n(r.id,i,r.optionalAttributes,a);return await o.loadDependencies(),o}_getMeshWriter(e){switch(e){case v.Fill:return dt;case v.DotDensity:return mt;case v.ComplexFill:return ut;case v.PatternFill:return ht;case v.GradientFill:return lt;case v.OutlineFill:return ct;case v.PatternOutlineFill:return ot;case v.ComplexOutlineFill:return nt;case v.Marker:return at;case v.PieChart:return it;case v.Text:return xe;case v.Line:return rt;case v.TexturedLine:return st;case v.GradientStroke:return tt;case v.Heatmap:return et;case v.Label:return Ct;case v.AnimatedMarker:return wt;case v.AnimatedMarkerShift:return It;case v.AnimatedFill:return $t;case v.AnimatedLine:return Lt;default:throw new Error("Internal Error: Mesh writer not in the registry")}}}export{Tt as r,hs as y};
