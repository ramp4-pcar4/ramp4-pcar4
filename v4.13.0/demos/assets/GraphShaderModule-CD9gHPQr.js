import{E as J}from"./enums-BKZXYdA3.js";import{q as v,t as Jt,s as Zt,i as jt,gO as Wt}from"./main-6eEsl9OJ.js";import{a as te,S as ee}from"./Texture-Cg6gEanA.js";import"./enums-UBzvFP7O.js";import"./FramebufferObject-DNgF0P1h.js";import{a as ne}from"./ProgramTemplate-QrVgIzo1.js";import{i as re}from"./ShaderBuilder-Bp451WLi.js";let je=class{constructor(){this.drawPhase=J.MAP|J.HITTEST|J.HIGHLIGHT|J.DEBUG}startup(){}shutdown(t){}};function se(n){return n.split(" ").map((t,e)=>e>0?t.charAt(0).toUpperCase()+t.slice(1):t).join("")}function ie(n,t){const e=[];for(e.push(t);e.length;){const r=e.pop();if(typeof r=="object"&&!n.has(r.uid)){n.add(r.uid);for(const s of r.children)e.push(s)}}}let F=class rt{constructor(){this.uid=rt.NodeCount++,this._debugName=null,this._isMutable=!1,this.isImplicit=!1}static{this.NodeCount=0}get isMutable(){return this._isMutable}setMutable(){return this._isMutable=!0,this}setDebugName(t){return t=se(t),this._debugName=t,this.isImplicit&&this.children[0]instanceof rt&&this.children[0].setDebugName(t),this}get debugInfo(){return{name:this._debugName??""}}cloneInto(t){t._debugName=this._debugName,t._isMutable=this._isMutable,t.isImplicit=this.isImplicit,t.uid=this.uid}};function a(n){return typeof n=="object"?n.clone():n}let m=class extends F{constructor(){super(...arguments),this.shaderType="primitive-node"}},oe=class Bt extends F{constructor(t){super(),this.child=t,this.shaderType="scope-node"}get children(){return[this.child]}clone(){const t=new Bt(a(this.child));return this.cloneInto(t),t}};class Pt extends F{constructor(t,e,r){super(),this.property=t,this.target=e,this.returnType=r,this.shaderType="property-access-node"}get children(){const t=[this.target];return typeof this.property!="string"&&t.push(this.property),t}clone(){const t=new Pt(this.property,a(this.target),this.returnType);return this.cloneInto(t),t}}let ae=class Dt extends F{constructor(t,e,r,s){super(),this.x=t,this.y=e,this.target=r,this.returnType=s,this.shaderType="property-access-2d-node"}get children(){return[this.target,this.x,this.y]}clone(){const t=new Dt(this.x,this.y,a(this.target),this.returnType);return this.cloneInto(t),t}};class Ft extends F{constructor(t,e,r){super(),this.condition=t,this.ifTrue=e,this.ifFalse=r,this.shaderType="condition-node"}get children(){return[this.condition,this.ifTrue,this.ifFalse]}clone(){const t=a(this.ifTrue),e=this.ifFalse?a(this.ifFalse):null,r=new Ft(this.condition,t,e);return this.cloneInto(r),r}}let ce=class zt extends F{constructor(t,e,r,s){super(),this.captureList=t,this.returnType=e,this.generator=s,this.shaderType="block-node",r&&(this.subgraph=new oe(r))}get children(){return Object.keys(this.captureList).map(t=>this.captureList[t]).concat(this.subgraph??[])}clone(){const t={};for(const r in this.captureList)t[r]=a(this.captureList[r]);const e=new zt(t,this.returnType,this.subgraph?a(this.subgraph.child):this.subgraph,this.generator);return this.cloneInto(e),e}},C=class Lt extends F{constructor(t,e,r,s,i,o=!1){super(),this.token=t,this._children=e,this.isInfix=r,this.isPropertyAccess=s,this.returnType=i,this.isTernary=o,this.shaderType="function-node"}get children(){return this._children}clone(){const t=new Lt(this.token,this._children.map(a),this.isInfix,this.isPropertyAccess,this.returnType,this.isTernary);return this.cloneInto(t),t}};var q,st,it,ot,at,ct,ut,ht,dt,pt,lt,ft,yt,mt;function ue(n){switch(n.type){case"bool":case"bvec2":case"bvec3":case"bvec4":return x;case"float":case"vec2":case"vec3":case"vec4":return p;case"int":case"ivec2":case"ivec3":case"ivec4":return y;case"uint":case"uvec2":case"uvec3":case"uvec4":return tt;default:throw new Error("Unable to handle type")}}function he(n){const t=[["float","vec2","vec3","vec4"],["int","ivec2","ivec3","ivec4"],["uint","uvec2","uvec3","uvec4"],["bool","bvec2","bvec3","bvec4"]];for(const e of t)if(e.includes(n))return e.map(r=>le[r]);throw new Error("Unable to find type family")}function Gt(n){return new Proxy(n,{get(t,e){if(e==="constructor")return new Proxy(t.constructor,{construct:(r,s,i)=>Gt(new r(...s))});if(e in t)return t[e];if(typeof e=="string"){const r=he(n.type);return _(n,e,r[e.length-1])}}})}function I(n){return new Proxy(n,{construct:(t,e,r)=>Gt(new t(...e))})}function de(n){return new Proxy(n,{get(t,e){if(e in t)return t[e];if(typeof e=="string"){const r=parseInt(e,10);if(!isNaN(r))return _(n,`[${r}]`,n.elementType.constructor)}}})}function pe(n){return new Proxy(n,{construct:(t,e,r)=>de(new t(...e))})}class gt extends Error{}let bt=class extends m{static{q=this}static{this.type="array"}constructor(n,t){super(),this.elementType=n,this.size=t,this.children=[],this.type="array"}clone(){const n=new q(this.elementType,this.size);return super.cloneInto(n),n}get(n,t){const e=new y(n),r=t!=null?new y(t):null;return r!=null?et(this,e,r,ue(this.elementType.constructor)):_(this,e,this.elementType.constructor)}last(){return this.get(this.size-1)}first(){return this.get(0)}findIndex(n,t,e){return me(this,n,t,e)}glslFindIndex(n,t,e){return ge(this,n,t,e)}static ofType(n,t){const e={construct:(r,s)=>new q(new n,t)};return new Proxy(q,e)}};bt=q=v([pe],bt);class wt extends m{static{this.type="array-2d"}constructor(t,e,r,s=!1){super(),this.elementType=t,this.xSize=e,this.ySize=r,this.isRowMajor=s,this.children=[],this.type="array-2d"}clone(){const t=new wt(this.elementType,this.xSize,this.ySize,this.isRowMajor);return super.cloneInto(t),t}get size(){return this.xSize*this.ySize}get(t,e){return this.isRowMajor?this._getRowMajor(t,e):this._getColumnMajor(t,e)}_getColumnMajor(t,e){const r=new y(t);return _(this,new y(e).add(r.multiply(this.xSize)),this.elementType.constructor)}_getRowMajor(t,e){const r=new y(t),s=new y(e);return _(this,r.add(s.multiply(this.ySize)),this.elementType.constructor)}static ofType(t,e,r,s=!1){return new Proxy(bt,{construct:(i,o)=>new wt(new t,e,r,s)})}}class Rt extends m{constructor(){super(...arguments),this.type="sampler2D",this.children=[]}static{this.type="sampler2D"}clone(){const t=new Rt;return t.children=this.children.map(a),super.cloneInto(t),t}}let p=class A extends m{static{this.type="float"}constructor(t){super(),this.type="float",this.children=[t]}clone(){const t=new A(a(this.children[0]));return super.cloneInto(t),t}multiply(t){return M(this,typeof t=="number"?g(t,A):t)}divide(t){return X(this,typeof t=="number"?g(t,A):t)}add(t){return j(this,typeof t=="number"?g(t,A):t)}subtract(t){return Q(this,typeof t=="number"?g(t,A):t)}},Y=class extends m{static{st=this}static{this.type="vec2"}constructor(t,e){super(),this.type="vec2",this.children=[t,e].filter(r=>r!=null)}clone(){const t=new st(a(this.children[0]),a(this.children[1]));return super.cloneInto(t),t}get 0(){return _(this,"[0]",p)}get 1(){return _(this,"[1]",p)}get 2(){throw new gt}get 3(){throw new gt}multiply(t){return M(this,typeof t=="number"?g(t,p):t)}divide(t){return X(this,typeof t=="number"?g(t,p):t)}add(t){return j(this,typeof t=="number"?g(t,p):t)}subtract(t){return Q(this,typeof t=="number"?g(t,p):t)}};Y=st=v([I],Y);let W=class extends m{static{it=this}static{this.type="vec3"}constructor(n,t,e){super(),this.type="vec3",this.children=[n,t,e].filter(r=>r!=null)}get 0(){return _(this,"[0]",p)}get 1(){return _(this,"[1]",p)}get 2(){return _(this,"[2]",p)}get 3(){throw new gt}clone(){const n=new it(a(this.children[0]),a(this.children[1]),a(this.children[2]));return super.cloneInto(n),n}multiply(n){return M(this,typeof n=="number"?g(n,p):n)}divide(n){return X(this,typeof n=="number"?g(n,p):n)}add(n){return j(this,typeof n=="number"?g(n,p):n)}subtract(n){return Q(this,typeof n=="number"?g(n,p):n)}};W=it=v([I],W);let P=class extends m{static{ot=this}static{this.type="vec4"}constructor(n,t,e,r){super(),this.type="vec4",this.children=[n,t,e,r].filter(s=>s!=null)}clone(){const n=new ot(a(this.children[0]),a(this.children[1]),a(this.children[2]),a(this.children[3]));return super.cloneInto(n),n}get 0(){return _(this,"[0]",p)}get 1(){return _(this,"[1]",p)}get 2(){return _(this,"[2]",p)}get 3(){return _(this,"[3]",p)}multiply(n){return M(this,typeof n=="number"?g(n,p):n)}divide(n){return X(this,typeof n=="number"?g(n,p):n)}add(n){return j(this,typeof n=="number"?g(n,p):n)}subtract(n){return Q(this,typeof n=="number"?g(n,p):n)}};P=ot=v([I],P);let tt=class extends m{static{at=this}static{this.type="uint"}constructor(n){super(),this.type="uint",this.children=[n]}clone(){const n=new at(a(this.children[0]));return super.cloneInto(n),n}};tt=at=v([I],tt);let vt=class extends m{static{ct=this}static{this.type="uvec2"}constructor(n,t){super(),this.type="uvec2",this.children=[n,t].filter(e=>e!=null)}clone(){const n=new ct(a(this.children[0]),a(this.children[1]));return super.cloneInto(n),n}};vt=ct=v([I],vt);let $t=class extends m{static{ut=this}static{this.type="uvec3"}constructor(n,t,e){super(),this.type="uvec3",this.children=[n,t,e].filter(r=>r!=null)}clone(){const n=new ut(a(this.children[0]),a(this.children[1]),a(this.children[2]));return super.cloneInto(n),n}};$t=ut=v([I],$t);let xt=class extends m{static{ht=this}static{this.type="uvec4"}constructor(n,t,e,r){super(),this.type="uvec4",this.children=[n,t,e,r].filter(s=>s!=null)}clone(){const n=new ht(a(this.children[0]),a(this.children[1]),a(this.children[2]),a(this.children[3]));return super.cloneInto(n),n}};xt=ht=v([I],xt);class x extends m{static{this.type="bool"}constructor(t){super(),this.type="bool",this.children=[t]}and(t){return _e(this,t)}or(t){return we(this,t)}xor(t){return $e(this,t)}clone(){const t=new x(a(this.children[0]));return super.cloneInto(t),t}}let _t=class extends m{static{dt=this}static{this.type="bvec2"}constructor(t,e){super(),this.type="bvec2",this.children=[t,e].filter(r=>r!=null)}all(){return Kt(this)}any(){return Ut(this)}clone(){const t=new dt(a(this.children[0]),a(this.children[1]));return super.cloneInto(t),t}};_t=dt=v([I],_t);let It=class extends m{static{pt=this}static{this.type="bvec3"}constructor(n,t,e){super(),this.type="bvec3",this.children=[n,t,e].filter(r=>r!=null)}all(){return Kt(this)}any(){return Ut(this)}clone(){const n=new pt(a(this.children[0]),a(this.children[1]),a(this.children[2]));return super.cloneInto(n),n}};function g(n,t){return typeof n=="number"?new t(n):n}It=pt=v([I],It);let Nt=class extends m{static{lt=this}static{this.type="bvec4"}constructor(n,t,e,r){super(),this.type="bvec4",this.children=[n,t,e,r].filter(s=>s!=null)}all(){return Kt(this)}any(){return Ut(this)}clone(){const n=new lt(a(this.children[0]),a(this.children[1]),a(this.children[2]),a(this.children[3]));return super.cloneInto(n),n}};Nt=lt=v([I],Nt);class y extends m{static{this.type="int"}constructor(t){super(),this.type="int",this.children=[t]}multiply(t){return M(this,g(t,y))}add(t){return j(this,g(t,y))}subtract(t){return Q(this,g(t,y))}divide(t){return X(this,g(t,y))}clone(){const t=new y(a(this.children[0]));return super.cloneInto(t),t}}let Tt=class extends m{static{ft=this}static{this.type="ivec2"}constructor(n,t){super(),this.type="ivec2",this.children=[n,t].filter(e=>e!=null)}clone(){const n=new ft(a(this.children[0]),a(this.children[1]));return super.cloneInto(n),n}};Tt=ft=v([I],Tt);let Mt=class extends m{static{yt=this}static{this.type="ivec3"}constructor(n,t,e){super(),this.type="ivec3",this.children=[n,t,e].filter(r=>r!=null)}clone(){const n=new yt(a(this.children[0]),a(this.children[1]),a(this.children[2]));return super.cloneInto(n),n}};Mt=yt=v([I],Mt);let St=class extends m{static{mt=this}static{this.type="ivec4"}constructor(n,t,e,r){super(),this.type="ivec4",this.children=[n,t,e,r].filter(s=>s!=null)}clone(){const n=new mt(a(this.children[0]),a(this.children[1]),a(this.children[2]),a(this.children[3]));return super.cloneInto(n),n}};St=mt=v([I],St);class qt extends m{static{this.type="mat2"}constructor(t,e,r,s){super(),this.type="mat2",this.children=[t,e,r,s]}clone(){const t=new qt(a(this.children[0]),a(this.children[1]),a(this.children[2]),a(this.children[3]));return super.cloneInto(t),t}get(t,e){return et(this,new y(t),new y(e),p)}multiply(t){return M(this,t)}}class H extends m{static{this.type="mat3"}static identity(){return new H(1,0,0,0,1,0,0,0,1)}static fromRotation(t){const e=Te(t),r=Ne(t);return new H(r,e,0,ye(e),r,0,0,0,1)}constructor(t,e,r,s,i,o,h,u,c){super(),this.type="mat3",this.children=[t,e,r,s,i,o,h,u,c]}add(t){return j(this,t)}multiply(t){return M(this,t)}get(t,e){return et(this,new y(t),new y(e),p)}clone(){const t=new H(a(this.children[0]),a(this.children[1]),a(this.children[2]),a(this.children[3]),a(this.children[4]),a(this.children[5]),a(this.children[6]),a(this.children[7]),a(this.children[8]));return super.cloneInto(t),t}}class Z extends m{static{this.type="mat4"}static identity(){return new Z(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}constructor(t,e,r,s,i,o,h,u,c,d,l,b,N,E,k,S){super(),this.type="mat4",this.children=[t,e,r,s,i,o,h,u,c,d,l,b,N,E,k,S]}static fromColumns(t,e,r,s){return new Z(t.x,t.y,t.z,t.w,e.x,e.y,e.z,e.w,r.x,r.y,r.z,r.w,s.x,s.y,s.z,s.w)}multiply(t){return M(this,t)}get(t,e){return et(this,new y(t),new y(e),p)}clone(){const t=new Z(a(this.children[0]),a(this.children[1]),a(this.children[2]),a(this.children[3]),a(this.children[4]),a(this.children[5]),a(this.children[6]),a(this.children[7]),a(this.children[8]),a(this.children[9]),a(this.children[10]),a(this.children[11]),a(this.children[12]),a(this.children[13]),a(this.children[14]),a(this.children[15]));return super.cloneInto(t),t}}const le={float:p,vec2:Y,vec3:W,vec4:P,int:y,ivec2:Tt,ivec3:Mt,ivec4:St,uint:tt,uvec2:vt,uvec3:$t,uvec4:xt,bool:x,bvec2:_t,bvec3:It,bvec4:Nt},Ge=(...n)=>new y(...n),fe=(...n)=>new p(...n),Re=(...n)=>new Y(...n),qe=(...n)=>new W(...n),He=(...n)=>new P(...n),Ye=(...n)=>new H(...n);function _(n,t,e){const r=new e(new Pt(t,n,e));return r.isImplicit=!0,r}function et(n,t,e,r){const s=new r(new ae(t,e,n,r));return s.isImplicit=!0,s}function w(n,t,e,r=null){if(r){const i=new r,o=new r(new C(n,[t,e],!0,!1,i));return o.isImplicit=!0,o}if(t.type==="float"||t.type==="int"){const i=new e.constructor(new C(n,[t,e],!0,!1,e.constructor));return i.isImplicit=!0,i}if((t.type==="mat2"||t.type==="mat3"||t.type==="mat4")&&e.type!=="float"){const i=new e.constructor(new C(n,[t,e],!0,!1,e.constructor));return i.isImplicit=!0,i}const s=new t.constructor(new C(n,[t,e],!0,!1,t.constructor));return s.isImplicit=!0,s}function f(n,t,e=t.constructor){const r=new e(new C(n,[t],!1,!1,e));return r.isImplicit=!0,r}function T(n,t,e,r=t.constructor){const s=new r(new C(n,[t,e],!1,!1,r));return s.isImplicit=!0,s}function nt(n,t,e,r,s=t.constructor){const i=new s(new C(n,[t,e,r],!1,!1,s));return i.isImplicit=!0,i}function ye(n){return M(n,fe(-1))}function Et(n,t,e,r){return new t(new ce(n,t,e,r))}function me(n,t,e=0,r=n.size){const s=new y(e).setMutable().setDebugName("FindIndexIterator"),i=t(n.get(s)).setDebugName("FindIndexPredicate");return Et({iter:s},y,i,({out:h,iter:u,subgraph:c})=>`
${h} = -1;

for (; ${u} < ${r}; ${u}++) {

${c.body}

  if (${c.varName}) {
    ${h} = ${u};
    break;
  }

}
`).setDebugName("FindIndexBlock")}function ge(n,t,e=0,r=n.size){return Et({array:n},y,null,({out:i,array:o})=>`
${i} = -1;
for (int i = ${e}; i < ${r}; i++) {
  bool condition;
  ${t({array:o,i:"i",out:"condition"})}
  if (condition) {
    ${i} = i;
    break;
  }
}
`).setDebugName("GlslFindIndexBlock")}function be(n,t,e){const r=typeof t=="function"?t():t,s=typeof e=="function"?e():e,i=new r.constructor(new Ft(n,r,s));return i.isImplicit=!0,i}function Xe(...n){const t=n.map(([h,u])=>typeof u=="function"?[h,u()]:[h,u]),e=t[0][1].constructor,r=t.findIndex(h=>h[0]===!0);if(r===-1)throw new Error("A cond must have a fallthrough case with `true`/; ");const s=t.slice(0,r),i=t[r][1],o=new e(s.reduceRight((h,u)=>be(u[0],u[1],h),i));return o.isImplicit=!0,o}function M(n,t){return w("*",n,t)}function X(n,t){return w("/",n,t)}function j(n,t){return w("+",n,t)}function Q(n,t){return w("-",n,t)}function Qe(n,t){return w("%",n,t)}function Je(n,t){return w("<<",n,t)}function Ze(n,t){return w(">>",n,t)}function We(n,t){return w("&",n,t)}function tn(n,t){return w("|",n,t)}function en(n,t){return w("^",n,t)}function nn(n){return f("~",n)}function rn(n,t){return w("==",n,t,x)}function sn(n,t){return w("!=",n,t,x)}function on(n,t){return w("<",n,t,x)}function an(n,t){return w("<=",n,t,x)}function cn(n,t){return w(">",n,t,x)}function un(n,t){return w(">=",n,t,x)}function we(...n){return n.length<=1?n[0]:n.slice(1).reduce((t,e)=>ve(t,e),n[0])}function ve(n,t){return w("||",n,t,x)}function $e(...n){return n.length<=1?n[0]:n.slice(1).reduce((t,e)=>xe(t,e),n[0])}function xe(n,t){return w("^^",n,t,x)}function _e(...n){return n.length<=1?n[0]:n.slice(1).reduce((t,e)=>Ie(t,e),n[0])}function Ie(n,t){return w("&&",n,t,x)}function hn(n){return f("abs",n)}function dn(n){return f("acos",n)}function pn(n){return f("acosh",n)}function Kt(n){return f("all",n,x)}function Ut(n){return f("any",n,x)}function ln(n){return f("asin",n)}function fn(n){return f("asinh",n)}function yn(n,t){return t==null?f("atan",n):T("atan",n,t,n.constructor)}function mn(n){return f("atanh",n)}function gn(n){return f("ceil",n)}function bn(n,t,e){return nt("clamp",n,t,e,n.constructor)}function Ne(n){return f("cos",n)}function wn(n){return f("cosh",n)}function vn(n,t){return T("distance",n,t,p)}function $n(n,t){return T("dot",n,t,p)}function xn(n){return f("exp",n)}function _n(n){return f("floor",n)}function In(n){return f("fract",n)}function Nn(n){return f("length",n,p)}function Tn(n){return f("log",n)}function Mn(n){return f("log2",n)}function Sn(n,t){return T("max",n,t)}function kn(n,t){return T("min",n,t)}function Cn(n,t,e){return nt("mix",n,t,e)}function Pn(n,t){return T("mod",n,t)}function Fn(n){return f("normalize",n)}function En(n){return n.type==="bool"?f("!",n):f("not",n)}function Kn(n,t){return T("pow",n,t)}function Un(n){return f("round",n)}function Vn(n){return f("sign",n)}function Te(n){return f("sin",n)}function An(n){return f("sinh",n)}function On(n,t,e){return nt("smoothstep",n,t,e)}function jn(n){return f("sqrt",n)}function Bn(n,t){return T("step",n,t,t.constructor)}function Dn(n){return f("tan",n)}function zn(n){return f("tanh",n)}function Ln(n,t,e){return nt("texelFetch",n,t,e,P)}function Gn(n,t){return T("texture",n,t,P)}function Rn(n,t){const{initialValue:e,xRange:r,yRange:s,callback:i}=t,[o,h]=r,[u,c]=s,d=new y(0).setMutable().setDebugName("iterX"),l=new y(0).setMutable().setDebugName("iterY"),b=e.setMutable().setDebugName("accumulator"),N=i(b,n.get(d,l),d,l).setDebugName("callback");return Et({iterX:d,iterY:l,accumulator:b},e.constructor,N,({out:k,iterX:S,iterY:K,accumulator:D,subgraph:z})=>`
for (${K} = ${u}; ${K} < ${c}; ${K}++) {
  for (${S} = ${o}; ${S} < ${h}; ${S}++) {

  ${z.body}

  ${D} = ${z.varName};
  }
}
${k} = ${D};
`).setDebugName("reduce2DBody")}const L=5;function $(n,t,e){const r=t.split(`
`);for(const s of r)if(s.trim().length){{let i="";e!=null&&(i+=`/*id:${e??"000"}*/   `),n.body+=i.padEnd(14)}n.body+=" ".repeat(n.indent)+s+`
`}}class At{write(t){for(const e of t.rootOutputNodes())t.shouldPruneOutputNode(e)||(e.variableName=this._write(t,e.node));return t}_createVarName(t,e){let r="";return typeof e!="boolean"&&typeof e!="number"&&e.debugInfo.name&&(r=`${e.debugInfo.name}_`),`${r}v${t.varCount++}`}_write(t,e,r=!1){if(typeof e=="number"||typeof e=="boolean")return e.toString();let s=t.getEmit(e);if(s)return s;switch(e.shaderType){case"scope-node":s=this._writeScopeNode(t,e);break;case"primitive-node":s=this._writePrimitiveNode(t,e,r);break;case"function-node":s=this._writeFunctionNode(t,e);break;case"property-access-node":s=this._writePropertyAccessNode(t,e);break;case"property-access-2d-node":s=this._writePropertyAccess2DNode(t,e);break;case"text-node":s=e.text;break;case"block-node":s=this._writeBlockNode(t,e);break;case"condition-node":s=this._writeConditionNode(t,e)}return t.setEmit(e,s),s}_writeScopeNode(t,e){const r=new e.child.constructor;r.setDebugName(e.debugInfo.name);const s=this._write(t,r,!0);return $(t,`{ /*ScopeStart: ${e.uid} ${e.debugInfo.name}*/`),t.indent+=2,$(t,`${s} = ${this._write(t,e.child)};`),t.indent-=2,$(t,`} /*ScopeEnd: ${e.uid} ${e.debugInfo.name}*/`),s}_writeConditionNode(t,e){const r=new e.ifTrue.constructor,s=this._write(t,r,!0);$(t,`if (${this._write(t,e.condition)}) {`),t.indent+=2;const i=t.createSubgraphContext(),o=this._write(i,e.ifTrue);if(t.body+=i.body,o&&$(t,`${s} = ${o};`),t.indent-=2,$(t,"}"),e.ifFalse){$(t,"else {"),t.indent+=2;const h=t.createSubgraphContext(),u=this._write(h,e.ifFalse);t.body+=h.body,u&&$(t,`${s} = ${u};`),t.indent-=2,$(t,"}")}return s}_writeBlockNode(t,e){const{captureList:r,generator:s,returnType:i}=e,o={};for(const d in r){if(!r[d])continue;const l=this._write(t,r[d]);o[d]=l}const h=new i,u=this._write(t,h,!0);if(o.out=u,e.subgraph){const d=t.createSubgraphContext(),l=this._write(d,e.subgraph.child),b=d.body;o.subgraph={varName:l,body:b}}const c=s(o);return $(t,`{
`),t.indent+=2,$(t,c),t.indent-=2,$(t,`}
`),u}_writePropertyAccessNode(t,e){const r=this._write(t,e.target);return typeof e.property=="string"&&e.property.includes("[")?`${r}${e.property}`:typeof e.property!="string"?`${r}[${this._write(t,e.property)}]`:`${r}.${e.property}`}_writePropertyAccess2DNode(t,e){return`${this._write(t,e.target)}[${this._write(t,e.x)}][${this._write(t,e.y)}]`}_writeFunctionNode(t,e){const r=e.returnType.type;if(e.isInfix){const[o,h]=e.children.map(c=>this._write(t,c)),u=this._createVarName(t,e);return $(t,`${r.padEnd(L)} ${u} = ${o} ${e.token} ${h};`,e.uid),u}const s=e.children.map(o=>this._write(t,o)).join(", "),i=this._createVarName(t,e);return $(t,`${r.padEnd(L)} ${i} = ${e.token}(${s});`,e.uid),i}_writePrimitiveNode(t,e,r=!1){const s=t.getInput(e);if(s)return s.isUsed=!0,s.variableName;const i=e.children.length===1&&e.children[0]?.type===e.type;if(!e.isMutable&&(e.isImplicit||i))return this._write(t,e.children[0]);const o=this._createVarName(t,e);if(r)return $(t,`${e.type.padEnd(L)} ${o};`,e.uid),o;const h=!e.debugInfo.name&&!e.isMutable;if(h&&e.type==="float"&&typeof e.children[0]=="number")return Number.isInteger(e.children[0])?e.children[0].toFixed(1):e.children[0].toString();if(h&&e.type==="int"&&typeof e.children[0]=="number"&&Number.isInteger(e.children[0]))return e.children[0].toString();const u=e.children.map(c=>this._write(t,c)).join(", ");return e.type==="array"?($(t,`${e.type.padEnd(L)} ${o} = [${u}];`,e.uid),o):h?`${e.type}(${u})`:($(t,`${e.type.padEnd(L)} ${o} = ${e.type}(${u});`,e.uid),o)}}let U=class Ht{constructor(t,e,r){this.variableName=t,this.variableInputType=e,this.node=r,this.type="shader-input",this.isUsed=!1}clone(){return new Ht(this.variableName,this.variableInputType,a(this.node))}},V=class Yt{constructor(t,e,r){this.outVariableName=t,this.outVariableType=e,this.node=r,this.type="shader-output"}clone(){const t=new Yt(this.outVariableName,this.outVariableType,a(this.node));return t.variableName=this.variableName,t}};class O{static createVertex(t,e,r,s,i,o){const h=[];for(const c in t){const d=t[c],l=r.get(c);l?h.push(new U(l,"builtin",d)):h.push(new U("a_"+c,"in",d))}for(const c of s){const d=c.uniformHydrated;h.push(new U(c.uniformName,"uniform",d))}const u=[];for(const c in e){const d=e[c];c==="glPosition"?u.push(new V("gl_Position","builtin",d)):c==="glPointSize"?u.push(new V("gl_PointSize","builtin",d)):u.push(new V("v_"+c,"out",d))}return new O(h,u,i,o)}static createFragment(t,e,r,s,i,o){const h=[],u=Array.from(i.rootOutputNodes());for(const d in t){const l=t[d],b=r.get(d);if(b){h.push(new U(b,"builtin",l));continue}const N=u.find(E=>E.node===l);N&&h.push(new U(N.outVariableName,"in",l))}for(const d of s){const l=d.uniformHydrated;h.push(new U(d.uniformName,"uniform",l))}const c=[];for(const d in e){const l=e[d],b=r.get(d);d==="discard"?c.push(new V(null,"discard",l)):b?c.push(new V(b,"builtin",l)):c.push(new V(d,"out",l))}return new O(h,c,o)}constructor(t,e,r,s){this.type="shader-graph-context",this.indent=0,this.body="",this.varCount=0,this._inputShaderTypesByNodeUid=new Map,this._nodeEmitMap=new Map;for(const i of t)this._inputShaderTypesByNodeUid.set(i.node.uid,i);this._outputShaderTypes=e,this._transformFeedbackBindings=r,this._transformFeedbackNames=new Set(r.map(i=>"v_"+i.propertyKey)),this._usedInFragmentShader=s}shouldPruneOutputNode(t){return!!this._usedInFragmentShader&&t.outVariableType!=="builtin"&&!this._transformFeedbackNames.has(t.outVariableName)&&!this._usedInFragmentShader.has(t.node.uid)}setEmit(t,e){this._nodeEmitMap.set(t.uid,e)}getEmit(t){return this._nodeEmitMap.get(t.uid)}inputs(){return this._inputShaderTypesByNodeUid.values()}getInput(t){return this._inputShaderTypesByNodeUid.get(t.uid)}*rootOutputNodes(){for(const t of this._outputShaderTypes)yield t}*nodes(){const t=[];for(const e of this._outputShaderTypes.values())t.push(e.node);for(;t.length;){const e=t.pop();typeof e!="number"&&typeof e!="boolean"&&t.push(...e.children.filter(Boolean)),yield e}}*nodesOfTypeOrFunction(){for(const t of this.nodes())typeof t!="number"&&typeof t!="boolean"&&(yield t)}createSubgraphContext(){const t=this.clone();return t.body="",t.indent=this.indent+2,t._nodeEmitMap=new Map(this._nodeEmitMap),t}clone(){const t=new O([],this._outputShaderTypes,this._transformFeedbackBindings,this._usedInFragmentShader);return t._inputShaderTypesByNodeUid=this._inputShaderTypesByNodeUid,t.indent=this.indent,t.body=this.body,t.varCount=this.varCount,t._nodeEmitMap=this._nodeEmitMap,t}insertVertexShader(t){t.vertex.code.add(""),this._insertInputs(t,"vertex"),t.vertex.code.add(""),t.vertex.code.add("// OUTPUTS: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this.rootOutputNodes()){const r=e.outVariableType==="builtin";this.shouldPruneOutputNode(e)||(r?t.vertex.code.add(`// ${e.outVariableType.padEnd(7)} ${e.node.type.padEnd(9)} ${e.outVariableName};`):t.vertex.code.add(`${e.outVariableType.padEnd(10)} ${e.node.type.padEnd(9)} ${e.outVariableName};`))}t.vertex.code.add(""),t.vertex.code.add("void main() {"),t.vertex.code.add("  "+this.body.split(`
`).join(`
  `));for(const e of this.rootOutputNodes())this.shouldPruneOutputNode(e)||t.vertex.code.add(`  ${e.outVariableName} = ${e.variableName};`);t.vertex.code.add("}")}insertFragmentShader(t){this._insertInputs(t,"fragment"),t.fragment.code.add(""),t.fragment.code.add("// OUTPUTS: "),t.fragment.code.add("// --------------------------------------------------------- ");let e=0;for(const r of this.rootOutputNodes())r.outVariableType==="builtin"?t.fragment.code.add(`// ${r.outVariableType.padEnd(7)} ${r.node.type.padEnd(9)} ${r.outVariableName};`):t.outputs.add(r.outVariableName,r.node.type,e++);t.fragment.code.add(""),t.fragment.code.add("void main() {"),t.fragment.code.add("  "+this.body.split(`
`).join(`
  `));for(const r of this.rootOutputNodes())r.outVariableType==="discard"?(t.fragment.code.add("  // TODO: Should ensure codegen for discard appears first in fragment shader"),t.fragment.code.add(`  if (${r.variableName}) {`),t.fragment.code.add("    discard;"),t.fragment.code.add("  }"),t.fragment.code.add("  ")):t.fragment.code.add(`  ${r.outVariableName} = ${r.variableName};`);t.fragment.code.add("}")}_insertInputs(t,e){t[e].code.add("// INPUTS: "),t[e].code.add("// --------------------------------------------------------- ");for(const r of this.inputs())r.isUsed&&r.variableInputType!=="builtin"&&(r.node.type==="array"?t[e].code.add(`${r.variableInputType.padEnd(10)} ${r.node.elementType.type.padEnd(9)} ${r.variableName}[${r.node.size}];`):r.node.type==="array-2d"?t[e].code.add(`${r.variableInputType.padEnd(10)} ${r.node.elementType.type.padEnd(9)} ${r.variableName}[${r.node.size}]; // Emulated 2D Array. Not supported by ES3.0`):t[e].code.add(`${r.variableInputType.padEnd(10)} ${r.node.type.padEnd(9)} ${r.variableName};`))}}function Me(n,t,e){const r=new te(t.width,t.height);return r.dataType=t.dataType,t.depth&&(r.depth=t.depth),t.flipped&&(r.flipped=t.flipped),t.hasMipmap&&(r.hasMipmap=t.hasMipmap),r.internalFormat=t.internalFormat,t.isImmutable&&(r.isImmutable=t.isImmutable),t.isOpaque&&(r.isOpaque=t.isOpaque),t.maxAnisotropy&&(r.maxAnisotropy=t.maxAnisotropy),r.pixelFormat=t.pixelFormat,t.preMultiplyAlpha&&(r.preMultiplyAlpha=t.preMultiplyAlpha),t.samplingMode&&(r.samplingMode=t.samplingMode),t.target&&(r.target=t.target),r.uniform=t.uniform,t.unpackAlignment&&(r.unpackAlignment=t.unpackAlignment),t.wrapMode&&(r.wrapMode=t.wrapMode),new ee(n,r,e)}const Se=()=>jt.getLogger("esri.views.2d.engine.webgl.shaderGraph.typed.TypedShaderProgram");function G(n,t,e){const r=t.length;if(r!==e){const s=new Zt("Invalid Uniform",`Invalid length, expected ${e} but got ${r}`,{uniformName:n,values:t});Se().errorOnce(s)}}class Ot{constructor(t,e,r,s,i,o){this._program=null,this._vao=null,this._temporaryTextures=[],this.vertexShader=t,this.fragmentShader=e,this._locations=r,this._locationInfo=s,this._uniformBindings=i,this._transformFeedbackBindings=o}destroy(){this._program&&this._program.dispose(),this.cleanupTemporaryTextures()}get locations(){return this._locations}get locationInfo(){return this._locationInfo}setUniforms(t){this._uniforms=t}cleanupTemporaryTextures(){for(const t of this._temporaryTextures)t.dispose();this._temporaryTextures=[]}bind(t){const e=this._uniforms;if(!this._program){const s=new Map;for(const[o,h]of this._locations)s.set(o,h);const i=[];for(const o of this._transformFeedbackBindings??[]){const{index:h,propertyKey:u}=o;i[h]=`v_${u}`}this._program=new ne(t,this.vertexShader,this.fragmentShader,s,new Map,i)}const r=this._program;t.useProgram(r);for(const s of this._uniformBindings){const{shaderModulePath:i,uniformName:o,uniformType:h,uniformArrayLength:u}=s,c=Jt(i,e);if(c==null){if(h==="sampler2D")continue;throw new Error(`Failed to find uniform value for ${i}`)}switch(h==="array"||h==="array-2d"?s.uniformArrayElementType:h){case"sampler2D":{const{unit:d,texture:l}=c;if(r.setUniform1i(o,d),"type"in l)t.bindTexture(l,d);else{const b=Me(t,l.descriptor,l.data);t.bindTexture(b,d)}break}case"int":if(!u){r.setUniform1i(o,c);break}G(s.uniformName,c,u),r.setUniform1iv(o,c);break;case"float":if(!u){r.setUniform1f(o,c);break}G(s.uniformName,c,u),r.setUniform1fv(o,c);break;case"vec2":if(!u){r.setUniform2f(o,c[0],c[1]);break}G(s.uniformName,c,u),r.setUniform2fv(o,c.flat());break;case"vec3":if(!u){r.setUniform3f(o,c[0],c[1],c[2]);break}G(s.uniformName,c,u),r.setUniform3fv(o,c.flat());break;case"vec4":if(!u){r.setUniform4f(o,c[0],c[1],c[2],c[3]);break}G(s.uniformName,c,u),r.setUniform4fv(o,c.flat());break;case"mat3":r.setUniformMatrix3fv(o,c);break;case"mat4":r.setUniformMatrix4fv(o,c);break;default:throw new Error(`Unable to set uniform for type ${h}`)}}}}function R(n){return new n}function B(n,t,e){const r=n.constructor[t]??[];n.constructor.hasOwnProperty(t)||Object.defineProperty(n.constructor,t,{value:r.slice()}),n.constructor[t].push(e)}function qn(n,t){return(e,r)=>{B(e,"locations",{typeCtor:t,propertyKey:r,parameterIndex:null,index:n})}}const ke=n=>(t,e)=>{B(t,"builtins",{builtin:n,propertyKey:e})},Hn=n=>(t,e,r)=>{B(t,"inputs",{inputCtor:n,propertyKey:e,parameterIndex:r})},Yn=n=>(t,e)=>{B(t,"uniforms",{typeCtor:n,propertyKey:e})},Xn=n=>(t,e)=>{B(t,"options",{typeCtor:n,propertyKey:e})},Qn=(n,t)=>{B(n,"defines",{propertyKey:t})},kt=(n,t)=>(e,r)=>{e.constructor.builtins.push({builtin:n,propertyKey:r,typeCtor:t})};class Ce{static{this.builtins=[]}}v([kt("gl_VertexID",y)],Ce.prototype,"glVertexID",void 0);class Jn{}let Ct=class{static{this.builtins=[]}};v([kt("gl_FragCoord",P)],Ct.prototype,"glFragCoord",void 0),v([kt("gl_PointCoord",Y)],Ct.prototype,"glPointCoord",void 0);class Pe{}v([ke("gl_FragDepth")],Pe.prototype,"glFragDepth",void 0);let Wn=class{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}},er=class{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const t=this._shaderModuleClass.inputs.findLast(e=>e.propertyKey==="vertex"&&e.parameterIndex===0);if(!t)throw new Error("Unable to find vertex input parameter");return t}get computeInput(){return this._shaderModuleClass.inputs.findLast(t=>t.propertyKey==="vertex"&&t.parameterIndex===1)}get fragmentInput(){const t=this._shaderModuleClass.inputs.findLast(e=>e.propertyKey==="fragment");if(!t)throw new Error("Unable to find fragment input parameter");return t}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){return[...this.vertexInput.inputCtor.locations,...this.computeInput?.inputCtor.locations??[]]}get locationsMap(){const t=new Map,e=new Set;for(const r of this.locations)e.has(r.index)?jt.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${r.propertyKey} to ${r.index}. Index already in use`,{locationsMap:t}):(t.set(r.propertyKey,r.index),e.add(r.index));return t}get locationInfo(){if(!this._locationInfo){const t=this.locationsMap,e=Array.from(t.entries()).map(([i,o])=>`${i}.${o}`).join("."),r=Wt(e),s=this.computeAttributes;this._locationInfo={hash:r,stringHash:e,locations:t,computeAttributeMap:s}}return this._locationInfo}get renamedLocationsMap(){const t=new Map;for(const e of this.locations)t.set("a_"+e.propertyKey,e.index);return t}get optionPropertyKeys(){if(!this._optionPropertyKeys){const t=new Set;for(const e of this._options)t.add(e.propertyKey);this._optionPropertyKeys=t}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram(t,e,r,s){try{const{vertex:i,fragment:o,uniformBindings:h}=this._generateShaders(t,e,r,s);return new Ot(i,o,this.renamedLocationsMap,this.locationInfo,h,this.transformFeedbackBindings)}catch{return new Ot("","",this.renamedLocationsMap,this.locationInfo,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo(t){const e=this._options.find(s=>s.propertyKey===t);if(e)return{type:"option",className:e.typeCtor};const r=this._uniforms.find(s=>s.propertyKey===t);if(!r)throw new Error(`Unable to find uniform class type for property: ${t}`);return{type:"required",className:r.typeCtor}}getShaderKey(t,e,r,s){const i=Object.keys(t).map(c=>`${c}.${t[c]}`).join("."),o=Object.keys(r).map(c=>`${c}.${r[c]}`).join("."),h=Object.keys(s).map(c=>`${c}.${s[c]}`).join("."),u=Object.keys(e).filter(c=>this.optionPropertyKeys.has(c)&&e[c]).join(".");return`${this.type}.${i}.${o}.${h}.${u}`}_generateShaders(t,e,r,s){const i=[];this._setDefines(r),this._setOptionalUniforms(i,e),this._setRequiredUniforms(i);const o=this._hydrateVertexInput(s),h=this._injectPackPrecisionFactor(o,t),u=this._hydrateComputeInput(),c=u&&this._injectComputePackPrecisionFactor(u,t),d=this.vertex(h,c),l=this._hydrateFragmentInput(d),b=this.fragment(l),N=new Set;for(const Xt in b){const Qt=b[Xt];ie(N,Qt)}const E=this._getVertexInputBuiltins(),k=O.createVertex({...o,...u},d,E,i,this.transformFeedbackBindings,N);new At().write(k);const S=this._getFragmentInputBuiltins(b);S.set("glPointCoord","gl_PointCoord");const K=O.createFragment(l,b,S,i,k,this.transformFeedbackBindings);new At().write(K);const D=this._createShaderBuilder(k,K),z=D.generate("vertex"),Vt=D.generate("fragment");return this.logShader&&(console.log(z),console.log(Vt)),{vertex:z,fragment:Vt,uniformBindings:i}}_setDefines(t){for(const e in t)this[e]=t[e]}_setOptionalUniforms(t,e){for(const r of this._options)e[r.propertyKey]?this[r.propertyKey]=this._hydrateUniformGroup(t,r):this[r.propertyKey]=null}_setRequiredUniforms(t){for(const e of this._uniforms)this[e.propertyKey]=this._hydrateUniformGroup(t,e)}_hydrateUniformGroup(t,e){const r=new e.typeCtor;for(const s of r._uniforms??[]){const i=R(s.typeCtor),o=`u_${e.propertyKey}_${s.propertyKey}`,h=i.type,u=[e.propertyKey,s.propertyKey].join(".");if("type"in s.typeCtor&&s.typeCtor.type==="array"){const c=i;t.push({shaderModulePath:u,uniformName:o,uniformType:h,uniformArrayLength:c.size,uniformArrayElementType:c.elementType.type,uniformHydrated:i})}else if("type"in s.typeCtor&&s.typeCtor.type==="array-2d"){const c=i;t.push({shaderModulePath:u,uniformName:o,uniformType:h,uniformArrayLength:c.size,uniformArrayElementType:c.elementType.type,uniformHydrated:i})}else t.push({shaderModulePath:u,uniformName:o,uniformType:h,uniformHydrated:i});r[s.propertyKey]=i}return r}_hydrateVertexInput(t){const e=this.vertexInput.inputCtor,r=e.locations.reduce((s,i)=>t[i.propertyKey]===!1?s:{...s,[i.propertyKey]:R(i.typeCtor)},{});for(const{propertyKey:s,typeCtor:i}of e.builtins){const o=R(i);r[s]=o}return r}_hydrateComputeInput(){return this.computeInput==null?null:this.computeInput.inputCtor.locations.reduce((t,e)=>({...t,[e.propertyKey]:R(e.typeCtor)}),{})}_injectPackPrecisionFactor(t,e){const r={};for(const s in t){const i=t[s],o=e[s];if(o){if(i.type!=="float"&&i.type!=="vec2"&&i.type!=="vec3"&&i.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${i.type}`);r[s]=i.divide(new p(o))}else r[s]=i}return r}_injectComputePackPrecisionFactor(t,e){const r={},s=new Map;for(const i in this.computeAttributes)for(const o of this.computeAttributes[i]??[])s.set(o,i);for(const i in t){const o=t[i],h=s.get(i);if(!h)continue;const u=e[h];if(u){if(o.type!=="float"&&o.type!=="vec2"&&o.type!=="vec3"&&o.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${o.type}`);r[i]=o.divide(new p(u))}else r[i]=o}return r}_hydrateFragmentInput(t){const e={};for(const r in t)e[r]=t[r];for(const{propertyKey:r,typeCtor:s}of Ct.builtins){const i=R(s);e[r]=i}return e}_getVertexInputBuiltins(){const t=this.vertexInput.inputCtor,e=new Map;for(const{builtin:r,propertyKey:s}of t.builtins)e.set(s,r);return e}_getFragmentInputBuiltins(t){const e=t.constructor,r=new Map;for(const s of e.builtins??[])r.set(s.propertyKey,s.builtin);return r}_createShaderBuilder(t,e){const r=new re;return this._insertDebugInfo(r),t.insertVertexShader(r),e.insertFragmentShader(r),r}_insertDebugInfo(t){t.vertex.code.add("// DEFINES: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this._defines)this[e.propertyKey]?t.vertex.code.add(`//   ${e.propertyKey}: true`):t.vertex.code.add(`//   ${e.propertyKey}: false`);t.vertex.code.add(""),t.vertex.code.add("// OPTIONS: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this._options)this[e.propertyKey]?t.vertex.code.add(`//   ${e.propertyKey}: true`):t.vertex.code.add(`//   ${e.propertyKey}: false`)}};export{Xn as $,jn as A,an as B,Sn as C,on as D,yn as E,Ne as F,cn as G,On as H,y as I,Un as J,Qn as K,M as L,Ln as M,x as N,Ge as O,Wn as P,hn as Q,Nn as R,Qe as S,In as T,Rt as U,Vn as V,Kn as W,W as X,Cn as Y,Tt as Z,p as _,Pn as a,bt as a0,ye as a1,sn as a2,un as a3,$e as a4,we as a5,_e as a6,en as a7,nn as a8,Ze as a9,Ot as aA,Je as aa,tn as ab,We as ac,zn as ad,Dn as ae,An as af,wn as ag,mn as ah,fn as ai,ln as aj,pn as ak,dn as al,gn as am,xn as an,Mn as ao,Tn as ap,Rn as aq,wt as ar,Et as as,Jn as at,Z as au,qt as av,vn as aw,En as ax,Fn as ay,Ye as az,rn as b,Y as c,Gn as d,P as e,qn as f,Yn as g,qe as h,Ce as i,er as j,be as k,He as l,Hn as m,bn as n,Re as o,kn as p,Bn as q,H as r,Te as s,je as t,fe as u,Ct as v,Pe as w,Xe as x,$n as y,_n as z};
