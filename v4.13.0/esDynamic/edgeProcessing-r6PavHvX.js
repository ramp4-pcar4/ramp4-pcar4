import{e as Ot}from"./deduplicate-DRKoZSEv.js";import{O as x}from"./InterleavedLayout-C2YUDwKf.js";import{e as c}from"./VertexAttribute-hUz6pozM.js";import{t as k}from"./glUtil-0ZzWJjlL.js";import{ah as T,cJ as H,di as It,dz as nt,ig as St}from"./main-BFDurRCu.js";import{p as At,o as J,s as ot,P as q,c as st,_ as at,A as it,K as Et,u as Tt}from"./vec32-Cj8pVsU0.js";import{e as G}from"./Normals-BNEsVQbp.js";const rt=x().vec3f(c.POSITION).u16(c.COMPONENTINDEX).freeze(),wt=x().vec2u8(c.SIDENESS).freeze();k(wt);const Q=x().vec3f(c.POSITION0).vec3f(c.POSITION1).vec2i16(c.NORMALCOMPRESSED).u16(c.COMPONENTINDEX).u8(c.VARIANTOFFSET,{glNormalized:!0}).u8(c.VARIANTSTROKE).u8(c.VARIANTEXTENSION,{glNormalized:!0}).freeze(),j=x().vec3f(c.POSITION0).vec3f(c.POSITION1).vec2i16(c.NORMALCOMPRESSED).vec2i16(c.NORMAL2COMPRESSED).u16(c.COMPONENTINDEX).u8(c.VARIANTOFFSET,{glNormalized:!0}).u8(c.VARIANTSTROKE).u8(c.VARIANTEXTENSION,{glNormalized:!0}).freeze();c.POSITION0,c.POSITION1,c.COMPONENTINDEX,c.VARIANTOFFSET,c.VARIANTSTROKE,c.VARIANTEXTENSION,c.NORMALCOMPRESSED,c.NORMAL2COMPRESSED,c.SIDENESS;class vt{constructor(){this.position0=T(),this.position1=T(),this.faceNormal0=T(),this.faceNormal1=T(),this.componentIndex=0,this.cosAngle=0}}const B=-1;function ct(t,n,s){const a=t.vertices.position,r=t.vertices.componentIndex,f=N.position0,g=N.position1,O=N.faceNormal0,S=N.faceNormal1,{edges:i,normals:d}=Mt(t),m=i.length/4,A=n.allocate(m);let V=0;const _=m,w=s?.allocate(_);let b=0,e=0,o=0;X.length=0;for(let p=0;p<m;++p){const R=4*p;a.getVec(i.data[R],f),a.getVec(i.data[R+1],g);const C=X.pushNew();C.index=4*p,C.length=At(f,g)}X.sort((p,R)=>R.length-p.length);const u=new Array,l=new Array;X.forAll(({length:p,index:R})=>{const C=i.data[R],mt=i.data[R+1],$=i.data[R+2],tt=i.data[R+3],et=tt===B;if(a.getVec(C,f),a.getVec(mt,g),et){const E=3*$;J(O,d.data[E],d.data[E+1],d.data[E+2]),ot(S,O),N.componentIndex=r.get(C),N.cosAngle=q(O,S)}else{let E=3*$;if(J(O,d.data[E],d.data[E+1],d.data[E+2]),E=3*tt,J(S,d.data[E],d.data[E+1],d.data[E+2]),N.componentIndex=r.get(C),N.cosAngle=q(O,S),yt(N,Ct))return;N.cosAngle<-.9999&&ot(S,O)}e+=p,o++,et||Rt(N,Lt)?(n.write(A,V++,N),u.push(p)):Pt(N,ft)&&(w&&s&&s.write(w,b++,N),l.push(p))});const I=new Float32Array(u.reverse()),v=new Float32Array(l.reverse()),y=w&&s?{instancesData:w.slice(0,b),lodInfo:{lengths:v}}:void 0;return{regular:{instancesData:A.slice(0,V),lodInfo:{lengths:I}},silhouette:y,averageEdgeLength:e/o}}function Rt(t,n){return t.cosAngle<n}function yt(t,n){return t.cosAngle>n}function Pt(t,n){const s=It(t.cosAngle);return Et(lt,t.position1,t.position0),s*(q(at(Dt,t.faceNormal0,t.faceNormal1),lt)>0?-1:1)>n}function Mt(t){const n=t.faces.length/3,s=t.faces,a=t.neighbors,r=t.vertices.position;h.length=Y.length=0;for(let f=0;f<n;f++){const g=3*f,O=a[g],S=a[g+1],i=a[g+2],d=s[g],m=s[g+1],A=s[g+2];r.getVec(d,D),r.getVec(m,W),r.getVec(A,U),st(W,W,D),st(U,U,D),at(D,W,U),it(D,D),Y.pushArray(D),(O===B||d<m)&&(h.push(d),h.push(m),h.push(f),h.push(O)),(S===B||m<A)&&(h.push(m),h.push(A),h.push(f),h.push(S)),(i===B||A<d)&&(h.push(A),h.push(d),h.push(f),h.push(i))}return{edges:h,normals:Y}}class Vt{constructor(){this.index=0,this.length=0}}const X=new H({allocator:t=>t||new Vt,deallocator:null}),h=new H({deallocator:null}),Y=new H({deallocator:null}),N=new vt,Dt=T(),lt=T(),D=T(),W=T(),U=T(),ft=nt(4),Ct=Math.cos(ft),xt=nt(35),Lt=Math.cos(xt);function ut(t,n,s){const a=n/3,r=new Uint32Array(s+1),f=new Uint32Array(s+1),g=(e,o)=>{e<o?r[e+1]++:f[o+1]++};for(let e=0;e<a;e++){const o=t[3*e],u=t[3*e+1],l=t[3*e+2];g(o,u),g(u,l),g(l,o)}let O=0,S=0;for(let e=0;e<s;e++){const o=r[e+1],u=f[e+1];r[e+1]=O,f[e+1]=S,O+=o,S+=u}const i=new Uint32Array(6*a),d=r[s],m=(e,o,u)=>{if(e<o){const l=r[e+1]++;i[2*l]=o,i[2*l+1]=u}else{const l=f[o+1]++;i[2*d+2*l]=e,i[2*d+2*l+1]=u}};for(let e=0;e<a;e++){const o=t[3*e],u=t[3*e+1],l=t[3*e+2];m(o,u,e),m(u,l,e),m(l,o,e)}const A=(e,o)=>{const u=2*e,l=o-e;for(let I=1;I<l;I++){const v=i[u+2*I],y=i[u+2*I+1];let p=I-1;for(;p>=0&&i[u+2*p]>v;p--)i[u+2*p+2]=i[u+2*p],i[u+2*p+3]=i[u+2*p+1];i[u+2*p+2]=v,i[u+2*p+3]=y}};for(let e=0;e<s;e++)A(r[e],r[e+1]),A(d+f[e],d+f[e+1]);const V=new Int32Array(3*a),_=(e,o)=>e===t[3*o]?0:e===t[3*o+1]?1:e===t[3*o+2]?2:-1,w=(e,o)=>{const u=_(e,o);V[3*o+u]=-1},b=(e,o,u,l)=>{const I=_(e,o);V[3*o+I]=l;const v=_(u,l);V[3*l+v]=o};for(let e=0;e<s;e++){let o=r[e];const u=r[e+1];let l=f[e];const I=f[e+1];for(;o<u&&l<I;){const v=i[2*o],y=i[2*d+2*l];v===y?(b(e,i[2*o+1],y,i[2*d+2*l+1]),o++,l++):v<y?(w(e,i[2*o+1]),o++):(w(y,i[2*d+2*l+1]),l++)}for(;o<u;)w(e,i[2*o+1]),o++;for(;l<I;)w(i[2*d+2*l],i[2*d+2*l+1]),l++}return V}const Z=.7;let dt=class{updateSettings(t){this.settings=t,this._edgeHashFunction=t.reducedPrecision?zt:Ft}write(t,n,s){K.seed=this._edgeHashFunction(s);const a=K.getIntRange(0,255),r=K.getIntRange(0,this.settings.variants-1),f=K.getFloat(),g=255*(.5*_t(-(1-Math.min(f/Z,1))+Math.max(0,f-Z)/(1-Z),1.2)+.5);t.position0.setVec(n,s.position0),t.position1.setVec(n,s.position1),t.componentIndex.set(n,s.componentIndex),t.variantOffset.set(n,a),t.variantStroke.set(n,r),t.variantExtension.set(n,g)}};const P=new Float32Array(6),M=new Uint32Array(P.buffer),L=new Uint32Array(1);function Ft(t){return P[0]=t.position0[0],P[1]=t.position0[1],P[2]=t.position0[2],P[3]=t.position1[0],P[4]=t.position1[1],P[5]=t.position1[2],L[0]=31*(31*(31*(31*(31*(166811+M[0])+M[1])+M[2])+M[3])+M[4])+M[5],L[0]}function zt(t){const n=P;n[0]=F(t.position0[0]),n[1]=F(t.position0[1]),n[2]=F(t.position0[2]),n[3]=F(t.position1[0]),n[4]=F(t.position1[1]),n[5]=F(t.position1[2]),L[0]=5381;for(let s=0;s<M.length;s++)L[0]=31*L[0]+M[s];return L[0]}const pt=1e4;function F(t){return Math.round(t*pt)/pt}function _t(t,n){return Math.abs(t)**n*Math.sign(t)}class bt{constructor(){this._commonWriter=new dt}updateSettings(n){this._commonWriter.updateSettings(n)}allocate(n){return Q.createBuffer(n)}write(n,s,a){this._commonWriter.write(n,s,a),Tt(z,a.faceNormal0,a.faceNormal1),it(z,z);const{typedBuffer:r,typedBufferStride:f}=n.normalCompressed;G(r,s,z[0],z[1],z[2],f)}static{this.Layout=Q}static{this.glLayout=k(Q,1)}}class Bt{constructor(){this._commonWriter=new dt}updateSettings(n){this._commonWriter.updateSettings(n)}allocate(n){return j.createBuffer(n)}write(n,s,a){this._commonWriter.write(n,s,a);{const{typedBuffer:r,typedBufferStride:f}=n.normalCompressed;G(r,s,a.faceNormal0[0],a.faceNormal0[1],a.faceNormal0[2],f)}{const{typedBuffer:r,typedBufferStride:f}=n.normal2Compressed;G(r,s,a.faceNormal1[0],a.faceNormal1[1],a.faceNormal1[2],f)}}static{this.Layout=j}static{this.glLayout=k(j,1)}}const z=T(),K=new St;function Xt(t){const n=gt(t.data,t.skipDeduplicate,t.indices,t.indicesLength);return ht.updateSettings(t.writerSettings),Nt.updateSettings(t.writerSettings),ct(n,ht,Nt)}function gt(t,n,s,a){if(n){const g=ut(s,a,t.count);return new Wt(s,a,g,t)}const r=Ot(t.buffer,t.stride/4,{originalIndices:s}),f=ut(r.indices,a,r.uniqueCount);return{faces:r.indices,facesLength:r.indices.length,neighbors:f,vertices:rt.createView(r.buffer)}}class Wt{constructor(n,s,a,r){this.faces=n,this.facesLength=s,this.neighbors=a,this.vertices=r}}const ht=new bt,Nt=new Bt,Ut=x().vec3f(c.POSITION0).vec3f(c.POSITION1),Kt=x().vec3f(c.POSITION0).vec3f(c.POSITION1).u16(c.COMPONENTINDEX);export{rt as E,Ut as d,Xt as f,Kt as g,ct as p,gt as u};
