import{a as m,m as X}from"./Point2D-CaHJVGk1.js";import"./Envelope2D-DlBzXkgv.js";import{O as Y,Y as z,r as k,E as I,e as h}from"./ProjectionTransformation-DQ4GElxa.js";import{b$ as N,cr as S,c2 as p,am as O,al as D}from"./main-BFDurRCu.js";import{fromGeometryToGXGeometry as g,toGeometry as y}from"./jsonConverter-tsQ40CV0.js";const s="_gxVersion",x=2,C=1;function $(e){return Array.isArray(e)?e[0].spatialReference:e.spatialReference}function b(e){switch(e.type){case"point":return w(e);case"multipoint":return V(e);case"polyline":return P(e);case"polygon":return Z(e);case"extent":return M(e);default:throw new Error(`Unsupported geometry type: ${e.type}`)}}function M(e){if(!e.getCacheValue(s)){const n=new k;n.setCoords(e.xmin,e.ymin,e.xmax,e.ymax),e.hasM&&n.setInterval(x,0,e.mmin,e.mmax),e.hasZ&&n.setInterval(C,0,e.zmin,e.zmax),e.setCacheValue(s,n)}return e.getCacheValue(s)}function V(e){if(!e.getCacheValue(s)){const n=new I,a=new h,r=e.points,t=e.hasM,o=e.hasZ,i=o?3:2;for(let u=0,l=r.length;u<l;u++){const c=r[u];a.setXYCoords(c[0],c[1]),o&&a.setZ(c[2]??0),t&&a.setM(c[i]??NaN),n.add(a)}e.setCacheValue(s,n)}return e.getCacheValue(s)}function w(e){if(!e.getCacheValue(s)){const n=new h;n.setXYCoords(e.x,e.y),e.hasM&&n.setM(e.m),e.hasZ&&n.setZ(e.z),e.setCacheValue(s,n)}return e.getCacheValue(s)}function Z(e){if(!e.getCacheValue(s)){const{curveRings:n,hasM:a,hasZ:r,rings:t}=e,o=g({curveRings:n,hasM:a,hasZ:r,rings:t});e.setCacheValue(s,o)}return e.getCacheValue(s)}function P(e){if(!e.getCacheValue(s)){const{curvePaths:n,hasM:a,hasZ:r,paths:t}=e,o=g({curvePaths:n,hasM:a,hasZ:r,paths:t});e.setCacheValue(s,o)}return e.getCacheValue(s)}function q(e){if(e.wkid)return Y(e.wkid);const n=e.wkt2||e.wkt;return n?z(n):null}function A(e,n){if(e)switch(e.getGeometryType()){case m.enumPoint:return E(e,n);case m.enumEnvelope:return v(e,n);case m.enumMultiPoint:return R(e,n);case m.enumPolyline:return G(e,n);case m.enumPolygon:return d(e,n)}return null}function v(e,n){if(e.isEmpty())return null;const a=new N({xmin:e.getXMin(),ymin:e.getYMin(),xmax:e.getXMax(),ymax:e.getYMax(),spatialReference:n}),r=e.getDescription();if(r.hasM()){const t=e.queryInterval(x,0);a.mmin=t.vmin,a.mmax=t.vmax}if(r.hasZ()){const t=e.queryInterval(C,0);a.zmin=t.vmin,a.zmax=t.vmax}return a.setCacheValue(s,e),a}function R(e,n){if(e.isEmpty())return null;const a=e.getDescription(),r=a.hasM(),t=a.hasZ(),o=[],i=new h;for(let l=0,c=e.getPointCount();l<c;l++){e.getPointByVal(l,i);const f=[i.getX(),i.getY()];t&&f.push(i.getZ()),r&&f.push(i.getM()),o.push(f)}const u=new S({hasM:r,hasZ:t,points:o,spatialReference:n});return u.setCacheValue(s,e),u}function E(e,n){if(e instanceof X)return new p({x:e.x,y:e.y,spatialReference:n});if(e.isEmpty())return null;const a=new p({x:e.getX(),y:e.getY(),spatialReference:n}),r=e.getDescription();return r.hasM()&&(a.m=e.getM()),r.hasZ()&&(a.z=e.getZ()),a.setCacheValue(s,e),a}function d(e,n){if(e.isEmpty())return null;const a=O.fromJSON({spatialReference:n,...y(e,null)});return a.setCacheValue(s,e),a}function G(e,n){if(e.isEmpty())return null;const a=D.fromJSON({spatialReference:n,...y(e,null)});return a.setCacheValue(s,e),a}export{M as fromExtent,b as fromGeometry,V as fromMultipoint,w as fromPoint,Z as fromPolygon,P as fromPolyline,q as fromSpatialReference,$ as getSpatialReference,v as toExtent,A as toGeometry,R as toMultipoint,E as toPoint,d as toPolygon,G as toPolyline};
