import{s as Ae,t as qe}from"./SimpleGeometryCursor-DSF_YyIm.js";import{d as Ee,z as Re,P as oe,j as ge,y as ze,a as T,E as Xe,f as Ye,l as Be,i as W,v as Fe,Y as Oe,O as We,m as C,o as k,W as F,K as A}from"./Point2D-CaHJVGk1.js";import{Envelope2D as M}from"./Envelope2D-DlBzXkgv.js";import{h as J,u as N,m as Je,R as Ue,H as je,V as me,b as pe,F as U,s as $,e as Pe,o as xe,q as j,A as He,t as Ve,B as X,M as Z,W as Le,x as Ke,G as ee,J as be,a as ye,N as ae,P as he,Q as Qe,U as ce,_ as q,$ as Y,C as x,D as v,a0 as te,a1 as se,a2 as ne,a3 as Ce,a4 as $e,a5 as Ze,a6 as et,a7 as tt}from"./ProjectionTransformation-DQ4GElxa.js";import{dS as S,dT as E}from"./main-BFDurRCu.js";import{x as H}from"./Transformation2D-CXWnDKXs.js";import{i as st}from"./GeometryCleaner-BEJM7I4l-DzJanffG.js";function nt(p,e,s,t,m,o){t<Number.MAX_VALUE&&t>-Number.MAX_VALUE||oe("Geodesic_bufferer.buffer - bad distance"),ge(p);const i=st(p),r=i.getGeometryType();if(ze(r)){const n=i.getPointCount(),c=8e6;if(Math.abs(t)>c&&(n>50||r!==T.enumMultiPoint&&s===4&&n>2)){let a=i;const _=t>0?1:-1,h=7e6;let u=t,l=1;do l++,u=(Math.abs(u)-h)*_;while(Math.abs(u)>c);u=t;for(let f=0;f<l-1;f++)a=ue(a,e,s,h*_,m,l,o),u=(Math.abs(u)-h)*_;return a=ue(a,e,s,u,m,l,o),a}}return ue(i,e,s,t,m,1,o)}class it{constructor(e){this.m_sr=null,this.m_gcs=null,this.m_transform=null,this.m_a=0,this.m_eSquared=0,this.m_rpu=0,this.m_radTolerance=0,this.m_q90=0,this.m_gcs90=0,this.m_gcs180=0,this.m_gcs360=0,this.m_gcs60=0,this.m_ellipticToGeodesicMaxRatio=0,this.m_curveType=0,this.m_bShapePreserving=!1,this.m_distance=0,this.m_absDistance=0,this.m_convergenceOffset=0,this.m_cornerStep=0,this.m_segmentStep=0,this.m_progressTracker=e}bufferPolygon(e){const s=new N,t=new Me(this,e,s);return this.processGnomonicBufferPiecesCursor(!0,t)}bufferPolyline(e){const s=new Me(this,e,null);return this.processGnomonicBufferPiecesCursor(!0,s)}bufferMultiPoint(e){const s=new mt(this,e);return this.processGnomonicBufferPiecesCursor(!1,s)}bufferPoint(e){const s=e.getXY();s.scale(this.m_rpu);let t=new N;if(this.bufferPoint2D(s,!1,t)){const m=X(null,t,!0);t=Z(t,m,!0,!0,-1,this.m_progressTracker,0,!1)}return t=new j().foldInto360RangeGeodetic(t,this.m_gcs,2),t}processGnomonicBufferPiecesCursor(e,s){const t=s;let m=t.getGnomonic();const o=Le(Ke());let i=new ee,r=new J().executeMany(i,o,this.m_progressTracker,2);const n=Oe(6,!1),c=We(M,6);this.initializeGrid(n,c);const a=[null,null,null,null,null,null],_=[null,null,null,null,null,null],h=[null,null,null,null,null,null];let u,l,f;for(;(u=t.next())!==null;){if(l=t.getGnomonic(),l!==m){if(m!==null){let g=r.next();if(i=null,r=null,g!=null){const w=X(o,g,!0),P=U(w);g=m.unproject(g,P,this.m_progressTracker),this.putInGridCursors(e,g,o,!0,n,c,a,_,h)}}l!==null&&(i=new ee,r=new J().executeMany(i,o,this.m_progressTracker,2)),m=l}if(t.isRunningInGnomonic()){if(l.project(u),t.needsSimplify()){const g=X(null,u,!0);u=Z(u,g,!0,!0,-1,this.m_progressTracker,0,!1)}i.tick(ie(u)),r.tock()}else this.putInGridCursors(e,u,o,!0,n,c,a,_,h)}let d=!1;for(let g=0;g<6;g++)if(h[g]!=null){d=!0;break}if(d){let g=!1;const w=[null,null,null,null,null,null];if(e){const b=t.m_densified;if(t.m_densified=null,b!==null){const y=new H;y.scale(1/this.m_rpu,1/this.m_rpu),b.applyTransformation(y),this.m_distance>0?this.putInGridCursors(e,b,o,!1,n,c,a,_,h):(this.processInGrid(e,b,!1,n,c,a,w),g=!0)}}const P=new ee,D=new J().executeMany(P,this.m_gcs,this.m_progressTracker,2);if(r!==null){let b=r.next();i=null,r=null;const y=X(o,b,!0),G=U(y);b=m.unproject(b,G,this.m_progressTracker),this.putInGridCursors(e,b,o,!0,n,c,a,_,h)}for(let b=0;b<6;b++)if(h[b]!=null){let y=h[b].next();h[b]=null,_[b]=null,g&&w[b]!==null&&(y=new be().execute(w[b],y,o,this.m_progressTracker));const G=X(o,y,!0),I=U(G);y=a[b].unproject(y,I,this.m_progressTracker),y=new ye().execute(y,this.m_gcs,!0,this.m_progressTracker),P.tick(ie(y)),D.tock()}f=D.next()}else{let g,w=!1;if(e){let y=t.m_densified;if(t.m_densified=null,y!==null){const G=new H;G.scale(1/this.m_rpu,1/this.m_rpu),y.applyTransformation(G),l.project(y);const I=X(null,y,!0);y=Z(y,I,!1,!0,-1,this.m_progressTracker,0,!1),this.m_distance>0?(i.tick(ie(y)),r.tock()):(g=y,w=!0)}}let P=r.next();i=null,r=null,w&&(P=new be().execute(g,P,o,this.m_progressTracker));const D=X(o,P,!0),b=U(D);f=m.unproject(P,b,this.m_progressTracker),f=new ye().execute(f,this.m_gcs,!0,this.m_progressTracker)}return f=new j().foldInto360RangeGeodetic(f,this.m_gcs,2),f}putInGridCursors(e,s,t,m,o,i,r,n,c){const a=[null,null,null,null,null,null];this.processInGrid(e,s,m,o,i,r,a);for(let _=0;_<6;_++)a[_]!==null&&(n[_]===null&&(n[_]=new ee,c[_]=new J().executeMany(n[_],t,this.m_progressTracker,2)),n[_].tick(ie(a[_])),c[_].tock())}processInGrid(e,s,t,m,o,i,r){const n=this.insertGeodeticPointsAlongGrid(s,o,.01);for(let c=0;c<6;c++){if(m[c])continue;const a=o[c].clone();a.inflateCoords(.01,.01);const _=ae(s,a),h=$(null,_,!1).total();let u=he(n,a,h,Number.NaN,this.m_progressTracker);if(u!==null&&!u.isEmpty()){if(u===n&&(u=u.clone()),i[c]===null){const f=new C;c<3?f.setCoords(0,1):f.setCoords(0,-1);const d=new C;d.setAdd(o[c].getCenter(),f),i[c]=L(this.m_gcs,d)}i[c].project(u);const l=X(null,u,!0);u=Z(u,l,t,!0,-1,this.m_progressTracker,0,!1),r[c]=u}}}insertGeodeticPointsAlongGrid(e,s,t){const m=M.construct(s[3].xmin,s[3].ymin,s[2].xmax,s[2].ymax),o=Qe(this.m_gcs,m,e,!0,this.m_progressTracker),i=new ce,r=i.addGeometry(o);return q(i,r,this.m_gcs,0,2,!0,s[0].xmax+t),q(i,r,this.m_gcs,0,2,!0,s[1].xmax+t),q(i,r,this.m_gcs,0,2,!1,s[1].ymin+t),t!==0&&(q(i,r,this.m_gcs,0,2,!0,s[0].xmax-t),q(i,r,this.m_gcs,0,2,!0,s[1].xmax-t),q(i,r,this.m_gcs,0,2,!1,s[1].ymin-t)),i.getGeometry(r)}initializeGrid(e,s){for(let t=0;t<6;t++)e[t]=!1;s[0].setCoords({xmin:-this.m_gcs180,ymin:0,xmax:-this.m_gcs60,ymax:this.m_gcs90}),s[1].setCoords({xmin:-this.m_gcs60,ymin:0,xmax:this.m_gcs60,ymax:this.m_gcs90}),s[2].setCoords({xmin:this.m_gcs60,ymin:0,xmax:this.m_gcs180,ymax:this.m_gcs90}),s[3].setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:-this.m_gcs60,ymax:0}),s[4].setCoords({xmin:-this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs60,ymax:0}),s[5].setCoords({xmin:this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:0})}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(e,s,t,m,o,i){const r=e[0],n=e.at(-1),c=r.y<n.y?r.y:n.y,a=r.y>n.y?r.y:n.y,_=me.q(this.m_a,this.m_eSquared,c),h=me.q(this.m_a,this.m_eSquared,a);if(this.m_q90-(_+s+this.m_absDistance)>.001&&this.m_q90+(h-s-this.m_absDistance)>.001)return!1;const u=t-F,l=m+F,f=u-Math.PI,d=u+Math.PI,g=l+Math.PI,w=[Number.NaN],P=[Number.NaN],D=[Number.NaN],b=[Number.NaN];let y=!1;if(we(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,r,u,f,n,l,w,P),we(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,n,g,l,r,f,D,b),(l<w[0]&&w[0]<g||l<P[0]&&P[0]<g)&&(y=!0),y||(f<D[0]&&D[0]<u||f<b[0]&&b[0]<u)&&(y=!0),!y&&o)return!1;const G=[];for(let R=e.length-1;R>=0;R--)G.push(e[R]);i.setEmpty(),i.addPathPoint2D(null,0,!0);let I=0;I=le(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,e,u,l,o,I,i),I=V(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,n,l,g,this.m_cornerStep,o,I,i,w[0],P[0]),I=le(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,G,g,d,o,I,i),I=V(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,r,f,u,this.m_cornerStep,o,I,i,D[0],b[0]);let B=!1;return o||(B=this.checkAndPrepForPole(i)),y||B}bufferPoint2D(e,s,t){t.setEmpty(),t.addPathPoint2D(null,0,!0),V(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,e,-this.m_cornerStep,2*Math.PI,this.m_cornerStep,s,0,t);let m=!1;return s||(m=this.checkAndPrepForPole(t)),m}checkAndPrepForPole(e){const s=this.checkAndPrepForPoleTouch(e),t=this.checkAndPrepForPoleWrap(e);return s||t}checkAndPrepForPoleTouch(e){const s=new M;return e.queryEnvelope(s),!(!Y(s.ymax,this.m_gcs90)&&!Y(s.ymin,-this.m_gcs90))&&(this.prepPoleTouch(e),!0)}checkAndPrepForPoleWrap(e){const s=e.getXY(0),t=e.getXY(e.getPointCount()-1);return Math.abs(s.x-t.x)>this.m_gcs180?(this.prepSinglePoleWrap(e),!0):this.checkAndPrepForDoublePoleWrap(e)}checkAndPrepForDoublePoleWrap(e){return e.calculateArea2D()<0&&(this.prepDoublePoleWrap(e),!0)}prepPoleTouch(e){const s=new N;s.insertPath2D(-1,null,0,0,!0);const t=e.getPathStart(0),m=e.getPathEnd(0),o=m-t;let i=-1;for(i=t;i<m;i++){const a=e.getXY(i),_=Y(a.y,this.m_gcs90),h=Y(a.y,-this.m_gcs90);if(!_&&!h)break}let r=i,n=!1,c=Number.NaN;do{const a=e.getXY(r),_=Y(a.y,this.m_gcs90),h=Y(a.y,-this.m_gcs90),u=t+(r+1-t)%o;if(_||h){let l=C.construct(c,a.y);s.insertPoint2D(0,-1,l);const f=e.getXY(u),d=Y(f.y,this.m_gcs90),g=Y(f.y,-this.m_gcs90);d||g||(l=C.construct(f.x,a.y),n?s.setXY(s.getPointCount()-1,l):s.insertPoint2D(0,-1,l)),n=!0}else s.insertPoint2D(0,-1,a),c=a.x,n=!1;r=u}while(r!==i);e.setEmpty(),e.add(s,!1)}prepSinglePoleWrap(e){const s=new N,t=new N,m=new H,o=e.getXY(e.getPathStart(0)),i=e.getXY(e.getPathEnd(0)-1),r=this.m_gcs360,n=this.m_gcs180,c=new M;c.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});const a=new M;e.queryEnvelope(a);const _=Math.ceil(a.width()/r);let h,u;o.x>i.x?(h=-r,u=this.m_gcs90):(h=r,u=-this.m_gcs90),m.setShiftCoords(h,0),s.addPath(e,0,!0),t.add(s,!1);const l=new Pe;for(let z=0;z<_;z++)t.applyTransformation(m),t.getPointByVal(0,l),s.lineToPoint(l),s.addSegmentsFromPath(t,0,0,t.getSegmentCount()-1,!1);const f=s.getXY(0),d=s.getXY(s.getPointCount()-1);f.y=u,d.y=u,s.lineTo(d);const g=new C;for(g.setCoordsPoint2D(d),g.x-=.5*h;Math.abs(g.x-f.x)>n;)s.lineTo(g),g.x-=.5*h;s.lineTo(f);const w=c.getCenterX(),P=new M;s.queryEnvelope(P);let D=0;const b=P.getCenter().x;b-w>n?D=-Math.ceil((b-w-n)/r):w-b>n&&(D=Math.ceil((w-b-n)/r)),D!==0&&(m.setShiftCoords(D*r,0),s.applyTransformation(m));const y=new ce,G=y.addGeometry(s);q(y,G,this.m_gcs,0,2,!0,c.xmin),q(y,G,this.m_gcs,0,2,!0,c.xmax);const I=y.getGeometry(G),B=ae(I,c);B.inflateCoords(0,1);const R=$(null,B,!0).total(),O=he(I,c,R,Number.NaN,this.m_progressTracker);e.setEmpty(),e.add(O,!1)}prepDoublePoleWrap(e){const s=this.m_gcs360,t=this.m_gcs180,m=new M;m.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});const o=m.getCenter().x,i=new M;e.queryPathEnvelope(0,i);let r,n=0,c=i.getCenter().x;if(c-o>t?n=-Math.ceil((c-o-t)/s):o-c>t&&(n=Math.ceil((o-c-t)/s)),n!==0){const u=new H;u.setShiftCoords(n*s,0),e.getImpl().applyTransformationToPath(u,0),e.queryPathEnvelope(0,i),c=i.getCenter().x}const a=new M;m.containsExclusiveEnvelope(i)?(r=!1,a.setCoords({env2D:m})):(r=!0,a.setCoords({env2D:m}),a.xmin-=s,a.xmax+=s);let _=e.createInstance();_.addPathPoint2D(null,0,!0);const h=new C;if(h.setCoords(a.xmin,a.ymin),_.insertPoint2D(0,-1,h),h.setCoords(a.xmin,a.ymax),_.insertPoint2D(0,-1,h),h.setCoords(.5*(a.xmin+a.xmax),a.ymax),_.insertPoint2D(0,-1,h),h.setCoords(a.xmax,a.ymax),_.insertPoint2D(0,-1,h),h.setCoords(a.xmax,a.ymin),_.insertPoint2D(0,-1,h),h.setCoords(.5*(a.xmin+a.xmax),a.ymin),_.insertPoint2D(0,-1,h),r){_.addPath(e,0,!0);const u=new H;c<o?u.setShiftCoords(s,0):u.setShiftCoords(-s,0),e.getImpl().applyTransformationToPath(u,0),_.addPath(e,0,!0);const l=new ce,f=l.addGeometry(_);q(l,f,this.m_gcs,0,2,!0,m.xmin),q(l,f,this.m_gcs,0,2,!0,m.xmax),_=l.getGeometry(f);const d=ae(_,m);d.inflateCoords(0,1);const g=$(null,d,!0).total();_=he(_,m,g,Number.NaN,this.m_progressTracker)}else _.addPath(e,0,!0);e.setEmpty(),e.add(_,!1)}setMinCornerStep(){const e={stack:[],error:void 0,hasError:!1};try{let s=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);s=Math.min(s,.125*this.m_a*Math.PI);const t=new C;t.setCoords(0,10*this.m_rpu);const m=0;let o=45*this.m_rpu;const i=S(e,new k(new x,new x),!1),r=S(e,new k(new x,new x),!1),n=S(e,new k(new x,new x),!1),c=S(e,new k(new x,new x),!1),a=new C,_=new C,h=new C,u=new C;for(v.geodesicCoordinate(this.m_a,this.m_eSquared,t.x,t.y,s,m,i.at(0),i.at(1)),a.setCoords(i.at(0).val,i.at(1).val),v.geodesicCoordinate(this.m_a,this.m_eSquared,t.x,t.y,s,o,r.at(0),r.at(1)),_.setCoords(r.at(0).val,r.at(1).val);;){const d={stack:[],error:void 0,hasError:!1};try{const g=.5*(m+o);v.geodesicCoordinate(this.m_a,this.m_eSquared,t.x,t.y,s,g,n.at(0),n.at(1)),h.setCoords(n.at(0).val,n.at(1).val);const w=S(d,new x,!1),P=S(d,new x,!1);v.geodeticDistance(this.m_a,this.m_eSquared,a.x,a.y,_.x,_.y,w,P,null,2),v.geodeticCoordinate(this.m_a,this.m_eSquared,a.x,a.y,.5*w.val,P.val,c.at(0),c.at(1),2),u.setCoords(c.at(0).val,c.at(1).val);const D=S(d,new x,!1);if(v.geodeticDistance(this.m_a,this.m_eSquared,h.x,h.y,u.x,u.y,D,null,null,2),D.val<=this.m_convergenceOffset)break;o*=.9,v.geodesicCoordinate(this.m_a,this.m_eSquared,t.x,t.y,s,o,r.at(0),r.at(1)),_.setCoords(r.at(0).val,r.at(1).val)}catch(g){d.error=g,d.hasError=!0}finally{E(d)}}const l=o-m,f=2*Math.PI/Math.ceil(2*Math.PI/l);this.m_cornerStep=f}catch(s){e.error=s,e.hasError=!0}finally{E(e)}}setMinSegmentStep(){const e={stack:[],error:void 0,hasError:!1};try{let s=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);s=Math.min(s,.125*this.m_a*Math.PI);const t=new C,m=new C;t.setCoords(0,10*this.m_rpu),m.setCoords(10*this.m_rpu,10*this.m_rpu);const o=S(e,new x,!1),i=S(e,new x,!1),r=S(e,new x,!1);v.geodeticDistance(this.m_a,this.m_eSquared,t.x,t.y,m.x,m.y,r,o,i,this.m_curveType);const n=S(e,new k(new x,new x),!1),c=S(e,new k(new x,new x),!1),a=new C,_=S(e,new x,!1),h=S(e,new k(new x,new x),!1),u=S(e,new k(new x,new x),!1),l=S(e,new k(new x,new x),!1),f=S(e,new k(new x,new x),!1),d=new C,g=new C,w=new C,P=new C,D=0;let b=1;const y=o.val,G=i.val,I=y-.5*Math.PI,B=G+.5*Math.PI,R=r.val;for(v.geodesicCoordinate(this.m_a,this.m_eSquared,t.x,t.y,s,I,h.at(0),h.at(1)),d.setCoords(h.at(0).val,h.at(1).val),v.geodesicCoordinate(this.m_a,this.m_eSquared,m.x,m.y,s,B,u.at(0),u.at(1)),g.setCoords(u.at(0).val,u.at(1).val);;){const z={stack:[],error:void 0,hasError:!1};try{const re=.5*(D+b);v.geodeticCoordinate(this.m_a,this.m_eSquared,t.x,t.y,re*R,y,n.at(0),n.at(1),this.m_curveType),a.setCoords(n.at(0).val,n.at(1).val),v.geodeticDistance(this.m_a,this.m_eSquared,t.x,t.y,a.x,a.y,null,null,_,this.m_curveType);const Te=_.val+.5*Math.PI;v.geodesicCoordinate(this.m_a,this.m_eSquared,a.x,a.y,s,Te,l.at(0),l.at(1)),w.setCoords(l.at(0).val,l.at(1).val);const _e=S(z,new x,!1),fe=S(z,new x,!1);v.geodeticDistance(this.m_a,this.m_eSquared,d.x,d.y,g.x,g.y,_e,fe,null,2),v.geodeticCoordinate(this.m_a,this.m_eSquared,d.x,d.y,.5*_e.val,fe.val,f.at(0),f.at(1),2),P.setCoords(f.at(0).val,f.at(1).val);const de=S(z,new x,!1);if(v.geodeticDistance(this.m_a,this.m_eSquared,w.x,w.y,P.x,P.y,de,null,null,2),de.val<=this.m_convergenceOffset)break;{const K={stack:[],error:void 0,hasError:!1};try{b*=.9,v.geodeticCoordinate(this.m_a,this.m_eSquared,t.x,t.y,b*R,y,c.at(0),c.at(1),this.m_curveType),m.setCoords(c.at(0).val,c.at(1).val);const Q=S(K,new x,!1);v.geodeticDistance(this.m_a,this.m_eSquared,t.x,t.y,m.x,m.y,null,null,Q,this.m_curveType);const ke=Q.val+.5*Math.PI;v.geodesicCoordinate(this.m_a,this.m_eSquared,m.x,m.y,s,ke,u.at(0),u.at(1)),g.setCoords(u.at(0).val,u.at(1).val)}catch(Q){K.error=Q,K.hasError=!0}finally{E(K)}}}catch(re){z.error=re,z.hasError=!0}finally{E(z)}}let O=b*R;O>1e5&&(O=1e5),this.m_segmentStep=O}catch(s){e.error=s,e.hasError=!0}finally{E(e)}}setConvergenceOffset(){let e;e=this.m_absDistance>5e4?100:this.m_absDistance>1e4?10:1,this.m_absDistance/e<500&&(e=this.m_absDistance/500),e<.01&&(e=.01),this.m_convergenceOffset=e}}function ue(p,e,s,t,m,o,i){if(p.isEmpty())return new N({vd:p.getDescription()});let r=p;if(Xe(r)){const d=10*e.getTolerance(0);r=new Je().execute(r,0,d,0,i,12e3)}const n=new it(i);n.m_sr=e,n.m_gcs=e.getGCS(),n.m_transform=Ue(e,n.m_gcs,null);const c=je();n.m_gcs.querySpheroidData(c);const a=new M;r.queryEnvelope(a),n.m_a=c.majorSemiAxis,n.m_eSquared=c.e2,n.m_rpu=n.m_gcs.getUnit().getUnitToBaseFactor(),n.m_gcs90=.5*Math.PI/n.m_rpu,n.m_gcs180=Math.PI/n.m_rpu,n.m_gcs360=2*Math.PI/n.m_rpu,n.m_gcs60=n.m_gcs360/6,n.m_q90=me.q90(n.m_a,n.m_eSquared),n.m_ellipticToGeodesicMaxRatio=.5*n.m_a*Math.PI/n.m_q90;const _=n.m_gcs.getTolerance(0);n.m_radTolerance=_*n.m_rpu,s===4?(n.m_curveType=2,n.m_bShapePreserving=!0):(n.m_curveType=s,n.m_bShapePreserving=!1),n.m_distance=t,n.m_absDistance=Math.abs(t),Number.isNaN(m)||m<=0?n.setConvergenceOffset():n.m_convergenceOffset=Math.max(m,.001),n.m_convergenceOffset/=o;let h,u=r.getGeometryType();if(Ye(u)){const d=new pe({vd:r.getDescription()});d.addSegment(r,!0),h=d,u=T.enumPolyline}else if(u===T.enumEnvelope){const d=r,g=new M;d.queryEnvelope(g);const w=U($(n.m_sr,a,!0));if(g.minDimension()<=w)if(g.maxDimension()===0){const P=new Pe({vd:r.getDescription()});d.getCenter(P),h=P,u=T.enumPoint}else{const P=new pe({vd:r.getDescription()});P.addEnvelope(d,!1),h=P,u=T.enumPolyline}else{const P=new N({vd:r.getDescription()});P.addEnvelope(d,!1),h=P,u=T.enumPolygon}}else h=r;if(n.setMinCornerStep(),Be(u)||n.setMinSegmentStep(),n.m_absDistance<=.5*n.m_convergenceOffset)return u!==T.enumPolygon?new N({vd:h.getDescription()}):n.m_bShapePreserving?h:xe(h,n.m_sr,n.m_curveType,n.m_segmentStep,-1,i);if(n.m_distance<0&&u!==T.enumPolygon)return new N({vd:h.getDescription()});if(n.m_bShapePreserving&&W(u)){const d=xe(h,e,4,Number.NaN,n.m_convergenceOffset,i);h=new j().execute(d,n.m_transform,i)}else h=new j().execute(h,n.m_transform,i);if(h=He(h,n.m_gcs),h.isEmpty())return new N({vd:h.getDescription()});!n.m_bShapePreserving&&W(u)&&(h=Ve(n.m_rpu,h)),h=rt(h,n.m_gcs);let l=new N;switch(u){case T.enumPolygon:l=n.bufferPolygon(h);break;case T.enumPolyline:l=n.bufferPolyline(h);break;case T.enumMultiPoint:l=n.bufferMultiPoint(h);break;case T.enumPoint:l=n.bufferPoint(h);break;default:Fe("")}const f=new j().execute(l,n.m_transform.getInverse(),i);return f.mergeVertexDescription(h.getDescription()),f}function le(p,e,s,t,m,o,i,r,n,c,a){const _={stack:[],error:void 0,hasError:!1};try{const h=new C;h.setNAN(),n||a.getPointCount()>0&&(h.setCoordsPoint2D(a.getXY(a.getPointCount()-1)),h.scale(s));const u=S(_,new x,!1),l=S(_,new k(new x,new x),!1),f=new C,d=new C,g=o.at(-1),w=1/s;for(let P=0;P<o.length;P++){const D=o[P];let b;P===0?b=i:P===o.length-1?b=r:(v.geodeticDistance(p,e,g.x,g.y,D.x,D.y,null,null,u,m),b=u.val-.5*Math.PI),v.geodesicCoordinate(p,e,D.x,D.y,t,b,l.at(0),l.at(1)),n?d.setCoords(l.at(0).val,l.at(1).val):(f.setCoords(l.at(0).val,l.at(1).val),c=ve(D.x,f.x,h.x,c),d.setCoords(c+f.x,f.y),h.setCoordsPoint2D(d)),d.scale(w),a.insertPoint2D(0,-1,d)}return c}catch(h){_.error=h,_.hasError=!0}finally{E(_)}}function V(p,e,s,t,m,o,i,r,n,c,a,_=Number.NaN,h=Number.NaN){const u={stack:[],error:void 0,hasError:!1};try{if(i-o<r)return c;const l=S(u,new k(new x,new x),!1),f=new C,d=new C,g=new C;d.setNAN(),n||a.getPointCount()>0&&(d.setCoordsPoint2D(a.getXY(a.getPointCount()-1)),d.scale(s));let w=Math.ceil(o/r),P=w++*r;P===o&&(P=w++*r);let D=o;const b=1/s;for(;P<i+r&&(D<_&&_<P?(P=_,w--):D<h&&h<P&&(P=h,w--),!(P>=i));)v.geodesicCoordinate(p,e,m.x,m.y,t,P,l.at(0),l.at(1)),n?g.setCoords(l.at(0).val,l.at(1).val):(f.setCoords(l.at(0).val,l.at(1).val),c=ve(m.x,f.x,d.x,c),g.setCoords(c+f.x,f.y),d.setCoordsPoint2D(g)),g.scale(b),a.insertPoint2D(0,-1,g),D=P,P=w++*r;return c}catch(l){u.error=l,u.hasError=!0}finally{E(u)}}function we(p,e,s,t,m,o,i,r,n,c,a){const _={stack:[],error:void 0,hasError:!1};try{const h=new C,u=new C,l=S(_,new k(new x,new x),!1);v.geodesicCoordinate(p,e,m.x,m.y,t,o,l.at(0),l.at(1)),h.setCoords(l.at(0).val,l.at(1).val),v.geodesicCoordinate(p,e,m.x,m.y,t,i,l.at(0),l.at(1)),u.setCoords(l.at(0).val,l.at(1).val);const f=S(_,new x,!1);for(v.geodeticDistance(p,e,r.x,r.y,h.x,h.y,null,f,null,0),c[0]=f.val,v.geodeticDistance(p,e,r.x,r.y,u.x,u.y,null,f,null,0),a[0]=f.val;c[0]<=a[0];)c[0]+=A;for(;c[0]>a[0];)c[0]-=A;for(;c[0]>=n;)c[0]-=A,a[0]-=A;for(;c[0]<n;)c[0]+=A,a[0]+=A}catch(h){_.error=h,_.hasError=!0}finally{E(_)}}function ve(p,e,s,t){if(Number.isNaN(s)){for(;t+e-p>Math.PI;)t-=A;for(;p-(t+e)>Math.PI;)t+=A;return t}return t+e-s>Math.PI?t-=A:s-(t+e)>Math.PI&&(t+=A),t}function rt(p,e){const s=p.getGeometryType();let t;if(t=W(s)?p.getPathCount():s===T.enumMultiPoint?p.getPointCount():1,t===1)return p;const m=[],o=[];for(let r=0;r<t;r++){m.push(r);const n=new C;if(W(s)){const a=new M;p.queryPathEnvelope(r,a),n.assign(a.getCenter())}else n.assign(p.getXY(r));const c=e.toGeohash(n);o.push(c)}m.sort((r,n)=>o[r]<o[n]?-1:o[r]>o[n]?1:0);const i=p.createInstance();for(let r=0;r<t;r++){const n=m[r];W(s)?i.addPath(p,n,!0):i.addPoints(p,n,n+1)}return i}function Se(p,e,s,t,m,o){const i={stack:[],error:void 0,hasError:!1};try{if(t>=o)return!1;const r=s[0],n=s.at(-1),c=S(i,new x,!1),a=S(i,new x,!1),_=S(i,new x,!1);v.greatEllipticDistance(p,e,m.x,m.y,r.x,r.y,c,null,null),v.greatEllipticDistance(p,e,m.x,m.y,n.x,n.y,a,null,null),v.greatEllipticDistance(p,e,r.x,r.y,n.x,n.y,_,null,null);let h=Math.min(c.val,a.val)+_.val,u=h+t;if(u<o)return!0;const l=S(i,new x,!1);h=Math.max(c.val,a.val);for(let f=1;f<s.length-1;f++){const d=s[f];v.greatEllipticDistance(p,e,m.x,m.y,d.x,d.y,l,null,null),l.val>h&&(h=l.val)}return u=h+t,u<o}catch(r){i.error=r,i.hasError=!0}finally{E(i)}}function De(p,e,s,t,m,o,i,r){let n;if(t.length%2==0){const _=t.length>>1,h=t[_],u=t[_-1];n=C.lerp(h,u,.5)}else n=t[t.length-1>>1].clone();const c=n.clone(),a=te(p,e,c,75/180*Math.PI);return!!Se(p,e,t,m,c,a)&&(o!==null&&(o.setCoordsPoint2D(n),o.scale(1/s)),i!==null&&i.setCoordsPoint2D(c),r!==null&&(r[0]=a),!0)}function Ie(p,e,s,t,m,o){const i={stack:[],error:void 0,hasError:!1};try{if(t>=o)return!1;const r=S(i,new x,!1);return v.greatEllipticDistance(p,e,m.x,m.y,s.x,s.y,r,null,null),r.val+t<o}catch(r){i.error=r,i.hasError=!0}finally{E(i)}}function ot(p,e,s,t,m,o,i,r){const n=te(p,e,t,.4166666666666667*Math.PI);return!!Ie(p,e,t,m,t,n)&&(o!==null&&(o.setCoordsPoint2D(t),o.scale(1/s)),i!==null&&i.setCoordsPoint2D(t),r!==null&&(r[0]=n),!0)}function L(p,e){return new tt(p,e)}function ie(p){return Ze(p,0)||et(p,0),p}class Ge{constructor(e){this.m_bRunningInGnomonic=!1,this.m_bNeedsSimplify=!1,this.m_gnomonic=null,this.m_gnomonicCenterRad=new C,this.m_minGnomonicRadius=Number.NaN,this.m_progressTracker=e}isRunningInGnomonic(){return this.m_bRunningInGnomonic}needsSimplify(){return this.m_bNeedsSimplify}getGnomonic(){return this.m_gnomonic}}class Me extends Ge{constructor(e,s,t){super(e.m_progressTracker),this.m_segIter=null,this.m_bNextSegmentCannotJoin=!1,this.m_currentDensifiedDelta=[0],this.m_currentBufferedDelta=0,this.m_lastAzimuth=0,this.m_startAzimuth=[0],this.m_endAzimuth=[0],this.m_numWinds=0,this.m_debugCounter=0,this.m_bufferHelper=new N,this.m_densifiedPoints=[],this.m_bufferer=e,this.m_multiPath=s,this.m_densified=t,this.m_bNeedsSimplify=!0;const m=new M;this.m_multiPath.queryEnvelope(m);const o=m.getCenter(),i=o.clone();i.scale(this.m_bufferer.m_rpu),this.m_gnomonic=L(this.m_bufferer.m_gcs,o),this.m_gnomonicCenterRad=i.clone(),this.m_minGnomonicRadius=te(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,i,75/180*Math.PI)}next(){let e;if(this.m_bNextSegmentCannotJoin)return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),e=this.m_bufferHelper.clone(),e;if(this.m_segIter===null){if(this.m_segIter=this.m_multiPath.getImpl().querySegmentIterator(),!this.m_segIter.nextPath())return null;this.m_densified!==null&&this.m_densified.addPathPoint2D(null,0,!0)}if(!this.m_segIter.hasNextSegment()){if(!this.m_segIter.nextPath())return null;this.m_densified!=null&&this.m_densified.addPathPoint2D(null,0,!0)}let s=null;this.m_currentBufferedDelta=0,this.m_currentDensifiedDelta=[0],this.m_numWinds=0,this.m_lastAzimuth=Number.NaN,this.m_bNextSegmentCannotJoin=!1,this.m_densifiedPoints.length=0;const t=16;let m=0;const o=new C,i=new C;for(;this.m_segIter.hasNextSegment()&&this.m_numWinds<t;){const r=this.m_segIter.nextSegment();if(o.setCoordsPoint2D(r.getStartXY()),i.setCoordsPoint2D(r.getEndXY()),o.scale(this.m_bufferer.m_rpu),i.scale(this.m_bufferer.m_rpu),se(o,i))o.x=i.x;else if(ne(o,i))i.x=o.x;else{let c=-1,a=-1;const _=this.m_segIter.getPathIndex(),h=this.m_multiPath.getPathStart(_),u=this.m_multiPath.getPathEnd(_);if(c=this.m_segIter.getStartPointIndex()-1,a=this.m_segIter.getEndPointIndex()+1,c<h&&(c=this.m_multiPath.isClosedPath(_)?u-1:-1),a>u-1&&(a=this.m_multiPath.isClosedPath(_)?h:-1),c!==-1){const l=this.m_multiPath.getXY(c);l.scale(this.m_bufferer.m_rpu),ne(l,o)&&(o.x=l.x)}if(a!==-1){const l=this.m_multiPath.getXY(a);l.scale(this.m_bufferer.m_rpu),se(i,l)&&(i.x=l.x)}}this.m_densifiedPoints.length=0;const n=Ce(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,o,i,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta);if(m===0)this.m_bRunningInGnomonic=this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=this.tryUpdateGnomonic(this.m_densifiedPoints));else if(this.m_bRunningInGnomonic){if(!this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}}else if(De(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_densifiedPoints,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,null,null,null)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}if(n===0||$e(o,i)?(this.m_bufferHelper.setEmpty(),this.m_bufferer.bufferPoint2D(o,this.m_bRunningInGnomonic,this.m_bufferHelper),this.m_bNextSegmentCannotJoin=!0):(this.m_bufferHelper.setEmpty(),this.m_bNextSegmentCannotJoin=this.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(n,this.m_bufferHelper)),this.m_bNextSegmentCannotJoin){this.m_segIter.previousSegment(),this.m_segIter.hasPreviousSegment()?(this.m_segIter.previousSegment(),this.m_segIter.nextSegment()):this.m_segIter.resetToFirstSegment(),this.m_densified!=null&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0);break}this.m_densified!=null&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0),s===null&&(s=new N,s.addPathPoint2D(null,0,!0)),this.addJoinAndBufferLeftSide(s),m++}if(this.m_currentDensifiedDelta=[0],m>0){const r=this.m_segIter.getStartPointIndex(),n=this.m_segIter.getPathIndex();for(;m>0;){if(this.m_segIter.previousSegment(),o.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),i.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getEndPointIndex())),o.scale(this.m_bufferer.m_rpu),i.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic)if(se(o,i))o.x=i.x;else if(ne(o,i))i.x=o.x;else{let c=-1,a=-1;const _=this.m_segIter.getPathIndex(),h=this.m_multiPath.getPathStart(_),u=this.m_multiPath.getPathEnd(_);if(c=this.m_segIter.getStartPointIndex()-1,a=this.m_segIter.getEndPointIndex()+1,c<h&&(c=this.m_multiPath.isClosedPath(_)?u-1:-1),a>u-1&&(a=this.m_multiPath.isClosedPath(_)?h:-1),c!==-1){const l=this.m_multiPath.getXY(c);l.scale(this.m_bufferer.m_rpu),ne(l,o)&&(o.x=l.x)}if(a!==-1){const l=this.m_multiPath.getXY(a);l.scale(this.m_bufferer.m_rpu),se(i,l)&&(i.x=l.x)}}this.m_densifiedPoints.length=0,Ce(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,i,o,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta),this.addJoinAndBufferLeftSide(s),m--}return o.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),o.scale(this.m_bufferer.m_rpu),this.m_currentBufferedDelta=V(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,o,this.m_lastAzimuth+.5*Math.PI,this.m_lastAzimuth+1.5*Math.PI,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,s),this.m_segIter.resetToVertex(r,n),this.m_segIter.nextSegment(),s}return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),e=this.m_bufferHelper.clone(),e}isSegmentBufferInCurrentGnomonic(e){return this.m_gnomonic!==null&&Se(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(e){const s=new C,t=new C,m=[0];return De(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,s,t,m)?(this.m_gnomonicCenterRad.setCoordsPoint2D(t),this.m_minGnomonicRadius=m[0],this.m_gnomonic=L(this.m_bufferer.m_gcs,s),!0):(this.m_gnomonic=null,!1)}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(e,s){return this.m_bufferer.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(this.m_densifiedPoints,e,this.m_startAzimuth[0],this.m_endAzimuth[0],this.m_bRunningInGnomonic,s)}addJoinAndBufferLeftSide(e){const s=this.m_densifiedPoints[0];let t=Number.NaN,m=this.m_startAzimuth[0]-F;const o=this.m_endAzimuth[0]+F;let i=!1;if(!Number.isNaN(this.m_lastAzimuth)){this.m_lastAzimuth>=this.m_startAzimuth[0]?(t=this.m_lastAzimuth+F,m=t+Math.PI-(this.m_lastAzimuth-this.m_startAzimuth[0])):(t=this.m_lastAzimuth+F,m=t+Math.PI-(A-(this.m_startAzimuth[0]-this.m_lastAzimuth))),i=!(this.m_lastAzimuth>=this.m_startAzimuth[0]&&this.m_lastAzimuth-this.m_startAzimuth[0]<=Math.PI)&&!(this.m_lastAzimuth<this.m_startAzimuth[0]&&this.m_startAzimuth[0]-this.m_lastAzimuth>=Math.PI);let r=!1;if(Math.abs(m-t)<=.5*this.m_bufferer.m_cornerStep&&(i||(r=!0)),r){if(e.removePointFromPath(0,e.getPointCount()-1),!this.m_bRunningInGnomonic){const n=new C;n.setCoordsPoint2D(e.getXY(e.getPointCount()-1)),n.scale(this.m_bufferer.m_rpu),n.x-this.m_currentBufferedDelta<-Math.PI?this.m_currentBufferedDelta-=A:n.x-this.m_currentBufferedDelta>Math.PI&&(this.m_currentBufferedDelta+=A)}m=.5*(m+t)}else if(i){const n=new C;n.setCoordsPoint2D(s),n.scale(1/this.m_bufferer.m_rpu),e.insertPoint2D(0,-1,n)}else V(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_densifiedPoints[0],t,m,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,e)}this.m_startAzimuth[0]!==this.m_lastAzimuth&&this.m_numWinds++,le(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_bufferer.m_curveType,this.m_densifiedPoints,m,o,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,e),this.m_lastAzimuth=this.m_endAzimuth[0]}}class mt extends Ge{constructor(e,s){super(e.m_progressTracker),this.m_pointIndex=-1,this.m_bufferer=e,this.m_multiPoint=s,this.m_bNeedsSimplify=!1;const t=new M;this.m_multiPoint.queryEnvelope(t);const m=t.getCenter(),o=m.clone();o.scale(this.m_bufferer.m_rpu),this.m_gnomonic=L(this.m_bufferer.m_gcs,m),this.m_gnomonicCenterRad=o.clone(),this.m_minGnomonicRadius=te(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,o,75/180*Math.PI)}next(){if(this.m_bNeedsSimplify=!1,++this.m_pointIndex===this.m_multiPoint.getPointCount())return null;const e=this.m_multiPoint.getXY(this.m_pointIndex);e.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic=this.isPointBufferInCurrentGnomonic(e),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=this.tryUpdateGnomonic(e));const s=new N,t=this.m_bufferer.bufferPoint2D(e,this.m_bRunningInGnomonic,s);return this.m_bNeedsSimplify=t,s}isPointBufferInCurrentGnomonic(e){return this.m_gnomonic!==null&&Ie(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(e){const s=new C,t=new C,m=[0];return ot(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,s,t,m)?(this.m_gnomonicCenterRad.setCoordsPoint2D(t),this.m_minGnomonicRadius=m[0],this.m_gnomonic=L(this.m_bufferer.m_gcs,s),!0):(this.m_gnomonic=null,!1)}}class at{getOperatorType(){return 10110}supportsCurves(){return!0}accelerateGeometry(e,s,t){return!1}canAccelerateGeometry(e){return!1}executeMany(e,s,t,m,o,i,r,n){if(r){const c=new Ne(e,s,t,m,o,!1,i,n);return new J().executeMany(c,s,n)}return new Ne(e,s,t,m,o,!1,i,n)}execute(e,s,t,m,o,i,r){const n=new Ae([e]),c=[m],a=this.executeMany(n,s,t,c,o,!1,i,r).next();return a||Ee("geodesic buffer null output"),a}}class Ne extends qe{constructor(e,s,t,m,o,i,r,n){super(),this.m_currentUnionEnvelope2D=new M,this.m_index=-1,this.m_dindex=-1,this.m_progressTracker=n,i&&Re(""),s||oe(""),s.getCoordinateSystemType()===0&&oe(""),this.m_inputGeoms=e,this.m_spatialReference=s,this.m_curveType=t,this.m_distances=m,this.m_convergenceOffset=o,this.m_bOutlineOnly=i,this.m_bUnion=r}next(){let e;for(;e=this.m_inputGeoms.next();)return ge(e),this.m_index=this.m_inputGeoms.getGeometryID(),this.m_dindex+1<this.m_distances.length&&this.m_dindex++,this.geodesicBuffer(e,this.m_distances[this.m_dindex]);return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}geodesicBuffer(e,s){return nt(e,this.m_spatialReference,this.m_curveType,s,this.m_convergenceOffset,this.m_progressTracker)}}export{at as OperatorGeodesicBuffer};
