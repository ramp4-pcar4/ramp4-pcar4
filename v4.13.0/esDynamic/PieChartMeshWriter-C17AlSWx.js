import{s as j,t as b,a as nt,R as De,c as ot,i as Fe,l as Ne,G as Oe,A as Ye}from"./definitions-MCCItX4r.js";import{bh as Wt,i as Ut,s as Be,kO as Ce,gL as Re,bS as y,ao as Ge,dz as We,af as Ht}from"./main-BFDurRCu.js";import{o as A,y as B,r as _t,e as Xt,a as kt}from"./UpdateTracking2D-GEad80KZ.js";import{O as u}from"./enums-wEDHPbCF.js";import{c as Vt,i as Zt,l as Ue}from"./GeometryUtils-B8e3Iwyx.js";import{C as He,q as qt,B as Qt,M as Xe,K as at,L as jt,F as Ve,H as Ze,D as qe,E as Qe}from"./constants-oLcGh8d3.js";import{w as X,e as St,G as bt,a as Pt,n as ct,i as $t}from"./enums-a_LDTPYU.js";import{S as je,Z as Jt,R as Kt,s as te,b as L,O as $e,g as Je,j as Ke,k as ti}from"./CIMSymbolHelper-34UsTwam.js";import{a as ei,c as ii,i as si}from"./libtess-C6mGekL8.js";import{t as ri,e as ni,f as oi,g as ee}from"./Utils-Co3xiu1z.js";import{D as ie}from"./utils-BfXZnjCE.js";import"./earcut-C6NeZYSh.js";import{e as ai}from"./OptimizedGeometry-pzfNw1AT.js";import{a as ci,i as li,s as ui}from"./mat2d-BQA-1WB-.js";import{n as hi}from"./mat2df32-fg3OHsAI.js";import{S as lt}from"./vec2-BnynUbeJ.js";import{r as ut}from"./rasterizingUtils-1wASRzSP.js";let vt=class{static getPlacement(t,e,i,s,r,n){const o=je(i);return o?(e===-1&&t.invertY(),o.execute(t,i,s,r,n)):null}};const pi=()=>Ut.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.meshWriterUtils"),fi=0,di=100;function C(t,e){return[!!t?.minScale&&e.scaleToZoom(t.minScale)||fi,!!t?.maxScale&&e.scaleToZoom(t.maxScale)||di]}function w(t){return 1<<t}function V(t){let e=0;for(const[i,s]of t)s&&(e|=1<<i);return e}function _(t){let e;if(!t)return[0,0,0,0];if(typeof t=="string"){const o=Wt.fromString(t);if(!o)return pi().errorOnce(new Be("mapview:mesh-processing","Unable to parse string into color",{color:t})),[0,0,0,0];e=o.toArray()}else e=t;const[i,s,r,n]=e;return[i*(n/255),s*(n/255),r*(n/255),n]}function se(t){switch(t){case"butt":case X.Butt:return St.BUTT;case"round":case X.Round:return St.ROUND;case"square":case X.Square:return St.SQUARE}}function re(t){switch(t){case"bevel":case bt.Bevel:return Pt.BEVEL;case"miter":case bt.Miter:return Pt.MITER;case"round":case bt.Round:return Pt.ROUND}}function wt(t,e){return Math.round(Math.min(Math.sqrt(t*e),255))}function ht(t,e){return Math.round(t*e)/e}const mi=96/72;let ne=class{static executeEffects(t,e,i,s,r){const n=mi,o=Jt(t);let a=new te(e);for(const c of t){const l=Kt(c);l&&(a=l.execute(a,c,n,i,s,o,r))}return a}static applyEffects(t,e,i){if(!t)return e;const s=Jt(t);let r,n=new te(L.fromJSONCIM(e));for(const c of t){const l=Kt(c);l&&(n=l.execute(n,c,1,null,i,s,!1))}const o=[];let a=null;for(;r=n.next();)o.push(...Ce(r)),a=r.geometryType;return o.length===0||a===null?null:a==="esriGeometryPolygon"?{rings:o}:{paths:o}}},oe=null;function pt(){return oe}async function xi(){oe=await import("./geometryEngineJSON-DUmg2EKv.js").then(t=>t.g)}function ae(t){switch(t){case u.BYTE:case u.UNSIGNED_BYTE:return 1;case u.SHORT:case u.UNSIGNED_SHORT:case u.HALF_FLOAT:return 2;case u.FLOAT:case u.INT:case u.UNSIGNED_INT:return 4}}function yi(t){const e=[],i=[],s=[];for(const r of t){const n=ae(r.type)*r.count;switch(n%2||n%4||4){case 4:e.push(r);continue;case 2:i.push(r);continue;case 1:s.push(r);continue;default:throw new Error("Found unexpected dataType byte count")}}return e.push(...i),e.push(...s),e}let gi=class ze{static fromVertexSpec(e,i){const{attributes:s,optionalAttributes:r}=e;let n,o,a;const c=[];for(const x in s){if(s[x].otherSource)continue;const g=s[x];g.pack==="position"?n={...g,name:x,offset:0}:g.pack==="id"?o={...g,name:x,offset:4}:x==="bitset"?a={...g,name:x,offset:7}:c.push({...g,name:x})}for(const x in r)if(i[x]===!0){const g=r[x];c.push({...g,name:x})}const l=yi(c),h=[];let f=8,m=1;for(const x of l)h.push({...x,offset:f}),f+=ae(x.type)*x.count,x.packAlternating&&(m=Math.max(x.packAlternating.count,m));const p=Uint32Array.BYTES_PER_ELEMENT,d=f%p;return new ze(n,o,a,h,f+(d?p-d:0),m)}constructor(e,i,s,r,n,o){this.position=e,this.id=i,this.bitset=s,this.standardAttributes=r,this.stride=n,this.packVertexCount=o,r.push(s),this._attributes=[e,i,s,...r]}get attributeLayout(){if(!this._attributeLayout){const e=ri(this._attributes),i=this._attributes.map(s=>({name:s.name,count:s.count,offset:s.offset,type:s.type,packPrecisionFactor:s.packPrecisionFactor,normalized:s.normalized??!1}));this._attributeLayout={attributes:i,hash:e,stride:this.stride}}return this._attributeLayout}},_i=class Ie{static fromVertexSpec(e,i){const s=gi.fromVertexSpec(e,i);return new Ie(s)}constructor(e){this._spec=e,this._packed=new Uint8Array(this._spec.stride*this._spec.packVertexCount),this._packedU32View=new Uint32Array(this._packed.buffer),this._dataView=new DataView(this._packed.buffer)}get attributeLayout(){return this._spec.attributeLayout}get stride(){return this._spec.stride}writeVertex(e,i,s,r,n,o){for(let a=0;a<this._spec.packVertexCount;a++){const c=a*this._spec.stride;this._packPosition(s,r,c),this._packId(i,c);const l=this._spec.bitset;if(o){if(l.packTessellation){const h=l.packTessellation(o,n,s,r);this._pack(h,l,c)}for(const h of this._spec.standardAttributes)if(h.packTessellation!=null){const f=h.packTessellation(o,n,s,r);this._pack(f,h,c)}else if(h.packAlternating?.packTessellation){const f=h.packAlternating.packTessellation(o,n,s,r);for(let m=0;m<this._spec.packVertexCount;m++){const p=f[m];this._pack(p,h,m*this._spec.stride)}}}}e.vertexWriteRegion(this._packedU32View)}pack(e,i){for(const s of this._spec.standardAttributes)if(s.pack&&typeof s.pack!="string"){const r=s.pack(e,i);for(let n=0;n<this._spec.packVertexCount;n++)this._pack(r,s,n*this._spec.stride)}else if(s.packAlternating?.pack){const r=s.packAlternating.pack(e,i);for(let n=0;n<this._spec.packVertexCount;n++){const o=r[n];this._pack(o,s,n*this._spec.stride)}}}_packPosition(e,i,s){const{offset:r}=this._spec.position,n=this._spec.position.packPrecisionFactor??1,o=ni(e*n,i*n);this._dataView.setUint32(s+r,o,!0)}_packId(e,i){const s=e*(this._spec.id.packPrecisionFactor??1),r=4278190080&this._dataView.getUint32(i+this._spec.id.offset,!0);this._dataView.setUint32(i+this._spec.id.offset,s|r,!0)}_pack(e,i,s){oi(this._dataView,e,i,s)}};function ki(t){if(!t)return!1;for(const e of t)switch(e.effect.type){case"CIMGeometricEffectBuffer":case"CIMGeometricEffectDonut":case"CIMGeometricEffectOffset":case"CIMGeometricEffectTaperedPolygon":case"CIMGeometricEffectEnclosingPolygon":return!0}return!1}let R=class{constructor(t,e,i,s){this._instanceId=t,this._evaluator=e,this._enabledOptionalAttributes=i,this._viewParams=s,this._evaluator.evaluator=r=>this.vertexSpec.createComputedParams(r)}get _vertexPack(){if(!this._cachedVertexPack){const t=_i.fromVertexSpec(this.vertexSpec,this._enabledOptionalAttributes);this._evaluator.hasDynamicProperties||t.pack(this._evaluator.evaluatedMeshParams,this._viewParams),this._cachedVertexPack=t}return this._cachedVertexPack}get evaluatedMeshParams(){return this._evaluator.evaluatedMeshParams}get hasEffects(){return!!this.evaluatedMeshParams.effects}get effectInfos(){return this._evaluator.inputMeshParams.effects?.effectInfos}get instanceId(){return this._instanceId}get attributeLayout(){return this._vertexPack.attributeLayout}get _preventEffectClipping(){return!1}setReferences(t){this._references=t}getBoundsInfo(){return null}getTileInfo(){return this._viewParams.tileInfo}async loadDependencies(){ki(this.effectInfos)&&await xi()}enqueueRequest(t,e,i){this._evaluator.hasDynamicProperties&&this._evaluator.enqueueRequest(t,e,i)}write(t,e,i,s,r){this.ensurePacked(e,i,s);const n=this.evaluatedMeshParams.effects;if(!n||n.length===0)return void this._write(t,i,void 0,r);const o=this.getEffectCursor(t,i,n);if(!o)return;let a;for(;a=o.next();)a.invertY(),this._write(t,i,a,r)}ensurePacked(t,e,i){if(!this._evaluator.hasDynamicProperties)return;const s=this._evaluator.evaluateMeshParams(t,e,i);this._vertexPack.pack(s,this._viewParams)}hasArcadeDependency(t){return this._evaluator.hasArcadeDependency(t)}_writeVertex(t,e,i,s,r){const n=this.evaluatedMeshParams;this._vertexPack.writeVertex(t,e,i,s,n,r)}getEffectCursor(t,e,i){const s=e.readGeometryForDisplay()?.clone();if(!s)return;const r=L.fromOptimizedCIM(s,e.geometryType),n=pt();r.invertY();const o=t.id||"";return ne.executeEffects(i,r,o,n,this._preventEffectClipping)}},Si=class extends R{};function bi(t){const{sprite:e,isMapAligned:i,colorLocked:s,scaleSymbolsProportionally:r,isStroke:n}=t;let o=0;return i&&(o|=w(A.bitset.isMapAligned)),s&&(o|=w(A.bitset.colorLocked)),e.sdf&&(o|=w(A.bitset.isSDF)),r&&(o|=w(A.bitset.scaleSymbolsProportionally)),n&&(o|=w(A.bitset.isStroke)),o}function Tt(t,e){let i;if(typeof t=="string")i=Re(t+`-seed(${e})`);else{let s=12;i=t^e;do i=107*(i>>8^i)+s|0;while(--s!==0)}return(1+i/(1<<31))/2}function ce(t){return Math.floor(Tt(t,Pi)*vi)}const Pi=53290320,vi=10;function $(t){return t instanceof J?t:typeof t=="object"&&"type"in t?Ei[t.type].hydrate(t):new Z(t)}let J=class{constructor(t){this.inputs=t}encode(){const t=[];for(const e of this.inputs)t.push(...e.encode());return t.push(...this.instructions),t}},Z=class extends J{constructor(t){super([]),this.value=t}simplify(){return this}get instructions(){if(Array.isArray(this.value)){const[t,e,i,s]=this.value;return s!=null?B.vector4.encode([t,e||0,i||0,s]):B.vector3.encode([t,e||0,i||0])}return B.scalar.encode(this.value)}},wi=class Bt extends J{constructor(e,i){super([i]),this._config=e,this._parent=i}static hydrate(e){return new Bt(e,$(e.parent))}simplify(){if(this._config.relativeTranslation||this._config.absoluteScale)return this;const e=this._parent.simplify();if(!(e instanceof Z))return this;const[i,s,r,n]=e.value,o=this._config.translation.from[0],a=this._config.translation.from[1],c=this._config.rotation.from,l=this._config.scale.from;if(o===this._config.translation.to[0]&&a===this._config.translation.to[1]&&c===this._config.rotation.to&&l===this._config.scale.to){const h=r+c,f=n*l,m=Math.sin(r),p=Math.cos(r);return new Z([p*n*o-m*n*a+i,m*n*o+p*n*a+s,h,f])}return new Bt(this._config,e)}get instructions(){return B.animatedTransform.encode(this._config)}},Ti=class Ct extends J{constructor(e,i){super([i]),this._config=e,this._parent=i}static hydrate(e){return new Ct(e,$(e.parent))}simplify(){const e=this._parent.simplify();if(!(e instanceof Z))return this;const[i,s,r,n]=e.value,o=this._config.color.from[0],a=this._config.color.from[1],c=this._config.color.from[2];let l=this._config.color.from[3];const h=this._config.opacity.from;return o===this._config.color.to[0]&&a===this._config.color.to[1]&&c===this._config.color.to[2]&&l===this._config.color.to[3]&&h===this._config.opacity.to?(l*=h,new Z([i*o,s*a,r*c,n*l])):new Ct(this._config,e)}get instructions(){return B.animatedColor.encode(this._config)}},Mi=class Rt extends J{constructor(e,i){super([i]),this._config=e,this._parent=i}static hydrate(e){return new Rt(e,$(e.parent))}simplify(){const e=this._parent.simplify();return e instanceof Z?new Rt(this._config,e):this}get instructions(){return B.animatedShift.encode(this._config)}};const Ei={AnimatedTransform:wi,AnimatedColor:Ti,AnimatedShift:Mi};function Ai(t){return le(t.map(e=>S(e)).map(e=>$(e).simplify()))}function zi(t){const e=[];return e.push(t.transform),e.push(t.fromColor),e.push(t.toColor),e.push(t.colorMix),e.push(t.toOpacity),e.push(t.opacityMix),t?.shift?e.push(t?.shift):e.push([1,1,1,1]),e}function le(t){const e=[],i=[];let s=0;for(const r of t){const n=[...r.encode(),...B.ret.encode()];e.push([s+t.length,0,0,0]),i.push(...n),s+=n.length}return[...e,...i]}async function Mt(t,e){const i=t;let s;if(typeof i=="number"||typeof i=="string"||typeof i=="boolean")s=i;else if(Array.isArray(i))s=await Promise.all(i.map(r=>Mt(r,e)));else if(typeof i=="object")if("valueExpressionInfo"in i){const{valueExpressionInfo:r}=i,{expression:n}=r;s={...i,computed:await e.createComputedField({expression:n})}}else{s={};for(const r in i)s[r]=await Mt(i[r],e)}return s}function S(t,e,i){function s(o){if(!("computed"in o))return o;let a=o.computed.readWithDefault(e,i,[255*o.defaultValue[0],255*o.defaultValue[1],255*o.defaultValue[2],o.defaultValue[3]]);if(typeof a=="string"){const c=Wt.fromString(a);c&&(a=[c.r,c.g,c.b,c.a])}return a}const r=t;let n;if(typeof r=="number"||typeof r=="string"||typeof r=="boolean")n=r;else if(Array.isArray(r))n=r.map(o=>S(o,e,i));else if(typeof r=="object")if("type"in r&&r.type!=null&&r.type==="Process")switch(r.op){case"ArcadeColor":{const o=S(r.value,e,i);K(Array.isArray(o)&&o.length===4),n=[o[0]/255,o[1]/255,o[2]/255,o[3]]}break;case"Transparency":{const o=S(r.value,e,i);K(typeof o=="number"),n=1-o/100}break;case"Divide":case"Multiply":case"Add":{const o=S(r.left,e,i);K(typeof o=="number");const a=S(r.right,e,i);switch(K(typeof a=="number"),r.op){case"Divide":n=o/a;break;case"Multiply":n=o*a;break;case"Add":n=o+a}}break;case"Random":{const o=S(r.seed,e,i),a=S(r.min,e,i),c=S(r.max,e,i),l=e.getObjectId(),h=ce(l||0);n=a+Tt(h,o)*(c-a)}break;case"Cond":{const o=S(r.condition,e,i),a=S(r.ifTrue,e,i),c=S(r.ifFalse,e,i);n=o?a:c}break;case"MatchWinding":{const o=S(r.sign,e,i);let a=S(r.angle,e,i);if(o>0)for(;a<0;)a+=2*Math.PI;else for(;a>0;)a-=2*Math.PI;n=a}}else if("computed"in r)n=s(r);else{n={};for(const o in r)n[o]=S(r[o],e,i)}return n}function*P(t){const e=t;if(Array.isArray(e))for(const i of e)yield*P(i);else if(typeof e=="object")if("type"in e&&e.type!=null&&e.type==="Process")switch(e.op){case"ArcadeColor":case"Transparency":yield*P(e.value);break;case"Divide":case"Multiply":case"Add":yield*P(e.left),yield*P(e.right);break;case"Random":yield*P(e.seed),yield*P(e.min),yield*P(e.max);break;case"Cond":yield*P(e.condition),yield*P(e.ifTrue),yield*P(e.ifFalse);break;case"MatchWinding":yield*P(e.sign),yield*P(e.angle)}else if("computed"in e)yield e.computed;else for(const i in e)yield*P(e[i])}function K(t){if(!t)throw new Error("Assertion failed.")}const Ii={type:u.SHORT,count:2,packPrecisionFactor:j,pack:({scaleInfo:t},{tileInfo:e})=>C(t,e)},Li={type:u.FLOAT,count:4,packPrecisionFactor:1,packTessellation:({value1Position2Value2:t})=>(K(t),t)},Di={type:u.FLOAT,count:4,packPrecisionFactor:1,packTessellation:()=>[0,0,0,1]},Fi={type:u.FLOAT,count:1,packPrecisionFactor:1,pack:()=>0},Ni={type:u.FLOAT,count:1,packPrecisionFactor:1,packTessellation:({lineLength:t})=>t},Oi={type:u.UNSIGNED_SHORT,count:1,packTessellation:({distance:t})=>t},Yi={type:u.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:t,directionY:e})=>[t,e]},Bi={type:u.FLOAT,count:2,packPrecisionFactor:16,packTessellation:({normalX:t,normalY:e})=>[t,e]},Ci={type:u.UNSIGNED_BYTE,count:3,pack:"id"},Ri={type:u.UNSIGNED_BYTE,count:1,pack:bi},Gi={type:u.SHORT,count:2,pack:"position",packPrecisionFactor:1},Wi={marker:{type:u.FLOAT,count:2,packAlternating:{count:4,pack:({texelDimensions:t})=>[[-.5*t[0],-.5*t[1]],[.5*t[0],-.5*t[1]],[-.5*t[0],.5*t[1]],[.5*t[0],.5*t[1]]]}},line:{type:u.FLOAT,count:2,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e},{baseSize:i})=>[t*i/2,e*i/2]},fill:{type:u.FLOAT,count:2,packTessellation:()=>[0,0]}},Ui={marker:{type:u.SHORT,count:2,packPrecisionFactor:1,packAlternating:{count:4,packTessellation:({texXmax:t,texXmin:e,texYmax:i,texYmin:s})=>[[e,s],[t,s],[e,i],[t,i]]}}},Hi={type:u.UNSIGNED_SHORT,count:4,pack:({sprite:t})=>{const{rect:e,width:i,height:s}=t,r=e.x+b,n=e.y+b;return[r+1,n+1,r+i-1,n+s-1]}},Xi={type:u.UNSIGNED_SHORT,count:4,packPrecisionFactor:4,pack:({animations:t,baseSize:e,referenceSize:i})=>[t.dataColumn,t.dataRow,e,i]},Vi={type:u.UNSIGNED_SHORT,count:4,packPrecisionFactor:8,pack:({strokeWidth:t,pixelDimensions:e,baseSize:i,sprite:s,sizeRatio:r})=>{const n=Math.max(i*s.width/s.height,i),o=s.sdfDecodeCoeff*n*r;return[e[0],e[1],t,o]}},Zi={type:u.BYTE,count:1,packTessellation:({angle:t})=>t};function qi(t,e,i,s,r,n,o){zt=0;const a=(s-i)*n,c=r&&r.length,l=c?(r[0]-i)*n:a;let h,f,m,p,d,x=ue(e,i,s,0,l,n,!0);if(x&&x.next!==x.prev){if(c&&(x=Ji(e,i,s,r,x,n)),a>80*n){h=m=e[0+i*n],f=p=e[1+i*n];for(let g=n;g<l;g+=n){const v=e[g+i*n],M=e[g+1+i*n];h=Math.min(h,v),f=Math.min(f,M),m=Math.max(m,v),p=Math.max(p,M)}d=Math.max(m-h,p-f),d=d!==0?1/d:0}et(x,t,n,h,f,d,o,0)}}function ue(t,e,i,s,r,n,o){let a;if(o===ss(t,e,i,s,r,n)>0)for(let c=s;c<r;c+=n)a=he(c+e*n,t[c+e*n],t[c+1+e*n],a);else for(let c=r-n;c>=s;c-=n)a=he(c+e*n,t[c+e*n],t[c+1+e*n],a);return a&&G(a,a.next)&&(it(a),a=a.next),a}function tt(t,e=t){if(!t)return t;let i,s=t;do if(i=!1,s.steiner||!G(s,s.next)&&k(s.prev,s,s.next)!==0)s=s.next;else{if(it(s),s=e=s.prev,s===s.next)break;i=!0}while(i||s!==e);return e}function et(t,e,i,s,r,n,o,a){if(!t)return;!a&&n&&(t=pe(t,s,r,n));let c=t;for(;t.prev!==t.next;){const l=t.prev,h=t.next;if(n?ji(t,s,r,n):Qi(t))e.push(l.index/i+o),e.push(t.index/i+o),e.push(h.index/i+o),it(t),t=h.next,c=h.next;else if((t=h)===c){a?a===1?et(t=ns(t,e,i,o),e,i,s,r,n,o,2):a===2&&os(t,e,i,s,r,n,o):et(tt(t),e,i,s,r,n,o,1);break}}}function Qi(t){const e=t.prev,i=t,s=t.next;if(k(e,i,s)>=0)return!1;let r=t.next.next;const n=r;let o=0;for(;r!==t.prev&&(o===0||r!==n);){if(o++,q(e.x,e.y,i.x,i.y,s.x,s.y,r.x,r.y)&&k(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function ji(t,e,i,s){const r=t.prev,n=t,o=t.next;if(k(r,n,o)>=0)return!1;const a=r.x<n.x?r.x<o.x?r.x:o.x:n.x<o.x?n.x:o.x,c=r.y<n.y?r.y<o.y?r.y:o.y:n.y<o.y?n.y:o.y,l=r.x>n.x?r.x>o.x?r.x:o.x:n.x>o.x?n.x:o.x,h=r.y>n.y?r.y>o.y?r.y:o.y:n.y>o.y?n.y:o.y,f=Et(a,c,e,i,s),m=Et(l,h,e,i,s);let p=t.prevZ,d=t.nextZ;for(;p&&p.z>=f&&d&&d.z<=m;){if(p!==t.prev&&p!==t.next&&q(r.x,r.y,n.x,n.y,o.x,o.y,p.x,p.y)&&k(p.prev,p,p.next)>=0||(p=p.prevZ,d!==t.prev&&d!==t.next&&q(r.x,r.y,n.x,n.y,o.x,o.y,d.x,d.y)&&k(d.prev,d,d.next)>=0))return!1;d=d.nextZ}for(;p&&p.z>=f;){if(p!==t.prev&&p!==t.next&&q(r.x,r.y,n.x,n.y,o.x,o.y,p.x,p.y)&&k(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;d&&d.z<=m;){if(d!==t.prev&&d!==t.next&&q(r.x,r.y,n.x,n.y,o.x,o.y,d.x,d.y)&&k(d.prev,d,d.next)>=0)return!1;d=d.nextZ}return!0}function he(t,e,i,s){const r=Q.create(t,e,i);return s?(r.next=s.next,r.prev=s,s.next.prev=r,s.next=r):(r.prev=r,r.next=r),r}function it(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function $i(t){let e=t,i=t;do(e.x<i.x||e.x===i.x&&e.y<i.y)&&(i=e),e=e.next;while(e!==t);return i}function Ji(t,e,i,s,r,n){const o=new Array;for(let a=0,c=s.length;a<c;a++){const l=ue(t,e,i,s[a]*n,a<c-1?s[a+1]*n:i*n,n,!1);l===l.next&&(l.steiner=!0),o.push($i(l))}o.sort(rs);for(const a of o)r=Ki(a,r);return r}function Ki(t,e){const i=ts(t,e);if(!i)return e;const s=de(i,t);return tt(s,s.next),tt(i,i.next)}function ts(t,e){let i=e;const s=t.x,r=t.y;let n,o=-1/0;do{if(r<=i.y&&r>=i.next.y&&i.next.y!==i.y){const m=i.x+(r-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(m<=s&&m>o){if(o=m,m===s){if(r===i.y)return i;if(r===i.next.y)return i.next}n=i.x<i.next.x?i:i.next}}i=i.next}while(i!==e);if(!n)return null;if(s===o)return n.prev;const a=n,c=n.x,l=n.y;let h,f=1/0;for(i=n.next;i!==a;)s>=i.x&&i.x>=c&&s!==i.x&&q(r<l?s:o,r,c,l,r<l?o:s,r,i.x,i.y)&&(h=Math.abs(r-i.y)/(s-i.x),(h<f||h===f&&i.x>n.x)&&st(i,t)&&(n=i,f=h)),i=i.next;return n}function pe(t,e,i,s){let r;for(;r!==t;r=r.next){if(r=r||t,r.z===null&&(r.z=Et(r.x,r.y,e,i,s)),r.prev.next!==r||r.next.prev!==r)return r.prev.next=r,r.next.prev=r,pe(t,e,i,s);r.prevZ=r.prev,r.nextZ=r.next}return t.prevZ.nextZ=null,t.prevZ=null,es(t)}function es(t){let e,i=1;for(;;){let s,r=t;t=null,e=null;let n=0;for(;r;){n++,s=r;let o=0;for(;o<i&&s;o++)s=s.nextZ;let a=i;for(;o>0||a>0&&s;){let c;o===0?(c=s,s=s.nextZ,a--):a!==0&&s?r.z<=s.z?(c=r,r=r.nextZ,o--):(c=s,s=s.nextZ,a--):(c=r,r=r.nextZ,o--),e?e.nextZ=c:t=c,c.prevZ=e,e=c}r=s}if(e.nextZ=null,i*=2,n<2)return t}}function k(t,e,i){return(e.y-t.y)*(i.x-e.x)-(e.x-t.x)*(i.y-e.y)}function fe(t,e,i,s){return!!(G(t,e)&&G(i,s)||G(t,s)&&G(i,e))||k(t,e,i)>0!=k(t,e,s)>0&&k(i,s,t)>0!=k(i,s,e)>0}function is(t,e){let i=t;do{if(i.index!==t.index&&i.next.index!==t.index&&i.index!==e.index&&i.next.index!==e.index&&fe(i,i.next,t,e))return!0;i=i.next}while(i!==t);return!1}function ss(t,e,i,s,r,n){let o=0;for(let a=s,c=r-n;a<r;a+=n)o+=(t[c+e*n]-t[a+e*n])*(t[a+1+e*n]+t[c+1+e*n]),c=a;return o}function q(t,e,i,s,r,n,o,a){return(r-o)*(e-a)-(t-o)*(n-a)>=0&&(t-o)*(s-a)-(i-o)*(e-a)>=0&&(i-o)*(n-a)-(r-o)*(s-a)>=0}function st(t,e){return k(t.prev,t,t.next)<0?k(t,e,t.next)>=0&&k(t,t.prev,e)>=0:k(t,e,t.prev)<0||k(t,t.next,e)<0}function Et(t,e,i,s,r){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-i)*r)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-s)*r)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function G(t,e){return t.x===e.x&&t.y===e.y}function rs(t,e){return t.x-e.x}function ns(t,e,i,s){let r=t;do{const n=r.prev,o=r.next.next;!G(n,o)&&fe(n,r,r.next,o)&&st(n,o)&&st(o,n)&&(e.push(n.index/i+s),e.push(r.index/i+s),e.push(o.index/i+s),it(r),it(r.next),r=t=o),r=r.next}while(r!==t);return r}function os(t,e,i,s,r,n,o){let a=t;do{let c=a.next.next;for(;c!==a.prev;){if(a.index!==c.index&&as(a,c)){let l=de(a,c);return a=tt(a,a.next),l=tt(l,l.next),et(a,e,i,s,r,n,o,0),void et(l,e,i,s,r,n,o,0)}c=c.next}a=a.next}while(a!==t)}function as(t,e){return t.next.index!==e.index&&t.prev.index!==e.index&&!is(t,e)&&st(t,e)&&st(e,t)&&cs(t,e)}function cs(t,e){let i=t,s=!1;const r=(t.x+e.x)/2,n=(t.y+e.y)/2;do i.y>n!=i.next.y>n&&i.next.y!==i.y&&r<(i.next.x-i.x)*(n-i.y)/(i.next.y-i.y)+i.x&&(s=!s),i=i.next;while(i!==t);return s}function de(t,e){const i=Q.create(t.index,t.x,t.y),s=Q.create(e.index,e.x,e.y),r=t.next,n=e.prev;return t.next=e,e.prev=t,i.next=r,r.prev=i,s.next=i,i.prev=s,n.next=s,s.prev=n,s}class Q{constructor(){this.index=0,this.x=0,this.y=0,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}static create(e,i,s){const r=zt<At.length?At[zt++]:new Q;return r.index=e,r.x=i,r.y=s,r.prev=null,r.next=null,r.z=null,r.prevZ=null,r.nextZ=null,r.steiner=!1,r}}const At=[],ls=8096;let zt=0;for(let t=0;t<ls;t++)At.push(new Q);const us=1e-5,W=new Vt(0,0,0,1,0),It=new Vt(0,0,0,1,0);function me(t,e,i){let s=0;for(let r=1;r<i;r++){const n=t[2*(e+r-1)],o=t[2*(e+r-1)+1];s+=(t[2*(e+r)]-n)*(t[2*(e+r)+1]+o)}return s}function hs(t,e,i,s,r){let n=0;const o=2;for(let a=i;a<s;a+=3){const c=(t[a]-r)*o,l=(t[a+1]-r)*o,h=(t[a+2]-r)*o;n+=Math.abs((e[c]-e[h])*(e[l+1]-e[c+1])-(e[c]-e[l])*(e[h+1]-e[c+1]))}return n}function xe(t,e){const{coords:i,lengths:s}=e,r=0,n=t;let o=0;for(let a=0;a<s.length;){let c=a,l=s[a],h=me(i,o,l);const f=[];for(;++c<s.length;){const x=s[c],g=me(i,o+l,x);if(!(g>0))break;h+=g,f.push(o+l),l+=x}const m=n.length;qi(n,i,o,o+l,f,2,r);const p=hs(n,i,m,n.length,r),d=Math.abs(h);if(Math.abs((p-d)/Math.max(1e-7,d))>us)return n.length=0,!1;a=c,o+=l}return!0}function ps(t){const{coords:e,lengths:i}=t,{buffer:s}=ei(e,i);return s}function fs(t,e,i){let s=0;for(let r=0;r<t.lengths.length;r++){const n=t.lengths[r];for(let o=0;o<n;o++){const a=t.coords[2*(o+s)],c=t.coords[2*(o+s)+1];if(a<e||a>i||c<e||c>i)return!0}s+=n}return!1}function ye(t,e){if(t==null)return null;if(!fs(t,-128,nt+128))return t;W.setPixelMargin(e),W.reset(Zt.Polygon);let i=0;for(let o=0;o<t.lengths.length;o++){const a=t.lengths[o];let c=t.coords[2*(0+i)],l=t.coords[2*(0+i)+1];W.moveTo(c,l);for(let h=1;h<a;h++)c=t.coords[2*(h+i)],l=t.coords[2*(h+i)+1],W.lineTo(c,l);W.close(),i+=a}const s=W.result(!1);if(!s)return null;const r=[],n=[];for(const o of s){let a=0;for(const c of o)n.push(c.x),n.push(c.y),a++;r.push(a)}return new ai(r,n)}function ge(t,e){It.setPixelMargin(e);const i=It,s=-e,r=nt+e;let n=[],o=!1;if(!t.nextPath())return null;let a=t.pathLength(),c=!0;for(;c;){t.seekPathStart();const l=[];if(!t.pathSize)return null;i.reset(Zt.LineString),t.nextPoint();let h=t.x,f=t.y;if(o)i.moveTo(h,f);else{if(h<s||h>r||f<s||f>r){o=!0;continue}l.push({x:h,y:f})}let m=!1;for(;t.nextPoint();)if(h=t.x,f=t.y,o)i.lineTo(h,f);else{if(h<s||h>r||f<s||f>r){m=!0;break}l.push({x:h,y:f})}if(m)o=!0;else{if(o){const p=i.resultWithStarts();if(p)for(const d of p)n.push({...d,pathLength:a})}else n.push({line:l,start:0,pathLength:a});c=t.nextPath(),a=c?t.pathLength():0,o=!1}}return n=n.filter(l=>l.line.length>1),n.length===0?null:n}W.setExtent(nt),It.setExtent(nt);let _e=class{constructor(){this.extrusionOffsetX=0,this.extrusionOffsetY=0,this.normalX=0,this.normalY=0,this.directionX=0,this.directionY=0,this.distance=0,this.pathLength=0,this.distanceOffset=0,this.lineLength=0}};const D={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:u.SHORT,count:2,packPrecisionFactor:j,pack:({scaleInfo:t},{tileInfo:e})=>C(t,e)}},attributes:{id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},bitset:{type:u.UNSIGNED_BYTE,count:1},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>_(t)},offset:{type:u.BYTE,count:2,packPrecisionFactor:16,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e})=>[ht(t,16),ht(e,16)]},normal:{type:u.BYTE,count:2,packPrecisionFactor:16,packTessellation:({normalX:t,normalY:e})=>[ht(t,16),ht(e,16)]},halfWidth:{type:u.HALF_FLOAT,count:1,pack:({width:t})=>y(.5*t)},referenceHalfWidth:{type:u.HALF_FLOAT,count:1,pack:({referenceWidth:t})=>y(.5*t)}}};let ds=class{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0,this.distanceOffset=0}};const ft=65535;let dt=class extends R{constructor(t,e,i,s){super(t,e,i,s),this.vertexSpec=D,this._currentWrite=new ds,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:ft,textured:!1},this._tessParams=new _e,this._initializeTessellator()}writeLineVertices(t,e,i){const s=this._getLines(e);s!=null&&this._writeVertices(t,i,s)}_initializeTessellator(){this._lineTessellator=new ii(this._writeTesselatedVertex.bind(this),this._writeTriangle.bind(this),!0)}_write(t,e,i){const s=i??L.fromFeatureSetReaderCIM(e);s&&this._writeGeometry(t,e,s)}_writeGeometry(t,e,i,s){t.recordStart(this.instanceId,this.attributeLayout,s),this.writeLineVertices(t,i,e),t.recordEnd()}_getLines(t){return ge(t,ee(this.evaluatedMeshParams))}_writeVertices(t,e,i){const{_currentWrite:s,_tessellationOptions:r,evaluatedMeshParams:n}=this,{width:o,capType:a,joinType:c,miterLimit:l,hasSizeVV:h}=n,f=y(.5*o);r.halfWidth=f,r.capType=se(a),r.joinType=re(c),r.miterLimit=l;const m=!h;s.out=t,s.id=e.getDisplayId(),s.vertexCount=0,s.indexCount=0,s.vertexFrom=t.vertexCount(),s.vertexBounds=m&&f<De?0:1;for(const{line:p,start:d,pathLength:x}of i)r.initialDistance=d%ft,s.pathLength=x,s.distanceOffset=Math.floor(d/ft)*ft,this._lineTessellator.tessellate(p,r,m)}_writeTesselatedVertex(t,e,i,s,r,n,o,a,c,l,h){const{out:f,id:m,vertexBounds:p,pathLength:d,distanceOffset:x}=this._currentWrite;return this.hasEffects&&f.recordBounds(t,e,p,p),this._tessParams.extrusionOffsetX=o,this._tessParams.extrusionOffsetY=a,this._tessParams.normalX=c,this._tessParams.normalY=l,this._tessParams.directionX=r,this._tessParams.directionY=n,this._tessParams.distance=h,this._tessParams.pathLength=d,this._tessParams.distanceOffset=x,this._writeVertex(f,m,t,e,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(t,e,i){const{out:s}=this._currentWrite;s.indexEnsureSize(3),s.indexWrite(t),s.indexWrite(e),s.indexWrite(i),this._currentWrite.indexCount+=3}};const ms=100,xs=Ge("featurelayer-fast-triangulation-enabled");let Lt=class extends R{async loadDependencies(){await Promise.all([super.loadDependencies(),si()])}_write(t,e,i){const s=i?.asOptimized()??e.readGeometryForDisplay(),r=this._clip(s);r&&(t.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(t,e,r),t.recordEnd())}_clip(t){if(!t)return null;const e=this.hasEffects;return ye(t,e?256:8)}_writeGeometry(t,e,i){const s=i.maxLength>ms,r=[],n=this.createTesselationParams(e);if(!s&&xs&&xe(r,i))return void(r.length&&this._writeVertices(t,e,i.coords,n,r));const o=ps(i);this._writeVertices(t,e,o,n)}_writeVertices(t,e,i,s,r){const n=e.getDisplayId(),o=t.vertexCount(),a=this.hasEffects;let c=0;if(r)for(const l of r){const h=i[2*l],f=i[2*l+1];a&&t.recordBounds(h,f,0,0),this._writeVertex(t,n,h,f,s),c++}else for(let l=0;l<i.length;l+=2){const h=Math.round(i[l]),f=Math.round(i[l+1]);a&&t.recordBounds(h,f,0,0),this._writeVertex(t,n,h,f,s),c++}t.indexEnsureSize(c);for(let l=0;l<c;l++)t.indexWrite(l+o)}};const ys={createComputedParams:t=>t,optionalAttributes:{},attributes:{id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1},pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},inverseArea:{type:u.FLOAT,count:1,packTessellation:({inverseArea:t})=>t}}};let gs=class extends Lt{constructor(){super(...arguments),this.vertexSpec=ys}createTesselationParams(t){return{inverseArea:1/t.readGeometryArea()}}};const rt={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:u.SHORT,count:2,packPrecisionFactor:j,pack:({scaleInfo:t},{tileInfo:e})=>C(t,e)}},attributes:{id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1},pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>_(t)}}};let Dt=class extends Lt{constructor(){super(...arguments),this.vertexSpec=rt}createTesselationParams(t){return null}};const U={createComputedParams:t=>t,optionalAttributes:rt.optionalAttributes,attributes:{...rt.attributes,tlbr:{count:4,type:u.UNSIGNED_SHORT,pack:({sprite:t})=>{const{rect:e,width:i,height:s}=t,r=e.x+b,n=e.y+b;return[r,n,r+i,n+s]}},inverseRasterizationScale:{count:1,type:u.BYTE,packPrecisionFactor:16,pack:({sprite:t})=>1/t.rasterizationScale}}};let ke=class extends Dt{constructor(){super(...arguments),this.vertexSpec=U}_write(t,e,i){const s=i?.asOptimized()??e.readGeometryForDisplay(),r=this._clip(s);if(!r)return;const n=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(t,e,r),t.recordEnd()}};function mt(t){const{sprite:e,aspectRatio:i,scaleProportionally:s}=t,r=y(t.height),n=r>0?r:e.height;let o=r*i;return o<=0?o=e.width:s&&(o*=e.width/e.height),{width:o,height:n}}function Se(t){const{applyRandomOffset:e,sampleAlphaOnly:i}=t;return V([[He,e],[qt,i]])}const be={createComputedParams:t=>t,optionalAttributes:U.optionalAttributes,attributes:{...U.attributes,bitset:{count:1,type:u.UNSIGNED_BYTE,pack:Se},width:{count:1,type:u.HALF_FLOAT,pack:t=>mt(t).width},height:{count:1,type:u.HALF_FLOAT,pack:t=>mt(t).height},offset:{count:2,type:u.HALF_FLOAT,pack:({offsetX:t,offsetY:e})=>[y(t),-y(e)]},scale:{count:2,type:u.UNSIGNED_BYTE,packPrecisionFactor:16,pack:({scaleX:t,scaleY:e})=>[t,e]},angle:{count:1,type:u.UNSIGNED_BYTE,pack:({angle:t})=>Ue(t)}}};let _s=class extends ke{constructor(){super(...arguments),this.vertexSpec=be}};const Pe={createComputedParams:t=>t,optionalAttributes:D.optionalAttributes,attributes:{...D.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:t=>0},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>_(t)}}},Ft={createComputedParams:t=>t,optionalAttributes:D.optionalAttributes,attributes:{...D.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:t=>V([[Qt,!0],[Xe,t.outlineUsesColorVV]])},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>_(t)}}};let Nt=class extends dt{constructor(){super(...arguments),this.vertexSpec=Ft}},Ot=class extends Dt{constructor(t,e,i,s){super(t,e,i,s),this.vertexSpec=Pe,this._lineMeshWriter=this._createOutlineWriter(t,e,i,s)}_createOutlineWriter(t,e,i,s){return new Nt(t,e,i,s)}_write(t,e){const i=this.evaluatedMeshParams.effects,s=this.evaluatedMeshParams.outlineEffects;if(i?.length||s?.length){if(i?.length){const r=this.getEffectCursor(t,e,i);if(r){let n;for(;n=r?.next();)n.invertY(),this._writeFill(t,e,n)}}else this._writeFill(t,e);if(s?.length){const r=this.getEffectCursor(t,e,s);if(r){let n;for(;n=r?.next();)n.invertY(),this._writeOutline(t,e,n)}}else this._writeOutline(t,e)}else this._writeSimpleOutlineFill(t,e)}_writeSimpleOutlineFill(t,e){const i=e.readGeometryForDisplay(),s=this._clip(i);s&&(this._writeGeometry(t,e,s),this._lineMeshWriter.writeLineVertices(t,L.fromOptimizedCIM(s,"esriGeometryPolyline"),e))}_writeFill(t,e,i){const s=i?.asOptimized()??e.readGeometryForDisplay(),r=this._clip(s);r&&this._writeGeometry(t,e,r)}_writeOutline(t,e,i){const s=i?.asOptimized()??e.readGeometryForDisplay(),r=this._clip(s);r&&this._lineMeshWriter.writeLineVertices(t,L.fromOptimizedCIM(r,"esriGeometryPolyline"),e)}_clip(t){return t?ye(t,ee(this.evaluatedMeshParams)):null}get effectInfos(){return[...this._evaluator.inputMeshParams.effects?.effectInfos??[],...this._evaluator.inputMeshParams.outlineEffects?.effectInfos??[]]}write(t,e,i,s,r){this.ensurePacked(e,i,s),t.recordStart(this.instanceId,this.attributeLayout),this._write(t,i),t.recordEnd()}ensurePacked(t,e,i){super.ensurePacked(t,e,i),this._lineMeshWriter.ensurePacked(t,e,i)}enqueueRequest(t,e,i){super.enqueueRequest(t,e,i),this._lineMeshWriter.enqueueRequest(t,e,i)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}get hasEffects(){return!!this.evaluatedMeshParams.outlineEffects}};const xt=be,ks=Ft,Ss={createComputedParams:t=>t,optionalAttributes:xt.optionalAttributes,attributes:{...xt.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:t=>Se(t)},aux1:{count:1,type:u.HALF_FLOAT,pack:t=>mt(t).width},aux2:{count:1,type:u.HALF_FLOAT,pack:t=>mt(t).height},aux3:{count:2,type:u.HALF_FLOAT,pack:({offsetX:t,offsetY:e})=>[y(t),y(e)]},aux4:{count:2,type:u.UNSIGNED_BYTE,pack:({scaleX:t,scaleY:e})=>[t*at,e*at]}}},bs={createComputedParams:t=>t,optionalAttributes:xt.optionalAttributes,attributes:{...xt.attributes,color:ks.attributes.color,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:t=>V([[Qt,!0]])},aux1:{count:1,type:u.HALF_FLOAT,pack:t=>y(.5*t.width)},aux2:{count:1,type:u.HALF_FLOAT,pack:t=>y(.5*t.referenceWidth)},aux3:{count:2,type:u.HALF_FLOAT,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e})=>[t,e]},aux4:{count:2,type:u.UNSIGNED_BYTE,packTessellation:({normalX:t,normalY:e})=>[t*at+jt,e*at+jt]}}};let Ps=class extends Nt{constructor(){super(...arguments),this.vertexSpec=bs}};class vs extends Ot{constructor(){super(...arguments),this.vertexSpec=Ss}_createOutlineWriter(e,i,s,r){return new Ps(e,i,s,r)}write(e,i,s,r,n){this.ensurePacked(i,s,r);const o=this.evaluatedMeshParams.sprite?.textureBinding;e.recordStart(this.instanceId,this.attributeLayout,o),this._write(e,s),e.recordEnd()}ensurePacked(e,i,s){super.ensurePacked(e,i,s),this._lineMeshWriter.ensurePacked(e,i,s)}enqueueRequest(e,i,s){super.enqueueRequest(e,i,s),this._lineMeshWriter.enqueueRequest(e,i,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const ws=()=>Ut.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.fill.GradientSizeHelper");let Ts=class{constructor(t,e){this._size=t,this._sizeUnits=e,this._relativeSize=null}get relativeSize(){return this._relativeSize??=this.calculateRelativeSize(),this._relativeSize}calculateRelativeSize(){if(this._sizeUnits===ct.Relative){const t=Math.min(this._size/100,1);return[t,t]}return this.calculateRelativeSizeFromAbsolute()}},Yt=class extends Ts{constructor(t,e,i,s){super(e,i),this.rotationMatrix00=1,this.rotationMatrix01=0,this.rotationMatrix10=0,this.rotationMatrix11=1,this.bounds={xmin:1/0,ymin:1/0,xmax:-1/0,ymax:-1/0},this.rotationMatrix00=Math.cos(s),this.rotationMatrix01=-Math.sin(s),this.rotationMatrix10=-this.rotationMatrix01,this.rotationMatrix11=this.rotationMatrix00;const{bounds:r,rotationMatrix00:n,rotationMatrix01:o,rotationMatrix10:a,rotationMatrix11:c}=this;t.forEachVertex((l,h)=>{const f=l*n+h*o,m=l*a+h*c;r.xmin=Math.min(r.xmin,f),r.ymin=Math.min(r.ymin,m),r.xmax=Math.max(r.xmax,f),r.ymax=Math.max(r.ymax,m)}),this.center=[(r.xmin+r.xmax)/2,(r.ymin+r.ymax)/2]}},Ms=class extends Yt{constructor(t,e,i,s){super(t,e,i,s),this.method="linear"}getRelativePosition(t,e){const{rotationMatrix00:i,rotationMatrix01:s,bounds:r}=this,{xmin:n,xmax:o}=r;return[(t*i+e*s-n)/(o-n),0]}calculateRelativeSizeFromAbsolute(){const{_size:t,bounds:e}=this,{xmin:i,xmax:s}=e;return[y(t)/(s-i),0]}};class Es extends Yt{constructor(e,i,s,r){super(e,i,s,r),this.method="rectangular"}getRelativePosition(e,i){const{bounds:s,center:r,rotationMatrix00:n,rotationMatrix01:o,rotationMatrix10:a,rotationMatrix11:c}=this,l=e*a+i*c,h=e*n+i*o-r[0],f=l-r[1];return[h*(2/(s.xmax-s.xmin)),-f*(2/(s.ymax-s.ymin))]}calculateRelativeSizeFromAbsolute(){const{_size:e,bounds:i}=this,{xmin:s,ymin:r,xmax:n,ymax:o}=i;return[y(2*e)/(n-s),y(2*e)/(o-r)]}}class As extends Yt{constructor(e,i,s){super(e,i,s,0),this.method="circular";const{xmin:r,xmax:n,ymin:o,ymax:a}=this.bounds,c=n-r,l=a-o;this.radius=Math.sqrt(c*c+l*l)/2}getRelativePosition(e,i){const{center:s,radius:r}=this;return[(e-s[0])/r,-((i-s[1])/r)]}calculateRelativeSizeFromAbsolute(){const{_size:e}=this;return[y(e)/this.radius,0]}}function zs(t,e){if(t==null)return null;const i=We(e.angle),s=e.gradientSize,r=e.gradientSizeUnits;switch(e.gradientMethod.toLowerCase()){case"linear":return new Ms(t,s,r,i);case"rectangular":return new Es(t,s,r,i);case"circular":return new As(t,s,r);default:return ws().errorOnce(`Gradient fill method "${e.gradientMethod}" currently unsupported.`),null}}const Is={createComputedParams:t=>t,optionalAttributes:rt.optionalAttributes,attributes:{...rt.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:({gradientSizeUnits:t,gradientType:e})=>{let i=0;return t===ct.Absolute&&(i|=w(Xt.isAbsolute)),e.toLowerCase()==="discrete"&&(i|=w(Xt.isDiscrete)),i}},tlbr:{count:4,type:u.UNSIGNED_SHORT,pack:({sprite:t})=>{const{rect:e,width:i,height:s}=t,r=e.x+b+ot,n=e.y+b;return[r,n,r+i-2*ot,n+s]}},relativePosition:{count:2,type:u.HALF_FLOAT,packTessellation:({gradientStats:t},e,i,s)=>t?.getRelativePosition(i,s)??[0,0]},relativeGradientSize:{count:2,type:u.HALF_FLOAT,packTessellation:({gradientStats:t})=>t?.relativeSize??[1,1]},gradientMethod:{count:1,type:u.UNSIGNED_BYTE,pack:({gradientMethod:t})=>{switch(t.toLowerCase()){case"rectangular":return _t.rectangular;case"circular":return _t.circular;default:return _t.linear}}}}};let Ls=class extends Lt{constructor(){super(...arguments),this.vertexSpec=Is}get _preventEffectClipping(){return!0}createTesselationParams(t){return{gradientStats:zs(this._unclippedGeometry,this.evaluatedMeshParams)}}_write(t,e,i){const s=i?.asOptimized()??e.readGeometryForDisplay();this._unclippedGeometry=s;const r=this._clip(s);if(!r)return void(this._unclippedGeometry=null);const n=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(t,e,r),this._unclippedGeometry=null,t.recordEnd()}};const Ds={optionalAttributes:U.optionalAttributes,createComputedParams:t=>t,attributes:{...U.attributes,...Pe.attributes}},Fs={optionalAttributes:U.optionalAttributes,createComputedParams:t=>t,attributes:{...U.attributes,...Ft.attributes}};class Ns extends Nt{constructor(){super(...arguments),this.vertexSpec=Fs}}let Os=class extends Ot{constructor(){super(...arguments),this.vertexSpec=Ds}_createOutlineWriter(t,e,i,s){return new Ns(t,e,i,s)}write(t,e,i,s,r){this.ensurePacked(e,i,s);const n=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._write(t,i),t.recordEnd()}ensurePacked(t,e,i){super.ensurePacked(t,e,i),this._lineMeshWriter.ensurePacked(t,e,i)}enqueueRequest(t,e,i){super.enqueueRequest(t,e,i),this._lineMeshWriter.enqueueRequest(t,e,i)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}};const Ys={createComputedParams:t=>t,optionalAttributes:{},attributes:{pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1},offset:{type:u.BYTE,count:2,packAlternating:{count:4,pack:()=>[[-1,-1],[1,-1],[-1,1],[1,1]]}}}};let Bs=class extends R{constructor(){super(...arguments),this.vertexSpec=Ys}_write(t,e){t.recordStart(this.instanceId,this.attributeLayout);const i=e.getDisplayId();if(e.geometryType==="esriGeometryPoint"){const s=e.readXForDisplay(),r=e.readYForDisplay();this._writeQuad(t,i,s,r)}else e.geometryType==="esriGeometryMultipoint"&&e.readGeometryForDisplay()?.forEachVertex((s,r)=>{s>=0&&s<=512&&r>=0&&r<=512&&this._writeQuad(t,i,s,r)});t.recordEnd()}_writeQuad(t,e,i,s){const r=t.vertexCount();this._writeVertex(t,e,i,s),t.indexWrite(r+0),t.indexWrite(r+1),t.indexWrite(r+2),t.indexWrite(r+1),t.indexWrite(r+3),t.indexWrite(r+2)}};const ve=96;class Cs{constructor(e){const{offsetX:i,offsetY:s,postAngle:r,fontSize:n,haloSize:o,outlineSize:a,scaleFactor:c,transforms:l}=e;if(this.offsetX=i,this.offsetY=s,this.postAngle=r,this.fontSize=Math.min(n,ve),this.haloSize=o??0,this.outlineSize=a??0,this.transforms=l,l&&l.infos.length>1){const h=ie(n,r,!1,i,s,l,!1);this.fontSize=Math.min(h.size,ve);const f=h.size/n;this.haloSize*=f,this.outlineSize*=f,this.postAngle=h.rotation,this.offsetX=h.offsetX,this.offsetY=h.offsetY}c&&(this.fontSize*=c,this.offsetX*=c,this.offsetY*=c)}}const we=28,N=[4,4],yt=[16,4],Rs={topLeft:yt,topRight:yt,bottomLeft:yt,bottomRight:yt},gt=[4,2],T=[4,6],Te={topLeft:gt,topRight:gt,bottomLeft:T,bottomRight:T},Me={topLeft:gt,topRight:T,bottomLeft:gt,bottomRight:T},Gs={topLeft:T,topRight:T,bottomLeft:N,bottomRight:N},Ws={topLeft:N,topRight:N,bottomLeft:T,bottomRight:T},Us={topLeft:T,topRight:N,bottomLeft:T,bottomRight:N},Hs={topLeft:N,topRight:T,bottomLeft:N,bottomRight:T},Xs={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:u.UNSIGNED_SHORT,count:2,packPrecisionFactor:j,packTessellation:({minZoom:t,maxZoom:e})=>[t||0,e||we]},clipAngle:{type:u.UNSIGNED_BYTE,count:1,packTessellation:({clipAngle:t})=>Zs(t||0)},referenceSymbol:{type:u.BYTE,count:4,packPrecisionFactor:1,packTessellation:(t,e)=>{const i=t.isLineLabel||!t.referenceBounds,s=Je(i?"center":e.horizontalAlignment),r=Ke(i?"middle":e.verticalAlignment),{offsetX:n,offsetY:o,size:a}=i?{offsetX:0,offsetY:0,size:0}:t.referenceBounds;return[y(n),-y(o),Math.round(y(a)),s+1<<2|r+1]}},visibility:{type:u.FLOAT,count:1,otherSource:!0}},attributes:{pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1,packTessellation:({isBackground:t,mapAligned:e})=>V([[Ve,t],[Ze,!!e]])},offset:{type:u.SHORT,count:2,packPrecisionFactor:8,packAlternating:{count:4,packTessellation:({offsets:t})=>{const{bottomLeft:e,bottomRight:i,topLeft:s,topRight:r}=t;return[s,r,e,i]}}},textureUV:{type:u.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,packTessellation:({texcoords:t})=>{const{bottomLeft:e,bottomRight:i,topLeft:s,topRight:r}=t;return[s,r,e,i]}}},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,packTessellation:({color:t})=>t},fontAndReferenceSize:{type:u.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({fontSize:t},{referenceSize:e})=>[Math.round(y(t)),Math.round(y(e??t))]},outlineColor:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>_(t)},haloColor:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({haloColor:t})=>_(t)},outlineAndHaloSize:{type:u.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({outlineSize:t,haloSize:e})=>[Math.round(y(t)),Math.round(y(e))]}}};class Vs extends R{constructor(){super(...arguments),this.vertexSpec=Xs,this._textMeshParamsPropsInitialized=!1}ensurePacked(e,i,s){super.ensurePacked(e,i,s),this._textMeshParamsPropsInitialized&&!this._evaluator.hasDynamicProperties||(this._textMeshTransformProps=new Cs(this.evaluatedMeshParams),this._textMeshParamsPropsInitialized=!0)}_write(e,i,s){const r=this._getShaping();if(!r)return;const n=i.getDisplayId();if(this.evaluatedMeshParams.placement!=null)return this._writePlacedTextMarkers(e,i,r,s);if(s?.nextPath())return s.nextPoint(),this._writeGlyphs(e,n,s.x,s.y,r,0);if(i.geometryType==="esriGeometryPolygon"){const c=i.readCentroidForDisplay();if(!c)return;const[l,h]=c.coords;return this._writeGlyphs(e,n,l,h,r,0)}if(i.geometryType==="esriGeometryMultipoint")return void i.readGeometryForDisplay()?.forEachVertex((c,l)=>this._writeGlyphs(e,n,c,l,r,0));const o=i.readXForDisplay(),a=i.readYForDisplay();return this._writeGlyphs(e,n,o,a,r,0)}_writePlacedTextMarkers(e,i,s,r){const n=r??L.fromFeatureSetReaderCIM(i);if(!n)return;const o=-1,a=vt.getPlacement(n,o,this.evaluatedMeshParams.placement,y(1),e.id,pt());if(!a)return;const c=i.getDisplayId();let l=a.next();for(;l!=null;){const h=l.tx,f=-l.ty,m=-l.getAngle();this._writeGlyphs(e,c,h,f,s,m),l=a.next()}}_getShaping(e){const i=this._textMeshTransformProps,s=this.evaluatedMeshParams;if(!s.glyphs?.glyphs.length)return null;const r=y(i.fontSize),n=y(i.offsetX),o=y(i.offsetY),a=Ht(y(s.lineWidth),Ne,Fe),c=Oe*Ht(s.lineHeightRatio,.25,4);return $e(s.glyphs,{scale:r/Ye,angle:i.postAngle,xOffset:n,yOffset:o,horizontalAlignment:s.horizontalAlignment,verticalAlignment:e||s.verticalAlignment,maxLineWidth:a,lineHeight:c,decoration:s.decoration,borderLineSizePx:y(s.boxBorderLineSize),hasBackground:!!s.boxBackgroundColor,useCIMAngleBehavior:s.useCIMAngleBehavior})}_writeGlyphs(e,i,s,r,n,o,a,c,l=!0){const h=this.evaluatedMeshParams,f=this._textMeshTransformProps,m=y(f.fontSize),p=f.haloSize,d=f.outlineSize,x=y(f.offsetX),g=y(f.offsetY),[v,M]=C(h.scaleInfo,this.getTileInfo());o!==0&&n.setRotation(o);const z=n.bounds,I=s+z.x+x,O=r+z.y-g,F=2*(h.minPixelBuffer?h.minPixelBuffer/m:1),E=Math.max(z.width,z.height)*F;n.textBox&&(e.recordStart(this.instanceId,this.attributeLayout,n.glyphs[0].textureBinding),l&&e.recordBounds(I,O,E,E),this._writeTextBox(e,i,s,r,n.textBox,a,c),e.recordEnd());for(const Y of n.glyphs){e.recordStart(this.instanceId,this.attributeLayout,Y.textureBinding),l&&e.recordBounds(I,O,E,E);const{texcoords:H,offsets:Le}=Y;this._writeQuad(e,i,s,r,{texcoords:H,offsets:Le,fontSize:m,haloSize:p,outlineSize:d,color:_(h.color),isBackground:!1,referenceBounds:a,minZoom:v,maxZoom:M,...c}),e.recordEnd()}o!==0&&n.setRotation(-o)}_writeTextBox(e,i,s,r,n,o,a){const c=this.evaluatedMeshParams,{fontSize:l,haloSize:h,outlineSize:f}=this._textMeshTransformProps,{boxBackgroundColor:m,boxBorderLineColor:p}=c,d={isBackground:!0,fontSize:l,haloSize:h,outlineSize:f,referenceBounds:o,...a};m&&(this._writeQuad(e,i,s,r,{texcoords:Rs,offsets:n.main,color:_(m),...d}),p||(this._writeQuad(e,i,s,r,{texcoords:Gs,offsets:n.top,color:_(m),...d}),this._writeQuad(e,i,s,r,{texcoords:Ws,offsets:n.bot,color:_(m),...d}),this._writeQuad(e,i,s,r,{texcoords:Us,offsets:n.left,color:_(m),...d}),this._writeQuad(e,i,s,r,{texcoords:Hs,offsets:n.right,color:_(m),...d}))),p&&(this._writeQuad(e,i,s,r,{texcoords:Te,offsets:n.top,color:_(p),...d}),this._writeQuad(e,i,s,r,{texcoords:Te,offsets:n.bot,color:_(p),...d}),this._writeQuad(e,i,s,r,{texcoords:Me,offsets:n.left,color:_(p),...d}),this._writeQuad(e,i,s,r,{texcoords:Me,offsets:n.right,color:_(p),...d}))}_writeQuad(e,i,s,r,n){const o=e.vertexCount();this._writeVertex(e,i,s,r,n),e.indexWrite(o+0),e.indexWrite(o+1),e.indexWrite(o+2),e.indexWrite(o+1),e.indexWrite(o+3),e.indexWrite(o+2)}}const Zs=t=>Math.round(t*(254/360)),qs={createComputedParams:t=>t,optionalAttributes:D.optionalAttributes,attributes:{...D.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:({gradientMethod:t,gradientSizeUnits:e,gradientType:i})=>V([[kt.isAlongLine,t.toLowerCase()==="alongline"],[kt.isAbsoluteSize,e===ct.Absolute],[kt.isDiscrete,i.toLowerCase()==="discrete"]])},tlbr:{type:u.UNSIGNED_SHORT,count:4,pack:({sprite:t})=>{const{rect:e,width:i,height:s}=t,r=e.x+b+ot,n=e.y+b;return[r,n,r+i-2*ot,n+s]}},accumulatedDistance:{type:u.HALF_FLOAT,count:1,packTessellation:({distance:t,pathLength:e,distanceOffset:i})=>(i+t)/e},gradientSize:{type:u.HALF_FLOAT,count:1,pack:({gradientSize:t,gradientSizeUnits:e})=>e===ct.Relative?t/100:y(t)},totalLength:{type:u.HALF_FLOAT,count:1,packTessellation:({pathLength:t})=>t},segmentDirection:{type:u.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:t,directionY:e})=>[t,e]}}};let Qs=class extends dt{get _preventEffectClipping(){return!0}constructor(t,e,i,s){super(t,e,i,s),this.vertexSpec=qs,this._tessellationOptions.textured=!0}_write(t,e,i){const s=i??L.fromFeatureSetReaderCIM(e);if(!s)return;const{sprite:r}=this.evaluatedMeshParams;this._writeGeometry(t,e,s,r?.textureBinding)}};const js={createComputedParams:t=>t,optionalAttributes:D.optionalAttributes,attributes:{...D.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:({shouldSampleAlphaOnly:t,shouldScaleDash:e,isSDF:i})=>V([[qt,t],[qe,e],[Qe,i]])},tlbr:{type:u.UNSIGNED_SHORT,count:4,pack:({sprite:t})=>{const{rect:e,width:i,height:s}=t,r=e.x+b,n=e.y+b;return[r,n,r+i,n+s]}},accumulatedDistance:{type:u.UNSIGNED_SHORT,count:1,packTessellation:({distance:t})=>t},segmentDirection:{type:u.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:t,directionY:e})=>[t,e]},offsetAlongLine:{type:u.HALF_FLOAT,count:1,pack:({offsetAlongLine:t})=>y(t)},capType:{type:u.UNSIGNED_BYTE,count:1,pack:({capType:t})=>{switch(t){case X.Butt:case"butt":return 0;case X.Square:case"square":return 1;case X.Round:case"round":return 2;default:return 0}}}}};class $s extends dt{constructor(e,i,s,r){super(e,i,s,r),this.vertexSpec=js,this._tessellationOptions.textured=!0}_write(e,i,s){const r=s??L.fromFeatureSetReaderCIM(i);if(!r)return;const{sprite:n}=this.evaluatedMeshParams;this._writeGeometry(e,i,r,n?.textureBinding)}}let Js=class Gt{static from(e){return"width"in e?this.fromSimpleMeshParams(e):this.fromComplexMeshParams(e)}static fromSimpleMeshParams(e){const i=new Gt(e.sprite,e.color,e.outlineColor,e.minPixelBuffer,e.placement,e.scaleInfo,e.effects),{type:s,width:r,height:n,angle:o,alignment:a,outlineSize:c,referenceSize:l,sprite:h,overrideOutlineColor:f}=e;return i.rawWidth=y(r),i.rawHeight=y(n),i.angle=o,i.alignment=a,i.outlineSize=y(c),i.referenceSize=y(l),i.overrideOutlineColor=f,i.offsetX=y(e.offsetX),i.offsetY=y(e.offsetY),s!=="simple"||h.sdf||(i.rawWidth=h.width,i.rawHeight=h.height),i._computeSize(e,!1),i}static fromComplexMeshParams(e){const i=new Gt(e.sprite,e.color,e.outlineColor,e.minPixelBuffer,e.placement,e.scaleInfo,e.effects);let{alignment:s,transforms:r,size:n,scaleX:o,anchorX:a,anchorY:c,angle:l,colorLocked:h,frameHeight:f,widthRatio:m,offsetX:p,offsetY:d,outlineSize:x,referenceSize:g,scaleFactor:v,sizeRatio:M,isAbsoluteAnchorPoint:z,rotateClockwise:I,scaleSymbolsProportionally:O,sprite:F}=e;if(r&&r.infos.length>0){const H=ie(n,l,I,p,d,r);n=H.size,l=H.rotation,p=H.offsetX,d=H.offsetY,I=!1}v&&(n*=v,p*=v,d*=v);const E=o*(F.width/F.height);i.alignment=s,i.rawHeight=y(n),i.rawWidth=i.rawHeight*E,i.referenceSize=y(g),i.sizeRatio=M,i.sdfDecodeCoeff=(F.sdfDecodeCoeff??1)*M,i.angle=l,i.rotateClockwise=I,i.anchorX=a,i.anchorY=c,i.offsetX=y(p),i.offsetY=y(d),z&&n&&(F.sdf?i.anchorX=a/(n*m):i.anchorX=a/(n*E),i.anchorY=c/n);const Y=O&&f?n/f:1;return i.outlineSize=x===0||isNaN(x)?0:y(x)*Y,i.scaleSymbolsProportionally=O,i.colorLocked=h,i._computeSize(e,!0),i}constructor(e,i,s,r,n,o,a){this.sprite=e,this.color=i,this.outlineColor=s,this.minPixelBuffer=r,this.placement=n,this.scaleInfo=o,this.effects=a,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.sdfDecodeCoeff=1,this.alignment=$t.SCREEN,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize(e,i){const{sprite:s,hasSizeVV:r}=e,n=!!s.sdf,o=s.sdfPaddingRatio??.5,{rawWidth:a,rawHeight:c,sizeRatio:l,outlineSize:h}=this,f=s.rect;let m=a*l,p=c*l,d=0,x=0;if(n){const I=1/(1-o);if(m*=I,p*=I,r)this.computedWidth=m,this.computedHeight=p;else{const O=i&&a>c?m:a,F=c,E=h+2;this.computedWidth=Math.min(O+E,m),this.computedHeight=Math.min(F+E,p);const Y=Math.max(s.width,s.height)/Math.max(m,p);d=(this.computedWidth-m)*Y,x=(this.computedHeight-p)*Y}}else this.computedWidth=m*(f.width/s.width),this.computedHeight=p*(f.height/s.height),d=2*b,x=2*b;const g=f.x+b-d/2,v=f.y+b-x/2,M=g+s.width+d,z=v+s.height+x;this.texXmin=Ee(g),this.texYmin=Ee(v),this.texXmax=Ae(M),this.texYmax=Ae(z),this.computedWidth*=(this.texXmax-this.texXmin)/(M-g),this.computedHeight*=(this.texYmax-this.texYmin)/(z-v),this.anchorX*=m/this.computedWidth,this.anchorY*=p/this.computedHeight}};function Ee(t,e=1e-7){const i=Math.ceil(t);return i-t<e?i:Math.floor(t)}function Ae(t,e=1e-7){const i=Math.floor(t);return t-i<e?i:Math.ceil(t)}const Ks=3.14159265359/180,tr=128/Math.PI;function er(t,e){return t%=e,Math.abs(t>=0?t:t+e)}function ir(t){return er(t*tr,256)}function sr(t,e,i,s,r=!1){const n=hi(),o=r?1:-1;return ci(n),(e||i)&&li(n,n,[e,-i]),s&&ui(n,n,o*Ks*-s),n}const rr={createComputedParams:t=>Js.from(t),optionalAttributes:{zoomRange:{type:u.SHORT,count:2,packPrecisionFactor:j,pack:({scaleInfo:t},{tileInfo:e})=>C(t,e)}},attributes:{pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1,pack:({sprite:t,alignment:e,scaleSymbolsProportionally:i,overrideOutlineColor:s,colorLocked:r})=>{let n=0;return t.sdf&&(n|=w(A.bitset.isSDF)),e===$t.MAP&&(n|=w(A.bitset.isMapAligned)),i&&(n|=w(A.bitset.scaleSymbolsProportionally)),s&&(n|=w(A.bitset.overrideOutlineColor)),r&&(n|=w(A.bitset.colorLocked)),n}},offset:{type:u.HALF_FLOAT,count:2,packAlternating:{count:4,pack:({angle:t,computedWidth:e,computedHeight:i,anchorX:s,anchorY:r,offsetX:n,offsetY:o,rotateClockwise:a})=>{const c=sr(0,n,o,-t,a),l=-(.5+s)*e,h=-(.5-r)*i,f=[l,h],m=[l+e,h],p=[l,h+i],d=[l+e,h+i];return lt(f,f,c),lt(m,m,c),lt(p,p,c),lt(d,d,c),[f,m,p,d]}}},textureUV:{type:u.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({texXmax:t,texXmin:e,texYmax:i,texYmin:s})=>[[e,s],[t,s],[e,i],[t,i]]}},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>_(t)},outlineColor:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>_(t)},sizing:{type:u.UNSIGNED_BYTE,count:4,pack:({rawWidth:t,rawHeight:e,outlineSize:i,referenceSize:s})=>{const r=Math.max(t,e);return[wt(r,128),wt(i,128),wt(s,128),0]}},placementAngle:{type:u.UNSIGNED_BYTE,count:1,packTessellation:({placementAngle:t})=>ir(t)},sdfDecodeCoeff:{type:u.UNSIGNED_SHORT,count:1,packPrecisionFactor:64,pack:({sdfDecodeCoeff:t})=>t}}};class nr extends R{constructor(){super(...arguments),this.vertexSpec=rr}getBoundsInfo(){return this.evaluatedMeshParams.boundsInfo}_write(e,i,s){const r=this.evaluatedMeshParams.sprite?.textureBinding,n=i.getDisplayId();e.recordStart(this.instanceId,this.attributeLayout,r);const o=this.evaluatedMeshParams.minPixelBuffer,a=Math.max(this.evaluatedMeshParams.computedWidth,o),c=Math.max(this.evaluatedMeshParams.computedHeight,o),l=-this.evaluatedMeshParams.anchorX*this.evaluatedMeshParams.computedWidth,h=this.evaluatedMeshParams.anchorY*this.evaluatedMeshParams.computedHeight,f=this.evaluatedMeshParams.offsetX+l,m=-this.evaluatedMeshParams.offsetY+h;if(this.evaluatedMeshParams.placement!=null){let p=null;if(s!=null){const d=Math.max(this.evaluatedMeshParams.computedWidth,this.evaluatedMeshParams.computedHeight);if(p=ti(s,2*d,!1),p===null)return}this._writePlacedMarkers(e,i,p,a,c)}else if(s?.nextPath()){s.nextPoint();const p=s.x,d=s.y;e.recordBounds(p+f,d+m,a,c),this._writeQuad(e,n,p,d)}else if(i.geometryType==="esriGeometryPolygon"){const p=i.readCentroidForDisplay();if(!p)return;const[d,x]=p.coords;e.recordBounds(d+f,x+m,a,c),this._writeQuad(e,n,d,x)}else if(i.geometryType==="esriGeometryPoint"){const p=i.readXForDisplay(),d=i.readYForDisplay();e.recordBounds(p+f,d+m,a,c),this._writeQuad(e,n,p,d)}else i.readGeometryForDisplay()?.forEachVertex((p,d)=>{e.recordBounds(p+f,d+m,a,c),Math.abs(p)>ut||Math.abs(d)>ut||this._writeQuad(e,n,p,d)});e.recordEnd()}_writePlacedMarkers(e,i,s,r,n){const o=s??L.fromFeatureSetReaderCIM(i);if(!o)return;const a=-1,c=vt.getPlacement(o,a,this.evaluatedMeshParams.placement,y(1),e.id,pt());if(!c)return;const l=i.getDisplayId();let h=c.next();const f=this.evaluatedMeshParams.offsetX,m=-this.evaluatedMeshParams.offsetY;for(;h!=null;){const p=h.tx,d=-h.ty;if(Math.abs(p)>ut||Math.abs(d)>ut){h=c.next();continue}const x=-h.getAngle();e.recordBounds(p+f,d+m,r,n),this._writeQuad(e,l,p,d,x),h=c.next()}}_writeQuad(e,i,s,r,n){const o=e.vertexCount(),a=n==null?null:{placementAngle:n};this._writeVertex(e,i,s,r,a),e.indexWrite(o+0),e.indexWrite(o+1),e.indexWrite(o+2),e.indexWrite(o+1),e.indexWrite(o+3),e.indexWrite(o+2)}}const or={createComputedParams:t=>t,optionalAttributes:{},attributes:{pos:{type:u.SHORT,count:2,packPrecisionFactor:10,pack:"position"},id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1,pack:t=>0},offset:{type:u.SHORT,count:2,packPrecisionFactor:16,packAlternating:{count:4,pack:({size:t})=>{const e=y(t),i=-e/2,s=-e/2;return[[i,s],[i+e,s],[i,s+e],[i+e,s+e]]}}},texCoords:{type:u.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:()=>[[0,1],[1,1],[0,0],[1,0]]}},size:{type:u.UNSIGNED_BYTE,count:2,pack:({size:t})=>[t,t]},referenceSize:{type:u.UNSIGNED_BYTE,count:1,pack:({size:t})=>y(t)},zoomRange:{type:u.UNSIGNED_BYTE,count:2,pack:({scaleInfo:t},{tileInfo:e})=>C(t,e)}}};class ar extends R{constructor(){super(...arguments),this.vertexSpec=or}_write(e,i){const s=i.getDisplayId(),r=this.evaluatedMeshParams.minPixelBuffer,n=Math.max(y(this.evaluatedMeshParams.size),r);let o,a;if(i.geometryType==="esriGeometryPoint")o=i.readXForDisplay(),a=i.readYForDisplay();else{const l=i.readCentroidForDisplay();if(!l)return;o=l?.coords[0],a=l?.coords[1]}e.recordStart(this.instanceId,this.attributeLayout),e.recordBounds(o,a,n,n);const c=e.vertexCount();this._writeVertex(e,s,o,a),e.indexWrite(c+0),e.indexWrite(c+1),e.indexWrite(c+2),e.indexWrite(c+1),e.indexWrite(c+3),e.indexWrite(c+2),e.recordEnd()}}export{Vs as A,ce as B,S as C,$ as D,le as E,Gi as F,P as G,Bs as H,Qs as I,$s as J,dt as K,ar as L,nr as M,Zi as N,Ui as O,we as P,vs as Q,Os as R,Hi as S,Bi as T,Ot as U,Ls as V,ke as W,_s as X,gs as Y,Dt as Z,ne as _,Ii as a,vt as b,_e as c,Xi as d,Tt as e,Wi as f,ge as g,se as h,re as i,xe as j,Oi as k,Ni as l,Ci as m,C as n,Si as o,Di as p,_ as q,Fi as r,Li as s,pt as t,Yi as u,zi as v,Mt as w,Vi as x,Ri as y,Ai as z};
