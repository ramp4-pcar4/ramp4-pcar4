import{bl as O,b_ as _,a0 as k,bw as E,aZ as G,T as H,ct as j,al as z,d_ as F,i as K,am as J,a3 as Q,s as V}from"./main-BFDurRCu.js";import{r as A,i as R,o as S,s as U}from"./normalizeUtilsCommon-ClagynAA.js";import{f as Y}from"./utils-BO8hgPs3.js";import{r as $,o as tt}from"./utils-DpLVEUvg.js";async function et(t,s,a,n){const e=Y(t),i=s[0].spatialReference,r={...n,responseType:"json",query:{...e.query,f:"json",sr:_(i),target:JSON.stringify({geometryType:O(s[0]),geometries:s}),cutter:JSON.stringify(a)}},o=await k(e.path+"/cut",r),{cutIndexes:l,geometries:f=[]}=o.data;return{cutIndexes:l,geometries:f.map(u=>{const m=E(u);return m.spatialReference=i,m})}}async function st(t,s,a){const n=typeof t=="string"?G(t):t,e=s[0].spatialReference,i=O(s[0]),r={...a,query:{...n.query,f:"json",sr:_(e),geometries:JSON.stringify($(s))}},{data:o}=await k(n.path+"/simplify",r);return tt(o.geometries,i,e)}const X=()=>K.getLogger("esri.geometry.support.normalizeUtils");function nt(t){return t.type==="polygon"}function ot(t){return t[0].type==="polygon"}function rt(t){return t[0].type==="polyline"}function C(t){const s=[];let a=0,n=0;for(let e=0;e<t.length;e++){const i=t[e];let r=null;for(let o=0;o<i.length;o++)r=i[o],s.push(r),o===0?(a=r[0],n=a):(a=Math.min(a,r[0]),n=Math.max(n,r[0]));r&&s.push([(a+n)/2,0])}return s}function D(t,s){if(!(t instanceof z||t instanceof J)){const e="straightLineDensify: the input geometry is neither polyline nor polygon";throw X().error(e),new V("internal:geometry",e)}const a=S(t),n=[];for(const e of a){const i=[];n.push(i),i.push([e[0][0],e[0][1]]);for(let r=0;r<e.length-1;r++){const o=e[r][0],l=e[r][1],f=e[r+1][0],u=e[r+1][1],m=Math.sqrt((f-o)*(f-o)+(u-l)*(u-l)),p=(u-l)/m,d=(f-o)/m,g=m/s;if(g>1){for(let N=1;N<=g-1;N++){const v=N*s,c=d*v+o,h=p*v+l;i.push([c,h])}const w=(m+Math.floor(g-1)*s)/2,P=d*w+o,T=p*w+l;i.push([P,T])}i.push([f,u])}}return nt(t)?new J({rings:n,spatialReference:t.spatialReference}):new z({paths:n,spatialReference:t.spatialReference})}function W(t,s,a){if(s){const n=D(t,1e6);t=Q(n,!0)}return a&&(t=U(t,a)),t}function Z(t,s,a){if(Array.isArray(t)){const n=t[0];if(n>s){const e=R(n,s);t[0]=n+e*(-2*s)}else if(n<a){const e=R(n,a);t[0]=n+e*(-2*a)}}else{const n=t.x;if(n>s){const e=R(n,s);t=t.clone().offset(e*(-2*s),0)}else if(n<a){const e=R(n,a);t=t.clone().offset(e*(-2*a),0)}}return t}function it(t,s){let a=-1;for(let n=0;n<s.cutIndexes.length;n++){const e=s.cutIndexes[n],i=s.geometries[n],r=S(i);for(let o=0;o<r.length;o++){const l=r[o];l.some(f=>{if(f[0]<180)return!0;{let u=0;for(let p=0;p<l.length;p++){const d=l[p][0];u=d>u?d:u}u=Number(u.toFixed(9));const m=-360*R(u,180);for(let p=0;p<l.length;p++){const d=i.getPoint(o,p);i.setPoint(o,p,d.clone().offset(m,0))}return!0}})}if(e===a){if(ot(t))for(const o of S(i))t[e]=t[e].addRing(o);else if(rt(t))for(const o of S(i))t[e]=t[e].addPath(o)}else a=e,t[e]=i}return t}async function B(t,s,a){if(!Array.isArray(t))return B([t],s);s&&typeof s!="string"&&X().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const n=typeof s=="string"?s:s?.url??H.geometryServiceUrl;let e,i,r,o,l,f,u,m,p=0;const d=[],g=[];for(const c of t)if(c!=null)if(e||(e=c.spatialReference,i=j(e),r=e.isWebMercator,f=r?102100:4326,o=A[f].maxX,l=A[f].minX,u=A[f].plus180Line,m=A[f].minus180Line),i)if(c.type==="mesh")g.push(c);else if(c.type==="point")g.push(Z(c.clone(),o,l));else if(c.type==="multipoint"){const h=c.clone();h.points=h.points.map(x=>Z(x,o,l)),g.push(h)}else if(c.type==="extent"){const h=c.clone()._normalize(!1,!1,i);g.push(h.rings?new J(h):h)}else if(c.extent){const h=c.extent,x=R(h.xmin,l)*(2*o);let M=x===0?c.clone():U(c.clone(),x);h.offset(x,0);let{xmin:b,xmax:y}=h;b=Number(b.toFixed(9)),y=Number(y.toFixed(9)),h.intersects(u)&&y!==o?(p=y>p?y:p,M=W(M,r),d.push(M),g.push("cut")):h.intersects(m)&&b!==l?(p=y*(2*o)>p?y*(2*o):p,M=W(M,r,360),d.push(M),g.push("cut")):g.push(M)}else g.push(c.clone());else g.push(c);else g.push(c);let w=R(p,o),P=-90;const T=w,N=new z;for(;w>0;){const c=360*w-180;N.addPath([[c,P],[c,-1*P]]),P*=-1,w--}if(d.length>0&&T>0){const c=it(d,await et(n,d,N,a)),h=[],x=[];for(let y=0;y<g.length;y++){const q=g[y];if(q!=="cut")x.push(q);else{const L=c.shift(),I=t[y];I!=null&&I.type==="polygon"&&I.rings&&I.rings.length>1&&L.rings.length>=I.rings.length?(h.push(L),x.push("simplify")):x.push(r?F(L):L)}}if(!h.length)return x;const M=await st(n,h,a),b=[];for(let y=0;y<x.length;y++){const q=x[y];q!=="simplify"?b.push(q):b.push(r?F(M.shift()):M.shift())}return b}const v=[];for(let c=0;c<g.length;c++){const h=g[c];if(h!=="cut")v.push(h);else{const x=d.shift();v.push(r===!0?F(x):x)}}return v}function at(t){if(!t)return null;const s=t.extent;if(!s)return null;const a=t.spatialReference&&j(t.spatialReference);if(!a)return s;const[n,e]=a.valid,i=2*e,{width:r}=s;let o,{xmin:l,xmax:f}=s;if([l,f]=[f,l],t.type==="extent"||r===0||r<=e||r>i||l<n||f>e)return s;switch(t.type){case"polygon":if(!(t.rings.length>1))return s;o=C(t.rings);break;case"polyline":if(!(t.paths.length>1))return s;o=C(t.paths);break;case"multipoint":o=t.points}const u=s.clone();for(let m=0;m<o.length;m++){let p=o[m][0];p<0?(p+=e,f=Math.max(p,f)):(p-=e,l=Math.min(p,l))}return u.xmin=l,u.xmax=f,u.width<r?(u.xmin-=e,u.xmax-=e,u):s}function lt(t,s,a){const n=j(a);if(n==null)return t;const[e,i]=n.valid,r=2*i;let o=0,l=0;s>i?o=Math.ceil(Math.abs(s-i)/r):s<e&&(o=-Math.ceil(Math.abs(s-e)/r)),t>i?l=Math.ceil(Math.abs(t-i)/r):t<e&&(l=-Math.ceil(Math.abs(t-e)/r));let f=t+(o-l)*r;const u=f-s;return u>i?f-=r:u<e&&(f+=r),f}function ct(t,s){const a=j(s);if(a){const[n,e]=a.valid,i=e-n;if(t<n)for(;t<n;)t+=i;if(t>e)for(;t>e;)t-=i}return t}export{ct as L,D as M,lt as P,B as R,at as v};
