import { r as r$1, t, eZ as D, f4 as d, eP as r, eQ as M$1, eR as t$1, eT as h, f5 as b, ax as i, f6 as b$1, eM as e, bL as r$3, eq as o } from './main-5658cd6e.js';
import { r as r$2 } from './Container-1d8ffe9c.js';
import { M, P as P$1, U, G as G$1, D as D$1 } from './enums-1f7f0b0a.js';
import { E } from './Texture-aefe232f.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
class l{constructor(e,t,l){this.pixelBlock=e,this.extent=t,this.originalPixelBlock=l;}get width(){return r$1(this.pixelBlock)?this.pixelBlock.width:0}get height(){return r$1(this.pixelBlock)?this.pixelBlock.height:0}render(e){const l=this.pixelBlock;if(t(l))return;const i=this.filter({extent:this.extent,pixelBlock:this.originalPixelBlock??l});if(t(i.pixelBlock))return;i.pixelBlock.maskIsAlpha&&(i.pixelBlock.premultiplyAlpha=!0);const o=i.pixelBlock.getAsRGBA(),s=e.createImageData(i.pixelBlock.width,i.pixelBlock.height);s.data.set(o),e.putImageData(s,0,0);}getRenderedRasterPixels(){const e=this.filter({extent:this.extent,pixelBlock:this.pixelBlock});return t(e.pixelBlock)?null:(e.pixelBlock.maskIsAlpha&&(e.pixelBlock.premultiplyAlpha=!0),{width:e.pixelBlock.width,height:e.pixelBlock.height,renderedRasterPixels:new Uint8Array(e.pixelBlock.getAsRGBA().buffer)})}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
function T(t){return t&&"render"in t}function S(t){const e=document.createElement("canvas");return e.width=t.width,e.height=t.height,t.render(e.getContext("2d")),e}function v(t){return T(t)?t instanceof l?o(t.getRenderedRasterPixels(),(t=>t.renderedRasterPixels)):S(t):t}class R extends r$2{constructor(t=null,e){super(),this.blendFunction="standard",this._sourceWidth=0,this._sourceHeight=0,this._textureInvalidated=!1,this._texture=null,this.stencilRef=0,this.coordScale=[1,1],this._height=void 0,this.pixelRatio=1,this.resolution=0,this.rotation=0,this._source=null,this._width=void 0,this.x=0,this.y=0,this.immutable=e.immutable??!1,this.requestRenderOnSourceChangedEnabled=e.requestRenderOnSourceChangedEnabled??!0,this.source=t,this.requestRender=this.requestRender.bind(this);}destroy(){this._texture&&(this._texture.dispose(),this._texture=null),r$1(this._uploadStatus)&&(this._uploadStatus.controller.abort(),this._uploadStatus=null);}get isSourceScaled(){return this.width!==this._sourceWidth||this.height!==this._sourceHeight}get height(){return void 0!==this._height?this._height:this._sourceHeight}set height(t){this._height=t;}get source(){return this._source}set source(t){null==t&&null==this._source||(this._source=t,this._source instanceof HTMLImageElement?(this._sourceHeight=this._source.naturalHeight,this._sourceWidth=this._source.naturalWidth):this._source&&(this._sourceHeight=this._source.height,this._sourceWidth=this._source.width),this.invalidateTexture());}get width(){return void 0!==this._width?this._width:this._sourceWidth}set width(t){this._width=t;}beforeRender(t){super.beforeRender(t),this.updateTexture(t);}async setSourceAsync(e,r){r$1(this._uploadStatus)&&this._uploadStatus.controller.abort();const h=new AbortController,o=D();return d(r,(()=>h.abort())),d(h,(t=>o.reject(t))),this._uploadStatus={controller:h,resolver:o},this.source=e,o.promise}invalidateTexture(){this._textureInvalidated||(this._textureInvalidated=!0,this.requestRenderOnSourceChangedEnabled&&this.requestRender());}updateTransitionProperties(t,e){t>=64&&(this.fadeTransitionEnabled=!1,this.inFadeTransition=!1),super.updateTransitionProperties(t,e);}setTransform(t){const e=r(this.transforms.dvs),[s,i$1]=t.toScreenNoRotation([0,0],[this.x,this.y]),r$1=this.resolution/this.pixelRatio/t.resolution,d=r$1*this.width,c=r$1*this.height,_=Math.PI*this.rotation/180;M$1(e,e,t$1(s,i$1)),M$1(e,e,t$1(d/2,c/2)),h(e,e,-_),M$1(e,e,t$1(-d/2,-c/2)),b(e,e,t$1(d,c)),i(this.transforms.dvs,t.displayViewMat3,e);}setSamplingProfile(t){this._texture&&(t.mips&&!this._texture.descriptor.hasMipmap&&this._texture.generateMipmap(),this._texture.setSamplingMode(t.samplingMode));}bind(t,e){this._texture&&t.bindTexture(this._texture,e);}async updateTexture({context:e,painter:s}){if(!this._textureInvalidated)return;if(this._textureInvalidated=!1,this._texture||(this._texture=this._createTexture(e)),!this.source)return void this._texture.setData(null);this._texture.resize(this._sourceWidth,this._sourceHeight);const i=v(this.source);try{if(r$1(this._uploadStatus)){const{controller:t,resolver:e}=this._uploadStatus,r={signal:t.signal},{width:h,height:o}=this,u=this._texture,a=s.textureUploadManager;await a.enqueueTextureUpdate({data:i,texture:u,width:h,height:o},r),e.resolve(),this._uploadStatus=null;}else this._texture.setData(i);this.ready();}catch(h){b$1(h);}}onDetach(){this.destroy();}_createTransforms(){return {dvs:e()}}_createTexture(t){const e=this.immutable&&t.type===r$3.WEBGL2;return new E(t,{target:M.TEXTURE_2D,pixelFormat:P$1.RGBA,internalFormat:e?U.RGBA8:P$1.RGBA,dataType:G$1.UNSIGNED_BYTE,wrapMode:D$1.CLAMP_TO_EDGE,isImmutable:e,width:this._sourceWidth,height:this._sourceHeight})}}

export { R, S, T, l };
