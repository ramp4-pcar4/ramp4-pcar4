import { cm as h, cn as r, co as r$1, cp as p$1, bz as a$1, ar as E$1, bd as v, v as v$1, t as t$1, c as s, r as r$2, cq as f$1, cr as P, bQ as D$1, bP as a, bS as f$2, bD as $$1, cs as P$1, a9 as p, aq as I, ct as b, cu as ct, ag as u, cv as o, ah as y, aj as c$1, aa as u$1, cw as i, cx as x } from './main-5658cd6e.js';
import { A, D, l, c, o as o$1, a as a$2, f as f$3 } from './QueryEngineResult-0581c70c.js';
import { f, g, M } from './projectionSupport-90bb00b7.js';
import { t } from './QueryEngineCapabilities-014f3e07.js';
import { t as t$2, v as v$2, n, I as I$1, P as P$2 } from './timeSupport-6b86616d.js';
import { F, E, z, v as v$3 } from './utils-0bd9643b.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
function W(e){return null!=e&&e.every((e=>"exceedslimit"!==e.statisticType))}const $="feature-store:unsupported-query";const X=new h(2e6);let Y=0;class ee{constructor(e){this._geometryQueryCache=null,this._changeHandle=null,this.capabilities={query:t},this.geometryType=e.geometryType,this.hasM=!!e.hasM,this.hasZ=!!e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",(()=>this.clearCache())),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new r(Y+++"$$",X)),this.fieldsIndex=new r$1(e.fields),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority));}destroy(){this._frameTask=p$1(this._frameTask),this.clearCache(),a$1(this._geometryQueryCache),this._changeHandle=p$1(this._changeHandle),a$1(this.fieldsIndex);}get featureAdapter(){return this.featureStore.featureAdapter}clearCache(){this._geometryQueryCache?.clear(),this._allFeaturesPromise=null,this._timeExtentPromise=null;}async executeQuery(e,t){try{return (await this._executeQuery(e,{},t)).createQueryResponse()}catch(i){if(i!==F)throw i;return new A([],e,this).createQueryResponse()}}async executeQueryForCount(e={},t){try{return (await this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null},t)).createQueryResponseForCount()}catch(i){if(i!==F)throw i;return 0}}async executeQueryForExtent(e,t){const i=e.outSR;try{const s=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},t),r=s.size;if(!r)return {count:0,extent:null};return {count:r,extent:await this._getBounds(s.items,s.spatialReference,i||this.spatialReference)}}catch(s){if(s===F)return {count:0,extent:null};throw s}}async executeQueryForIds(e,t){return this.executeQueryForIdSet(e,t).then((e=>Array.from(e)))}async executeQueryForIdSet(e,t){try{const i=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},t),s=i.items,r=new Set;return await this._reschedule((()=>{for(const e of s)r.add(i.featureAdapter.getObjectId(e));}),t),r}catch(i){if(i===F)return new Set;throw i}}async executeQueryForSnapping(e,t){const{point:i,distance:s,types:r}=e;if(r===D.NONE)return {candidates:[]};const a=await this._reschedule((()=>this._checkQuerySupport(e.query)),t),o=!E$1(i.spatialReference,this.spatialReference);o&&await f(i.spatialReference,this.spatialReference);const u="number"==typeof s?s:s.x,c="number"==typeof s?s:s.y,l={xmin:i.x-u,xmax:i.x+u,ymin:i.y-c,ymax:i.y+c,spatialReference:i.spatialReference},h=o?g(l,this.spatialReference):l;if(!h)return {candidates:[]};const m=(await v(v$1(i),null,{signal:t}))[0],p=(await v(v$1(h),null,{signal:t}))[0];if(t$1(m)||t$1(p))return {candidates:[]};const f$1=new A(await this._reschedule((()=>this._searchFeatures(this._getQueryBBoxes(p.toJSON()))),t),a,this);await this._reschedule((()=>this._executeObjectIdsQuery(f$1)),t),await this._reschedule((()=>this._executeTimeQuery(f$1)),t),await this._reschedule((()=>this._executeAttributesQuery(f$1)),t);const d=m.toJSON(),y=o?g(d,this.spatialReference):d,g$1=o?Math.max(h.xmax-h.xmin,h.ymax-h.ymin)/2:s;return f$1.createSnappingResponse({...e,point:y,distance:g$1},i.spatialReference)}async executeQueryForLatestObservations(e,t){if(!this.timeInfo||!this.timeInfo.trackIdField)throw new s($,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});try{const i=await this._executeQuery(e,{},t);return await this._reschedule((()=>this._filterLatest(i)),t),i.createQueryResponse()}catch(s){if(s!==F)throw s;return new A([],e,this).createQueryResponse()}}async executeQueryForSummaryStatistics(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return (await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createSummaryStatisticsResponse(t)}async executeQueryForUniqueValues(e={},t,i){const{field:s,field2:r,field3:a,valueExpression:n}=t;return (await this._getQueryEngineResultForStats(e,{field:s,field2:r,field3:a,valueExpression:n},i)).createUniqueValuesResponse(t)}async executeQueryForClassBreaks(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return (await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createClassBreaksResponse(t)}async executeQueryForHistogram(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return (await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createHistogramResponse(t)}async fetchRecomputedExtents(e){const[t,i]=await Promise.all(["getFullExtent"in this.featureStore&&this.featureStore.getFullExtent?Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)):this._getBounds(await this._getAllFeatures(),this.spatialReference,this.spatialReference),r$2(this._timeExtentPromise)?this._timeExtentPromise:this._timeExtentPromise=t$2(this.timeInfo,this.featureStore)]);return f$1(e),{fullExtent:t,timeExtent:i}}async _getBounds(e,t,i){const s=P(a(),D$1);await this.featureStore.forEachBounds(e,(e=>f$2(s,e)));const r={xmin:s[0],ymin:s[1],xmax:s[3],ymax:s[4],spatialReference:E(this.spatialReference)};this.hasZ&&isFinite(s[2])&&isFinite(s[5])&&(r.zmin=s[2],r.zmax=s[5]);const a$1=g(r,t,i);if(a$1.spatialReference=E(i),a$1.xmax-a$1.xmin==0){const e=$$1(a$1.spatialReference);a$1.xmin-=e,a$1.xmax+=e;}if(a$1.ymax-a$1.ymin==0){const e=$$1(a$1.spatialReference);a$1.ymin-=e,a$1.ymax+=e;}if(this.hasZ&&null!=a$1.zmin&&null!=a$1.zmax&&a$1.zmax-a$1.zmin==0){const e=$$1(a$1.spatialReference);a$1.zmin-=e,a$1.zmax+=e;}return a$1}async _schedule(e,t){return r$2(this._frameTask)?this._frameTask.schedule(e,t):e(P$1)}async _reschedule(e,t){return r$2(this._frameTask)?this._frameTask.reschedule(e,t):e(P$1)}async _getAllFeaturesQueryEngineResult(e){return new A(await this._getAllFeatures(),e,this)}async _getAllFeatures(){if(t$1(this._allFeaturesPromise)){const e=[];this._allFeaturesPromise=(async()=>{await this.featureStore.forEach((t=>e.push(t)));})().then((()=>e));}const e=this._allFeaturesPromise,t=await e;return e===this._allFeaturesPromise?t.slice():this._getAllFeatures()}async _executeQuery(e,t,i){e=p(e),e=await this._schedule((()=>z(e,this.definitionExpression,this.spatialReference)),i),e=await this._reschedule((()=>this._checkQuerySupport(e)),i),e={...e,...t};const r=await this._reschedule((()=>this._executeSceneFilterQuery(e,i)),i),a=await this._reschedule((()=>this._executeGeometryQuery(e,r,i)),i);return await this._reschedule((()=>this._executeAggregateIdsQuery(a)),i),await this._reschedule((()=>this._executeObjectIdsQuery(a)),i),await this._reschedule((()=>this._executeTimeQuery(a)),i),await this._reschedule((()=>this._executeAttributesQuery(a)),i),a}async _executeSceneFilterQuery(e,t){if(t$1(e.sceneFilter))return null;const{outSR:i,returnGeometry:s,returnCentroid:r}=e,a=this.featureStore.featureSpatialReference,o=e.sceneFilter.geometry,u=t$1(a)||E$1(a,o.spatialReference)?o:g(o,a);if(!u)return null;const c=s||r,l=I(i)&&!E$1(this.spatialReference,i)&&c?async e=>this._project(e,i):e=>e,h=this.featureAdapter,m=await this._reschedule((()=>this._searchFeatures(this._getQueryBBoxes(u))),t);if("disjoint"===e.sceneFilter.spatialRelationship){if(!m.length)return null;const i=new Set;for(const e of m)i.add(h.getObjectId(e));const s=await this._reschedule((()=>this._getAllFeatures()),t),r=await this._reschedule((async()=>{const r=await v$2("esriSpatialRelDisjoint",u,this.geometryType,this.hasZ,this.hasM),a=e=>!i.has(h.getObjectId(e))||r(h.getGeometry(e)),n=await this._runSpatialFilter(s,a,t);return new A(n,e,this)}),t);return l(r)}if(!m.length)return new A([],e,this);if(this._canExecuteSinglePass(u,e))return l(new A(m,e,this));const p=await v$2("esriSpatialRelContains",u,this.geometryType,this.hasZ,this.hasM),f=await this._runSpatialFilter(m,(e=>p(h.getGeometry(e))),t);return l(new A(f,e,this))}async _executeGeometryQuery(i,s,r){if(r$2(s)&&0===s.items.length)return s;i=r$2(s)?s.query:i;const{geometry:a,outSR:u,spatialRel:c,returnGeometry:l,returnCentroid:h}=i,m=this.featureStore.featureSpatialReference,p=!a||t$1(m)||E$1(m,a.spatialReference)?a:g(a,m),f=l||h,d=I(u)&&!E$1(this.spatialReference,u),y=this._geometryQueryCache&&t$1(s)?d&&f?JSON.stringify({originalFilterGeometry:a,spatialRelationship:c,outSpatialReference:u}):JSON.stringify({originalFilterGeometry:a,spatialRelationship:c}):null,g$1=y?this._geometryQueryCache.get(y):null;if(r$2(g$1))return new A(g$1,i,this);const _=async e=>(d&&f&&await this._project(e,u),y&&this._geometryQueryCache.put(y,e.items,e.items.length+1),e);if(!p)return _(r$2(s)?s:await this._getAllFeaturesQueryEngineResult(i));const x$1=this.featureAdapter;let w=await this._reschedule((()=>this._searchFeatures(this._getQueryBBoxes(a))),r);if("esriSpatialRelDisjoint"===c){if(!w.length)return _(r$2(s)?s:await this._getAllFeaturesQueryEngineResult(i));const e=new Set;for(const i of w)e.add(x$1.getObjectId(i));const t=r$2(s)?s.items:await this._reschedule((()=>this._getAllFeatures()),r),a=await this._reschedule((async()=>{const s=await v$2(c,p,this.geometryType,this.hasZ,this.hasM),a=t=>!e.has(x$1.getObjectId(t))||s(x$1.getGeometry(t)),n=await this._runSpatialFilter(t,a,r);return new A(n,i,this)}),r);return _(a)}if(r$2(s)){const i=new x;w=w.filter((e=>b(s.items,e,s.items.length,i)>=0));}if(!w.length){const e=new A([],i,this);return y&&this._geometryQueryCache.put(y,e.items,1),e}if(this._canExecuteSinglePass(p,i))return _(new A(w,i,this));const S=await v$2(c,p,this.geometryType,this.hasZ,this.hasM),F=await this._runSpatialFilter(w,(e=>S(x$1.getGeometry(e))),r);return _(new A(F,i,this))}_executeAggregateIdsQuery(e){if(0===e.items.length||!e.query.aggregateIds||!e.query.aggregateIds.length||t$1(this.aggregateAdapter))return;const t=new Set;for(const s of e.query.aggregateIds){this.aggregateAdapter.getFeatureObjectIds(s).forEach((e=>t.add(e)));}const i=this.featureAdapter.getObjectId;e.items=e.items.filter((e=>t.has(i(e))));}_executeObjectIdsQuery(e){if(0===e.items.length||!e.query.objectIds||!e.query.objectIds.length)return;const t=new Set(e.query.objectIds),i=this.featureAdapter.getObjectId;e.items=e.items.filter((e=>t.has(i(e))));}_executeTimeQuery(e){if(0===e.items.length)return;const t=n(this.timeInfo,e.query.timeExtent,this.featureAdapter);t$1(t)||(e.items=e.items.filter(t));}_executeAttributesQuery(e){if(0===e.items.length)return;const t=l(e.query.where,this.fieldsIndex);if(t){if(!t.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter((e=>t.testFeature(e,this.featureAdapter)));}}async _runSpatialFilter(e,t,i){if(!t)return e;if(t$1(this._frameTask))return e.filter((e=>t(e)));let s=0;const r=new Array,a=async n=>{for(;s<e.length;){const o=e[s++];t(o)&&(r.push(o),n.madeProgress()),n.done&&await this._reschedule((e=>a(e)),i);}};return this._reschedule((e=>a(e)),i).then((()=>r))}_filterLatest(e){const{trackIdField:t,startTimeField:i,endTimeField:s}=this.timeInfo,r=s||i,a=new Map,n=this.featureAdapter.getAttribute;for(const o of e.items){const e=n(o,t),i=n(o,r),s=a.get(e);(!s||i>n(s,r))&&a.set(e,o);}e.items=Array.from(a.values());}_canExecuteSinglePass(e,t){const{spatialRel:i}=t;return I$1(e)&&("esriSpatialRelEnvelopeIntersects"===i||"esriGeometryPoint"===this.geometryType&&("esriSpatialRelIntersects"===i||"esriSpatialRelContains"===i||"esriSpatialRelWithin"===i))}async _project(e,t){if(!t||E$1(this.spatialReference,t))return e;const i=this.featureAdapter,s=await M(e.items.map((e=>v$3(this.geometryType,this.hasZ,this.hasM,i.getGeometry(e)))),this.spatialReference,t);return e.items=s.map(((t,s)=>i.cloneWithGeometry(e.items[s],ct(t,this.hasZ,this.hasM)))),e}_getQueryBBoxes(e){if(I$1(e)){if(u(e))return [o(e.xmin,e.ymin,e.xmax,e.ymax)];if(y(e))return e.rings.map((e=>o(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1]))))}return [c$1(u$1(),e)]}async _searchFeatures(e){const t=new Set;await Promise.all(e.map((e=>this.featureStore.forEachInBounds(e,(e=>t.add(e))))));const i=Array.from(t.values());return t.clear(),i}async _checkStatisticsSupport(e,t){if((e.distance??0)<0||null!=e.geometryPrecision||e.multipatchOption||e.pixelSize||e.relationParam||e.text||e.outStatistics||e.groupByFieldsForStatistics||e.having||e.orderByFields)throw new s($,"Unsupported query options",{query:e});return this._checkAttributesQuerySupport(e),Promise.all([this._checkStatisticsParamsSupport(t),P$2(e,this.geometryType,this.spatialReference),f(this.spatialReference,e.outSR)]).then((()=>e))}async _checkStatisticsParamsSupport(e){let t=[];if(e.valueExpression){const{arcadeUtils:i$1}=await i();t=i$1.extractFieldNames(e.valueExpression);}if(e.field&&t.push(e.field),e.field2&&t.push(e.field2),e.field3&&t.push(e.field3),e.normalizationField&&t.push(e.normalizationField),!t.length)throw new s($,"params should have at least a field or valueExpression",{params:e});c(this.fieldsIndex,t,"params contains missing fields");}async _checkQuerySupport(e){if((e.distance??0)<0||null!=e.geometryPrecision||e.multipatchOption||e.pixelSize||e.relationParam||e.text)throw new s($,"Unsupported query options",{query:e});return this._checkAttributesQuerySupport(e),this._checkStatisticsQuerySupport(e),Promise.all([P$2(e,this.geometryType,this.spatialReference),f(this.spatialReference,e.outSR)]).then((()=>e))}_checkAttributesQuerySupport(e){const{outFields:t,orderByFields:s$1,returnDistinctValues:r,outStatistics:a}=e,n=a?a.map((e=>e.outStatisticFieldName&&e.outStatisticFieldName.toLowerCase())).filter(Boolean):[];if(s$1&&s$1.length>0){const e=" asc",t=" desc",i=s$1.map((i=>{const s=i.toLowerCase();return s.includes(e)?s.split(e)[0]:s.includes(t)?s.split(t)[0]:i})).filter((e=>!n.includes(e)));c(this.fieldsIndex,i,"orderByFields contains missing fields");}if(t&&t.length>0)c(this.fieldsIndex,t,"outFields contains missing fields");else if(r)throw new s($,"outFields should be specified for returnDistinctValues",{query:e});o$1(this.fieldsIndex,e.where);}_checkStatisticsQuerySupport(e){const{outStatistics:t,groupByFieldsForStatistics:s$1,having:r}=e,a=s$1&&s$1.length,n=t&&t.length;if(r){if(!a||!n)throw new s($,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:e});a$2(this.fieldsIndex,r,t);}if(n){if(!W(t))return;const r=t.map((e=>e.onStatisticField)).filter(Boolean);c(this.fieldsIndex,r,"onStatisticFields contains missing fields"),a&&c(this.fieldsIndex,s$1,"groupByFieldsForStatistics contains missing fields");for(const s$1 of t){const{onStatisticField:t,statisticType:r}=s$1;if(("percentile_disc"===r||"percentile_cont"===r)&&"statisticParameters"in s$1){const{statisticParameters:t}=s$1;if(!t)throw new s($,"statisticParamters should be set for percentile type",{definition:s$1,query:e})}else if("count"!==r&&t&&f$3(t,this.fieldsIndex))throw new s($,"outStatistics contains non-numeric fields",{definition:s$1,query:e})}}}async _getQueryEngineResultForStats(e,t,i){e=p(e);try{e=await this._schedule((()=>z(e,this.definitionExpression,this.spatialReference)),i),e=await this._reschedule((()=>this._checkStatisticsSupport(e,t)),i);const s=await this._reschedule((()=>this._executeSceneFilterQuery(e,i)),i),r=await this._reschedule((()=>this._executeGeometryQuery(e,s,i)),i);return await this._reschedule((()=>this._executeAggregateIdsQuery(r)),i),await this._reschedule((()=>this._executeObjectIdsQuery(r)),i),await this._reschedule((()=>this._executeTimeQuery(r)),i),await this._reschedule((()=>this._executeAttributesQuery(r)),i),r}catch(r){if(r!==F)throw r;return new A([],e,this)}}}

export { ee as e };
