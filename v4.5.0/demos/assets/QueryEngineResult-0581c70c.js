import { _ as __vitePreload } from './preload-helper-a4975f27.js';
import { ds as e$1, c as s$1, t as t$2, aq as I, ar as E$1, r as r$2, c_ as te, iT as v$2, cz as l$1, iU as r$3, iV as e$2, cw as i } from './main-5658cd6e.js';
import { s as s$2 } from './quantizationUtils-ec270d9a.js';
import { f as f$1 } from './WhereClause-2f1c02a5.js';
import { c as c$2, D as D$1, m, f as f$2, d as d$1, T, y, x, z, S, M, v, p } from './utils-fe8b3668.js';
import { g } from './projectionSupport-90bb00b7.js';
import { E as E$2, v as v$1, b } from './utils-0bd9643b.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
let c$1 = class c{constructor(e,c){this._cache=new e$1(e),this._invalidCache=new e$1(c);}get(t,c){const i=`${c.uid}:${t}`,r=this._cache.get(i);if(r)return r;if(void 0!==this._invalidCache.get(i))return null;try{const r=f$1.create(t,c);return this._cache.put(i,r),r}catch{return this._invalidCache.put(i,null),null}}};

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
const n=new c$1(50,500),s="feature-store:unsupported-query",t$1=" as ",r$1=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeDate"]);function o(i,t){if(!t)return !0;const r=n.get(t,i);if(!r)throw new s$1(s,"invalid SQL expression",{where:t});if(!r.isStandardized)throw new s$1(s,"where clause is not standard",{where:t});return c(i,r.fieldNames,"where clause contains missing fields"),!0}function a(i,t,r){if(!t)return !0;const o=n.get(t,i);if(!o)throw new s$1(s,"invalid SQL expression",{having:t});if(!o.isAggregate)throw new s$1(s,"having does not contain a valid aggregate function",{having:t});const a=o.fieldNames;c(i,a,"having contains missing fields");if(!o.getExpressions().every((e=>{const{aggregateType:n,field:s}=e,t=i.get(s)?.name;return r.some((e=>{const{onStatisticField:s,statisticType:r}=e,o=i.get(s)?.name;return o===t&&r.toLowerCase().trim()===n}))})))throw new s$1(s,"expressions in having should also exist in outStatistics",{having:t});return !0}function l(e,i){return e?n.get(e,i):null}function c(i,n,t,r=!0){const o=[];for(const u of n)if("*"!==u&&!i.has(u))if(r){const n=d(u);try{const t=l(n,i);if(!t)throw new s$1(s,"invalid SQL expression",{where:n});if(!t.isStandardized)throw new s$1(s,"expression is not standard",{clause:t});c(i,t.fieldNames,"expression contains missing fields");}catch(a){const e=a&&a.details;if(e&&(e.clause||e.where))throw a;e&&e.missingFields?o.push(...e.missingFields):o.push(u);}}else o.push(u);if(o.length)throw new s$1(s,t,{missingFields:o})}function d(e){return e.split(t$1)[0]}function u(e){return e.split(t$1)[1]}function f(e,i){const n=i.get(e);return !!n&&!r$1.has(n.type)}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
class r{constructor(t,a,l$1){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=t.returnDistinctValues??!1,this.fieldsIndex=l$1,this.featureAdapter=a;const r=t.outFields;if(r&&!r.includes("*")){this.outFields=r;let t=0;for(const a of r){const r=d(a),n=this.fieldsIndex.get(r),u$1=n?null:l(r,l$1),d$1=n?n.name:u(a)||"FIELD_EXP_"+t++;this._fieldDataCache.set(a,{alias:d$1,clause:u$1});}}}countDistinctValues(t){return this.returnDistinctValues?(t.forEach((t=>this.getAttributes(t))),this._returnDistinctMap.size):t.length}getAttributes(t){const e=this._processAttributesForOutFields(t);return this._processAttributesForDistinctValues(e)}getFieldValue(t,e,s){const a=s?s.name:e;let l$1=null;return this._fieldDataCache.has(a)?l$1=this._fieldDataCache.get(a)?.clause:s||(l$1=l(e,this.fieldsIndex),this._fieldDataCache.set(a,{alias:a,clause:l$1})),s?this.featureAdapter.getAttribute(t,a):l$1?.calculateValue(t,this.featureAdapter)}getDataValue(t,e){const i=e.normalizationType,s=e.normalizationTotal;let r=e.field&&this.getFieldValue(t,e.field,this.fieldsIndex.get(e.field));if(e.field2&&(r=`${c$2(r)}${e.fieldDelimiter}${c$2(this.getFieldValue(t,e.field2,this.fieldsIndex.get(e.field2)))}`,e.field3&&(r=`${r}${e.fieldDelimiter}${c$2(this.getFieldValue(t,e.field3,this.fieldsIndex.get(e.field3)))}`)),i&&Number.isFinite(r)){const a="field"===i&&e.normalizationField?this.getFieldValue(t,e.normalizationField,this.fieldsIndex.get(e.normalizationField)):null;r=D$1(r,i,a,s);}return r}getExpressionValue(t,e,i,s){const a={attributes:this.featureAdapter.getAttributes(t),layer:{fields:this.fieldsIndex.fields}},l=s.createExecContext(a,i);return s.executeFunction(e,l)}getExpressionValues(t,e,i,s){const a={fields:this.fieldsIndex.fields};return t.map((t=>{const l={attributes:this.featureAdapter.getAttributes(t),layer:a},r=s.createExecContext(l,i);return s.executeFunction(e,r)}))}validateItem(t,e){return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:l(e,this.fieldsIndex)}),this._fieldDataCache.get(e)?.clause?.testFeature(t,this.featureAdapter)??!1}validateItems(t,e){return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:l(e,this.fieldsIndex)}),this._fieldDataCache.get(e)?.clause?.testSet(t,this.featureAdapter)??!1}_processAttributesForOutFields(t){const e=this.outFields;if(!e||!e.length)return this.featureAdapter.getAttributes(t);const i={};for(const s of e){const{alias:e,clause:a}=this._fieldDataCache.get(s);i[e]=a?a.calculateValue(t,this.featureAdapter):this.featureAdapter.getAttribute(t,e);}return i}_processAttributesForDistinctValues(e){if(t$2(e)||!this.returnDistinctValues)return e;const i=this.outFields,s=[];if(i)for(const t of i){const{alias:i}=this._fieldDataCache.get(t);s.push(e[i]);}else for(const t in e)s.push(e[t]);const a=`${(i||["*"]).join(",")}=${s.join(",")}`;let l=this._returnDistinctMap.get(a)||0;return this._returnDistinctMap.set(a,++l),l>1?null:e}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
function t(t,e,r){return {objectId:t,target:e,distance:r,type:"vertex"}}function e(t,e,r,n,d,a=!1){return {objectId:t,target:e,distance:r,type:"edge",start:n,end:d,draped:a}}

class A{constructor(e,t,i){this.items=e,this.query=t,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter;}get size(){return this.items.length}createQueryResponseForCount(){const e=new r(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:i,outStatistics:s}=this.query,a=t?.length;if(!!!a)return 1;const r$1=new Map,n=new Map,o=new Set;for(const l of s){const{statisticType:s}=l,a="exceedslimit"!==s?l.onStatisticField:void 0;if(!n.has(a)){const i=[];for(const s of t){const t=this._getAttributeValues(e,s,r$1);i.push(t);}n.set(a,this._calculateUniqueValues(i,e.returnDistinctValues));}const u=n.get(a);for(const t in u){const{data:s,items:a}=u[t],r=s.join(",");i&&!e.validateItems(a,i)||o.add(r);}}return o.size}async createQueryResponse(){let e;if(this.query.outStatistics){e=this.query.outStatistics.some((e=>"exceedslimit"===e.statisticType))?this._createExceedsLimitQueryResponse(this.query):await this._createStatisticsQueryResponse(this.query);}else e=this._createFeatureQueryResponse(this.query);if(this.query.returnQueryGeometry){const t=this.query.geometry;I(this.query.outSR)&&!E$1(t.spatialReference,this.query.outSR)?e.queryGeometry=E$2({spatialReference:this.query.outSR,...g(t,t.spatialReference,this.query.outSR)}):e.queryGeometry=E$2({spatialReference:this.query.outSR,...t});}return e}createSnappingResponse(t$1,i){const s=this.featureAdapter,a=N(this.hasZ,this.hasM),{point:r,mode:n}=t$1,o="number"==typeof t$1.distance?t$1.distance:t$1.distance.x,l="number"==typeof t$1.distance?t$1.distance:t$1.distance.y,u={candidates:[]},c="esriGeometryPolygon"===this.geometryType,h=this._getPointCreator(n,this.spatialReference,i),f=new q(null,0),g=new q(null,0),p={x:0,y:0,z:0};for(const y of this.items){const i=s.getGeometry(y);if(t$2(i))continue;const{coords:n,lengths:x}=i;if(f.coords=n,g.coords=n,t$1.types&D.EDGE){let e$1=0;for(let t=0;t<x.length;t++){const i=x[t];for(let t=0;t<i;t++,e$1+=a){const n=f;if(n.coordsIndex=e$1,t!==i-1){const t=g;t.coordsIndex=e$1+a;const i=p;E(p,r,n,t);const c=(r.x-i.x)/o,m=(r.y-i.y)/l,f=c*c+m*m;f<=1&&u.candidates.push(e(s.getObjectId(y),h(i),Math.sqrt(f),h(n),h(t)));}}}}if(t$1.types&D.VERTEX){const e=c?n.length-a:n.length;for(let t$1=0;t$1<e;t$1+=a){const e=f;e.coordsIndex=t$1;const i=(r.x-e.x)/o,a=(r.y-e.y)/l,n=i*i+a*a;n<=1&&u.candidates.push(t(s.getObjectId(y),h(e),Math.sqrt(n)));}}}return u.candidates.sort(((e,t)=>e.distance-t.distance)),u}_getPointCreator(e,i,s){const a=r$2(s)&&!E$1(i,s)?e=>g(e,i,s):e=>e,{hasZ:r}=this,n=0;return "3d"===e?r?({x:e,y:t,z:i})=>a({x:e,y:t,z:i}):({x:e,y:t})=>a({x:e,y:t,z:n}):({x:e,y:t})=>a({x:e,y:t})}async createSummaryStatisticsResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,minValue:n,maxValue:o,scale:l}=e,u=this.fieldsIndex.isDateField(t),c=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:l}),d=m({normalizationType:a,normalizationField:s,minValue:n,maxValue:o}),m$1=this.fieldsIndex.get(t),h={value:.5,fieldType:m$1?.type},f=te(m$1)?f$2({values:c,supportsNullCount:d,percentileParams:h}):d$1({values:c,minValue:n,maxValue:o,useSampleStdDev:!a,supportsNullCount:d,percentileParams:h});return T(f,u)}async createUniqueValuesResponse(e){const{field:t,valueExpression:i,domains:s,returnAllCodedValues:a,scale:r}=e,n=await this._getDataValues({field:t,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:i,scale:r}),o=y(n);return x(o,s,a,e.fieldDelimiter)}async createClassBreaksResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numClasses:c,scale:d}=e,m=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:d}),h=z(m,{field:t,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numClasses:c});return S(h,n)}async createHistogramResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numBins:c,scale:d}=e,m=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:d});return M(m,{field:t,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numBins:c})}_sortFeatures(e,t,i){if(e.length>1&&t&&t.length)for(const s of t.reverse()){const t=s.split(" "),a=t[0],r=this.fieldsIndex.get(a),n=!!t[1]&&"desc"===t[1].toLowerCase(),o=v(r?.type,n);e.sort(((e,t)=>{const s=i(e,a,r),n=i(t,a,r);return o(s,n)}));}}_createFeatureQueryResponse(e){const t=this.items,{geometryType:i,hasM:s,hasZ:a,objectIdField:r,spatialReference:o}=this,{outFields:l,outSR:u,quantizationParameters:c,resultRecordCount:d,resultOffset:m,returnZ:f,returnM:g}=e,p=null!=d&&t.length>(m||0)+d,y=l&&(l.includes("*")?[...this.fieldsIndex.fields]:l.map((e=>this.fieldsIndex.get(e))));return {exceededTransferLimit:p,features:this._createFeatures(e,t),fields:y,geometryType:i,hasM:s&&g,hasZ:a&&f,objectIdFieldName:r,spatialReference:E$2(u||o),transform:c&&s$2(c)||null}}_createFeatures(e,t){const i=new r(e,this.featureAdapter,this.fieldsIndex),{hasM:s,hasZ:a}=this,{orderByFields:r$1,quantizationParameters:o,returnGeometry:l,returnCentroid:c,maxAllowableOffset:d,resultOffset:m,resultRecordCount:h,returnZ:p=!1,returnM:y=!1}=e,x=a&&p,I=s&&y;let T=[],V=0;const F=[...t];if(this._sortFeatures(F,r$1,((e,t,s)=>i.getFieldValue(e,t,s))),l||c){const e=s$2(o)??void 0;if(l&&!c)for(const t of F)T[V++]={attributes:i.getAttributes(t),geometry:v$1(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),d,e,x,I)};else if(!l&&c)for(const t of F)T[V++]={attributes:i.getAttributes(t),centroid:b(this,this.featureAdapter.getCentroid(t,this),e)};else for(const t of F)T[V++]={attributes:i.getAttributes(t),centroid:b(this,this.featureAdapter.getCentroid(t,this),e),geometry:v$1(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),d,e,x,I)};}else for(const n of F){const e=i.getAttributes(n);e&&(T[V++]={attributes:e});}const S=m||0;if(null!=h){const e=S+h;T=T.slice(S,Math.min(T.length,e));}return T}_createExceedsLimitQueryResponse(e){let i=!1,s=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY,r=Number.POSITIVE_INFINITY;for(const t of e.outStatistics??[])if("exceedslimit"===t.statisticType){s=null!=t.maxPointCount?t.maxPointCount:Number.POSITIVE_INFINITY,a=null!=t.maxRecordCount?t.maxRecordCount:Number.POSITIVE_INFINITY,r=null!=t.maxVertexCount?t.maxVertexCount:Number.POSITIVE_INFINITY;break}if("esriGeometryPoint"===this.geometryType)i=this.items.length>s;else if(this.items.length>a)i=!0;else {const e=N(this.hasZ,this.hasM),s=this.featureAdapter;i=this.items.reduce(((e,i)=>{const a=s.getGeometry(i);return e+(r$2(a)&&a.coords.length||0)}),0)/e>r;}return {fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(i)}}]}}async _createStatisticsQueryResponse(e){const t={attributes:{}},i=[],s=new Map,a=new Map,r$1=new Map,n=new Map,o=new r(e,this.featureAdapter,this.fieldsIndex),l=e.outStatistics,{groupByFieldsForStatistics:c,having:d,orderByFields:m}=e,h=c&&c.length,f=!!h,g=f?c[0]:null,p=f&&!this.fieldsIndex.get(g);for(const u of l??[]){const{outStatisticFieldName:e,statisticType:l}=u,m=u,y="exceedslimit"!==l?u.onStatisticField:void 0,x="percentile_disc"===l||"percentile_cont"===l,I="EnvelopeAggregate"===l||"CentroidAggregate"===l||"ConvexHullAggregate"===l,T=f&&1===h&&(y===g||p)&&"count"===l;if(f){if(!r$1.has(y)){const e=[];for(const t of c){const i=this._getAttributeValues(o,t,s);e.push(i);}r$1.set(y,this._calculateUniqueValues(e,!I&&o.returnDistinctValues));}const t=r$1.get(y);for(const i in t){const{count:a,data:r,items:l,itemPositions:u}=t[i],h=r.join(",");if(!d||o.validateItems(l,d)){const t=n.get(h)||{attributes:{}};if(I){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:i}=await this._getAggregateGeometry(m,l);t.aggregateGeometries[i]=e;}else {let i=null;if(T)i=a;else {const e=this._getAttributeValues(o,y,s),t=u.map((t=>e[t]));i=x&&"statisticParameters"in m?this._getPercentileValue(m,t):this._getStatisticValue(m,t,null,o.returnDistinctValues);}t.attributes[e]=i;}let i=0;c.forEach(((e,s)=>t.attributes[this.fieldsIndex.get(e)?e:"EXPR_"+ ++i]=r[s])),n.set(h,t);}}}else if(I){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:i}=await this._getAggregateGeometry(m,this.items);t.aggregateGeometries[i]=e;}else {const i=this._getAttributeValues(o,y,s);t.attributes[e]=x&&"statisticParameters"in m?this._getPercentileValue(m,i):this._getStatisticValue(m,i,a,o.returnDistinctValues);}i.push({name:e,alias:e,type:"esriFieldTypeDouble"});}const y=f?Array.from(n.values()):[t];return this._sortFeatures(y,m,((e,t)=>e.attributes[t])),{fields:i,features:y}}async _getAggregateGeometry(e,t){const n=await __vitePreload(() => import('./geometryEngineJSON-6a09f904.js').then(n => n.g),true?["./geometryEngineJSON-6a09f904.js","./geometryEngineBase-67566f1a.js","./json-ce6e5728.js"]:void 0,import.meta.url),{statisticType:o,outStatisticFieldName:l}=e,{featureAdapter:u,spatialReference:c,geometryType:d,hasZ:m,hasM:h}=this,g=t.map((e=>v$1(d,m,h,u.getGeometry(e)))),p=n.convexHull(c,g,!0)[0],y={aggregateGeometries:null,outStatisticFieldName:null};if("EnvelopeAggregate"===o){const e=p?v$2(p):l$1(n.union(c,g));y.aggregateGeometries={...e,spatialReference:c},y.outStatisticFieldName=l||"extent";}else if("CentroidAggregate"===o){const e=p?r$3(p):e$2(l$1(n.union(c,g)));y.aggregateGeometries={x:e[0],y:e[1],spatialReference:c},y.outStatisticFieldName=l||"centroid";}else "ConvexHullAggregate"===o&&(y.aggregateGeometries=p,y.outStatisticFieldName=l||"convexHull");return y}_getStatisticValue(e,t,i,s){const{onStatisticField:a,statisticType:r}=e;let n=null;n=i?.has(a)?i.get(a):te(this.fieldsIndex.get(a))?f$2({values:t,returnDistinct:s}):d$1({values:s?[...new Set(t)]:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(a,n);return n["var"===r?"variance":r]}_getPercentileValue(e,t){const{onStatisticField:i,statisticParameters:s,statisticType:a}=e,{value:r,orderBy:n}=s,o=this.fieldsIndex.get(i);return p(t,{value:r,orderBy:n,fieldType:o?.type,isDiscrete:"percentile_disc"===a})}_getAttributeValues(e,t,i){if(i.has(t))return i.get(t);const s=this.fieldsIndex.get(t),a=this.items.map((i=>e.getFieldValue(i,t,s)));return i.set(t,a),a}_getAttributeDataValues(e,t){return this.items.map((i=>e.getDataValue(i,{field:t.field,field2:t.field2,field3:t.field3,fieldDelimiter:t.fieldDelimiter,normalizationField:t.normalizationField,normalizationType:t.normalizationType,normalizationTotal:t.normalizationTotal})))}async _getAttributeExpressionValues(e,t,i$1){const{arcadeUtils:s}=await i(),a=s.createFunction(t),r=i$1&&s.getViewInfo(i$1);return e.getExpressionValues(this.items,a,r,s)}_calculateUniqueValues(e,t){const i={},s=this.items,a=s.length;for(let r=0;r<a;r++){const a=s[r],n=[];for(const t of e)n.push(t[r]);const o=n.join(",");null==i[o]?i[o]={count:1,data:n,items:[a],itemPositions:[r]}:(t||i[o].count++,i[o].items.push(a),i[o].itemPositions.push(r));}return i}async _getDataValues(e){const t=new r(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:i,field:s,normalizationField:a,normalizationType:r$1,normalizationTotal:n,scale:o}=e,l=i?{viewingMode:"map",scale:o,spatialReference:this.query.outSR||this.spatialReference}:null;return i?this._getAttributeExpressionValues(t,i,l):this._getAttributeDataValues(t,{field:s,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,normalizationField:a,normalizationType:r$1,normalizationTotal:n})}}function E(e,t,i,s){const a=s.x-i.x,r=s.y-i.y,n=a*a+r*r,o=(t.x-i.x)*a+(t.y-i.y)*r,l=Math.min(1,Math.max(0,o/n));e.x=i.x+a*l,e.y=i.y+r*l;}function N(e,t){return e?t?4:3:t?3:2}var D;!function(e){e[e.NONE=0]="NONE",e[e.EDGE=1]="EDGE",e[e.VERTEX=2]="VERTEX";}(D||(D={}));class q{constructor(e,t){this.coords=e,this.coordsIndex=t;}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}

export { A, D, a, c, f, l, o };
