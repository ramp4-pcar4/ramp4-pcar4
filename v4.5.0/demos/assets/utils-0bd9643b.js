import { _ as __vitePreload } from './preload-helper-a4975f27.js';
import { s, cz as l, bd as v$1, v as v$2, t, ag as u, ah as y, ai as f$1, ar as E$1, bE as An, cA as X, cB as o, ac as k$1, cC as c, r as r$1, cD as gt, cE as mt, cF as Mt, cG as t$1, cH as j, cI as C$1, cJ as K, cK as q$1 } from './main-5658cd6e.js';
import { f, g } from './projectionSupport-90bb00b7.js';

const O=new s({esriSRUnit_Meter:"meters",esriSRUnit_Kilometer:"kilometers",esriSRUnit_Foot:"feet",esriSRUnit_StatuteMile:"miles",esriSRUnit_NauticalMile:"nautical-miles",esriSRUnit_USNauticalMile:"us-nautical-miles"}),F=Object.freeze({}),N=new t$1,_=new t$1,G=new t$1,P={esriGeometryPoint:j,esriGeometryPolyline:C$1,esriGeometryPolygon:K,esriGeometryMultipoint:q$1};function b(e,i,r,n=e.hasZ,o=e.hasM){if(t(i))return null;const s=e.hasZ&&n,a=e.hasM&&o;if(r){const t=mt(G,i,e.hasZ,e.hasM,"esriGeometryPoint",r,n,o);return j(t,s,a)}return j(i,s,a)}function v(e,r,n,o,s,a,l=r,m=n){const f=r&&l,u=n&&m,c=r$1(o)?"coords"in o?o:o.geometry:null;if(t(c))return null;if(s){let t=gt(_,c,r,n,e,s,l,m);return a&&(t=mt(G,t,f,u,e,a)),P[e]?.(t,f,u)??null}if(a){const t=mt(G,c,r,n,e,a,l,m);return P[e]?.(t,f,u)??null}return Mt(N,c,r,n,l,m),P[e]?.(N,f,u)??null}async function z(e,t,i){const{outFields:r,orderByFields:n,groupByFieldsForStatistics:o,outStatistics:s}=e;if(r)for(let a=0;a<r.length;a++)r[a]=r[a].trim();if(n)for(let a=0;a<n.length;a++)n[a]=n[a].trim();if(o)for(let a=0;a<o.length;a++)o[a]=o[a].trim();if(s)for(let a=0;a<s.length;a++)s[a].onStatisticField&&(s[a].onStatisticField=s[a].onStatisticField.trim());return e.geometry&&!e.outSR&&(e.outSR=e.geometry.spatialReference),J(e,t,i)}async function J(e,i,r){if(!e)return null;let{where:n}=e;if(e.where=n=n&&n.trim(),(!n||/^1 *= *1$/.test(n)||i&&i===n)&&(e.where=null),!e.geometry)return e;let a=await Z(e);if(e.distance=0,e.units=null,"esriSpatialRelEnvelopeIntersects"===e.spatialRel){const{spatialReference:t}=e.geometry;a=l(a),a.spatialReference=t;}if(a){await f(a.spatialReference,r),a=B(a,r);const i=(await v$1(v$2(a)))[0];if(t(i))throw F;const n="quantizationParameters"in e&&e.quantizationParameters?.tolerance||"maxAllowableOffset"in e&&e.maxAllowableOffset||0,o=n&&A(a,r)?{densificationStep:8*n}:void 0,l=i.toJSON(),m=await g(l,l.spatialReference,r,o);if(!m)throw F;m.spatialReference=r,e.geometry=m;}return e}function A(e,t){if(!e)return !1;const i=e.spatialReference;return (u(e)||y(e)||f$1(e))&&!E$1(i,t)&&!An(i,t)}function B(e,t){const i=e.spatialReference;return A(e,t)&&u(e)?{spatialReference:i,rings:[[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]]}:e}async function Z(e){const{distance:t,units:i}=e,n=e.geometry;if(null==t||"vertexAttributes"in n)return n;const o$1=n.spatialReference,s=i?O.fromJSON(i):X(o$1),a=o$1&&(o(o$1)||k$1(o$1))?n:await f(o$1,c).then((()=>g(n,c)));return (await q())(a.spatialReference,a,t,s)}async function q(){return (await __vitePreload(() => import('./geometryEngineJSON-6a09f904.js').then(n => n.g),true?["./geometryEngineJSON-6a09f904.js","./geometryEngineBase-67566f1a.js","./json-ce6e5728.js"]:void 0,import.meta.url)).geodesicBuffer}function E(e){return e&&k in e?JSON.parse(JSON.stringify(e,C)):e}const k="_geVersion",C=(e,t)=>e!==k?t:void 0;

export { E, F, J, b, v, z };
