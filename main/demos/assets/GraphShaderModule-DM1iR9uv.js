import{_ as x,eE as Qt,t as Jt,s as Zt,i as Bt}from"./main-CtmwM019.js";import"./BufferObject-DG9EMnfd.js";import"./FramebufferObject-PAs-KxsF.js";import{s as Wt}from"./ProgramTemplate-CpLijHZI.js";import{h as te,A as ee}from"./Texture-QG2FbAaW.js";import{s as re}from"./ShaderBuilder-DMCNkLu1.js";let Ae=class{constructor(){this.drawPhase=89}startup(){}shutdown(t){}};function ne(e){return e.split(" ").map((t,r)=>r>0?t.charAt(0).toUpperCase()+t.slice(1):t).join("")}function se(e,t){const r=[];for(r.push(t);r.length;){const n=r.pop();if(typeof n=="object"&&!e.has(n.uid)){e.add(n.uid);for(const s of n.children)r.push(s)}}}class P{constructor(){this.uid=P.NodeCount++,this._debugName=null,this._isMutable=!1,this.isImplicit=!1}static{this.NodeCount=0}get isMutable(){return this._isMutable}setMutable(){return this._isMutable=!0,this}setDebugName(t){return t=ne(t),this._debugName=t,this.isImplicit&&this.children[0]instanceof P&&this.children[0].setDebugName(t),this}get debugInfo(){return{name:this._debugName??""}}cloneInto(t){t._debugName=this._debugName,t._isMutable=this._isMutable,t.isImplicit=this.isImplicit,t.uid=this.uid}}function u(e){return typeof e=="object"?e.clone():e}let v=class extends P{constructor(){super(...arguments),this.shaderType="primitive-node"}},ie=class zt extends P{constructor(t){super(),this.child=t,this.shaderType="scope-node"}get children(){return[this.child]}clone(){const t=new zt(u(this.child));return this.cloneInto(t),t}};class Pt extends P{constructor(t,r,n){super(),this.property=t,this.target=r,this.returnType=n,this.shaderType="property-access-node"}get children(){const t=[this.target];return typeof this.property!="string"&&t.push(this.property),t}clone(){const t=new Pt(this.property,u(this.target),this.returnType);return this.cloneInto(t),t}}let oe=class Lt extends P{constructor(t,r,n,s){super(),this.x=t,this.y=r,this.target=n,this.returnType=s,this.shaderType="property-access-2d-node"}get children(){return[this.target,this.x,this.y]}clone(){const t=new Lt(this.x,this.y,u(this.target),this.returnType);return this.cloneInto(t),t}};class Ft extends P{constructor(t,r,n){super(),this.condition=t,this.ifTrue=r,this.ifFalse=n,this.shaderType="condition-node"}get children(){return[this.condition,this.ifTrue,this.ifFalse]}clone(){const t=u(this.ifTrue),r=this.ifFalse?u(this.ifFalse):null,n=new Ft(this.condition,t,r);return this.cloneInto(n),n}}let ae=class qt extends P{constructor(t,r,n,s){super(),this.captureList=t,this.returnType=r,this.generator=s,this.shaderType="block-node",n&&(this.subgraph=new ie(n))}get children(){return Object.keys(this.captureList).map(t=>this.captureList[t]).concat(this.subgraph??[])}clone(){const t={};for(const n in this.captureList)t[n]=u(this.captureList[n]);const r=new qt(t,this.returnType,this.subgraph?u(this.subgraph.child):this.subgraph,this.generator);return this.cloneInto(r),r}},V=class Rt extends P{constructor(t,r,n,s,i,o=!1){super(),this.token=t,this._children=r,this.isInfix=n,this.isPropertyAccess=s,this.returnType=i,this.isTernary=o,this.shaderType="function-node"}get children(){return this._children}clone(){const t=new Rt(this.token,this._children.map(u),this.isInfix,this.isPropertyAccess,this.returnType,this.isTernary);return this.cloneInto(t),t}};var Z,ot,at,ut,O,ct,ht,dt,pt,lt,ft,yt,mt,gt;function ue(e){switch(e.type){case"bool":case"bvec2":case"bvec3":case"bvec4":return N;case"float":case"vec2":case"vec3":case"vec4":return y;case"int":case"ivec2":case"ivec3":case"ivec4":return d;case"uint":case"uvec2":case"uvec3":case"uvec4":return b;default:throw new Error("Unable to handle type")}}function ce(e){const t=[["float","vec2","vec3","vec4"],["int","ivec2","ivec3","ivec4"],["uint","uvec2","uvec3","uvec4"],["bool","bvec2","bvec3","bvec4"]];for(const r of t)if(r.includes(e))return r.map(n=>pe[n]);throw new Error("Unable to find type family")}function Gt(e){return new Proxy(e,{get(t,r){if(r==="constructor")return new Proxy(t.constructor,{construct:(n,s,i)=>Gt(new n(...s))});if(r in t)return t[r];if(typeof r=="string"){const n=ce(e.type);return m(e,r,n[r.length-1])}}})}function T(e){return new Proxy(e,{construct:(t,r,n)=>Gt(new t(...r))})}function he(e){return new Proxy(e,{get(t,r){if(r in t)return t[r];if(typeof r=="string"){const n=parseInt(r,10);if(!isNaN(n))return m(e,`[${n}]`,e.elementType.constructor)}}})}function de(e){return new Proxy(e,{construct:(t,r,n)=>he(new t(...r))})}class K extends Error{}let bt=class extends v{static{Z=this}static{this.type="array"}constructor(e,t){super(),this.elementType=e,this.size=t,this.children=[],this.type="array"}clone(){const e=new Z(this.elementType,this.size);return super.cloneInto(e),e}get(e,t){const r=new d(e),n=t!=null?new d(t):null;return n!=null?st(this,r,n,ue(this.elementType.constructor)):m(this,r,this.elementType.constructor)}last(){return this.get(this.size-1)}first(){return this.get(0)}findIndex(e,t,r){return ye(this,e,t,r)}glslFindIndex(e,t,r){return me(this,e,t,r)}static ofType(e,t){const r={construct:(n,s)=>new Z(new e,t)};return new Proxy(Z,r)}};bt=Z=x([de],bt);class wt extends v{static{this.type="array-2d"}constructor(t,r,n,s=!1){super(),this.elementType=t,this.xSize=r,this.ySize=n,this.isRowMajor=s,this.children=[],this.type="array-2d"}clone(){const t=new wt(this.elementType,this.xSize,this.ySize,this.isRowMajor);return super.cloneInto(t),t}get size(){return this.xSize*this.ySize}get(t,r){return this.isRowMajor?this._getRowMajor(t,r):this._getColumnMajor(t,r)}_getColumnMajor(t,r){const n=new d(t);return m(this,new d(r).add(n.multiply(this.xSize)),this.elementType.constructor)}_getRowMajor(t,r){const n=new d(t),s=new d(r);return m(this,n.add(s.multiply(this.ySize)),this.elementType.constructor)}static ofType(t,r,n,s=!1){return new Proxy(bt,{construct:(i,o)=>new wt(new t,r,n,s)})}}class Ht extends v{constructor(){super(...arguments),this.type="sampler2D",this.children=[]}static{this.type="sampler2D"}clone(){const t=new Ht;return t.children=this.children.map(u),super.cloneInto(t),t}}let y=class L extends v{static{this.type="float"}constructor(t){super(),this.type="float",this.children=[t]}clone(){const t=new L(u(this.children[0]));return super.cloneInto(t),t}multiply(t){return I(this,typeof t=="number"?p(t,L):t)}divide(t){return k(this,typeof t=="number"?p(t,L):t)}add(t){return M(this,typeof t=="number"?p(t,L):t)}subtract(t){return S(this,typeof t=="number"?p(t,L):t)}},tt=class extends v{static{ot=this}static{this.type="vec2"}constructor(e,t){super(),this.type="vec2",this.children=[e,t].filter(r=>r!=null)}clone(){const e=new ot(u(this.children[0]),u(this.children[1]));return super.cloneInto(e),e}get 0(){return m(this,"[0]",y)}get 1(){return m(this,"[1]",y)}get 2(){throw new K}get 3(){throw new K}multiply(e){return I(this,typeof e=="number"?p(e,y):e)}divide(e){return k(this,typeof e=="number"?p(e,y):e)}add(e){return M(this,typeof e=="number"?p(e,y):e)}subtract(e){return S(this,typeof e=="number"?p(e,y):e)}};tt=ot=x([T],tt);let nt=class extends v{static{at=this}static{this.type="vec3"}constructor(t,r,n){super(),this.type="vec3",this.children=[t,r,n].filter(s=>s!=null)}get 0(){return m(this,"[0]",y)}get 1(){return m(this,"[1]",y)}get 2(){return m(this,"[2]",y)}get 3(){throw new K}clone(){const t=new at(u(this.children[0]),u(this.children[1]),u(this.children[2]));return super.cloneInto(t),t}multiply(t){return I(this,typeof t=="number"?p(t,y):t)}divide(t){return k(this,typeof t=="number"?p(t,y):t)}add(t){return M(this,typeof t=="number"?p(t,y):t)}subtract(t){return S(this,typeof t=="number"?p(t,y):t)}};nt=at=x([T],nt);let B=class extends v{static{ut=this}static{this.type="vec4"}constructor(t,r,n,s){super(),this.type="vec4",this.children=[t,r,n,s].filter(i=>i!=null)}clone(){const t=new ut(u(this.children[0]),u(this.children[1]),u(this.children[2]),u(this.children[3]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",y)}get 1(){return m(this,"[1]",y)}get 2(){return m(this,"[2]",y)}get 3(){return m(this,"[3]",y)}multiply(t){return I(this,typeof t=="number"?p(t,y):t)}divide(t){return k(this,typeof t=="number"?p(t,y):t)}add(t){return M(this,typeof t=="number"?p(t,y):t)}subtract(t){return S(this,typeof t=="number"?p(t,y):t)}};B=ut=x([T],B);let b=class extends v{static{O=this}static{this.type="uint"}constructor(e){super(),this.type="uint",this.children=[e]}clone(){const e=new O(u(this.children[0]));return super.cloneInto(e),e}multiply(e){return I(this,p(e,O))}add(e){return M(this,p(e,O))}subtract(e){return S(this,p(e,O))}divide(e){return k(this,p(e,O))}};b=O=x([T],b);let vt=class extends v{static{ct=this}static{this.type="uvec2"}constructor(e,t){super(),this.type="uvec2",this.children=[e,t].filter(r=>r!=null)}clone(){const e=new ct(u(this.children[0]),u(this.children[1]));return super.cloneInto(e),e}get 0(){return m(this,"[0]",d)}get 1(){return m(this,"[1]",d)}get 2(){throw new K}get 3(){throw new K}multiply(e){return I(this,typeof e=="number"?p(e,b):e)}divide(e){return k(this,typeof e=="number"?p(e,b):e)}add(e){return M(this,typeof e=="number"?p(e,b):e)}subtract(e){return S(this,typeof e=="number"?p(e,b):e)}};vt=ct=x([T],vt);let $t=class extends v{static{ht=this}static{this.type="uvec3"}constructor(e,t,r){super(),this.type="uvec3",this.children=[e,t,r].filter(n=>n!=null)}clone(){const e=new ht(u(this.children[0]),u(this.children[1]),u(this.children[2]));return super.cloneInto(e),e}get 0(){return m(this,"[0]",b)}get 1(){return m(this,"[1]",b)}get 2(){return m(this,"[2]",b)}get 3(){throw new K}multiply(e){return I(this,typeof e=="number"?p(e,b):e)}divide(e){return k(this,typeof e=="number"?p(e,b):e)}add(e){return M(this,typeof e=="number"?p(e,b):e)}subtract(e){return S(this,typeof e=="number"?p(e,b):e)}};$t=ht=x([T],$t);let xt=class extends v{static{dt=this}static{this.type="uvec4"}constructor(e,t,r,n){super(),this.type="uvec4",this.children=[e,t,r,n].filter(s=>s!=null)}clone(){const e=new dt(u(this.children[0]),u(this.children[1]),u(this.children[2]),u(this.children[3]));return super.cloneInto(e),e}get 0(){return m(this,"[0]",b)}get 1(){return m(this,"[1]",b)}get 2(){return m(this,"[2]",b)}get 3(){return m(this,"[3]",b)}multiply(e){return I(this,typeof e=="number"?p(e,b):e)}divide(e){return k(this,typeof e=="number"?p(e,b):e)}add(e){return M(this,typeof e=="number"?p(e,b):e)}subtract(e){return S(this,typeof e=="number"?p(e,b):e)}};xt=dt=x([T],xt);class N extends v{static{this.type="bool"}constructor(t){super(),this.type="bool",this.children=[t]}and(t){return xe(this,t)}or(t){return be(this,t)}xor(t){return ve(this,t)}clone(){const t=new N(u(this.children[0]));return super.cloneInto(t),t}}let _t=class extends v{static{pt=this}static{this.type="bvec2"}constructor(e,t){super(),this.type="bvec2",this.children=[e,t].filter(r=>r!=null)}all(){return Kt(this)}any(){return Dt(this)}clone(){const e=new pt(u(this.children[0]),u(this.children[1]));return super.cloneInto(e),e}};_t=pt=x([T],_t);let It=class extends v{static{lt=this}static{this.type="bvec3"}constructor(e,t,r){super(),this.type="bvec3",this.children=[e,t,r].filter(n=>n!=null)}all(){return Kt(this)}any(){return Dt(this)}clone(){const e=new lt(u(this.children[0]),u(this.children[1]),u(this.children[2]));return super.cloneInto(e),e}};function p(e,t){return typeof e=="number"?new t(e):e}It=lt=x([T],It);let Nt=class extends v{static{ft=this}static{this.type="bvec4"}constructor(e,t,r,n){super(),this.type="bvec4",this.children=[e,t,r,n].filter(s=>s!=null)}all(){return Kt(this)}any(){return Dt(this)}clone(){const e=new ft(u(this.children[0]),u(this.children[1]),u(this.children[2]),u(this.children[3]));return super.cloneInto(e),e}};Nt=ft=x([T],Nt);class d extends v{static{this.type="int"}constructor(t){super(),this.type="int",this.children=[t]}multiply(t){return I(this,p(t,d))}add(t){return M(this,p(t,d))}subtract(t){return S(this,p(t,d))}divide(t){return k(this,p(t,d))}clone(){const t=new d(u(this.children[0]));return super.cloneInto(t),t}}let Tt=class extends v{static{yt=this}static{this.type="ivec2"}constructor(e,t){super(),this.type="ivec2",this.children=[e,t].filter(r=>r!=null)}clone(){const e=new yt(u(this.children[0]),u(this.children[1]));return super.cloneInto(e),e}get 0(){return m(this,"[0]",d)}get 1(){return m(this,"[1]",d)}get 2(){throw new K}get 3(){throw new K}multiply(e){return I(this,typeof e=="number"?p(e,d):e)}divide(e){return k(this,typeof e=="number"?p(e,d):e)}add(e){return M(this,typeof e=="number"?p(e,d):e)}subtract(e){return S(this,typeof e=="number"?p(e,d):e)}};Tt=yt=x([T],Tt);let Mt=class extends v{static{mt=this}static{this.type="ivec3"}constructor(e,t,r){super(),this.type="ivec3",this.children=[e,t,r].filter(n=>n!=null)}clone(){const e=new mt(u(this.children[0]),u(this.children[1]),u(this.children[2]));return super.cloneInto(e),e}get 0(){return m(this,"[0]",d)}get 1(){return m(this,"[1]",d)}get 2(){return m(this,"[2]",d)}get 3(){throw new K}multiply(e){return I(this,typeof e=="number"?p(e,d):e)}divide(e){return k(this,typeof e=="number"?p(e,d):e)}add(e){return M(this,typeof e=="number"?p(e,d):e)}subtract(e){return S(this,typeof e=="number"?p(e,d):e)}};Mt=mt=x([T],Mt);let kt=class extends v{static{gt=this}static{this.type="ivec4"}constructor(e,t,r,n){super(),this.type="ivec4",this.children=[e,t,r,n].filter(s=>s!=null)}clone(){const e=new gt(u(this.children[0]),u(this.children[1]),u(this.children[2]),u(this.children[3]));return super.cloneInto(e),e}get 0(){return m(this,"[0]",d)}get 1(){return m(this,"[1]",d)}get 2(){return m(this,"[2]",d)}get 3(){return m(this,"[3]",d)}multiply(e){return I(this,typeof e=="number"?p(e,d):e)}divide(e){return k(this,typeof e=="number"?p(e,d):e)}add(e){return M(this,typeof e=="number"?p(e,d):e)}subtract(e){return S(this,typeof e=="number"?p(e,d):e)}};kt=gt=x([T],kt);class Yt extends v{static{this.type="mat2"}constructor(t,r,n,s){super(),this.type="mat2",this.children=[t,r,n,s]}clone(){const t=new Yt(u(this.children[0]),u(this.children[1]),u(this.children[2]),u(this.children[3]));return super.cloneInto(t),t}get(t,r){return st(this,new d(t),new d(r),y)}multiply(t){return I(this,t)}}class W extends v{static{this.type="mat3"}static identity(){return new W(1,0,0,0,1,0,0,0,1)}static fromRotation(t){const r=Ne(t),n=Ie(t);return new W(n,r,0,fe(r),n,0,0,0,1)}constructor(t,r,n,s,i,o,h,c,a){super(),this.type="mat3",this.children=[t,r,n,s,i,o,h,c,a]}add(t){return M(this,t)}multiply(t){return I(this,t)}get(t,r){return st(this,new d(t),new d(r),y)}clone(){const t=new W(u(this.children[0]),u(this.children[1]),u(this.children[2]),u(this.children[3]),u(this.children[4]),u(this.children[5]),u(this.children[6]),u(this.children[7]),u(this.children[8]));return super.cloneInto(t),t}}class et extends v{static{this.type="mat4"}static identity(){return new et(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}constructor(t,r,n,s,i,o,h,c,a,l,f,w,F,z,j,E){super(),this.type="mat4",this.children=[t,r,n,s,i,o,h,c,a,l,f,w,F,z,j,E]}static fromColumns(t,r,n,s){return new et(t.x,t.y,t.z,t.w,r.x,r.y,r.z,r.w,n.x,n.y,n.z,n.w,s.x,s.y,s.z,s.w)}multiply(t){return I(this,t)}get(t,r){return st(this,new d(t),new d(r),y)}clone(){const t=new et(u(this.children[0]),u(this.children[1]),u(this.children[2]),u(this.children[3]),u(this.children[4]),u(this.children[5]),u(this.children[6]),u(this.children[7]),u(this.children[8]),u(this.children[9]),u(this.children[10]),u(this.children[11]),u(this.children[12]),u(this.children[13]),u(this.children[14]),u(this.children[15]));return super.cloneInto(t),t}}const pe={float:y,vec2:tt,vec3:nt,vec4:B,int:d,ivec2:Tt,ivec3:Mt,ivec4:kt,uint:b,uvec2:vt,uvec3:$t,uvec4:xt,bool:N,bvec2:_t,bvec3:It,bvec4:Nt},Le=(...e)=>new d(...e),le=(...e)=>new y(...e),qe=(...e)=>new tt(...e),Re=(...e)=>new nt(...e),Ge=(...e)=>new B(...e),He=(...e)=>new W(...e);function m(e,t,r){const n=new r(new Pt(t,e,r));return n.isImplicit=!0,n}function st(e,t,r,n){const s=new n(new oe(t,r,e,n));return s.isImplicit=!0,s}function $(e,t,r,n=null){if(n){const i=new n,o=new n(new V(e,[t,r],!0,!1,i));return o.isImplicit=!0,o}if(t.type==="float"||t.type==="int"){const i=new r.constructor(new V(e,[t,r],!0,!1,r.constructor));return i.isImplicit=!0,i}if((t.type==="mat2"||t.type==="mat3"||t.type==="mat4")&&r.type!=="float"){const i=new r.constructor(new V(e,[t,r],!0,!1,r.constructor));return i.isImplicit=!0,i}const s=new t.constructor(new V(e,[t,r],!0,!1,t.constructor));return s.isImplicit=!0,s}function g(e,t,r=t.constructor){const n=new r(new V(e,[t],!1,!1,r));return n.isImplicit=!0,n}function D(e,t,r,n=t.constructor){const s=new n(new V(e,[t,r],!1,!1,n));return s.isImplicit=!0,s}function it(e,t,r,n,s=t.constructor){const i=new s(new V(e,[t,r,n],!1,!1,s));return i.isImplicit=!0,i}function fe(e){return I(e,le(-1))}function Et(e,t,r,n){return new t(new ae(e,t,r,n))}function ye(e,t,r=0,n=e.size){const s=new d(r).setMutable().setDebugName("FindIndexIterator"),i=t(e.get(s)).setDebugName("FindIndexPredicate");return Et({iter:s},d,i,({out:h,iter:c,subgraph:a})=>`
${h} = -1;

for (; ${c} < ${n}; ${c}++) {

${a.body}

  if (${a.varName}) {
    ${h} = ${c};
    break;
  }

}
`).setDebugName("FindIndexBlock")}function me(e,t,r=0,n=e.size){return Et({array:e},d,null,({out:i,array:o})=>`
${i} = -1;
for (int i = ${r}; i < ${n}; i++) {
  bool condition;
  ${t({array:o,i:"i",out:"condition"})}
  if (condition) {
    ${i} = i;
    break;
  }
}
`).setDebugName("GlslFindIndexBlock")}function ge(e,t,r){const n=typeof t=="function"?t():t,s=typeof r=="function"?r():r,i=new n.constructor(new Ft(e,n,s));return i.isImplicit=!0,i}function Ye(...e){const t=e.map(([h,c])=>typeof c=="function"?[h,c()]:[h,c]),r=t[0][1].constructor,n=t.findIndex(h=>h[0]===!0);if(n===-1)throw new Error("A cond must have a fallthrough case with `true`/; ");const s=t.slice(0,n),i=t[n][1],o=new r(s.reduceRight((h,c)=>ge(c[0],c[1],h),i));return o.isImplicit=!0,o}function I(e,t){return $("*",e,t)}function k(e,t){return $("/",e,t)}function M(e,t){return $("+",e,t)}function S(e,t){return $("-",e,t)}function Xe(e,t){return $("%",e,t)}function Qe(e,t){return $("<<",e,t)}function Je(e,t){return $(">>",e,t)}function Ze(e,t){return $("&",e,t)}function We(e,t){return $("|",e,t)}function tr(e,t){return $("^",e,t)}function er(e){return g("~",e)}function rr(e,t){return $("==",e,t,N)}function nr(e,t){return $("!=",e,t,N)}function sr(e,t){return $("<",e,t,N)}function ir(e,t){return $("<=",e,t,N)}function or(e,t){return $(">",e,t,N)}function ar(e,t){return $(">=",e,t,N)}function be(...e){return e.length<=1?e[0]:e.slice(1).reduce((t,r)=>we(t,r),e[0])}function we(e,t){return $("||",e,t,N)}function ve(...e){return e.length<=1?e[0]:e.slice(1).reduce((t,r)=>$e(t,r),e[0])}function $e(e,t){return $("^^",e,t,N)}function xe(...e){return e.length<=1?e[0]:e.slice(1).reduce((t,r)=>_e(t,r),e[0])}function _e(e,t){return $("&&",e,t,N)}function ur(e){return g("abs",e)}function cr(e){return g("acos",e)}function hr(e){return g("acosh",e)}function Kt(e){return g("all",e,N)}function Dt(e){return g("any",e,N)}function dr(e){return g("asin",e)}function pr(e){return g("asinh",e)}function lr(e,t){return t==null?g("atan",e):D("atan",e,t,e.constructor)}function fr(e){return g("atanh",e)}function yr(e){return g("ceil",e)}function mr(e,t,r){return it("clamp",e,t,r,e.constructor)}function Ie(e){return g("cos",e)}function gr(e){return g("cosh",e)}function br(e,t){return D("distance",e,t,y)}function wr(e,t){return D("dot",e,t,y)}function vr(e){return g("exp",e)}function $r(e){return g("floor",e)}function xr(e){return g("fract",e)}function _r(e){return g("length",e,y)}function Ir(e){return g("log",e)}function Nr(e){return g("log2",e)}function Tr(e,t){return D("max",e,t)}function Mr(e,t){return D("min",e,t)}function kr(e,t,r){return it("mix",e,t,r)}function Sr(e,t){return D("mod",e,t)}function Cr(e){return g("normalize",e)}function Pr(e){return e.type==="bool"?g("!",e):g("not",e)}function Fr(e,t){return D("pow",e,t)}function Er(e){return g("round",e)}function Kr(e){return g("sign",e)}function Ne(e){return g("sin",e)}function Dr(e){return g("sinh",e)}function Ur(e,t,r){return it("smoothstep",e,t,r)}function jr(e){return g("sqrt",e)}function Ar(e,t){return D("step",e,t,t.constructor)}function Or(e){return g("tan",e)}function Vr(e){return g("tanh",e)}function Br(e,t,r){return it("texelFetch",e,t,r,B)}function zr(e,t){return D("texture",e,t,B)}function Lr(e,t){const{initialValue:r,xRange:n,yRange:s,callback:i}=t,[o,h]=n,[c,a]=s,l=new d(0).setMutable().setDebugName("iterX"),f=new d(0).setMutable().setDebugName("iterY"),w=r.setMutable().setDebugName("accumulator"),F=i(w,e.get(l,f),l,f).setDebugName("callback");return Et({iterX:l,iterY:f,accumulator:w},r.constructor,F,({out:j,iterX:E,iterY:A,accumulator:R,subgraph:G})=>`
for (${A} = ${c}; ${A} < ${a}; ${A}++) {
  for (${E} = ${o}; ${E} < ${h}; ${E}++) {

  ${G.body}

  ${R} = ${G.varName};
  }
}
${j} = ${R};
`).setDebugName("reduce2DBody")}const X=5;function _(e,t,r){const n=t.split(`
`);for(const s of n)if(s.trim().length){{let i="";r!=null&&(i+=`/*id:${r??"000"}*/   `),e.body+=i.padEnd(14)}e.body+=" ".repeat(e.indent)+s+`
`}}let At=class{write(t){for(const r of t.rootOutputNodes())t.shouldPruneOutputNode(r)||(r.variableName=this._write(t,r.node));return t}_createVarName(t,r){let n="";return typeof r!="boolean"&&typeof r!="number"&&r.debugInfo.name&&(n=`${r.debugInfo.name}_`),`${n}v${t.varCount++}`}_write(t,r,n=!1){if(typeof r=="number"||typeof r=="boolean")return r.toString();let s=t.getEmit(r);if(s)return s;switch(r.shaderType){case"scope-node":s=this._writeScopeNode(t,r);break;case"primitive-node":s=this._writePrimitiveNode(t,r,n);break;case"function-node":s=this._writeFunctionNode(t,r);break;case"property-access-node":s=this._writePropertyAccessNode(t,r);break;case"property-access-2d-node":s=this._writePropertyAccess2DNode(t,r);break;case"text-node":s=r.text;break;case"block-node":s=this._writeBlockNode(t,r);break;case"condition-node":s=this._writeConditionNode(t,r)}return t.setEmit(r,s),s}_writeScopeNode(t,r){const n=new r.child.constructor;n.setDebugName(r.debugInfo.name);const s=this._write(t,n,!0);return _(t,`{ /*ScopeStart: ${r.uid} ${r.debugInfo.name}*/`),t.indent+=2,_(t,`${s} = ${this._write(t,r.child)};`),t.indent-=2,_(t,`} /*ScopeEnd: ${r.uid} ${r.debugInfo.name}*/`),s}_writeConditionNode(t,r){const n=new r.ifTrue.constructor,s=this._write(t,n,!0);_(t,`if (${this._write(t,r.condition)}) {`),t.indent+=2;const i=t.createSubgraphContext(),o=this._write(i,r.ifTrue);if(t.body+=i.body,o&&_(t,`${s} = ${o};`),t.indent-=2,_(t,"}"),r.ifFalse){_(t,"else {"),t.indent+=2;const h=t.createSubgraphContext(),c=this._write(h,r.ifFalse);t.body+=h.body,c&&_(t,`${s} = ${c};`),t.indent-=2,_(t,"}")}return s}_writeBlockNode(t,r){const{captureList:n,generator:s,returnType:i}=r,o={};for(const l in n){if(!n[l])continue;const f=this._write(t,n[l]);o[l]=f}const h=new i,c=this._write(t,h,!0);if(o.out=c,r.subgraph){const l=t.createSubgraphContext(),f=this._write(l,r.subgraph.child),w=l.body;o.subgraph={varName:f,body:w}}const a=s(o);return _(t,`{
`),t.indent+=2,_(t,a),t.indent-=2,_(t,`}
`),c}_writePropertyAccessNode(t,r){const n=this._write(t,r.target);return typeof r.property=="string"&&r.property.includes("[")?`${n}${r.property}`:typeof r.property!="string"?`${n}[${this._write(t,r.property)}]`:`${n}.${r.property}`}_writePropertyAccess2DNode(t,r){return`${this._write(t,r.target)}[${this._write(t,r.x)}][${this._write(t,r.y)}]`}_writeFunctionNode(t,r){const n=r.returnType.type;if(r.isInfix){const[o,h]=r.children.map(a=>this._write(t,a)),c=this._createVarName(t,r);return _(t,`${n.padEnd(X)} ${c} = ${o} ${r.token} ${h};`,r.uid),c}const s=r.children.map(o=>this._write(t,o)).join(", "),i=this._createVarName(t,r);return _(t,`${n.padEnd(X)} ${i} = ${r.token}(${s});`,r.uid),i}_writePrimitiveNode(t,r,n=!1){const s=t.getInput(r);if(s)return s.isUsed=!0,s.variableName;const i=r.children.length===1&&r.children[0]?.type===r.type;if(!r.isMutable&&(r.isImplicit||i))return this._write(t,r.children[0]);const o=this._createVarName(t,r);if(n)return _(t,`${r.type.padEnd(X)} ${o};`,r.uid),o;const h=!r.debugInfo.name&&!r.isMutable;if(h&&r.type==="float"&&typeof r.children[0]=="number")return Number.isInteger(r.children[0])?r.children[0].toFixed(1):r.children[0].toString();if(h&&r.type==="int"&&typeof r.children[0]=="number"&&Number.isInteger(r.children[0]))return r.children[0].toString();const c=r.children.map(a=>this._write(t,a)).join(", ");return r.type==="array"?(_(t,`${r.type.padEnd(X)} ${o} = [${c}];`,r.uid),o):h?`${r.type}(${c})`:(_(t,`${r.type.padEnd(X)} ${o} = ${r.type}(${c});`,r.uid),o)}};class U{constructor(t,r,n,s=[]){this.variableName=t,this.variableInputType=r,this.node=n,this.qualifiers=s,this.type="shader-input",this.isUsed=!1}clone(){return new U(this.variableName,this.variableInputType,u(this.node),[...this.qualifiers])}}let C=class Xt{constructor(t,r,n,s=[]){this.outVariableName=t,this.outVariableType=r,this.node=n,this.qualifiers=s,this.type="shader-output"}clone(){const t=new Xt(this.outVariableName,this.outVariableType,u(this.node),[...this.qualifiers]);return t.variableName=this.variableName,t}},Ot=class rt{static createVertex(t,r,n,s,i,o){const h=[];for(const a in t){const l=t[a],f=n.get(a);f?h.push(new U(f,"builtin",l)):h.push(new U("a_"+a,"in",l))}for(const a of s){const l=a.uniformHydrated;h.push(new U(a.uniformName,"uniform",l))}const c=[];for(const a in r){const l=r[a];if(a==="glPosition")c.push(new C("gl_Position","builtin",l));else if(a==="glPointSize")c.push(new C("gl_PointSize","builtin",l));else{const f=Te(l),w=[];f&&w.push(f),c.push(new C("v_"+a,"out",l,w))}}return new rt(h,c,i,o)}static createFragment(t,r,n,s,i,o){const h=[],c=Array.from(i.rootOutputNodes());for(const l in t){const f=t[l],w=n.get(l);if(w){h.push(new U(w,"builtin",f));continue}const F=c.find(z=>z.node===f);F&&h.push(new U(F.outVariableName,"in",f))}for(const l of s){const f=l.uniformHydrated;h.push(new U(l.uniformName,"uniform",f))}const a=[];for(const l in r){const f=r[l],w=n.get(l);switch(l){case"discard":a.push(new C(null,"discard",f));break;case"fragData0":a.push(new C("fragData0","fragData0",f));break;case"fragData1":a.push(new C("fragData1","fragData1",f));break;case"fragData2":a.push(new C("fragData2","fragData2",f));break;case"fragData3":a.push(new C("fragData3","fragData3",f));break;default:w?a.push(new C(w,"builtin",f)):a.push(new C(l,"out",f))}}return new rt(h,a,o)}constructor(t,r,n,s){this.type="shader-graph-context",this.indent=0,this.body="",this.varCount=0,this._inputShaderTypesByNodeUid=new Map,this._nodeEmitMap=new Map;for(const i of t)this._inputShaderTypesByNodeUid.set(i.node.uid,i);this._outputShaderTypes=r,this._transformFeedbackBindings=n,this._transformFeedbackNames=new Set(n.map(i=>"v_"+i.propertyKey)),this._usedInFragmentShader=s}shouldPruneOutputNode(t){return!!this._usedInFragmentShader&&t.outVariableType!=="builtin"&&!this._transformFeedbackNames.has(t.outVariableName)&&!this._usedInFragmentShader.has(t.node.uid)}setEmit(t,r){this._nodeEmitMap.set(t.uid,r)}getEmit(t){return this._nodeEmitMap.get(t.uid)}inputs(){return this._inputShaderTypesByNodeUid.values()}getInput(t){return this._inputShaderTypesByNodeUid.get(t.uid)}*rootOutputNodes(){for(const t of this._outputShaderTypes)yield t}*nodes(){const t=[];for(const r of this._outputShaderTypes.values())t.push(r.node);for(;t.length;){const r=t.pop();typeof r!="number"&&typeof r!="boolean"&&t.push(...r.children.filter(Boolean)),yield r}}*nodesOfTypeOrFunction(){for(const t of this.nodes())typeof t!="number"&&typeof t!="boolean"&&(yield t)}createSubgraphContext(){const t=this.clone();return t.body="",t.indent=this.indent+2,t._nodeEmitMap=new Map(this._nodeEmitMap),t}clone(){const t=new rt([],this._outputShaderTypes,this._transformFeedbackBindings,this._usedInFragmentShader);return t._inputShaderTypesByNodeUid=this._inputShaderTypesByNodeUid,t.indent=this.indent,t.body=this.body,t.varCount=this.varCount,t._nodeEmitMap=this._nodeEmitMap,t}insertVertexShader(t){t.vertex.code.add(""),this._insertInputs(t,"vertex"),t.vertex.code.add(""),t.vertex.code.add("// OUTPUTS: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const r of this.rootOutputNodes()){const n=r.outVariableType==="builtin";if(!this.shouldPruneOutputNode(r))if(n)t.vertex.code.add(`// ${r.outVariableType.padEnd(7)} ${r.node.type.padEnd(9)} ${r.outVariableName};`);else{const s=[...r.qualifiers,r.outVariableType].join(" ");t.vertex.code.add(`${s.padEnd(10)} ${r.node.type.padEnd(9)} ${r.outVariableName};`)}}t.vertex.code.add(""),t.vertex.code.add("void main() {"),t.vertex.code.add("  "+this.body.split(`
`).join(`
  `));for(const r of this.rootOutputNodes())this.shouldPruneOutputNode(r)||t.vertex.code.add(`  ${r.outVariableName} = ${r.variableName};`);t.vertex.code.add("}")}insertFragmentShader(t){this._insertInputs(t,"fragment"),t.fragment.code.add(""),t.fragment.code.add("// OUTPUTS: "),t.fragment.code.add("// --------------------------------------------------------- ");let r=0;for(const n of this.rootOutputNodes())n.outVariableType==="builtin"?t.fragment.code.add(`// ${n.outVariableType.padEnd(7)} ${n.node.type.padEnd(9)} ${n.outVariableName};`):t.outputs.add(n.outVariableName,n.node.type,r++);t.fragment.code.add(""),t.fragment.code.add("void main() {"),t.fragment.code.add("  "+this.body.split(`
`).join(`
  `));for(const n of this.rootOutputNodes())n.outVariableType==="discard"?(t.fragment.code.add("  // TODO: Should ensure codegen for discard appears first in fragment shader"),t.fragment.code.add(`  if (${n.variableName}) {`),t.fragment.code.add("    discard;"),t.fragment.code.add("  }"),t.fragment.code.add("  ")):t.fragment.code.add(`  ${n.outVariableName} = ${n.variableName};`);t.fragment.code.add("}")}_insertInputs(t,r){t[r].code.add("// INPUTS: "),t[r].code.add("// --------------------------------------------------------- ");for(const n of this.inputs())if(n.isUsed&&n.variableInputType!=="builtin")if(n.node.type==="array")t[r].code.add(`${n.variableInputType.padEnd(10)} ${n.node.elementType.type.padEnd(9)} ${n.variableName}[${n.node.size}];`);else if(n.node.type==="array-2d")t[r].code.add(`${n.variableInputType.padEnd(10)} ${n.node.elementType.type.padEnd(9)} ${n.variableName}[${n.node.size}]; // Emulated 2D Array. Not supported by ES3.0`);else{const s=[...n.qualifiers,n.variableInputType].join(" ");t[r].code.add(` ${s.padEnd(10)} ${n.node.type.padEnd(9)} ${n.variableName};`)}}};function Te(e){switch(e.type){case"float":case"vec2":case"vec3":case"vec4":return null;case"int":case"ivec2":case"ivec3":case"ivec4":case"uint":case"uvec2":case"uvec3":case"uvec4":case"bool":case"bvec2":case"bvec3":case"bvec4":return"flat";case"mat2":case"mat3":case"mat4":case"array":case"sampler2D":case"array-2d":throw new Error(`InternalError: ${e.type} is not a valid output type`)}}function Me(e,t,r){const n=new te(t.width,t.height);return n.dataType=t.dataType,t.depth&&(n.depth=t.depth),t.flipped&&(n.flipped=t.flipped),t.hasMipmap&&(n.hasMipmap=t.hasMipmap),n.internalFormat=t.internalFormat,t.isImmutable&&(n.isImmutable=t.isImmutable),t.isOpaque&&(n.isOpaque=t.isOpaque),t.maxAnisotropy&&(n.maxAnisotropy=t.maxAnisotropy),n.pixelFormat=t.pixelFormat,t.preMultiplyAlpha&&(n.preMultiplyAlpha=t.preMultiplyAlpha),t.samplingMode&&(n.samplingMode=t.samplingMode),t.target&&(n.target=t.target),n.uniform=t.uniform,t.unpackAlignment&&(n.unpackAlignment=t.unpackAlignment),t.wrapMode&&(n.wrapMode=t.wrapMode),new ee(e,n,r)}const ke=()=>Bt.getLogger("esri.views.2d.engine.webgl.shaderGraph.typed.TypedShaderProgram");function Q(e,t,r){const n=t.length;if(n!==r){const s=new Zt("Invalid Uniform",`Invalid length, expected ${r} but got ${n}`,{uniformName:e,values:t});ke().errorOnce(s)}}let Vt=class{constructor(t,r,n,s,i){this.vertexShader=t,this.fragmentShader=r,this._locations=n,this._uniformBindings=s,this._transformFeedbackBindings=i,this._vao=null,this._temporaryTextures=[]}destroy(){this._program=Qt(this._program),this.cleanupTemporaryTextures()}setUniforms(t){this._uniforms=t}cleanupTemporaryTextures(){for(const t of this._temporaryTextures)t.dispose();this._temporaryTextures=[]}bind(t){const r=this._uniforms;if(!this._program){const s=[];for(const i of this._transformFeedbackBindings??[]){const{index:o,propertyKey:h}=i;s[o]=`v_${h}`}this._program=new Wt(t,this.vertexShader,this.fragmentShader,this._locations,new Map,s)}const n=this._program;t.useProgram(n);for(const s of this._uniformBindings){const{shaderModulePath:i,uniformName:o,uniformType:h,uniformArrayLength:c}=s,a=Jt(i,r);if(a==null){if(h==="sampler2D")continue;throw new Error(`Failed to find uniform value for ${i}`)}switch(h==="array"||h==="array-2d"?s.uniformArrayElementType:h){case"sampler2D":{const{unit:l,texture:f}=a;if(n.setUniform1i(o,l),"type"in f)t.bindTexture(f,l);else{const w=Me(t,f.descriptor,f.data);t.bindTexture(w,l)}break}case"int":if(!c){n.setUniform1i(o,a);break}Q(s.uniformName,a,c),n.setUniform1iv(o,a);break;case"float":if(!c){n.setUniform1f(o,a);break}Q(s.uniformName,a,c),n.setUniform1fv(o,a);break;case"vec2":if(!c){n.setUniform2f(o,a[0],a[1]);break}Q(s.uniformName,a,c),n.setUniform2fv(o,a.flat());break;case"vec3":if(!c){n.setUniform3f(o,a[0],a[1],a[2]);break}Q(s.uniformName,a,c),n.setUniform3fv(o,a.flat());break;case"vec4":if(!c){n.setUniform4f(o,a[0],a[1],a[2],a[3]);break}Q(s.uniformName,a,c),n.setUniform4fv(o,a.flat());break;case"mat3":n.setUniformMatrix3fv(o,a);break;case"mat4":n.setUniformMatrix4fv(o,a);break;default:throw new Error(`Unable to set uniform for type ${h}`)}}}};function J(e){return new e}function q(e,t,r){const n=e.constructor[t]??[];e.constructor.hasOwnProperty(t)||Object.defineProperty(e.constructor,t,{value:n.slice()}),e.constructor[t].push(r)}function Gr(e,t){return(r,n)=>{q(r,"locations",{typeCtor:t,propertyKey:n,parameterIndex:null,index:e})}}const Se=e=>(t,r)=>{q(t,"builtins",{builtin:e,propertyKey:r})},Hr=e=>(t,r,n)=>{q(t,"inputs",{inputCtor:e,propertyKey:r,parameterIndex:n})},Yr=e=>(t,r)=>{q(t,"uniforms",{typeCtor:e,propertyKey:r})},Xr=e=>(t,r)=>{q(t,"options",{typeCtor:e,propertyKey:r})},Qr=(e,t)=>{q(e,"defines",{propertyKey:t})},St=(e,t)=>(r,n)=>{r.constructor.builtins.push({builtin:e,propertyKey:n,typeCtor:t})};class Ce{static{this.builtins=[]}}x([St("gl_VertexID",d)],Ce.prototype,"glVertexID",void 0);class Jr{}class Ct{static{this.builtins=[]}}x([St("gl_FragCoord",B)],Ct.prototype,"glFragCoord",void 0),x([St("gl_PointCoord",tt)],Ct.prototype,"glPointCoord",void 0);let Pe=class{};x([Se("gl_FragDepth")],Pe.prototype,"glFragDepth",void 0);let Wr=class{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}},en=class{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const t=this._shaderModuleClass.inputs.findLast(r=>r.propertyKey==="vertex"&&r.parameterIndex===0);if(!t)throw new Error("Unable to find vertex input parameter");return t}get computeInput(){return this._shaderModuleClass.inputs.findLast(t=>t.propertyKey==="vertex"&&t.parameterIndex===1)}get fragmentInput(){const t=this._shaderModuleClass.inputs.findLast(r=>r.propertyKey==="fragment");if(!t)throw new Error("Unable to find fragment input parameter");return t}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){return[...this.vertexInput.inputCtor.locations,...this.computeInput?.inputCtor.locations??[]]}get locationsMap(){const t=new Map,r=new Set;for(const n of this.locations)r.has(n.index)?Bt.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${n.propertyKey} to ${n.index}. Index already in use`,{locationsMap:t}):(t.set(n.propertyKey,n.index),r.add(n.index));return t}get locationInfo(){if(!this._locationInfo){const t=this.locationsMap,r=Array.from(t.entries()).map(([s,i])=>`${s}.${i}`).join("."),n=this.computeAttributes;this._locationInfo={stringHash:r,locations:t,computeAttributeMap:n}}return this._locationInfo}get renamedLocationsMap(){const t=new Map;for(const r of this.locations)t.set("a_"+r.propertyKey,r.index);return t}get optionPropertyKeys(){if(!this._optionPropertyKeys){const t=new Set;for(const r of this._options)t.add(r.propertyKey);this._optionPropertyKeys=t}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram(t,r,n,s){try{const{vertex:i,fragment:o,uniformBindings:h}=this._generateShaders(t,r,n,s);return new Vt(i,o,this.renamedLocationsMap,h,this.transformFeedbackBindings)}catch{return new Vt("","",this.renamedLocationsMap,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo(t){const r=this._options.find(s=>s.propertyKey===t);if(r)return{type:"option",className:r.typeCtor};const n=this._uniforms.find(s=>s.propertyKey===t);if(!n)throw new Error(`Unable to find uniform class type for property: ${t}`);return{type:"required",className:n.typeCtor}}getShaderKey(t,r,n,s){const i=Object.keys(t).map(a=>`${a}.${t[a]}`).join("."),o=Object.keys(n).map(a=>`${a}.${n[a]}`).join("."),h=Object.keys(s).map(a=>`${a}.${s[a]}`).join("."),c=Object.keys(r).filter(a=>this.optionPropertyKeys.has(a)&&r[a]).join(".");return`${this.type}.${i}.${o}.${h}.${c}`}_generateShaders(t,r,n,s){const i=[];this._setDefines(n),this._setOptionalUniforms(i,r),this._setRequiredUniforms(i);const o=this._hydrateVertexInput(s),h=this._injectPackPrecisionFactor(o,t),c=this._hydrateComputeInput(),a=c&&this._injectComputePackPrecisionFactor(c,t),l=this.vertex(h,a),f=this._hydrateFragmentInput(l),w=this.fragment(f),F=new Set;for(const H in w){const Y=w[H];se(F,Y)}const z=this._getVertexInputBuiltins(),j={};for(const[H,Y]of Object.entries(o))j[H]=Y;if(c!=null)for(const[H,Y]of Object.entries(c))j[H]=Y;const E=Ot.createVertex(j,l,z,i,this.transformFeedbackBindings,F);new At().write(E);const A=this._getFragmentInputBuiltins(w);A.set("glPointCoord","gl_PointCoord"),A.set("glFragCoord","gl_FragCoord");const R=Ot.createFragment(f,w,A,i,E,this.transformFeedbackBindings);new At().write(R);const G=this._createShaderBuilder(E,R),Ut=G.generate("vertex"),jt=G.generate("fragment");return this.logShader&&(console.log(Ut),console.log(jt)),{vertex:Ut,fragment:jt,uniformBindings:i}}_setDefines(t){for(const r in t)this[r]=t[r]}_setOptionalUniforms(t,r){for(const n of this._options)r[n.propertyKey]?this[n.propertyKey]=this._hydrateUniformGroup(t,n):this[n.propertyKey]=null}_setRequiredUniforms(t){for(const r of this._uniforms)this[r.propertyKey]=this._hydrateUniformGroup(t,r)}_hydrateUniformGroup(t,r){const n=new r.typeCtor;for(const s of n._uniforms??[]){const i=J(s.typeCtor),o=`u_${r.propertyKey}_${s.propertyKey}`,h=i.type,c=[r.propertyKey,s.propertyKey].join(".");if("type"in s.typeCtor&&s.typeCtor.type==="array"){const a=i;t.push({shaderModulePath:c,uniformName:o,uniformType:h,uniformArrayLength:a.size,uniformArrayElementType:a.elementType.type,uniformHydrated:i})}else if("type"in s.typeCtor&&s.typeCtor.type==="array-2d"){const a=i;t.push({shaderModulePath:c,uniformName:o,uniformType:h,uniformArrayLength:a.size,uniformArrayElementType:a.elementType.type,uniformHydrated:i})}else t.push({shaderModulePath:c,uniformName:o,uniformType:h,uniformHydrated:i});n[s.propertyKey]=i}return n}_hydrateVertexInput(t){const r=this.vertexInput.inputCtor,n=r.locations.reduce((s,i)=>t[i.propertyKey]===!1?s:{...s,[i.propertyKey]:J(i.typeCtor)},{});for(const{propertyKey:s,typeCtor:i}of r.builtins){const o=J(i);n[s]=o}return n}_hydrateComputeInput(){return this.computeInput==null?null:this.computeInput.inputCtor.locations.reduce((t,r)=>({...t,[r.propertyKey]:J(r.typeCtor)}),{})}_injectPackPrecisionFactor(t,r){const n={};for(const s in t){const i=t[s],o=r[s];if(o){if(i.type!=="float"&&i.type!=="vec2"&&i.type!=="vec3"&&i.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${i.type}`);n[s]=i.divide(new y(o))}else n[s]=i}return n}_injectComputePackPrecisionFactor(t,r){const n={},s=new Map;for(const i in this.computeAttributes)for(const o of this.computeAttributes[i]??[])s.set(o,i);for(const i in t){const o=t[i],h=s.get(i);if(!h)continue;const c=r[h];if(c){if(o.type!=="float"&&o.type!=="vec2"&&o.type!=="vec3"&&o.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${o.type}`);n[i]=o.divide(new y(c))}else n[i]=o}return n}_hydrateFragmentInput(t){const r={};for(const n in t)r[n]=t[n];for(const{propertyKey:n,typeCtor:s}of Ct.builtins){const i=J(s);r[n]=i}return r}_getVertexInputBuiltins(){const t=this.vertexInput.inputCtor,r=new Map;for(const{builtin:n,propertyKey:s}of t.builtins)r.set(s,n);return r}_getFragmentInputBuiltins(t){const r=t.constructor,n=new Map;for(const s of r.builtins??[])n.set(s.propertyKey,s.builtin);return n}_createShaderBuilder(t,r){const n=new re;return this._insertDebugInfo(n),t.insertVertexShader(n),r.insertFragmentShader(n),n}_insertDebugInfo(t){t.vertex.code.add("// DEFINES: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const r of this._defines)this[r.propertyKey]?t.vertex.code.add(`//   ${r.propertyKey}: true`):t.vertex.code.add(`//   ${r.propertyKey}: false`);t.vertex.code.add(""),t.vertex.code.add("// OPTIONS: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const r of this._options)this[r.propertyKey]?t.vertex.code.add(`//   ${r.propertyKey}: true`):t.vertex.code.add(`//   ${r.propertyKey}: false`)}};export{N as $,jr as A,ir as B,y as C,sr as D,Ur as E,bt as F,or as G,vr as H,Ct as I,et as J,lr as K,_r as L,Ie as M,d as N,Er as O,en as P,ur as Q,I as R,Xe as S,xr as T,Ht as U,Br as V,Fr as W,Tr as X,nt as Y,Tt as Z,B as _,Sr as a,Le as a0,Kr as a1,Xr as a2,fe as a3,nr as a4,ar as a5,ve as a6,be as a7,xe as a8,tr as a9,Vt as aA,er as aa,Je as ab,Qe as ac,We as ad,Ze as ae,Vr as af,Or as ag,Dr as ah,gr as ai,fr as aj,pr as ak,dr as al,hr as am,cr as an,yr as ao,Nr as ap,Ir as aq,Lr as ar,wt as as,Et as at,Jr as au,Yt as av,br as aw,Pr as ax,Cr as ay,He as az,rr as b,tt as c,zr as d,kr as e,Gr as f,Hr as g,Re as h,Ce as i,Wr as j,Ae as k,Ge as l,Yr as m,Qr as n,qe as o,ge as p,mr as q,W as r,le as s,Mr as t,Ne as u,Pe as v,wr as w,Ar as x,Ye as y,$r as z};
