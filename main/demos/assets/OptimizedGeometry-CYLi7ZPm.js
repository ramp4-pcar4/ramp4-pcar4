import{i as d}from"./memoryEstimations-R8dTJqWI.js";const i=2;class l{constructor(s=[],t=[]){this.lengths=s??[],this.coords=t??[]}static fromJSON(s){return new l(s.lengths,s.coords)}static fromRect(s){const[t,o,e,r]=s,h=e-t,n=r-o;return new l([5],[t,o,h,0,0,n,-h,0,0,-n])}get isPoint(){return this.lengths.length===0&&this.coords.length>=2}get maxLength(){return Math.max(...this.lengths)}get size(){return this.lengths.reduce((s,t)=>s+t)}get usedMemory(){return 64+d(this.lengths,this.coords)}area(){let s=0,t=0;if(!this.lengths.length)return 0;for(let o=0;o<this.lengths.length;o++){const e=this.lengths[o];if(e<3)continue;let r=this.coords[i*t],h=this.coords[i*t+1];for(let n=1;n<e;n+=1){const c=this.coords[i*(n+t)],g=this.coords[i*(n+t)+1];s+=-.5*(c-r)*(g+h),r=c,h=g}t+=e}return s}forEachVertex(s){let t=0;this.lengths.length||s(this.coords[0],this.coords[1]);for(let o=0;o<this.lengths.length;o++){const e=this.lengths[o];for(let r=0;r<e;r++)s(this.coords[i*(r+t)],this.coords[i*(r+t)+1]);t+=e}}deltaDecode(){const s=this.clone(),{coords:t,lengths:o}=s;let e=0;for(const r of o){for(let h=1;h<r;h++)t[2*(e+h)]+=t[2*(e+h)-2],t[2*(e+h)+1]+=t[2*(e+h)-1];e+=r}return s}clone(s){if(this.lengths.length===0)return new l([],[this.coords[0],this.coords[1]]);const t=(this.lengths.length===0?1:this.lengths.reduce((e,r)=>e+r))*i,o=this.coords.slice(0,t);return s?(s.set(o),new l(this.lengths,s)):new l(Array.from(this.lengths),Array.from(o))}}export{l as e};
