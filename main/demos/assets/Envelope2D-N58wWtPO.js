import{m as e,z as p,O as c,U as N,P as l,L as d}from"./Point2D-yI-uny1B.js";class r{static construct(t,s,i,m){return new r(t,s,i,m)}constructor(t,s,i,m){this.m_EnvelopeType=2,t===void 0?(this.xmin=Number.NaN,this.ymin=Number.NaN,this.xmax=Number.NaN,this.ymax=Number.NaN):typeof t=="number"?(this.xmin=t,this.ymin=s,this.xmax=i,this.ymax=m):(this.xmin=t.xmin,this.ymin=t.ymin,this.xmax=t.xmax,this.ymax=t.ymax),this.normalize()}static constructEmpty(){return new r(Number.NaN,Number.NaN,Number.NaN,Number.NaN)}clone(){return new r(this)}assign(t){return this.xmin=t.xmin,this.xmax=t.xmax,this.ymin=t.ymin,this.ymax=t.ymax,this}width(){return this.xmax-this.xmin}height(){return this.ymax-this.ymin}maxDimension(){return Math.max(this.width(),this.height())}minDimension(){return Math.min(this.width(),this.height())}sqrDiagonal(){const t=this.width(),s=this.height();return t*t+s*s}diagonal(){return Math.sqrt(this.sqrDiagonal())}getCenterX(){return .5*(this.xmin+this.xmax)}getCenterY(){return .5*(this.ymin+this.ymax)}getCenter(){return e.construct(this.getCenterX(),this.getCenterY())}queryCenter(t){t.x=.5*(this.xmin+this.xmax),t.y=.5*(this.ymin+this.ymax)}setEmpty(){this.xmin=Number.NaN,this.ymin=Number.NaN,this.xmax=Number.NaN,this.ymax=Number.NaN}setInfinite(){this.xmin=Number.NEGATIVE_INFINITY,this.xmax=Number.POSITIVE_INFINITY,this.ymin=Number.NEGATIVE_INFINITY,this.ymax=Number.POSITIVE_INFINITY}isDegenerate(t){return!this.isEmpty()&&(this.width()<=t||this.height()<=t)}isZero(){return!(this.isEmpty()||this.width()&&this.height())}isEmpty(){return Number.isNaN(this.xmin)||Number.isNaN(this.ymin)||Number.isNaN(this.xmax)||Number.isNaN(this.ymax)}mergeNeCoords(t,s){this.xmin>t?this.xmin=t:this.xmax<t&&(this.xmax=t),this.ymin>s?this.ymin=s:this.ymax<s&&(this.ymax=s)}mergeNe(t){this.mergeNeCoords(t.x,t.y)}mergeCoords(t,s){this.isEmpty()?(this.xmin=t,this.ymin=s,this.xmax=t,this.ymax=s):(this.xmin>t?this.xmin=t:this.xmax<t&&(this.xmax=t),this.ymin>s?this.ymin=s:this.ymax<s&&(this.ymax=s))}merge(t){this.mergeCoords(t.x,t.y)}mergeEnvelope2D(t){t.isEmpty()||(this.mergeCoords(t.xmin,t.ymin),this.mergeNeCoords(t.xmax,t.ymax))}mergePoints(t,s){for(let i=0;i<s;){if(!this.isEmpty()){for(let m=i;m<s;m++)this.mergeNe(t[m]);break}this.setCoords(t[i]),i++}}mergePointsInterleaved(t,s,i){for(let m=2*s,n=m+2*i;m<n;m+=2)this.mergeCoords(t.read(m),t.read(m+1))}inflateCoords(t,s){this.isEmpty()||(this.xmin-=t,this.xmax+=t,this.ymin-=s,this.ymax+=s,(this.xmin>this.xmax||this.ymin>this.ymax)&&this.setEmpty())}getInflatedCoords(t,s){const i=this.clone();return i.inflateCoords(t,s),i}inflate(t){this.inflateCoords(t,t)}getInflated(t){const s=this.clone();return s.inflateCoords(t,t),s}zoom(t,s){this.isEmpty()||this.setCoords({center:this.getCenter(),width:t*this.width(),height:s*this.height()})}scale(t){t<0&&this.setEmpty(),this.xmin*=t,this.xmax*=t,this.ymin*=t,this.ymax*=t}equals(t,s){return!(!this.isEmpty()||!t.isEmpty())||(s?Math.abs(this.xmin-t.xmin)<=s&&Math.abs(this.ymin-t.ymin)<=s&&Math.abs(this.xmax-t.xmax)<=s&&Math.abs(this.ymax-t.ymax)<=s:this.xmin===t.xmin&&this.ymin===t.ymin&&this.xmax===t.xmax&&this.ymax===t.ymax)}setCoords(t){t.xmin!==void 0?(this.xmin=t.xmin,this.xmax=t.xmax,this.ymin=t.ymin,this.ymax=t.ymax):t.x!==void 0?(this.xmin=t.x,this.xmax=t.x,this.ymin=t.y,this.ymax=t.y):t.pt1!==void 0?(this.xmin=t.pt1.x,this.ymin=t.pt1.y,this.xmax=t.pt2.x,this.ymax=t.pt2.y,this.normalize()):t.env2D!==void 0?(this.xmin=t.env2D.xmin,this.xmax=t.env2D.xmax,this.ymin=t.env2D.ymin,this.ymax=t.env2D.ymax,this.normalize()):t.pt!==void 0?(this.xmin=t.pt.x,this.xmax=t.pt.x,this.ymin=t.pt.y,this.ymax=t.pt.y):t.center!==void 0?(this.xmin=t.center.x-.5*t.width,this.xmax=this.xmin+t.width,this.ymin=t.center.y-.5*t.height,this.ymax=this.ymin+t.height,this.normalize()):p("unrecognized input type for setCoords"),this.normalize()}queryIntervalX(t){this.isEmpty()?t.setEmpty():t.setCoords(this.xmin,this.xmax)}queryIntervalY(t){this.isEmpty()?t.setEmpty():t.setCoords(this.ymin,this.ymax)}setFromPoints(t,s){if(s===0)return void this.setEmpty();if(Array.isArray(t)){const m=t;this.setCoords(m[0]);for(let n=1;n<s;){if(!this.isEmpty()){for(let h=n;h<s;h++)this.mergeNe(m[h]);return}this.setCoords(m[n]),n++}return}const i=t;this.setCoords({x:i[0],y:i[1]});for(let m=1,n=2*s;m<n;m+=2){if(!this.isEmpty()){for(let h=m,x=2*s;h<x;h+=2)this.mergeNeCoords(i[h],i[h+1]);return}this.setCoords({x:i[m],y:i[m+1]}),m+=2}}normalize(){let t=!1;this.xmin<=this.xmax||([this.xmin,this.xmax]=[this.xmax,this.xmin],t=!0),this.ymin<=this.ymax||([this.ymin,this.ymax]=[this.ymax,this.ymin],t=!0),!t||this.xmin<=this.xmax&&this.ymin<=this.ymax||this.setEmpty()}isValid(){return this.isEmpty()||this.xmin<=this.xmax&&this.ymin<=this.ymax}getLowerLeft(){return new e(this.xmin,this.ymin)}getLowerRight(){return new e(this.xmax,this.ymin)}getUpperLeft(){return new e(this.xmin,this.ymax)}getUpperRight(){return new e(this.xmax,this.ymax)}move(t,s){this.isEmpty()||(this.xmin+=t,this.ymin+=s,this.xmax+=t,this.ymax+=s)}centerAtCoords(t,s){this.move(t-this.getCenterX(),s-this.getCenterY())}centerAt(t){this.centerAtCoords(t.x,t.y)}containsCoords(t,s){return t>=this.xmin&&t<=this.xmax&&s>=this.ymin&&s<=this.ymax}contains(t){return this.containsCoords(t.x,t.y)}containsEnvelope(t){return t.xmin>=this.xmin&&t.xmax<=this.xmax&&t.ymin>=this.ymin&&t.ymax<=this.ymax}containsExclusiveCoords(t,s){return t>this.xmin&&t<this.xmax&&s>this.ymin&&s<this.ymax}containsExclusive(t){return this.containsExclusiveCoords(t.x,t.y)}containsExclusiveEnvelope(t){return t.xmin>this.xmin&&t.xmax<this.xmax&&t.ymin>this.ymin&&t.ymax<this.ymax}isIntersecting(t){return(this.xmin<=t.xmin?this.xmax>=t.xmin:t.xmax>=this.xmin)&&(this.ymin<=t.ymin?this.ymax>=t.ymin:t.ymax>=this.ymin)}isIntersectingNe(t){return(this.xmin<=t.xmin?this.xmax>=t.xmin:t.xmax>=this.xmin)&&(this.ymin<=t.ymin?this.ymax>=t.ymin:t.ymax>=this.ymin)}intersect(t){if(this.isEmpty())return!1;if(t.isEmpty())return this.setEmpty(),!1;t.xmin>this.xmin&&(this.xmin=t.xmin),t.xmax<this.xmax&&(this.xmax=t.xmax),t.ymin>this.ymin&&(this.ymin=t.ymin),t.ymax<this.ymax&&(this.ymax=t.ymax);const s=this.xmin<=this.xmax&&this.ymin<=this.ymax;return s||this.setEmpty(),s}queryCorner(t){switch(3&t){case 0:return new e(this.xmin,this.ymin);case 1:return new e(this.xmin,this.ymax);case 2:return new e(this.xmax,this.ymax);default:return new e(this.xmax,this.ymin)}}queryCorners(t){t[0].setCoords(this.xmin,this.ymin),t[1].setCoords(this.xmin,this.ymax),t[2].setCoords(this.xmax,this.ymax),t[3].setCoords(this.xmax,this.ymin)}queryCornersReversed(t){t[0].setCoords(this.xmin,this.ymin),t[1].setCoords(this.xmax,this.ymin),t[2].setCoords(this.xmax,this.ymax),t[3].setCoords(this.xmin,this.ymax)}reaspect(t,s){if(this.isEmpty())return;const i=t/s,m=.5*this.width(),n=.5*this.height()*i;if(m<=n){const h=this.getCenterX();this.xmin=h-n,this.xmax=h+n}else{const h=m/i,x=this.getCenterY();this.ymin=x-h,this.ymax=x+h}this.normalize()}getArea(){return this.isEmpty()?0:this.width()*this.height()}getLength(){return this.isEmpty()?0:2*(this.width()+this.height())}clipCode(t){return(t.x<this.xmin?1:0)|(t.x>this.xmax?1:0)<<1|(t.y<this.ymin?1:0)<<2|(t.y>this.ymax?1:0)<<3}clipLine(t,s){let i=this.clipCode(t),m=this.clipCode(s);if(i&m)return 0;if(!(i|m))return 4;const n=(i?1:0)|(m?2:0);do{const h=s.x-t.x,x=s.y-t.y;if(Math.abs(h)>Math.abs(x)?i&r.XMASK?(i&r.XLESSXMIN?(t.y+=x*(this.xmin-t.x)/h,t.x=this.xmin):(t.y+=x*(this.xmax-t.x)/h,t.x=this.xmax),i=this.clipCode(t)):m&r.XMASK?(m&r.XLESSXMIN?(s.y+=x*(this.xmin-s.x)/h,s.x=this.xmin):(s.y+=x*(this.xmax-s.x)/h,s.x=this.xmax),m=this.clipCode(s)):i?(i&r.YLESSYMIN?(t.x+=h*(this.ymin-t.y)/x,t.y=this.ymin):(t.x+=h*(this.ymax-t.y)/x,t.y=this.ymax),i=this.clipCode(t)):(m&r.YLESSYMIN?(s.x+=h*(this.ymin-s.y)/x,s.y=this.ymin):(s.x+=h*(this.ymax-s.y)/x,s.y=this.ymax),m=this.clipCode(s)):i&r.YMASK?(i&r.YLESSYMIN?(t.x+=h*(this.ymin-t.y)/x,t.y=this.ymin):(t.x+=h*(this.ymax-t.y)/x,t.y=this.ymax),i=this.clipCode(t)):m&r.YMASK?(m&r.YLESSYMIN?(s.x+=h*(this.ymin-s.y)/x,s.y=this.ymin):(s.x+=h*(this.ymax-s.y)/x,s.y=this.ymax),m=this.clipCode(s)):i?(i&r.XLESSXMIN?(t.y+=x*(this.xmin-t.x)/h,t.x=this.xmin):(t.y+=x*(this.xmax-t.x)/h,t.x=this.xmax),i=this.clipCode(t)):(m&r.XLESSXMIN?(s.y+=x*(this.xmin-s.x)/h,s.x=this.xmin):(s.y+=x*(this.xmax-s.x)/h,s.x=this.xmax),m=this.clipCode(s)),i&m)return 0}while(i|m);return n}distanceFromEnvelope(t){return Math.sqrt(this.sqrDistanceEnvelope(t,null,null))}distance(t){return Math.sqrt(this.sqrDistance(t))}sqrDistanceEnvelope(t,s,i){if(!s&&!i){if(this.isEmpty()||t.isEmpty())return Number.NaN;let a,o=0,u=0;return a=this.xmin-t.xmax,a>o&&(o=a),a=this.ymin-t.ymax,a>u&&(u=a),a=t.xmin-this.xmax,a>o&&(o=a),a=t.ymin-this.ymax,a>u&&(u=a),o*o+u*u}if(this.isEmpty()||t.isEmpty())return s&&s.setNAN(),i&&i.setNAN(),Number.NaN;let m,n=0,h=0;const x=Math.max(this.xmin,t.xmin),y=Math.max(this.ymin,t.ymin);return s&&s.setCoords(x,y),i&&i.setCoords(x,y),m=this.xmin-t.xmax,m>n&&(n=m,s&&(s.x=this.xmin),i&&(i.x=t.xmax)),m=this.ymin-t.ymax,m>h&&(h=m,s&&(s.y=this.ymin),i&&(i.y=t.ymax)),m=t.xmin-this.xmax,m>n&&(n=m,s&&(s.x=this.xmax),i&&(i.x=t.xmin)),m=t.ymin-this.ymax,m>h&&(h=m,s&&(s.y=this.ymax),i&&(i.y=t.ymin)),n*n+h*h}sqrDistance(t,s){if(s===void 0){if(this.isEmpty()||t.isNAN())return Number.NaN;let h,x=0,y=0;return h=this.xmin-t.x,h>x&&(x=h),h=this.ymin-t.y,h>y&&(y=h),h=t.x-this.xmax,h>x&&(x=h),h=t.y-this.ymax,h>y&&(y=h),x*x+y*y}if(this.isEmpty()||t.isNAN())return s.setNAN(),Number.NaN;s.assign(t);let i,m=0,n=0;return i=this.xmin-t.x,i>m&&(m=i,s.x=this.xmin),i=this.ymin-t.y,i>n&&(n=i,s.y=this.ymin),i=t.x-this.xmax,i>m&&(m=i,s.x=this.xmax),i=t.y-this.ymax,i>n&&(n=i,s.y=this.ymax),m*m+n*n}sqrMaxMinDistanceEnvelope(t){if(this.isEmpty()||t.isEmpty())return Number.NaN;let s=Number.MAX_VALUE;{const i=e.sqrDistanceCoords(this.xmin,this.ymin,t.xmax,t.ymin),m=e.sqrDistanceCoords(this.xmin,this.ymin,t.xmax,t.ymax),n=e.sqrDistanceCoords(this.xmin,this.ymax,t.xmax,t.ymin),h=e.sqrDistanceCoords(this.xmin,this.ymax,t.xmax,t.ymax),x=Math.max(i,m),y=Math.max(n,h),a=Math.max(x,y);s=Math.min(a,s)}{const i=e.sqrDistanceCoords(this.xmin,this.ymin,t.xmin,t.ymax),m=e.sqrDistanceCoords(this.xmin,this.ymin,t.xmax,t.ymax),n=e.sqrDistanceCoords(this.xmax,this.ymin,t.xmin,t.ymax),h=e.sqrDistanceCoords(this.xmax,this.ymin,t.xmax,t.ymax),x=Math.max(i,m),y=Math.max(n,h),a=Math.max(x,y);s=Math.min(a,s)}{const i=e.sqrDistanceCoords(this.xmax,this.ymin,t.xmin,t.ymin),m=e.sqrDistanceCoords(this.xmax,this.ymin,t.xmin,t.ymax),n=e.sqrDistanceCoords(this.xmax,this.ymax,t.xmin,t.ymin),h=e.sqrDistanceCoords(this.xmax,this.ymax,t.xmin,t.ymax),x=Math.max(i,m),y=Math.max(n,h),a=Math.max(x,y);s=Math.min(a,s)}{const i=e.sqrDistanceCoords(this.xmin,this.ymax,t.xmin,t.ymin),m=e.sqrDistanceCoords(this.xmin,this.ymax,t.xmax,t.ymin),n=e.sqrDistanceCoords(this.xmax,this.ymax,t.xmin,t.ymin),h=e.sqrDistanceCoords(this.xmax,this.ymax,t.xmax,t.ymin),x=Math.max(i,m),y=Math.max(n,h),a=Math.max(x,y);s=Math.min(a,s)}return s}sqrMaxDistanceEnvelope(t){if(this.isEmpty()||t.isEmpty())return Number.NaN;let s=0;const i=c(e,4);this.queryCorners(i);const m=c(e,4);t.queryCorners(m);for(let n=0;n<4;n++)for(let h=0;h<4;h++){const x=e.sqrDistance(i[n],m[h]);x>s&&(s=x)}return s}sqrMaxMinDistance(t){const s=e.sqrDistance(t,this.getLowerLeft()),i=e.sqrDistance(t,this.getUpperLeft()),m=e.sqrDistance(t,this.getLowerRight()),n=e.sqrDistance(t,this.getUpperRight());let h,x=Math.max(s,i);return h=Math.max(s,m),x>h&&(x=h),h=Math.max(i,n),x>h&&(x=h),h=Math.max(m,n),x>h&&(x=h),x}sqrMinDistance(t){return this.contains(t)?0:this.sqrDistance(t)}sqrMaxDistance(t){let s=e.sqrDistance(t,this.getLowerLeft());return s=Math.max(e.sqrDistance(t,this.getUpperLeft()),s),s=Math.max(e.sqrDistance(t,this.getUpperRight()),s),s=Math.max(e.sqrDistance(t,this.getLowerRight()),s),s}snapToBoundary(t){if(t.isNAN())return!1;if(this.isEmpty())return t.setNAN(),!0;let s=!0;if(t.x<this.xmin?t.x=this.xmin:t.x>this.xmax?t.x=this.xmax:s=!1,t.y<this.ymin?t.y=this.ymin:t.y>this.ymax?t.y=this.ymax:s=!1,s)return!0;if(t.x===this.xmin||t.x===this.xmax||t.y===this.ymin||t.y===this.ymax)return!1;const i=this.xmax-t.x,m=t.x-this.xmin,n=this.ymax-t.y,h=t.y-this.ymin;return Math.max(i,m)>Math.max(n,h)?t.y=h<n?this.ymin:this.ymax:t.x=m<i?this.xmin:this.xmax,!0}snapClip(t){const s=N(t.x,this.xmin,this.xmax),i=N(t.y,this.ymin,this.ymax);return e.construct(s,i)}boundaryDistance(t){if(this.isEmpty()||t.isNAN())return Number.NaN;if(t.x===this.xmin)return t.y-this.ymin;const s=this.ymax-this.ymin,i=this.xmax-this.xmin;if(t.y===this.ymax)return s+t.x-this.xmin;if(t.x===this.xmax)return s+i+this.ymax-t.y;if(t.y===this.ymin)return 2*s+i+this.xmax-t.x;const m=new e;return m.setCoordsPoint2D(t),this.snapToBoundary(m),this.boundaryDistance(m)}envelopeSide(t){if(this.isEmpty())return-1;let s=this.boundaryDistance(t);const i=this.ymax-this.ymin,m=this.xmax-this.xmin;return s<i?0:(s-=i)<m?1:s-m<i?2:3}querySide(t,s){switch(t){case 0:s.constructFromCoords(this.xmin,this.ymin,this.xmin,this.ymax);break;case 1:s.constructFromCoords(this.xmin,this.ymax,this.xmax,this.ymax);break;case 2:s.constructFromCoords(this.xmax,this.ymax,this.xmax,this.ymin);break;case 3:s.constructFromCoords(this.xmax,this.ymin,this.xmin,this.ymin);break;default:l("query_side")}return s}isPointOnBoundary(t,s){return Math.abs(t.x-this.xmin)<=s||Math.abs(t.x-this.xmax)<=s||Math.abs(t.y-this.ymin)<=s||Math.abs(t.y-this.ymax)<=s}calculateToleranceFromEnvelope(){return this.isEmpty()?d():(Math.abs(this.xmin)+Math.abs(this.xmax)+Math.abs(this.ymin)+Math.abs(this.ymax)+1)*d()}toString(){return`[${this.xmin}, ${this.ymin}, ${this.xmax}, ${this.ymax}]`}}r.XLESSXMIN=1,r.YLESSYMIN=4,r.XMASK=3,r.YMASK=12;export{r as Envelope2D};
