import{bJ as b,a0 as F,_ as r,Y as l,Z as m,aR as P,s as d,D as f}from"./main-CtmwM019.js";import{m as h}from"./Field-Qk7kqJE_.js";import{n as k}from"./locationUtils-DeLFsPu9.js";import{d as q,w as v,g as R}from"./parquet-C3iHxsP7.js";let p=class extends b(F){constructor(n){super(n),this.type=null}};r([l({type:["wkb","location"],nonNullable:!0,readOnly:!0,json:{read:!1,write:{isRequired:!0}}})],p.prototype,"type",void 0),p=r([m("esri.layers.support.ParquetEncodingBase")],p);let a=class extends p{constructor(e){super(e),this.type="location",this.latitudeFieldName=null,this.longitudeFieldName=null}};r([l({type:["location"]})],a.prototype,"type",void 0),r([l({type:String,json:{name:"yField",write:{isRequired:!0}}})],a.prototype,"latitudeFieldName",void 0),r([l({type:String,json:{name:"xField",write:{isRequired:!0}}})],a.prototype,"longitudeFieldName",void 0),a=r([m("esri.layers.support.ParquetEncodingLocation")],a);let u=class extends p{constructor(e){super(e),this.type="wkb",this.primaryFieldName=null}};r([l({type:["wkb"]})],u.prototype,"type",void 0),r([l({type:["counter-clockwise"],json:{write:!0}})],u.prototype,"orientation",void 0),r([l({type:String,json:{name:"field",write:{isRequired:!0}}})],u.prototype,"primaryFieldName",void 0),u=r([m("esri.layers.support.ParquetEncodingWkb")],u);const g=new P({esriGeometryPoint:"point",esriGeometryPolygon:"polygon",esriGeometryPolyline:"polyline",esriGeometryMultipoint:"multipoint"});function J(e){return g.toJSON(e)}function E(e){return g.fromJSON(e)}async function M(e,n={}){if(e.urls.length<1)throw new d("parquet:bad-input","At least one url must be specified",e);if(e.geometryType&&e.spatialReference&&e.encoding&&e.fields)return e;const i=await q(e.urls.getItemAt(0),{getCustomParameters:()=>n.customParameters}),o=v(i),t={...e,file:i};t.fields==null&&(t.fields=i.fields().map(s=>h.fromJSON({name:s.name,alias:s.name,type:s.type}))),t.encoding==null&&(t.encoding=x(o,t.fields));const c=R(i);if(c)switch(c.mode){case"z":t.displayOptimization={mode:"z"};break;case"xz":{const s=c.multiscale;if(!s)throw new d("parquet:bad-format","XZ display optimization requires multiscale geometries");t.displayOptimization={mode:"xz",multiscale:s};break}}if(!t.encoding)return t;switch(t.encoding.type){case"location":t.spatialReference==null&&(t.spatialReference=f.WGS84),t.geometryType==null&&(t.geometryType="point");break;case"wkb":{if(!o)return t;const s=o.primary_column,y=o.columns[s];if(t.geometryType||(t.geometryType=S(y)),t.spatialReference||(t.spatialReference=$(y)),t.fields)for(const w of Object.keys(o.columns))t.fields=t.fields.filter(N=>N.name!==w)}}return t}function x(e,n){if(e!=null){const o=e.primary_column,t=e.columns[o];return new u({primaryFieldName:o,orientation:t.orientation==="counterclockwise"?"counter-clockwise":null})}const i=k(n.map(o=>o.name));return i.latitudeFieldName&&i.longitudeFieldName?new a({latitudeFieldName:i.latitudeFieldName,longitudeFieldName:i.longitudeFieldName}):null}function z(e){switch(e){case"Point":return"point";case"Polygon":case"MultiPolygon":return"polygon";case"LineString":return"polyline";case"MultiPoint":return"multipoint";default:return null}}function S(e){const{geometry_types:n}=e,i=new Set;for(const o of n){const t=z(o);t&&i.add(t)}if(i.size>1)throw new d("parquet:unsupported","Parquet mixed geometry types are not supported",{geometryTypes:i});return i.size===1?i.values().next().value:void 0}function $(e){const n=e.crs?.id?.code;return n&&typeof n=="number"?new f({wkid:n}):void 0}export{p as a,g as c,E as f,a as i,J as p,u as s,M as y};
