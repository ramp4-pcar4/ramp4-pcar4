import{bG as O,cu as T,H as k,bS as B,I as _,ac as E,ci as L,aH as F,e$ as q,aI as U,s as K,i as Q,D as C,B as V}from"./main-CtmwM019.js";import{n as Y}from"./Cyclical-BjYazOTz.js";import{r as z,i as b,o as I,s as D}from"./normalizeUtilsCommon-oR7kIHq_.js";import{f as Z}from"./utils-PyBYdGi0.js";import{r as ee,o as te}from"./utils-CjyZX5Fj.js";async function ne(e,t,i,r){const n=Z(e),l=t[0].spatialReference,o={...r,responseType:"json",query:{...n.query,f:"json",sr:T(l),target:JSON.stringify({geometryType:O(t[0]),geometries:t}),cutter:JSON.stringify(i)}},s=await k(n.path+"/cut",o),{cutIndexes:a,geometries:f=[]}=s.data;return{cutIndexes:a,geometries:f.map(u=>{const m=B(u);return m.spatialReference=l,m})}}async function se(e,t,i){const r=typeof e=="string"?_(e):e,n=t[0].spatialReference,l=O(t[0]),o={...i,query:{...r.query,f:"json",sr:T(n),geometries:JSON.stringify(ee(t))}},{data:s}=await k(r.path+"/simplify",o);return te(s.geometries,l,n)}const X=()=>Q.getLogger("esri.geometry.support.normalizeUtils");function re(e){return e.type==="polygon"}function oe(e){return e[0].type==="polygon"}function ie(e){return e[0].type==="polyline"}function G(e){const t=[];let i=0,r=0;for(let n=0;n<e.length;n++){const l=e[n];let o=null;for(let s=0;s<l.length;s++)o=l[s],t.push(o),s===0?(i=o[0],r=i):(i=Math.min(i,o[0]),r=Math.max(r,o[0]));o&&t.push([(i+r)/2,0])}return t}function le(e,t){if(!(e instanceof F||e instanceof U)){const n="straightLineDensify: the input geometry is neither polyline nor polygon";throw X().error(n),new K("internal:geometry",n)}const i=I(e),r=[];for(const n of i){const l=[];r.push(l),l.push([n[0][0],n[0][1]]);for(let o=0;o<n.length-1;o++){const s=n[o][0],a=n[o][1],f=n[o+1][0],u=n[o+1][1],m=Math.sqrt((f-s)*(f-s)+(u-a)*(u-a)),p=(u-a)/m,d=(f-s)/m,g=m/t;if(g>1){for(let R=1;R<=g-1;R++){const S=R*t,c=d*S+s,h=p*S+a;l.push([c,h])}const $=(m+Math.floor(g-1)*t)/2,A=d*$+s,P=p*$+a;l.push([A,P])}l.push([f,u])}}return re(e)?new U({rings:r,spatialReference:e.spatialReference}):new F({paths:r,spatialReference:e.spatialReference})}function H(e,t,i){if(t){const r=le(e,1e6);e=V(r,!0)}return i&&(e=D(e,i)),e}function J(e,t,i){if(Array.isArray(e)){const r=e[0];if(r>t){const n=b(r,t);e[0]=r+n*(-2*t)}else if(r<i){const n=b(r,i);e[0]=r+n*(-2*i)}}else{const r=e.x;if(r>t){const n=b(r,t);e=e.clone().offset(n*(-2*t),0)}else if(r<i){const n=b(r,i);e=e.clone().offset(n*(-2*i),0)}}return e}function ae(e,t){let i=-1;for(let r=0;r<t.cutIndexes.length;r++){const n=t.cutIndexes[r],l=t.geometries[r],o=I(l);for(let s=0;s<o.length;s++){const a=o[s];a.some(f=>{if(f[0]<180)return!0;{let u=0;for(let p=0;p<a.length;p++){const d=a[p][0];u=d>u?d:u}u=Number(u.toFixed(9));const m=-360*b(u,180);for(let p=0;p<a.length;p++){const d=l.getPoint(s,p);l.setPoint(s,p,d.clone().offset(m,0))}return!0}})}if(n===i){if(oe(e))for(const s of I(l))e[n]=e[n].addRing(s);else if(ie(e))for(const s of I(l))e[n]=e[n].addPath(s)}else i=n,e[n]=l}return e}async function ce(e,t,i){if(!Array.isArray(e))return ce([e],t);t&&typeof t!="string"&&X().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const r=typeof t=="string"?t:t?.url??E.geometryServiceUrl;let n,l,o,s,a,f,u,m,p=0;const d=[],g=[];for(const c of e)if(c!=null)if(n||(n=c.spatialReference,l=L(n),o=n.isWebMercator,f=o?102100:4326,s=z[f].maxX,a=z[f].minX,u=z[f].plus180Line,m=z[f].minus180Line),l)if(c.type==="mesh")g.push(c);else if(c.type==="point")g.push(J(c.clone(),s,a));else if(c.type==="multipoint"){const h=c.clone();h.points=h.points.map(x=>J(x,s,a)),g.push(h)}else if(c.type==="extent"){const h=c.clone()._normalize(!1,!1,l);g.push(h.rings?new U(h):h)}else if(c.extent){const h=c.extent,x=b(h.xmin,a)*(2*s);let M=x===0?c.clone():D(c.clone(),x);h.offset(x,0);let{xmin:w,xmax:y}=h;w=Number(w.toFixed(9)),y=Number(y.toFixed(9)),h.intersects(u)&&y!==s?(p=y>p?y:p,M=H(M,o),d.push(M),g.push("cut")):h.intersects(m)&&w!==a?(p=y*(2*s)>p?y*(2*s):p,M=H(M,o,360),d.push(M),g.push("cut")):g.push(M)}else g.push(c.clone());else g.push(c);else g.push(c);let $=b(p,s),A=-90;const P=$,R=new F;for(;$>0;){const c=360*$-180;R.addPath([[c,A],[c,-1*A]]),A*=-1,$--}if(d.length>0&&P>0){const c=ae(d,await ne(r,d,R,i)),h=[],x=[];for(let y=0;y<g.length;y++){const N=g[y];if(N!=="cut")x.push(N);else{const v=c.shift(),j=e[y];j!=null&&j.type==="polygon"&&j.rings&&j.rings.length>1&&v.rings.length>=j.rings.length?(h.push(v),x.push("simplify")):x.push(o?q(v):v)}}if(!h.length)return x;const M=await se(r,h,i),w=[];for(let y=0;y<x.length;y++){const N=x[y];N!=="simplify"?w.push(N):w.push(o?q(M.shift()):M.shift())}return w}const S=[];for(let c=0;c<g.length;c++){const h=g[c];if(h!=="cut")S.push(h);else{const x=d.shift();S.push(o===!0?q(x):x)}}return S}function me(e){if(!e)return null;const t=e.extent;if(!t)return null;const i=e.spatialReference&&L(e.spatialReference);if(!i)return t;const[r,n]=i.valid,l=2*n,{width:o}=t;let s,{xmin:a,xmax:f}=t;if([a,f]=[f,a],e.type==="extent"||o===0||o<=n||o>l||a<r||f>n)return t;switch(e.type){case"polygon":if(!(e.rings.length>1))return t;s=G(e.rings);break;case"polyline":if(!(e.paths.length>1))return t;s=G(e.paths);break;case"multipoint":s=e.points}const u=t.clone();for(let m=0;m<s.length;m++){let p=s[m][0];p<0?(p+=n,f=Math.max(p,f)):(p-=n,a=Math.min(p,a))}return u.xmin=a,u.xmax=f,u.width<o?(u.xmin-=n,u.xmax-=n,u):t}function ye(e,t,i){const r=L(i);if(r==null)return e;const[n,l]=r.valid,o=2*l;let s=0,a=0;t>l?s=Math.ceil(Math.abs(t-l)/o):t<n&&(s=-Math.ceil(Math.abs(t-n)/o)),e>l?a=Math.ceil(Math.abs(e-l)/o):e<n&&(a=-Math.ceil(Math.abs(e-n)/o));let f=e+(s-a)*o;const u=f-t;return u>l?f-=o:u<n&&(f+=o),f}function xe(e,t){return W(t)?.normalize(e)??e}function W(e){const t=L(e);if(t==null)return null;const[i,r]=t.valid;return new Y(i,r)}const de=W(C.WGS84);W(C.WebMercator);export{de as A,ye as L,ce as P,xe as S,le as b,me as z};
