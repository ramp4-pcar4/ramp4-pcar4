import{bC as at,cc as P,aK as Ae,my as ct,mz as N,e1 as ae,hX as E,mA as Le,me as ce,l_ as lt,l$ as De,bL as K,L as ht,i as ut,s as dt}from"./main-CtmwM019.js";import{a as Y}from"./labelPoint-DnnG3eTE.js";import{r as X}from"./rasterizingUtils-ZEBapkgM.js";import{S as ft,z as pt,d as mt,s as gt,y as yt}from"./CIMSymbolHelper-DKDCpqRw.js";import{s as j,t as D,o as R,c as _t,d as xt,l as Pt,q as Mt}from"./definitions-Bxxl7NsE.js";import{i as A,a as Q,s as Z,d as bt,p as vt,f as wt,m as St,h as kt,g as It,b as zt,c as z,u as Tt,l as le,e as $t,j as At,T as Lt,k as Dt,o as Et,n as Bt,q as Rt,r as Ct,t as Ft,v as Yt}from"./TexturedLineMeshWriter-_h2bJpBD.js";import{d as L,h as F}from"./UpdateTracking2D-VHT7oA2_.js";import{o as Ue,e as Wt}from"./grouping-DwuFyoM7.js";import{R as _}from"./enums-DQOO6RKE.js";import{o as Gt,F as Ot,G as Nt}from"./constants-BBnGEY1d.js";import{_ as Xt,a as Ht}from"./TurboLine-V2R3QRU3.js";import{M as he,i as me,a as Vt,s as Ut}from"./mat2d-Bgm8yl9G.js";import{n as O}from"./mat2df32-Dpt2CT5P.js";import{r as ee}from"./vec2f32-CaVKkSa6.js";import{n as W}from"./vec2f64-Cgb6qxNH.js";import{d as jt,l as Ee}from"./featureConversionUtils-CQ7EbBKb.js";import{e as ue}from"./OptimizedGeometry-CYLi7ZPm.js";import{i as Be}from"./BoundingBox-BSOANoLO.js";import{h as Re,r as Qt}from"./Utils-DsYp0Wpl.js";import{q as je}from"./utils-DQaLv0i_.js";import{u as Zt}from"./ArcadeExpression-BHsVDuiI.js";import{a as qt}from"./AttributeStore-C_mkMGTj.js";let Me=class{static getPlacement(e,t,i,r,s){const n=ft(i);return n?(t===-1&&e.invertY(),n.execute(e,i,r,s)):null}},Qe=class extends Q{};function Jt(o){const{sprite:e,isMapAligned:t,colorLocked:i,scaleSymbolsProportionally:r,isStroke:s}=o;let n=0;return t&&(n|=A(L.bitset.isMapAligned)),i&&(n|=A(L.bitset.colorLocked)),e.sdf&&(n|=A(L.bitset.isSDF)),r&&(n|=A(L.bitset.scaleSymbolsProportionally)),s&&(n|=A(L.bitset.isStroke)),n}function q(o){return o instanceof J?o:typeof o=="object"&&"type"in o?ss[o.type].hydrate(o):new V(o)}let J=class{constructor(e){this.inputs=e}encode(){const e=[];for(const t of this.inputs)e.push(...t.encode());return e.push(...this.instructions),e}},V=class extends J{constructor(e){super([]),this.value=e}simplify(){return this}get instructions(){if(Array.isArray(this.value)){const[e,t,i,r]=this.value;return r!=null?F.vector4.encode([e,t||0,i||0,r]):F.vector3.encode([e,t||0,i||0])}return F.scalar.encode(this.value)}},Kt=class ge extends J{constructor(e,t){super([t]),this._config=e,this._parent=t}static hydrate(e){return new ge(e,q(e.parent))}simplify(){if(this._config.relativeTranslation||this._config.absoluteScale)return this;const e=this._parent.simplify();if(!(e instanceof V))return this;const[t,i,r,s]=e.value,n=this._config.translation.from[0],a=this._config.translation.from[1],c=this._config.rotation.from,l=this._config.scale.from;if(n===this._config.translation.to[0]&&a===this._config.translation.to[1]&&c===this._config.rotation.to&&l===this._config.scale.to){const h=r+c,d=s*l,f=Math.sin(r),u=Math.cos(r);return new V([u*s*n-f*s*a+t,f*s*n+u*s*a+i,h,d])}return new ge(this._config,e)}get instructions(){return F.animatedTransform.encode(this._config)}},es=class ye extends J{constructor(e,t){super([t]),this._config=e,this._parent=t}static hydrate(e){return new ye(e,q(e.parent))}simplify(){const e=this._parent.simplify();if(!(e instanceof V))return this;const[t,i,r,s]=e.value,n=this._config.color.from[0],a=this._config.color.from[1],c=this._config.color.from[2];let l=this._config.color.from[3];const h=this._config.opacity.from;return n===this._config.color.to[0]&&a===this._config.color.to[1]&&c===this._config.color.to[2]&&l===this._config.color.to[3]&&h===this._config.opacity.to?(l*=h,new V([t*n,i*a,r*c,s*l])):new ye(this._config,e)}get instructions(){return F.animatedColor.encode(this._config)}},ts=class _e extends J{constructor(e,t){super([t]),this._config=e,this._parent=t}static hydrate(e){return new _e(e,q(e.parent))}simplify(){const e=this._parent.simplify();return e instanceof V?new _e(this._config,e):this}get instructions(){return F.animatedShift.encode(this._config)}};const ss={AnimatedTransform:Kt,AnimatedColor:es,AnimatedShift:ts};function is(o){return Ze(o.map(e=>I(e)).map(e=>q(e).simplify()))}function rs(o){const e=[];return e.push(o.transform),e.push(o.fromColor),e.push(o.toColor),e.push(o.colorMix),e.push(o.toOpacity),e.push(o.opacityMix),o?.shift?e.push(o?.shift):e.push([1,1,1,1]),e}function Ze(o){const e=[],t=[];let i=0;for(const r of o){const s=[...r.encode(),...F.ret.encode()];e.push([i+o.length,0,0,0]),t.push(...s),i+=s.length}return[...e,...t]}async function xe(o,e){const t=o;let i;if(typeof t=="number"||typeof t=="string"||typeof t=="boolean")i=t;else if(Array.isArray(t))i=await Promise.all(t.map(r=>xe(r,e)));else if(typeof t=="object")if("valueExpressionInfo"in t){const{valueExpressionInfo:r}=t,{expression:s}=r;i={...t,computed:await e.createComputedField({expression:s})}}else{i={};for(const r in t)i[r]=await xe(t[r],e)}return i}function I(o,e,t){function i(n){if(!("computed"in n))return n;let a=n.computed.readWithDefault(e,t,[255*n.defaultValue[0],255*n.defaultValue[1],255*n.defaultValue[2],n.defaultValue[3]]);if(typeof a=="string"){const c=at.fromString(a);c&&(a=[c.r,c.g,c.b,c.a])}return a}const r=o;let s;if(typeof r=="number"||typeof r=="string"||typeof r=="boolean")s=r;else if(Array.isArray(r))s=r.map(n=>I(n,e,t));else if(typeof r=="object")if("type"in r&&r.type!=null&&r.type==="Process")switch(r.op){case"ArcadeColor":{const n=I(r.value,e,t);U(Array.isArray(n)&&n.length===4),s=[n[0]/255,n[1]/255,n[2]/255,n[3]]}break;case"Transparency":{const n=I(r.value,e,t);U(typeof n=="number"),s=1-n/100}break;case"Divide":case"Multiply":case"Add":{const n=I(r.left,e,t);U(typeof n=="number");const a=I(r.right,e,t);switch(U(typeof a=="number"),r.op){case"Divide":s=n/a;break;case"Multiply":s=n*a;break;case"Add":s=n+a}}break;case"Random":{const n=I(r.seed,e,t),a=I(r.min,e,t),c=I(r.max,e,t),l=e.getObjectId(),h=Ue(l||0);s=a+Wt(h,n)*(c-a)}break;case"Cond":{const n=I(r.condition,e,t),a=I(r.ifTrue,e,t),c=I(r.ifFalse,e,t);s=n?a:c}break;case"MatchWinding":{const n=I(r.sign,e,t);let a=I(r.angle,e,t);if(n>0)for(;a<0;)a+=2*Math.PI;else for(;a>0;)a-=2*Math.PI;s=a}}else if("computed"in r)s=i(r);else{s={};for(const n in r)s[n]=I(r[n],e,t)}return s}function*T(o){const e=o;if(Array.isArray(e))for(const t of e)yield*T(t);else if(typeof e=="object")if("type"in e&&e.type!=null&&e.type==="Process")switch(e.op){case"ArcadeColor":case"Transparency":yield*T(e.value);break;case"Divide":case"Multiply":case"Add":yield*T(e.left),yield*T(e.right);break;case"Random":yield*T(e.seed),yield*T(e.min),yield*T(e.max);break;case"Cond":yield*T(e.condition),yield*T(e.ifTrue),yield*T(e.ifFalse);break;case"MatchWinding":yield*T(e.sign),yield*T(e.angle)}else if("computed"in e)yield e.computed;else for(const t in e)yield*T(e[t])}function U(o){if(!o)throw new Error("Assertion failed.")}const be={type:_.SHORT,count:2,packPrecisionFactor:j,pack:({scaleInfo:o},{tileInfo:e})=>Z(o,e)},os={type:_.FLOAT,count:4,packPrecisionFactor:1,packTessellation:({value1Position2Value2:o})=>(U(o),o)},qe={type:_.FLOAT,count:4,packPrecisionFactor:1,packTessellation:()=>[0,0,0,1]},ns={type:_.FLOAT,count:1,packPrecisionFactor:1,pack:()=>0},Je={type:_.FLOAT,count:1,packPrecisionFactor:1,packTessellation:({lineLength:o})=>o},as={type:_.UNSIGNED_SHORT,count:1,packTessellation:({distance:o})=>o},cs={type:_.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:o,directionY:e})=>[o,e]},ls={type:_.FLOAT,count:2,packPrecisionFactor:16,packTessellation:({normalX:o,normalY:e})=>[o,e]},ve={type:_.UNSIGNED_BYTE,count:3,pack:"id"},we={type:_.UNSIGNED_BYTE,count:1,pack:Jt},Se={type:_.SHORT,count:2,pack:"position",packPrecisionFactor:1},ke={marker:{type:_.FLOAT,count:2,packAlternating:{count:4,pack:({texelDimensions:o})=>[[-.5*o[0],-.5*o[1]],[.5*o[0],-.5*o[1]],[-.5*o[0],.5*o[1]],[.5*o[0],.5*o[1]]]}},line:{type:_.FLOAT,count:2,packTessellation:({extrusionOffsetX:o,extrusionOffsetY:e},{baseSize:t})=>[o*t/2,e*t/2]},fill:{type:_.FLOAT,count:2,packTessellation:()=>[0,0]}},hs={marker:{type:_.SHORT,count:2,packPrecisionFactor:1,packAlternating:{count:4,packTessellation:({texXmax:o,texXmin:e,texYmax:t,texYmin:i})=>[[e,i],[o,i],[e,t],[o,t]]}}},Ke={type:_.UNSIGNED_SHORT,count:4,pack:({sprite:o})=>{const{rect:e,width:t,height:i}=o,r=e.x+D,s=e.y+D;return[r+1,s+1,r+t-1,s+i-1]}},Ie={type:_.UNSIGNED_SHORT,count:4,packPrecisionFactor:4,pack:({animations:o,baseSize:e,referenceSize:t})=>[o.dataColumn,o.dataRow,e,t]},ze={type:_.UNSIGNED_SHORT,count:4,packPrecisionFactor:8,pack:({strokeWidth:o,pixelDimensions:e,baseSize:t,sprite:i,sizeRatio:r})=>{const s=Math.max(t*i.width/i.height,t),n=i.sdfDecodeCoeff*s*r;return[e[0],e[1],o,n]}},us={type:_.BYTE,count:1,packTessellation:({angle:o})=>o};function Te(o){let{pixelDimensions:e,texelDimensions:t,baseSize:i,referenceSize:r,strokeWidth:s,sizeRatio:n}=o;if(e||(e=o.sprite.sdf?[0,0]:[o.sprite.width,o.sprite.height]),t||(t=o.sprite.sdf?[0,0]:e),o.patternHeight!=null){const c=o.patternHeight/e[1];e[1]*=c,e[0]*=c}i===-1&&(i=e[1]),i=P(i),r=P(r),s=P(s);const a=(o.sprite.sdfDecodeCoeff??1)*n;return{...o,pixelDimensions:e,texelDimensions:t,baseSize:i,referenceSize:r,strokeWidth:s,sdfDecodeCoeff:a}}const de=64,ds=64,fs=2;let et=class extends Qe{get vertexSpec(){return{createComputedParams:Te,optionalAttributes:{zoomRange:be,value1Position2Value2:os,lineLength:Je},attributes:{id:ve,bitset:we,pos:Se,offset:ke.marker,uv:hs.marker,animationPointerAndBaseSizeAndReferenceSize:Ie,sizing:ze,angle:us}}}_write(e,t,i){const r=this.evaluatedMeshParams.sprite,{textureBinding:s}=r;e.recordStart(this.instanceId,this.attributeLayout,s);const n=t.getDisplayId();if(this.shift&&t.geometryType==="esriGeometryPolyline"){if(!i){const a=Y.fromFeatureSetReaderCIM(t);a&&this._writeParticles(e,t,a)}}else if(this.evaluatedMeshParams.placement!=null)this._writePlacedMarkers(e,t);else if(t.geometryType==="esriGeometryPolygon"){const a=t.readCentroidForDisplay();if(!a)return;const[c,l]=a.coords;this._writeQuad(e,n,c,l)}else if(t.geometryType==="esriGeometryPoint"){const a=t.readXForDisplay(),c=t.readYForDisplay();this._writeQuad(e,n,a,c)}else{const a=t.readGeometryForDisplay();a&&a.forEachVertex((c,l)=>{this._writeQuad(e,n,c,l)})}e.recordEnd()}_writePlacedMarkers(e,t){const i=Y.fromFeatureSetReaderCIM(t)?.clone();if(!i)return;const r=-1,s=Me.getPlacement(i,r,this.evaluatedMeshParams.placement,P(1),e.id);if(!s)return;const n=t.getDisplayId();let a=s.next(),c=null;for(;a!=null;){const l=a.tx,h=-a.ty;if(Math.abs(l)>X||Math.abs(h)>X){a=s.next();continue}const d=-a.getAngle();e.recordBounds(l,h,de,ds),this.shift?c&&this._writeQuad(e,n,c[0],c[1],void 0,d):this._writeQuad(e,n,l,h,void 0,d),c=[l,h],a=s.next()}}_writeParticles(e,t,i){const r=t.getDisplayId();for(;i.nextPath();){const s=[];for(;i.nextPoint();)s.push([i.x,i.y]);const n=ps(s);let a=0;for(let h=1;h<s.length;h++){const d=s[h][0]-s[h-1][0],f=s[h][1]-s[h-1][1],u=Math.sqrt(d*d+f*f);a+=u}const c=h=>{for(const d of n){const{a:f,b:u}=d;this._writeQuad(e,r,f.position[0],f.position[1],[f.distance-h,u.position[0],u.position[1],u.distance-h],this.evaluatedMeshParams.angleToLine?Math.atan2(f.direction[1],f.direction[0]):0,a,!0)}},{placement:l}=this.evaluatedMeshParams;if(!l||"placementTemplate"in l||l.type==="CIMMarkerPlacementOnVertices"){let h;if(l&&l.type!=="CIMMarkerPlacementOnVertices")h=l.placementTemplate;else{h=[0];for(const f of n){const{a:u,b:p}=f,m=u.position[0]-p.position[0],g=u.position[1]-p.position[1],y=Math.sqrt(m*m+g*g);h.push(y)}}let d=-1*a;for(;d<(1+fs/2)*a;)for(const f of h)d+=f,c(d)}else l.type==="CIMMarkerPlacementAtExtremities"?l.extremityPlacement==="JustBegin"?c(1):l.extremityPlacement==="JustEnd"?(c(a-1),c(-1)):l.extremityPlacement==="Both"&&(c(1),c(a-1)):l.type==="CIMMarkerPlacementOnLine"&&(l.relativeTo==="LineBeginning"?c(1):l.relativeTo==="LineEnd"?(c(a-1),c(-1)):l.relativeTo==="LineMiddle"&&c(a/2))}}_writeQuad(e,t,i,r,s,n=0,a=0,c=!1){const l=this.evaluatedMeshParams.sprite,{rect:h}=l,d=h.x+D,f=h.y+D,u=h.x+h.width-D,p=h.y+h.height-D,m=e.vertexCount();c||e.recordBounds(i,r,de,de);const g={texXmin:d,texYmin:f,texXmax:u,texYmax:p,value1Position2Value2:s,angle:n/Gt,lineLength:a};for(let y=0;y<4;y++)this._writeVertex(e,t,i,r,g);e.indexEnsureSize(6),e.indexWrite(m),e.indexWrite(m+1),e.indexWrite(m+2),e.indexWrite(m+1),e.indexWrite(m+3),e.indexWrite(m+2)}};function ps(o){const e=[];let t=0;for(let i=1;i<o.length;i++){const r=o[i-1],s=o[i],n=s[0]-r[0],a=s[1]-r[1],c=Math.sqrt(n*n+a*a),l=n/c,h=a/c;e.push({a:{position:r,distance:t,direction:[l,h]},b:{position:s,distance:t+c,direction:[l,h]}}),t+=c}return e}let ms=class extends et{constructor(){super(...arguments),this.shift=!1}},gs=class extends et{constructor(){super(...arguments),this.shift=!0}};class tt extends Qe{_write(e,t,i){const r=i??Y.fromFeatureSetReaderCIM(t);if(!r)return;const s=this.evaluatedMeshParams.sprite,{textureBinding:n}=s;e.recordStart(this.instanceId,this.attributeLayout,n);const a=t.getDisplayId();this._writePoly(e,a,r.asOptimized()),e.recordEnd()}}let ys=class extends tt{constructor(){super(...arguments),this.vertexSpec={createComputedParams:Te,attributes:{id:ve,bitset:we,pos:Se,offset:ke.fill,tlbr:Ke,animationPointerAndBaseSizeAndReferenceSize:Ie,sizing:ze},optionalAttributes:{zoomRange:be,value1Position2Value2:qe,lineLength:ns}}}_writePoly(e,t,i){const r=this._clip(i);if(!r)return;i=r;const s=[],n=e.vertexCount();let a;if(kt(s,i)){if(s.length===0)return;a=0;for(const c of s){const l=i.coords[2*c],h=i.coords[2*c+1];this._writeVertex(e,t,l,h),a++}}else{const{coords:c,lengths:l}=i,h=Ht(c,l);a=h.vertexCount;for(let d=0;d<h.buffer.length/2;d++){const f=h.buffer[2*d],u=h.buffer[2*d+1];this._writeVertex(e,t,f,u)}}if(a>0){e.indexEnsureSize(a);for(let c=0;c<a;c++)e.indexWrite(c+n)}}_clip(e){const t=this.hasEffects;return It(e,t?256:8)}},_s=class{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0}};const Ce=65535;let xs=class extends tt{constructor(){super(...arguments),this.vertexSpec={createComputedParams:Te,attributes:{id:ve,bitset:we,pos:Se,offset:ke.line,tlbr:Ke,animationPointerAndBaseSizeAndReferenceSize:Ie,sizing:ze,accumulatedDistance:as,normal:ls,segmentDirection:cs},optionalAttributes:{zoomRange:be,value1Position2Value2:qe,lineLength:Je}},this._tessParams=new bt,this._currentWrite=new _s,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:Ce,textured:!1},this._lineLength=0,this._lineTessellator=new Xt((e,t,i,r,s,n,a,c,l,h,d)=>this._writeTesselatedVertex(e,t,i,r,s,n,a,c,l,h,d,this._lineLength),this._writeTriangle.bind(this),!1)}_writePoly(e,t,i){const n=vt(Y.fromOptimized(i,"esriGeometryPolyline"),64);if(n==null)return;const{_currentWrite:a,_tessellationOptions:c}=this,{baseSize:l,capType:h,joinType:d,miterLimit:f}=this.evaluatedMeshParams,u=P(.5*l);c.halfWidth=u,c.capType=wt(h||"Round"),c.joinType=St(d||"Round"),c.miterLimit=f||2,a.out=e,a.id=t,a.vertexCount=0,a.indexCount=0,a.vertexFrom=e.vertexCount(),a.vertexBounds=1;for(const{line:p,start:m,pathLength:g}of n){c.initialDistance=m%Ce,a.pathLength=g,this._lineLength=0;for(let y=1;y<p.length;y++){const x=p[y].x-p[y-1].x,b=p[y].y-p[y-1].y;this._lineLength+=Math.sqrt(x*x+b*b)}this._lineTessellator.tessellate(p,c,!1)}}_writeTesselatedVertex(e,t,i,r,s,n,a,c,l,h,d,f){const{out:u,id:p,vertexBounds:m,pathLength:g}=this._currentWrite;return this.hasEffects&&u.recordBounds(e,t,m,m),this._tessParams.extrusionOffsetX=a,this._tessParams.extrusionOffsetY=c,this._tessParams.normalX=l,this._tessParams.normalY=h,this._tessParams.directionX=s,this._tessParams.directionY=n,this._tessParams.distance=d,this._tessParams.pathLength=g,this._tessParams.lineLength=f,this._writeVertex(u,p,e,t,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(e,t,i){const{out:r}=this._currentWrite;r.indexEnsureSize(3),r.indexWrite(e),r.indexWrite(t),r.indexWrite(i),this._currentWrite.indexCount+=3}};const Ps={createComputedParams:o=>o,optionalAttributes:{},attributes:{id:{type:_.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:_.UNSIGNED_BYTE,count:1},pos:{type:_.SHORT,count:2,pack:"position",packPrecisionFactor:10},inverseArea:{type:_.FLOAT,count:1,packTessellation:({inverseArea:o})=>o}}};let Ms=class extends zt{constructor(){super(...arguments),this.vertexSpec=Ps}createTesselationParams(e){return{inverseArea:1/e.readGeometryArea()}}};const bs={createComputedParams:o=>o,optionalAttributes:{},attributes:{pos:{type:_.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:_.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:_.UNSIGNED_BYTE,count:1},offset:{type:_.BYTE,count:2,packAlternating:{count:4,pack:()=>[[-1,-1],[1,-1],[-1,1],[1,1]]}}}};let vs=class extends Q{constructor(){super(...arguments),this.vertexSpec=bs}_write(e,t){e.recordStart(this.instanceId,this.attributeLayout);const i=t.getDisplayId();if(t.geometryType==="esriGeometryPoint"){const r=t.readXForDisplay(),s=t.readYForDisplay();this._writeQuad(e,i,r,s)}else t.geometryType==="esriGeometryMultipoint"&&t.readGeometryForDisplay()?.forEachVertex((s,n)=>{s>=0&&s<=512&&n>=0&&n<=512&&this._writeQuad(e,i,s,n)});e.recordEnd()}_writeQuad(e,t,i,r){const s=e.vertexCount();this._writeVertex(e,t,i,r),e.indexWrite(s+0),e.indexWrite(s+1),e.indexWrite(s+2),e.indexWrite(s+1),e.indexWrite(s+3),e.indexWrite(s+2)}};function Fe(o,e,t){return o[0]=e[0]-t[0],o[1]=e[1]-t[1],o}function st(o,e){return Math.sqrt(o*o+e*e)}function Ye(o){const e=st(o[0],o[1]);o[0]/=e,o[1]/=e}function ws(o,e){return st(o[0]-e[0],o[1]-e[1])}function Ss(o,e){return o[e+1]}function it(o){return o.length-1}function ks(o){let e=0;for(let t=0;t<it(o);t++)e+=Is(o,t);return e}function Is(o,e,t=1){let[i,r]=Ss(o,e);return[i,r]=[Math.round(i),Math.round(r)],Math.sqrt(i*i+r*r)*t}class re{constructor(e,t,i,r,s){this._segments=e,this._index=t,this._distance=i,this._xStart=r,this._yStart=s,this._done=!1}static create(e){return new re(e,0,0,e[0][0],e[0][1])}clone(){return new re(this._segments,this._index,this._distance,this.xStart,this.yStart)}equals(e){return this._index===e._index||e._index===this._index-1&&(this._distance===0||e._distance===1)||e._index===this._index+1&&(this._distance===1||e._distance===0)}leq(e){return this._index<e._index||this._index===e._index&&this._distance<=e._distance}geq(e){return this._index>e._index||this._index===e._index&&this._distance>=e._distance}get _segment(){return this._segments[this._index+1]}get angle(){const e=this.dy,t=(0*e+-1*-this.dx)/(1*this.length);let i=Math.acos(t);return e>0&&(i=2*Math.PI-i),i}get xStart(){return this._xStart}get yStart(){return this._yStart}get x(){return this.xStart+this.distance*this.dx}get y(){return this.yStart+this.distance*this.dy}get dx(){return this._segment[0]}get dy(){return this._segment[1]}get xMidpoint(){return this.xStart+.5*this.dx}get yMidpoint(){return this.yStart+.5*this.dy}get xEnd(){return this.xStart+this.dx}get yEnd(){return this.yStart+this.dy}get length(){const{dx:e,dy:t}=this;return Math.sqrt(e*e+t*t)}get remainingLength(){return this.length*(1-this._distance)}get backwardLength(){return this.length*this._distance}get distance(){return this._distance}get done(){return this._done}hasPrev(){return this._index-1>=0}hasNext(){return this._index+1<it(this._segments)}next(){return this.hasNext()?(this._xStart+=this.dx,this._yStart+=this.dy,this._distance=0,this._index+=1,this):null}prev(){return this.hasPrev()?(this._index-=1,this._xStart-=this.dx,this._yStart-=this.dy,this._distance=1,this):(this._done=!0,null)}_seekBackwards(e,t){const i=this.backwardLength;if(e<=i)return this._distance=(i-e)/this.length,this;let r=this.backwardLength;for(;this.prev();){if(r+this.length>e)return this._seekBackwards(e-r);r+=this.length}return this._distance=0,t?this:null}seek(e,t=!1){if(e<0)return this._seekBackwards(Math.abs(e),t);if(e<=this.remainingLength)return this._distance=(this.backwardLength+e)/this.length,this;let i=this.remainingLength;for(;this.next();){if(i+this.length>e)return this.seek(e-i,t);i+=this.length}return this._distance=1,t?this:null}}function fe(o,e,t,i=!0){const r=ks(o),s=re.create(o),n=r/2;if(!i)return s.seek(n),void(s.x<R&&s.y<R&&s.x>=0&&s.y>=0&&t(s.clone(),0,n+0*e,r));const a=Math.max((r-e)/2,0),c=Math.floor(a/e),l=n-c*e;s.seek(l);for(let h=-c;h<=c;h++)s.x<R&&s.y<R&&s.x>=0&&s.y>=0&&t(s.clone(),h,n+h*e,r),s.seek(e)}function pe(o,e){const t=e;for(let i=0;i<o.length;i++){let r=o[i];zs(r,t);const s=[];s.push(r[0]);for(let n=1;n<r.length;n++){const[a,c]=r[n-1],[l,h]=r[n],d=l-a,f=h-c;s.push([d,f])}o[i]=s,r=s}return o}function zs(o,e){if(e<=0)return;const i=o.length;if(i<3)return;const r=[];let s=0;r.push(0);for(let d=1;d<i;d++)s+=ws(o[d],o[d-1]),r.push(s);e=Math.min(e,.2*s);const n=[];n.push(o[0][0]),n.push(o[0][1]);const a=o[i-1][0],c=o[i-1][1],l=Fe([0,0],o[0],o[1]);Ye(l),o[0][0]+=e*l[0],o[0][1]+=e*l[1],Fe(l,o[i-1],o[i-2]),Ye(l),o[i-1][0]+=e*l[0],o[i-1][1]+=e*l[1];for(let d=1;d<i;d++)r[d]+=e;r[i-1]+=e;const h=.5*e;for(let d=1;d<i-1;d++){let f=0,u=0,p=0;for(let m=d-1;m>=0&&!(r[m+1]<r[d]-h);m--){const g=h+r[m+1]-r[d],y=r[m+1]-r[m],x=r[d]-r[m]<h?1:g/y;if(Math.abs(x)<1e-6)break;const b=x*x,M=x*g-.5*b*y,w=x*y/e,v=o[m+1],S=o[m][0]-v[0],k=o[m][1]-v[1];f+=w/M*(v[0]*x*g+.5*b*(g*S-y*v[0])-b*x*y*S/3),u+=w/M*(v[1]*x*g+.5*b*(g*k-y*v[1])-b*x*y*k/3),p+=w}for(let m=d+1;m<i&&!(r[m-1]>r[d]+h);m++){const g=h-r[m-1]+r[d],y=r[m]-r[m-1],x=r[m]-r[d]<h?1:g/y;if(Math.abs(x)<1e-6)break;const b=x*x,M=x*g-.5*b*y,w=x*y/e,v=o[m-1],S=o[m][0]-v[0],k=o[m][1]-v[1];f+=w/M*(v[0]*x*g+.5*b*(g*S-y*v[0])-b*x*y*S/3),u+=w/M*(v[1]*x*g+.5*b*(g*k-y*v[1])-b*x*y*k/3),p+=w}n.push(f/p),n.push(u/p)}n.push(a),n.push(c);for(let d=0,f=0;d<i;d++)o[d][0]=n[f++],o[d][1]=n[f++]}const We=96;class Ts{constructor(e){const{offsetX:t,offsetY:i,postAngle:r,fontSize:s,haloSize:n,outlineSize:a,scaleFactor:c,transforms:l}=e;if(this.offsetX=t,this.offsetY=i,this.postAngle=r,this.fontSize=Math.min(s,We),this.haloSize=n??0,this.outlineSize=a??0,this.transforms=l,l&&l.infos.length>1){const h=je(s,r,!1,t,i,l,!1);this.fontSize=Math.min(h.size,We);const d=h.size/s;this.haloSize*=d,this.outlineSize*=d,this.postAngle=h.rotation,this.offsetX=h.offsetX,this.offsetY=h.offsetY}c&&(this.fontSize*=c,this.offsetX*=c,this.offsetY*=c)}}const H=28,C=[4,4],te=[16,4],$s={topLeft:te,topRight:te,bottomLeft:te,bottomRight:te},oe=[4,2],$=[4,6],Ge={topLeft:oe,topRight:oe,bottomLeft:$,bottomRight:$},Oe={topLeft:oe,topRight:$,bottomLeft:oe,bottomRight:$},As={topLeft:$,topRight:$,bottomLeft:C,bottomRight:C},Ls={topLeft:C,topRight:C,bottomLeft:$,bottomRight:$},Ds={topLeft:$,topRight:C,bottomLeft:$,bottomRight:C},Es={topLeft:C,topRight:$,bottomLeft:C,bottomRight:$},Bs={createComputedParams:o=>o,optionalAttributes:{zoomRange:{type:_.UNSIGNED_SHORT,count:2,packPrecisionFactor:j,packTessellation:({minZoom:o,maxZoom:e})=>[o||0,e||H]},clipAngle:{type:_.UNSIGNED_BYTE,count:1,packTessellation:({clipAngle:o})=>Rs(o||0)},referenceSymbol:{type:_.BYTE,count:4,packPrecisionFactor:1,packTessellation:(o,e)=>{const t=o.isLineLabel||!o.referenceBounds,i=mt(t?"center":e.horizontalAlignment),r=gt(t?"middle":e.verticalAlignment),{offsetX:s,offsetY:n,size:a}=t?{offsetX:0,offsetY:0,size:0}:o.referenceBounds;return[P(s),-P(n),Math.round(P(a)),i+1<<2|r+1]}},visibility:{type:_.FLOAT,count:1,otherSource:!0}},attributes:{pos:{type:_.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:_.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:_.UNSIGNED_BYTE,count:1,packTessellation:({isBackground:o,mapAligned:e})=>Tt([[Ot,o],[Nt,!!e]])},offset:{type:_.SHORT,count:2,packPrecisionFactor:8,packAlternating:{count:4,packTessellation:({offsets:o})=>{const{bottomLeft:e,bottomRight:t,topLeft:i,topRight:r}=o;return[i,r,e,t]}}},textureUV:{type:_.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,packTessellation:({texcoords:o})=>{const{bottomLeft:e,bottomRight:t,topLeft:i,topRight:r}=o;return[i,r,e,t]}}},color:{type:_.UNSIGNED_BYTE,count:4,normalized:!0,packTessellation:({color:o})=>o},fontAndReferenceSize:{type:_.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({fontSize:o},{referenceSize:e})=>[Math.round(P(o)),Math.round(P(e??o))]},outlineColor:{type:_.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:o})=>z(o)},haloColor:{type:_.UNSIGNED_BYTE,count:4,normalized:!0,pack:({haloColor:o})=>z(o)},outlineAndHaloSize:{type:_.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({outlineSize:o,haloSize:e})=>[Math.round(P(o)),Math.round(P(e))]}}};class rt extends Q{constructor(){super(...arguments),this.vertexSpec=Bs,this._textMeshParamsPropsInitialized=!1}ensurePacked(e,t,i){super.ensurePacked(e,t,i),this._textMeshParamsPropsInitialized&&!this._evaluator.hasDynamicProperties||(this._textMeshTransformProps=new Ts(this.evaluatedMeshParams),this._textMeshParamsPropsInitialized=!0)}_write(e,t,i){const r=this._getShaping();if(!r)return;const s=t.getDisplayId();if(this.evaluatedMeshParams.placement!=null)return this._writePlacedTextMarkers(e,t,r,i);if(i?.nextPath())return i.nextPoint(),this._writeGlyphs(e,s,i.x,i.y,r,0);if(t.geometryType==="esriGeometryPolygon"){const c=t.readCentroidForDisplay();if(!c)return;const[l,h]=c.coords;return this._writeGlyphs(e,s,l,h,r,0)}if(t.geometryType==="esriGeometryMultipoint")return void t.readGeometryForDisplay()?.forEachVertex((l,h)=>this._writeGlyphs(e,s,l,h,r,0));const n=t.readXForDisplay(),a=t.readYForDisplay();return this._writeGlyphs(e,s,n,a,r,0)}_writePlacedTextMarkers(e,t,i,r){const s=r??Y.fromFeatureSetReaderCIM(t);if(!s)return;const n=-1,a=Me.getPlacement(s,n,this.evaluatedMeshParams.placement,P(1),e.id);if(!a)return;const c=t.getDisplayId();let l=a.next();for(;l!=null;){const h=l.tx,d=-l.ty,f=-l.getAngle();this._writeGlyphs(e,c,h,d,i,f),l=a.next()}}_getShaping(e){const t=this._textMeshTransformProps,i=this.evaluatedMeshParams;if(!i.glyphs?.glyphs.length)return null;const r=P(t.fontSize),s=P(t.offsetX),n=P(t.offsetY),a=Ae(P(i.lineWidth),xt,_t),c=Pt*Ae(i.lineHeightRatio,.25,4);return pt(i.glyphs,{scale:r/Mt,angle:t.postAngle,xOffset:s,yOffset:n,horizontalAlignment:i.horizontalAlignment,verticalAlignment:e||i.verticalAlignment,maxLineWidth:a,lineHeight:c,decoration:i.decoration,borderLineSizePx:P(i.boxBorderLineSize),hasBackground:!!i.boxBackgroundColor,useCIMAngleBehavior:i.useCIMAngleBehavior})}_writeGlyphs(e,t,i,r,s,n,a,c,l=!0){const h=this.evaluatedMeshParams,d=this._textMeshTransformProps,f=P(d.fontSize),u=d.haloSize,p=d.outlineSize,m=P(d.offsetX),g=P(d.offsetY),[y,x]=Z(h.scaleInfo,this.getTileInfo());n!==0&&s.setRotation(n);const b=s.bounds,M=i+b.x+m,w=r+b.y-g,v=2*(h.minPixelBuffer?h.minPixelBuffer/f:1),S=Math.max(b.width,b.height)*v;s.textBox&&(e.recordStart(this.instanceId,this.attributeLayout,s.glyphs[0].textureBinding),l&&e.recordBounds(M,w,S,S),this._writeTextBox(e,t,i,r,s.textBox,a,c),e.recordEnd());for(const k of s.glyphs){e.recordStart(this.instanceId,this.attributeLayout,k.textureBinding),l&&e.recordBounds(M,w,S,S);const{texcoords:B,offsets:nt}=k;this._writeQuad(e,t,i,r,{texcoords:B,offsets:nt,fontSize:f,haloSize:u,outlineSize:p,color:z(h.color),isBackground:!1,referenceBounds:a,minZoom:y,maxZoom:x,...c}),e.recordEnd()}n!==0&&s.setRotation(-n)}_writeTextBox(e,t,i,r,s,n,a){const c=this.evaluatedMeshParams,{fontSize:l,haloSize:h,outlineSize:d}=this._textMeshTransformProps,{boxBackgroundColor:f,boxBorderLineColor:u}=c,p={isBackground:!0,fontSize:l,haloSize:h,outlineSize:d,referenceBounds:n,...a};f&&(this._writeQuad(e,t,i,r,{texcoords:$s,offsets:s.main,color:z(f),...p}),u||(this._writeQuad(e,t,i,r,{texcoords:As,offsets:s.top,color:z(f),...p}),this._writeQuad(e,t,i,r,{texcoords:Ls,offsets:s.bot,color:z(f),...p}),this._writeQuad(e,t,i,r,{texcoords:Ds,offsets:s.left,color:z(f),...p}),this._writeQuad(e,t,i,r,{texcoords:Es,offsets:s.right,color:z(f),...p}))),u&&(this._writeQuad(e,t,i,r,{texcoords:Ge,offsets:s.top,color:z(u),...p}),this._writeQuad(e,t,i,r,{texcoords:Ge,offsets:s.bot,color:z(u),...p}),this._writeQuad(e,t,i,r,{texcoords:Oe,offsets:s.left,color:z(u),...p}),this._writeQuad(e,t,i,r,{texcoords:Oe,offsets:s.right,color:z(u),...p}))}_writeQuad(e,t,i,r,s){const n=e.vertexCount();this._writeVertex(e,t,i,r,s),e.indexWrite(n+0),e.indexWrite(n+1),e.indexWrite(n+2),e.indexWrite(n+1),e.indexWrite(n+3),e.indexWrite(n+2)}}const Rs=o=>Math.round(o*(254/360)),se=1,G=0,Cs=128;function Fs(o,e,t){return ae(`${o}${e}${t}`)}function Ys(o,e,t,i,r){return ae(`${o}${e}${t}${i*2**(H-r)}`)}function Ws(o,e,t){return ae(`${o}${e}${t}`)}function Gs(o,e,t,i,r){return ae(`${o}${r}${e}${t*2**(H-i)}`)}const Os=ct(o=>{let e=0;if(o===0)return 1/0;for(;!(o%2);)e++,o/=2;return e});class Ns extends rt{constructor(){super(...arguments),this._zoomLevel=0}_write(e,t,i,r){if(this._zoomLevel=r||0,i!=null)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(t.geometryType){case"esriGeometryPoint":{const s=t.readXForDisplay(),n=t.readYForDisplay();this._writePoint(e,s,n,0,t);break}case"esriGeometryEnvelope":case"esriGeometryPolygon":{const s=t.readCentroidForDisplay();if(!s)return;const[n,a]=s.coords;this._writePoint(e,n,a,0,t);break}case"esriGeometryMultipoint":{let s=0;const n=Y.fromFeatureSetReader(t);if(n?.nextPath())for(;n.nextPoint();)this._writePoint(e,n.x,n.y,s++,t);break}case"esriGeometryPolyline":this._writeLines(e,t)}}_getMetricDir(){const{horizontalAlignment:e,verticalAlignment:t}=this.evaluatedMeshParams;return[e==="center"?0:e==="right"?-1:1,t==="middle"?0:t==="bottom"?-1:1]}_createLineLabelMetric(e,t,i,r,s,n){const[a,c]=this._getMetricDir(),l=this.evaluatedMeshParams.scaleInfo?.maxScale??0,h=this.evaluatedMeshParams.scaleInfo?.minScale??0,d=this.evaluatedMeshParams.labelClassId;return new Re(e,d,t,i,r,s,a,c,l,h,n)}_writePoint(e,t,i,r,s){if(t<0||t>R||i<0||i>R)return;const n=this._getShaping();if(!n)return;const a=s.getDisplayId(),c=this.evaluatedMeshParams.labelClassId,l=Fs(this.evaluatedMeshParams.layerId,s.getObjectId(),r),h=Ws(s.getObjectId(),c,r),[d,f]=this._getMetricDir(),u=this.evaluatedMeshParams.scaleInfo?.maxScale??0,p=this.evaluatedMeshParams.scaleInfo?.minScale??0,m=this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0};e.metricStart(new Re(a,c,l,h,t,i,d,f,u,p,m)),this._writeGlyphs(e,a,t,i,n,0,m,void 0,!1),e.metricBoxWrite(n.boundsT),e.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const e of this._references){const t=e.getBoundsInfo();if(t)return t}return null}_writeLines(e,t){const{scaleInfo:i,verticalAlignment:r}=this.evaluatedMeshParams,s=this.evaluatedMeshParams.repeatLabelDistance||128,n=this._getShaping("middle");if(!n)return;const a=(l,h,d,f)=>this._placeSubdivGlyphs(l,h,d,f),c=(n.bounds.width+s)/(1<<se);this._current={out:e,id:t.getDisplayId(),objId:t.getObjectId(),shaping:n,zoomRange:Z(i,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null,pathIndex:0},this._verticalPlacement=r==="bottom"?"above":r==="top"?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(t,a,c):this._writeCenterAlong(t,a,c)}_writeAboveAndBelowAlong(e,t,i){const{repeatLabel:r}=this.evaluatedMeshParams,{shaping:s}=this._current,n=s.bounds.halfHeight,a=e.readGeometryForDisplay();if(!a)return;const c=new ue;jt(c,a,!1,!1,"esriGeometryPolyline",1);const l=Ne(new ue,c,n),h=Ne(new ue,c,-n),d=Ee(h,"esriGeometryPolyline",!1,!1),f=Ee(l,"esriGeometryPolyline",!1,!1),u=pe(f.paths,s.bounds.width),p=pe(d.paths,s.bounds.width);this._current.offsetDirection="above";for(let m=0;m<u.length;m++)this._current.pathIndex=m,fe(u[m],i,t,!!r);this._current.offsetDirection="below";for(let m=0;m<p.length;m++)this._current.pathIndex=m,fe(p[m],i,t,!!r)}_writeCenterAlong(e,t,i){const{repeatLabel:r}=this.evaluatedMeshParams,{shaping:s}=this._current,n=pe(e.readLegacyGeometryForDisplay().paths,s.bounds.width);for(let a=0;a<n.length;a++)this._current.pathIndex=a,fe(n[a],i,t,!!r)}_placeSubdivGlyphs(e,t,i,r){const{allowOverrun:s,labelPosition:n,repeatLabelDistance:a,layerId:c,labelClassId:l}=this.evaluatedMeshParams,{objId:h,shaping:d,pathIndex:f}=this._current,u=this._current.zoomRange[0],p=Os(t),m=this._current.shaping.bounds.width/(1<<se),g=Math.sqrt(a||Cs)/(1<<se),y=Math.min(i,r-i),x=d.isMultiline?H:Math.log2(y/(g+m/2)),b=t===0?x:Math.min(p,x),M=Math.max(u,this._zoomLevel+se-b),w=this._zoomLevel-M,v=d.bounds.width/2*2**w,S=Ys(c,h,f,t,this._zoomLevel),k=Gs(h,f,t,this._zoomLevel,l);this._current.shaping.isMultiline?t===0&&this._placeStraight(e,M,S,k):s&&w<0?this._placeStraightAlong(e,u,S,k):n==="parallel"?this._placeStraightAlong(e,M,S,k):n==="curved"&&this._placeCurved(e,M,v,S,k)}_placeStraight(e,t,i,r){const{out:s,id:n,shaping:a,referenceBounds:c}=this._current,{x:l,y:h}=e;s.metricStart(this._createLineLabelMetric(n,i,r,l,h)),s.metricBoxWrite(a.boundsT);const d=e.angle*(180/Math.PI)%360,f=(e.angle*(180/Math.PI)+180)%360;if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const u={clipAngle:d,mapAligned:!0,isLineLabel:!0,minZoom:t};this._writeGlyphs(s,n,l,h,a,0,c,u,!1)}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const u={clipAngle:f,mapAligned:!0,isLineLabel:!0,minZoom:t};this._writeGlyphs(s,n,l,h,a,0,c,u,!1)}s.metricEnd()}_placeCurved(e,t,i,r,s){const{out:n,id:a}=this._current;n.metricStart(this._createLineLabelMetric(a,r,s,e.x,e.y));const c=e.clone(),l=e.angle*(180/Math.PI)%360,h=(e.angle*(180/Math.PI)+180)%360;this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(c,t,1,l),this._placeBack(e,c,t,i,1,l),this._placeForward(e,c,t,i,1,l)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(c,t,0,h),this._placeBack(e,c,t,i,0,h),this._placeForward(e,c,t,i,0,h)),n.metricEnd()}_placeStraightAlong(e,t,i,r){const{out:s,id:n,shaping:a,zoomRange:c,referenceBounds:l}=this._current,{boxBorderLineColor:h,boxBackgroundColor:d}=this.evaluatedMeshParams,f=e.clone(),u=e.angle*(180/Math.PI)%360,p=(e.angle*(180/Math.PI)+180)%360,m=a.glyphs.length>0&&!(!h&&!d);if(s.metricStart(this._createLineLabelMetric(n,i,r,e.x,e.y)),m){const g=Math.max(t,c[0],0),y=Math.min(H,c[1]),x=he(O(),-e.angle),b={minZoom:g,maxZoom:y,clipAngle:u,mapAligned:!0,isLineLabel:!0},M=P(this.evaluatedMeshParams.offsetX),w=P(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const v=ee(M,-1*w),[S,k]=a.shapeBackground(me(O(),x,v));s.recordStart(this.instanceId,this.attributeLayout,a.glyphs[0].textureBinding),this._writeTextBox(s,n,e.x,e.y,k,l,b),s.recordEnd()}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const v=ee(M,w),[S,k]=a.shapeBackground(me(O(),x,v));b.clipAngle=p,s.recordStart(this.instanceId,this.attributeLayout,a.glyphs[0].textureBinding),this._writeTextBox(s,n,e.x,e.y,k,l,b),s.recordEnd()}}this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(f,t,1,u,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(f,t,0,p,!0),s.metricEnd()}_placeBack(e,t,i,r,s,n){const a=e.clone();let c=e.backwardLength+G;for(;a.prev()&&!(c>=r);)this._placeOnSegment(a,t,c,i,-1,s,n),c+=a.length+G}_placeForward(e,t,i,r,s,n){const a=e.clone();let c=e.remainingLength+G;for(;a.next()&&!(c>=r);)this._placeOnSegment(a,t,c,i,1,s,n),c+=a.length+G}_placeFirst(e,t,i,r,s=!1){const{out:n,id:a,shaping:c,zoomRange:l,referenceBounds:h}=this._current,d=c.glyphs,f=P(this.evaluatedMeshParams.offsetX),u=P(this.evaluatedMeshParams.offsetY),p=ee(f,u),m=he(O(),-e.angle);N(p,p,m);for(const g of d){const y=g.x>c.bounds.x?i:1-i,x=y*e.remainingLength+(1-y)*e.backwardLength,b=Math.abs(g.x+g.width/2-c.bounds.x),M=Math.max(0,this._zoomLevel+Math.log2(b/(x+G))),w=Math.max(t,s?0:M);if(g.maxZoom=Math.min(l[1],H),g.angle=e.angle+(1-i)*Math.PI,g.minZoom=Math.max(l[0],w),this._writeLineGlyph(n,a,e.x,e.y,g,r,h,!0),(i||this._current.offsetDirection)&&this._isVisible(g.minZoom,g.maxZoom)){const v=new Be(g.bounds.x+p[0],g.bounds.y+p[1],g.bounds.width,g.bounds.height);n.metricBoxWrite(v)}}}_placeOnSegment(e,t,i,r,s,n,a){const{out:c,id:l,shaping:h,referenceBounds:d}=this._current,f=h.glyphs,u=e.dx/e.length,p=e.dy/e.length,m={x:e.x+i*-s*u,y:e.y+i*-s*p},g=P(this.evaluatedMeshParams.offsetX),y=P(this.evaluatedMeshParams.offsetY),x=ee(g,y),b=he(O(),-e.angle);N(x,x,b);for(const M of f){const w=M.x>h.bounds.x?n:1-n;if(!(w&&s===1||!w&&s===-1))continue;const v=Math.abs(M.x+M.width/2-h.bounds.x),S=Math.max(0,this._zoomLevel+Math.log2(v/i)-.1),k=Math.max(r,this._zoomLevel+Math.log2(v/(i+e.length+G)));if(S!==0&&(M.angle=e.angle+(1-n)*Math.PI,M.minZoom=k,M.maxZoom=S,this._writeLineGlyph(c,l,m.x,m.y,M,a,d,!0),(n||this._current.offsetDirection)&&this._isVisible(M.minZoom,M.maxZoom))){const B=new Be(M.bounds.x+x[0],M.bounds.y+x[1],M.bounds.width,M.bounds.height);c.metricBoxWrite(B)}}}_writeLineGlyph(e,t,i,r,s,n,a,c){if(i<0||i>R||r<0||r>R)return;e.recordStart(this.instanceId,this.attributeLayout,s.textureBinding);const{texcoords:l,offsets:h}=s,{fontSize:d,haloSize:f,outlineSize:u}=this._textMeshTransformProps;this._writeQuad(e,t,i,r,{texcoords:l,offsets:h,fontSize:d,haloSize:f,outlineSize:u,color:z(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:a,minZoom:Math.max(this._current.zoomRange[0],s.minZoom),maxZoom:Math.min(this._current.zoomRange[1],s.maxZoom),clipAngle:n,mapAligned:c,isLineLabel:!0}),e.recordEnd()}_packedZoom(e){return Math.floor(e*j)/j}_isVisible(e,t){let i=Math.max(this._current.zoomRange[0],e),r=Math.min(this._current.zoomRange[1],t);i=this._packedZoom(i),r=this._packedZoom(r);const s=this._packedZoom(this._zoomLevel);return i<=s&&s<=r}}function Ne(o,e,t){const{coords:i,lengths:r}=e,s=W(),n=W(),a=W(),c=W(),l=W(),h=W(),d=2;let f=0;for(let u=0;u<r.length;u++){const p=r[u];for(let m=0;m<p;m++){const g=d*(m+f-1),y=d*(m+f),x=d*(m+f+1);m>0?E(s,i[g],i[g+1]):E(s,0,0),E(n,i[y],i[y+1]),m<p-1?E(a,i[x],i[x+1]):E(a,0,0),m===0?E(c,0,0):(Le(c,n,s),ce(c,c),E(c,c[1],-c[0])),m===p-1?E(l,0,0):(Le(l,a,n),ce(l,l),E(l,l[1],-l[0])),lt(h,c,l),ce(h,h);const b=h[0]*l[0]+h[1]*l[1];b!==0&&De(h,h,b),De(h,h,t),o.coords.push(n[0]+h[0],n[1]+h[1])}o.lengths.push(p),f+=p}return o}let Xs=class Pe{static from(e){return"width"in e?this.fromSimpleMeshParams(e):this.fromComplexMeshParams(e)}static fromSimpleMeshParams(e){const t=new Pe(e.sprite,e.color,e.outlineColor,e.minPixelBuffer,e.placement,e.scaleInfo,e.effects),{type:i,width:r,height:s,angle:n,alignment:a,outlineSize:c,referenceSize:l,sprite:h,overrideOutlineColor:d}=e;return t.rawWidth=P(r),t.rawHeight=P(s),t.angle=n,t.alignment=a,t.outlineSize=P(c),t.referenceSize=P(l),t.overrideOutlineColor=d,t.offsetX=P(e.offsetX),t.offsetY=P(e.offsetY),i!=="simple"||h.sdf||(t.rawWidth=h.width,t.rawHeight=h.height),t._computeSize(e,!1),t}static fromComplexMeshParams(e){const t=new Pe(e.sprite,e.color,e.outlineColor,e.minPixelBuffer,e.placement,e.scaleInfo,e.effects);let{alignment:i,transforms:r,size:s,scaleX:n,anchorX:a,anchorY:c,angle:l,colorLocked:h,frameHeight:d,widthRatio:f,offsetX:u,offsetY:p,outlineSize:m,referenceSize:g,scaleFactor:y,sizeRatio:x,isAbsoluteAnchorPoint:b,rotateClockwise:M,scaleSymbolsProportionally:w,sprite:v}=e;if(r&&r.infos.length>0){const B=je(s,l,M,u,p,r);s=B.size,l=B.rotation,u=B.offsetX,p=B.offsetY,M=!1}y&&(s*=y,u*=y,p*=y);const S=n*(v.width/v.height);t.alignment=i,t.rawHeight=P(s),t.rawWidth=t.rawHeight*S,t.referenceSize=P(g),t.sizeRatio=x,t.sdfDecodeCoeff=(v.sdfDecodeCoeff??1)*x,t.angle=l,t.rotateClockwise=M,t.anchorX=a,t.anchorY=c,t.offsetX=P(u),t.offsetY=P(p),b&&s&&(v.sdf?t.anchorX=a/(s*f):t.anchorX=a/(s*S),t.anchorY=c/s);const k=w&&d?s/d:1;return t.outlineSize=m===0||isNaN(m)?0:P(m)*k,t.scaleSymbolsProportionally=w,t.colorLocked=h,t._computeSize(e,!0),t}constructor(e,t,i,r,s,n,a){this.sprite=e,this.color=t,this.outlineColor=i,this.minPixelBuffer=r,this.placement=s,this.scaleInfo=n,this.effects=a,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.sdfDecodeCoeff=1,this.alignment=0,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize(e,t){const{sprite:i,hasSizeVV:r}=e,s=!!i.sdf,n=i.sdfPaddingRatio??.5,{rawWidth:a,rawHeight:c,sizeRatio:l,outlineSize:h}=this,d=i.rect;let f=a*l,u=c*l,p=0,m=0;if(s){const M=1/(1-n);if(f*=M,u*=M,r)this.computedWidth=f,this.computedHeight=u;else{const w=t&&a>c?f:a,v=c,S=h+2;this.computedWidth=Math.min(w+S,f),this.computedHeight=Math.min(v+S,u);const k=Math.max(i.width,i.height)/Math.max(f,u);p=(this.computedWidth-f)*k,m=(this.computedHeight-u)*k}}else this.computedWidth=f*(d.width/i.width),this.computedHeight=u*(d.height/i.height),p=2*D,m=2*D;const g=d.x+D-p/2,y=d.y+D-m/2,x=g+i.width+p,b=y+i.height+m;this.texXmin=Xe(g),this.texYmin=Xe(y),this.texXmax=He(x),this.texYmax=He(b),this.computedWidth*=(this.texXmax-this.texXmin)/(x-g),this.computedHeight*=(this.texYmax-this.texYmin)/(b-y),this.anchorX*=f/this.computedWidth,this.anchorY*=u/this.computedHeight}};function Xe(o,e=1e-7){const t=Math.ceil(o);return t-o<e?t:Math.floor(o)}function He(o,e=1e-7){const t=Math.floor(o);return o-t<e?t:Math.ceil(o)}const Hs=3.14159265359/180,Vs=128/Math.PI;function Us(o,e){return o%=e,Math.abs(o>=0?o:o+e)}function js(o){return Us(o*Vs,256)}function Qs(o,e,t,i,r=!1){const s=O(),n=r?1:-1;return Vt(s),(e||t)&&me(s,s,[e,-t]),i&&Ut(s,s,n*Hs*-i),s}const Zs={createComputedParams:o=>Xs.from(o),optionalAttributes:{zoomRange:{type:_.SHORT,count:2,packPrecisionFactor:j,pack:({scaleInfo:o},{tileInfo:e})=>Z(o,e)}},attributes:{pos:{type:_.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:_.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:_.UNSIGNED_BYTE,count:1,pack:({sprite:o,alignment:e,scaleSymbolsProportionally:t,overrideOutlineColor:i,colorLocked:r})=>{let s=0;return o.sdf&&(s|=A(L.bitset.isSDF)),e===1&&(s|=A(L.bitset.isMapAligned)),t&&(s|=A(L.bitset.scaleSymbolsProportionally)),i&&(s|=A(L.bitset.overrideOutlineColor)),r&&(s|=A(L.bitset.colorLocked)),s}},offset:{type:_.HALF_FLOAT,count:2,packAlternating:{count:4,pack:({angle:o,computedWidth:e,computedHeight:t,anchorX:i,anchorY:r,offsetX:s,offsetY:n,rotateClockwise:a})=>{const c=Qs(0,s,n,-o,a),l=-(.5+i)*e,h=-(.5-r)*t,d=[l,h],f=[l+e,h],u=[l,h+t],p=[l+e,h+t];return N(d,d,c),N(f,f,c),N(u,u,c),N(p,p,c),[d,f,u,p]}}},textureUV:{type:_.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({texXmax:o,texXmin:e,texYmax:t,texYmin:i})=>[[e,i],[o,i],[e,t],[o,t]]}},color:{type:_.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:o})=>z(o)},outlineColor:{type:_.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:o})=>z(o)},sizing:{type:_.UNSIGNED_BYTE,count:4,pack:({rawWidth:o,rawHeight:e,outlineSize:t,referenceSize:i})=>{const r=Math.max(o,e);return[le(r,128),le(t,128),le(i,128),0]}},placementAngle:{type:_.UNSIGNED_BYTE,count:1,packTessellation:({placementAngle:o})=>js(o)},sdfDecodeCoeff:{type:_.UNSIGNED_SHORT,count:1,packPrecisionFactor:64,pack:({sdfDecodeCoeff:o})=>o}}};let qs=class extends Q{constructor(){super(...arguments),this.vertexSpec=Zs}getBoundsInfo(){return this.evaluatedMeshParams.boundsInfo}_write(e,t,i){const r=this.evaluatedMeshParams.sprite?.textureBinding,s=t.getDisplayId();e.recordStart(this.instanceId,this.attributeLayout,r);const n=this.evaluatedMeshParams.minPixelBuffer,a=Math.max(this.evaluatedMeshParams.computedWidth,n),c=Math.max(this.evaluatedMeshParams.computedHeight,n),l=-this.evaluatedMeshParams.anchorX*this.evaluatedMeshParams.computedWidth,h=this.evaluatedMeshParams.anchorY*this.evaluatedMeshParams.computedHeight,d=this.evaluatedMeshParams.offsetX+l,f=-this.evaluatedMeshParams.offsetY+h;if(this.evaluatedMeshParams.placement!=null){let u=null;if(i!=null){const p=Math.max(this.evaluatedMeshParams.computedWidth,this.evaluatedMeshParams.computedHeight);if(u=yt(i,2*p,!1),u===null)return}this._writePlacedMarkers(e,t,u,a,c)}else if(i?.nextPath()){i.nextPoint();const u=i.x,p=i.y;e.recordBounds(u+d,p+f,a,c),this._writeQuad(e,s,u,p)}else if(t.geometryType==="esriGeometryPolygon"){const u=t.readCentroidForDisplay();if(!u)return;const[p,m]=u.coords;e.recordBounds(p+d,m+f,a,c),this._writeQuad(e,s,p,m)}else if(t.geometryType==="esriGeometryPoint"){const u=t.readXForDisplay(),p=t.readYForDisplay();e.recordBounds(u+d,p+f,a,c),this._writeQuad(e,s,u,p)}else t.readGeometryForDisplay()?.forEachVertex((p,m)=>{e.recordBounds(p+d,m+f,a,c),Math.abs(p)>X||Math.abs(m)>X||this._writeQuad(e,s,p,m)});e.recordEnd()}_writePlacedMarkers(e,t,i,r,s){const n=i??Y.fromFeatureSetReaderCIM(t);if(!n)return;const a=-1,c=Me.getPlacement(n,a,this.evaluatedMeshParams.placement,P(1),e.id);if(!c)return;const l=t.getDisplayId();let h=c.next();const d=this.evaluatedMeshParams.offsetX,f=-this.evaluatedMeshParams.offsetY;for(;h!=null;){const u=h.tx,p=-h.ty;if(Math.abs(u)>X||Math.abs(p)>X){h=c.next();continue}const m=-h.getAngle();e.recordBounds(u+d,p+f,r,s),this._writeQuad(e,l,u,p,m),h=c.next()}}_writeQuad(e,t,i,r,s){const n=e.vertexCount(),a=s==null?null:{placementAngle:s};this._writeVertex(e,t,i,r,a),e.indexWrite(n+0),e.indexWrite(n+1),e.indexWrite(n+2),e.indexWrite(n+1),e.indexWrite(n+3),e.indexWrite(n+2)}};class Js extends qt{constructor(e){super(),this._value=e}resize(e){}read(e,t){return this._value}readWithDefault(e,t,i){return this._value}hasArcadeDependency(e){return!1}}const Ks=()=>ut.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator");async function ie(o,e,t,i){const{defaultValue:r,valueExpressionInfo:s,value:n}=e;if(s){if(s.type==="dictionary-template")return{...e,computed:o.createDictionaryTemplateField(s,t),defaultValue:r};const{expression:a}=s,c=await o.createComputedField({expression:a},i);return c?{...e,computed:c,defaultValue:r}:null}return{...e,computed:new Js(n),defaultValue:r}}async function Ve(o,e,t){const{valueExpressionInfo:i}=e,r=i.type==="dictionary-template"?o.createDictionaryTemplateField(i,t):await o.createComputedField({expression:i.expression});return r?{...e,computed:r}:null}function ot(o){return typeof o=="object"&&o!=null&&(!(!("valueExpressionInfo"in o)||!o.valueExpressionInfo)||"type"in o&&o.type==="Process"&&"op"in o&&o.op==="Random")}function ne(o){if(Array.isArray(o)){for(const e of o)if(ne(e))return!0}if(typeof o=="object"){if(ot(o))return!0;for(const e in o)if(ne(o[e]))return!0}return!1}class $e{static async create(e,t,i,r){const s={},n=new Map,a=new Map,c=new Map,l=new Map,h=new Map,d=new Map;for(const f in i){const u=i[f];if(u!=null&&typeof u=="object")if(Array.isArray(u)){if(typeof u[0]=="object")throw new Error(`InternalError: Cannot handle ${f}. Nested array params are not supported`);s[f]=u}else{if("valueExpressionInfo"in u){if(u.value){s[f]=u.value;continue}const p=await Ve(e,u,r);if(!p){s[f]=u.defaultValue;continue}n.set(f,p),s[f]=null;continue}switch(u.type){case"cim-effect-infos":if(u.effectInfos.some(p=>p.overrides.length)){a.set(f,{effects:await Promise.all(u.effectInfos.map(async p=>{const m=p.overrides.map(g=>ie(e,g,r,!1));return{effect:p.effect,compiledOverrides:(await Promise.all(m)).filter(K)}}))});break}s[f]=u.effectInfos.map(p=>p.effect);break;case"cim-marker-placement-param":u.overrides.length&&c.set(f,{placementInfo:u,compiledOverrides:(await Promise.all(u.overrides.map(p=>ie(e,p,r,!1)))).filter(K)}),s[f]=u.placement;break;case"text-rasterization-param":{if(u.overrides.length){const m=u.overrides.map(g=>ie(e,g,r,u.useLegacyLabelEvaluationRules??!1));l.set(f,{compiledOverrides:(await Promise.all(m)).filter(K),rasterizationParam:u,objectIdToResourceId:new Map});continue}const p={type:"cim-rasterization-info",resource:u.resource};s[f]=await t.fetchResourceImmediate(p)??null;break}case"sprite-rasterization-param":{if(u.overrides.length){const m=u.overrides.map(g=>ie(e,g,r,!1));l.set(f,{compiledOverrides:(await Promise.all(m)).filter(K),rasterizationParam:u,objectIdToResourceId:new Map});continue}if(u.resource.type==="animated"){l.set(f,{compiledOverrides:[],rasterizationParam:u,objectIdToResourceId:new Map});continue}const p={type:"cim-rasterization-info",resource:u.resource};s[f]=await t.fetchResourceImmediate(p)??null;break}case"cim-marker-transform-param":{const{params:p}=u;if(ne(p)){const m={compiledMarkerInfos:[]};await Promise.all(p.map(async g=>{const y={props:{}};for(const x in g)if(ot(g[x])){const b=await Ve(e,g[x],r);y.compiledExpressionMap||(y.compiledExpressionMap=new Map);const M=y.compiledExpressionMap;b&&M.set(x,b)}else y.props[x]=g[x];m.compiledMarkerInfos.push(y)})),h.set(f,m)}else s[f]={type:"cim-marker-transform-info",infos:p};break}case"animation-params":{const{params:p}=u,m=rs(p);if(ne(m)){const g=await Promise.all(m.map(y=>xe(y,e)));d.set(f,{params:g,propertyIdToResourceId:new Map,key:f})}else{const g=is(m),y=await t.fetchResourceImmediate({type:"animation-info",resource:g});y!=null&&y.type==="sprite"&&(s[f]={dataRow:y.rect.y,dataColumn:y.rect.x})}break}default:s[f]=u}}else s[f]=u}return new $e(i,s,n,a,c,l,h,d)}constructor(e,t,i,r,s,n,a,c){this.inputMeshParams=e,this._resolvedMeshParams=t,this._dynamicProperties=i,this._dynamicEffectProperties=r,this._dynamicPlacementProperties=s,this._dynamicAsyncProperties=n,this._dynamicTransformProperties=a,this._dynamicAsyncAnimations=c,this.evaluator=l=>l,this._arcadeDependencies=new Set;for(const l of this._expressions())Zt(this._arcadeDependencies,l)}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size||this._dynamicAsyncAnimations.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(e,t,i){for(const r of this._dynamicAsyncProperties.values()){const s=ht(r.rasterizationParam.resource);r.rasterizationParam.resource.type==="animated"&&r.rasterizationParam.resource.randomizeStartTime&&(s.primitiveName="__RESERVED__PRIMITIVE__NAME__",s.startGroup=Ue(t.getObjectId()||0));for(const{primitiveName:a,propertyName:c,computed:l,defaultValue:h,valueExpressionInfo:d}of r.compiledOverrides)try{const f=r.rasterizationParam.resource.type==="animated"?s.primitiveName:a;Qt(s,f,c,l,t,i,h)}catch(f){Ks().errorOnce(new dt("invalid-arcade-expression","Encountered an error when evaluating the arcade expression",{error:f,valueExpressionInfo:d}))}const n=e.enqueueRequest({type:"cim-rasterization-info",resource:s});r.objectIdToResourceId.set(t.getObjectId(),n)}for(const r of this._dynamicAsyncAnimations.values()){const s=r.params.map(c=>I(c,t,i)).map(q).map(c=>c.simplify()),n=Ze(s),a=e.enqueueRequest({type:"animation-info",resource:n});r.propertyIdToResourceId.set(t.getObjectId()+"."+r.key,a)}}evaluateMeshParams(e,t,i){for(const[r,s]of this._dynamicProperties.entries())this._resolvedMeshParams[r]=s.computed.readWithDefault(t,i,s.defaultValue);for(const[r,s]of this._dynamicPlacementProperties.entries())for(const{computed:n,defaultValue:a,propertyName:c}of s.compiledOverrides){const l=n.readWithDefault(t,i,a);s.placementInfo.placement[c]=l,this._resolvedMeshParams[r]=s.placementInfo.placement}for(const[r,s]of this._dynamicEffectProperties.entries())for(const n of s.effects){for(const{computed:a,defaultValue:c,propertyName:l}of n.compiledOverrides){const h=a.readWithDefault(t,i,c);n.effect[l]=h}this._resolvedMeshParams[r]=s.effects.map(a=>a.effect)}for(const[r,s]of this._dynamicTransformProperties.entries()){const n={type:"cim-marker-transform-info",infos:[]};for(const a of s.compiledMarkerInfos){const c={...a.props};if(a.compiledExpressionMap)for(const[l,h]of a.compiledExpressionMap){const d=h.computed.readWithDefault(t,i,h.defaultValue);c[l]=typeof d=="number"||typeof d=="boolean"?d:h.defaultValue}n.infos.push(c)}this._resolvedMeshParams[r]=n}for(const[r,s]of this._dynamicAsyncProperties.entries()){const n=s.objectIdToResourceId.get(t.getObjectId());if(n==null)continue;const a=e.getResource(n);this._resolvedMeshParams[r]=a}for(const[r,s]of this._dynamicAsyncAnimations.entries()){const n=s.propertyIdToResourceId.get(t.getObjectId()+"."+r);if(n==null)continue;const a=e.getResource(n);this._resolvedMeshParams[r]={dataRow:a.rect.y,dataColumn:a.rect.x}}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}hasArcadeDependency(e){return this._arcadeDependencies.has(e)}*_expressions(){for(const e of this._dynamicProperties.values())yield e.computed;for(const e of this._dynamicEffectProperties.values())for(const t of e.effects)for(const i of t.compiledOverrides)yield i.computed;for(const e of this._dynamicPlacementProperties.values())for(const t of e.compiledOverrides)yield t.computed;for(const e of this._dynamicAsyncProperties.values())for(const t of e.compiledOverrides)yield t.computed;for(const e of this._dynamicTransformProperties.values())for(const t of e.compiledMarkerInfos)if(t.compiledExpressionMap!=null)for(const i of t.compiledExpressionMap.values())yield i.computed;for(const e of this._dynamicAsyncAnimations.values())for(const t of e.params)yield*T(t)}}const ei={createComputedParams:o=>o,optionalAttributes:{},attributes:{pos:{type:_.SHORT,count:2,packPrecisionFactor:10,pack:"position"},id:{type:_.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:_.UNSIGNED_BYTE,count:1,pack:o=>0},offset:{type:_.SHORT,count:2,packPrecisionFactor:16,packAlternating:{count:4,pack:({size:o})=>{const e=P(o),t=-e/2,i=-e/2;return[[t,i],[t+e,i],[t,i+e],[t+e,i+e]]}}},texCoords:{type:_.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:()=>[[0,1],[1,1],[0,0],[1,0]]}},size:{type:_.UNSIGNED_BYTE,count:2,pack:({size:o})=>[o,o]},referenceSize:{type:_.UNSIGNED_BYTE,count:1,pack:({size:o})=>P(o)},zoomRange:{type:_.UNSIGNED_BYTE,count:2,pack:({scaleInfo:o},{tileInfo:e})=>Z(o,e)}}};class ti extends Q{constructor(){super(...arguments),this.vertexSpec=ei}_write(e,t){const i=t.getDisplayId(),r=this.evaluatedMeshParams.minPixelBuffer,s=Math.max(P(this.evaluatedMeshParams.size),r);let n,a;if(t.geometryType==="esriGeometryPoint")n=t.readXForDisplay(),a=t.readYForDisplay();else{const l=t.readCentroidForDisplay();if(!l)return;n=l?.coords[0],a=l?.coords[1]}e.recordStart(this.instanceId,this.attributeLayout),e.recordBounds(n,a,s,s);const c=e.vertexCount();this._writeVertex(e,i,n,a),e.indexWrite(c+0),e.indexWrite(c+1),e.indexWrite(c+2),e.indexWrite(c+1),e.indexWrite(c+3),e.indexWrite(c+2),e.recordEnd()}}class Ci{async createMeshWriter(e,t,i,r,s){const n=this._getMeshWriter(r.techniqueType),a=await $e.create(e,t,r.inputParams,s),c=new n(r.id,a,r.optionalAttributes,i);return await c.loadDependencies(),c}_getMeshWriter(e){switch(e){case 13:return Yt;case 11:return Ms;case 9:return Ft;case 26:return Ct;case 14:return Rt;case 24:return Bt;case 27:return Et;case 10:return Dt;case 21:return qs;case 28:return ti;case 30:return rt;case 19:return Lt;case 31:return At;case 15:return $t;case 17:return vs;case 18:return Ns;case 2:return ms;case 3:return gs;case 0:return ys;case 1:return xs;default:throw new Error("Internal Error: Mesh writer not in the registry")}}}export{Js as r,Ci as x};
