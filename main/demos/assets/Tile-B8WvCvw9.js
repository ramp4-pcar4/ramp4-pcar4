import{ci as j,bB as Z,l as E,a as G,d as J,$ as H,e as Y,A as U,C as ee,V as te,a9 as se,bc as ie,lf as oe,kx as re,_ as z,Y as M,Z as le,gQ as K,al as N,kw as ne,h5 as he,lg as ae}from"./main-CtmwM019.js";import{e as R}from"./TileKey-CCdPKQiK.js";import{s as ce}from"./Queue-CI0vPdwz.js";import{s as $}from"./ReactiveMap-0nkT3Rr1.js";import{r as ue}from"./signal-Btlkyg0w.js";import{m as fe}from"./Query-COoGphoa.js";import{e as de}from"./arcadeUtils-62jCBeLc.js";function P(m,e){return[m,e]}function F(m,e,t){return m[0]=e,m[1]=t,m}function _e(m,e,t,s,i){return m[0]=e,m[1]=t,m[2]=s,m[3]=i,m}const I=new R("0/0/0/0");let ge=class D{static create(e,t,s=null){const i=j(e.spatialReference),o=t.origin||P(e.origin.x,e.origin.y),l=P(e.size[0]*t.resolution,e.size[1]*t.resolution),r=P(-1/0,-1/0),n=P(1/0,1/0),a=P(1/0,1/0);s!=null&&(F(r,Math.max(0,Math.floor((s.xmin-o[0])/l[0])),Math.max(0,Math.floor((o[1]-s.ymax)/l[1]))),F(n,Math.max(0,Math.floor((s.xmax-o[0])/l[0])),Math.max(0,Math.floor((o[1]-s.ymin)/l[1]))),F(a,n[0]-r[0]+1,n[1]-r[1]+1));const{cols:c,rows:u}=t;let _,p,v,g;return!s&&c&&u&&(F(r,c[0],u[0]),F(n,c[1],u[1]),F(a,c[1]-c[0]+1,u[1]-u[0]+1)),e.isWrappable?(_=P(Math.ceil(Math.round((i.valid[1]-i.valid[0])/t.resolution)/e.size[0]),a[1]),p=!0,v=i.origin,g=i.valid):(_=a,p=!1),new D(t.level,t.resolution,t.scale,o,r,n,a,l,_,p,v,g)}constructor(e,t,s,i,o,l,r,n,a,c,u,_){this.level=e,this.resolution=t,this.scale=s,this.origin=i,this.first=o,this.last=l,this.size=r,this.norm=n,this.worldSize=a,this.wrap=c,this._spatialReferenceOrigin=u,this._spatialReferenceValid=_}normalizeCol(e){if(!this.wrap)return e;const t=this.worldSize[0];return e<0?t-1-Math.abs((e+1)%t):e%t}normalizeKey(e){if(!this.wrap)return;const t=this.worldSize[0],s=e.col;s<0?(e.col=s+t,e.world-=1):s>=t&&(e.col=s-t,e.world+=1)}denormalizeCol(e,t){return this.wrap?this.worldSize[0]*t+e:e}getWorldForColumn(e){return this.wrap?Math.floor(e/this.worldSize[0]):0}getFirstColumnForWorld(e){return e*this.worldSize[0]+this.first[0]}getLastColumnForWorld(e){return e*this.worldSize[0]+this.first[0]+this.size[0]-1}getColumnForX(e){return(e-this.origin[0])/this.norm[0]}getXForColumn(e){const t=this.origin[0]+e*this.norm[0],s=this._spatialReferenceOrigin,i=this._spatialReferenceValid;return this.wrap&&s&&i?t===s[0]?i[0]:this.origin[0]===s[0]&&e===this.worldSize[0]?i[1]:t:t}getRowForY(e){return(this.origin[1]-e)/this.norm[1]}getYForRow(e){return this.origin[1]-e*this.norm[1]}getTileBounds(e,t,s=!1){I.set(t);const i=s?I.col:this.denormalizeCol(I.col,I.world),o=I.row;return _e(e,this.getXForColumn(i),this.getYForRow(o+1),this.getXForColumn(i+1),this.getYForRow(o)),e}getTileCoords(e,t,s=!1){I.set(t);const i=s?I.col:this.denormalizeCol(I.col,I.world);return Array.isArray(e)?F(e,this.getXForColumn(i),this.getYForRow(I.row)):(e.x=this.getXForColumn(i),e.y=this.getYForRow(I.row)),e}};class L{constructor(){this.spans=[]}static{this.pool=new Z(()=>new L)}acquire(e){this.lodInfo=e}release(){this.lodInfo=null,this.spans.length=0}*keys(){const e=this.lodInfo;for(const{row:t,colFrom:s,colTo:i}of this.spans)for(let o=s;o<=i;o++){const l=e.getWorldForColumn(o);yield new R(e.level,t,e.normalizeCol(o),l)}}forEach(e,t){const{spans:s,lodInfo:i}=this,{level:o}=i;if(s.length!==0)for(const{row:l,colFrom:r,colTo:n}of s)for(let a=r;a<=n;a++)e.call(t,o,l,i.normalizeCol(a),i.getWorldForColumn(a))}}let V=class{constructor(e,t,s){this.row=e,this.colFrom=t,this.colTo=s}};const d=new R("0/0/0/0");class O{static create(e,t){e[1]>t[1]&&([e,t]=[t,e]);const[s,i]=e,[o,l]=t,r=o-s,n=l-i,a=n!==0?r/n:0,c=(Math.ceil(i)-i)*a,u=(Math.floor(i)-i)*a;return new O(s,Math.floor(i),Math.ceil(l),a,r<0?c:u,r<0?u:c,r<0?o:s,r<0?s:o)}constructor(e,t,s,i,o,l,r,n){this.x=e,this.ymin=t,this.ymax=s,this.invM=i,this.leftAdjust=o,this.rightAdjust=l,this.leftBound=r,this.rightBound=n}incrRow(){this.x+=this.invM}getLeftCol(){return Math.max(this.x+this.leftAdjust,this.leftBound)}getRightCol(){return Math.min(this.x+this.rightAdjust,this.rightBound)}}const w=[[0,0],[0,0],[0,0],[0,0]],me=1e-6;let Fe=class{constructor(e,t=null,s=e.lods[0].level,i=e.lods[e.lods.length-1].level){this.tileInfo=e,this.fullExtent=t,this.scales=[],this._infoByScale={},this._infoByLevel={};const o=e.lods.filter(r=>r.level>=s&&r.level<=i);this.minScale=o[0].scale,this.maxScale=o[o.length-1].scale;const l=this._lodInfos=o.map(r=>ge.create(e,r,t));o.forEach((r,n)=>{this._infoByLevel[r.level]=l[n],this._infoByScale[r.scale]=l[n],this.scales[n]=r.scale},this),this._wrap=e.isWrappable}get spatialReference(){return this.tileInfo.spatialReference}getLODInfoAt(e){return this._infoByLevel[typeof e=="number"?e:e.level]}getTileBounds(e,t,s=!1){d.set(t);const i=this._infoByLevel[d.level];return i?i.getTileBounds(e,d,s):e}getTileCoords(e,t,s=!1){d.set(t);const i=this._infoByLevel[d.level];return i?i.getTileCoords(e,d,s):e}getTileCoverage(e,t=192,s=!0,i="closest"){if(!s&&(e.scale>this.minScale||e.scale<this.maxScale))return null;const o=i==="closest"?this.getClosestInfoForScale(e.scale):this.getSmallestInfoForScale(e.scale),l=L.pool.acquire(o),r=this._wrap;let n,a,c,u=1/0,_=-1/0;const p=l.spans;w[0][0]=w[0][1]=w[1][1]=w[3][0]=-t,w[1][0]=w[2][0]=e.size[0]+t,w[2][1]=w[3][1]=e.size[1]+t;for(const h of w)e.toMap(h,h),h[0]=o.getColumnForX(h[0]),h[1]=o.getRowForY(h[1]);const v=[];let g=3;for(let h=0;h<4;h++){if(w[h][1]===w[g][1]){g=h;continue}const f=O.create(w[h],w[g]);u=Math.min(f.ymin,u),_=Math.max(f.ymax,_),v[f.ymin]===void 0&&(v[f.ymin]=[]),v[f.ymin].push(f),g=h}if(u==null||_==null||_-u>100)return null;let y=[];for(n=u;n<_;){v[n]!=null&&(y=y.concat(v[n])),a=1/0,c=-1/0;for(let h=y.length-1;h>=0;h--){const f=y[h];a=Math.min(a,f.getLeftCol()),c=Math.max(c,f.getRightCol())}if(a=Math.floor(a),c=Math.floor(c),n>=o.first[1]&&n<=o.last[1])if(r)if(o.size[0]<o.worldSize[0]){const h=Math.floor(c/o.worldSize[0]);for(let f=Math.floor(a/o.worldSize[0]);f<=h;f++)p.push(new V(n,Math.max(o.getFirstColumnForWorld(f),a),Math.min(o.getLastColumnForWorld(f),c)))}else p.push(new V(n,a,c));else a>o.last[0]||c<o.first[0]||(a=Math.max(a,o.first[0]),c=Math.min(c,o.last[0]),p.push(new V(n,a,c)));n+=1;for(let h=y.length-1;h>=0;h--){const f=y[h];f.ymax>=n?f.incrRow():y.splice(h,1)}}return l}getTileParentId(e){d.set(e);const t=this._infoByLevel[d.level],s=this._lodInfos.indexOf(t)-1;return s<0?null:(this._getTileIdAtLOD(d,this._lodInfos[s],d),d.id)}getTileResolution(e){const t=this._infoByLevel[typeof e=="object"?e.level:e];return t?t.resolution:-1}getTileScale(e){const t=this._infoByLevel[e.level];return t?t.scale:-1}intersects(e,t){d.set(t);const s=this._infoByLevel[d.level],i=e.lodInfo;if(i.resolution>s.resolution){this._getTileIdAtLOD(d,i,d);const l=i.denormalizeCol(d.col,d.world);for(const r of e.spans)if(r.row===d.row&&r.colFrom<=l&&r.colTo>=l)return!0}if(i.resolution<s.resolution){const[l,r,n,a]=e.spans.reduce((g,y)=>(g[0]=Math.min(g[0],y.row),g[1]=Math.max(g[1],y.row),g[2]=Math.min(g[2],y.colFrom),g[3]=Math.max(g[3],y.colTo),g),[1/0,-1/0,1/0,-1/0]),c=s.denormalizeCol(d.col,d.world),u=i.getColumnForX(s.getXForColumn(c)),_=i.getRowForY(s.getYForRow(d.row)),p=i.getColumnForX(s.getXForColumn(c+1))-1,v=i.getRowForY(s.getYForRow(d.row+1))-1;return!(u>a||p<n||_>r||v<l)}const o=i.denormalizeCol(d.col,d.world);return e.spans.some(l=>l.row===d.row&&l.colFrom<=o&&l.colTo>=o)}normalizeBounds(e,t,s){if(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],this._wrap){const i=j(this.tileInfo.spatialReference),o=-s*(i.valid[1]-i.valid[0]);e[0]+=o,e[2]+=o}return e}getSmallestInfoForScale(e){const t=this.scales;if(this._infoByScale[e])return this._infoByScale[e];if(e>t[0])return this._infoByScale[t[0]];for(let s=1;s<t.length-1;s++)if(e>t[s]+me)return this._infoByScale[t[s-1]];return this._infoByScale[t[t.length-1]]}getClosestInfoForScale(e){const t=this.scales;return this._infoByScale[e]||(e=t.reduce((s,i)=>Math.abs(i-e)<Math.abs(s-e)?i:s,t[0])),this._infoByScale[e]}scaleToLevel(e){const t=this.scales;if(this._infoByScale[e])return this._infoByScale[e].level;for(let s=t.length-1;s>=0;s--)if(e<t[s])return s===t.length-1?this._infoByScale[t[t.length-1]].level:this._infoByScale[t[s]].level+(t[s]-e)/(t[s]-t[s+1]);return this._infoByScale[t[0]].level}scaleToZoom(e){return this.tileInfo.scaleToZoom(e)}zoomToScale(e){return this.tileInfo.zoomToScale(e)}_getTileIdAtLOD(e,t,s){const i=this._infoByLevel[s.level];return e.set(s),t.resolution<i.resolution?null:(t.resolution===i.resolution||(e.level=t.level,e.col=Math.floor(s.col*i.resolution/t.resolution+.01),e.row=Math.floor(s.row*i.resolution/t.resolution+.01)),e)}};class pe{constructor(e,t){this.item=e,this.controller=t,this.promise=null}}class ye{constructor(e){this._schedule=null,this._task=null,this._deferreds=new $,this._controllers=new $,this._processingItems=new $,this._pausedSignal=ue(!1),this.concurrency=1,e.concurrency&&(this.concurrency=e.concurrency),this._queue=new ce(e.peeker),this.process=e.process;const t=e.scheduler;e.priority&&t&&(this._task=t.registerTask(e.priority,this))}destroy(){this.clear(),this._schedule=E(this._schedule),this._task=E(this._task)}get updating(){return!!this._task?.updating||this.readyToRun}get length(){return this._processingItems.size+this._queue.length}abort(e){const t=this._controllers.get(e);t&&t.abort()}clear(){this._queue.clear();const e=[];this._controllers.forEach(t=>e.push(t)),this._controllers.clear(),e.forEach(t=>t.abort()),this._processingItems.clear(),this._cancelNext()}forEach(e){this._deferreds.forEach((t,s)=>e(s))}get(e){const t=this._deferreds.get(e);return t?t.promise:void 0}isOngoing(e){return this._processingItems.has(e)}has(e){return this._deferreds.has(e)}pause(){this._pausedSignal.value||(this._pausedSignal.value=!0,this._cancelNext())}push(e,t){const s=this.get(e);if(s)return s;const i=new AbortController;let o=null;t&&(o=G(t,()=>i.abort()));const l=()=>{const c=this._processingItems.get(e);c&&c.controller.abort(),r(),a.reject(Y())},r=()=>{n.remove(),o?.remove(),this._removeItem(e),this._queue.remove(e),this._scheduleNext()},n=J(i.signal,l),a=H();return this._deferreds.set(e,a),this._controllers.set(e,i),a.promise.then(r,r),this._queue.push(e),this._scheduleNext(),a.promise}last(){return this._queue.last()}lastPromise(){const e=this.last();return e?this.get(e):null}peek(){return this._queue.peek()}popLast(){const e=this._queue.popLast();return e&&(this._deferreds.get(e)?.reject(Y()),this._removeItem(e)),e}reset(){const e=Array.from(this._processingItems.values());this._processingItems.clear();for(const t of e)this._queue.push(t.item),t.controller.abort();this._scheduleNext()}resume(){this._pausedSignal.value&&(this._pausedSignal.value=!1,this._scheduleNext())}takeAll(){const e=[];for(;this._queue.length;)e.push(this._queue.pop());return this.clear(),e}get readyToRun(){return!this._pausedSignal.value&&this._queue.length>0&&this._processingItems.size<this.concurrency}runTask(e){for(;!e.done&&this._queue.length>0&&this._processingItems.size<this.concurrency;)this._process(this._queue.pop()),e.madeProgress()}_removeItem(e){this._deferreds.delete(e),this._controllers.delete(e),this._processingItems.delete(e)}_scheduleNext(){this._task||this._pausedSignal.value||this._schedule||(this._schedule=U(()=>{this._schedule=null,this._next()}))}_next(){for(;this._queue.length>0&&this._processingItems.size<this.concurrency;)this._process(this._queue.pop())}_cancelNext(){this._schedule&&(this._schedule.remove(),this._schedule=null)}_processResult(e,t){this._canProcessFulfillment(e)&&(this._scheduleNext(),this._deferreds.get(e.item).resolve(t))}_processError(e,t){this._canProcessFulfillment(e)&&(this._scheduleNext(),this._deferreds.get(e.item).reject(t))}_canProcessFulfillment(e){return!!this._deferreds.get(e.item)&&this._processingItems.get(e.item)===e}_process(e){if(e==null)return;let t;const s=new AbortController,i=new pe(e,s);this._processingItems.set(e,i);try{t=this.process(e,s.signal)}catch(o){this._processError(i,o)}ee(t)?(i.promise=t,t.then(o=>this._processResult(i,o),o=>this._processError(i,o))):this._processResult(i,t)}get test(){}}const X=[0,0];let C=class extends te{constructor(e){super(e),this._keyToItem=new Map,this._tilesByScale=new Map,this.concurrency=6}initialize(){const{concurrency:e,process:t,scheduler:s,priority:i}=this;this._queue=new ye({concurrency:e,scheduler:s,priority:i,process:(o,l)=>{const r=this._keyToItem.get(o);return t(r,{signal:l})},peeker:o=>this._peek(o)})}destroy(){this.clear(),this._queue=se(this._queue)}get length(){return this._queue?this._queue.length:0}abort(e){const t=typeof e=="string"?e:e.id;this._queue.abort(t)}clear(){this._queue.clear(),this._keyToItem.clear(),this._tilesByScale.clear()}has(e){return typeof e=="string"?this._keyToItem.has(e):this._keyToItem.has(e.id)}pause(){this._queue.pause()}push(e){const t=e.key.id;if(this._queue.has(t))return this._queue.get(t);const s=this._queue.push(t),i=this.tileInfoView.getTileScale(e.key),o=ie(this._tilesByScale,i,()=>new Set),l=()=>{o.delete(e.key),o.size===0&&this._tilesByScale.delete(i),this._keyToItem.delete(t)};return o.add(e.key),this._keyToItem.set(t,e),s.then(l,l),s}reset(){this._queue.reset()}resume(){this._queue.resume()}_peek(e){if(!this.state)return e.values().next().value;const t=new Set;for(const l of e)t.add(this._keyToItem.get(l).key);const s=this.state.scale;let i,o=Number.POSITIVE_INFINITY;for(const[l,r]of this._tilesByScale)if(oe(r,n=>t.has(n))){const n=Math.abs(l-s);n<o&&(i=r,o=n)}return this._getClosestTileKey(i,e).id}_getClosestTileKey(e,t){const s=this.tileInfoView,i=this.state.center;let o,l=Number.POSITIVE_INFINITY;for(const r of e)if(t.has(r.id)){s.getTileCoords(X,r);const n=re(X,i);n<l&&(l=n,o=r)}return o}};z([M({constructOnly:!0})],C.prototype,"concurrency",void 0),z([M({constructOnly:!0})],C.prototype,"priority",void 0),z([M({constructOnly:!0})],C.prototype,"process",void 0),z([M({constructOnly:!0})],C.prototype,"scheduler",void 0),z([M()],C.prototype,"state",void 0),z([M({constructOnly:!0})],C.prototype,"tileInfoView",void 0),C=z([le("esri.views.2d.tiling.TileQueue")],C);const Pe=C;class ve{constructor(e,t,s){this.maxSize=e,this._tileInfoView=t,this._removedFunc=s,this._tilePerId=new Map,this._tileKeysPerLevel=[]}clear(){this._tilePerId.clear(),this._tileKeysPerLevel=[]}has(e){return this._tilePerId.has(e)}get(e){return this._tilePerId.get(e)}pop(e){const t=this._tilePerId.get(e);if(!t)return;const s=t.key.level,i=this._tileKeysPerLevel[s];W(this._tilePerId,e);for(let o=0;o<i.length;o++)if(i[o].id===e){i.splice(o,1);break}return t.visible=!0,t}add(e){e.visible=!1;const t=e.key,s=t.id;if(this._tilePerId.has(s))return;this._tilePerId.set(s,e);const i=t.level;this._tileKeysPerLevel[i]||(this._tileKeysPerLevel[i]=[]),this._tileKeysPerLevel[i].push(t)}prune(e,t,s){let i=this._tilePerId.size;if(i<=this.maxSize)return;let o=this._tileKeysPerLevel.length-1;for(;i>this.maxSize&&o>=0;)o!==e&&(i=this._pruneAroundCenterTile(i,t,s,o)),o--;i>this.maxSize&&(i=this._pruneAroundCenterTile(i,t,s,e))}_pruneAroundCenterTile(e,t,s,i){const o=this._tileKeysPerLevel[i];if(!o||o.length===0)return e;const{size:l,origin:r}=this._tileInfoView.tileInfo,n=s*l[0],a=s*l[1],c=[0,0],u=[0,0];for(o.sort((_,p)=>(c[0]=r.x+n*(_.col+.5),c[1]=r.y-a*(_.row+.5),u[0]=r.x+n*(p.col+.5),u[1]=r.y-a*(p.row+.5),K(c,t)-K(u,t)));o.length>0;){const _=o.pop();if(this._removeTile(_.id),--e===this.maxSize)break}return e}_removeTile(e){const t=this._tilePerId.get(e);this._removedFunc&&t&&this._removedFunc(t),W(this._tilePerId,e)}}function W(m,e){m.delete(e)}const b=new R(0,0,0,0),x=new Map,B=[],A=[];let Be=class{constructor(e){this._previousScale=Number.POSITIVE_INFINITY,this.cachePolicy="keep",this.coveragePolicy="closest",this.resampling=!0,this.tileIndex=new Map,this.tiles=[],this.buffer=192,this.acquireTile=e.acquireTile,this.releaseTile=e.releaseTile,this.tileInfoView=e.tileInfoView,e.resampling!=null&&(this.resampling=e.resampling),e.cachePolicy&&(this.cachePolicy=e.cachePolicy),e.coveragePolicy&&(this.coveragePolicy=e.coveragePolicy),e.buffer!=null&&(this.buffer=e.buffer),e.cacheSize&&(this._tileCache=new ve(e.cacheSize,this.tileInfoView,t=>{this.releaseTile(t)}))}destroy(){this.tileIndex.clear()}update(e){const{resampling:t,tileIndex:s}=this,{scale:i,center:o,resolution:l}=e.state,{minScale:r,maxScale:n}=this.tileInfoView,a=!e.stationary&&i>this._previousScale;if(this._previousScale=i,!t&&(i>r||i<n))return this.tiles.length=0,void this.clear();const c=this.tileInfoView.getTileCoverage(e.state,this.buffer,this.resampling,this.coveragePolicy);if(!c)return this.tiles.length=0,void this.clear();const{spans:u,lodInfo:_}=c,{level:p}=_;this.tiles.length=0,s.forEach(h=>h.visible=!0);let v=0,g=0;if(u.length>0)for(const{row:h,colFrom:f,colTo:q}of u)for(let k=f;k<=q;k++){v++;const S=b.set(p,h,_.normalizeCol(k),_.getWorldForColumn(k)).id;let T=s.get(S);if(T)T.isReady?(x.set(S,T),g++):a||this._addParentTile(S,x);else{if(this._tileCache?.has(S)){if(T=this._tileCache.pop(S),this.tileIndex.set(S,T),T.isReady){x.set(S,T),g++;continue}}else T=this.acquireTile(b),this.tileIndex.set(S,T);a||this._addParentTile(S,x)}}const y=g===v;for(const[h,f]of s){if(x.has(h))continue;b.set(h);const q=this.tileInfoView.intersects(c,b),k=this.cachePolicy==="purge"?b.level!==p:b.level>p;!q||!a&&y?!k&&q||B.push(f):f.isReady?k&&this.cachePolicy==="purge"&&this._hasReadyAncestor(b,p)?B.push(f):A.push(f):k&&B.push(f)}for(const h of A)h.isReady&&x.set(h.key.id,h);for(const h of B)this._tileCache?this._tileCache.add(h):this.releaseTile(h),s.delete(h.key.id);for(const h of x.values())this.tiles.push(h);for(const h of s.values())x.has(h.key.id)||(h.visible=!1);this._tileCache?.prune(p,o,l),L.pool.release(c),A.length=0,B.length=0,x.clear()}clear(){const{tileIndex:e}=this;for(const t of e.values())this.releaseTile(t);e.clear()}refresh(e){for(const t of this.tileIndex.values())e(t);this._tileCache?.clear()}updateCacheSize(e){this._tileCache&&(this._tileCache.maxSize=e)}_addParentTile(e,t){let s=e,i=null;for(;s=this.tileInfoView.getTileParentId(s),s;)if(this.tileIndex.has(s)){if(i=this.tileIndex.get(s),i?.isReady){t.has(i.key.id)||t.set(i.key.id,i);break}}else if(this._tileCache?.has(s)&&(i=this._tileCache.pop(s),this.tileIndex.set(s,i),i?.isReady)){t.has(i.key.id)||t.set(i.key.id,i);break}}_hasReadyAncestor(e,t){const s=N();this.tileInfoView.getTileBounds(s,e,!0);for(const i of this.tileIndex.values())if(i.isReady&&i.key.level>=t&&i.key.level<e.level){const o=N();if(this.tileInfoView.getTileBounds(o,i.key,!0),ne(o,s))return!0}return!1}};class Q{constructor(e,t){this.key=new R(0,0,0,0),this.bounds=N(),this.objectIds=new Set,this.key.set(t);const s=e.getLODInfoAt(this.key);this.tileInfoView=e,this.tileInfoView.getTileBounds(this.bounds,this.key,!0),this.resolution=s.resolution,this.level=s.level,this.scale=s.scale,this.minScale=e.zoomToScale(s.level-1),this.maxScale=e.zoomToScale(s.level+1)}get lod(){return this.tileInfoView.getLODInfoAt(this.key)}get id(){return this.key.id}get extent(){return he(this.bounds,this.tileInfoView.tileInfo.spatialReference)}get transform(){return{originPosition:"upperLeft",scale:[this.resolution,this.resolution],translate:[this.bounds[0],this.bounds[3]]}}createArcadeEvaluationOptions(e){return de(this.scale,e)}createChildTiles(){const e=this.key.getChildKeys(),t=ae.acquire();for(let s=0;s<e.length;s++)t[s]=new Q(this.tileInfoView,e[s]);return t}getQuantizationParameters(){return fe.fromJSON({mode:"view",originPosition:"upperLeft",tolerance:this.resolution,extent:{xmin:this.bounds[0],ymin:this.bounds[1],xmax:this.bounds[2],ymax:this.bounds[3],spatialReference:this.tileInfoView.tileInfo.spatialReference}})}}export{ye as _,Q as a,Fe as h,Pe as p,Be as r,L as s};
