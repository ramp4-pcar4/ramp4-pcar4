import{am as z,i as nt,aa as ot,cg as Q,ch as H,ci as rt,cj as it,ck as at}from"./main-CtmwM019.js";const U=()=>nt.getLogger("esri.views.2d.engine.flow.dataUtils"),lt=10;async function gt(m,t,o,u){const d=performance.now(),g=st(t,o),c=performance.now(),l=ft(t,g,o.width,o.height),e=performance.now(),n=ut(l),r=performance.now(),M=m==="Streamlines"?dt(n,lt):wt(n),A=performance.now();return z("esri-2d-profiler")&&(U().info("I.1","_createFlowFieldFromData (ms)",Math.round(c-d)),U().info("I.2","_getStreamlines (ms)",Math.round(e-c)),U().info("I.3","createAnimatedLinesData (ms)",Math.round(r-e)),U().info("I.4","create{Streamlines|Particles}Mesh (ms)",Math.round(A-r)),U().info("I.5","createFlowMesh (ms)",Math.round(A-d)),U().info("I.6","Mesh size (bytes)",M.vertexData.buffer.byteLength+M.indexData.buffer.byteLength)),await Promise.resolve(),ot(u),M}function st(m,t){const o=ht(t.data,t.width,t.height,m.smoothing);return m.interpolate?(u,d)=>{const g=Math.floor(u),c=Math.floor(d);if(g<0||g>=t.width)return[0,0];if(c<0||c>=t.height)return[0,0];const l=u-g,e=d-c,n=g,r=c,M=g<t.width-1?g+1:g,A=c<t.height-1?c+1:c,i=o[2*(r*t.width+n)],f=o[2*(r*t.width+M)],x=o[2*(A*t.width+n)],v=o[2*(A*t.width+M)],y=o[2*(r*t.width+n)+1],h=o[2*(r*t.width+M)+1];return[(i*(1-e)+x*e)*(1-l)+(f*(1-e)+v*e)*l,(y*(1-e)+o[2*(A*t.width+n)+1]*e)*(1-l)+(h*(1-e)+o[2*(A*t.width+M)+1]*e)*l]}:(u,d)=>{const g=Math.round(u),c=Math.round(d);return g<0||g>=t.width||c<0||c>=t.height?[0,0]:[o[2*(c*t.width+g)],o[2*(c*t.width+g)+1]]}}function W(m,t,o,u,d,g,c,l){const e=[],{raster:n,width:r,height:M,resolutionFactor:A}=l;let i=u,f=d,x=0,[v,y]=o(i,f);v*=t.velocityScale,y*=t.velocityScale;const h=Math.sqrt(v*v+y*y);let p,w;e.push({x:i,y:f,t:x,speed:h});for(let a=0;a<t.verticesPerLine;a++){let[s,D]=o(i,f);s*=t.velocityScale,D*=t.velocityScale;const F=Math.sqrt(s*s+D*D);if(F<t.minSpeedThreshold)return e;const L=m*s/F,_=m*D/F;if(i+=L*t.segmentLength,f+=_*t.segmentLength,t.wrapAround&&(i=H(i,g[0])),x+=m*t.segmentLength/F,Math.acos(L*p+_*w)>t.maxTurnAngle)return e;if(t.collisions){let P=Math.round(i*A);const S=Math.round(f*A);if(t.wrapAround&&(P=H(P,r)),P<0||P>r-1||S<0||S>M-1)return e;const B=n[S*r+P];if(B!==-1&&B!==c)return e;n[S*r+P]=c}e.push({x:i,y:f,t:x,speed:F}),p=L,w=_}return e}function ct(m,t,o,u,d,g,c,l){const e=Math.round((.2+.6*c.getFloat())*m.verticesPerLine),n=m.verticesPerLine-e,r=W(-1,{...m,verticesPerLine:n},t,o,u,d,g,l),M=W(1,{...m,verticesPerLine:e},t,o,u,d,g,l),A=r.reverse();return A.splice(-1,1),A.concat(M)}function ft(m,t,o,u,d={positions:[]}){if(m.density<=0)return[];const{positions:g}=d,c=[],l=new Q,e=1/Math.max(m.lineCollisionWidth,1),n=Math.round(o*e),r=Math.round(u*e),M=new Int32Array(n*r);for(let h=0;h<M.length;h++)M[h]=-1;const A={raster:M,width:n,height:r,resolutionFactor:e},i={},f=m.lineSpacing/Math.sqrt(m.density),x=Math.floor(u/f),v=Math.floor(o/f);for(let h=0;h<x;h++){const p=h*f;for(let w=0;w<v;w++){const a=w*f;i[`${w}-${h}`]={x:a,y:p,positions:[]}}}for(const{x:h,y:p}of g){const w=i[`${Math.floor(h/f)}-${Math.floor(p/f)}`];w&&w.positions.push([h,p])}const y=[];for(const h in i){const p=i[h];if(p.positions.length===0)y.push({x:p.x+f/2,y:p.y+f/2,sort:.66+.33*l.getFloat(),stage:0});else{const[w]=p.positions.splice(0,1);y.push({x:w[0],y:w[1],sort:.33*l.getFloat(),stage:1});for(const[a,s]of p.positions)y.push({x:a,y:s,sort:.33+.33*l.getFloat(),stage:2})}}y.sort((h,p)=>h.sort-p.sort);for(const{x:h,y:p,stage:w}of y){const a=m.onlyForwardTracing?W(1,m,t,h,p,[o,u],c.length,A):ct(m,t,h,p,[o,u],c.length,l,A);a.length<2||c.push({stage:w,vertices:a})}return c}function ht(m,t,o,u){if(u===0)return m;const d=Math.round(3*u),g=new Array(2*d+1);let c=0;for(let n=-d;n<=d;n++){const r=Math.exp(-n*n/(u*u));g[n+d]=r,c+=r}for(let n=-d;n<=d;n++)g[n+d]/=c;const l=new Float32Array(m.length);for(let n=0;n<o;n++)for(let r=0;r<t;r++){let M=0,A=0;for(let i=-d;i<=d;i++){if(r+i<0||r+i>=t)continue;const f=g[i+d];M+=f*m[2*(n*t+(r+i))],A+=f*m[2*(n*t+(r+i))+1]}l[2*(n*t+r)]=M,l[2*(n*t+r)+1]=A}const e=new Float32Array(m.length);for(let n=0;n<t;n++)for(let r=0;r<o;r++){let M=0,A=0;for(let i=-d;i<=d;i++){if(r+i<0||r+i>=o)continue;const f=g[i+d];M+=f*l[2*((r+i)*t+n)],A+=f*l[2*((r+i)*t+n)+1]}e[2*(r*t+n)]=M,e[2*(r*t+n)+1]=A}return e}function ut(m,t){const o=new Q,u=m.reduce((e,n)=>e+n.vertices.length,0),d=new Float32Array(4*u),g=new Array(m.length);let c=0,l=0;for(const{vertices:e}of m){const n=c;for(const r of e)d[4*c]=r.x,d[4*c+1]=r.y,d[4*c+2]=r.t,d[4*c+3]=r.speed,c++;g[l++]={startVertex:n,numberOfVertices:e.length,totalTime:e[e.length-1].t,timeSeed:o.getFloat()}}return{lineVertices:d,lineDescriptors:g}}function dt(m,t){const{lineVertices:u,lineDescriptors:d}=m;let g=0,c=0;for(const i of d)g+=2*i.numberOfVertices,c+=6*(i.numberOfVertices-1);const l=new Float32Array(g*9),e=new Uint32Array(c);let n=0,r=0;function M(){e[r++]=n-2,e[r++]=n,e[r++]=n-1,e[r++]=n,e[r++]=n+1,e[r++]=n-1}function A(i,f,x,v,y,h,p,w){const a=n*9;let s=0;l[a+s++]=i,l[a+s++]=f,l[a+s++]=1,l[a+s++]=x,l[a+s++]=h,l[a+s++]=p,l[a+s++]=v/2,l[a+s++]=y/2,l[a+s++]=w,n++,l[a+s++]=i,l[a+s++]=f,l[a+s++]=-1,l[a+s++]=x,l[a+s++]=h,l[a+s++]=p,l[a+s++]=-v/2,l[a+s++]=-y/2,l[a+s++]=w,n++}for(const i of d){const{totalTime:f,timeSeed:x}=i;let v=null,y=null,h=null,p=null,w=null,a=null;for(let s=0;s<i.numberOfVertices;s++){const D=u[4*(i.startVertex+s)],F=u[4*(i.startVertex+s)+1],L=u[4*(i.startVertex+s)+2],_=u[4*(i.startVertex+s)+3];let P=null,S=null,B=null,N=null;if(s>0){P=D-v,S=F-y;const V=Math.sqrt(P*P+S*S);if(P/=V,S/=V,s>1){let I=P+w,k=S+a;const b=Math.sqrt(I*I+k*k);I/=b,k/=b;const R=Math.min(1/(I*P+k*S),t);I*=R,k*=R,B=-k,N=I}else B=-S,N=P;B!==null&&N!==null&&(A(v,y,h,B,N,f,x,_),M())}v=D,y=F,h=L,w=P,a=S,p=_}A(v,y,h,-a,w,f,x,p)}return{vertexData:l,indexData:e}}function wt(m){const{lineVertices:d,lineDescriptors:g}=m;let c=0,l=0;for(const V of g){const I=V.numberOfVertices-1;c+=4*I*2,l+=6*I*2}const e=new Float32Array(c*16),n=new Uint32Array(l);let r,M,A,i,f,x,v,y,h,p,w,a,s,D,F=0,L=0;function _(){n[L++]=F-8,n[L++]=F-7,n[L++]=F-6,n[L++]=F-7,n[L++]=F-5,n[L++]=F-6,n[L++]=F-4,n[L++]=F-3,n[L++]=F-2,n[L++]=F-3,n[L++]=F-1,n[L++]=F-2}function P(V,I,k,b,R,C,O,j,E,G,X,Y,Z,$){const q=F*16;let T=0;for(const tt of[1,2])for(const et of[1,2,3,4])e[q+T++]=V,e[q+T++]=I,e[q+T++]=k,e[q+T++]=b,e[q+T++]=O,e[q+T++]=j,e[q+T++]=E,e[q+T++]=G,e[q+T++]=tt,e[q+T++]=et,e[q+T++]=Z,e[q+T++]=$,e[q+T++]=R/2,e[q+T++]=C/2,e[q+T++]=X/2,e[q+T++]=Y/2,F++}function S(V,I){let k=h+w,b=p+a;const R=Math.sqrt(k*k+b*b);k/=R,b/=R;const C=h*k+p*b;k/=C,b/=C;let O=w+s,j=a+D;const E=Math.sqrt(O*O+j*j);O/=E,j/=E;const G=w*O+a*j;O/=G,j/=G,P(r,M,A,i,-b,k,f,x,v,y,-j,O,V,I),_()}function B(V,I,k,b,R,C){if(h=w,p=a,w=s,a=D,h==null&&p==null&&(h=w,p=a),f!=null&&x!=null){s=V-f,D=I-x;const O=Math.sqrt(s*s+D*D);s/=O,D/=O}h!=null&&p!=null&&S(R,C),r=f,M=x,A=v,i=y,f=V,x=I,v=k,y=b}function N(V,I){h=w,p=a,w=s,a=D,h==null&&p==null&&(h=w,p=a),h!=null&&p!=null&&S(V,I)}for(const V of g){r=null,M=null,A=null,i=null,f=null,x=null,v=null,y=null,h=null,p=null,w=null,a=null,s=null,D=null;const{totalTime:I,timeSeed:k}=V;for(let b=0;b<V.numberOfVertices;b++)B(d[4*(V.startVertex+b)],d[4*(V.startVertex+b)+1],d[4*(V.startVertex+b)+2],d[4*(V.startVertex+b)+3],I,k);N(I,k)}return{vertexData:e,indexData:n}}function J(m,t,o=t.width,u=t.height,d=0,g=0){const c=t.pixels,l=o*u,e=2,n=new Float32Array(l*e),r=t.width,M=(f,x)=>f+d+(x+g)*r,A=(f,x)=>f+x*o;let i;if(t.mask!=null)if(o!==t.width||u!==t.height||d!==0||g!==0){i=new Uint8Array(l*e);const f=t.mask;for(let x=0;x<u;++x)for(let v=0;v<o;++v){const y=M(v,x),h=A(v,x);i[e*h]=f[e*y],i[e*h+1]=f[e*y+1]}}else i=t.mask;else i=new Uint8Array(l*e),i.fill(255);if(m==="vector-uv")for(let f=0;f<u;++f)for(let x=0;x<o;++x){const v=M(x,f),y=A(x,f);n[e*y]=c[0][v],n[e*y+1]=-c[1][v]}else if(m==="vector-magdir"){const{cos:f,sin:x}=Math;for(let v=0;v<u;++v)for(let y=0;y<o;++y){const h=M(y,v),p=A(y,v),w=c[0][h],a=at(c[1][h]),s=f(a-Math.PI/2),D=x(a-Math.PI/2);n[e*p]=s*w,n[e*p+1]=D*w}}return{data:n,mask:i,width:o,height:u}}async function pt(m,t,o,u,d,g){const c=performance.now(),l=rt(t.spatialReference);if(!l){const w=await K(m,t,o,u,d,g);return z("esri-2d-profiler")&&U().info("I.7","loadImagery, early exit (ms)",Math.round(performance.now()-c)),z("esri-2d-profiler")&&U().info("I.9","Number of parts",1),w}const[e,n]=l.valid,r=n-e,M=Math.ceil(t.width/r),A=t.width/M,i=Math.round(o/M);let f=t.xmin;const x=[],v=performance.now();for(let w=0;w<M;w++){const a=new it({xmin:f,xmax:f+A,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference});x.push(K(m,a,i,u,d,g)),f+=A}const y=await Promise.all(x);if(z("esri-2d-profiler")&&U().info("I.8","All calls to _fetchPart (ms)",Math.round(performance.now()-v)),z("esri-2d-profiler")&&U().info("I.9","Number of parts",y.length),y.length===1)return z("esri-2d-profiler")&&U().info("I.10","loadImagery, general exit without stitching back (ms)",Math.round(performance.now()-c)),y[0];const h={data:new Float32Array(o*u*2),mask:new Uint8Array(o*u),width:o,height:u};let p=0;for(const w of y){for(let a=0;a<w.height;a++)for(let s=0;s<w.width;s++)p+s>=o||(h.data[2*(a*o+p+s)]=w.data[2*(a*w.width+s)],h.data[2*(a*o+p+s)+1]=w.data[2*(a*w.width+s)+1],h.mask[a*o+p+s]=w.mask[a*w.width+s]);p+=w.width}return z("esri-2d-profiler")&&U().info("I.10","loadImagery, general exit (ms)",Math.round(performance.now()-c)),h}async function K(m,t,o,u,d,g){const c={requestProjectedLocalDirections:!0,signal:g};if(d!=null&&(c.timeExtent=d),m.type==="imagery"){await m.load({signal:g});const e=await m.internalFetchImage(t,o,u,c);return e?.pixelData?.pixelBlock==null?{data:new Float32Array(o*u*2),mask:new Uint8Array(o*u),width:o,height:u}:J(m.rasterInfo.dataType,e.pixelData.pixelBlock)}await m.load({signal:g});const l=await m.fetchPixels(t,o,u,c);return l?.pixelBlock==null?{data:new Float32Array(o*u*2),mask:new Uint8Array(o*u),width:o,height:u}:J(m.serviceRasterInfo.dataType,l.pixelBlock)}export{gt as c,ft as d,st as f,pt as x};
