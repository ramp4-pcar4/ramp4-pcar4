import{T as ft,c4 as O,D as vt,lN as Lt,fx as Ut,O as qt,eH as yt,$ as Nt,_ as u,Y as c,Z as z,V as _t,dk as Wt,bL as Xt,aK as at,h9 as Q,aw as S,X as Y,l as xt,eP as j,ct as bt,fg as U,a9 as q,L as lt,hC as Yt,gR as jt,cn as Bt}from"./main-CtmwM019.js";import{I as Kt,x as Z,U as Jt,t as ut,i as Qt,E as Pt}from"./elevationInfoUtils-Rm5QE2pq.js";import{t as te}from"./ReactiveSet-BnT-JVp6.js";import{y as ee}from"./diffUtils-MaI4D9Mw.js";import{h as ne}from"./UpdatingHandles-lgENzTF6.js";import{g as B,e as K,w as ie,a as se,V as re}from"./SnappingContext-BvZ1mDD1.js";import{W as R}from"./projectionUtils-DKBF6_Ma.js";import{c as oe}from"./meshVertexSpaceUtils-CeN7ZS2W.js";import{x as H,k as ae}from"./hydratedFeatures-BBluDIY8.js";import{f as T,T as tt,U as le,Z as wt,V as ue,W as St,X as ce,D as pe,Y as de,j as he,_ as Mt,$ as me,a0 as ge}from"./SketchViewModel-Bj0qQq8r.js";import{v as et,c as fe,a as ve}from"./quantityUtils-CU1WV3ce.js";import{c as ye,s as _e,u as xe}from"./vec32-gK3TWme0.js";import{n as G,t as nt}from"./projectVectorToVector-PMDI3BQJ.js";import{N as be}from"./geodesicUtils-BG1Wf2YN.js";import{R as M,j as Tt,U as Pe}from"./angularMeasurementUtils-Cr9hvkn9.js";import{G as Et,f as Ct}from"./Scheduler-DIu-iJOg.js";function D(t,e){return t===e||t!=null&&e!=null&&ft(t.spatialReference,e.spatialReference)&&t.x===e.x&&t.y===e.y&&t.z===e.z&&t.m===e.m}function N(t,e,n){return t===e||t!=null&&e!=null&&ft(t.spatialReference,e.spatialReference)&&O(t.x,e.x,n)&&O(t.y,e.y,n)&&O(t.z??0,e.z??0,n)&&O(t.m??0,e.m??0,n)}function pn(t,e,n,i,s,r){let a="geodesic",o=be(n);const l=T();return tt(t,e,i,l),l[2]=0,o&&G(l,n,l,o)||(a="euclidean",o=n),{mode:a,view:e,elevationInfo:i,hasZ:s,directionMode:r,spatialReference:t.spatialReference,measurementSR:o,origin:l}}function we(t,e,n){if(e==null||t==null)return;const i=Lt(n.measurementSR);if(i==null)return;const s=k(t,n);if(s==null)return;const r=et(e,i);return new ue(s,r)}function Se(t,e,n,i){if(n==null||t==null)return;const s=k(t,i);if(s==null)return;const r=M(n),a=10,o=p=>{if(p==null)return;const h=T(),g=fe(p,"degrees","geographic");return Pe(h,s,i.measurementSR,a,g,i.mode)?new pe(s,h):void 0},l=()=>{if(e!=null&&t!=null)return M(Tt(e,t))};switch(i.directionMode){case"absolute":return o(r);case"relative":{const p=l();return p==null?void 0:o(p+r)}case"relative-bilateral":{const p=l();return p==null?void 0:St([o(p+r),o(p-r)])}}}function $t(t,e){const n=A(t,e);return n!=null?new ce(n):void 0}function Vt(t,e,n){const{context:i,longitude:s,latitude:r,direction:a,distance:o,elevation:l}=n;if(s!=null||r!=null||o!=null||l!=null||a!=null){if(s!=null||r!=null){const p=M(s),h=M(r),g=A(l,i);return new wt(p,h,g)}return Me(t,e,n)}}function Me(t,e,{context:n,direction:i,distance:s,elevation:r}){if(e==null)return $t(r,n);const{view:a,elevationInfo:o,measurementSR:l}=n,p=tt(e,a,o);if(!l||!G(p,e.spatialReference,ct,l))return;const[h,g]=ct,y=s!=null?et(s,"meters"):void 0,m=M(i),E=A(r,n),f=_=>{const w=new de([h,g],l,y,E,_);return y==null||_==null||E==null&&n.hasZ?w:new he(w.closestTo(p))};if(m==null)return f(void 0);const P=()=>{if(t!=null&&e!=null)return M(Tt(t,e))};switch(n.directionMode){case"absolute":return f(m);case"relative":{const _=P();return _==null?void 0:f(_+m)}case"relative-bilateral":{const _=P();return _==null?void 0:St([f(_+m),f(_-m)])}}}function Te(t){return t.context.mode==="geodesic"?Vt(null,null,t):Ot(t)}function Ee(t,e,n){const{context:i,x:s,y:r,distance:a,direction:o,elevation:l}=n;return i.mode==="geodesic"?Vt(e,t,n):s!=null||r!=null?Ot(n):Ce([we(t,a,i),Se(t,e,o,i),$t(l,i)])}function Ot({x:t,y:e,elevation:n,context:i}){I.x=t?.value??0,I.y=e?.value??0,I.spatialReference=i.spatialReference;const s=k(I,i,Oe);return new wt(t!=null&&s!=null?s[0]:void 0,e!=null&&s!=null?s[1]:void 0,A(n,i))}function Ce(t){let e;for(const n of t)n&&(e=e?.intersect(n)??n);return e}function k(t,e,n=T()){const{view:i,elevationInfo:s,measurementSR:r,origin:a,mode:o}=e;if(tt(t,i,s,n),G(n,t.spatialReference,n,r))return o!=="geodesic"&&ye(n,n,a),n}function $e(t,e,n,i){const{view:s,measurementSR:r,spatialReference:a,origin:o,mode:l}=n;if(l==="geodesic"?_e($,t):xe($,t,o),G($,r,$,a))return le($,s,e,n,i)}function A(t,e){return Ve(t,e)?.value??void 0}function Ve(t,{view:e,origin:n,elevationInfo:i,hasZ:s,measurementSR:r}){if(t==null||!s)return;const a=Ut(r);if(a==null)return;const[o,l]=n,p=et(t,a),h=e?.type==="3d"?Kt(e,o,l,p,r,i):p;return h!=null?ve(h,a):void 0}const ct=T(),Oe=T(),$=T(),I=nt(0,0,0,vt.WGS84);class Ie{constructor(){this._isToolEditable=!0,this._manipulators=new qt,this._resourceContexts={manipulator3D:{}},this._attached=!1}set isToolEditable(e){this._isToolEditable=e}get length(){return this._manipulators.length}add(e,n=0){this.addMany([e],n)}addMany(e,n=0){for(const i of e){const s={manipulator:i,visibilityPredicate:n,attached:!1};this._manipulators.add(s),this._attached&&this._updateManipulatorAttachment(s)}}remove(e){for(let n=0;n<this._manipulators.length;n++)if(this._manipulators.at(n).manipulator===e){const i=this._manipulators.splice(n,1)[0];this._detachManipulator(i);break}}removeAll(){this._manipulators.forEach(e=>{this._detachManipulator(e)}),this._manipulators.removeAll()}attach(){this._manipulators.forEach(e=>{this._updateManipulatorAttachment(e)}),this._attached=!0}detach(){this._manipulators.forEach(e=>{this._detachManipulator(e)}),this._attached=!1}destroy(){this.detach(),this._manipulators.forEach(({manipulator:e})=>e.destroy()),this._manipulators.destroy(),this._resourceContexts=null}on(e,n){return this._manipulators.on(e,i=>{n(i)})}forEach(e){for(const n of this._manipulators.items)e(n)}some(e){return this._manipulators.items.some(e)}toArray(){const e=[];return this.forEach(n=>e.push(n.manipulator)),e}intersect(e,n){let i=null,s=Number.MAX_VALUE;return this._manipulators.forEach(({manipulator:r,attached:a})=>{if(!a||!r.interactive)return;const o=r.intersectionDistance(e,n);o!=null&&o<s&&(s=o,i=r)}),i}_updateManipulatorAttachment(e){this._isManipulatorItemVisible(e)?this._attachManipulator(e):this._detachManipulator(e)}_attachManipulator(e){e.attached||(e.manipulator.attach&&e.manipulator.attach(this._resourceContexts),e.attached=!0)}_detachManipulator(e){if(!e.attached)return;const n=e.manipulator;n.grabbing=!1,n.dragging=!1,n.hovering=!1,n.selected=!1,n.detach&&n.detach(this._resourceContexts),e.attached=!1}_isManipulatorItemVisible(e){return e.visibilityPredicate===2||(this._isToolEditable?e.visibilityPredicate===0:e.visibilityPredicate===1)}}let v=class extends yt{constructor(t){super(t),this.manipulators=new Ie,this.automaticManipulatorSelection=!0,this.hasGrabbedManipulators=!1,this.hasHoveredManipulators=!1,this.firstGrabbedManipulator=null,this.created=!1,this.removeIncompleteOnCancel=!0,this._editableFlags=new Map([[1,!0],[0,!0]]),this._creationFinishedResolver=Nt()}get active(){return this.view!=null&&this.view.activeTool===this}set visible(t){this._get("visible")!==t&&(this._set("visible",t),this._syncVisible())}get editable(){return this.getEditableFlag(0)}set editable(t){this.setEditableFlag(0,t)}get updating(){return!1}get cursor(){return null}get hasFocusedManipulators(){return this.hasGrabbedManipulators||this.hasHoveredManipulators}destroy(){this.manipulators.destroy(),this._set("view",null)}onAdd(){this._syncVisible()}activate(){this.view!=null&&(this.view.focus(),this.onActivate())}deactivate(){this.onDeactivate()}cancel(){this.emit("cancel")}handleInputEvent(t){this.onInputEvent(t)}handleInputEventAfter(t){this.onInputEventAfter(t)}setEditableFlag(t,e){this._editableFlags.set(t,e),this.manipulators.isToolEditable=this.internallyEditable,this._updateManipulatorAttachment(),t===0&&this.notifyChange("editable"),this.onEditableChange(),this.onManipulatorSelectionChanged()}getEditableFlag(t){return this._editableFlags.get(t)??!1}endDrag(){const t=this.view.inputManager.latestPointerInfo?.location;if(!t)return;let e=!1;this.manipulators.forEach(({manipulator:n})=>{n.dragging&&(e=!0,n.events.emit("drag",{action:"end",start:t,screenPoint:t}))}),e&&(this.view.toolViewManager.activeTool=null)}whenCreated(){return this._creationFinishedResolver.promise}onManipulatorSelectionChanged(){}onActivate(){}onDeactivate(){}onShow(){}onHide(){}onEditableChange(){}onInputEvent(t){}onInputEventAfter(t){}get internallyEditable(){return this.getEditableFlag(0)&&this.getEditableFlag(1)}finishToolCreation(){this.created||this._creationFinishedResolver.resolve(this),this._set("created",!0)}_syncVisible(){if(this.initialized){if(this.visible)this._show();else if(this._hide(),this.active)return void(this.view.activeTool=null)}}_show(){this._updateManipulatorAttachment(),this.onShow()}_hide(){this._updateManipulatorAttachment(),this.onHide()}_updateManipulatorAttachment(){this.visible?this.manipulators.attach():this.manipulators.detach()}};u([c({constructOnly:!0})],v.prototype,"view",void 0),u([c({readOnly:!0})],v.prototype,"active",null),u([c({value:!0})],v.prototype,"visible",null),u([c({value:!0})],v.prototype,"editable",null),u([c({readOnly:!0})],v.prototype,"manipulators",void 0),u([c({readOnly:!0})],v.prototype,"updating",null),u([c()],v.prototype,"cursor",null),u([c({readOnly:!0})],v.prototype,"automaticManipulatorSelection",void 0),u([c()],v.prototype,"hasFocusedManipulators",null),u([c()],v.prototype,"hasGrabbedManipulators",void 0),u([c()],v.prototype,"hasHoveredManipulators",void 0),u([c()],v.prototype,"firstGrabbedManipulator",void 0),u([c({readOnly:!0})],v.prototype,"created",void 0),u([c({readOnly:!0})],v.prototype,"removeIncompleteOnCancel",void 0),v=u([z("esri.views.interactive.InteractiveToolBase")],v);const It="click";let x=class extends _t{constructor(e){super(e),this.events=new Wt,this.interactive=!0,this.selectable=!1,this.cursor=null,this.grabbable=!0}intersectionDistance(e,n){return 0}attach(){}detach(){}onElevationChange(){}onViewChange(){}};u([c()],x.prototype,"interactive",void 0),u([c()],x.prototype,"selectable",void 0),u([c()],x.prototype,"cursor",void 0),u([c()],x.prototype,"grabbing",void 0),u([c()],x.prototype,"grabbable",void 0),u([c()],x.prototype,"consumesClicks",void 0),u([c()],x.prototype,"grabbableForEvent",void 0),u([c()],x.prototype,"dragging",void 0),u([c()],x.prototype,"hovering",void 0),u([c()],x.prototype,"selected",void 0),x=u([z("esri.views.draw.LegacyDrawManipulator")],x);function De(t,e){let n=null,i=null;return s=>{if(s.action==="cancel")return void(i!=null&&(i.execute({action:"cancel"}),n=null,i=null));const r={action:s.action,screenStart:s.start,screenEnd:s.screenPoint};s.action==="start"&&n==null&&(n=new V,i=new V,e(t,n,i,s.pointerType,r)),n?.execute(r),s.action==="end"&&n!=null&&(n=null,i=null)}}function W(t,e){return t.events.on("drag",De(t,e))}function hn(t,e){const n=[t.x,t.y,t.z??0],i=e,s=[Math.cos(i),Math.sin(i)],r=Math.sqrt(s[0]*s[0]+s[1]*s[1]);if(r===0)return null;s[0]/=r,s[1]/=r;const a=o=>{const l=(o.x-n[0])*s[0]+(o.y-n[1])*s[1];o.x=n[0]+l*s[0],o.y=n[1]+l*s[1]};return o=>(a(o.mapStart),a(o.mapEnd),{...o,axis:s})}function Ze(t){let e=null;const n=Dt();return i=>{if(i.action==="start"&&(e=Re(t,i.mapStart.spatialReference)),e==null)return null;const s=n(i);if(!s)return null;const{translationX:r,translationY:a,translationZ:o}=s;return e.move(r,a,o,i.action),s}}function pt(t,e){return t==null?null:t.spatialReference.equals(e)?t.clone():R(t,e)}function Re(t,e){const n=t.operations;if(!n)return null;const i=n.data.geometry,s=ae(e);if(i.spatialReference.equals(s))return X(t,n,()=>{});if(i.type!=="mesh"){const r=pt(i,s);if(r==null)return null;const a=i.spatialReference,o=B.fromGeometry(r,n.viewingMode);return X(t,o,()=>{const l=o.data.geometry,p=R(l,a);n.trySetGeometry(p)})}if(oe(i)){const r=pt(i.origin,s);if(!r)return null;const a=i.spatialReference,o=B.fromGeometry(r,n.viewingMode);return X(t,n,()=>{const l=R(o.data.geometry,a),p=l.x-i.origin.x,h=l.y-i.origin.y,g=(l.z??0)-(i.origin.z??0);n.move(p,h,g)})}return null}function X(t,e,n){let i=0,s=0,r=0;return{move:(a,o,l,p)=>{p==="start"&&(i=0,s=0,r=0);const h=a-i,g=o-s,y=l-r;e.move(h,g,y),i+=h,s+=g,r+=y,n(),p==="end"&&t.endInteraction?.()}}}function mn(t,e=null,n){let i=null;const s=e==null||t.spatialReference?.equals(e)?a=>a:a=>a!=null?R(a,e):a,r={exclude:[],...n};return a=>{if(a.action==="start"&&(i=s(t.toMap(a.screenStart,r))),i==null)return null;const o=s(t.toMap(a.screenEnd,r));return o!=null?{...a,mapStart:i,mapEnd:o}:null}}function gn(t){const e=t.map(i=>Ze(i)).filter(Xt),n=Dt();return i=>{const s=n(i);return e.forEach(r=>r(i)),s}}function ze(t){const e=t.operations?.createResetState();return n=>(e?.remove(),n)}function fn(t){const e=t.map(n=>ze(n)).filter(n=>n!=null);return n=>(e.forEach(i=>i(n)),n)}function vn(){let t=0,e=0,n=0;return i=>{i.action==="start"&&(t=i.mapStart.x,e=i.mapStart.y,n=i.mapStart.z??0);const s=i.mapEnd.x-t,r=i.mapEnd.y-e,a=(i.mapEnd.z??0)-n;return t=i.mapEnd.x,e=i.mapEnd.y,n=i.mapEnd.z,{...i,mapDeltaX:s,mapDeltaY:r,mapDeltaZ:a,mapDeltaSpatialReference:i.mapStart.spatialReference}}}function Dt(){let t=0,e=0,n=0;return i=>{i.action==="start"&&(t=i.mapStart.x,e=i.mapStart.y,n=i.mapStart.z??0);const s=i.mapEnd.x-t,r=i.mapEnd.y-e,a=(i.mapEnd.z??0)-n;return{...i,translationX:s,translationY:r,translationZ:a}}}function yn(){let t=0,e=0;return n=>{n.action==="start"&&(t=n.screenStart.x,e=n.screenStart.y);const i=n.screenEnd.x-t,s=n.screenEnd.y-e;return t=n.screenEnd.x,e=n.screenEnd.y,{...n,screenDeltaX:i,screenDeltaY:s}}}function _n(t,e){let n=null,i=0,s=0;return r=>{if(r.action==="start"&&(n=t.toScreen?.(e),n!=null&&(n.x<0||n.x>t.width||n.y<0||n.y>t.height?n=null:(i=r.screenStart.x-n.x,s=r.screenStart.y-n.y))),n==null)return null;const a=at(r.screenEnd.x-i,0,t.width),o=at(r.screenEnd.y-s,0,t.height),l=Q(a,o);return r.screenStart=n,r.screenEnd=l,r}}const He=()=>{};class V{constructor(){this.execute=He}next(e,n=new V){return e!=null&&(this.execute=i=>{const s=e(i);s!=null&&n.execute(s)}),n}}function Ge(t,e,n=[]){if(t.type==="2d")return s=>s;let i=null;return s=>{s.action==="start"&&(i=t.toMap(s.screenStart,{exclude:n}),i!=null&&(i.z=Z(i,t,e)));const r=t.toMap(s.screenEnd,{exclude:n});r!=null&&(r.z=Z(r,t,e));const a=i!=null&&r!=null?{sceneStart:i,sceneEnd:r}:null;return{...s,scenePoints:a}}}function dt(t,e,n){const i=e.elevationProvider.getElevation(t.x,t.y,t.z??0,t.spatialReference,"scene")??0,s=H(t);return s.z=i,s.hasZ=!0,s.z=Z(s,e,n),s}function xn(t,e){if(t.type==="2d")return i=>i;let n=null;return i=>{i.action==="start"&&(n=dt(i.mapStart,t,e));const s=dt(i.mapEnd,t,e),r=n!=null&&s!=null?{sceneStart:n,sceneEnd:s}:null;return{...i,scenePoints:r}}}function ke({predicate:t=()=>!0,snappingManager:e,snappingContext:n,updatingHandles:i,useZ:s=!0}){const r=new V;if(e==null)return{snappingStep:[ht,r],cancelSnapping:ht};let a,o=null,l=null,p=null;const h=()=>{o=Y(o),e.doneSnapping(),l?.frameTask.remove(),l=null,a=xt(a),p=null},g=Ae(e,s,r);let y=null,m=null,E=null;return{snappingStep:[f=>{if(!t(f))return f;const{action:P}=f;if(P==="start"){const{info:_}=f,w=Fe(e.view);if(l=Le(n,f,w),l.context.selfSnappingZ=null,!s&&_!=null){const C=qe(n.coordinateHelper,_.handle.part);C!=null&&(l.context.selfSnappingZ={value:C,elevationInfo:n.elevationInfo??Jt})}}if(l!=null){const{context:_,originalScenePos:w,originalPos:C}=l,{mapEnd:it,mapStart:st,scenePoints:Ht}=f,F=Zt(C,J(it,st)),rt=J(st,C),Gt={...f,action:"update"},kt=l.context,L=Ue(w,Ht),ot=e.update({point:F,scenePoint:L,context:_});if(E=ot,Rt(it,ot,rt,s),y=F,m=L,P!=="end"){const{frameTask:At}=l;o==null&&(o=new AbortController),p=Ft=>{i.addPromise(j(g({frameTask:At,event:Gt,context:kt,point:F,scenePoint:L,delta:rt,getLastState:()=>({point:y,scenePoint:m,updatePoint:Ft.forceUpdate?null:E})},o.signal)))},p({forceUpdate:!1}),a==null&&(a=S(()=>e.options.effectiveEnabled,()=>p?.({forceUpdate:!0})))}}return P==="end"&&h(),f},r],cancelSnapping:f=>(h(),f)}}function Ae(t,e,n){return bt(async({frameTask:i,point:s,scenePoint:r,context:a,event:o,delta:l,getLastState:p},h)=>{const g=await i.schedule(()=>t.snap({point:s,scenePoint:r,context:a,signal:h}),h);if(g.valid){let y=await i.schedule(()=>g.apply(),h);const m=p();m.point!=null&&s!==m.point&&(y=t.update({point:m.point,scenePoint:m.scenePoint,context:a})),m.updatePoint!=null&&D(y,m.updatePoint)||(Rt(o.mapEnd,y,l,e),n.execute(o))}})}function Fe(t){return t.type==="3d"?t.resourceController.scheduler.registerTask(Ct.SNAPPING):Et}function Le(t,e,n){return{context:new K({editGeometryOperations:t.editGeometryOperations,elevationInfo:t.elevationInfo,pointer:t.pointer,vertexHandle:e.info!=null?e.info.handle:null,excludeFeature:t.excludeFeature,feature:t.feature,visualizer:t.visualizer}),originalPos:e.snapOrigin!=null?t.coordinateHelper.vectorToDehydratedPoint(e.snapOrigin):e.mapStart,originalScenePos:e.scenePoints!=null?e.scenePoints.sceneStart:null,frameTask:n}}function Zt(t,[e,n,i]){const s=H(t);return s.x+=e,s.y+=n,s.hasZ&&(s.z+=i),s}function Ue(t,e){return t==null||e==null?null:Zt(t,J(e.sceneEnd,e.sceneStart))}function J(t,e){const n=t.hasZ&&e.hasZ?t.z-e.z:0;return[t.x-e.x,t.y-e.y,n]}function Rt(t,e,[n,i,s],r){t.x=e.x+n,t.y=e.y+i,r&&t.hasZ&&e.hasZ&&(t.z=e.z+s)}function qe(t,e){if(!t.hasZ())return null;const n=e.vertices;let i=null;for(const s of n){const r=t.getZ(s.pos);if(i!=null&&r!=null&&Math.abs(r-i)>1e-6)return null;i==null&&(i=r)}return i}function ht(t){return t}let b=class extends _t{constructor(t){super(t),this.constrainResult=e=>e,this._snapPoints=null,this._frameTask=null,this._abortController=null,this._stagedPoint=null,this._snap=bt(async(e,n,i,s)=>{const r=this._frameTask;if(r==null)return;const a=await r.schedule(()=>n.snap({...e,context:i,signal:s}),s);a.valid&&await r.schedule(()=>{this.stagedPoint=a.apply(),e!==this._snapPoints&&this._snapPoints!=null&&(this.stagedPoint=n.update({...this._snapPoints,context:i}))},s)})}get stagedPoint(){return this._stagedPoint}set stagedPoint(t){this._stagedPoint=this.constrainResult(t)}initialize(){const t=this.view.type==="3d"?this.view?.resourceController?.scheduler:null;this._frameTask=t!=null?t.registerTask(Ct.SNAPPING):Et}destroy(){this._abortController=Y(this._abortController),this._frameTask=xt(this._frameTask)}update(t,e,n){this._snapPoints=t;const{point:i,scenePoint:s}=t,r=e.update({point:i,scenePoint:s,context:n});return this.stagedPoint=r,r}async snap(t,e,n){const{point:i,scenePoint:s}=t;return this.stagedPoint=e.update({point:i,scenePoint:s,context:n}),this._snapPoints=t,this._abortController==null&&(this._abortController=new AbortController),this._snap(t,e,n,this._abortController.signal)}async snapAgainNearPreviousMapPoint(t,e){this._snapPoints!=null&&await this.snap(this._snapPoints,t,e)}abort(){this._abortController=Y(this._abortController),this._snapPoints=null}};u([c({constructOnly:!0})],b.prototype,"view",void 0),u([c()],b.prototype,"stagedPoint",null),u([c()],b.prototype,"constrainResult",void 0),u([c()],b.prototype,"_stagedPoint",void 0),b=u([z("esri.views.interactive.snapping.SnappingOperation")],b);const Ne="crosshair",We="progress",mt=Symbol(),gt=Symbol();let d=class extends yt{constructor(t){super(t),this._createOperationCompleted=!1,this._hideDefaultCursor=!1,this._pointerDownStates=new te,this._stagedScreenPoint=null,this._stagedPointerType=null,this._updatingHandles=new ne,this._stagedPointerId=null,this.constraintsEnabled=!1,this.constraints=void 0,this._getPointConstraint=ut(Te),this._getPolylineOrPolygonConstraint=ut(Ee),this.constraintZ=null,this.defaultZ=null,this.isDraped=!0,this.labelOptions=new Mt,this.cursor=null,this.loading=!1,this.snapToSceneEnabled=null,this.firstVertex=null,this.lastVertex=null,this.secondToLastVertex=null,t.elevationInfo==null&&(this.elevationInfo=Qt(!!t.hasZ))}initializePointer(){const t=this.view.inputManager?.latestPointerInfo;t!=null&&this._updatePointer(t.location,t.id,t.type)}initialize(){const{geometryType:t,view:e}=this,n=e.spatialReference,i="viewingMode"in e.state?e.state.viewingMode:2,s=t==="segment"||t==="multipoint"?"polyline":t;this.coordinateHelper=ie(this.hasZ,this.hasM,n),this._editGeometryOperations=new B(new se(s,this.coordinateHelper),i),this._snappingOperation=new b({view:e}),this.addHandles([S(()=>({stagedPoint:this._snappingOperation.stagedPoint,constraint:this._constraint}),({stagedPoint:o,constraint:l},p)=>{const{snappingOptions:h}=this;if(h&&(h.forceDisabled=l!=null&&me(l)),p!=null&&o===p.stagedPoint&&l!==p.constraint)return this._onKeyboardBasedChange();this._processCursor(o??this._screenToMap(this._stagedScreenPoint))},{equals:(o,l)=>o.stagedPoint===l.stagedPoint&&Yt(o.constraint,l.constraint)}),S(()=>this.view.viewpoint,(o,l)=>{o&&l&&ee(o,l)&&this._onKeyboardBasedChange()})]),this._activePart=new re(n,i),this._editGeometryOperations.data.parts.push(this._activePart);const r=this.segmentLabels;r!=null&&(r.context={view:e,editGeometryOperations:this._editGeometryOperations,elevationInfo:this.elevationInfo,labelOptions:this.labelOptions,automaticLengthMeasurementUtils:this.automaticLengthMeasurementUtils},this.addHandles(S(()=>this.labelOptions.enabled,o=>{r.visible=o},U))),this.addHandles(this._editGeometryOperations.on(["vertex-add","vertex-update","vertex-remove"],o=>{const l=o.vertices.map(m=>({componentIndex:0,vertexIndex:m.index,coordinates:this.coordinateHelper.vectorToArray(m.pos)})),p=l.map(m=>m.coordinates),h=this.coordinateHelper.vectorToDehydratedPoint(this._activePart.getFirstVertex()?.pos)??null;D(h,this.firstVertex)||(this.firstVertex=h);const g=this.coordinateHelper.vectorToDehydratedPoint(this._activePart.getLastVertex()?.pos)??null;D(g,this.lastVertex)||(this.lastVertex=g);const y=this.coordinateHelper.vectorToDehydratedPoint(this._activePart.segments.at(-1)?.leftVertex?.pos)??null;switch(D(y,this.secondToLastVertex)||(this.secondToLastVertex=y),this._processCursor(this.cursorVertex),o.type){case"vertex-add":this.emit(o.type,{...o,added:p,vertices:l});break;case"vertex-update":this.emit(o.type,{...o,updated:p,vertices:l});break;case"vertex-remove":this.emit(o.type,{...o,removed:p,vertices:l})}}));const a=this._manipulator=new x({consumesClicks:!1,grabbableForEvent:o=>this.drawingMode!=="click"||o.pointerType==="touch"&&this._snappingEnabled&&this._pointerDownStates.size===1});this.manipulators.add(a),a.grabbable=t!=="point"&&t!=="multipoint",this.addHandles([a.events.on("immediate-click",o=>this._onImmediateClick(o)),a.events.on("immediate-double-click",o=>this._onImmediateDoubleClick(o)),S(()=>this.drawingMode,()=>{this.removeHandles(mt),this.addHandles(this._createManipulatorDragPipeline(a),mt)},U),S(()=>({effectiveCursor:this.effectiveCursor}),({effectiveCursor:o})=>{a.cursor=o},U)]),ge(this,()=>{const o=this.view.inputManager.latestPointerInfo?.type??"mouse",l=this._getSnappingContext(o);if(this.snappingManager!=null){const p=this._snappingOperation.snapAgainNearPreviousMapPoint(this.snappingManager,l);this._updatingHandles.addPromise(j(p))}})}destroy(){q(this.segmentLabels),q(this._snappingOperation),this._editGeometryOperations=q(this._editGeometryOperations),this._updatingHandles.destroy()}get _isDragging(){const{_stagedPointerId:t,_manipulator:e}=this;return t!=null&&this._pointerDownStates.has(t)||e.grabbing||!e.interactive}get _snappingEnabled(){return this.snappingManager!=null&&this.snappingManager.options.effectiveEnabled}get _requiresScenePoint(){const t=this._updateAndGetEffectiveDrawSurface();return this.view.type==="3d"&&this.drawSurface!==t}get canRedo(){return this._editGeometryOperations.canRedo}get canUndo(){return this._editGeometryOperations.canUndo}get committedVertices(){return this._activePart.vertices.map(t=>this.coordinateHelper.vectorToArray(t.pos))}get _constraint(){const{constraints:t,constraintsEnabled:e}=this;if(t&&e)switch(this.geometryType){case"point":case"multipoint":return this._getPointConstraint(t);case"polygon":case"polyline":return this._getPolylineOrPolygonConstraint(this.lastVertex,this.secondToLastVertex,t)}}set drawingMode(t){this._set("drawingMode",t??It)}get effectiveCursor(){return this.loading?We:this._hideDefaultCursor?null:this.cursor||Ne}get interactive(){return this._manipulator.interactive}set interactive(t){this._manipulator.interactive=t}get isCompleted(){return this._createOperationCompleted}get numCommittedVertices(){return this._activePart.vertices.length}get snappingOptions(){return this.snappingManager!=null?this.snappingManager.options:null}get cursorVertex(){return this._get("cursorVertex")}get visualizationCursorVertex(){return this._stagedPointerType==="mouse"?this.cursorVertex:null}get committableVertex(){const{cursorVertex:t,lastVertex:e,firstVertex:n,geometryType:i}=this;return i==="polygon"&&N(t,n)||N(t,e)?null:t}get updating(){return this._updatingHandles.updating}get geometryIncludingUncommittedVertices(){const{committedVertices:t,committableVertex:e,coordinateHelper:n}=this,i=t.slice();return e!=null&&i.push(n.pointToArray(e)),i}cancel(){this.complete({aborted:!0})}commitStagedVertex(){this._snappingOperation.abort();const{committableVertex:t}=this;t!=null&&this._editGeometryOperations.appendVertex(this.coordinateHelper.pointToVector(t),this._activePart)}complete(t){const e=t?.aborted||!1;this._snappingOperation.abort(),this.snappingManager?.doneSnapping();const{geometryType:n,numCommittedVertices:i}=this,s=n==="multipoint"&&i===0||n==="polyline"&&i<2||n==="polygon"&&i<3;n!=="segment"&&n!=="point"||this.commitStagedVertex(),this._createOperationCompleted=!s,(this.isCompleted||e)&&(this._stagedScreenPoint=null,this._stagedPointerId=null,this._stagedPointerType=null,this._processCursor(null),this.emit("complete",{vertices:this.committedVertices.map((r,a)=>({componentIndex:0,vertexIndex:a,coordinates:r})),aborted:e,type:"complete"}))}onInputEvent(t){switch(t.type){case"pointer-down":this._pointerDownStates.add(t.pointerId);break;case"pointer-up":this._pointerDownStates.delete(t.pointerId)}switch(t.type){case"pointer-move":return this._onPointerMove(t);case"hold":return this._onHold(t)}}redo(){this._editGeometryOperations.redo()}undo(){this.snappingManager!=null&&this.snappingManager.doneSnapping(),this._editGeometryOperations.undo()}_processCursor(t){const e=lt(this.cursorVertex),n=lt(t),i=n&&(this._updateAndGetEffectiveDrawSurface()?.constrainZ(n)??n),s=this._snapToClosingVertex(i),r=this._applyConstraints(s);N(e,r)||(this._set("cursorVertex",r),this.segmentLabels?.set("stagedVertex",r!=null?this.coordinateHelper.pointToVector(r):null),r==null||this._stagedPointerType!=="mouse"?this.emit("cursor-remove"):this.emit("cursor-update",{updated:null,vertices:[{componentIndex:0,vertexIndex:this._activePart.vertices.length,coordinates:this.coordinateHelper.pointToArray(r)}],operation:"apply",type:"vertex-update"}))}_snapToClosingVertex(t){if(t==null||this._isDragging||this.geometryType!=="polygon"||this.numCommittedVertices<=2)return t;const e=this._mapToScreen(t);if(!e)return t;const n=this._activePart;return this._vertexWithinPointerDistance(n.vertices[0].pos,e)?this.firstVertex:this._vertexWithinPointerDistance(n.vertices.at(-1).pos,e)?this.lastVertex:t}_createManipulatorDragPipeline(t){switch(this.drawingMode){case"click":return this._createManipulatorDragPipelineClick(t);case"freehand":return this._createManipulatorDragPipelineFreehand(t);case"hybrid":return this._createManipulatorDragPipelineHybrid(t)}}_createManipulatorDragPipelineClick(t){return W(t,(e,n,i,s)=>{const r=s==="touch"&&this._snappingEnabled;if(this.isCompleted||!r)return;const{snappingStep:a,cancelSnapping:o}=ke({predicate:()=>r,snappingManager:this.snappingManager,snappingContext:new K({editGeometryOperations:this._editGeometryOperations,elevationInfo:this.elevationInfo,feature:this.graphic,pointer:s,visualizer:this.snappingVisualizer,drawConstraints:this.constraints}),updatingHandles:this._updatingHandles,useZ:!this._requiresScenePoint});i=i.next(l=>(r&&this.snappingManager!=null&&this.snappingManager.doneSnapping(),l)).next(o),n.next(this._screenToMapDragEventStep()).next(l=>(l.action==="start"&&(this._processCursor(l.mapStart),(this.geometryType==="segment"||r&&!this.numCommittedVertices)&&this.commitStagedVertex()),l)).next(Ge(this.view,this.elevationInfo)).next(...a).next(l=>(r&&(this._processCursor(l.mapEnd),l.action==="end"&&this.commitStagedVertex()),l)).next(l=>(l.action==="end"&&(this._stagedPointerType!=="mouse"&&this._snappingOperation.abort(),this.geometryType!=="segment"&&this.geometryType!=="point"||this.complete()),l))})}_createManipulatorDragPipelineFreehand(t){return W(t,(e,n)=>{this.isCompleted||n.next(this._screenToMapDragEventStep()).next(i=>(i.action==="start"&&(this._snappingOperation.abort(),this.committableVertex==null&&this._processCursor(i.mapStart),this.geometryType==="segment"&&this.commitStagedVertex()),i)).next(i=>{switch(i.action){case"start":case"update":this._processCursor(i.mapEnd),this.geometryType!=="polygon"&&this.geometryType!=="polyline"||this.commitStagedVertex();break;case"end":this.complete()}return i})})}_createManipulatorDragPipelineHybrid(t){return W(t,(e,n)=>{this.isCompleted||n.next(this._screenToMapDragEventStep()).next(i=>(i.action==="start"&&(this._snappingOperation.abort(),this.addHandles(this._editGeometryOperations.createUndoGroup(),gt),this._processCursor(i.mapStart),this.commitStagedVertex()),i)).next(i=>{switch(i.action){case"start":case"update":this._processCursor(i.mapEnd),this.geometryType!=="polygon"&&this.geometryType!=="polyline"||this.commitStagedVertex();break;case"end":this._stagedPointerType!=="mouse"&&this._snappingOperation.abort(),this.removeHandles(gt),this.geometryType!=="segment"&&this.geometryType!=="point"||this.complete()}return i})})}get _drawAtFixedElevation(){const{constraintsEnabled:t,constraintZ:e,geometryType:n,numCommittedVertices:i}=this;return t?e!=null||n==="segment"&&i>0:(n==="segment"||n==="polygon")&&i>0}_updateAndGetEffectiveDrawSurface(){const{constraintsEnabled:t,coordinateHelper:e,drawSurface:n,elevationDrawSurface:i,snapToSceneEnabled:s}=this;if(i==null)return n;if(!this.hasZ)return i.defaultZ=null,i;const r=this.elevationInfo?.mode;let a=this.defaultZ,o=t||r==="absolute-height";return s!=null&&(o=s),r==="on-the-ground"&&(o=!1),this._drawAtFixedElevation&&(a=(t?this.constraintZ:null)??e.getZ(this._activePart.vertices[0].pos),o=!1),o?n:(i.defaultZ=a,i)}_mapToScreen(t){return this._updateAndGetEffectiveDrawSurface()?.mapToScreen(t)}_onHold(t){this._snappingOperation.abort(),this.drawingMode==="click"&&t.pointerType==="touch"&&this._snappingEnabled&&this._processCursor(t.mapPoint),t.stopPropagation()}_onImmediateClick(t){if(!(t.pointerType==="mouse"&&t.button===2||this._manipulator.dragging))try{const{drawingMode:e,geometryType:n}=this;this._stagedPointerType=t.pointerType,this._stagedScreenPoint=t.screenPoint;const i=this._screenToMap(t.screenPoint);if(i==null||i==null||e==="freehand"&&n!=="point"&&n!=="multipoint")return;if(this._snappingEnabled&&this.cursorVertex!=null||this._processCursor(i),this.committableVertex==null)return void this.complete();this.commitStagedVertex(),t.pointerType!=="mouse"&&this._processCursor(null),(e==="freehand"&&this.geometryType!=="multipoint"||n==="point"||n==="segment"&&this.numCommittedVertices===2||n==="segment"&&e==="hybrid"&&this.numCommittedVertices===1)&&this.complete()}finally{t.stopPropagation()}}_onImmediateDoubleClick(t){this._manipulator.dragging||this.geometryType==="point"||(this.complete(),t.stopPropagation())}_onPointerMove(t){const e=Q(t.x,t.y);this._updatePointer(e,t.pointerId,t.pointerType)&&t.stopPropagation()}_updatePointer(t,e,n){return this._stagedScreenPoint=t,this._stagedPointerType=n,this._stagedPointerId=e,this._isDragging?(this._snappingOperation.abort(),!1):(this._processCursorMovementRelativeToSurface(t,n),!0)}_onKeyboardBasedChange(){this._stagedPointerType==="mouse"&&this._stagedScreenPoint&&this._stagedPointerId!=null&&!this._isDragging?this._processCursorMovementRelativeToSurface(this._stagedScreenPoint,this._stagedPointerType):this._snappingOperation.abort()}_processCursorMovementRelativeToSurface(t,e){const n=this._snappingOperation,i=this._screenToMap(t),s=this._requiresScenePoint?this.drawSurface?.screenToMap(t):null;if(i==null)return this._hideDefaultCursor=!0,this._processCursor(null),void n.abort();this._hideDefaultCursor=!1;const r=this.snappingManager;if(r==null)return this._processCursor(i),void n.abort();const a=this._getSnappingContext(e);this._updatingHandles.addPromise(j(n.snap({point:i,scenePoint:s},r,a)))}_applyConstraints(t){const{_constraint:e,constraints:n}=this;if(!t||!n||!e)return t;const{context:i}=n,s=k(t,i),r=s?e.closestTo(s):void 0;if(!r)return t;const a=$e(r,t,i),o=this.view.type==="2d"||i.elevationInfo.mode!=="absolute-height";return a!=null&&o&&this.constraintZ!=null&&this.hasZ&&(a.z=this.constraintZ),a}_screenToMap(t){return t?this._updateAndGetEffectiveDrawSurface()?.screenToMap(t):null}_screenToMapDragEventStep(){let t=null;return e=>{if(e.action==="start"&&(t=this._screenToMap(e.screenStart)),t==null)return null;const n=this._screenToMap(e.screenEnd);return n!=null?{...e,mapStart:t,mapEnd:n}:null}}_vertexWithinPointerDistance(t,e){const i=this._mapToScreen(this.coordinateHelper.vectorToDehydratedPoint(t));return i!=null&&Xe(i,e,25)}_getSnappingContext(t){const e=this._drawAtFixedElevation?this.elevationDrawSurface?.defaultZ:null;return new K({editGeometryOperations:this._editGeometryOperations,elevationInfo:this.elevationInfo,pointer:t,feature:this.graphic,visualizer:this.snappingVisualizer,selfSnappingZ:e!=null?{value:e,elevationInfo:this.elevationInfo}:null,drawConstraints:this.constraints})}};function Xe(t,e,n){const i=t.x-e.x,s=t.y-e.y;return i*i+s*s<=n}u([c()],d.prototype,"_hideDefaultCursor",void 0),u([c()],d.prototype,"_stagedPointerId",void 0),u([c()],d.prototype,"_isDragging",null),u([c()],d.prototype,"_snappingOperation",void 0),u([c()],d.prototype,"_snappingEnabled",null),u([c({constructOnly:!0})],d.prototype,"graphic",void 0),u([c()],d.prototype,"constraintsEnabled",void 0),u([c()],d.prototype,"constraints",void 0),u([c()],d.prototype,"_constraint",null),u([c()],d.prototype,"constraintZ",void 0),u([c()],d.prototype,"defaultZ",void 0),u([c()],d.prototype,"isDraped",void 0),u([c({constructOnly:!0})],d.prototype,"automaticLengthMeasurementUtils",void 0),u([c({value:It})],d.prototype,"drawingMode",null),u([c({constructOnly:!0})],d.prototype,"elevationDrawSurface",void 0),u([c({constructOnly:!0})],d.prototype,"elevationInfo",void 0),u([c({constructOnly:!0,type:Mt})],d.prototype,"labelOptions",void 0),u([c({constructOnly:!0})],d.prototype,"geometryType",void 0),u([c({constructOnly:!0})],d.prototype,"hasM",void 0),u([c({constructOnly:!0})],d.prototype,"hasZ",void 0),u([c()],d.prototype,"cursor",void 0),u([c()],d.prototype,"effectiveCursor",null),u([c()],d.prototype,"loading",void 0),u([c({constructOnly:!0})],d.prototype,"manipulators",void 0),u([c({constructOnly:!0})],d.prototype,"drawSurface",void 0),u([c({constructOnly:!0})],d.prototype,"segmentLabels",void 0),u([c({constructOnly:!0})],d.prototype,"snappingManager",void 0),u([c({constructOnly:!0})],d.prototype,"snappingVisualizer",void 0),u([c()],d.prototype,"snapToSceneEnabled",void 0),u([c({readOnly:!0})],d.prototype,"cursorVertex",null),u([c({readOnly:!0})],d.prototype,"visualizationCursorVertex",null),u([c()],d.prototype,"committableVertex",null),u([c()],d.prototype,"firstVertex",void 0),u([c()],d.prototype,"lastVertex",void 0),u([c()],d.prototype,"secondToLastVertex",void 0),u([c()],d.prototype,"updating",null),u([c({constructOnly:!0})],d.prototype,"view",void 0),d=u([z("esri.views.draw.DrawOperation")],d);class bn{constructor(e,n,i,s=null){this._elevationInfo=e,this.defaultZ=n,this._view=i,this._excludeGraphics=s}screenToMap(e){const{defaultZ:n,_view:i}=this,s=i.sceneIntersectionHelper.intersectElevationFromScreen(jt(e.x,e.y),this._elevationInfo,n??0,this._excludeGraphics);return n==null&&s!=null&&(s.z=void 0),s}mapToScreen(e){const n=nt(e.x,e.y,Pt(this._view,e,this._elevationInfo),e.spatialReference);return this._view.toScreen(n)}constrainZ(e){const{defaultZ:n}=this;return n!=null&&e.z!==n&&((e=H(e)).z=n),e}}class Pn{constructor(e,n,i=[]){this.view=e,this.elevationInfo=n,this.exclude=i}screenToMap(e){const n=this.view.toMap(e,{exclude:this.exclude,excludeLabels:!0});return n!=null&&(n.z=Z(n,this.view,this.elevationInfo)),n}mapToScreen(e){let n=e;return this.elevationInfo!=null&&(n=nt(e.x,e.y,Pt(this.view,e,this.elevationInfo),e.spatialReference)),this.view.toScreen(n)}constrainZ(e){return e}}class wn{constructor(e,n=!1,i=0){this.view=e,this.hasZ=n,this.defaultZ=i,this.mapToScreen=s=>e.toScreen(s),this.screenToMap=n?s=>{const r=e.toMap(s);return r.z=i,r}:s=>e.toMap(s)}constrainZ(e){const{defaultZ:n}=this;return this.hasZ&&e.z!==n&&((e=H(e)).z=n),e}}class zt{screenToMap(e){const{x:n,y:i}=e;return new Bt({x:n,y:i,spatialReference:zt.spatialReference})}mapToScreen(e){return Q(e.x,e.y)}constrainZ(e){return e}static{this.spatialReference=new vt}}export{d as A,V as D,mn as E,yn as M,_n as R,gn as S,Ge as U,D as a,pn as b,bn as c,ke as d,Ze as f,ze as g,wn as h,Pn as l,hn as m,W as p,xn as q,v as r,zt as u,fn as v,vn as z};
