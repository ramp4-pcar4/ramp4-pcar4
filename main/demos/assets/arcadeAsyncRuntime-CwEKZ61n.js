import{r as S,t as ne}from"./arcadeEnvironment-DMxuwDuN.js";import{e as q,R as g,v as W,q as Q,L as x,_ as y,I as U,o as re,p as v,P as p,y as Z,S as u,g as A,d as Se,a as xe,Q as K,t as B,H as te,B as oe,U as ae,s as Fe,b as $,r as Ie,n as X}from"./Dictionary-DIDyRWej.js";import{o as ke,i as ie,s as se,j as Oe,E as Me,P as Re,g as Ce,C as Ne,a as Ae,b as Be,y as Ee,d as P,f as le,c as je,p as Ge}from"./arcade-BBgWo9VK.js";import{n as a,i as ce}from"./enum-BshDcSFN.js";import{I as ue}from"./Feature-SbXO3u4G.js";import{T as Ke}from"./aiServices-GldRxNRU.js";import{registerFunctions as Le}from"./geomasync-BsUSWr_v.js";import{D as fe,eV as Ue,eW as k,eX as h,eY as J,eZ as E,e2 as N,i as _e}from"./main-CtmwM019.js";import"./TimeOnly-BYrd6q6s.js";import"./UnknownTimeZone-B7fquLC-.js";import"./ImmutableArray-BPVd6ESQ.js";import"./shared-B_51gLwt.js";import"./Field-Qk7kqJE_.js";import"./fieldType-CgDsR44Y.js";import"./number-C5dztEtP.js";import"./preload-helper-DMGCcr4D.js";import"./WhereClause-CX4_Dr18.js";import"./streamLayerUtils-DFlbJ4P1.js";import"./unitConversion-BsKt_ZxW.js";import"./uuid-Oe6SV2kF.js";import"./featureConversionUtils-CQ7EbBKb.js";import"./OptimizedFeature-69ue8f4g.js";import"./memoryEstimations-R8dTJqWI.js";import"./OptimizedGeometry-CYLi7ZPm.js";import"./OptimizedFeatureSet-BR8EEvDc.js";import"./FieldsIndex-BfaTaUfm.js";import"./timeZoneUtils-kvnFYCV8.js";import"./commonProperties-DHiB1uzW.js";import"./utils-PyBYdGi0.js";import"./portalUtils-CfDrFthw.js";import"./operatorsWorkerConnection-BigrmA6M.js";import"./workers-C6h9H2XY.js";import"./Queue-CI0vPdwz.js";import"./intl-BF_HwN3J.js";import"./messages-CIIwatVx.js";const z=()=>_e.getLogger("esri.arcade.arcadeAsyncRuntime"),M=Symbol("uninitialized");function L(n){if(n===M)throw new a(null,"InvalidIdentifier",null)}function pe(n){return L(n),n}function R(n,e){const r=S(e);if(n.localScope!==null){const i=n.localScope[r];if(i!==void 0)return{scope:n.localScope,id:r,var:i}}const t=n.globalScope[r];if(t!==void 0)return{scope:n.globalScope,id:r,var:t};throw new a(n,"InvalidIdentifier",e)}function we(n,e,r="InvalidIdentifier"){const t=S(e);if(n.localScope!==null){const s=n.localScope[t];if(s!==void 0)return L(s),s.value}const i=n.globalScope[t];if(i!==void 0)return L(i),i.value;throw new a(n,r,e)}const j=function(){};async function de(n,e){const r=[];for(let t=0;t<e.arguments.length;t++)r.push(await c(n,e.arguments[t]));return r}async function b(n,e,r){return e.preparsed===!0?r(n,null,e.arguments):r(n,e,await de(n,e))}j.prototype=Object.freeze(Object.create(null));class De extends Ie{constructor(e,r,t,i){super(),this.definition=e,this.context=r,this._params=t,this._locals=i}createFunction(e){return(...r)=>{const t={spatialReference:this.context.spatialReference,console:this.context.console,lrucache:this.context.lrucache,timeZone:this.context.timeZone??null,exports:this.context.exports,libraryResolver:this.context.libraryResolver,interceptor:this.context.interceptor,services:this.context.services,abortSignal:this.context.abortSignal,localScope:new j,depthCounter:{depth:e.depthCounter.depth+1},globalScope:this.context.globalScope,track:this.context.track};if(t.depthCounter.depth>64)throw new a(e,"MaximumCallDepth",null);return D(t,this.definition.body,this._params,this._locals,r,null)}}call(e,r){return V(e,r,(t,i,s)=>{const o={spatialReference:e.spatialReference,services:e.services,console:e.console,libraryResolver:e.libraryResolver,exports:e.exports,lrucache:e.lrucache,timeZone:e.timeZone??null,interceptor:e.interceptor,localScope:new j,abortSignal:e.abortSignal,globalScope:e.globalScope,depthCounter:{depth:e.depthCounter.depth+1},track:e.track};if(o.depthCounter.depth>64)throw new a(e,"MaximumCallDepth",r);return D(o,this.definition.body,this._params,this._locals,s,r)})}marshalledCall(e,r,t,i){return i(e,r,async(s,o,l)=>{const f={spatialReference:e.spatialReference,services:e.services,globalScope:t.globalScope,depthCounter:{depth:e.depthCounter.depth+1},libraryResolver:e.libraryResolver,exports:e.exports,console:e.console,abortSignal:e.abortSignal,lrucache:e.lrucache,timeZone:e.timeZone??null,interceptor:e.interceptor,localScope:new j,track:e.track};return l=l.map(w=>!x(w)||w instanceof $?w:X(w,e,i)),X(await D(f,this.definition.body,this._params,this._locals,l,r),t,i)})}}async function D(n,e,r,t,i,s){if(r.length!==i.length)throw new a(n,"WrongNumberOfParameters",s);if(n.localScope!=null){for(let l=0;l<r.length;l++)n.localScope[r[l]]={value:i[l]};for(const l of t)n.localScope[l]=M}const o=await m(n,e);if(o instanceof g)return o.value;if(o===y)throw new a(n,"UnexpectedToken",s);if(o===U)throw new a(n,"UnexpectedToken",s);return o instanceof W?o.value:o}class I extends Fe{constructor(e){super(),this.moduleGlobalContext=e}global(e){const r=S(e),t=this.moduleGlobalContext.globalScope[r];if(L(t),x(t.value)&&!(t.value instanceof $)){const i=new $;return i.fn=t.value,i.parameterEvaluator=b,i.context=this.moduleGlobalContext,this.moduleGlobalContext.globalScope[r]={value:i},i}return t.value}setGlobal(e,r){if(x(r))throw new a(null,"AssignModuleFunction",null);const t=S(e);if(this.moduleGlobalContext.globalScope[t]===void 0)throw new a(null,"ModuleExportNotFound",null);this.moduleGlobalContext.globalScope[t]={value:r}}hasGlobal(e){return this.moduleGlobalContext.exports.has(S(e))}static async load(e,r){const{globals:t,exports:i}=ie(r),s=new H;for(const f of t)f in s||(s[f]=M);const o=e.spatialReference??fe.WebMercator,l={lrucache:e.lrucache,interceptor:e.interceptor,services:e.services,console:e.console??ve,abortSignal:e.abortSignal??ne,timeZone:e.timeZone??null,spatialReference:o,track:null,depthCounter:{depth:1},libraryResolver:new se(e.libraryResolver._moduleSingletons,r.loadedModules),exports:i,localScope:null,globalScope:s};return await T(l,r),new I(l)}}async function V(n,e,r){return e.preparsed===!0?r(n,null,e.arguments):r(n,e,await de(n,e))}async function c(n,e){e.breakpoint&&await e.breakpoint();try{switch(e.type){case"UpdateExpression":return await Te(n,e);case"AssignmentExpression":return await Ye(n,e);case"TemplateLiteral":return await fn(n,e);case"Identifier":return Y(n,e);case"MemberExpression":return await on(n,e);case"Literal":return e.value;case"CallExpression":return await un(n,e);case"UnaryExpression":return await an(n,e);case"BinaryExpression":return await ln(n,e);case"LogicalExpression":return await cn(n,e);case"ArrayExpression":return await sn(n,e);case"ObjectExpression":return await Ze(n,e);default:throw new a(n,"Unrecognized",e)}}catch(r){throw ce(n,e,r)}}async function m(n,e){e.breakpoint&&await e.breakpoint();try{switch(e.type){case"ImportDeclaration":return await en(n,e);case"ExportNamedDeclaration":return await nn(n,e);case"VariableDeclaration":return await rn(n,e);case"BlockStatement":return await T(n,e);case"FunctionDeclaration":return await Je(n,e);case"ReturnStatement":return await Xe(n,e);case"IfStatement":return await Qe(n,e);case"ExpressionStatement":return await He(n,e);case"ForStatement":return await Pe(n,e);case"WhileStatement":return await $e(n,e);case"ForInStatement":return await We(n,e);case"ForOfStatement":return await Ve(n,e);case"BreakStatement":return y;case"EmptyStatement":return p;case"ContinueStatement":return U;default:throw new a(n,"Unrecognized",e)}}catch(r){throw ce(n,e,r)}}async function Ze(n,e){const r=[];for(let o=0;o<e.properties.length;o++){const l=e.properties[o],f=await c(n,l.value),w=l.key.type==="Identifier"?l.key.name:await c(n,l.key);r[o]={key:w,value:f}}const t=Object.create(null),i=new Map;for(let o=0;o<r.length;o++){const l=r[o];if(x(l.value))throw new a(n,"NoFunctionInDictionary",e);if(h(l.key)===!1)throw new a(n,"KeyMustBeString",e);let f=l.key.toString();const w=f.toLowerCase();i.has(w)?f=i.get(w):i.set(w,f),l.value===p?t[f]=null:t[f]=l.value}const s=new v(t);return s.immutable=!1,s}async function $e(n,e){let r=await c(n,e.test);if(r===!1)return p;if(r!==!0)throw new a(n,"BooleanConditionRequired",e);for(;r===!0;){const t=await m(n,e.body);if(t===y)break;if(t instanceof g)return t;if(r=await c(n,e.test),r!==!0&&r!==!1)throw new a(n,"BooleanConditionRequired",e)}return p}async function Pe(n,e){try{for(e.init!==null&&(e.init.type==="VariableDeclaration"?await m(n,e.init):await c(n,e.init));;){if(e.test!==null){const t=await c(n,e.test);if(n.abortSignal?.aborted===!0)throw new a(n,"Cancelled",e);if(t===!1)break;if(t!==!0)throw new a(n,"BooleanConditionRequired",e)}const r=await m(n,e.body);if(r===y)break;if(r instanceof g)return r;e.update!==null&&await c(n,e.update)}return p}catch(r){throw r}}async function G(n,e,r,t,i="i"){const s=r.length;for(let o=0;o<s;o++){if(i==="k"){if(o>=r.length)throw new a(n,"OutOfBounds",e);t.scope[t.id]={value:r[o]}}else t.scope[t.id]={value:o};const l=await m(n,e.body);if(l===y)break;if(l instanceof g)return l}return p}async function he(n,e,r,t,i="i"){const s=r.length();for(let o=0;o<s;o++){t.scope[t.id]=i==="k"?{value:r.get(o)}:{value:o};const l=await m(n,e.body);if(l===y)break;if(l instanceof g)return l}return p}async function me(n,e,r,t){const i=r.iterator(n.abortSignal);let s;for(;(s=await i.next())!=null;){const o=ue.createFromGraphicLikeObject(s.geometry,s.attributes,r,n.timeZone);o._underlyingGraphic=s,t.scope[t.id]={value:o};const l=await m(n,e.body);if(l===y)break;if(l instanceof g)return l}return p}async function ze(n,e,r,t){for(const i of r.keys()){const s=r.field(i);t.scope[t.id]={value:v.containerEntry(i,s)};const o=await m(n,e.body);if(o===y)break;if(o instanceof g)return o}return p}async function qe(n,e,r,t){for(const i of le(r)){const s=P(r,i,n,e,1);t.scope[t.id]={value:v.containerEntry(i,s)};const o=await m(n,e.body);if(o===y)break;if(o instanceof g)return o}return p}async function We(n,e){const r=await c(n,e.right);e.left.type==="VariableDeclaration"&&await m(n,e.left);const t=R(n,e.left.type==="VariableDeclaration"?e.left.declarations[0].id:e.left);return E(r)||h(r)?await G(n,e,r,t):B(r)?await he(n,e,r,t):r instanceof v||K(r)?await G(n,e,r.keys(),t,"k"):oe(r)?await me(n,e,r,t):ae(r)?await G(n,e,le(r),t,"k"):p}async function Ve(n,e){const r=await c(n,e.right);e.left.type==="VariableDeclaration"&&await m(n,e.left);const t=R(n,e.left.type==="VariableDeclaration"?e.left.declarations[0].id:e.left);return E(r)||h(r)?await G(n,e,r,t,"k"):B(r)?await he(n,e,r,t,"k"):r instanceof v||K(r)?await ze(n,e,r,t):oe(r)?await me(n,e,r,t):ae(r)?await qe(n,e,r,t):p}async function Te(n,e){const r=e.argument;if(r.type==="CallExpression")throw new a(n,"NeverReach",e);if(r.type==="MemberExpression"){const o=await c(n,r.object);let l,f;if(r.computed===!0)l=await c(n,r.property);else{if(r.property.type!=="Identifier")throw new a(n,"Unrecognized",e);l=r.property.name}if(E(o)){if(!N(l))throw new a(n,"ArrayAccessMustBeNumber",e);if(l<0&&(l=o.length+l),l<0||l>=o.length)throw new a(n,"OutOfBounds",e);f=u(o[l]),o[l]=e.operator==="++"?f+1:f-1}else if(o instanceof v){if(h(l)===!1)throw new a(n,"KeyAccessorMustBeString",e);if(o.hasField(l)!==!0)throw new a(n,"FieldNotFound",e,{key:l});f=u(o.field(l)),o.setField(l,e.operator==="++"?f+1:f-1)}else if(o instanceof I){if(h(l)===!1)throw new a(n,"ModuleAccessorMustBeString",e);if(o.hasGlobal(l)!==!0)throw new a(n,"ModuleExportNotFound",e);f=u(o.global(l)),o.setGlobal(l,e.operator==="++"?f+1:f-1)}else{if(!te(o))throw B(o)?new a(n,"Immutable",e):new a(n,"InvalidParameter",e);if(h(l)===!1)throw new a(n,"KeyAccessorMustBeString",e);if(o.hasField(l)!==!0)throw new a(n,"FieldNotFound",e,{key:l});f=u(o.field(l)),o.setField(l,e.operator==="++"?f+1:f-1)}return e.prefix===!1?f:e.operator==="++"?f+1:f-1}const t=R(n,r),i=u(pe(t.var).value),s=e.operator==="++"?i+1:i-1;return t.scope[t.id]={value:s},e.prefix===!1?i:e.operator==="++"?i+1:i-1}function F(n,e,r,t,i){switch(e){case"=":return n===p?null:n;case"/=":return u(r)/u(n);case"*=":return u(r)*u(n);case"-=":return u(r)-u(n);case"+=":return h(r)||h(n)?A(r)+A(n):u(r)+u(n);case"%=":return u(r)%u(n);default:throw new a(i,"UnsupportedOperator",t)}}async function Ye(n,e){const r=e.left;if(r.type==="MemberExpression"){const s=await c(n,r.object);let o;if(r.computed===!0)o=await c(n,r.property);else{if(r.property.type!=="Identifier")throw new a(n,"InvalidIdentifier",e);o=r.property.name}const l=await c(n,e.right);if(E(s)){if(!N(o))throw new a(n,"ArrayAccessMustBeNumber",e);if(o<0&&(o=s.length+o),o<0||o>s.length)throw new a(n,"OutOfBounds",e);if(o===s.length){if(e.operator!=="=")throw new a(n,"OutOfBounds",e);s[o]=F(l,e.operator,s[o],e,n)}else s[o]=F(l,e.operator,s[o],e,n)}else if(s instanceof v){if(h(o)===!1)throw new a(n,"KeyAccessorMustBeString",e);if(s.hasField(o)===!0)s.setField(o,F(l,e.operator,s.field(o),e,n));else{if(e.operator!=="=")throw new a(n,"FieldNotFound",e,{key:o});s.setField(o,F(l,e.operator,null,e,n))}}else if(s instanceof I){if(h(o)===!1)throw new a(n,"KeyAccessorMustBeString",e);if(s.hasGlobal(o)!==!0)throw new a(n,"ModuleExportNotFound",e);s.setGlobal(o,F(l,e.operator,s.global(o),e,n))}else{if(!te(s))throw B(s)?new a(n,"Immutable",e):new a(n,"InvalidParameter",e);if(h(o)===!1)throw new a(n,"KeyAccessorMustBeString",e);if(s.hasField(o)===!0)s.setField(o,F(l,e.operator,s.field(o),e,n));else{if(e.operator!=="=")throw new a(n,"FieldNotFound",e,{key:o});s.setField(o,F(l,e.operator,null,e,n))}}return p}const t=R(n,r),i=await c(n,e.right);return t.scope[t.id]={value:F(i,e.operator,e.operator!=="="?pe(t.var).value:null,e,n)},p}async function He(n,e){const r=await c(n,e.expression);return r===p?p:new W(r)}async function Qe(n,e){const r=await c(n,e.test);if(r===!0)return m(n,e.consequent);if(r===!1)return e.alternate!==null?m(n,e.alternate):p;throw new a(n,"BooleanConditionRequired",e)}async function T(n,e){return ge(n,e,0)}async function ge(n,e,r){if(r>=e.body.length)return p;const t=await m(n,e.body[r]);return t instanceof g||t===y||t===U||r===e.body.length-1?t:ge(n,e,r+1)}async function Xe(n,e){if(e.argument===null)return new g(p);const r=await c(n,e.argument);return new g(r)}async function Je(n,e){if(n.localScope!=null)throw z().error("Function declarations are only valid in global scope."),new a(n,"NeverReach",e);const r=S(e.id);if(!(r in n.globalScope))throw z().error(`Function "${r}" not declared.`),new a(n,"NeverReach",e);const t=je(e),i=e.params.map(o=>S(o)),s=Array.from(t).filter(o=>!i.includes(o));return n.globalScope[r]={value:new De(e,n,i,s)},p}async function en(n,e){const r=R(n,e.specifiers[0].local),t=n.libraryResolver;if(t==null)throw z().error("Internal error: module loader not initialized"),new a(n,"NeverReach",e);const i=t.loadLibrary(r.id);let s;return t._moduleSingletons?.has(i.uri)?s=t._moduleSingletons.get(i.uri):(s=await I.load(n,i.syntax),t._moduleSingletons?.set(i.uri,s)),r.scope[r.id]={value:s},p}async function nn(n,e){return await m(n,e.declaration),p}async function rn(n,e){for(const r of e.declarations)await tn(n,r);return p}async function tn(n,e){let r=null;r=e.init===null?null:await c(n,e.init),r===p&&(r=null);const t=R(n,e.id);t.scope[t.id]={value:r}}async function on(n,e){const r=await c(n,e.object);if(r===null)throw new a(n,"MemberOfNull",e);if(e.computed===!1){if(e.property.type==="Identifier"){if(r instanceof v||K(r))return r.field(e.property.name);if(r instanceof J)return P(r,e.property.name,n,e);if(r instanceof I){if(!r.hasGlobal(e.property.name))throw new a(n,"InvalidIdentifier",e);return r.global(e.property.name)}throw new a(n,"InvalidMemberAccessKey",e)}throw new a(n,"InvalidMemberAccessKey",e)}let t=await c(n,e.property);if(r instanceof v||K(r)){if(h(t))return r.field(t);throw new a(n,"InvalidMemberAccessKey",e)}if(r instanceof I){if(h(t))return r.global(t);throw new a(n,"InvalidMemberAccessKey",e)}if(r instanceof J){if(h(t))return P(r,t,n,e);throw new a(n,"InvalidMemberAccessKey",e)}if(E(r)){if(N(t)&&isFinite(t)&&Math.floor(t)===t){if(t<0&&(t=r.length+t),t>=r.length||t<0)throw new a(n,"OutOfBounds",e);return r[t]}throw new a(n,"InvalidMemberAccessKey",e)}if(B(r)){if(N(t)&&isFinite(t)&&Math.floor(t)===t){if(t<0&&(t=r.length()+t),t>=r.length()||t<0)throw new a(n,"OutOfBounds",e);return r.get(t)}throw new a(n,"InvalidMemberAccessKey",e)}if(h(r)){if(N(t)&&isFinite(t)&&Math.floor(t)===t){if(t<0&&(t=r.length+t),t>=r.length||t<0)throw new a(n,"OutOfBounds",e);return r[t]}throw new a(n,"InvalidMemberAccessKey",e)}throw new a(n,"InvalidMemberAccessKey",e)}async function an(n,e){const r=await c(n,e.argument);if(k(r)){if(e.operator==="!")return!r;if(e.operator==="-")return-1*u(r);if(e.operator==="+")return 1*u(r);if(e.operator==="~")return~u(r);throw new a(n,"UnsupportUnaryOperator",e)}if(e.operator==="-")return-1*u(r);if(e.operator==="+")return 1*u(r);if(e.operator==="~")return~u(r);throw new a(n,"UnsupportUnaryOperator",e)}async function sn(n,e){const r=[];for(let t=0;t<e.elements.length;t++)r.push(await c(n,e.elements[t]));for(let t=0;t<r.length;t++){if(x(r[t]))throw new a(n,"NoFunctionInArray",e);r[t]===p&&(r[t]=null)}return r}async function ln(n,e){const r=await c(n,e.left),t=await c(n,e.right);switch(e.operator){case"|":case"<<":case">>":case">>>":case"^":case"&":return xe(u(r),u(t),e.operator);case"==":return Z(r,t);case"!=":return!Z(r,t);case"<":case">":case"<=":case">=":return Se(r,t,e.operator);case"+":return h(r)||h(t)?A(r)+A(t):u(r)+u(t);case"-":return u(r)-u(t);case"*":return u(r)*u(t);case"/":return u(r)/u(t);case"%":return u(r)%u(t);default:throw new a(n,"UnsupportedOperator",e)}}async function cn(n,e){const r=await c(n,e.left);if(!k(r))throw new a(n,"LogicalExpressionOnlyBoolean",e);switch(e.operator){case"||":{if(r===!0)return r;const t=await c(n,e.right);if(k(t))return t;throw new a(n,"LogicExpressionOrAnd",e)}case"&&":{if(r===!1)return r;const t=await c(n,e.right);if(k(t))return t;throw new a(n,"LogicExpressionOrAnd",e)}default:throw new a(n,"LogicExpressionOrAnd",e)}}function Y(n,e){return we(n,e)}async function un(n,e){if(e.callee.type==="MemberExpression"){const t=await c(n,e.callee.object);if(!(t instanceof I))throw new a(n,"FunctionNotFound",e);const i=e.callee.computed===!1?e.callee.property.name:await c(n,e.callee.property);if(!t.hasGlobal(i))throw new a(n,"FunctionNotFound",e);const s=t.global(i);if(!x(s))throw new a(n,"CallNonFunction",e);return s.call(n,e)}if(e.callee.type!=="Identifier")throw new a(n,"FunctionNotFound",e);const r=we(n,e.callee,"FunctionNotFound");if(x(r))return r.call(n,e);throw new a(n,"CallNonFunction",e)}async function fn(n,e){let r="",t=0;for(const i of e.quasis)if(r+=i.value?i.value.cooked:"",i.tail===!1){if(e.expressions[t]){const s=await c(n,e.expressions[t]);if(x(s))throw new a(n,"NoFunctionInTemplateLiteral",e);r+=A(s)}t++}return r}async function pn(n,e){re(e.arguments===null?[]:e.arguments,3,3,n,e);const r=await c(n,e.arguments[0]);if(k(r)===!1)throw new a(n,"BooleanConditionRequired",e);return c(n,r?e.arguments[1]:e.arguments[2])}async function wn(n,e){re(e.arguments===null?[]:e.arguments,2,3,n,e);const r=await c(n,e.arguments[0]);if(e.arguments.length===3){const t=await c(n,e.arguments[1]),i=Ee(r,t);return i!=null&&i!==""?i:c(n,e.arguments[2])}return r==null||r===""?c(n,e.arguments[1]):r}async function dn(n,e){if(e.arguments.length<2)throw new a(n,"WrongNumberOfParameters",e);if(e.arguments.length===2)return c(n,e.arguments[1]);if((e.arguments.length-1)%2==0)throw new a(n,"WrongNumberOfParameters",e);return ye(n,e,1,await c(n,e.arguments[0]))}async function ye(n,e,r,t){const i=await c(n,e.arguments[r]);if(Z(i,t))return c(n,e.arguments[r+1]);const s=e.arguments.length-r;return s===1?c(n,e.arguments[r]):s===2?null:s===3?c(n,e.arguments[r+2]):ye(n,e,r+2,t)}async function hn(n,e){if(e.arguments.length<3)throw new a(n,"WrongNumberOfParameters",e);if(e.arguments.length%2==0)throw new a(n,"WrongNumberOfParameters",e);const r=await c(n,e.arguments[0]);if(k(r)===!1)throw new a(n,"BooleanConditionRequired",e.arguments[0]);return be(n,e,0,r)}async function be(n,e,r,t){if(t===!0)return c(n,e.arguments[r+1]);if(e.arguments.length-r===3)return c(n,e.arguments[r+2]);const i=await c(n,e.arguments[r+2]);if(k(i)===!1)throw new a(n,"ModuleExportNotFound",e.arguments[r+2]);return be(n,e,r+2,i)}function mn(){const n=Object.create(null);Oe(n,b),Me(n,b),Re(n,b,Y),Ce(n,b),Ne(n,b),Ae(n,b),Be(n,b),Le({functions:n,compiled:!1,signatures:null,evaluateIdentifier:null,mode:"async",standardFunction:b,standardFunctionAsync:V}),n.iif=pn,n.defaultvalue=wn,n.decode=dn,n.when=hn;const e=function(){this.textformatting={value:v.textFormatting()}};e.prototype=Object.create(null),e.prototype.infinity=Object.freeze({value:Number.POSITIVE_INFINITY}),e.prototype.pi=Object.freeze({value:Math.PI});for(const[r,t]of Object.entries(n))e.prototype[r]=Object.freeze({value:new q(t)});return e}const H=mn();function ee(n){const e={mode:"async",compiled:!1,functions:Object.create(null),signatures:[],standardFunction:b,standardFunctionAsync:V,evaluateIdentifier:Y};for(let r=0;r<n.length;r++)n[r].registerFunctions(e);for(const[r,t]of Object.entries(e.functions))H.prototype[r]=Object.freeze({value:new q(t)});for(let r=0;r<e.signatures.length;r++)ke(e.signatures[r],"async")}function ve(n){console.log(n)}function gn(n,e){const r=new Set(Object.keys(e?.vars||{}).map(o=>S(o))),t=new Set(Object.keys(e?.customfunctions||{}).map(o=>S(o))),{globals:i,exports:s}=ie(n);return async o=>{const l=o.spatialReference??fe.WebMercator;let f=null;n.usesModules&&(f=new se(new Map,n.loadedModules));const w=new H;for(const d of t)o.customfunctions!=null&&d in o.customfunctions?w[d]={value:new q(o.customfunctions[d])}:w[d]=M;for(const d of r){if(o.vars==null||!(d in o.vars)){d in w||(w[d]=M);continue}const _=o.vars[d]??null;Ue(_)?w[d]={value:ue.createFromGraphic(_,o.timeZone??null)}:w[d]={value:_}}for(const d of i)d in w||(w[d]=M);const C={lrucache:o.lrucache,interceptor:o.interceptor,services:o.services,console:o.console??ve,abortSignal:o.abortSignal??ne,timeZone:o.timeZone??null,spatialReference:l,track:o.track,depthCounter:{depth:1},libraryResolver:f,exports:s,localScope:null,globalScope:w},O=await T(C,n);if(O instanceof g||O instanceof W){const d=O.value;if(Q(d))return null;if(x(d))throw new a(C,"IllegalResult",null);return d}if(Q(O))return null;throw O===y?new a(C,"IllegalResult",null):O===U?new a(C,"IllegalResult",null):new a(C,"NeverReach",null)}}function Jn(n,e){return gn(n,e)(e)}ee([Ge]),ee([Ke]);export{Jn as executeScript,ee as extend,gn as prepareScript};
