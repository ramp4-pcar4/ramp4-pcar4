import{aK as D,i1 as U,i as z}from"./main-CtmwM019.js";import{o as p}from"./defaultCIMValues-XI-Li77m.js";import{a as R}from"./definitions-Bxxl7NsE.js";const L=15.5,S=4,P=64,X=1024,Y={outlineWidth:.75,referenceWidth:.75,cap:p.CIMSolidStroke.capstyle,join:p.CIMSolidStroke.joinstyle,miterLimit:p.CIMSolidStroke.miterlimit};function $(o,s,a=0){const r=D(o,0,G);for(let n=0;n<4;n++)s[a+n]=Math.floor(256*W(r*q[n]))}function b(o,s=0){let a=0;for(let r=0;r<4;r++)a+=o[s+r]*E[r];return a}const q=[1,256,65536,16777216],E=[1/256,1/65536,1/16777216,1/4294967296],G=b(new Uint8ClampedArray([255,255,255,255]));b(new Uint8ClampedArray([255,255,255,0]));function W(o){return o-Math.floor(o)}const I=()=>z.getLogger("esri.symbols.cim.rasterizingUtils"),j=32,B=o=>o==="vertical"||o==="horizontal"||o==="cross"||o==="esriSFSCross"||o==="esriSFSVertical"||o==="esriSFSHorizontal";function Z(o,s,a){const r=s.style,n=U(Math.ceil(a)),t=B(r)?8*n:16*n,e=2*n;o.width=t,o.height=t;const i=o.getContext("2d");i.strokeStyle="#ffffff",i.lineWidth=n,i.beginPath(),r!=="vertical"&&r!=="cross"&&r!=="esriSFSCross"&&r!=="esriSFSVertical"||(i.moveTo(t/2,-e),i.lineTo(t/2,t+e)),r!=="horizontal"&&r!=="cross"&&r!=="esriSFSCross"&&r!=="esriSFSHorizontal"||(i.moveTo(-e,t/2),i.lineTo(t+e,t/2)),r!=="backward-diagonal"&&r!=="diagonal-cross"&&r!=="esriSFSDiagonalCross"&&r!=="esriSFSBackwardDiagonal"||(i.moveTo(-e,-e),i.lineTo(t+e,t+e),i.moveTo(t-e,-e),i.lineTo(t+e,e),i.moveTo(-e,t-e),i.lineTo(e,t+e)),r!=="forward-diagonal"&&r!=="diagonal-cross"&&r!=="esriSFSForwardDiagonal"&&r!=="esriSFSDiagonalCross"||(i.moveTo(t+e,-e),i.lineTo(-e,t+e),i.moveTo(e,-e),i.lineTo(-e,e),i.moveTo(t+e,t-e),i.lineTo(t-e,t+e)),i.stroke();const h=i.getImageData(0,0,o.width,o.height),l=new Uint8Array(h.data);let f;for(let c=0;c<l.length;c+=4)f=l[c+3]/255,l[c]=l[c]*f,l[c+1]=l[c+1]*f,l[c+2]=l[c+2]*f;return[l,o.width,o.height,n]}function _(o){o.length%2==1&&(o=[...o,...o]);const s=o.reduce((c,m)=>c+m,0),a=Math.round(s*S),r=1,n=new Float32Array(a*r);let t=0,e=0,i=.5,h=!0;for(const c of o){for(t=e,e+=c*S;i<=e;){const m=i-.5,u=Math.min(Math.abs(i-t),Math.abs(i-e));n[m]=h?-u:u,i++}h=!h}const l=n.length,f=new Uint8Array(4*l);for(let c=0;c<l;++c){const m=n[c]/S;$(m/P*.5+.5,f,4*c)}return[f,a,r]}function oo(o,s){o==null&&(o=[]);const a=s==="Butt",r=s==="Square",n=!a&&!r;o.length%2==1&&(o=[...o,...o]);const t=L,e=2*t;let i=0;for(const d of o)i+=d;const h=Math.round(i*t),l=new Float32Array(h*e),f=.5*t;let c=0,m=0,u=.5,y=!0;for(const d of o){for(c=m,m+=d*t;u<=m;){let C=.5;for(;C<e;){const A=(C-.5)*h+u-.5,g=n?(C-t)*(C-t):Math.abs(C-t);l[A]=y?a?Math.max(Math.max(c+f-u,g),Math.max(u-m+f,g)):g:n?Math.min((u-c)*(u-c)+g,(u-m)*(u-m)+g):r?Math.min(Math.max(u-c,g),Math.max(m-u,g)):Math.min(Math.max(u-c+f,g),Math.max(m+f-u,g)),C++}u++}y=!y}const T=l.length,v=new Uint8Array(4*T);for(let d=0;d<T;++d){const C=(n?Math.sqrt(l[d]):l[d])/t;$(C,v,4*d)}return[v,h,e]}function to(o,s){const{colorRamp:a,gradientType:r}=s,n=a.type==="CIMFixedColorRamp",t=s.interval||p.CIMGradientFill.interval;let e=w(a);return n&&(e=N(e,t)),r==="Discrete"||n?V(o,e,t):H(o,e)}let x;function eo(o,s){const{colorRamp:a,gradientType:r}=s,n=w(a),t=a.type==="CIMFixedColorRamp";if(r==="Continuous"&&!t)return M(o,n);const e=s.interval??p.CIMGradientFill.interval;if(t)return M(o,N(n,e));const i=[];x??=document.createElement("canvas"),F(x,n,e,1,0);const h=x.getContext("2d").getImageData(0,0,e,1).data;for(let l=0,f=0;l<e;l++,f=4*l){const c=[h[f+0],h[f+1],h[f+2],h[f+3]];i.push({offset:l/e,color:c}),i.push({offset:(l+1)/e,color:c})}return M(o,i)}function w(o){const s=[];switch(o.type){case"CIMPolarContinuousColorRamp":case"CIMLinearContinuousColorRamp":{o.type==="CIMPolarContinuousColorRamp"&&I().warnOnce("CIMPolarContinuousColorRamp is currently unsupported. Falling back to CIMLinearContinuousColorRamp.");const a=o;s.push({offset:0,color:[a.fromColor[0],a.fromColor[1],a.fromColor[2],a.fromColor[3]/255]}),s.push({offset:1,color:[a.toColor[0],a.toColor[1],a.toColor[2],a.toColor[3]/255]});break}case"CIMFixedColorRamp":{const a=o,r=1/(a.colors.length-1);let n=0;for(const t of a.colors)s.push({offset:n,color:[t[0],t[1],t[2],t[3]/255]}),n+=r;break}case"CIMMultipartColorRamp":{const a=o,r=a.weights.reduce((t,e)=>t+e,0);let n=0;for(let t=0;t<a.colorRamps.length;t++){const e=a.colorRamps[t],i=a.weights[t],h=w(e);for(const l of h)s.push({offset:(n+l.offset*i)/r,color:l.color});n+=i}break}default:I().error(`Color ramp "${o.type}" currently unsupported.`)}return s}function N(o,s){const a=[],r=(o.length-1)/(s-1);for(let n=0;n<s;n++){const t=o[Math.round(n*r)].color;a.push({offset:n/s,color:t}),a.push({offset:(n+1)/s,color:t})}return a}function H(o,s){return F(o,s,j,1,R),k(o)}function V(o,s,a){return F(o,s,a,1,R),k(o)}function M(o,s,a=0){for(const{offset:r,color:n}of s)o.addColorStop(Math.min(Math.max(r,a),1-a),`rgba(${n[0]}, ${n[1]}, ${n[2]}, ${n[3]})`)}function F(o,s,a,r,n){const t=a+2*n;o.width=t,o.height=r;const e=(n+1)/t,i=o.getContext("2d",{willReadFrequently:!0});if(s.length>0){const h=i.createLinearGradient(0,0,t,r);M(h,s,e),i.fillStyle=h}else i.fillStyle="rgba(128, 128, 128, 1)";i.fillRect(0,0,t,r)}function k(o){const{width:s,height:a}=o,r=o.getContext("2d").getImageData(0,0,s,a),n=new Uint8Array(r.data);for(let t=0;t<n.length;t+=4){const e=n[t+3]/255;n[t]*=e,n[t+1]*=e,n[t+2]*=e}return[n,s,a]}function K(o){const s=o[0]?.[0]?.[0]??0,a=o[0]?.[0]?.[1]??0,r={ymin:a,xmin:s,ymax:a,xmax:s,width:0,height:0};for(let n=0;n<o.length;n++){const t=o[n];for(let e=0;e<t.length;e++){const i=t[e][0],h=t[e][1];i<r.xmin&&(r.xmin=i),i>r.xmax&&(r.xmax=i),h<r.ymin&&(r.ymin=h),h>r.ymax&&(r.ymax=h)}}return r.width=Math.abs(r.xmax-r.xmin),r.height=Math.abs(r.ymax-r.ymin),r}function ro(o,s){const a=K(o),r=a.width===0?1:a.width,n=a.height===0?1:a.height,t=[];for(let e=0;e<o.length;e++){const i=o[e],h=[];for(let l=0;l<i.length;l++){let f=Math.round(i[l][0]-a.xmin),c=Math.round(i[l][1]-a.ymin);if(f=s.xmin+f*s.width/r,c=s.ymin+c*s.height/n,isNaN(f)||isNaN(c))throw new Error("Scaled shape has NaN values");h.push([f,c])}t.push(h)}return t}function no(o,s,a){const r=[];for(let n=0;n<o.length;n++){const t=o[n],e=[];for(let i=0;i<t.length;i++){const h=t[i][0]+s,l=t[i][1]+a;if(isNaN(h)||isNaN(l))throw new Error("Scaled shape has NaN values");e.push([h,l])}r.push(e)}return r}export{no as R,ro as T,P as a,Z as f,to as g,S as i,Y as l,_ as m,$ as o,eo as p,X as r,oo as u};
