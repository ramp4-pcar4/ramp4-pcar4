const a={convertToGEGeometry:r,exportPoint:x,exportPolygon:u,exportPolyline:v,exportMultipoint:p,exportExtent:Z};function r(s,t){return t==null?null:s.convertJSONToGeometry(t)}class c{constructor(t,n,o){this.x=t,this.y=n,this.spatialReference=o,this.z=void 0,this.m=void 0}}function x(s,t,n){const o=new c(s.getPointX(t),s.getPointY(t),n),i=s.hasZ(t),e=s.hasM(t);return i&&(o.z=s.getPointZ(t)),e&&(o.m=s.getPointM(t)),o}class m{constructor(t,n,o,i){this.rings=t,this.spatialReference=n,this.hasZ=void 0,this.hasM=void 0,o&&(this.hasZ=o),i&&(this.hasM=i)}}function u(s,t,n){return new m(s.exportPaths(t),n,s.hasZ(t),s.hasM(t))}class l{constructor(t,n,o,i){this.paths=t,this.spatialReference=n,this.hasZ=void 0,this.hasM=void 0,o&&(this.hasZ=o),i&&(this.hasM=i)}}function v(s,t,n){return new l(s.exportPaths(t),n,s.hasZ(t),s.hasM(t))}class M{constructor(t,n,o,i){this.points=t,this.spatialReference=n,this.hasZ=void 0,this.hasM=void 0,o&&(this.hasZ=o),i&&(this.hasM=i)}}function p(s,t,n){return new M(s.exportPoints(t),n,s.hasZ(t),s.hasM(t))}class f{constructor(t,n,o,i,e){this.xmin=t,this.ymin=n,this.xmax=o,this.ymax=i,this.spatialReference=e,this.zmin=void 0,this.zmax=void 0,this.mmin=void 0,this.mmax=void 0}}function Z(s,t,n){const o=s.hasZ(t),i=s.hasM(t),e=new f(s.getXMin(t),s.getYMin(t),s.getXMax(t),s.getYMax(t),n);if(o){const h=s.getZExtent(t);e.zmin=h.vmin,e.zmax=h.vmax}if(i){const h=s.getMExtent(t);e.mmin=h.vmin,e.mmax=h.vmax}return e}export{a as t};
