import{c3 as ke,c4 as We,db as V,aH as Se,h2 as Fe,z as b,d4 as Z,ap as J,jv as Ce,dh as Ae,al as Y}from"./main-6gYsRPh_.js";import{s as k,n as B}from"./memoryEstimations-AZeom_OA.js";import{e as x}from"./OptimizedGeometry-JpgWJFHl.js";import{r as Oe}from"./parquet-Esx5XyIu.js";import{a as je,O as K,u as Ge,r as ze}from"./FeatureStoreQueryAdapter-4_8QbITA.js";import{e as Ee,i as De}from"./arcadeUtils-BkvNBhzm.js";import"./vec2f64-CkowXrDb.js";import{b as Xe,T as Pe,g as W,X as Q,R as Ue,l as Ye}from"./featureConversionUtils-CNzEiqZf.js";import{a as C}from"./queryUtils-BrfBK8br.js";import{o as ee}from"./definitions-DVO21zOC.js";import{u as L,i as te,a as se}from"./quantizationUtils-CLDFoR5p.js";let re=class{constructor(n){this._statistics=n}get statistics(){return this._statistics}};const ie=Math.PI/180;let A=class R{static create(e){return new R(e.map(t=>Be(t)))}constructor(e){this._statistics=e}static get estimatedMemory(){return k+4*k}values(){return this._statistics.values()}insert(e,t){for(const s of this._statistics)s.insert(e,t)}merge(e){for(let t=0;t<this._statistics.length;t++){const s=this._statistics[t],r=e._statistics[t];if(s.field.name!==r.field.name)throw new Error("InternalError: Tried to merge incompatible statistics");s.merge(r)}}clone(){return new R(this._statistics.map(e=>e.clone()))}};function Be(n){switch(n.statisticType){case"min":return new $(n);case"max":return new Le(n);case"avg":return new qe(n);case"avg_angle":return new Re(n);case"sum":case"count":return new Ne(n);case"mode":return new $e(n)}}let w=class{constructor(n){this.field=n}insert(n,e){if(!this.field.computed)return;const t=this.field.computed.read(n,e);je(t)||this._insertValue(t)}};class $ extends w{constructor(){super(...arguments),this.type="min",this.value=Number.MAX_VALUE}_insertValue(e){this.value=Math.min(this.value,e)}merge(e){this.value=Math.min(this.value,e.value)}clone(){const e=new $(this.field);return e.value=this.value,e}}let Le=class ce extends w{constructor(){super(...arguments),this.type="max",this.value=Number.MIN_VALUE}_insertValue(e){this.value=Math.max(this.value,e)}merge(e){this.value=Math.max(this.value,e.value)}clone(){const e=new ce(this.field);return e.value=this.value,e}},Ne=class _e extends w{constructor(){super(...arguments),this.type="sum",this.value=0}_insertValue(e){this.value+=e}merge(e){this.value+=e.value}clone(){const e=new _e(this.field);return e.value=this.value,e}},qe=class fe extends w{constructor(){super(...arguments),this.type="avg",this._total=0,this._count=0}get value(){return this._total/this._count}_insertValue(e){this._total+=e,this._count+=1}merge(e){this._total+=e._total,this._count+=e._count}clone(){const e=new fe(this.field);return e._total=this._total,e._count=this._count,e}},Re=class ge extends w{constructor(){super(...arguments),this.type="avg_angle",this._x=0,this._y=0,this._count=0}get value(){const e=this._x/this._count,t=this._y/this._count,s=180/Math.PI;return Math.atan2(t,e)*s}_insertValue(e){this._x=this._x+Math.cos(e*ie),this._y=this._y+Math.sin(e*ie),this._count+=1}merge(e){this._x+=e._x,this._y+=e._y,this._count+=e._count}clone(){const e=new ge(this.field);return e._x=this._x,e._y=this._y,e._count=this._count,e}},$e=class pe extends w{constructor(){super(...arguments),this._frequencies=new Map}get value(){let e,t=0;for(const[s,r]of this._frequencies.entries())r>t&&(t=r,e=s);return e}_insertValue(e){const t=this._frequencies.get(e);t!=null?this._frequencies.set(e,t+1):this._frequencies.set(e,1)}merge(e){for(const[t,s]of e._frequencies.entries()){const r=this._frequencies.get(t);r!=null?this._frequencies.set(t,r+s):this._frequencies.set(t,s)}}clone(){const e=new pe(this.field);return e._frequencies=new Map(this._frequencies),e}};class v extends re{static createId(e,t){return`${e}.${t}`}static create(e,t,s,r){return new v(e,t,A.create(s),r)}constructor(e,t,s,r){super(s),this.gridX=e,this.gridY=t,this._worldUnitsPerCell=r,this._count=0,this._xWorldTotal=0,this._yWorldTotal=0,this._objectIds=new Set}get id(){return v.createId(this.gridX,this.gridY)}get containedObjectIds(){return this._objectIds}get count(){return this._count}get firstObjectId(){return this._objectIds.values().next().value}get centroidXWorld(){return this._xWorldTotal/this._count}get centroidYWorld(){return this._yWorldTotal/this._count}get usedMemory(){return 48}clone(){const e=new v(this.gridX,this.gridY,this._statistics.clone(),this._worldUnitsPerCell);return e._count=this._count,e._xWorldTotal=this._xWorldTotal,e._yWorldTotal=this._yWorldTotal,e._firstFeatureAttributes=this._firstFeatureAttributes,e._objectIds=new Set(this._objectIds),e}insert(e,t,s,r){this._count===0?this._firstFeatureAttributes=e.readAttributes():this._firstFeatureAttributes=null,this._count+=1,this._xWorldTotal+=s,this._yWorldTotal+=r,this._statistics.insert(e,t),this._objectIds.add(e.getObjectId())}merge(e){if(e._count!==0){this._count+=e._count,this._firstFeatureAttributes=e._firstFeatureAttributes,this._xWorldTotal+=e._xWorldTotal,this._yWorldTotal+=e._yWorldTotal,this._statistics.merge(e._statistics);for(const t of e._objectIds.values())this._objectIds.add(t)}}getCentroidX(e){return e==null?this.centroidXWorld:Xe(e,this.centroidXWorld)}getCentroidY(e){return e==null?this.centroidYWorld:Pe(e,this.centroidYWorld)}getGeometry(e,t){const s=this.gridX*this._worldUnitsPerCell,r=this.gridY*this._worldUnitsPerCell,i=new x([4],[s,r,s+this._worldUnitsPerCell,r,s+this._worldUnitsPerCell,r+this._worldUnitsPerCell,s,r+this._worldUnitsPerCell]);if(t!=null){const o=new x;return W(o,i,!1,!1,"esriGeometryPolygon",t)}return i}getCentroid(e){const t=new x([],[this.centroidXWorld,this.centroidYWorld]);if(e!=null){const s=new x;return W(s,t,!1,!1,"esriGeometryPoint",e)}return t}getGeometricCentroid(e,t){const s=this.gridX*this._worldUnitsPerCell+.5*this._worldUnitsPerCell,r=this.gridY*this._worldUnitsPerCell+.5*this._worldUnitsPerCell,i=new x([],[s,r]);if(t!=null){const o=new x;return W(o,i,!1,!1,"esriGeometryPoint",t)}return i}getAttributes(){const e={aggregateId:this.id};for(const t of this._statistics.values())e[t.field.name]=t.value;return this._firstFeatureAttributes!=null?{...e,...this._firstFeatureAttributes}:e}}let ne=class{constructor(n){this._options=n}insert(n,e){const t=n.getCursor(),{arcadeContextInfo:s,scale:r}=this._options,i=Ee(r,s);for(;t.next();)this._insertFeature(t,i,this._options.sqlOptions,e)}_insertFeature(n,e,t,s){const{featureFilter:r}=this._options;if(r!==null&&!r.check(n,t))return;let i=0,o=0;if(n.geometryType==="esriGeometryPoint")i=n.readXWorldSpace(),o=n.readYWorldSpace();else{if(s){const h=n.readCentroidForDisplay();if(h==null)return;const[a,l]=h.coords;if(a<0||a>ee||l<0||l>ee)return}const d=n.readCentroidWorldSpace();if(d==null)return;i=d.coords[0],o=d.coords[1]}this._insert(n,i,o,e)}};const He=96;function oe(n,e){return ke(n)*We*He/e}let Ve=class extends ne{constructor(n){super(n),this._cells=new Map,this._pixelsPerMapUnit=oe(n.spatialReference,n.scale)}get usedMemory(){const n=this._cells.values().next().value;return n?(B+n.usedMemory)*this._cells.size:0}put(n){for(const e of this._cells.values()){const t=n.get(e.id);t?t.merge(e):n.set(e.id,e.clone())}}putBounded(n,e,t){const s=[e.xmin,e.ymin,e.xmax,e.ymax],[r,i,o,d]=s,h=Math.floor(r*this._pixelsPerMapUnit/this._options.cellSize),a=Math.floor(i*this._pixelsPerMapUnit/this._options.cellSize),l=Math.ceil(o*this._pixelsPerMapUnit/this._options.cellSize),c=Math.ceil(d*this._pixelsPerMapUnit/this._options.cellSize);for(let f=a;f<=c;f++)for(let _=h;_<=l;_++){const u=`${_}.${f}`,g=this._cells.get(u);if(!g)continue;const y=n.get(g.id);y?g&&!n.has(g.id)&&y.merge(g):n.set(g.id,g.clone())}}_insert(n,e,t,s){const r=e*this._pixelsPerMapUnit,i=t*this._pixelsPerMapUnit,o=Math.floor(r/this._options.cellSize),d=Math.floor(i/this._options.cellSize);this._getCellOrCreate(o,d).insert(n,s,e,t)}_getCellOrCreate(n,e){const t=v.createId(n,e);let s=this._cells.get(t);if(!s){const r=1*this._options.cellSize/this._pixelsPerMapUnit;s=v.create(n,e,this._options.fields,r),this._cells.set(t,s)}return s}},Ze=class me{static fromReader(e){const t=[],s=e.copy(),r=V();for(;s.next();)s.getBounds(r)&&t.push(s.getIndex());const i=De(9,o=>(s.setIndex(o),{minX:s.getBoundsXMin(),minY:s.getBoundsYMin(),maxX:s.getBoundsXMax(),maxY:s.getBoundsYMax()}));return i.load(t),new me(i,t.length)}constructor(e,t){this._index=e,this._size=t}get usedMemory(){return this._size*B}search(e){const t={minX:e[0],minY:e[1],maxX:e[2],maxY:e[3]};return this._index.search(t)}};const Je=64;function Ke(n,e,t,s){const r=[n.xmin,n.ymin,n.xmax,n.ymax],i=Se.fromExtent(Fe(r,s)),o=C(i,s,b.WGS84,{extendedParams:{densificationStep:e*Je}});if(!o)return null;const d=Q(new x,o,!1,!1),h=d.coords.filter((y,p)=>!(p%2)),a=d.coords.filter((y,p)=>p%2),l=Math.min(...h),c=Math.min(...a),f=Math.max(...h),_=Math.max(...a),u=N(l,c,t,b.WGS84),g=N(f,_,t,b.WGS84);return u&&g?{bounds:r,geohashBounds:{xLL:u[0],yLL:u[1],xTR:g[0],yTR:g[1]},level:t}:null}function N(n,e,t,s){if(s.isWebMercator){const o=Z(n/J.radius),d=o-360*Math.floor((o+180)/360),h=[0,0];return ae(h,0,Z(Math.PI/2-2*Math.atan(Math.exp(-e/J.radius))),d,t),h}const r=C({x:n,y:e},s,b.WGS84);if(!r)return null;const i=[0,0];return ae(i,0,r.y,r.x,t),i}function Qe(n,e){let t=-90,s=90,r=-180,i=180;for(let o=0;o<e;o++){const d=Math.ceil((o+1)/2),h=Math.floor((o+1)/2),a=1-o%2,l=30-(3*d+2*h),c=30-(2*d+3*h),f=3*a+2*(1-a),_=2*a+3*(1-a),u=3*a+7*(1-a)<<c,g=(7*a+3*(1-a)<<l&n.geohashX)>>l,y=(u&n.geohashY)>>c;for(let p=f-1;p>=0;p--){const I=(r+i)/2,m=g&1<<p?1:0;r=(1-m)*r+m*I,i=(1-m)*I+m*i}for(let p=_-1;p>=0;p--){const I=(t+s)/2,m=y&1<<p?1:0;t=(1-m)*t+m*I,s=(1-m)*I+m*s}}return[r,t,i,s]}function ae(n,e,t,s,r){r%2&&(r+=1);let i=0,o=0,d=-90,h=90,a=-180,l=180;for(let c=0;c<r/2;c++){for(let f=0;f<5;f++){const _=(a+l)/2,u=s>_?1:0;i|=u<<29-(f+5*c),a=(1-u)*a+u*_,l=(1-u)*_+u*l}for(let f=0;f<5;f++){const _=(d+h)/2,u=t>_?1:0;o|=u<<29-(f+5*c),d=(1-u)*d+u*_,h=(1-u)*_+u*h}}n[2*e]=i,n[2*e+1]=o}const he=32;class T extends re{static create(e,t,s,r){const i=A.create(e),o=new Array(he);for(let d=0;d<o.length;d++)o[d]=null;return new T(i,t,s,r,o)}constructor(e,t,s,r,i){super(e),this.xNode=t,this.yNode=s,this.depth=r,this.children=i,this._objectIds=new Set,this._count=0,this._xWorldTotal=0,this._yWorldTotal=0,this._xGeohashTotal=0,this._yGeohashTotal=0,this.next=null}static get estimatedMemory(){let e=0;return e+=2*k,e+=B*he,e+=A.estimatedMemory,e}get id(){return`${this.xNode}.${this.yNode}`}get containedObjectIds(){return this._objectIds}get count(){return this._count}clone(){const e=new T(this._statistics.clone(),this.xNode,this.yNode,this.depth,this.children);return e._count=this._count,e._xWorldTotal=this._xWorldTotal,e._yWorldTotal=this._yWorldTotal,e._xGeohashTotal=this._xGeohashTotal,e._yGeohashTotal=this._yGeohashTotal,e.next=this.next,e._objectIds=new Set(this._objectIds),e}insert(e,t,s,r,i,o){this._count+=1,this._xWorldTotal+=t,this._yWorldTotal+=s,this._xGeohashTotal+=r,this._yGeohashTotal+=i,this._statistics.insert(e,o),this._objectIds.add(e.getObjectId())}merge(e){if(e._count!==0){this._count+=e._count,this._xWorldTotal+=e._xWorldTotal,this._yWorldTotal+=e._yWorldTotal,this._xGeohashTotal+=e._xWorldTotal,this._yGeohashTotal+=e._yWorldTotal,this._statistics.merge(e._statistics);for(const t of e._objectIds.values())this._objectIds.add(t)}}getCentroid(e){throw new Error("getCentroid not supported for GeohashNode")}getGeometry(e,t){const s=this._getLngLatBounds(),[r,i,o,d]=s,h=C({rings:[[[r,i],[r,d],[o,d],[o,i],[r,i]]]},b.WGS84,e),a=Q(new x,h,!1,!1);return t!=null?W(new x,a,!1,!1,"esriGeometryPolygon",t,!1,!1):a}getGeometricCentroid(e,t){const s=this._getLngLatBounds(),[r,i,o,d]=s,h=C({x:(r+o)/2,y:(i+d)/2},b.WGS84,e),a=Ue(new x,h);return t!=null?W(new x,a,!1,!1,"esriGeometryPoint",t,!1,!1):a}getAttributes(){const e={aggregateId:this.id};for(const t of this._statistics.values())e[t.field.name]=t.value;return e.aggregateCount=this._count,e}find(e,t,s,r,i,o){if(r>=s)return this;const d=1-r%2,h=3*d+2*(1-d),a=2*d+3*(1-d),l=30-i-h,c=30-o-a,f=((e&7*d+3*(1-d)<<l)>>l)+((t&3*d+7*(1-d)<<c)>>c)*(8*d+4*(1-d)),_=this.children[f];return _==null?null:_.find(e,t,s,r+1,i+h,o+a)}_getLngLatBounds(){const e=this.depth,t=Math.ceil(e/2),s=Math.floor(e/2),r=30-(3*t+2*s),i=30-(2*t+3*s),o=this.xNode<<r,d=this.yNode<<i;return Qe({geohashX:o,geohashY:d},this.depth)}}class et{constructor(e){this._fields=e,this._size=0,this._depth=0,this._root=T.create(this._fields,0,0,0)}destroy(){}get size(){return this._size}get depth(){return this._depth}get usedMemory(){return this._size*T.estimatedMemory}find(e,t,s){return this._root.find(e,t,s,0,0,0)}insert(e,t,s,r,i,o,d){let h=this._root,a=0,l=0,c=0;for(;h!==null;){if(h.insert(e,t,s,r,i,d),a>=o)return;const f=Math.ceil((a+1)/2),_=Math.floor((a+1)/2),u=1-a%2,g=30-(3*f+2*_),y=30-(2*f+3*_),p=(r&7*u+3*(1-u)<<g)>>g,I=(i&3*u+7*(1-u)<<y)>>y,m=p+I*(8*u+4*(1-u));l=l<<3*u+2*(1-u)|p,c=c<<2*u+3*(1-u)|I,h.children[m]==null&&(h.children[m]=T.create(this._fields,l,c,a+1),this._depth=Math.max(this._depth,a+1),this._size+=1),a+=1,h=h.children[m]}}putBins(e,t){for(const s of this.getNodes(t)){const r=e.get(s.id);r?r.merge(s):e.set(s.id,s.clone())}}getNodes(e){const t=[],{geohashBounds:s,level:r}=e;let i=this._root;for(;i!==null;){const o=i.depth,d=i.xNode,h=i.yNode;if(o>=r){t.push(i),i=i.next;continue}const a=Math.ceil((o+1)/2),l=Math.floor((o+1)/2),c=1-o%2,f=30-(3*a+2*l),_=30-(2*a+3*l),u=~((1<<f)-1),g=~((1<<_)-1),y=(s.xLL&u)>>f,p=(s.yLL&g)>>_,I=(s.xTR&u)>>f,m=(s.yTR&g)>>_,E=d<<3*c+2*(1-c),D=h<<2*c+3*(1-c),xe=E+8*c+4*(1-c),Ie=D+4*c+8*(1-c),ve=Math.max(E,y),be=Math.max(D,p),we=Math.min(xe,I),Te=Math.min(Ie,m);let F=null,X=null;for(let P=be;P<=Te;P++)for(let U=ve;U<=we;U++){const Me=U-E+(P-D)*(8*c+4*(1-c)),M=i.children[Me];M&&(F||(F=M,F.next=i.next),X&&(X.next=M),X=M,M.next=i.next)}i=F||i.next}return t}}let tt=class extends ne{constructor(n){super(n),this._tree=new et(this._options.fields)}get usedMemory(){return this._tree.usedMemory}put(n){throw new Error("Geohash tree does not support put")}putBounded(n,e,t){const{geohashLevel:s,spatialReference:r}=this._options,i=Ke(e,t,s,r);i!=null&&this._tree.putBins(n,i)}_insert(n,e,t,s){const{geohashLevel:r,spatialReference:i}=this._options,o=N(e,t,r,i);o&&this._tree.insert(n,e,t,o[0],o[1],r,s)}},de=class j extends K{static from(e,t){if(e instanceof this){const s=new Set(t),r=e._indices.filter(i=>s.has(i));return new j(e._reader,r)}return new j(e.copy(),t)}constructor(e,t){super(e.metadata),this._currentIndex=-1,this._displayTransform=null,this._reader=e,this._indices=t}setTransformForDisplay(e){const t=this._reader.getInTransform();if(t==null)return void(this._displayTransform=L(e));const s=L(t),r=L(e),[i,o]=s.scale,[d,h]=s.translate,[a,l]=r.scale,[c,f]=r.translate,_=i/a,u=o/l,g=(d-c)/a,y=(h-f)/l;this._displayTransform={originPosition:"lowerLeft",scale:[1/_,1/u,1,1],translate:[-g/_,-y/u,0,0]}}getInTransform(){return this._reader.getInTransform()}get fields(){return this._reader.fields}get hasNext(){return this._currentIndex+1<this._indices.length}getSize(){return this._indices.length}getCursor(){return this.copy()}copy(){const e=new j(this._reader.copy(),this._indices);return e._currentIndex=this._currentIndex,e._displayTransform=this._displayTransform,e._processorAttributes=this._processorAttributes,e}get contextTimeZone(){return this._reader.contextTimeZone}set contextTimeZone(e){this._reader.contextTimeZone=e}get usedMemory(){return k+this._reader.usedMemory}setProcessorAttributes(e){this._processorAttributes=Object.assign(this._processorAttributes??{},e)}_nextIndex(){return++this._currentIndex<this._indices.length&&(this._reader.setIndex(this._indices[this._currentIndex]),!0)}next(){for(;this._nextIndex()&&!this._reader._getExists(););return this._currentIndex<this._indices.length}readXForDisplay(){return this._displayTransform?te(this._displayTransform,this._reader.readXForDisplay()):this._reader.readXForDisplay()}readYForDisplay(){return this._displayTransform?se(this._displayTransform,this._reader.readYForDisplay()):this._reader.readYForDisplay()}readGeometryForDisplay(){return this._displayTransform?this._reader.readGeometryForDisplayTransformed(this._displayTransform):this._reader.readGeometryForDisplay()}readCentroidForDisplay(){const e=this._reader.readCentroidForDisplay()?.clone();if(e){const[t,s]=e.coords;this._displayTransform?(e.coords[0]=te(this._displayTransform,t),e.coords[1]=se(this._displayTransform,s)):(e.coords[0]=t,e.coords[1]=s)}return e}get geometryType(){return this._reader.geometryType}get hasFeatures(){return this._reader.hasFeatures}get exceededTransferLimit(){return this._reader.exceededTransferLimit}get hasZ(){return this._reader.hasZ}get hasM(){return this._reader.hasM}readAttribute(e,t=!1){const s=this._reader.readAttribute(e,t);return s==null&&this._processorAttributes?this._processorAttributes[e]:s}readAttributes(){return{...this._processorAttributes,...this._reader.readAttributes()}}joinAttributes(e){return this._reader.joinAttributes(e)}getBounds(e){return this._reader.getBounds(e)}getAttributeHash(){return this._reader.getAttributeHash()}getObjectId(){return this._reader.getObjectId()}getDisplayId(){return this._reader.getDisplayId()}setDisplayId(e){return this._reader.setDisplayId(e)}setIndex(e){return this._reader.setIndex(e)}getIndex(){return this._reader.getIndex()}readXWorldSpace(){return this._reader.readXWorldSpace()}readYWorldSpace(){return this._reader.readYWorldSpace()}_readX(){return this._reader.readXForDisplay()}_readY(){return this._reader.readYForDisplay()}_readServerCentroid(){return this._reader._readServerCentroid()}readLegacyFeatureForDisplay(){const e=this.readCentroidForDisplay();return{attributes:this.readAttributes(),geometry:this.readLegacyGeometryForDisplay(),centroid:(e&&{x:e.coords[0],y:e.coords[1]})??null}}readLegacyGeometryForDisplay(){const e=this.readGeometryForDisplay();return Ye(e,this.geometryType,!1,!1)}readGeometryArea(){return this._displayTransform?this._reader.readGeometryForDisplayTransformed(this._displayTransform)?.area()??0:this._reader.readGeometryArea()}readGeometryWorldSpace(){return this._reader.readGeometryWorldSpace()}_readGeometry(){return this._reader._readGeometry()}_readAttribute(e,t){throw new Error("Error: Should not be called. Underlying _reader should be used instead")}_readAttributes(){throw new Error("Error: Should not be called. Underlying _reader should be used instead")}readArcadeFeature(){return this._reader.readArcadeFeature()}geometry(){return this._reader.geometry()}field(e){return this._reader.field(e)}hasField(e){return this._reader.hasField(e)}setField(e,t){return this._reader.setField(e,t)}keys(){return this._reader.keys()}castToText(e=!1){return this._reader.castToText(e)}},q=class{size(){return this.reader.getSize()}get fields(){return this.reader.fields}invalidate(){this._aggregateIndex=null,this._aggregateIndexHash=null,this._spatialIndex=null}get usedMemory(){let n=0;return n+=this.reader.underlyingMemory,this._aggregateIndex&&(n+=this._aggregateIndex.usedMemory),this._spatialIndex&&(n+=this._spatialIndex.usedMemory),n}registerOverrides(n){this.reader.registerOverrides(n),this.invalidate()}queryFeaturesInBounds(n){const e=this._getSpatialIndex().search(n);return de.from(this.reader,e)}getAggregateIndex(n){const e=JSON.stringify(n);if(e!==this._aggregateIndexHash){switch(this._aggregateIndexHash=e,n.type){case"grid":this._aggregateIndex=new Ve(n);break;case"geohash":this._aggregateIndex=new tt(n)}this._aggregateIndex.insert(this.reader,this.isTiled)}return this._aggregateIndex}_getSpatialIndex(){return this._spatialIndex||(this._spatialIndex=Ze.fromReader(this.reader)),this._spatialIndex}};const le=1e4,st=1e3;class G{static async create(e){const{metadata:t,definitionExpression:s}=e,r=s?await Ce(s,t.fieldsIndex):null;return new G(t,r,s)}constructor(e,t,s){this.metadata=e,this._clause=t,this._definitionExpression=s}get hash(){return this._definitionExpression}testFeature(e){return this._clause==null||this._clause.testFeature(e)}}class z{constructor(){this.modified=new Map,this.removed=new Set}modify(e){this.modified.set(e.objectId,e),this.removed.has(e.objectId)&&this.removed.delete(e.objectId)}remove(e){this.modified.delete(e),this.removed.add(e)}get isEmpty(){return this.modified.size===0&&this.removed.size===0}applyWhereClause(e){const t=new z;for(const[s,r]of this.modified)e.testFeature(r)?t.modified.set(s,r):t.removed.add(r.objectId);for(const s of this.removed)t.removed.add(s);return t}}let ue=class ye extends q{constructor(e){super(),this._reader=e,this.chunkId="override",this.normalizedChunkId="override"}static fromFeatures(e,t){const s=Ge.fromOptimizedFeatures(e,t);return new ye(s)}get reader(){return this._reader}get queryInfo(){return{}}get first(){return!1}get end(){return!1}get isTiled(){return!1}getTileReader(e){if(!this._reader.getSize())return null;const t=this.queryFeaturesInBounds(e.bounds);return t.setTransformForDisplay(e.transform),t}};class O{constructor(e,t){this.inner=e,this.isWeak=t,this.lastWeak=null}get isStrong(){return!this.isWeak}}class rt{constructor(e){this._parameters=e,this._overrides=new Map,this._update=new z,this._lastCleanup=0}update(e){this._parameters=e}hasOverride(e){return this._overrides.has(e)}onChunkInsert(e){if(this._overrides.size){const t=e.reader.getCursor();for(;t.next();){const s=t.getObjectId(),r=this._overrides.get(s);if(r?.lastWeak&&(r.lastWeak=null),r?.isWeak){const i=t.readOptimizedFeatureWorldSpace(),o=r.inner?.attributes??{};i.attributes={...o,...i.attributes},r.inner=i,this._update.modify(i),this.invalidate()}}}e.registerOverrides(this)}apply(e,t){const{updateWeak:s,removeWeak:r,update:i,remove:o,release:d}=e.commands;this.invalidate();for(const h of s){const a=new O(h,!0),l=this._overrides.get(h.objectId);l?.isStrong?l.lastWeak=a:(this._overrides.set(h.objectId,a),this._update.modify(h))}for(const h of i){const a=new O(h,!1),l=this._overrides.get(h.objectId);a.lastWeak=l?.isWeak?l:l?.lastWeak??null,this._overrides.set(h.objectId,a),this._update.modify(h)}for(const h of r){const a=new O(null,!0),l=this._overrides.get(h);l?.isStrong?l.lastWeak=a:(this._overrides.set(h,a),this._update.remove(h))}for(const h of o){const a=new O(null,!1),l=this._overrides.get(h);a.lastWeak=l?.isWeak?l:l?.lastWeak??null,this._overrides.set(h,a),this._update.remove(h)}if(d.length){const h=new Set;for(const a of d){const l=this._overrides.get(a);l?.lastWeak?(this._overrides.set(a,l.lastWeak),l.lastWeak.inner==null?this._update.remove(a):this._update.modify(l.lastWeak.inner)):l&&!l.isWeak&&(this._overrides.delete(a),h.add(a))}t.forEachUnsafe(a=>{const l=a.getObjectId();h.has(l)&&(this._update.modify(a.readOptimizedFeatureWorldSpace()),h.delete(l))});for(const a of h.values())this._update.remove(a)}}clearWeakOverrides(){for(const[e,t]of this._overrides.entries())t.isWeak&&this._overrides.delete(e);this.invalidate()}cleanup(e){if(this._overrides.size<le)return;const t=performance.now();if(t-this._lastCleanup<st)return;this._lastCleanup=t;const s=this._getWeakDeletions();if(!(s.size<le)){for(const r of e){const i=r.reader.withoutOverrides().getCursor();for(;i.next();){const o=i.getObjectId();s.delete(o)}}for(const r of s)this._overrides.delete(r);s.size&&this.invalidate()}}takeOverrideUpdate(){const e=this._update;return e.isEmpty?null:(this._update=new z,e.applyWhereClause(this._parameters))}asChunk(){const e=this._parameters;if(this._lastOverrideParametersHash!==e.hash&&(this._lastOverrideParametersHash=e.hash,this._chunk=null),!this._chunk){const t=[];for(const s of this._overrides.values())s.inner!=null&&e.testFeature(s.inner)&&t.push(s.inner);this._chunk=ue.fromFeatures(t,e.metadata)}return this._chunk}invalidate(){this._chunk=null}putWeakObjectIdsFromGlobalIds(e,t,s){for(const[r,i]of this._overrides.entries()){if(i.isWeak&&i.inner!=null){const o=i.inner.attributes[s];o&&t.has(o)&&!e.has(o)&&e.set(o,r);continue}if(i.lastWeak!=null&&i.lastWeak.inner!=null){const o=i.lastWeak.inner.attributes[s];o&&t.has(o)&&!e.has(o)&&e.set(o,r)}}}_getWeakDeletions(){const e=new Set;for(const[t,s]of this._overrides.entries())s.isWeak&&s.inner==null&&e.add(t);return e}}class it extends q{constructor(e,t,s,r,i=0){super(),this._reader=e,this._queryJSON=t,this._page=s,this._end=r,this._fileIndex=i,this.chunkId=`${this._fileIndex}.${this._page}${this.end?"e":""}`,this.normalizedChunkId=this.chunkId}get reader(){return this._reader}get first(){return this._page===0}get end(){return this._end}get queryInfo(){return{type:"snapshot",chunkId:this.chunkId,queryJSON:this._queryJSON,page:this._page,size:this.size(),end:this.end}}get isTiled(){return!1}getTileReader(e){const t=this.queryFeaturesInBounds(e.bounds);return t.setTransformForDisplay(e.transform),t}}let S;class H extends K{constructor(e,t,s,r,i,o=new Uint32Array(s.size())){super(e),this._fields=t,this._inner=s,this._chunkId=r,this._fileIndex=i,this._displayIds=o,this._index=-1,this.usedMemory=k,this._size=this._inner.size(),e.featureIdInfo.type,this._chunkId>65535&&console.error("Exceeded max allowed parquet reader size")}destroy(){super.destroy(),this._inner.free()}get fields(){return this._fields}get geometryType(){return this.metadata.geometryType}get hasFeatures(){return!0}get hasNext(){throw new Error("Method not implemented.")}get exceededTransferLimit(){return!1}get hasZ(){return!1}get hasM(){return!1}getInTransform(){return null}getSize(){return this._size}getCursor(){return this.copy()}getAttributeHash(){let e="";for(const t of this.fields.fields)e+=this._readAttribute(t.name,!1)+".";return e}getObjectId(){return this._fileIndex<<24|this._inner.rowId(this._index)}getDisplayId(){return this._displayIds[this._index]}setDisplayId(e){this._displayIds[this._index]=e}setIndex(e){this._index=e}getBoundsXMin(){return this._inner.boundsXMin(this._index)}getBoundsYMin(){return this._inner.boundsYMin(this._index)}getBoundsXMax(){return this._inner.boundsXMax(this._index)}getBoundsYMax(){return this._inner.boundsYMax(this._index)}setBoundsXMin(e){throw new Error("InternalError: Setting bounds is unsupported")}setBoundsYMin(e){throw new Error("InternalError: Setting bounds is unsupported")}setBoundsXMax(e){throw new Error("InternalError: Setting bounds is unsupported")}setBoundsYMax(e){throw new Error("InternalError: Setting bounds is unsupported")}getIndex(){return this._index}next(){for(;++this._index<this._size&&!this._getExists(););return this._index<this._size}readGeometryArea(){return this.readGeometryForDisplay()?.area()??0}copy(){const e=new H(this.metadata,this._fields,this._inner,this._chunkId,this._fileIndex,this._displayIds);return this.copyInto(e),e}copyInto(e){super.copyInto(e),e._index=this._index}readGeometryForDisplayTransformed(e){const[t,s]=e.translate,[r,i]=e.scale;return S||(S=Oe.new()),this._inner.transformGeometry(S,t,s,r,i,this._index)?new x(S.readLengthsUnsafe(),S.readCoordsUnsafe()):null}_readGeometry(e){const t=this._inner.readCoords(this._index),s=this._inner.readLengths(this._index);return t&&s?new x(s,t):null}_readX(){return this._inner.readX(this._index)}_readY(){return this._inner.readY(this._index)}_readServerCentroid(){return null}_readAttribute(e,t){const s=this.fields.get(e);if(!s)return;if(s.column==null)return this.getObjectId();const r=this._inner.readAttribute(this._index,s.column);if(r==null)return r;const i=this.fields.isDateField(s.name);return t?r==null?r:i?new Date(r):r:r}_readAttributes(){const e={};for(const t of this._fields.fields)t.column!=null&&(this._inner.isEmpty(t.column)||(e[t.name]=this._readAttribute(t.name,!1)));return e.__OBJECTID=this.getObjectId(),e}}class nt{constructor(){this._chunks=new Map,this._chunksToRemove=[],this.events=new Ae,this.featureAdapter=new ze}destroy(){this.clear()}clear(){for(const e of this._chunks.values())this._chunksToRemove.push(e);this._chunks.clear(),this._overrides?.clearWeakOverrides()}get usedMemory(){let e=0;for(const t of this._chunks.values())e+=t.usedMemory;return e}async update(e){if(this._overrides){const t=await G.create(e);this._overrides.update(t)}this._schema=e}*chunks(){this._overrides&&(yield this._overrides.asChunk()),yield*this._chunks.values()}insert(e){Y("esri-2d-update-debug")&&console.debug(`Chunk[${e.chunkId}] SourceChunkStore.insert`),this._overrides?.onChunkInsert(e),this._chunks.set(e.chunkId,e),this.events.emit("changed")}remove(e){Y("esri-2d-update-debug")&&console.debug(`Chunk[${e.chunkId}] SourceChunkStore.remove`),this._chunks.delete(e.chunkId),this._chunksToRemove.push(e)}removeById(e){Y("esri-2d-update-debug")&&console.debug(`Chunk[${e}] SourceChunkStore.remove`);const t=this._chunks.get(e);this._chunks.delete(e),t&&this._chunksToRemove.push(t)}cleanup(){const e=this._chunksToRemove;return this._chunksToRemove=[],this._overrides?.cleanup(this._chunks.values()),e}async applyOverride(e){if(this._overrides==null){const t=await G.create(this._schema);this._overrides=new rt(t);for(const s of this._chunks.values())this._overrides.onChunkInsert(s)}this._overrides.apply(e,this),this.events.emit("changed");for(const t of this._chunks.values())t.invalidate()}takeOverrideUpdate(){return this._overrides?.takeOverrideUpdate()}refresh(){this.events.emit("refresh")}forEach(e){const t=new Set;for(const s of this.chunks()){const r=s.reader.getCursor();for(;r.next();){const i=r.getObjectId();t.has(i)||(e(r.copy()),t.add(i))}}}forEachUnsafe(e){const t=new Set;for(const s of this.chunks()){const r=s.reader.getCursor();for(;r.next();){const i=r.getObjectId();t.has(i)||(e(r),t.add(i))}}}mapObjectIdsFromGlobalIds(e,t){const s=new Map,r=new Set(e);return this._overrides?.putWeakObjectIdsFromGlobalIds(s,r,t),this._forEachUnsafeIgnoreOverrides(i=>{const o=i.readAttribute(t);if(o&&r.has(o)&&!s.has(o)){const d=i.getObjectId();s.set(o,d)}}),s}forEachInBounds(e,t){const s=new Set;for(const r of this.chunks()){const i=r.queryFeaturesInBounds(e);for(;i.next();){const o=i.getObjectId();s.has(o)||(t(i.copy()),s.add(o))}}}forEachBounds(e,t){const s=V();for(const r of e)r.getBounds(s)&&t(s)}_forEachUnsafeIgnoreOverrides(e){const t=new Set;for(const s of this._chunks.values()){const r=s.reader.withoutOverrides().getCursor();for(;r.next();){const i=r.getObjectId();t.has(i)||(e(r),t.add(i))}}}}export{ue as a,A as b,q as c,de as d,H as i,v as l,nt as n,oe as r,it as t};
