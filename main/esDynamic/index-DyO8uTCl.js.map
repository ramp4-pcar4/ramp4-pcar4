{"version":3,"file":"index-DyO8uTCl.js","sources":["../../src/fixtures/export-legend/index.ts"],"sourcesContent":["import { FixtureInstance, LayerInstance } from '@/api/internal';\nimport type { ExportAPI, ExportSubFixture } from '@/fixtures/export/api/export';\nimport { fabric } from 'fabric';\nimport type { LegendSymbology } from '@/geo/api';\nimport type { ExportConfig } from '../export/store';\n\n/**\n * Represents a map layer.\n *\n * @interface Segment\n */\ninterface Segment {\n    title: fabric.Text;\n    items: SegmentChunk[];\n}\n\n/**\n * Represents a map layer entry.\n *\n * @interface SegmentChunk\n */\ninterface SegmentChunk {\n    title?: fabric.Text;\n\n    /**\n     * Represents layer entry symbology.\n     *\n     * @type {fabric.Group[]}\n     * @memberof SegmentChunk\n     */\n    items: fabric.Group[];\n}\n\nconst SEGMENT_TOP_MARGIN = 30;\nconst SEGMENT_BOTTOM_MARGIN = 20;\nconst CHUNK_TOP_MARGIN = 16;\nconst CHUNK_BOTTOM_MARGIN = 12;\nconst ITEM_MARGIN = 8;\n\nconst ROW_HEIGHT = 32;\nconst ICON_WIDTH = 32;\n\nconst MIN_COLUMN_WIDTH = 350;\nconst COLUMN_SPACING = 20;\n\nconst DEFAULT_FONT = 'Montserrat, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif';\n\nclass ExportLegendFixture extends FixtureInstance implements ExportSubFixture {\n    get config(): any {\n        const fixtureConfig: ExportConfig | undefined = this.$iApi.fixture.get<ExportAPI>('export').config;\n        return fixtureConfig?.legend;\n    }\n\n    async make(options: any): Promise<fabric.Group> {\n        // filter out loading/errored, invisible, and cosmetic layers\n        const layers = this.$iApi.geo.layer.allLayersOnMap().filter(layer => !layer.isCosmetic);\n\n        if (layers.length === 0) {\n            // return an empty group\n            return new fabric.Group([], {\n                originX: 'left'\n            });\n        }\n\n        // number of columns based on export width and min col width\n        const columns = Math.min(\n            layers.length,\n            Math.floor(options.width / (MIN_COLUMN_WIDTH + COLUMN_SPACING)) || 1 // round to 1 if floor is 0\n        );\n\n        // calculate column width such that columns are even spaced across entire export width\n        const columnWidth = (options.width - (columns - 1) * COLUMN_SPACING) / columns;\n\n        let runningHeight = 0;\n\n        const segments = await Promise.all(this._makeSegments(layers as unknown as Array<LayerInstance>, columnWidth));\n\n        // string all the graphic legend elements together adding margins between them\n        const fbAllItems = segments\n            .map(({ title: segmentTitle, items: chunks }, segmentIndex) => {\n                if (segmentIndex > 0) {\n                    runningHeight += SEGMENT_TOP_MARGIN;\n                }\n\n                segmentTitle.top = runningHeight;\n                runningHeight += segmentTitle.height! + SEGMENT_BOTTOM_MARGIN;\n\n                const allChunkItems = chunks.map(({ title: chunkTitle, items: chunkItems }, chunkIndex) => {\n                    const result = [];\n\n                    // if a single chunk shares the title with its parent segment, skip the chunk title\n                    if (chunkTitle && !(chunks.length === 1 && chunkTitle.text === segmentTitle.text)) {\n                        if (chunkIndex > 0) {\n                            runningHeight += CHUNK_TOP_MARGIN;\n                        }\n\n                        chunkTitle.top = runningHeight;\n                        runningHeight += chunkTitle.height! + CHUNK_BOTTOM_MARGIN;\n\n                        result.push(chunkTitle);\n                    }\n\n                    chunkItems.forEach(item => {\n                        item.top = runningHeight;\n                        runningHeight += item.height! + ITEM_MARGIN;\n                    });\n\n                    return [...result, ...chunkItems].filter(a => a);\n                });\n\n                // create a group for each config layer\n                return new fabric.Group([segmentTitle, ...allChunkItems.flat()]);\n            })\n            .flat();\n\n        const fbLegend = this._makeColumns(fbAllItems, columnWidth, columns);\n\n        return Promise.resolve(fbLegend);\n    }\n\n    /**\n     * Breaks up legend layers into columns\n     *\n     * @private\n     * @param {fabric.Group[]} items\n     * @param {number} columnWidth\n     * @param {number} columns\n     * @returns {fabric.Group}\n     * @memberof ExportLegendFixture\n     */\n    private _makeColumns(items: fabric.Group[], columnWidth: number, columns: number) {\n        let curColumn = 0;\n        let curTop = 0;\n        let accumLength = 0;\n        // target column height is the total length of all items divided by number of columns\n        const targetHeight: number = items[items.length - 1].aCoords!.bl.y / columns;\n\n        items.forEach((group, index) => {\n            const height: number = index !== items.length - 1 ? items[index + 1].top! - group.top! : group.height!;\n\n            // reached end of column, try to evently split items\n            const columnFull: boolean = accumLength > targetHeight * (curColumn + 1);\n            // don't allow column to go over target if layer is very long\n            const longLayer: boolean = curTop !== 0 && height > targetHeight;\n            // ensure there are no empty columns on the right\n            const fillColumns: boolean = columns - curColumn > items.length - index;\n\n            if ((columnFull || longLayer || fillColumns) && curColumn < columns) {\n                // move to next column\n                ++curColumn;\n                curTop = 0;\n            }\n\n            // update layer position in legend export\n            group.left = curColumn * (columnWidth + COLUMN_SPACING);\n            group.top = curTop;\n\n            curTop += height;\n            accumLength += height;\n        });\n\n        return new fabric.Group(items, {\n            originX: 'left'\n        });\n    }\n\n    /**\n     * Create segments of the export image based on the provided layers and layer configs.\n     *\n     * @private\n     * @param {LayerInstance[]} layers\n     * @param {RampLayerConfig[]} layerConfigs\n     * @returns {Promise<Segment>[]}\n     * @memberof ExportLegendFixture\n     */\n    private _makeSegments(layers: LayerInstance[], segmentWidth: number): Promise<Segment>[] {\n        return layers.map(async (layer: LayerInstance) => {\n            const title = new fabric.Textbox(layer.name, {\n                fontSize: 24,\n                fontFamily: DEFAULT_FONT,\n                width: segmentWidth\n            });\n\n            // filter out invisible layer entries\n            const ids = this._getLayerTreeIds(layer);\n\n            let items: any = [];\n            items = layer.supportsSublayers\n                ? await Promise.all(\n                      this._makeSegmentChunks(ids, layer, segmentWidth) // pass list of flatenned sublayer ids\n                  )\n                : await Promise.all(\n                      this._makeSegmentChunks([-1], layer, segmentWidth) // pass single -1 id so the root gets processed\n                  );\n\n            return { title, items };\n        });\n    }\n\n    /**\n     * Creates segment chunks based on the provided layer and layer entry id.\n     *\n     * Used for layers that support sublayers (e.g. MapImageLayers)\n     *\n     * @private\n     * @param {(number[] | string[])} ids\n     * @param {LayerInstance} layer\n     * @returns {Promise<SegmentChunk>[]}\n     * @memberof ExportLegendFixture\n     */\n    private _makeSegmentChunks(ids: number[], layer: LayerInstance, segmentWidth: number): Promise<SegmentChunk>[] {\n        const rootLayer: LayerInstance = layer;\n        return ids.map<Promise<SegmentChunk>>(async (idx: number) => {\n            const currLayer: LayerInstance | undefined = idx === -1 ? rootLayer : rootLayer.getSublayer(idx);\n\n            if (!currLayer) {\n                // This should not happen, but if it does return an ERROR label\n                return {\n                    title: new fabric.Textbox('ERROR', {\n                        fontSize: 20,\n                        fontFamily: DEFAULT_FONT,\n                        width: segmentWidth\n                    }),\n                    items: []\n                };\n            }\n\n            await Promise.all(currLayer.legend.map(lg => lg.drawPromise));\n            const symbologyStack = currLayer.legend;\n\n            const title = new fabric.Textbox(currLayer.name, {\n                fontSize: 20,\n                fontFamily: DEFAULT_FONT,\n                width: segmentWidth\n            });\n\n            const items = await Promise.all(this._makeChunkItems(symbologyStack, segmentWidth));\n\n            return {\n                title,\n                items\n            };\n        });\n    }\n\n    /**\n     * Creates layer entry symbology based on the provided symbology stack.\n     *\n     * @private\n     * @param {LegendSymbology[]} symbologyStack\n     * @returns {Promise<fabric.Group>[]}\n     * @memberof ExportLegendFixture\n     */\n    private _makeChunkItems(symbologyStack: LegendSymbology[], segmentWidth: number): Promise<fabric.Group>[] {\n        return symbologyStack.map(async symbol => {\n            const fbSymbol = (await promisify(fabric.loadSVGFromString)(symbol.svgcode))[0];\n\n            if (!symbol.esriStandard) {\n                // WMS legend\n                const fbLabel = new fabric.Textbox(symbol.label, {\n                    fontSize: 12,\n                    fontFamily: DEFAULT_FONT,\n                    originY: 'center',\n                    left: 0,\n                    top: ROW_HEIGHT / 2,\n                    width: segmentWidth\n                });\n\n                const symbolWidth = Number(symbol.imgWidth!);\n                const symbolHeight = Number(symbol.imgHeight!);\n\n                // scale down image if wider than column\n                const scale = Math.min(1, segmentWidth / symbolWidth);\n\n                if (fbSymbol) {\n                    fbSymbol.originY = 'center';\n                    fbSymbol.top = (symbolHeight * scale) / 2 + ROW_HEIGHT;\n                    fbSymbol.scaleToHeight(symbolHeight * scale);\n                    fbSymbol.scaleToWidth(symbolWidth * scale);\n                }\n\n                return new fabric.Group([fbLabel, fbSymbol].filter(Boolean), {\n                    height: symbolHeight * scale + ROW_HEIGHT\n                });\n            } else {\n                fbSymbol.originY = 'center';\n                fbSymbol.top = ROW_HEIGHT / 2;\n\n                const fbLabel = new fabric.Textbox(symbol.label, {\n                    fontSize: 12,\n                    fontFamily: DEFAULT_FONT,\n                    originY: 'center',\n                    left: ICON_WIDTH + 20,\n                    top: ROW_HEIGHT / 2,\n                    width: segmentWidth - ICON_WIDTH - 20\n                });\n\n                return new fabric.Group([fbSymbol, fbLabel], {\n                    height: ROW_HEIGHT\n                });\n            }\n        });\n    }\n\n    /**\n     * Gets flattened array of ids from layer tree\n     *\n     * @private\n     * @param {TreeNode} node\n     * @returns {number[]}\n     * @memberof ExportLegendFixture\n     */\n    private _getLayerTreeIds(rootLayer: LayerInstance): number[] {\n        const ids: Array<number> = [];\n        const queue: Array<LayerInstance> = [...rootLayer.sublayers];\n\n        while (queue.length > 0) {\n            const sublayer: LayerInstance = queue.shift()!;\n            if (!sublayer) {\n                continue;\n            }\n\n            if (sublayer.visibility) {\n                ids.push(sublayer.layerIdx);\n            }\n\n            queue.push(...sublayer.sublayers);\n        }\n\n        return ids;\n    }\n}\n\ntype Callback<A> = (args: A) => void;\n\n/**\n * A utility function to promisify callback-based function.\n * TODO: move somewhere where this can be reused\n *\n * @param fn A\n * @returns\n */\nconst promisify = <T, A>(fn: (args: T, cb: Callback<A>) => void): ((args: T) => Promise<A>) => {\n    return (args: T) =>\n        new Promise(resolve => {\n            fn(args, callbackArgs => {\n                resolve(callbackArgs);\n            });\n        });\n};\n\nexport default ExportLegendFixture;\n"],"names":["SEGMENT_TOP_MARGIN","SEGMENT_BOTTOM_MARGIN","CHUNK_TOP_MARGIN","CHUNK_BOTTOM_MARGIN","ITEM_MARGIN","ROW_HEIGHT","ICON_WIDTH","MIN_COLUMN_WIDTH","COLUMN_SPACING","DEFAULT_FONT","ExportLegendFixture","FixtureInstance","options","layers","layer","fabric","columns","columnWidth","runningHeight","fbAllItems","segmentTitle","chunks","segmentIndex","allChunkItems","chunkTitle","chunkItems","chunkIndex","result","item","a","fbLegend","items","curColumn","curTop","accumLength","targetHeight","group","index","height","columnFull","longLayer","fillColumns","segmentWidth","title","ids","rootLayer","idx","currLayer","lg","symbologyStack","symbol","fbSymbol","promisify","fbLabel","symbolWidth","symbolHeight","scale","queue","sublayer","fn","args","resolve","callbackArgs"],"mappings":"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"}