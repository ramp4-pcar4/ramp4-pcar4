import{bE as W,cs as k,H as G,bQ as _,I as $,ab as B,cg as L,aG as F,eY as J,i as K,aH as O,z as H,y as V,s as Z}from"./main-6gYsRPh_.js";import{n as tt}from"./Cyclical-U44SrVPp.js";import{r as P,i as R,o as j,s as U}from"./normalizeUtilsCommon-C9xHTsMD.js";import{f as et}from"./utils-hE7D5uZL.js";import{r as nt,o as st}from"./utils-c9J6vWTl.js";async function rt(t,e,i,r){const n=et(t),a=e[0].spatialReference,o={...r,responseType:"json",query:{...n.query,f:"json",sr:k(a),target:JSON.stringify({geometryType:W(e[0]),geometries:e}),cutter:JSON.stringify(i)}},s=await G(n.path+"/cut",o),{cutIndexes:l,geometries:f=[]}=s.data;return{cutIndexes:l,geometries:f.map(u=>{const m=_(u);return m.spatialReference=a,m})}}async function ot(t,e,i){const r=typeof t=="string"?$(t):t,n=e[0].spatialReference,a=W(e[0]),o={...i,query:{...r.query,f:"json",sr:k(n),geometries:JSON.stringify(nt(e))}},{data:s}=await G(r.path+"/simplify",o);return st(s.geometries,a,n)}const X=()=>K.getLogger("esri.geometry.support.normalizeUtils");function it(t){return t.type==="polygon"}function at(t){return t[0].type==="polygon"}function lt(t){return t[0].type==="polyline"}function C(t){const e=[];let i=0,r=0;for(let n=0;n<t.length;n++){const a=t[n];let o=null;for(let s=0;s<a.length;s++)o=a[s],e.push(o),s===0?(i=o[0],r=i):(i=Math.min(i,o[0]),r=Math.max(r,o[0]));o&&e.push([(i+r)/2,0])}return e}function D(t,e){if(!(t instanceof F||t instanceof O)){const n="straightLineDensify: the input geometry is neither polyline nor polygon";throw X().error(n),new Z("internal:geometry",n)}const i=j(t),r=[];for(const n of i){const a=[];r.push(a),a.push([n[0][0],n[0][1]]);for(let o=0;o<n.length-1;o++){const s=n[o][0],l=n[o][1],f=n[o+1][0],u=n[o+1][1],m=Math.sqrt((f-s)*(f-s)+(u-l)*(u-l)),p=(u-l)/m,d=(f-s)/m,g=m/e;if(g>1){for(let z=1;z<=g-1;z++){const S=z*e,c=d*S+s,h=p*S+l;a.push([c,h])}const b=(m+Math.floor(g-1)*e)/2,q=d*b+s,v=p*b+l;a.push([q,v])}a.push([f,u])}}return it(t)?new O({rings:r,spatialReference:t.spatialReference}):new F({paths:r,spatialReference:t.spatialReference})}function E(t,e,i){if(e){const r=D(t,1e6);t=V(r,!0)}return i&&(t=U(t,i)),t}function Q(t,e,i){if(Array.isArray(t)){const r=t[0];if(r>e){const n=R(r,e);t[0]=r+n*(-2*e)}else if(r<i){const n=R(r,i);t[0]=r+n*(-2*i)}}else{const r=t.x;if(r>e){const n=R(r,e);t=t.clone().offset(n*(-2*e),0)}else if(r<i){const n=R(r,i);t=t.clone().offset(n*(-2*i),0)}}return t}function ct(t,e){let i=-1;for(let r=0;r<e.cutIndexes.length;r++){const n=e.cutIndexes[r],a=e.geometries[r],o=j(a);for(let s=0;s<o.length;s++){const l=o[s];l.some(f=>{if(f[0]<180)return!0;{let u=0;for(let p=0;p<l.length;p++){const d=l[p][0];u=d>u?d:u}u=Number(u.toFixed(9));const m=-360*R(u,180);for(let p=0;p<l.length;p++){const d=a.getPoint(s,p);a.setPoint(s,p,d.clone().offset(m,0))}return!0}})}if(n===i){if(at(t))for(const s of j(a))t[n]=t[n].addRing(s);else if(lt(t))for(const s of j(a))t[n]=t[n].addPath(s)}else i=n,t[n]=a}return t}async function Y(t,e,i){if(!Array.isArray(t))return Y([t],e);e&&typeof e!="string"&&X().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const r=typeof e=="string"?e:e?.url??B.geometryServiceUrl;let n,a,o,s,l,f,u,m,p=0;const d=[],g=[];for(const c of t)if(c!=null)if(n||(n=c.spatialReference,a=L(n),o=n.isWebMercator,f=o?102100:4326,s=P[f].maxX,l=P[f].minX,u=P[f].plus180Line,m=P[f].minus180Line),a)if(c.type==="mesh")g.push(c);else if(c.type==="point")g.push(Q(c.clone(),s,l));else if(c.type==="multipoint"){const h=c.clone();h.points=h.points.map(x=>Q(x,s,l)),g.push(h)}else if(c.type==="extent"){const h=c.clone()._normalize(!1,!1,a);g.push(h.rings?new O(h):h)}else if(c.extent){const h=c.extent,x=R(h.xmin,l)*(2*s);let M=x===0?c.clone():U(c.clone(),x);h.offset(x,0);let{xmin:w,xmax:y}=h;w=Number(w.toFixed(9)),y=Number(y.toFixed(9)),h.intersects(u)&&y!==s?(p=y>p?y:p,M=E(M,o),d.push(M),g.push("cut")):h.intersects(m)&&w!==l?(p=y*(2*s)>p?y*(2*s):p,M=E(M,o,360),d.push(M),g.push("cut")):g.push(M)}else g.push(c.clone());else g.push(c);else g.push(c);let b=R(p,s),q=-90;const v=b,z=new F;for(;b>0;){const c=360*b-180;z.addPath([[c,q],[c,-1*q]]),q*=-1,b--}if(d.length>0&&v>0){const c=ct(d,await rt(r,d,z,i)),h=[],x=[];for(let y=0;y<g.length;y++){const A=g[y];if(A!=="cut")x.push(A);else{const I=c.shift(),N=t[y];N!=null&&N.type==="polygon"&&N.rings&&N.rings.length>1&&I.rings.length>=N.rings.length?(h.push(I),x.push("simplify")):x.push(o?J(I):I)}}if(!h.length)return x;const M=await ot(r,h,i),w=[];for(let y=0;y<x.length;y++){const A=x[y];A!=="simplify"?w.push(A):w.push(o?J(M.shift()):M.shift())}return w}const S=[];for(let c=0;c<g.length;c++){const h=g[c];if(h!=="cut")S.push(h);else{const x=d.shift();S.push(o===!0?J(x):x)}}return S}function ft(t){if(!t)return null;const e=t.extent;if(!e)return null;const i=t.spatialReference&&L(t.spatialReference);if(!i)return e;const[r,n]=i.valid,a=2*n,{width:o}=e;let s,{xmin:l,xmax:f}=e;if([l,f]=[f,l],t.type==="extent"||o===0||o<=n||o>a||l<r||f>n)return e;switch(t.type){case"polygon":if(!(t.rings.length>1))return e;s=C(t.rings);break;case"polyline":if(!(t.paths.length>1))return e;s=C(t.paths);break;case"multipoint":s=t.points}const u=e.clone();for(let m=0;m<s.length;m++){let p=s[m][0];p<0?(p+=n,f=Math.max(p,f)):(p-=n,l=Math.min(p,l))}return u.xmin=l,u.xmax=f,u.width<o?(u.xmin-=n,u.xmax-=n,u):e}function ut(t,e,i){const r=L(i);if(r==null)return t;const[n,a]=r.valid,o=2*a;let s=0,l=0;e>a?s=Math.ceil(Math.abs(e-a)/o):e<n&&(s=-Math.ceil(Math.abs(e-n)/o)),t>a?l=Math.ceil(Math.abs(t-a)/o):t<n&&(l=-Math.ceil(Math.abs(t-n)/o));let f=t+(s-l)*o;const u=f-e;return u>a?f-=o:u<n&&(f+=o),f}function pt(t,e){return T(e)?.normalize(t)??t}function T(t){const e=L(t);if(e==null)return null;const[i,r]=e.valid;return new tt(i,r)}const ht=T(H.WGS84);T(H.WebMercator);export{ht as A,ut as L,Y as P,pt as S,D as b,ft as z};
