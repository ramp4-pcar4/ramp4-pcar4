import{_ as d,c1 as x,Y as y,ch as l,cl as h}from"./main-6gYsRPh_.js";import{c as O}from"./projectionUtils-CVhOpzeN.js";import{c as i}from"./PixelBlock-CIPHcvhA.js";import{k,R as g,O as N,y as B}from"./RasterSymbolizer-BjGm7f2J.js";import{f as P,j as J,u as w,W as b,E as v,T as z,N as T,D,a as F}from"./vectorFieldUtils-SYjs0cN6.js";import{T as I}from"./rasterFunctionHelper-C61ZvN6T.js";import{j as L,r as j}from"./rasterProjectionHelper-DA2LiUFi.js";import{t as E,u as R,n as G}from"./GCSShiftTransform-CUMgRrbh.js";import{c as X}from"./dataUtils-BCqrjtX7.js";var p;let m=p=class extends E{constructor(){super(...arguments),this.type="identity"}clone(){return new p}};d([x({IdentityXform:"identity"})],m.prototype,"type",void 0),m=p=d([y("esri.layers.support.rasterTransforms.IdentityTransform")],m);const A={GCSShiftXform:G,IdentityXform:m,PolynomialXform:R};function M(a){if(!a?.type)return null;const e=A[a?.type];if(e){const r=new e;return r.read(a),r}return null}function n(a){if(!a)return{result:null,transferList:[]};const{pixelBlock:e,transferList:r}=a.getTransferableObject();return{result:e,transferList:r}}class W{convertVectorFieldData(e){const r=i.fromJSON(e.pixelBlock),s=n(P(r,e.type));return Promise.resolve(s)}convertPixelBlockToFeatures(e){const r=J({pixelBlock:i.fromJSON(e.pixelBlock),extent:l.fromJSON(e.extent),fieldNames:e.fieldNames,skipFactor:e.skipFactor,skipSpatialReference:!0,pixelIdOffset:e.pixelIdOffset,imageRowSize:e.imageRowSize});return Promise.resolve(r)}computeStatisticsHistograms(e){const r=i.fromJSON(e.pixelBlock),s=k(r,{histogramSize:e.histogramSize,includeSkewnessKurtosis:e.includeSkewnessKurtosis});return Promise.resolve(s)}async decode(e){return n(await g(e.data,e.options))}symbolize(e){e.pixelBlock=i.fromJSON(e.pixelBlock),e.extent=e.extent?l.fromJSON(e.extent):null;const r=n(this.symbolizer.symbolize(e));return Promise.resolve(r)}highlightPixels(e){const r=i.fromJSON(e.pixelBlock),s=i.fromJSON(e.renderedPixelBlock);return w(r,s,e.highlightOptions),Promise.resolve(s.toJSON())}async updateSymbolizer(e){this.symbolizer=N.fromJSON(e.symbolizerJSON),e.histograms&&this.symbolizer?.rendererJSON.type==="rasterStretch"&&(this.symbolizer.rendererJSON.histograms=e.histograms)}async updateRasterFunction(e){this.rasterFunction=I(e.rasterFunctionJSON)}async process(e){return n(this.rasterFunction.process({extent:l.fromJSON(e.extent),primaryPixelBlocks:e.primaryPixelBlocks.map(r=>r!=null?i.fromJSON(r):null),primaryPixelSizes:e.primaryPixelSizes?.map(r=>r!=null?h.fromJSON(r):null),primaryRasterIds:e.primaryRasterIds}))}stretch(e){const r=n(this.symbolizer.simpleStretch(i.fromJSON(e.srcPixelBlock),e.stretchParams));return Promise.resolve(r)}estimateStatisticsHistograms(e){const r=B(i.fromJSON(e.srcPixelBlock));return Promise.resolve(r)}split(e){const r=b(i.fromJSON(e.srcPixelBlock),e.tileSize,e.maximumPyramidLevel??0,e.useBilinear===!1),s=[];let t;return r&&(t=new Map,r.forEach((o,f)=>{if(o){const{pixelBlock:u,transferList:c}=o.getTransferableObject();t.set(f,u),c.forEach(S=>{s.includes(S)||s.push(S)})}})),Promise.resolve({result:t,transferList:s})}clipTile(e){const r=i.fromJSON(e.pixelBlock),s=n(v({...e,pixelBlock:r}));return Promise.resolve(s)}async mosaicAndTransform(e){const r=e.srcPixelBlocks.map(c=>c?new i(c):null),s=z(r,e.srcMosaicSize,{blockWidths:e.blockWidths,alignmentInfo:e.alignmentInfo,clipOffset:e.clipOffset,clipSize:e.clipSize});let t,o=s;e.coefs&&(o=T(s,e.destDimension,e.coefs,e.sampleSpacing,e.interpolation)),e.projectDirections&&e.gcsGrid&&(t=D(e.destDimension,e.gcsGrid),o=F(o,e.isUV?"vector-uv":"vector-magdir",t));const{result:f,transferList:u}=n(o);return{result:{pixelBlock:f,localNorthDirections:t},transferList:u}}async createFlowMesh(e,r){const s={data:new Float32Array(e.flowData.buffer),mask:new Uint8Array(e.flowData.maskBuffer),width:e.flowData.width,height:e.flowData.height},{vertexData:t,indexData:o}=await X(e.meshType,e.simulationSettings,s,r.signal);return{result:{vertexBuffer:t.buffer,indexBuffer:o.buffer},transferList:[t.buffer,o.buffer]}}async getProjectionOffsetGrid(e){const r=l.fromJSON(e.projectedExtent),s=l.fromJSON(e.srcBufferExtent);let t=null;e.datumTransformationSteps?.length&&(t=new O({steps:e.datumTransformationSteps})),await L();const o=e.rasterTransform?M(e.rasterTransform):null;return j({...e,projectedExtent:r,srcBufferExtent:s,datumTransformation:t,rasterTransform:o})}}export{W as default};
