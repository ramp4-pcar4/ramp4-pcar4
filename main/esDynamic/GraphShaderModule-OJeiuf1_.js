import{E as W}from"./enums-COb5EYx9.js";import{v as w,t as oe,s as ae,i as Ot,gL as ce}from"./main-CnDVnExo.js";import{a as ue,S as he}from"./Texture-BMXmG4Zf.js";import"./enums-wEDHPbCF.js";import"./FramebufferObject-BCj-WFlt.js";import{a as de}from"./ProgramTemplate-BzJLUm2k.js";import{i as pe}from"./ShaderBuilder-D7ZTGT0a.js";let le=class{constructor(){this.drawPhase=W.MAP|W.HITTEST|W.HIGHLIGHT|W.DEBUG}startup(){}shutdown(e){}};function fe(e){return e.split(" ").map((t,r)=>r>0?t.charAt(0).toUpperCase()+t.slice(1):t).join("")}function ye(e,t){const r=[];for(r.push(t);r.length;){const n=r.pop();if(typeof n=="object"&&!e.has(n.uid)){e.add(n.uid);for(const i of n.children)r.push(i)}}}let F=class Et{constructor(){this.uid=Et.NodeCount++,this._debugName=null,this._isMutable=!1,this.isImplicit=!1}static{this.NodeCount=0}get isMutable(){return this._isMutable}setMutable(){return this._isMutable=!0,this}setDebugName(t){return t=fe(t),this._debugName=t,this.isImplicit&&this.children[0]instanceof Et&&this.children[0].setDebugName(t),this}get debugInfo(){return{name:this._debugName??""}}cloneInto(t){t._debugName=this._debugName,t._isMutable=this._isMutable,t.isImplicit=this.isImplicit,t.uid=this.uid}};function o(e){return typeof e=="object"?e.clone():e}let m=class extends F{constructor(){super(...arguments),this.shaderType="primitive-node"}},me=class Wt extends F{constructor(t){super(),this.child=t,this.shaderType="scope-node"}get children(){return[this.child]}clone(){const t=new Wt(o(this.child));return this.cloneInto(t),t}};class Ut extends F{constructor(t,r,n){super(),this.property=t,this.target=r,this.returnType=n,this.shaderType="property-access-node"}get children(){const t=[this.target];return typeof this.property!="string"&&t.push(this.property),t}clone(){const t=new Ut(this.property,o(this.target),this.returnType);return this.cloneInto(t),t}}let ge=class Zt extends F{constructor(t,r,n,i){super(),this.x=t,this.y=r,this.target=n,this.returnType=i,this.shaderType="property-access-2d-node"}get children(){return[this.target,this.x,this.y]}clone(){const t=new Zt(this.x,this.y,o(this.target),this.returnType);return this.cloneInto(t),t}};class Kt extends F{constructor(t,r,n){super(),this.condition=t,this.ifTrue=r,this.ifFalse=n,this.shaderType="condition-node"}get children(){return[this.condition,this.ifTrue,this.ifFalse]}clone(){const t=o(this.ifTrue),r=this.ifFalse?o(this.ifFalse):null,n=new Kt(this.condition,t,r);return this.cloneInto(n),n}}let be=class te extends F{constructor(t,r,n,i){super(),this.captureList=t,this.returnType=r,this.generator=i,this.shaderType="block-node",n&&(this.subgraph=new me(n))}get children(){return Object.keys(this.captureList).map(t=>this.captureList[t]).concat(this.subgraph??[])}clone(){const t={};for(const n in this.captureList)t[n]=o(this.captureList[n]);const r=new te(t,this.returnType,this.subgraph?o(this.subgraph.child):this.subgraph,this.generator);return this.cloneInto(r),r}},E=class ee extends F{constructor(t,r,n,i,s,a=!1){super(),this.token=t,this._children=r,this.isInfix=n,this.isPropertyAccess=i,this.returnType=s,this.isTernary=a,this.shaderType="function-node"}get children(){return this._children}clone(){const t=new ee(this.token,this._children.map(o),this.isInfix,this.isPropertyAccess,this.returnType,this.isTernary);return this.cloneInto(t),t}};var G,at,ct,ut,ht,dt,pt,lt,ft,yt,mt,gt,bt,wt;function we(e){switch(e.type){case"bool":case"bvec2":case"bvec3":case"bvec4":return _;case"float":case"vec2":case"vec3":case"vec4":return p;case"int":case"ivec2":case"ivec3":case"ivec4":return y;case"uint":case"uvec2":case"uvec3":case"uvec4":return tt;default:throw new Error("Unable to handle type")}}function ve(e){const t=[["float","vec2","vec3","vec4"],["int","ivec2","ivec3","ivec4"],["uint","uvec2","uvec3","uvec4"],["bool","bvec2","bvec3","bvec4"]];for(const r of t)if(r.includes(e))return r.map(n=>Ie[n]);throw new Error("Unable to find type family")}function Dt(e){return new Proxy(e,{get(t,r){if(r==="constructor")return new Proxy(t.constructor,{construct:(n,i,s)=>Dt(new n(...i))});if(r in t)return t[r];if(typeof r=="string"){const n=ve(e.type);return I(e,r,n[r.length-1])}}})}function $(e){return new Proxy(e,{construct:(t,r,n)=>Dt(new t(...r))})}function xe(e){return new Proxy(e,{get(t,r){if(r in t)return t[r];if(typeof r=="string"){const n=parseInt(r,10);if(!isNaN(n))return I(e,`[${n}]`,e.elementType.constructor)}}})}function _e(e){return new Proxy(e,{construct:(t,r,n)=>xe(new t(...r))})}class vt extends Error{}let Z=class extends m{static{G=this}static{this.type="array"}constructor(e,t){super(),this.elementType=e,this.size=t,this.children=[],this.type="array"}clone(){const e=new G(this.elementType,this.size);return super.cloneInto(e),e}get(e,t){const r=new y(e),n=t!=null?new y(t):null;return n!=null?rt(this,r,n,we(this.elementType.constructor)):I(this,r,this.elementType.constructor)}last(){return this.get(this.size-1)}first(){return this.get(0)}findIndex(e,t,r){return ke(this,e,t,r)}glslFindIndex(e,t,r){return Ce(this,e,t,r)}static ofType(e,t){const r={construct:(n,i)=>new G(new e,t)};return new Proxy(G,r)}};Z=G=w([_e],Z);class ot extends m{static{this.type="array-2d"}constructor(t,r,n,i=!1){super(),this.elementType=t,this.xSize=r,this.ySize=n,this.isRowMajor=i,this.children=[],this.type="array-2d"}clone(){const t=new ot(this.elementType,this.xSize,this.ySize,this.isRowMajor);return super.cloneInto(t),t}get size(){return this.xSize*this.ySize}get(t,r){return this.isRowMajor?this._getRowMajor(t,r):this._getColumnMajor(t,r)}_getColumnMajor(t,r){const n=new y(t);return I(this,new y(r).add(n.multiply(this.xSize)),this.elementType.constructor)}_getRowMajor(t,r){const n=new y(t),i=new y(r);return I(this,n.add(i.multiply(this.ySize)),this.elementType.constructor)}static ofType(t,r,n,i=!1){return new Proxy(Z,{construct:(s,a)=>new ot(new t,r,n,i)})}}class Bt extends m{constructor(){super(...arguments),this.type="sampler2D",this.children=[]}static{this.type="sampler2D"}clone(){const t=new Bt;return t.children=this.children.map(o),super.cloneInto(t),t}}let p=class O extends m{static{this.type="float"}constructor(t){super(),this.type="float",this.children=[t]}clone(){const t=new O(o(this.children[0]));return super.cloneInto(t),t}multiply(t){return N(this,typeof t=="number"?g(t,O):t)}divide(t){return H(this,typeof t=="number"?g(t,O):t)}add(t){return K(this,typeof t=="number"?g(t,O):t)}subtract(t){return q(this,typeof t=="number"?g(t,O):t)}},U=class extends m{static{at=this}static{this.type="vec2"}constructor(e,t){super(),this.type="vec2",this.children=[e,t].filter(r=>r!=null)}clone(){const e=new at(o(this.children[0]),o(this.children[1]));return super.cloneInto(e),e}get 0(){return I(this,"[0]",p)}get 1(){return I(this,"[1]",p)}get 2(){throw new vt}get 3(){throw new vt}multiply(e){return N(this,typeof e=="number"?g(e,p):e)}divide(e){return H(this,typeof e=="number"?g(e,p):e)}add(e){return K(this,typeof e=="number"?g(e,p):e)}subtract(e){return q(this,typeof e=="number"?g(e,p):e)}};U=at=w([$],U);let R=class extends m{static{ct=this}static{this.type="vec3"}constructor(e,t,r){super(),this.type="vec3",this.children=[e,t,r].filter(n=>n!=null)}get 0(){return I(this,"[0]",p)}get 1(){return I(this,"[1]",p)}get 2(){return I(this,"[2]",p)}get 3(){throw new vt}clone(){const e=new ct(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(e),e}multiply(e){return N(this,typeof e=="number"?g(e,p):e)}divide(e){return H(this,typeof e=="number"?g(e,p):e)}add(e){return K(this,typeof e=="number"?g(e,p):e)}subtract(e){return q(this,typeof e=="number"?g(e,p):e)}};R=ct=w([$],R);let P=class extends m{static{ut=this}static{this.type="vec4"}constructor(e,t,r,n){super(),this.type="vec4",this.children=[e,t,r,n].filter(i=>i!=null)}clone(){const e=new ut(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(e),e}get 0(){return I(this,"[0]",p)}get 1(){return I(this,"[1]",p)}get 2(){return I(this,"[2]",p)}get 3(){return I(this,"[3]",p)}multiply(e){return N(this,typeof e=="number"?g(e,p):e)}divide(e){return H(this,typeof e=="number"?g(e,p):e)}add(e){return K(this,typeof e=="number"?g(e,p):e)}subtract(e){return q(this,typeof e=="number"?g(e,p):e)}};P=ut=w([$],P);let tt=class extends m{static{ht=this}static{this.type="uint"}constructor(e){super(),this.type="uint",this.children=[e]}clone(){const e=new ht(o(this.children[0]));return super.cloneInto(e),e}};tt=ht=w([$],tt);let xt=class extends m{static{dt=this}static{this.type="uvec2"}constructor(e,t){super(),this.type="uvec2",this.children=[e,t].filter(r=>r!=null)}clone(){const e=new dt(o(this.children[0]),o(this.children[1]));return super.cloneInto(e),e}};xt=dt=w([$],xt);let _t=class extends m{static{pt=this}static{this.type="uvec3"}constructor(e,t,r){super(),this.type="uvec3",this.children=[e,t,r].filter(n=>n!=null)}clone(){const e=new pt(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(e),e}};_t=pt=w([$],_t);let It=class extends m{static{lt=this}static{this.type="uvec4"}constructor(e,t,r,n){super(),this.type="uvec4",this.children=[e,t,r,n].filter(i=>i!=null)}clone(){const e=new lt(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(e),e}};It=lt=w([$],It);class _ extends m{static{this.type="bool"}constructor(t){super(),this.type="bool",this.children=[t]}and(t){return Ht(this,t)}or(t){return Gt(this,t)}xor(t){return Rt(this,t)}clone(){const t=new _(o(this.children[0]));return super.cloneInto(t),t}}let $t=class extends m{static{ft=this}static{this.type="bvec2"}constructor(e,t){super(),this.type="bvec2",this.children=[e,t].filter(r=>r!=null)}all(){return kt(this)}any(){return Ct(this)}clone(){const e=new ft(o(this.children[0]),o(this.children[1]));return super.cloneInto(e),e}};$t=ft=w([$],$t);let Nt=class extends m{static{yt=this}static{this.type="bvec3"}constructor(e,t,r){super(),this.type="bvec3",this.children=[e,t,r].filter(n=>n!=null)}all(){return kt(this)}any(){return Ct(this)}clone(){const e=new yt(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(e),e}};function g(e,t){return typeof e=="number"?new t(e):e}Nt=yt=w([$],Nt);let Tt=class extends m{static{mt=this}static{this.type="bvec4"}constructor(e,t,r,n){super(),this.type="bvec4",this.children=[e,t,r,n].filter(i=>i!=null)}all(){return kt(this)}any(){return Ct(this)}clone(){const e=new mt(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(e),e}};Tt=mt=w([$],Tt);class y extends m{static{this.type="int"}constructor(t){super(),this.type="int",this.children=[t]}multiply(t){return N(this,g(t,y))}add(t){return K(this,g(t,y))}subtract(t){return q(this,g(t,y))}divide(t){return H(this,g(t,y))}clone(){const t=new y(o(this.children[0]));return super.cloneInto(t),t}}let et=class extends m{static{gt=this}static{this.type="ivec2"}constructor(e,t){super(),this.type="ivec2",this.children=[e,t].filter(r=>r!=null)}clone(){const e=new gt(o(this.children[0]),o(this.children[1]));return super.cloneInto(e),e}};et=gt=w([$],et);let Mt=class extends m{static{bt=this}static{this.type="ivec3"}constructor(e,t,r){super(),this.type="ivec3",this.children=[e,t,r].filter(n=>n!=null)}clone(){const e=new bt(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(e),e}};Mt=bt=w([$],Mt);let St=class extends m{static{wt=this}static{this.type="ivec4"}constructor(e,t,r,n){super(),this.type="ivec4",this.children=[e,t,r,n].filter(i=>i!=null)}clone(){const e=new wt(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(e),e}};St=wt=w([$],St);class Vt extends m{static{this.type="mat2"}constructor(t,r,n,i){super(),this.type="mat2",this.children=[t,r,n,i]}clone(){const t=new Vt(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(t),t}get(t,r){return rt(this,new y(t),new y(r),p)}multiply(t){return N(this,t)}}class D extends m{static{this.type="mat3"}static identity(){return new D(1,0,0,0,1,0,0,0,1)}static fromRotation(t){const r=Xt(t),n=qt(t);return new D(n,r,0,zt(r),n,0,0,0,1)}constructor(t,r,n,i,s,a,u,c,h){super(),this.type="mat3",this.children=[t,r,n,i,s,a,u,c,h]}add(t){return K(this,t)}multiply(t){return N(this,t)}get(t,r){return rt(this,new y(t),new y(r),p)}clone(){const t=new D(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]),o(this.children[4]),o(this.children[5]),o(this.children[6]),o(this.children[7]),o(this.children[8]));return super.cloneInto(t),t}}class Q extends m{static{this.type="mat4"}static identity(){return new Q(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}constructor(t,r,n,i,s,a,u,c,h,d,l,v,S,T,k,C){super(),this.type="mat4",this.children=[t,r,n,i,s,a,u,c,h,d,l,v,S,T,k,C]}static fromColumns(t,r,n,i){return new Q(t.x,t.y,t.z,t.w,r.x,r.y,r.z,r.w,n.x,n.y,n.z,n.w,i.x,i.y,i.z,i.w)}multiply(t){return N(this,t)}get(t,r){return rt(this,new y(t),new y(r),p)}clone(){const t=new Q(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]),o(this.children[4]),o(this.children[5]),o(this.children[6]),o(this.children[7]),o(this.children[8]),o(this.children[9]),o(this.children[10]),o(this.children[11]),o(this.children[12]),o(this.children[13]),o(this.children[14]),o(this.children[15]));return super.cloneInto(t),t}}const Ie={float:p,vec2:U,vec3:R,vec4:P,int:y,ivec2:et,ivec3:Mt,ivec4:St,uint:tt,uvec2:xt,uvec3:_t,uvec4:It,bool:_,bvec2:$t,bvec3:Nt,bvec4:Tt},$e=(...e)=>new y(...e),jt=(...e)=>new p(...e),Ne=(...e)=>new U(...e),Te=(...e)=>new R(...e),Me=(...e)=>new P(...e),Se=(...e)=>new D(...e);function I(e,t,r){const n=new r(new Ut(t,e,r));return n.isImplicit=!0,n}function rt(e,t,r,n){const i=new n(new ge(t,r,e,n));return i.isImplicit=!0,i}function b(e,t,r,n=null){if(n){const s=new n,a=new n(new E(e,[t,r],!0,!1,s));return a.isImplicit=!0,a}if(t.type==="float"||t.type==="int"){const s=new r.constructor(new E(e,[t,r],!0,!1,r.constructor));return s.isImplicit=!0,s}if((t.type==="mat2"||t.type==="mat3"||t.type==="mat4")&&r.type!=="float"){const s=new r.constructor(new E(e,[t,r],!0,!1,r.constructor));return s.isImplicit=!0,s}const i=new t.constructor(new E(e,[t,r],!0,!1,t.constructor));return i.isImplicit=!0,i}function f(e,t,r=t.constructor){const n=new r(new E(e,[t],!1,!1,r));return n.isImplicit=!0,n}function M(e,t,r,n=t.constructor){const i=new n(new E(e,[t,r],!1,!1,n));return i.isImplicit=!0,i}function nt(e,t,r,n,i=t.constructor){const s=new i(new E(e,[t,r,n],!1,!1,i));return s.isImplicit=!0,s}function zt(e){return N(e,jt(-1))}function it(e,t,r,n){return new t(new be(e,t,r,n))}function ke(e,t,r=0,n=e.size){const i=new y(r).setMutable().setDebugName("FindIndexIterator"),s=t(e.get(i)).setDebugName("FindIndexPredicate");return it({iter:i},y,s,({out:a,iter:u,subgraph:c})=>`
${a} = -1;

for (; ${u} < ${n}; ${u}++) {

${c.body}

  if (${c.varName}) {
    ${a} = ${u};
    break;
  }

}
`).setDebugName("FindIndexBlock")}function Ce(e,t,r=0,n=e.size){return it({array:e},y,null,({out:i,array:s})=>`
${i} = -1;
for (int i = ${r}; i < ${n}; i++) {
  bool condition;
  ${t({array:s,i:"i",out:"condition"})}
  if (condition) {
    ${i} = i;
    break;
  }
}
`).setDebugName("GlslFindIndexBlock")}function Lt(e,t,r){const n=typeof t=="function"?t():t,i=typeof r=="function"?r():r,s=new n.constructor(new Kt(e,n,i));return s.isImplicit=!0,s}function Pe(...e){const t=e.map(([u,c])=>typeof c=="function"?[u,c()]:[u,c]),r=t[0][1].constructor,n=t.findIndex(u=>u[0]===!0);if(n===-1)throw new Error("A cond must have a fallthrough case with `true`/; ");const i=t.slice(0,n),s=t[n][1],a=new r(i.reduceRight((u,c)=>Lt(c[0],c[1],u),s));return a.isImplicit=!0,a}function N(e,t){return b("*",e,t)}function H(e,t){return b("/",e,t)}function K(e,t){return b("+",e,t)}function q(e,t){return b("-",e,t)}function Fe(e,t){return b("%",e,t)}function Ee(e,t){return b("<<",e,t)}function Ue(e,t){return b(">>",e,t)}function Ke(e,t){return b("&",e,t)}function Be(e,t){return b("|",e,t)}function Ve(e,t){return b("^",e,t)}function Ae(e){return f("~",e)}function Oe(e,t){return b("==",e,t,_)}function De(e,t){return b("!=",e,t,_)}function je(e,t){return b("<",e,t,_)}function ze(e,t){return b("<=",e,t,_)}function Le(e,t){return b(">",e,t,_)}function Ge(e,t){return b(">=",e,t,_)}function Gt(...e){return e.length<=1?e[0]:e.slice(1).reduce((t,r)=>Re(t,r),e[0])}function Re(e,t){return b("||",e,t,_)}function Rt(...e){return e.length<=1?e[0]:e.slice(1).reduce((t,r)=>He(t,r),e[0])}function He(e,t){return b("^^",e,t,_)}function Ht(...e){return e.length<=1?e[0]:e.slice(1).reduce((t,r)=>qe(t,r),e[0])}function qe(e,t){return b("&&",e,t,_)}function Xe(e){return f("abs",e)}function Ye(e){return f("acos",e)}function Je(e){return f("acosh",e)}function kt(e){return f("all",e,_)}function Ct(e){return f("any",e,_)}function Qe(e){return f("asin",e)}function We(e){return f("asinh",e)}function Ze(e,t){return t==null?f("atan",e):M("atan",e,t,e.constructor)}function tr(e){return f("atanh",e)}function er(e){return f("ceil",e)}function rr(e,t,r){return nt("clamp",e,t,r,e.constructor)}function qt(e){return f("cos",e)}function nr(e){return f("cosh",e)}function ir(e,t){return M("distance",e,t,p)}function sr(e,t){return M("dot",e,t,p)}function or(e){return f("exp",e)}function ar(e){return f("floor",e)}function cr(e){return f("fract",e)}function ur(e){return f("length",e,p)}function hr(e){return f("log",e)}function dr(e){return f("log2",e)}function pr(e,t){return M("max",e,t)}function lr(e,t){return M("min",e,t)}function fr(e,t,r){return nt("mix",e,t,r)}function yr(e,t){return M("mod",e,t)}function mr(e){return f("normalize",e)}function gr(e){return e.type==="bool"?f("!",e):f("not",e)}function br(e,t){return M("pow",e,t)}function wr(e){return f("round",e)}function vr(e){return f("sign",e)}function Xt(e){return f("sin",e)}function xr(e){return f("sinh",e)}function _r(e,t,r){return nt("smoothstep",e,t,r)}function Ir(e){return f("sqrt",e)}function $r(e,t){return M("step",e,t,t.constructor)}function Nr(e){return f("tan",e)}function Tr(e){return f("tanh",e)}function Mr(e,t,r){return nt("texelFetch",e,t,r,P)}function Sr(e,t){return M("texture",e,t,P)}function kr(e,t){const{initialValue:r,xRange:n,yRange:i,callback:s}=t,[a,u]=n,[c,h]=i,d=new y(0).setMutable().setDebugName("iterX"),l=new y(0).setMutable().setDebugName("iterY"),v=r.setMutable().setDebugName("accumulator"),S=s(v,e.get(d,l),d,l).setDebugName("callback");return it({iterX:d,iterY:l,accumulator:v},r.constructor,S,({out:T,iterX:k,iterY:C,accumulator:z,subgraph:L})=>`
for (${C} = ${c}; ${C} < ${h}; ${C}++) {
  for (${k} = ${a}; ${k} < ${u}; ${k}++) {

  ${L.body}

  ${z} = ${L.varName};
  }
}
${T} = ${z};
`).setDebugName("reduce2DBody")}const X=5;function x(e,t,r){const n=t.split(`
`);for(const i of n)if(i.trim().length){{let s="";r!=null&&(s+=`/*id:${r??"000"}*/   `),e.body+=s.padEnd(14)}e.body+=" ".repeat(e.indent)+i+`
`}}class Yt{write(t){for(const r of t.rootOutputNodes())t.shouldPruneOutputNode(r)||(r.variableName=this._write(t,r.node));return t}_createVarName(t,r){let n="";return typeof r!="boolean"&&typeof r!="number"&&r.debugInfo.name&&(n=`${r.debugInfo.name}_`),`${n}v${t.varCount++}`}_write(t,r,n=!1){if(typeof r=="number"||typeof r=="boolean")return r.toString();let i=t.getEmit(r);if(i)return i;switch(r.shaderType){case"scope-node":i=this._writeScopeNode(t,r);break;case"primitive-node":i=this._writePrimitiveNode(t,r,n);break;case"function-node":i=this._writeFunctionNode(t,r);break;case"property-access-node":i=this._writePropertyAccessNode(t,r);break;case"property-access-2d-node":i=this._writePropertyAccess2DNode(t,r);break;case"text-node":i=r.text;break;case"block-node":i=this._writeBlockNode(t,r);break;case"condition-node":i=this._writeConditionNode(t,r)}return t.setEmit(r,i),i}_writeScopeNode(t,r){const n=new r.child.constructor;n.setDebugName(r.debugInfo.name);const i=this._write(t,n,!0);return x(t,`{ /*ScopeStart: ${r.uid} ${r.debugInfo.name}*/`),t.indent+=2,x(t,`${i} = ${this._write(t,r.child)};`),t.indent-=2,x(t,`} /*ScopeEnd: ${r.uid} ${r.debugInfo.name}*/`),i}_writeConditionNode(t,r){const n=new r.ifTrue.constructor,i=this._write(t,n,!0);x(t,`if (${this._write(t,r.condition)}) {`),t.indent+=2;const s=t.createSubgraphContext(),a=this._write(s,r.ifTrue);if(t.body+=s.body,a&&x(t,`${i} = ${a};`),t.indent-=2,x(t,"}"),r.ifFalse){x(t,"else {"),t.indent+=2;const u=t.createSubgraphContext(),c=this._write(u,r.ifFalse);t.body+=u.body,c&&x(t,`${i} = ${c};`),t.indent-=2,x(t,"}")}return i}_writeBlockNode(t,r){const{captureList:n,generator:i,returnType:s}=r,a={};for(const d in n){if(!n[d])continue;const l=this._write(t,n[d]);a[d]=l}const u=new s,c=this._write(t,u,!0);if(a.out=c,r.subgraph){const d=t.createSubgraphContext(),l=this._write(d,r.subgraph.child),v=d.body;a.subgraph={varName:l,body:v}}const h=i(a);return x(t,`{
`),t.indent+=2,x(t,h),t.indent-=2,x(t,`}
`),c}_writePropertyAccessNode(t,r){const n=this._write(t,r.target);return typeof r.property=="string"&&r.property.includes("[")?`${n}${r.property}`:typeof r.property!="string"?`${n}[${this._write(t,r.property)}]`:`${n}.${r.property}`}_writePropertyAccess2DNode(t,r){return`${this._write(t,r.target)}[${this._write(t,r.x)}][${this._write(t,r.y)}]`}_writeFunctionNode(t,r){const n=r.returnType.type;if(r.isInfix){const[a,u]=r.children.map(h=>this._write(t,h)),c=this._createVarName(t,r);return x(t,`${n.padEnd(X)} ${c} = ${a} ${r.token} ${u};`,r.uid),c}const i=r.children.map(a=>this._write(t,a)).join(", "),s=this._createVarName(t,r);return x(t,`${n.padEnd(X)} ${s} = ${r.token}(${i});`,r.uid),s}_writePrimitiveNode(t,r,n=!1){const i=t.getInput(r);if(i)return i.isUsed=!0,i.variableName;const s=r.children.length===1&&r.children[0]?.type===r.type;if(!r.isMutable&&(r.isImplicit||s))return this._write(t,r.children[0]);const a=this._createVarName(t,r);if(n)return x(t,`${r.type.padEnd(X)} ${a};`,r.uid),a;const u=!r.debugInfo.name&&!r.isMutable;if(u&&r.type==="float"&&typeof r.children[0]=="number")return Number.isInteger(r.children[0])?r.children[0].toFixed(1):r.children[0].toString();if(u&&r.type==="int"&&typeof r.children[0]=="number"&&Number.isInteger(r.children[0]))return r.children[0].toString();const c=r.children.map(h=>this._write(t,h)).join(", ");return r.type==="array"?(x(t,`${r.type.padEnd(X)} ${a} = [${c}];`,r.uid),a):u?`${r.type}(${c})`:(x(t,`${r.type.padEnd(X)} ${a} = ${r.type}(${c});`,r.uid),a)}}let B=class re{constructor(t,r,n){this.variableName=t,this.variableInputType=r,this.node=n,this.type="shader-input",this.isUsed=!1}clone(){return new re(this.variableName,this.variableInputType,o(this.node))}},V=class ne{constructor(t,r,n){this.outVariableName=t,this.outVariableType=r,this.node=n,this.type="shader-output"}clone(){const t=new ne(this.outVariableName,this.outVariableType,o(this.node));return t.variableName=this.variableName,t}};class j{static createVertex(t,r,n,i,s,a){const u=[];for(const h in t){const d=t[h],l=n.get(h);l?u.push(new B(l,"builtin",d)):u.push(new B("a_"+h,"in",d))}for(const h of i){const d=h.uniformHydrated;u.push(new B(h.uniformName,"uniform",d))}const c=[];for(const h in r){const d=r[h];h==="glPosition"?c.push(new V("gl_Position","builtin",d)):h==="glPointSize"?c.push(new V("gl_PointSize","builtin",d)):c.push(new V("v_"+h,"out",d))}return new j(u,c,s,a)}static createFragment(t,r,n,i,s,a){const u=[],c=Array.from(s.rootOutputNodes());for(const d in t){const l=t[d],v=n.get(d);if(v){u.push(new B(v,"builtin",l));continue}const S=c.find(T=>T.node===l);S&&u.push(new B(S.outVariableName,"in",l))}for(const d of i){const l=d.uniformHydrated;u.push(new B(d.uniformName,"uniform",l))}const h=[];for(const d in r){const l=r[d],v=n.get(d);d==="discard"?h.push(new V(null,"discard",l)):v?h.push(new V(v,"builtin",l)):h.push(new V(d,"out",l))}return new j(u,h,a)}constructor(t,r,n,i){this.type="shader-graph-context",this.indent=0,this.body="",this.varCount=0,this._inputShaderTypesByNodeUid=new Map,this._nodeEmitMap=new Map;for(const s of t)this._inputShaderTypesByNodeUid.set(s.node.uid,s);this._outputShaderTypes=r,this._transformFeedbackBindings=n,this._transformFeedbackNames=new Set(n.map(s=>"v_"+s.propertyKey)),this._usedInFragmentShader=i}shouldPruneOutputNode(t){return!!this._usedInFragmentShader&&t.outVariableType!=="builtin"&&!this._transformFeedbackNames.has(t.outVariableName)&&!this._usedInFragmentShader.has(t.node.uid)}setEmit(t,r){this._nodeEmitMap.set(t.uid,r)}getEmit(t){return this._nodeEmitMap.get(t.uid)}inputs(){return this._inputShaderTypesByNodeUid.values()}getInput(t){return this._inputShaderTypesByNodeUid.get(t.uid)}*rootOutputNodes(){for(const t of this._outputShaderTypes)yield t}*nodes(){const t=[];for(const r of this._outputShaderTypes.values())t.push(r.node);for(;t.length;){const r=t.pop();typeof r!="number"&&typeof r!="boolean"&&t.push(...r.children.filter(Boolean)),yield r}}*nodesOfTypeOrFunction(){for(const t of this.nodes())typeof t!="number"&&typeof t!="boolean"&&(yield t)}createSubgraphContext(){const t=this.clone();return t.body="",t.indent=this.indent+2,t._nodeEmitMap=new Map(this._nodeEmitMap),t}clone(){const t=new j([],this._outputShaderTypes,this._transformFeedbackBindings,this._usedInFragmentShader);return t._inputShaderTypesByNodeUid=this._inputShaderTypesByNodeUid,t.indent=this.indent,t.body=this.body,t.varCount=this.varCount,t._nodeEmitMap=this._nodeEmitMap,t}insertVertexShader(t){t.vertex.code.add(""),this._insertInputs(t,"vertex"),t.vertex.code.add(""),t.vertex.code.add("// OUTPUTS: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const r of this.rootOutputNodes()){const n=r.outVariableType==="builtin";this.shouldPruneOutputNode(r)||(n?t.vertex.code.add(`// ${r.outVariableType.padEnd(7)} ${r.node.type.padEnd(9)} ${r.outVariableName};`):t.vertex.code.add(`${r.outVariableType.padEnd(10)} ${r.node.type.padEnd(9)} ${r.outVariableName};`))}t.vertex.code.add(""),t.vertex.code.add("void main() {"),t.vertex.code.add("  "+this.body.split(`
`).join(`
  `));for(const r of this.rootOutputNodes())this.shouldPruneOutputNode(r)||t.vertex.code.add(`  ${r.outVariableName} = ${r.variableName};`);t.vertex.code.add("}")}insertFragmentShader(t){this._insertInputs(t,"fragment"),t.fragment.code.add(""),t.fragment.code.add("// OUTPUTS: "),t.fragment.code.add("// --------------------------------------------------------- ");let r=0;for(const n of this.rootOutputNodes())n.outVariableType==="builtin"?t.fragment.code.add(`// ${n.outVariableType.padEnd(7)} ${n.node.type.padEnd(9)} ${n.outVariableName};`):t.outputs.add(n.outVariableName,n.node.type,r++);t.fragment.code.add(""),t.fragment.code.add("void main() {"),t.fragment.code.add("  "+this.body.split(`
`).join(`
  `));for(const n of this.rootOutputNodes())n.outVariableType==="discard"?(t.fragment.code.add("  // TODO: Should ensure codegen for discard appears first in fragment shader"),t.fragment.code.add(`  if (${n.variableName}) {`),t.fragment.code.add("    discard;"),t.fragment.code.add("  }"),t.fragment.code.add("  ")):t.fragment.code.add(`  ${n.outVariableName} = ${n.variableName};`);t.fragment.code.add("}")}_insertInputs(t,r){t[r].code.add("// INPUTS: "),t[r].code.add("// --------------------------------------------------------- ");for(const n of this.inputs())n.isUsed&&n.variableInputType!=="builtin"&&(n.node.type==="array"?t[r].code.add(`${n.variableInputType.padEnd(10)} ${n.node.elementType.type.padEnd(9)} ${n.variableName}[${n.node.size}];`):n.node.type==="array-2d"?t[r].code.add(`${n.variableInputType.padEnd(10)} ${n.node.elementType.type.padEnd(9)} ${n.variableName}[${n.node.size}]; // Emulated 2D Array. Not supported by ES3.0`):t[r].code.add(`${n.variableInputType.padEnd(10)} ${n.node.type.padEnd(9)} ${n.variableName};`))}}function Cr(e,t,r){const n=new ue(t.width,t.height);return n.dataType=t.dataType,t.depth&&(n.depth=t.depth),t.flipped&&(n.flipped=t.flipped),t.hasMipmap&&(n.hasMipmap=t.hasMipmap),n.internalFormat=t.internalFormat,t.isImmutable&&(n.isImmutable=t.isImmutable),t.isOpaque&&(n.isOpaque=t.isOpaque),t.maxAnisotropy&&(n.maxAnisotropy=t.maxAnisotropy),n.pixelFormat=t.pixelFormat,t.preMultiplyAlpha&&(n.preMultiplyAlpha=t.preMultiplyAlpha),t.samplingMode&&(n.samplingMode=t.samplingMode),t.target&&(n.target=t.target),n.uniform=t.uniform,t.unpackAlignment&&(n.unpackAlignment=t.unpackAlignment),t.wrapMode&&(n.wrapMode=t.wrapMode),new he(e,n,r)}const Pr=()=>Ot.getLogger("esri.views.2d.engine.webgl.shaderGraph.typed.TypedShaderProgram");function Y(e,t,r){const n=t.length;if(n!==r){const i=new ae("Invalid Uniform",`Invalid length, expected ${r} but got ${n}`,{uniformName:e,values:t});Pr().errorOnce(i)}}class Pt{constructor(t,r,n,i,s,a){this._program=null,this._vao=null,this._temporaryTextures=[],this.vertexShader=t,this.fragmentShader=r,this._locations=n,this._locationInfo=i,this._uniformBindings=s,this._transformFeedbackBindings=a}destroy(){this._program&&this._program.dispose(),this.cleanupTemporaryTextures()}get locations(){return this._locations}get locationInfo(){return this._locationInfo}setUniforms(t){this._uniforms=t}cleanupTemporaryTextures(){for(const t of this._temporaryTextures)t.dispose();this._temporaryTextures=[]}bind(t){const r=this._uniforms;if(!this._program){const i=new Map;for(const[a,u]of this._locations)i.set(a,u);const s=[];for(const a of this._transformFeedbackBindings??[]){const{index:u,propertyKey:c}=a;s[u]=`v_${c}`}this._program=new de(t,this.vertexShader,this.fragmentShader,i,new Map,s)}const n=this._program;t.useProgram(n);for(const i of this._uniformBindings){const{shaderModulePath:s,uniformName:a,uniformType:u,uniformArrayLength:c}=i,h=oe(s,r);if(h==null){if(u==="sampler2D")continue;throw new Error(`Failed to find uniform value for ${s}`)}switch(u==="array"||u==="array-2d"?i.uniformArrayElementType:u){case"sampler2D":{const{unit:d,texture:l}=h;if(n.setUniform1i(a,d),"type"in l)t.bindTexture(l,d);else{const v=Cr(t,l.descriptor,l.data);t.bindTexture(v,d)}break}case"int":if(!c){n.setUniform1i(a,h);break}Y(i.uniformName,h,c),n.setUniform1iv(a,h);break;case"float":if(!c){n.setUniform1f(a,h);break}Y(i.uniformName,h,c),n.setUniform1fv(a,h);break;case"vec2":if(!c){n.setUniform2f(a,h[0],h[1]);break}Y(i.uniformName,h,c),n.setUniform2fv(a,h.flat());break;case"vec3":if(!c){n.setUniform3f(a,h[0],h[1],h[2]);break}Y(i.uniformName,h,c),n.setUniform3fv(a,h.flat());break;case"vec4":if(!c){n.setUniform4f(a,h[0],h[1],h[2],h[3]);break}Y(i.uniformName,h,c),n.setUniform4fv(a,h.flat());break;case"mat3":n.setUniformMatrix3fv(a,h);break;case"mat4":n.setUniformMatrix4fv(a,h);break;default:throw new Error(`Unable to set uniform for type ${u}`)}}}}function J(e){return new e}function A(e,t,r){const n=e.constructor[t]??[];e.constructor.hasOwnProperty(t)||Object.defineProperty(e.constructor,t,{value:n.slice()}),e.constructor[t].push(r)}function Fr(e,t){return(r,n)=>{A(r,"locations",{typeCtor:t,propertyKey:n,parameterIndex:null,index:e})}}const Er=e=>(t,r)=>{A(t,"builtins",{builtin:e,propertyKey:r})},Ur=e=>(t,r,n)=>{A(t,"inputs",{inputCtor:e,propertyKey:r,parameterIndex:n})},Kr=e=>(t,r)=>{A(t,"uniforms",{typeCtor:e,propertyKey:r})},Br=e=>(t,r)=>{A(t,"options",{typeCtor:e,propertyKey:r})},Vr=(e,t)=>{A(e,"defines",{propertyKey:t})},Ft=(e,t)=>(r,n)=>{r.constructor.builtins.push({builtin:e,propertyKey:n,typeCtor:t})};class Jt{static{this.builtins=[]}}w([Ft("gl_VertexID",y)],Jt.prototype,"glVertexID",void 0);class Ar{}let st=class{static{this.builtins=[]}};w([Ft("gl_FragCoord",P)],st.prototype,"glFragCoord",void 0),w([Ft("gl_PointCoord",U)],st.prototype,"glPointCoord",void 0);class Qt{}w([Er("gl_FragDepth")],Qt.prototype,"glFragDepth",void 0);let Or=class{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}},Dr=class{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const e=this._shaderModuleClass.inputs.findLast(t=>t.propertyKey==="vertex"&&t.parameterIndex===0);if(!e)throw new Error("Unable to find vertex input parameter");return e}get computeInput(){return this._shaderModuleClass.inputs.findLast(e=>e.propertyKey==="vertex"&&e.parameterIndex===1)}get fragmentInput(){const e=this._shaderModuleClass.inputs.findLast(t=>t.propertyKey==="fragment");if(!e)throw new Error("Unable to find fragment input parameter");return e}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){return[...this.vertexInput.inputCtor.locations,...this.computeInput?.inputCtor.locations??[]]}get locationsMap(){const e=new Map,t=new Set;for(const r of this.locations)t.has(r.index)?Ot.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${r.propertyKey} to ${r.index}. Index already in use`,{locationsMap:e}):(e.set(r.propertyKey,r.index),t.add(r.index));return e}get locationInfo(){if(!this._locationInfo){const e=this.locationsMap,t=Array.from(e.entries()).map(([i,s])=>`${i}.${s}`).join("."),r=ce(t),n=this.computeAttributes;this._locationInfo={hash:r,stringHash:t,locations:e,computeAttributeMap:n}}return this._locationInfo}get renamedLocationsMap(){const e=new Map;for(const t of this.locations)e.set("a_"+t.propertyKey,t.index);return e}get optionPropertyKeys(){if(!this._optionPropertyKeys){const e=new Set;for(const t of this._options)e.add(t.propertyKey);this._optionPropertyKeys=e}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram(e,t,r,n){try{const{vertex:i,fragment:s,uniformBindings:a}=this._generateShaders(e,t,r,n);return new Pt(i,s,this.renamedLocationsMap,this.locationInfo,a,this.transformFeedbackBindings)}catch{return new Pt("","",this.renamedLocationsMap,this.locationInfo,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo(e){const t=this._options.find(n=>n.propertyKey===e);if(t)return{type:"option",className:t.typeCtor};const r=this._uniforms.find(n=>n.propertyKey===e);if(!r)throw new Error(`Unable to find uniform class type for property: ${e}`);return{type:"required",className:r.typeCtor}}getShaderKey(e,t,r,n){const i=Object.keys(e).map(c=>`${c}.${e[c]}`).join("."),s=Object.keys(r).map(c=>`${c}.${r[c]}`).join("."),a=Object.keys(n).map(c=>`${c}.${n[c]}`).join("."),u=Object.keys(t).filter(c=>this.optionPropertyKeys.has(c)&&t[c]).join(".");return`${this.type}.${i}.${s}.${a}.${u}`}_generateShaders(e,t,r,n){const i=[];this._setDefines(r),this._setOptionalUniforms(i,t),this._setRequiredUniforms(i);const s=this._hydrateVertexInput(n),a=this._injectPackPrecisionFactor(s,e),u=this._hydrateComputeInput(),c=u&&this._injectComputePackPrecisionFactor(u,e),h=this.vertex(a,c),d=this._hydrateFragmentInput(h),l=this.fragment(d),v=new Set;for(const ie in l){const se=l[ie];ye(v,se)}const S=this._getVertexInputBuiltins(),T=j.createVertex({...s,...u},h,S,i,this.transformFeedbackBindings,v);new Yt().write(T);const k=this._getFragmentInputBuiltins(l);k.set("glPointCoord","gl_PointCoord");const C=j.createFragment(d,l,k,i,T,this.transformFeedbackBindings);new Yt().write(C);const z=this._createShaderBuilder(T,C),L=z.generate("vertex"),At=z.generate("fragment");return this.logShader&&(console.log(L),console.log(At)),{vertex:L,fragment:At,uniformBindings:i}}_setDefines(e){for(const t in e)this[t]=e[t]}_setOptionalUniforms(e,t){for(const r of this._options)t[r.propertyKey]?this[r.propertyKey]=this._hydrateUniformGroup(e,r):this[r.propertyKey]=null}_setRequiredUniforms(e){for(const t of this._uniforms)this[t.propertyKey]=this._hydrateUniformGroup(e,t)}_hydrateUniformGroup(e,t){const r=new t.typeCtor;for(const n of r._uniforms??[]){const i=J(n.typeCtor),s=`u_${t.propertyKey}_${n.propertyKey}`,a=i.type,u=[t.propertyKey,n.propertyKey].join(".");if("type"in n.typeCtor&&n.typeCtor.type==="array"){const c=i;e.push({shaderModulePath:u,uniformName:s,uniformType:a,uniformArrayLength:c.size,uniformArrayElementType:c.elementType.type,uniformHydrated:i})}else if("type"in n.typeCtor&&n.typeCtor.type==="array-2d"){const c=i;e.push({shaderModulePath:u,uniformName:s,uniformType:a,uniformArrayLength:c.size,uniformArrayElementType:c.elementType.type,uniformHydrated:i})}else e.push({shaderModulePath:u,uniformName:s,uniformType:a,uniformHydrated:i});r[n.propertyKey]=i}return r}_hydrateVertexInput(e){const t=this.vertexInput.inputCtor,r=t.locations.reduce((n,i)=>e[i.propertyKey]===!1?n:{...n,[i.propertyKey]:J(i.typeCtor)},{});for(const{propertyKey:n,typeCtor:i}of t.builtins){const s=J(i);r[n]=s}return r}_hydrateComputeInput(){return this.computeInput==null?null:this.computeInput.inputCtor.locations.reduce((e,t)=>({...e,[t.propertyKey]:J(t.typeCtor)}),{})}_injectPackPrecisionFactor(e,t){const r={};for(const n in e){const i=e[n],s=t[n];if(s){if(i.type!=="float"&&i.type!=="vec2"&&i.type!=="vec3"&&i.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${i.type}`);r[n]=i.divide(new p(s))}else r[n]=i}return r}_injectComputePackPrecisionFactor(e,t){const r={},n=new Map;for(const i in this.computeAttributes)for(const s of this.computeAttributes[i]??[])n.set(s,i);for(const i in e){const s=e[i],a=n.get(i);if(!a)continue;const u=t[a];if(u){if(s.type!=="float"&&s.type!=="vec2"&&s.type!=="vec3"&&s.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${s.type}`);r[i]=s.divide(new p(u))}else r[i]=s}return r}_hydrateFragmentInput(e){const t={};for(const r in e)t[r]=e[r];for(const{propertyKey:r,typeCtor:n}of st.builtins){const i=J(n);t[r]=i}return t}_getVertexInputBuiltins(){const e=this.vertexInput.inputCtor,t=new Map;for(const{builtin:r,propertyKey:n}of e.builtins)t.set(n,r);return t}_getFragmentInputBuiltins(e){const t=e.constructor,r=new Map;for(const n of t.builtins??[])r.set(n.propertyKey,n.builtin);return r}_createShaderBuilder(e,t){const r=new pe;return this._insertDebugInfo(r),e.insertVertexShader(r),t.insertFragmentShader(r),r}_insertDebugInfo(e){e.vertex.code.add("// DEFINES: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this._defines)this[t.propertyKey]?e.vertex.code.add(`//   ${t.propertyKey}: true`):e.vertex.code.add(`//   ${t.propertyKey}: false`);e.vertex.code.add(""),e.vertex.code.add("// OPTIONS: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this._options)this[t.propertyKey]?e.vertex.code.add(`//   ${t.propertyKey}: true`):e.vertex.code.add(`//   ${t.propertyKey}: false`)}};export{Br as $,Ir as A,ze as B,pr as C,je as D,Ze as E,qt as F,Le as G,_r as H,y as I,wr as J,Vr as K,N as L,Mr as M,_ as N,$e as O,Or as P,Xe as Q,ur as R,Fe as S,cr as T,Bt as U,vr as V,br as W,R as X,fr as Y,et as Z,p as _,yr as a,Z as a0,zt as a1,De as a2,Ge as a3,Rt as a4,Gt as a5,Ht as a6,Ve as a7,Ae as a8,Ue as a9,Pt as aA,Ee as aa,Be as ab,Ke as ac,Tr as ad,Nr as ae,xr as af,nr as ag,tr as ah,We as ai,Qe as aj,Je as ak,Ye as al,er as am,or as an,dr as ao,hr as ap,kr as aq,ot as ar,it as as,Ar as at,Q as au,Vt as av,ir as aw,gr as ax,mr as ay,Se as az,Oe as b,U as c,Sr as d,P as e,Fr as f,Kr as g,Te as h,Jt as i,Dr as j,Lt as k,Me as l,Ur as m,rr as n,Ne as o,lr as p,$r as q,D as r,Xt as s,le as t,jt as u,st as v,Qt as w,Pe as x,sr as y,ar as z};
