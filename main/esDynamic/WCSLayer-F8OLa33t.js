import{s as k,bY as q,am as Se,a0 as ne,R as de,i as ie,v as D,x as T,z as me,bn as De,c4 as Te,q as Le,ab as Ae,by as Re}from"./main-CnDVnExo.js";import{S as Pe}from"./MultiOriginJSONSupport-Ruo0_g0o.js";import{h as Ee}from"./Layer-CmkLQVqW.js";import{p as Oe}from"./BlendLayer-BDk2CQB5.js";import{e as $e}from"./CustomParametersMixin-DgLbjG-n.js";import{e as w,t as y,l as $,n as P,r as S,i as E,c as fe,$ as Me,X as Ne}from"./xmlUtilities-85HZ262C.js";import{b as Ve,d as ke,l as Fe}from"./OperationalLayer-A4hDIwth.js";import{j as Ge}from"./PortalLayer-BPuUTCDW.js";import{d as _e}from"./RasterJobHandlerMixin-CdwgnjLX.js";import{f as Be}from"./RefreshableLayer-D50o-qLz.js";import{t as je}from"./ScaleRangeLayer-C11AuBvk.js";import{c as qe}from"./TemporalLayer-CJyRpOty.js";import{m as he}from"./Field-aY1vu-yl.js";import{w as se,D as We,p as Ue,o as He,b as ze}from"./datasetUtils-TW-hion6.js";import{o as ge}from"./crsUtils-BLe27KvG.js";import{m as oe,P as Ye}from"./RasterSymbolizer-__W937xp.js";import{W as Ke}from"./dataUtils-jj_Ulcwm.js";import{p as Xe}from"./popupUtils-DOiXoTRP.js";import{A as J}from"./interfaces-Cwm0pihk.js";function Z(e){return e.endsWith("?")?e.slice(0,-1):e}function ae(e){return e.filter(({coverageSubType:t})=>t==null||t===""||/^rectified(grid|dataset)/i.test(t))}function Ze(e){const t=y(e,"Service/name"),n=w(e,"Capability"),o=w(n,"GetCapabilities/Get/OnlineResource")?.getAttribute("xlink:href")??"",i=w(n,"DescribeCoverage/Get/OnlineResource")?.getAttribute("xlink:href")??"",a=w(n,"GetCoverage/Get/OnlineResource")?.getAttribute("xlink:href")??"",s={getCapabilities:Z(o),describeCoverage:Z(i),getCoverage:Z(a)},r=P(e,"CoverageOfferingBrief"),p=[];for(let l=0;l<r.length;l++){const u=r[l],m=y(u,"name"),c=P(u,"pos"),f=S(c[0]),d=S(c[1]),h=new q({xmin:f[0],ymin:f[1],xmax:d[0],ymax:d[1],spatialReference:{wkid:4326}});p.push({id:m,lonLatEnvelope:h})}return{name:t,onlineResources:s,coverages:p,gridCoverages:ae(p),supportedVersions:["1.0.0"],version:"1.0.0"}}function ve(e){const t={};for(let n=0;n<e.childNodes.length;n++){const o=e.childNodes[n];if(o.nodeType!==1)continue;const i=fe(o).toLowerCase();switch(i){case"title":case"abstract":t[i]=y(o);break;case"identifier":t.id=y(o);break;case"wgs84boundingbox":{const a=S(o,"LowerCorner"),s=S(o,"UpperCorner");t.lonLatEnvelope=new q({xmin:a[0],ymin:a[1],xmax:s[0],ymax:s[1],spatialReference:{wkid:4326}})}break;case"coveragesummary":t.coverageSummaries=t.coverageSummaries||[],t.coverageSummaries.push(ve(o))}}return t}function ye(e,t){if(e.coverageSummaries)for(let n=0;n<e.coverageSummaries.length;n++)e.coverageSummaries[n].abstract=e.coverageSummaries[n].abstract||e.abstract,e.coverageSummaries[n].lonLatEnvelope=e.coverageSummaries[n].lonLatEnvelope||e.lonLatEnvelope,e.coverageSummaries[n].title=e.coverageSummaries[n].title||e.title,ye(e.coverageSummaries[n],t);e.id!=null&&t.push(e)}function be(e){const t=w(e.querySelector("Operation[name=GetCapabilities]"),"Get")?.getAttribute("xlink:href")||"",n=w(e.querySelector("Operation[name=DescribeCoverage]"),"Get")?.getAttribute("xlink:href")||"",o=w(e.querySelector("Operation[name=GetCoverage]"),"Get")?.getAttribute("xlink:href")||"";return{getCapabilities:Z(t),describeCoverage:Z(n),getCoverage:Z(o)}}function Je(e){const t=y(e,"ServiceIdentification/Title"),n=$(e,"ServiceIdentification/ServiceTypeVersion"),o=be(w(e,"OperationsMetadata")),i=[],a=w(e,"Contents");for(let r=0;r<a.childNodes.length;r++){const p=a.childNodes[r];p.nodeType===1&&E(p,"CoverageSummary")&&ye(ve(p),i)}const s=$(a,"SupportedFormat");return{name:t,onlineResources:o,coverages:i,gridCoverages:ae(i),supportedVersions:n,supportedFormats:s,version:"1.1.0"}}function Qe(e){const t=w(e,"ServiceIdentification"),n=y(t,"Title"),o=$(t,"ServiceTypeVersion"),i=$(t,"Profile"),a=be(w(e,"OperationsMetadata")),s=P(e,"Contents/CoverageSummary"),r=[];for(let l=0;l<s.length;l++){const u=s[l],m=y(u,"CoverageId"),c=w(u,"WGS84BoundingBox");let f;if(c){const h=S(c,"LowerCorner"),g=S(c,"UpperCorner");f=new q({xmin:h[0],ymin:h[1],xmax:g[0],ymax:g[1],spatialReference:{wkid:4326}})}const d=y(u,"CoverageSubtype")||"RectifiedGridCoverage";r.push({id:m,lonLatEnvelope:f,coverageSubType:d})}const p=w(e,"ServiceMetadata");return{name:n,supportedVersions:o,supportedFormats:$(p,"formatSupported"),supportedInterpolations:$(p,"interpolationSupported").concat($(p,"InterpolationSupported")),onlineResources:a,profiles:i,coverages:r,gridCoverages:ae(r),version:"2.0.1"}}function et(e){let t=null;typeof e=="string"?t=new DOMParser().parseFromString(e,"text/xml"):t=e;const n=t.documentElement.getAttribute("version"),o=n?.slice(0,3);return o!=null&&o<"2.1"}function tt(e,t=null){let n=null;typeof e=="string"?n=new DOMParser().parseFromString(e,"text/xml"):n=e;let o=n.documentElement.getAttribute("version");o==="1.0"?o="1.0.0":o==="1.1"&&(o="1.1.0");const i=o||t||"1.0.0",a=i.slice(0,3);let s;if(a==="2.0")s=Qe(n);else if(a==="1.1")s=Je(n);else{if(a!=="1.0")throw new k("wcsraster:parsecapabilities","the capabilities version is not supported");s=Ze(n)}return s.version=i,s}function re(e){e.variables.forEach(t=>t.dimensions.forEach(n=>n.values??=We(n)))}function nt(e){return{requestResponseCRSs:$(e,"requestResponseCRSs").map(t=>t.split(":")[1]),nativeCRSs:$(e,"nativeCRSs").map(t=>t.split(":")[1])}}function we(e,t){const n=$(e,t==="1.0.0"?"interpolationMethod":"InterpolationMethod"),o=t==="1.0.0"?e.getAttribute("default"):y(e,"InterpolationMethods/Default");return o!=null?[o].concat(n.filter(i=>i.toLowerCase()!==o.toLowerCase())):n}function le(e){return e==null?["nearest"]:e.map(t=>{const n=t.toLowerCase();return n.includes("nearest")?"nearest":n.includes("linear")?"bilinear":n.includes("cubic")?"cubic":null}).filter(t=>!!t)}function it(e){const t=P(e,"pos"),n=S(t[0]),o=S(t[1]);return new q({xmin:n[0],ymin:n[1],xmax:o[0],ymax:o[1],spatialReference:{wkid:4326}})}function ce(e,t){const n=$(e,t);return n?.length&&n[0]!==""&&!isNaN(Number(n[0]))?n.map(o=>Number(o)):null}function st(e){const t=S(e,"MinimumValue"),n=S(e,"MaximumValue");return t.length&&n.length?t.map((o,i)=>({min:o,max:n[i],avg:-1,stddev:-1})):null}function ue(e){return e==null?null:e.every(t=>t===e[0])?e[0]:e}function ot(e){const t=[],n=P(e,"RangeSet");let o=[];for(let i=0;i<n.length;i++){const a=y(n[i],"name"),s=y(n[i],"label"),r=[],p=ce(n[i],"nullValues/singleValue"),l=P(n[i],"AxisDescription");for(let u=0;u<l.length;u++){const m=y(l[u],"name"),c=y(l[u],"label"),f=$(l[u],"singleValue");if(f.length===0){const d=y(l[u],"min"),h=y(l[u],"max"),g=Number(y(l[u],"res"))||1;if(d!==null&&h!==null)for(let v=parseInt(d,10);v<=parseInt(h,10);v+=g)f.push(v.toString())}m.toLowerCase()==="band"&&(o=f),r.push({name:m,label:c,values:f})}t.push({name:a,label:s,nullValues:p,axis:r})}return{rangeSet:t,bandNames:o}}function at(e=null){if(!e)return{resolution:null,units:null};let t=e.toUpperCase();const n=["Y","M","D"],o=["H","M","S"],i=["Years","Months","Days","Hours","Minutes","Seconds"];let a,s,r;return t.includes("PT")?(t=t.slice(2),r=o.findIndex(p=>t.includes(p)),a=i[3+r],s=parseFloat(t.slice(0,-1))):(t=t.slice(1),r=n.findIndex(p=>t.includes(p)),r>-1&&(a=i[r]),s=parseFloat(t.slice(0,-1))),{resolution:s,units:a}}function Q(e){const t=P(e,"timeposition");if(t.length>0){const o=[];for(let i=0;i<t.length;i++)o.push(new Date(y(t[i])));return{begin:o[0],end:o[o.length-1],values:o}}const n=w(e,"timePeriod")||w(e,"TimePeriod");return n?{begin:new Date(y(n,"beginPosition")||y(n,"BeginPosition")),end:new Date(y(n,"endPosition")||y(n,"EndPosition")),...at(y(n,"timeResolution")||y(n,"TimeResolution"))}:null}function rt(e){const t=w(e,"spatialDomain"),n=w(t,"Envelope")||w(t,"EnvelopeWithTimePeriod"),o=n.getAttribute("srsName").split(":"),i=o[o.length-1],a=P(n,"pos"),s=S(a[0]),r=S(a[1]),p=parseInt(i,10),l=isNaN(p)?null:{wkid:p},u=new q({xmin:s[0],ymin:s[1],xmax:r[0],ymax:r[1],spatialReference:l}),m=w(t,"RectifiedGrid"),c=y(m,"low").split(" "),f=y(m,"high").split(" "),d=parseInt(f[0],10)-parseInt(c[0],10)+1,h=parseInt(f[1],10)-parseInt(c[1],10)+1,g=S(t,"origin/pos"),v=P(t,"offsetVector"),b={envelope:u,columns:d,rows:h,offset:{x:parseFloat(y(v[0]).split(" ")[0]),y:parseFloat(y(v[1]).split(" ")[1])},origin:{x:g[0],y:g[1]}},x=w(e,"temporalDomain")||w(e,"TemporalDomain");return{spatialDomain:b,temporalDomain:x?Q(x):null}}function lt(e){const t={version:"1.0"};let n,o=[];for(let d=0;d<e.childNodes.length;d++){const h=e.childNodes[d];if(h.nodeType===1)if(E(h,"description"))t.description=y(h);else if(E(h,"name"))t.name=y(h);else if(E(h,"label"))t.label=y(h);else if(E(h,"supportedFormats"))t.supportedFormats=$(h,"formats");else if(E(h,"supportedCRSs"))t.supportedCRSs=nt(h);else if(E(h,"supportedInterpolations"))t.supportedInterpolations=we(h,"1.0.0");else if(E(h,"lonLatEnvelope"))t.lonLatEnvelope=it(h);else if(E(h,"rangeSet")){const g=ot(h);t.rangeSet=g.rangeSet,o=g.bandNames;const v=g.rangeSet[0].nullValues;v?.length&&(n=ue(v))}else E(h,"domainSet")&&(t.domainSet=rt(h))}const i=le(t.supportedInterpolations),{name:a,description:s,label:r,lonLatEnvelope:p,supportedFormats:l}=t,{spatialDomain:u}=t.domainSet,m={x:Math.abs(u.offset.x),y:Math.abs(u.offset.y)},c=ct(t.domainSet),f=new oe({width:u.columns,height:u.rows,pixelSize:m,pixelType:"unknown",extent:u.envelope,spatialReference:u.envelope.spatialReference,bandCount:o.length||1,noDataValue:n,multidimensionalInfo:c});return{id:a,title:t.name,description:s||r,lonLatEnvelope:p,rasterInfo:f,bandNames:o,supportedFormats:l,supportedInterpolations:i,coverageDescription:t,version:"1.0.0",useEPSGAxis:!1}}function ct(e){if(!e.temporalDomain)return null;const{begin:t,end:n,values:o,units:i,resolution:a}=e.temporalDomain,s={variables:[{name:"default",description:"",dimensions:[{name:"StdTime",description:"",unit:"ISO8601",values:o?.map(r=>r.getTime()),hasRegularIntervals:!o,interval:a,intervalUnit:i,extent:[t.getTime(),n.getTime()]}]}]};return re(s),s}function ut(e,t){const n=[],o=P(e,"Field");let i,a=[];for(let s=0;s<o.length;s++){const r=y(o[s],"Identifier"),p=y(o[s],"Description"),l=y(o[s],"Definition"),u=y(o[s],"Abstract"),m=y(o[s],"Title"),c=ce(o[s],"NullValue"),f=w(o[s],"AllowedValues"),d=f?st(f):null,h=we(o[s],"1.1.0"),g=[],v=P(o[s],"Axis");for(let b=0;b<v.length;b++){const x=v[b].getAttribute("identifier"),I=y(v[b],"UOM"),A=y(v[b],"DataType"),W=$(v[b],"Key");t&&!x.toLowerCase().includes("band")||(a=W,i=c),g.push({identifier:x,uom:I,dataType:A,values:W,bandNoDataValues:i})}n.push({identifier:r,description:p,definition:l,abstract:u,title:m,supportedInterpolations:h,axis:g,nullValues:c,statistics:d})}return{rangeSet:n,bandNames:a,bandNoDataValues:i,statistics:n[0].statistics}}function pt(e,t){if(!t.temporalDomain)return null;const n=e.filter(i=>!i.identifier.toLowerCase().includes("field_1")&&!i.axis.some(a=>a.identifier.includes("band"))),o=[];if(n.length&&n.forEach(i=>{const a=i.axis.map(s=>{const r=s.values.map(l=>s.uom==="ISO8601"?(l=l.trim()).toLowerCase().includes("z")?new Date(l).getTime():new Date(l+"Z").getTime():parseFloat(l.trim())),p=[Math.min.apply(null,r),Math.max.apply(null,r)];return{name:s.identifier.trim(),description:"",field:s.identifier.trim(),unit:s.uom?s.uom.trim():"",hasRegularIntervals:!1,values:r,extent:p}});o.push({name:i.identifier.trim(),description:i.description?.trim()??"",unit:"",dimensions:a,statistics:i.statistics})}),t.temporalDomain){const{begin:i,end:a,values:s,units:r,resolution:p}=t.temporalDomain;o.some(l=>l.dimensions.some(u=>u.name.toLowerCase()==="stdtime"))||o.forEach(l=>{l.dimensions.push({name:"StdTime",description:"",unit:"ISO8601",values:s?.map(u=>u.getTime()),hasRegularIntervals:!s,interval:p,intervalUnit:r,extent:[i.getTime(),a.getTime()]})})}if(o.length){const i={variables:o};return re(i),i}return null}function dt(e){const t=w(e,"SpatialDomain"),n=w(t,"GridCRS"),o=y(n,"GridBaseCRS"),i=y(n,"GridOrigin"),a=i?.split(" ").map(v=>parseFloat(v))??[0,0],s=S(n,"GridOffsets"),r=P(t,"BoundingBox");let p,l,u,m;for(let v=0;v<r.length;v++){const b=r[v].getAttribute("crs")?.toLowerCase();if(b!=null){if(b.includes("imagecrs")){const x=S(r[v],"LowerCorner"),I=S(r[v],"UpperCorner");p=I[0]-x[0]+1,l=I[1]-x[1]+1}else if(b.indexOf("epsg")>0){const x=b.split(":");u=parseInt(x[x.length-1],10);const I=S(r[v],"LowerCorner"),A=S(r[v],"UpperCorner");m=new q({xmin:I[0],ymin:I[1],xmax:A[0],ymax:A[1],spatialReference:{wkid:u}})}}}const c=p>l,f=m.xmax-m.xmin>m.ymax-m.ymin;let d=!1;ge(u)&&(c===f?d=!1:(d=!0,m=new q({xmin:m.ymin,ymin:m.xmin,xmax:m.ymax,ymax:m.xmax,spatialReference:{wkid:u}})));const h={columns:p,rows:l,origin:{x:a[0],y:a[1]},offset:{x:s[0],y:s[s.length-1]},gridBaseCRS:o,envelope:m,useEPSGAxis:d},g=w(e,"temporalDomain")||w(e,"TemporalDomain");return{spatialDomain:h,temporalDomain:g?Q(g):null}}function mt(e,t){const n=[],o=[],i={supportedFormats:n,supportedCRSs:o,version:"1.1"};let a,s,r=[];for(let v=0;v<e.childNodes.length;v++){const b=e.childNodes[v];if(b.nodeType!==1)continue;const x=fe(b).toLowerCase();switch(x){case"title":case"abstract":case"identifier":i[x]=y(b);break;case"supportedformat":{const I=y(b);n.includes(I)||n.push(I)}break;case"supportedcrs":{const I=y(b);o.includes(I)||o.push(I)}break;case"range":{const I=ut(b,!!i.domain?.temporalDomain);i.range=I.rangeSet,r=I.bandNames;const{bandNoDataValues:A}=I;A?.length&&(a=ue(A)),s=I.statistics}break;case"domain":i.domain=dt(b)}}const p=le(i.range[0].supportedInterpolations),{identifier:l,abstract:u,title:m,domain:c,range:f}=i,d={x:Math.abs(c.spatialDomain.offset.x),y:Math.abs(c.spatialDomain.offset.y)},h=pt(f,c);h&&(a=f[0].nullValues,a?.length===1&&(a=a[0]));const g=new oe({width:c.spatialDomain.columns,height:c.spatialDomain.rows,pixelSize:d,pixelType:"unknown",extent:c.spatialDomain.envelope,spatialReference:c.spatialDomain.envelope.spatialReference,bandCount:r.length||1,noDataValue:a,statistics:s,multidimensionalInfo:h});return{id:l,title:i.title,description:u||m,bandNames:r,rasterInfo:g,supportedFormats:n,supportedInterpolations:p,coverageDescription:i,version:t,useEPSGAxis:c.spatialDomain.useEPSGAxis}}function ft(e){const t=w(e,"Envelope")||w(e,"EnvelopeWithTimePeriod"),n=t.getAttribute("srsName"),o=n.slice(n.lastIndexOf("/")+1),i=t.getAttribute("axisLabels").split(" ").map(h=>h.trim()).filter(h=>h.trim()!==""),a=S(t,"lowerCorner"),s=S(t,"upperCorner"),r=!["y","lat","latitude","north","nor","n","b"].includes(i[0].toLowerCase());let p;const l=parseInt(o,10),u=isNaN(l)?null:{wkid:l};p=new q(r?{xmin:a[0],ymin:a[1],xmax:s[0],ymax:s[1],spatialReference:u}:{xmin:a[1],ymin:a[0],xmax:s[1],ymax:s[0],spatialReference:u});const m={mins:a,maxs:s},c=t.getAttribute("uomLabels").trim().split(" ");let f,d;if(E(t,"EnvelopeWithTimePeriod")){f=new Date(y(e,"beginPosition")||y(e,"BeginPosition")),d=new Date(y(e,"endPosition")||y(e,"EndPosition"));const h=c?.findIndex(g=>g?.toLowerCase()==="oledatetime");h>-1&&(c[h]="ISO8601")}return{envelope:p,axisLabels:i,uomLabels:c.length?c:null,envelopeAllDims:m,beginPosition:f,endPosition:d,isEastFirst:r}}function ht(e,t){const n=[],o=P(e,"DataRecord"),i=[];let a,s=[];for(let r=0;r<o.length;r++){const p=P(o[r],"field"),l=[];for(let u=0;u<p.length;u++){const m=p[u].getAttribute("name"),c=y(p[u],"description")||"",f=w(p[u],"uom")?.getAttribute("code")||"",d=S(p[u],"interval"),h=ce(p[u],"nilValue")?.[0];t&&!m.toLowerCase().includes("band")||(i.push(m),d?.length&&(a=a||[],a.push({min:d[0],max:d[1],avg:-1,stddev:-1})),s.push(h)),l.push({name:m,description:c,uom:f,allowedValues:d,nilValue:h})}n.push(l)}return s.some(r=>r!=null)||(s=null),{rangeType:n,bandNames:i,bandStats:a,bandNoDataValues:s}}function gt(e){let t=1,n="";const o=.01;return Math.abs(e-1/24)<1/24*o?n="Hours":Math.abs(e-1)<1*o?n="Days":e<1?(t=Math.round(24*e),n="Hours"):e>28-o&&e<31+o||Math.round(e/30)<12?n="Months":e>365-o&&e<366+o&&(n="Years"),{interval:t,intervalUnit:n}}function vt(e,t,n){if(n.axisLabels.length<=2)return null;const o=[];for(let a=0;a<e.length;a++){const s=e[a];for(let r=0;r<s.length;r++)s[r].name.toLowerCase().includes("band")||o.push(s[r])}const i=[];if(o.length){const a=[];for(let s=2;s<n.axisLabels.length;s++){const r=t.uomLabels?.[s]?.trim()??"",p=n.axisLabels[s].toLowerCase().includes("time")||r.toLowerCase()==="iso8601"||r.toLowerCase()==="oledatetime";let l,u;if(p){const c=gt(n.offset[s]);l=c.interval,u=c.intervalUnit}else l=n.offset[s],u=r;const m=[];p?(m.push(se(t.envelopeAllDims.mins[s])),m.push(se(t.envelopeAllDims.maxs[s]))):(m.push(t.envelopeAllDims.mins[s]),m.push(t.envelopeAllDims.maxs[s])),a.push({name:n.axisLabels[s].trim(),description:n.axisLabels[s].trim(),unit:p?"ISO8601":r,hasRegularIntervals:!0,extent:m,interval:l,intervalUnit:u})}if(o.forEach(s=>{const{allowedValues:r}=s,p=r?.length===2?[{min:r[0],max:r[1],avg:-1,stddev:-1}]:null;i.push({name:s.name.trim(),description:s.description?.trim()??"",unit:s.uom.trim(),statistics:p,dimensions:[...a]})}),i.length){const s={variables:i};return re(s),s}}return null}function yt(e,t){const n=w(e,"RectifiedGrid"),o=S(n,"low"),i=S(n,"high"),a=[];for(let g=0;g<o.length;g++)a.push(i[g]-o[g]+1);const s=y(n,"axisLabels").split(" "),r=S(n,"origin/pos"),p=P(n,"offsetVector"),l=[];for(let g=0;g<p.length;g++){const v=S(p[g]),b=v.findIndex(x=>x!==0);l[b]=v[b]}const u=["y","lat","latitude","north","nor","n","b"];let m=!1;t?.length&&s?.length&&(m=[...t].sort((g,v)=>g<v?-1:1).join(",")===[...s].sort((g,v)=>g<v?-1:1).join(","));const c=m?s:t;let f,d,h;return u.includes(c[0].toLowerCase())?(f=a[1],d=a[0],h={y:Math.abs(l[0]),x:Math.abs(l[1])}):(f=a[0],d=a[1],h={x:Math.abs(l[0]),y:Math.abs(l[1])}),{columns:f,rows:d,origin:r,offset:l,resolution:h,gridSamples:a,axisLabels:s,hasSameAxisLabelsAsBoundedBy:m}}function bt(e){const t=w(e,"EarthObservation");if(!t)return null;const n=w(t,"phenomenonTime"),o=n?Q(n):null,i=w(t,"phenomenonTime"),a=i?Q(i):null,s=y(t,"featureOfInterest/Footprint/multiExtentOf/MultiSurface/surfaceMembers/Polygon/exterior/LinearRing/posList");let r=null;if(s){const p=s.split(" ").map(l=>l.trim()).filter(l=>l!=null&&l!=="").map(Number);if(p.length){const l=[];for(let u=0;u<p.length/2;u+=2)l.push(p[u],p[u+1]);r=new Se({rings:[[l]]})}}return{observation:{phenomenonTime:o,resultTime:a,footprint:r,identifier:y(e,"metaDataProperty/EarthObservationMetaData/identifier"),acquisitionType:y(e,"metaDataProperty/EarthObservationMetaData/acquisitionType"),status:y(e,"metaDataProperty/EarthObservationMetaData/status")}}}function wt(e){const t={version:"2.0"};let n,o,i=[];for(let m=0;m<e.childNodes.length;m++){const c=e.childNodes[m];if(c.nodeType===1){if(E(c,"coverageId"))t.coverageId=y(c);else if(E(c,"ServiceParameters"))t.serviceParameters={supportedFormats:$(c,"nativeFormat")};else if(E(c,"boundedBy"))t.boundedBy=ft(c);else if(E(c,"rangeType")){const f=ht(c,t.boundedBy?.axisLabels.length>2||t.domainSet?.axisLabels.length>2);t.rangeType=f.rangeType,i=f.bandNames,n=f.bandStats;const{bandNoDataValues:d}=f;d?.length&&(o=ue(d))}else if(E(c,"domainSet"))t.domainSet=yt(c,t.boundedBy?.axisLabels);else if(E(c,"metadata")){const f=w(c,"EOMetadata");t.eoMetadata=f?bt(f):null}}}const{coverageId:a,boundedBy:s,domainSet:r,rangeType:p,serviceParameters:l}=t,u=vt(p,s,r);return!n&&u&&(n=u?.variables[0].statistics),u!=null&&(o=p[0][0].nilValue),{id:a,title:a,description:a,bandNames:i,rasterInfo:new oe({width:r.columns,height:r.rows,pixelSize:r.resolution,pixelType:"unknown",extent:s.envelope,spatialReference:s.envelope.spatialReference,bandCount:i.length||1,statistics:n,noDataValue:o,multidimensionalInfo:u}),supportedFormats:l.supportedFormats,coverageDescription:t,version:"2.0.1",useEPSGAxis:!1}}function xt(e,t){let n=null;if(typeof e=="string"?n=new DOMParser().parseFromString(e,"text/xml"):n=e,t==="1.0.0")return P(n,"CoverageOffering").map(i=>lt(i));const o=P(n,"CoverageDescription");return t==="1.1.0"||t==="1.1.1"||t==="1.1.2"?o.map(i=>mt(i,t)):o.map(i=>wt(i))}async function Ct(e,t){const{version:n,customParameters:o,signal:i}=t??{},a=n?.startsWith("1.0")?"version":"acceptVersions",s={service:"WCS",request:"GetCapabilities",[a]:n,...o};try{let{data:r}=await ne(e,{query:s,responseType:"xml",signal:i});return t?.version||et(r)||(s[a]="2.0.1",{data:r}=await ne(e,{query:s,responseType:"xml",signal:i})),tt(r)}catch(r){throw de(r)?r:new k("wcslayer:open","wcs capabilities is not valid or supported")}}async function pe(e,t){const{coverageIds:n,version:o,customParameters:i,signal:a}=t,s=o.slice(0,3),r=s==="1.0"?"coverage":s==="1.1"?"identifiers":"coverageId",p={service:"WCS",request:"DescribeCoverage",version:o,[r]:n.join(","),...i};try{const{data:l}=await ne(e,{query:p,responseType:"xml",signal:a});return xt(l,o)}catch(l){throw de(l)?l:new k("wcslayer:open","wcs coverage description is not valid or supported")}}function It(e){const t=Dt(e);return t?{isMultipart:!0,data:t.boundary?St(e.data,t,0):null}:{isMultipart:!1,data:null}}function St(e,t,n=0){const o="--"+t.boundary,i=[];for(let g=0;g<o.length;g++)i.push(o.charCodeAt(g));const a=[],s=`
--`+t.boundary+"--";for(let g=0;g<s.length;g++)a.push(s.charCodeAt(g));const r=[10],p=[13,10],l=[],u=i.length,m=new Uint8Array(e,n),c=m.length-u;let f=0,d=0;for(let g=0;g<c;g++){for(d=0;d<u&&m[g+d]===i[d];d++);if(d!==u)continue;let v=!1;if(f){const b=xe(m.subarray(f,g),t);l.push(b),v=!!b.isValidImage}if(g+=u-1,m[g+1]===r[0]?g+=1:m[g+1]===p[0]&&m[g+2]===p[1]&&(g+=2),f=g+1,v)break}const h=a.length;for(let g=m.length-h-10;g<m.length-h;g++){for(d=0;d<h&&m[g+d]===a[d];d++);if(d===h){l.push(xe(m.subarray(f,g),t));break}}return l}function Dt(e){const t=e.getHeader?.("Content-Type")?.split(";");if(!t||!(t[0].trim()??"").startsWith("multipart/"))return null;const n={boundary:"",start:"",type:""};for(let o=1;o<t.length;o++){const i=t[o].indexOf("=");if(i>0){const a=t[o].slice(0,i).trim(),s=t[o].slice(i+1).trim();n[a]=s.startsWith('"')?s.slice(1,-1):s}}return n}function xe(e,t){const n=String.fromCharCode.apply(null,e.subarray(0,Math.min(300,e.length))).split(`
`),o=Math.min(n.length,7),i={contentDisposition:"inline"};let a=0;for(let s=0;s<o;s++)if(n[s].length<4)a=a+n[s].length+1;else if(n[s].slice(0,7).toLowerCase()==="content"){a=a+n[s].length+1;const r=n[s].indexOf(":");if(r===-1)continue;const p=n[s].slice(0,r).trim(),l=n[s].slice(r+1).trim();switch(p.toLowerCase()){case"content-type":i.contentType=l;break;case"content-description":i.contentDescription=l;break;case"content-transfer-encoding":i.contentTransferEncoding=l;break;case"content-id":i.contentID=l;break;case"content-disposition":i.contentDisposition=l;break;case"content-location":i.contentLocation=l}}else{if(i.contentDisposition.toLowerCase().includes("inline")&&n[s].length>=4&&i.contentType?.toLowerCase().indexOf("image")>-1){let r=!0,p=e.subarray(a,e.length);if(i.contentType.toLowerCase().indexOf("tif")>0){if(i.contentTransferEncoding==="base64"){let l="";const u=p;for(let c=0;c<u.length;c+=65535){const f=u.subarray(c,c+65535>u.length-1?u.length-1:c+65535);l+=String.fromCharCode.apply(null,f)}const m=atob(l);p=new Uint8Array(m.length);for(let c=0;c<p.length;c++)p[c]=m.charCodeAt(c)}r=p[0]===73&&p[1]===73||p[0]===77&&p[1]===77}if(r){let l=p.buffer;i.contentTransferEncoding!=="base64"&&(l=new ArrayBuffer(e.length-a),p=new Uint8Array(l),p.set(e.subarray(a,e.length))),i.contentData=l,i.isValidImage=!0}break}if((t.start===""||i.contentID===t.start)&&i.contentType){if(i.contentType.includes("text")||i.contentType.includes("xml")){i.contentData=String.fromCharCode.apply(null,e.subarray(a,e.length));break}i.contentData=e.subarray(a,e.length)}}return i}const Tt=["nearest neighbor","bilinear","bicubic"],Lt=["nearest","linear","cubic"],Ce="response is not a supported multipart/related mediaType with inline tiff,  switching to compatibility mode",At="response is not a supported multipart mediaType with inline tiff",Rt="response is base64 encoded which may impact layer display performance",Pt="server returns an exception",ee=new Set(["1.0.0","1.1.0","1.1.1","1.1.2","2.0.1"]);let z=class extends Me{constructor(){super(...arguments),this.datasetFormat="WCSServer",this.tileType="Raster"}get rasterId(){return`${this.url}-${this.coverageId}-${this.version}`}async fetchRawTile(e,t,n,o={}){if(this.isBlockOutside(e,t,n))return null;const{nativePixelSize:i,spatialReference:a}=this.rasterInfo,s=2**e,r=i.x*s,p=i.y*s,{blockWidth:l,blockHeight:u}=this.getBlockWidthHeight(e),{origin:m}=this.rasterInfo.storageInfo.tileInfo,c=this.getTileExtent({x:r,y:p},t,n,m,a,[l,u]),f=this.rasterInfo.extent,d=c.xmax>f.xmax,h=c.ymin<f.ymin,g=d||h;let v=c,b=l,x=u;if(g&&(v=c.clone().intersection(f),v!=null&&(d&&(b=Math.floor((v.xmax-v.xmin)/r),v.xmax=v.xmin+r*b),h&&(x=Math.floor((v.ymax-v.ymin)/p),v.ymin=v.ymax-p*x))),v==null||b<=1||x<=1)return null;const I=await this._getCoverage(v,b,x,s,o);if(!I)return null;const{coverageDescription:A}=this.coverageInfo,{noDataValue:W,multidimensionalInfo:M}=this.rasterInfo,{multidimensionalDefinition:U}=o;let j;if(M!=null&&U!=null&&U.length){const Y=U[0].variableName;A.version==="2.0"?j=A.rangeType[0].find(K=>K.name===Y)?.nilValue:A.version==="1.1"&&(j=A.range.find(K=>K.identifier===Y)?.nullValues)}const H=j??W,N=await this.decodePixelBlock(I,{width:b,height:x,planes:null,pixelType:null,tiffNoDataValue:Array.isArray(H)?H[0]:H,matchAllNoData:!0});if(N==null)return null;if(N&&(N.width!==b||N.height!==x))throw new k("wcsraster-fetch",`the response has unexpected dimension width: ${N.width}, height: {pixelBlock.height}`);return g?Ke(N,{x:0,y:0},{width:u,height:u}):N}async _open(e){const{customFetchParameters:t}=this.ioConfig,n=e?.signal,o=await Ct(this.url,{version:t?.version??this.version,customParameters:t,signal:n});if(this.capabilities=o,!this.version){let c=o.version.slice(0,3);c==="2.0"||c==="1.1"||c==="1.0"?this.version=o.version:(c=o.supportedVersions.find(f=>f==="2.0.1")||o.supportedVersions.find(f=>f.slice(0,3)==="2.0")||o.supportedVersions.find(f=>f.slice(0,3)==="1.1")||o.supportedVersions.find(f=>f.slice(0,3)==="1.0")||"1.0.0",this.version=c)}const{version:i}=this;if(!ee.has(i))throw new k("wcsraster-open",`unsupported WCS version ${i}`);const{gridCoverages:a}=o;if(!a.length)throw new k("wcsraster-open","cannot find rectified grid coverages");this.coverageId??=a[0].id;const{coverageId:s}=this,r=a.find(c=>c.id===s);if(r==null)throw new k("wcsraster-open",`the coverageId ${s} does not exist in capabilities`);const p=await pe(this.url,{coverageIds:[s],version:i,customParameters:t,signal:n});if(this.coverageInfo=p[0],i.slice(0,3)==="2.0"){const{coverageInfo:c}=this;c.lonLatEnvelope=r.lonLatEnvelope,c.supportedInterpolations=le(o.supportedInterpolations),this._patchDimensionValues201(s,n)}this.datasetName=this.coverageInfo.title;const{rasterInfo:l}=this.coverageInfo;if(this.createRemoteDatasetStorageInfo(l,512,512),this._set("rasterInfo",l),l.spatialReference==null)throw new k("wcsraster-open",`coverage without spatial reference is not supported: ${s}`);const{pixelType:u,bandCount:m}=await this._getPixelTypeAndBandCount(n);l.pixelType=u,l.bandCount===1&&m>1&&(l.bandCount=m),this.updateTileInfo()}async _patchDimensionValues201(e,t){const{coverageInfo:n}=this,o=n.rasterInfo.multidimensionalInfo?.variables,i=ee.has("1.1.2")?"1.1.2":ee.has("1.1.1")?"1.1.1":ee.has("1.1.0")?"1.1.0":null,{customFetchParameters:a}=this.ioConfig;if(o&&i)try{const s=this.url.includes("/ImageServer/"),r=e.length>8&&e.startsWith("Coverage")&&s?e.slice(8):e,p=await pe(this.url,{coverageIds:[r??e],version:i,customParameters:a,signal:t}).catch(()=>{if(r)return pe(this.url,{coverageIds:[e],version:i,customParameters:a,signal:t})}),l=p?.[0].rasterInfo.multidimensionalInfo?.variables;if(l)for(const u of o){const m=l.find(({name:c})=>c===u.name);if(m?.dimensions?.length)for(let c=u.dimensions.length-1;c>=0;c--){const f=u.dimensions[c],d=m.dimensions.find(({name:h})=>h===f.name);d?d.values&&d.extent?.join(",")===f.extent?.join(",")&&(u.dimensions[c]={...f,values:d.values}):s&&u.dimensions.splice(c,1)}}}catch{}}async _getPixelTypeAndBandCount(e){const{pixelSize:t,extent:n,multidimensionalInfo:o}=this.rasterInfo,i=n.center,a=new q({xmin:i.x-t.x,xmax:i.x+t.x,ymin:i.y-t.y,ymax:i.y+t.y,spatialReference:n.spatialReference});let s=[];if(o!=null){const d=o.variables[0];s=[],d.dimensions.forEach(h=>{s.push(new Ue({variableName:d.name,dimensionName:h.name,values:h.hasRegularIntervals?h.extent?.[0]:h.values?.[0],isSlice:!0}))})}const{coverageDescription:r}=this.coverageInfo,p={interpolation:"nearest",multidimensionalDefinition:s,signal:e},{version:l}=r,{ioConfig:u}=this,m=l==="2.0"&&u.allowAnyMediaType==null||l==="1.1"&&u.use2GridOffsets==null;let c;try{c=await this._getCoverage(a,2,2,1,p,!0)}catch(d){if(!m)throw d;if(l==="1.1"){if(!d.details?.isResolutionMismatch)throw d;u.use2GridOffsets=!0}}if(!c&&m&&(l==="2.0"&&(u.allowAnyMediaType=!0),c=await this._getCoverage(a,2,2,1,p),c&&ie.getLogger(this).warn("wcsraster:getcoverage",Ce)),!c)throw new k("wcsraster-open","unable to determine pixel type");const f=await this.decodePixelBlock(c,{width:2,height:2,planes:null,pixelType:null});if(f==null)throw new k("wcsraster-open","unable to determine pixel type");return{pixelType:f.pixelType,bandCount:f.getPlaneCount()??0}}async _getCoverage(e,t,n,o,i,a=!1){const{coverageDescription:s}=this.coverageInfo,{version:r}=s,p=r==="2.0"?this._getCoverage201Parameters(e,t,n,o,i,s):r==="1.1"?this._getCoverage110Parameters(e,t,n,i,s):this._getCoverage100Parameters(e,t,n,i),l=r==="2.0"?await this.request(this._constructWCS201Url(p),{signal:i.signal,responseType:"array-buffer"}):await this.request(this.url,{query:p,signal:i.signal,responseType:"array-buffer"});if(r==="1.0")return l.data;if(r==="2.0"&&this.ioConfig.allowAnyMediaType!==!1&&Ye(l.data)==="tiff")return a&&(this.ioConfig.allowAnyMediaType=!0,ie.getLogger(this).warn("wcsraster:getcoverage",Ce)),l.data;const u=It(l);if(u.isMultipart&&u.data){const d=u.data.find(h=>h.isValidImage);return a&&d?.contentTransferEncoding==="base64"&&ie.getLogger(this).warn("wcsraster:getcoverage",Rt),d?.contentData}const m=new Uint8Array(l.data,0,Math.min(l.data.byteLength,2e3)),c=String.fromCharCode.apply(null,m).toLowerCase().includes("exception"),f=c&&String.fromCharCode.apply(null,m).includes("A non-zero RESX/RESY or WIDTH/HEIGHT is required but neither was provided");throw c?new k("wcsraster:getcoverage",Pt,{isResolutionMismatch:f}):new k("wcsraster:getcoverage",At)}_getInterpolationIndex(e){return e&&this.coverageInfo.supportedInterpolations?.includes(e)?e==="nearest"?0:e==="bilinear"?1:e==="cubic"?2:0:0}_getCoverage100Parameters(e,t,n,o){const i=`${e.xmin},${e.ymin},${e.xmax},${e.ymax}`,a=e.spatialReference.wkid,s=(this.coverageInfo.supportedFormats||[]).find(d=>d.toLowerCase().includes("tiff"))||"GEOTIFF",{bandIds:r,interpolation:p}=o,l=this._getInterpolationIndex(p),u=r?r.map(d=>this.coverageInfo.bandNames[d]):null,m=Tt[l],{multidimensionalDefinition:c}=o;let f;if(c!=null&&this.rasterInfo.multidimensionalInfo!=null){let d=c.find(h=>h.dimensionName==="StdTime")?.values;d&&d.length>0&&(Array.isArray(d[0])&&(d=d[0]),f=d.map(h=>te(h)).join(","))}return{service:"WCS",request:"GetCoverage",version:this.version,coverage:this.coverageId,format:s,crs:`EPSG:${a}`,bbox:i,width:t,height:n,time:f,interpolation:m,band:u?.join(",")}}_getCoverage110Parameters(e,t,n,o,i){const{multidimensionalDefinition:a,bandIds:s,interpolation:r}=o,p=e.spatialReference.wkid,l=`urn:ogc:def:crs:EPSG::${p}`,u=(this.coverageInfo.supportedFormats||[]).find(R=>R.toLowerCase().includes("tiff"))||"image/tiff",m=this._getInterpolationIndex(r),c=Lt[m],f=r==null||this.coverageInfo.supportedInterpolations?.indexOf(r)===0,d=i.domain.spatialDomain,h=d.origin.x<=d.envelope.xmin&&d.origin.y<=d.envelope.ymin,g=e.width/t,v=e.height/n*(h?1:-1),b=h?[e.xmin,e.ymin]:[e.xmin,e.ymax],x=d.useEPSGAxis&&ge(p),I=x?`${b[1]},${b[0]}`:`${b[0]},${b[1]}`,A=this.ioConfig.use2GridOffsets,W=x?A?`${v},${g}`:`${v},0,0,${g}`:A?`${g},${v}`:`${g},0,0,${v}`,M=g/2,U=e.xmin+M,j=e.xmax-M,H=Math.abs(v)/2,N=e.ymin+H,Y=e.ymax-H,K=x?`${N},${U},${Y},${j},${l}`:`${U},${N},${j},${Y},${l}`,C=i.range.find(R=>R.axis.some(F=>F.identifier.toLowerCase().includes("band")));let _,O=C&&c&&s?f?`${C.identifier}[${C.axis[0].identifier}[${s.join(",")}]]`:`${C.identifier}:${c}[${C.axis[0].identifier}[${s.join(",")}]]`:null;if(a!=null&&a.length)for(let R=0;R<a.length;R++){let F=a[R].values;const V=a[R].dimensionName?.toLowerCase(),X=a[R].variableName?.toLowerCase(),G=i.range.find(B=>B.identifier.toLowerCase()===X);if(F.length>0){if(Array.isArray(F[0])&&(F=F[0]),V==="stdtime")_=F.map(B=>te(B)).join(",");else if(G){const B=G.axis.find(Ie=>Ie.identifier.toLowerCase()===V);B&&(O=f?G.identifier+"["+B.identifier+"["+F.join(",")+"]]":G.identifier+":"+c+"["+B.identifier+"["+F.join(",")+"]]")}}R===a.length-1&&G&&!O&&(O=f?G.identifier:G.identifier+":"+c)}return{service:"WCS",request:"GetCoverage",version:this.version,identifier:this.coverageId,format:u,crs:`EPSG:${p}`,boundingbox:K,gridCS:"urn:ogc:def:cs:OGC:0.0:Grid2dSquareCS",gridType:"urn:ogc:def:method:WCS:1.1:2dGridIn2dCrs",gridOrigin:I,gridOffsets:W,gridBaseCRS:l,timeSequence:_,rangeSubset:O}}_getCoverage201Parameters(e,t,n,o,i,a){const{multidimensionalDefinition:s,interpolation:r}=i,p=this._getInterpolationIndex(r);let l=null;const{supportedInterpolations:u}=this.capabilities;if(u?.length)switch(p){case 0:l=u.find(C=>C.toLowerCase().includes("nearest"));break;case 1:l=u.find(C=>C.toLowerCase().includes("linear"));break;case 2:l=u.find(C=>C.toLowerCase().includes("cubic")||C.toLowerCase().includes("quadratic"))}const m=(this.coverageInfo.supportedFormats||[]).find(C=>C.toLowerCase().includes("tiff"))||"image/tiff",{bandNames:c}=this.coverageInfo,{boundedBy:f,domainSet:d,rangeType:h}=a,g=f.isEastFirst?0:1,v=1-g,{axisLabels:b}=f,x=b[g],I=b[v],A=`http://www.opengis.net/def/crs/EPSG/0/${e.spatialReference.wkid}`,W=A,M=[];M.push(`${x}(${e.xmin},${e.xmax})`),M.push(`${I}(${e.ymin},${e.ymax})`);const U=[];if(b.length>2)for(let C=2;C<b.length;C++){const _=d.origin[C];if(b[C].toLowerCase().includes("time")){let O=_.toString();f.uomLabels?.[C].toLowerCase().includes("ole")&&(U.push(b[C]),O=te(_,!0)),M.push(b[C]+",http://www.opengis.net("+O+")")}else M.push(b[C]+",http://www.opengis.net("+_+")")}let j=null;if(s!=null&&s.length){const C=[];h.forEach(O=>O.forEach(R=>C.push(R.name)));const _=[];for(let O=0;O<s.length;O++){const R=b.find(V=>V===s[O].dimensionName),F=C.find(V=>V===s[O].variableName);if(_.includes(F)||_.push(F),R){let V=s[O].values;if(V.length>0){Array.isArray(V[0])&&(V=V[0]);let X="";X=R.toLowerCase().includes("time")?V.map(B=>te(B)).join(","):V.join(",");const G=M.findIndex(B=>B.indexOf(R+",http://www.opengis.net")===0);G===-1&&M.push(R+",http://www.opengis.net("+X+")"),G===-1||M[G].includes("("+X+")")||M.splice(G,1,R+",http://www.opengis.net("+X+")")}}}_.length&&(j=_.join(","))}else c?.length>=2&&(j=(i.bandIds?i.bandIds.map(C=>c[C]):c).join(","));const H=M.join("&subset="),N=!a.domainSet.hasSameAxisLabelsAsBoundedBy&&this.ioConfig.allowScaleFactor!==!1,Y=N?null:`${x}(${t}),${I}(${n})`,K=N?1/o:null;return{service:"WCS",request:"GetCoverage",version:this.version,coverageId:this.coverageId,rangesubset:j,interpolation:l,scaleSize:Y,scaleFactor:K,subset:H,format:m,mediaType:this.ioConfig.allowAnyMediaType?null:"multipart/related",outputcrs:A,subsettingcrs:W}}_constructWCS201Url(e){const t={...this.ioConfig.customFetchParameters,...e},n=[];return Object.keys(t).forEach(o=>{const i=t[o];i!=null&&(o==="subset"?typeof i=="string"&&i.split("&subset=").forEach(a=>{a&&n.push(`subset=${encodeURIComponent(a)}`)}):n.push(`${o}=${encodeURIComponent(i)}`))}),`${encodeURI(this.url)}?${n.join("&")}`}};function te(e,t=!1){return(t?new Date(se(e)):new Date(e)).toISOString()}D([T({type:String,json:{write:!0}})],z.prototype,"datasetFormat",void 0),D([T({readOnly:!0})],z.prototype,"tileType",void 0),D([T({type:String,json:{write:!0}})],z.prototype,"version",void 0),D([T({type:String,json:{write:!0}})],z.prototype,"coverageId",void 0),D([T({readOnly:!0})],z.prototype,"rasterId",null),z=D([me("esri.layers.support.rasterDatasets.WCSRaster")],z);const Et=new Set(["milliseconds","seconds","minutes","hours","days","weeks","months","years","decades","centuries"]);let L=class extends Oe(je(Ve(Ge($e(Ne(_e(qe(Be(Pe(De.ClonableMixin(Ee))))))))))){constructor(...e){super(...e),this.coverageId=null,this.version=null,this.isReference=null,this.legendEnabled=!0,this.noData=0,this.operationalLayerType="WCS",this.type="wcs",this.popupEnabled=!0,this.popupTemplate=null,this.fields=null,this._debouncedSaveOperations=Te(async(t,n,o)=>{const{save:i,saveAs:a}=await import("./imageryUtils-Ci6c5mXk.js");switch(t){case J.SAVE:return i(this,n);case J.SAVE_AS:return a(this,o,n)}})}normalizeCtorArgs(e,t){return typeof e=="string"?{url:e,...t}:e}load(e){const t=e!=null?e.signal:null;return this.addResolvingPromise(this.loadFromPortal({supportedTypes:["WCS"]},e).catch(Le).then(()=>this._openRaster(t))),Promise.resolve(this)}get coverageInfo(){return this.raster.coverageInfo}get defaultPopupTemplate(){return this.createPopupTemplate()}get rasterFields(){const e=[He("Pixel Value")],t=this.raster?.rasterInfo??this.serviceRasterInfo,n=t?.multidimensionalInfo;if(n){const o=ze(n);e.push(...o)}return e}createPopupTemplate(e){return Xe({fields:this.rasterFields,title:this.title},e)}async save(e){return this._debouncedSaveOperations(J.SAVE,e)}async saveAs(e,t){return this._debouncedSaveOperations(J.SAVE_AS,t,e)}async _openRaster(e){const t=new z({url:this.url,version:this.version,coverageId:this.coverageId,ioConfig:{sampling:"closest",...this.ioConfig,customFetchParameters:this.customParameters}});if(await t.open({signal:e}),!t.rasterInfo)throw t.destroy(),new k("wcs-layer:load","cannot load resources on "+this.url);const{rasterInfo:n}=t;n.noDataValue==null&&(n.noDataValue=this.noData),this._set("serviceRasterInfo",n),this._set("spatialReference",n.spatialReference),this.title==null&&this.setAtOrigin("title",t.datasetName,"service"),this.coverageId==null&&this.setAtOrigin("coverageId",t.coverageInfo.id,"service"),this.version==null&&t.version&&this.setAtOrigin("version",t.version,"service"),this.setAtOrigin("tileInfo",t.rasterInfo.storageInfo.tileInfo,"service");const{multidimensionalInfo:o}=n;if(o!=null){const i=o.variables[0].dimensions.find(({name:a})=>a==="StdTime");if(i){let a=i.extent?.[0]??i.values[0];Array.isArray(a)&&(a=a[0]);let s=i.extent?.[1]??i.values[i.values.length-1];Array.isArray(s)&&(s=s[1]);const r=Et.has(i.intervalUnit?.toLowerCase())?i.intervalUnit?.toLowerCase():null;this.set("timeInfo",{startField:"StdTime",fullTimeExtent:{start:a,end:s},timeZone:null,interval:r?{value:i.interval,unit:r}:null})}}this.raster=t,this._configDefaultSettings(),this.addHandles(Ae(()=>this.customParameters,i=>this.raster.ioConfig.customFetchParameters=i))}};D([T({type:String,nonNullable:!0,json:{name:"wcsInfo.coverageId",write:{isRequired:!0,ignoreOrigin:!0}}})],L.prototype,"coverageId",void 0),D([T()],L.prototype,"coverageInfo",null),D([T({type:["1.0.0","1.1.0","1.1.1","1.1.2","2.0.1"],nonNullable:!0,json:{name:"wcsInfo.version",write:{isRequired:!0,ignoreOrigin:!0}}})],L.prototype,"version",void 0),D([T({type:Boolean,json:{read:!1,write:{enabled:!0,overridePolicy:()=>({enabled:!1})}}})],L.prototype,"isReference",void 0),D([T({json:{read:!0,write:!0}})],L.prototype,"blendMode",void 0),D([T(ke)],L.prototype,"legendEnabled",void 0),D([T({type:["show","hide"]})],L.prototype,"listMode",void 0),D([T()],L.prototype,"noData",void 0),D([T({type:["WCS"]})],L.prototype,"operationalLayerType",void 0),D([T()],L.prototype,"raster",void 0),D([T({readOnly:!0})],L.prototype,"type",void 0),D([T(Fe)],L.prototype,"popupEnabled",void 0),D([T({type:Re,json:{name:"popupInfo",write:!0}})],L.prototype,"popupTemplate",void 0),D([T({readOnly:!0})],L.prototype,"defaultPopupTemplate",null),D([T({readOnly:!0,type:[he]})],L.prototype,"fields",void 0),D([T({readOnly:!0,type:[he]})],L.prototype,"rasterFields",null),L=D([me("esri.layers.WCSLayer")],L);const Ot=L;export{Ot as default};
