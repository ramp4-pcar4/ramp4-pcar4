import{B as Fe,M as ue,i as K,ak as ee,bZ as C,bY as $,s as M,a0 as he,J as me,e as Pe,v as g,x as R,z as te,am as De,bV as Ce,bJ as Be,I as Je,b_ as Me}from"./main-CnDVnExo.js";import{y as de}from"./OperationalLayer-A4hDIwth.js";import{r as V,g as fe,N as He,i as ze,a as Ne,p as pe,f as Oe,d as ye,w as Ee,v as We,h as Le}from"./datasetUtils-TW-hion6.js";import{u as qe,N as xe,p as Ge,l as Ae,c as je,j as Ve,W as ge,h as $e,a as Ue,b as Qe,q as Xe,D as Ye,z as Ze,B as Ie,t as Ke,i as Re}from"./RasterJobHandlerMixin-CdwgnjLX.js";import{j as et,l as tt,a as it,h as nt,_ as rt}from"./RasterSymbolizer-__W937xp.js";import{j as X,l as st}from"./TileInfo-DhBuU59d.js";import{QueueProcessor as ot}from"./QueueProcessor-CdvWemgp.js";import{i as at,m as lt,h as ct,x as ut,s as ht}from"./RawBlockCache-DCSYXlC5.js";import{g as mt}from"./pixelRangeUtils-DcEknavd.js";import{T as ie,D as be,j as dt,u as ft,l as pt}from"./dataUtils-jj_Ulcwm.js";import{e as Y,v as ne,A as we,u as Se,f as yt,o as re,Q as Z,s as xt,i as gt,_ as It,V as se}from"./rasterProjectionHelper-DKJwtNZf.js";import{r as oe,p as Rt}from"./clipUtils-D3z6LU6S.js";import{g as bt}from"./FeatureSet-DClCm5PU.js";import{T as wt}from"./rasterFunctionHelper-Br0mdnIx.js";const ve=8,St=256;let vt=0,w=class extends Fe{constructor(){super(...arguments),this._tileFetchQueue=new ot({concurrency:32,process:(t,i)=>this._fetchRawTile(t.pyramidLevel,t.row,t.col,{...t.options,signal:i})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(t){return t?.ioConfig&&(t={...t,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:X.create(),...t.ioConfig}}),t}get _isGlobalWrappableSource(){const{rasterInfo:t}=this,i=Y(t.spatialReference);return i!=null&&t.extent.width>=i/2}get _hasNoneOrGCSShiftTransform(){const{transform:t}=this.rasterInfo;return t==null||t.type==="gcs-shift"}set rasterJobHandler(t){this._set("rasterJobHandler",t),V(this)&&this.primaryRasters?.rasters?.forEach(i=>i.rasterJobHandler=t)}get rasterId(){return this.url||"rasterId-"+vt++}set url(t){this._set("url",ue(t,K.getLogger(this)))}async open(t){return this._openPromise??=ne().then(()=>this._open(t)),this._openPromise}async fetchTile(t,i,s,e={}){const n=e.tileInfo||this.rasterInfo.storageInfo.tileInfo,o=this.getTileExtentFromTileInfo(t,i,s,n);return e={noClip:!0,...e},this.fetchPixels(o,n.size[0],n.size[1],e)}async identify(t,i={}){t=ee(C,t).clone().normalize();const{multidimensionalDefinition:s,timeExtent:e}=i,{rasterInfo:n}=this,{hasMultidimensionalTranspose:o,multidimensionalInfo:r}=n;let{transposedVariableName:l}=i;const a=r!=null&&o&&(e!=null||fe(s));a&&!l&&(l=s!=null&&s.length>0?s[0].variableName??void 0:r.variables[0].name,i={...i,transposedVariableName:l}),i=this._getRequestOptionsWithSliceId(i);const{spatialReference:c,extent:u}=n,{datumTransformation:m}=i;let h=we(t,c,m);if(!u.intersects(h))return{location:h,value:null};if(n.transform!=null){const F=n.transform.inverseTransform(h);if(!n.nativeExtent.intersects(F))return{location:F,value:null};h=F}let y=0;const p=l!=null&&r!=null&&n.hasMultidimensionalTranspose;if(V(this)){const F=this.primaryRasters.rasters[0];if(p)return F.identify(h,i);const{pixelSize:W}=n,v=3,B=W.x*v/2,L=W.y*v/2,q=new $({xmin:h.x-B,xmax:h.x+B,ymin:h.y-L,ymax:h.y+L,spatialReference:c}),G={interpolation:"nearest",multidimensionalDefinition:s,sliceId:i.sliceId},{pixelBlock:T}=await F.fetchPixels(q,v,v,G),{pixelBlock:_}=await this.fetchPixels(q,v,v,G);if(T==null)return{location:h,value:null};const P=Math.floor(v*v*.5),J=!T.mask||T.mask[P]?T.pixels.map(D=>D[P]):null;let z;return _!=null&&(z=!_.mask||_.mask[P]?_.pixels.map(D=>D[P]):void 0),{location:h,value:J,processedValue:z,pyramidLevel:0}}if(!p){if(i.srcResolution)y=Se(i.srcResolution,n,this.ioConfig.sampling).pyramidLevel;else if(y=await this.computeBestPyramidLevelForLocation(t,i),y==null)return{location:h,value:null}}const x=this.identifyPixelLocation(h,y,null,p);if(x===null)return{location:h,value:null};const{row:f,col:d,rowOffset:b,colOffset:I,blockWidth:S}=x,k=await this._tileFetchQueue.push({pyramidLevel:y,row:f,col:d,options:i},{signal:i.signal});if(!k?.pixels?.length)return{location:h,value:null};const H=b*S+I;return this._processIdentifyResult(k,{srcLocation:h,position:H,pyramidLevel:y,useTransposedTile:!!p,requestSomeSlices:a,identifyOptions:i})}async fetchPixels(t,i,s,e={}){t=yt(t),e=this._getRequestOptionsWithSliceId(e);const{_hasNoneOrGCSShiftTransform:n}=this;if(e.requestRawData&&n)return this._fetchPixels(t,i,s,e);const o=Y(t.spatialReference),r=re(t);if(o==null||r===0||r===1&&this._isGlobalWrappableSource&&n)return this._fetchPixels(t,i,s,e);if(r>=3)return{extent:t,pixelBlock:null};const l=[],{xmin:a,xmax:c}=t,u=Math.round(o/(c-a)*i),m=u-Math.round((o/2-a)/(c-a)*i);let h=0;const y=[];for(let d=0;d<=r;d++){const b=new $({xmin:d===0?a:-o/2,xmax:d===r?c-o*d:o/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),I=d===0?u-m:d===r?i-h:u;h+=I,y.push(I);const S=e.disableWrapAround&&d>0?null:this._fetchPixels(b,I,s,e);l.push(S)}const p=(await Promise.all(l)).map(d=>d?.pixelBlock);let x=null;const f={width:i,height:s};return this.rasterJobHandler?x=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:f,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:y},e)).pixelBlock:x=ie(p,f,{blockWidths:y}),{extent:t,srcExtent:Z(t,this.rasterInfo.spatialReference,e.datumTransformation),pixelBlock:x}}async fetchRawPixels(t,i,s,e={}){i={x:Math.floor(i.x),y:Math.floor(i.y)};const n=await this._fetchRawTiles(t,i,s,e),{nativeExtent:o,nativePixelSize:r,storageInfo:l}=this.rasterInfo,a=2**t,c=r.x*a,u=r.y*a,m=new $({xmin:o.xmin+c*i.x,xmax:o.xmin+c*(i.x+s.width-1),ymin:o.ymax-u*(i.y+s.height-1),ymax:o.ymax-u*i.y,spatialReference:o.spatialReference});if(!n)return{extent:m,srcExtent:m,pixelBlock:null};const{pixelBlocks:h,mosaicSize:y}=n;if(h.length===1&&h[0]!=null&&h[0].width===s.width&&h[0].height===s.height)return{extent:m,srcExtent:m,pixelBlock:n.pixelBlocks[0]};const p=t>0?l.pyramidBlockWidth:l.blockWidth,x=t>0?l.pyramidBlockHeight:l.blockHeight,f={x:i.x%p,y:i.y%x};let d;return this.rasterJobHandler?d=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:h,srcMosaicSize:y,destDimension:s,clipOffset:f,clipSize:s,coefs:null,sampleSpacing:null,interpolation:e.interpolation,alignmentInfo:null,blockWidths:null},e)).pixelBlock:d=ie(h,y,{clipOffset:f,clipSize:s}),{extent:m,srcExtent:m,pixelBlock:d}}fetchRawTile(t,i,s,e){throw new M("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return Z(this.rasterInfo.extent,t)}decodePixelBlock(t,i){return!this.rasterJobHandler||i.useCanvas?et(t,i):this.rasterJobHandler.decode({data:t,options:i})}async request(t,i,s=0){const{customFetchParameters:e}=this.ioConfig,{range:n,query:o,headers:r}=i;s=s??i.retryCount??this.ioConfig.retryCount;const l=n?{Range:`bytes=${n.from}-${n.to}`}:null;try{return await he(t,{...i,query:{...o,...e},headers:{...r,...l}})}catch(a){if(s>0)return s--,this.request(t,i,s);throw a}}getSliceIndex(t){const{multidimensionalInfo:i}=this.rasterInfo;return i==null||t==null||t.length===0?null:He(t,i)}getTileExtentFromTileInfo(t,i,s,e){const n=e.lodAt(t);return this.getTileExtent({x:n.resolution,y:n.resolution},i,s,e.origin,e.spatialReference,e.size)}updateTileInfo(){const{storageInfo:t,spatialReference:i,extent:s,pixelSize:e}=this.rasterInfo,{pyramidResolutions:n}=t;if(!t.tileInfo){const o=[],r=t.maximumPyramidLevel||0;let l=(e.x+e.y)/2,a=1/.0254*96*l;for(let u=0;u<=r&&(o.unshift(new st({level:r-u,resolution:l,scale:a})),u!==r);u++)if(n){const m=(n[u].x+n[u].y)/2;a*=m/l,l=m}else l*=2,a*=2;const c=new C({x:s.xmin,y:s.ymax,spatialReference:i});t.tileInfo=new X({origin:c,size:[t.blockWidth,t.blockHeight],spatialReference:i,lods:o}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,i=512,s=512,e){const{width:n,height:o,nativeExtent:r,pixelSize:l,spatialReference:a}=t,c=new C({x:r.xmin,y:r.ymax,spatialReference:a});e==null&&(e=Math.max(0,Math.round(Math.log(Math.max(n,o))/Math.LN2-8)));const u=this.computeBlockBoundary(r,512,512,{x:r.xmin,y:r.ymax},[l],e);t.storageInfo=new tt({blockWidth:i,blockHeight:s,pyramidBlockWidth:i,pyramidBlockHeight:s,origin:c,firstPyramidLevel:1,maximumPyramidLevel:e,blockBoundary:u})}async computeBestPyramidLevelForLocation(t,i={}){return 0}computeBlockBoundary(t,i,s,e,n,o=0,r=2){if(n.length===1&&o>0){n=[...n];let{x:u,y:m}=n[0];for(let h=0;h<o;h++)u*=r,m*=r,n.push({x:u,y:m})}const l=[],{x:a,y:c}=e;for(let u=0;u<n.length;u++){const{x:m,y:h}=n[u];l.push({minCol:Math.floor((t.xmin-a+.1*m)/i/m),maxCol:Math.floor((t.xmax-a-.1*m)/i/m),minRow:Math.floor((c-t.ymax+.1*h)/s/h),maxRow:Math.floor((c-t.ymin-.1*h)/s/h)})}return l}getPyramidPixelSize(t){const{nativePixelSize:i}=this.rasterInfo,{pyramidResolutions:s,pyramidScalingFactor:e}=this.rasterInfo.storageInfo;if(t===0)return i;if(s!=null&&s.length)return s[t-1];const n=e**t;return{x:i.x*n,y:i.y*n}}identifyPixelLocation(t,i,s,e){const{spatialReference:n,nativeExtent:o,storageInfo:r}=this.rasterInfo,{maximumPyramidLevel:l,origin:a,transposeInfo:c}=r,u=e&&c!=null?c.tileSize[0]:r.blockWidth,m=e&&c!=null?c.tileSize[1]:r.blockHeight,h=we(t,n,s);if(!o.intersects(h)||i<0||i>l)return null;const y=this.getPyramidPixelSize(i),{x:p,y:x}=y,f=(a.y-h.y)/x/m,d=(h.x-a.x)/p/u,b=Math.min(m-1,Math.floor((f-Math.floor(f))*m)),I=Math.min(u-1,Math.floor((d-Math.floor(d))*u));return{pyramidLevel:i,row:Math.floor(f),col:Math.floor(d),rowOffset:b,colOffset:I,blockWidth:u,srcLocation:h}}getTileExtent(t,i,s,e,n,o){const[r,l]=o,a=e.x+s*r*t.x,c=a+r*t.x,u=e.y-i*l*t.y,m=u-l*t.y;return new $({xmin:a,xmax:c,ymin:m,ymax:u,spatialReference:n})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,i,s){const e=this.rasterInfo.storageInfo.blockBoundary[t];return!e||e.maxRow<i||e.maxCol<s||e.minRow>i||e.minCol>s}updateImageSpaceRasterInfo(t){const{pixelSize:i}=t,{width:s,height:e}=t,n=me.WebMercator;t.spatialReference=n,t.extent=t.nativeExtent=new $({xmin:-.5,ymax:.5,xmax:s-.5,ymin:.5-e,spatialReference:n}),t.isPseudoSpatialReference=!0,t.transform=null,t.pixelSize=new C({x:1,y:1,spatialReference:n});const{extent:o,storageInfo:r}=t;if(r){r.origin=new C({x:o.xmin,y:o.ymax,spatialReference:n});const{pyramidResolutions:l,tileInfo:a}=r;if(l&&l.forEach(c=>{c.x/=i.x,c.y/=i.y}),a){a.origin=r.origin;const c=(t.nativePixelSize.x+t.nativePixelSize.y)/2;a.lods.forEach((u,m)=>{u.resolution=c*2**m,u.scale=96*u.resolution/.0254})}}}async _fetchPixels(t,i,s,e={}){let n=re(t);if(n>=2)return{extent:t,pixelBlock:null};const o=this._getSourceDataInfo(t,i,s,e),{pyramidLevel:r,srcResolution:l,srcExtent:a,srcWidth:c,srcHeight:u,ul:m}=o;if(c===0||u===0)return{extent:t,srcExtent:a,pixelBlock:null};const{rasterInfo:h}=this,y=h.transform,p=y?.type==="gcs-shift",x=Y(t.spatialReference)!=null;!p&&x||(n=re(o.srcExtent,p));const f=await this._fetchRawTiles(r,m,{width:c,height:u,wrapCount:n},e);if(!f)return{extent:t,srcExtent:a,pixelBlock:null};const d=h.storageInfo,b=r>0?d.pyramidBlockWidth:d.blockWidth,I=r>0?d.pyramidBlockHeight:d.blockHeight;let{x:S,y:k}=h.pixelSize;if(r>0){const{pyramidResolutions:O,pyramidScalingFactor:ke}=d;if(O!=null&&O[r-1])({x:S,y:k}=O[r-1]);else{const ce=ke**r;S*=ce,k*=ce}}const H=h.spatialReference,F=new C({x:S,y:k,spatialReference:H}),W=b===c&&I===u&&m.x%b===0&&m.y%I===0,v=new C({x:(t.xmax-t.xmin)/i,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference}),B=!t.spatialReference.equals(H),L=H.isGeographic?1e-9:1e-4,{datumTransformation:q}=e;if(!B&&W&&f.pixelBlocks.length===1&&b===i&&I===s&&_t(l,v,L))return{extent:t,srcExtent:a,srcTilePixelSize:F,pixelBlock:f.pixelBlocks[0]};const G=x&&Y(a.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,T=e.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");T&&!this.rasterJobHandler&&await ne();const _=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:f.extent,pixelSize:v.toJSON(),datumTransformation:q,rasterTransform:y,hasWrapAround:n>0||G,isAdaptive:this.ioConfig.optimizeProjectionAccuracy!==!1,includeGCSGrid:T},e):xt({projectedExtent:t,srcBufferExtent:f.extent,pixelSize:v,datumTransformation:q,rasterTransform:y,hasWrapAround:n>0||G,isAdaptive:!1,includeGCSGrid:T});let P;const J=!e.requestRawData,z={rows:_.spacing[0],cols:_.spacing[1]},D=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(r,f.extent.xmin):void 0,{pixelBlocks:N,mosaicSize:A,isPartiallyFilled:Q}=f;let j=null;if(this.rasterJobHandler)({pixelBlock:P,localNorthDirections:j}=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:N,srcMosaicSize:A,destDimension:J?{width:i,height:s}:null,coefs:J?_.coefficients:null,sampleSpacing:J?z:null,projectDirections:T,gcsGrid:T?_.gcsGrid:null,isUV:this.rasterInfo.dataType==="vector-uv",interpolation:e.interpolation,alignmentInfo:D,blockWidths:null},e));else{const O=ie(N,A,{alignmentInfo:D});P=J?be(O,{width:i,height:s},_.coefficients,z,e.interpolation):O,T&&_.gcsGrid&&(j=dt({width:i,height:s},_.gcsGrid),P=ft(P,this.rasterInfo.dataType,j))}return e.requestRawData||T?{extent:t,srcExtent:a,srcTilePixelSize:F,pixelBlock:P,transformGrid:_,localNorthDirections:j,isPartiallyFilled:Q}:{extent:t,srcExtent:a,srcTilePixelSize:F,pixelBlock:P}}async _fetchRawTiles(t,i,s,e){const{origin:n,blockBoundary:o}=this.rasterInfo.storageInfo,{blockWidth:r,blockHeight:l}=this.getBlockWidthHeight(t);let{x:a,y:c}=i,{width:u,height:m,wrapCount:h}=s;const y=this._getRasterTileAlignmentInfo(t,0);e.buffer&&(a-=e.buffer.cols,c-=e.buffer.rows,u+=2*e.buffer.cols,m+=2*e.buffer.rows);let p=0,x=0,f=0;h&&y!=null&&({worldColumnCountFromOrigin:x,originColumnOffset:f,rightPadding:p}=y,x*y.blockWidth-p>=a+u&&(p=0));const d=Math.floor(a/r),b=Math.floor(c/l),I=Math.floor((a+u+p-1)/r),S=Math.floor((c+m+p-1)/l),k=o[t];if(!k)return null;const{minRow:H,minCol:F,maxCol:W,maxRow:v}=k;if(h===0&&(S<H||I<F||b>v||d>W))return null;const B=new Array;let L=!1;const q=this.ioConfig.allowPartialFill==null?e.allowPartialFill:this.ioConfig.allowPartialFill;for(let D=b;D<=S;D++)for(let N=d;N<=I;N++){let A=N;if(!e.disableWrapAround&&h&&y!=null&&x<=N&&(A=N-x-f),D>=H&&A>=F&&v>=D&&W>=A){const Q=this._tileFetchQueue.push({pyramidLevel:t,row:D,col:A,options:e},{signal:e.signal});q?B.push(new Promise(j=>{Q.then(O=>j(O)).catch(()=>{L=!0,j(null)})})):B.push(Q)}else B.push(Promise.resolve(null))}if(B.length===0)return null;const G=await Promise.all(B),T={height:(S-b+1)*l,width:(I-d+1)*r},{spatialReference:_}=this.rasterInfo,P=this.getPyramidPixelSize(t),{x:J,y:z}=P;return{extent:new $({xmin:n.x+d*r*J,xmax:n.x+(I+1)*r*J,ymin:n.y-(S+1)*l*z,ymax:n.y-b*l*z,spatialReference:_}),pixelBlocks:G,mosaicSize:T,isPartiallyFilled:L}}_fetchRawTile(t,i,s,e){const{storageInfo:n}=this.rasterInfo,o=n.transposeInfo!=null&&!!e.transposedVariableName;if(!o){const m=n.blockBoundary[t];if(!m)return Promise.resolve(null);const{minRow:h,minCol:y,maxCol:p,maxRow:x}=m;if(i<h||s<y||i>x||s>p)return Promise.resolve(null)}const r=o?e.transposeVariableName:e.sliceId,l=this.rasterInfo.storageInfo.isBsqTile?e.bandIds:null,a=at(this.rasterId,r,l),c=`${t}/${i}/${s}`;let u=lt(a,e.registryId,c);if(u==null){const m=new AbortController;u=this.fetchRawTile(t,i,s,{...e,signal:m.signal}),ct(a,e.registryId,c,u,m),u.catch(()=>ut(a,e.registryId,c))}return e.signal&&Pe(e,()=>{ht(a,e.registryId,c)}),u}_computeMagDirValues(t){const{bandCount:i,dataType:s}=this.rasterInfo;if(!(i===2&&s==="vector-magdir"||s==="vector-uv")||t?.length!==2||!t[0]?.length)return null;const e=t[0].length;if(s==="vector-magdir"){const a=t[1].map(c=>(c+360)%360);return[t[0],a]}const[n,o]=t,r=[],l=[];for(let a=0;a<e;a++){const[c,u]=pt([n[a],o[a]]);r.push(c),l.push(u)}return[r,l]}_getRasterTileAlignmentInfo(t,i){return this._rasterTileAlignmentInfo==null&&(this._rasterTileAlignmentInfo=gt(this.rasterInfo)),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:{startX:i,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[t]}}_getSourceDataInfo(t,i,s,e={}){const n={datumTransformation:e.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};e.srcResolution&&(n.srcResolution=e.srcResolution,this._updateSourceDataInfo(t,n));const o=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:r,srcHeight:l,pyramidLevel:a}=n,c=r/i,u=l/s,m=a<o&&c*u>=16,h=a===o&&this._requireTooManySrcTiles(r,l,i,s);if(m||h||r===0||l===0){const y=new C({x:(t.xmax-t.xmin)/i,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference});let p=It(y,this.rasterInfo.spatialReference,t,n.datumTransformation);const x=!p||e.srcResolution&&p.x+p.y<e.srcResolution.x+e.srcResolution.y;if(m&&e.srcResolution&&x){const f=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(o-a+3>=f){const d=2**f;p={x:e.srcResolution.x*d,y:e.srcResolution.y*d}}}p&&(n.srcResolution=p,this._updateSourceDataInfo(t,n))}return this._requireTooManySrcTiles(n.srcWidth,n.srcHeight,i,s)&&(n.srcWidth=0,n.srcHeight=0),n}_requireTooManySrcTiles(t,i,s,e){const{tileInfo:n}=this.rasterInfo.storageInfo,o=Math.ceil(t/n.size[0])*Math.ceil(i/n.size[1]),r=t/s,l=i/e,a=Math.max(1,(s+e)/1024);return o>=St*a||r>ve||l>ve}_updateSourceDataInfo(t,i){i.srcWidth=0,i.srcHeight=0;const{rasterInfo:s}=this,e=s.spatialReference,{srcResolution:n,datumTransformation:o}=i,{pyramidLevel:r,pyramidResolution:l,excessiveReading:a}=Se(n,s,this.ioConfig.sampling);if(a)return;let c=i.srcExtent||Z(t,e,o);if(c==null)return;const u=s.transform;u&&(c=u.inverseTransform(c)),i.srcExtent=c;const{x:m,y:h}=s.storageInfo.origin,y=Math.floor((c.xmin-m)/l.x+.1),p=Math.floor((h-c.ymax)/l.y+.1),x=Math.floor((c.xmax-m)/l.x-.1),f=Math.floor((h-c.ymin)/l.y-.1),d=c.width<.1*l.x?0:x-y+1,b=c.height<.1*l.y?0:f-p+1;i.pyramidLevel=r,i.pyramidResolution=l,i.srcWidth=d,i.srcHeight=b,i.ul={x:y,y:p}}_getRequestOptionsWithSliceId(t){return this.rasterInfo.multidimensionalInfo!=null&&t.sliceId==null&&(t={...t,sliceId:this.getSliceIndex(t.multidimensionalDefinition)}),t}_processIdentifyResult(t,i){const{srcLocation:s,position:e,pyramidLevel:n,useTransposedTile:o}=i,r=t.pixels[0].length/t.width/t.height;if(!(!t.mask||t.mask[e]))return{location:s,value:null};const{multidimensionalInfo:l}=this.rasterInfo;if(l==null||!o){const f=t.pixels.map(I=>I[e]),d={location:s,value:f,pyramidLevel:n},b=this._computeMagDirValues(f.map(I=>[I]));return b?.length&&(d.magdirValue=b.map(I=>I[0])),d}let a=t.pixels.map(f=>f.slice(e*r,e*r+r)),c=this._computeMagDirValues(a);const{requestSomeSlices:u,identifyOptions:m}=i;let h=ze(l,m.transposedVariableName);if(u){const f=Ne(h,m.multidimensionalDefinition,m.timeExtent);a=a.map(d=>f.map(b=>d[b])),c=c?.map(d=>f.map(b=>d[b])),h=f.map(d=>h[d])}const y=t.noDataValues||this.rasterInfo.noDataValue,p={pixels:a,pixelType:t.pixelType};let x;return y!=null&&(mt(p,y),x=p.mask),{location:s,value:null,dataSeries:h.map((f,d)=>{const b={value:x?.[d]===0?null:a.map(I=>I[d]),multidimensionalDefinition:f.multidimensionalDefinition.map(I=>new pe({...I,isSlice:!0}))};return c?.length&&(b.magdirValue=[c[0][d],c[1][d]]),b}),pyramidLevel:n}}};function _t(t,i,s){return Math.abs(t.x-i.x)<s&&Math.abs(t.y-i.y)<s}g([R()],w.prototype,"_rasterTileAlignmentInfo",void 0),g([R()],w.prototype,"_tileFetchQueue",void 0),g([R({readOnly:!0})],w.prototype,"_isGlobalWrappableSource",null),g([R({readOnly:!0})],w.prototype,"_hasNoneOrGCSShiftTransform",null),g([R()],w.prototype,"_openPromise",void 0),g([R()],w.prototype,"rasterJobHandler",null),g([R({readOnly:!0})],w.prototype,"rasterId",null),g([R(de)],w.prototype,"url",null),g([R({type:String,json:{write:!0}})],w.prototype,"datasetName",void 0),g([R({type:String,json:{write:!0}})],w.prototype,"datasetFormat",void 0),g([R()],w.prototype,"hasUniqueSourceStorageInfo",void 0),g([R()],w.prototype,"rasterInfo",void 0),g([R()],w.prototype,"ioConfig",void 0),g([R()],w.prototype,"sourceJSON",void 0),w=g([te("esri.layers.support.rasterDatasets.BaseRaster")],w);const Tt=40;let E=class extends w{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(t,i,s,e={}){const{rasters:n,rasterIds:o}=this.primaryRasters;let r=!1;const{interpolation:l}=e,a=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!e.requestRawData&&a&&(r=n.length===1&&!e.skipRasterFunction,e={...e,interpolation:"bilinear",requestRawData:r});const c=n.map(I=>I.fetchPixels(t,i,s,e)),u=await Promise.all(c),m=u.map(I=>I.pixelBlock),h=r||e.requestRawData?u.map(I=>I.srcTilePixelSize):null;if(e.skipRasterFunction||m.every(I=>I==null))return u[0];const y=u.find(I=>I.pixelBlock!=null)?.extent??t;let p=this.rasterJobHandler?await this.rasterJobHandler.process({extent:y,primaryPixelBlocks:m,primaryPixelSizes:h,primaryRasterIds:o}):this.rasterFunction.process({extent:y,primaryPixelBlocks:m,primaryPixelSizes:h,primaryRasterIds:o});const{transformGrid:x}=u[0];if(!r||p==null||x==null){const I=e.noClip?null:this.getClippingGeometry(y.spatialReference);return e.noClip||e.requestRawData||p==null||!I||(p=await oe(p,y,I)),{...u[0],pixelBlock:p}}const f={rows:x.spacing[0],cols:x.spacing[1]};let d;this.rasterJobHandler?d=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[p],srcMosaicSize:{width:p.width,height:p.height},destDimension:{width:i,height:s},coefs:x.coefficients,sampleSpacing:f,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:l,alignmentInfo:void 0,blockWidths:null},e)).pixelBlock:d=be(p,{width:i,height:s},x.coefficients,f,l);const b=e.noClip?null:this.getClippingGeometry(t.spatialReference);return e.noClip||e.requestRawData||d==null||b==null||(d=await oe(d,t,b)),{extent:t,srcExtent:u[0].srcExtent,pixelBlock:d}}getClippingGeometry(t){const i=this._clippingGeometry.get("0");if(!t||!i)return i;const s=Ft(t);let e=this._clippingGeometry.get(s);return e!=null||(e=t.equals(i.spatialReference)?i:se(i,t),this._clippingGeometry.set(s,e)),e}async _open(t){const{rasterFunction:i}=this;i.isRoot=!0,this.primaryRasters?.rasters?.length?i.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=i.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach(c=>c.rasterJobHandler=this.rasterJobHandler));const{rasters:s,rasterIds:e}=this.primaryRasters,n=s.map(c=>c.rasterInfo?void 0:c.open(t));await Promise.all(n);const o=s.map(({rasterInfo:c})=>c),r=i.bind({rasterInfos:o,rasterIds:e});if(i.rawSourceRasterInfos=o,!r.success||o.length===0)throw new M("raster-function:open",`cannot bind the function: ${r.error??""}`);const l=i.functionName==="Table"?i:i.functionArguments?.raster;l?.functionName==="Table"&&(i.rasterInfo.attributeTable=bt.fromJSON(l.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const a=o[0];this.hasUniqueSourceStorageInfo=o.length===1||o.slice(1).every(c=>kt(c,a)),this.set("sourceJSON",s[0].sourceJSON),this.set("rasterInfo",i.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const t=this.rasterFunction.getClippingGeometries()[0];let i=t?.clippingGeometry;if(i&&t.clippingType==="inside"){const{extent:s}=this.rasterInfo,e=await import("./densifyOperator-DUe1OYw-.js").then(r=>r.d),n=await import("./differenceOperator-CqcepDd8.js").then(r=>r.d);let o=e.execute(De.fromExtent(s),2*(s.width+s.height)/Tt);o=se(o,i.spatialReference),i=n.execute(o,i)}this._clippingGeometry.clear(),i&&this._clippingGeometry.set("0",i)}};function kt(t,i){const{storageInfo:s,pixelSize:e,spatialReference:n,extent:o}=t,{storageInfo:r,pixelSize:l,spatialReference:a,extent:c}=i;return e.x===l.x&&e.y===l.y&&n.equals(a)&&o.equals(c)&&s.blockHeight===r.blockHeight&&s.blockWidth===r.blockWidth&&s.maximumPyramidLevel===r.maximumPyramidLevel}function Ft(t){return String(t.wkid??t.wkt??t.wkt2)}g([R({type:String,json:{write:!0}})],E.prototype,"datasetFormat",void 0),g([R()],E.prototype,"tileType",void 0),g([R()],E.prototype,"rasterFunction",void 0),g([R()],E.prototype,"primaryRasters",void 0),E=g([te("esri.layers.support.rasterDatasets.FunctionRaster")],E);const _e=1e3,Pt=t=>{let i=class extends t{constructor(...e){super(...e),this._isConstructedFromFunctionRaster=!1,this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=V(e[0]?.raster)}destroy(){this._shutdownJobHandler()}get fullExtent(){return this.serviceRasterInfo?.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){e?.functionName?.toLowerCase()==="none"&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",ue(e,K.getLogger(this)))}get renderer(){if(this.type!=="imagery-tile")return this.internalRenderer;const{activePresetRendererName:e,presetRenderers:n}=this;return e?n?.find(({name:o})=>o===e)?.renderer.clone():this.internalRenderer}set renderer(e){this.type==="imagery-tile"&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){e==null&&this.rasterFunction==null?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,n,o){const r=n?.layerDefinition?.drawingInfo?.renderer;return je(r,o)||void 0}async computeStatisticsHistograms(e,n){await this.load(n),e=ee(Ve,e).clone();const{serviceRasterInfo:o}=this;if(o==null)throw new M("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:r}=e;if(r==null)throw new M("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let l=r;const{spatialReference:a}=o;if(!r.spatialReference.equals(a)){await ne();const f=r.type==="extent"?Z(r,a):se(r,a);if(f==null)throw new M("imagery-tile-mixin:compute-statistics-histograms","geometry cannot be projected to the data source");l=f}const c=e.pixelSize??new C({x:o.pixelSize.x,y:o.pixelSize.y,spatialReference:a}),{extent:u,width:m,height:h}=Rt(o,l,c),y=await this.fetchPixels(u,m,h,{...n,interpolation:"nearest"});if(y.pixelBlock==null)throw new M("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const p=await oe(y.pixelBlock,u,l),x=this._rasterJobHandler;return x?x.computeStatisticsHistograms({pixelBlock:p},n):nt(p)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:n}=this.serviceRasterInfo??{};if(n==null)return e;const o=Oe({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:o,timeExtent:void 0}}async updateRasterFunction(){return this.loaded&&this.type==="imagery-tile"&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){const{loaded:e,symbolizer:n,renderer:o}=this;if(!e||!n||!o)return;const{rasterInfo:r}=this.raster,l=ye(r,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),a=l?.name,c=ge(r,a);return this._updateSymbolizer(n,o,a,c)}async applyRenderer(e,n,o){const r=e?.pixelBlock;if(!(r!=null&&r.pixels&&r.pixels.length>0))return null;await this.updateRenderer();const l=this.bandIds??[],{pixelBlock:a}=await this._symbolize({pixelData:e,simpleStretchParams:n,bandIds:l,symbolizer:this.symbolizer},o);return a}getTileUrl(e,n,o){return this.raster.datasetFormat==="RasterTileServer"?`${this.url}/tile/${e}/${n}/${o}`:""}getCompatibleTileInfo(e,n,o=!1){if(!this.loaded||n==null)return null;if(o&&e.equals(this.spatialReference))return this.tileInfo;const r=Me(e);return X.create({size:256,spatialReference:e,origin:r?{x:r.origin[0],y:r.origin[1]}:{x:n.xmin,y:n.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent?.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,n,o,r={}){if(s(this),r.requestAsImageElement){const a=this.getTileUrl(e,n,o);return he(a,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:r.signal}).then(c=>c.data)}const{serviceRasterInfo:l}=this;if(l.multidimensionalInfo!=null&&(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition==null){const a=r.tileInfo||l.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(e,n,o,a),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),this.renderer?.type==="raster-shaded-relief"&&(r={...r,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,n,o,r)}async fetchPixels(e,n,o,r={}){return this.serviceRasterInfo.multidimensionalInfo!=null&&(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition==null?{extent:e,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),n=Math.round(n),o=Math.round(o),this.raster.fetchPixels(e,n,o,r))}async getSamples(e,n){if(await this.load(),(e=ee($e,e).clone()).interpolation&&e.interpolation!=="nearest")throw new M("imagery-tile-mixin:get-samples","only nearest interpolation is currently supported");const o=e.mosaicRule?.multidimensionalDefinition,r={...n,multidimensionalDefinition:o},l=(await this._getSampleLocations(e)).map(c=>this.identify(c,r).then(u=>(u.location=c,u))),a=(await Promise.all(l)).flatMap((c,u)=>this._convertRasterIdentifyResultToSample(c,u));return new Ue({samples:a})}async identify(e,n={}){await this.load();const{raster:o,serviceRasterInfo:r}=this;if(r?.multidimensionalInfo!=null&&!(r.hasMultidimensionalTranspose&&!(!fe(n.multidimensionalDefinition)&&!n.transposedVariableName))&&(n=this.normalizeRasterFetchOptions(n)).multidimensionalDefinition==null)return{location:e,value:null};const l=this.multidimensionalSubset?.areaOfInterest;if(l&&!l.contains(e))throw new M("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");const a=this.serviceRasterInfo?.storageInfo.isBsqTile&&this.bandIds?.length?this.bandIds:void 0;return o.identify(e,{...n,bandIds:a})}hasStandardTime(){const e=this.serviceRasterInfo?.multidimensionalInfo;if(e==null||this.serviceRasterInfo?.dataType!=="standard-time")return!1;const n=this.multidimensionalDefinition,o=n?.[0]?.variableName;return e.variables.some(r=>r.name===o&&(!n?.[0].dimensionName||r.dimensions.some(l=>l.name==="StdTime")))}getStandardTimeValue(e){return new Date(Ee(e)).toISOString()}getMultidimensionalSubsetVariables(e){const n=e??this.serviceRasterInfo?.multidimensionalInfo;return We(this.multidimensionalSubset,n)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=Le(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&V(this.raster)&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}async _initJobHandler(){if(!this._rasterJobHandler)return super._initJobHandler().then(async()=>{if(!this._rasterJobHandler)return;s(this);const{raster:e}=this;e.rasterJobHandler=this._rasterJobHandler,V(e)&&e.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{})}_shutdownJobHandler(){super._shutdownJobHandler(),this.raster&&(this.raster.rasterJobHandler=null)}async _getSampleLocations(e){const{geometry:n}=e;if(n.type==="point")return[n];const{spatialReference:o,type:r}=n;if(r==="multipoint")return n.points.map(f=>new C({x:f[0],y:f[1],spatialReference:o}));if(r==="polyline"){let f=n;if(e.sampleCount||e.sampleDistance){const d=await import("./densifyOperator-DUe1OYw-.js").then(k=>k.d),b=(await import("./lengthOperator-srXyoGtC.js").then(k=>k.l)).execute(n,{unit:"meters"}),I=Math.min(e.sampleCount||100,_e);let S=e.sampleDistance;S||(S=b/(I+(f.paths[0].length===2?1:0))),f=d.execute(n,S,{unit:"meters"})}return f.paths.flatMap(d=>d.map(b=>new C({x:b[0],y:b[1],spatialReference:o})))}const l=Math.min(e.sampleCount||100,_e),a=n.type==="extent",c=a?n:n.extent,u=Math.sqrt(c.width*c.height/l),m=c.height/u,h=c.width/u,{xmin:y,ymax:p}=c,x=[];for(let f=0;f<m;f++)for(let d=0;d<h;d++){const b=new C({x:y+(d+.5)*u,y:p-(f+.5)*u,spatialReference:o});(a||n.contains(b))&&x.push(b)}return x}_configDefaultInterpolation(){if(this.interpolation==null){s(this);const{raster:e}=this,n=Qe(e.rasterInfo,e.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",n)}}_configDefaultRenderer(e="no"){s(this);const{rasterInfo:n}=this.raster,o=ye(n,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),r=o?.name,l=Xe({variableName:r,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&n.bandCount>1&&(this.bandIds=l?.bandIds??Ye(n)),!this.renderer||e==="override"){const m=Ze(this.raster),h=l?.renderer??Ie(n,{bandIds:this.bandIds,variableName:r,rasterFunctionColorRamp:m}),y=n.statistics,p=y&&y.length>0?y[0]:null,x=p?.max??0,f=p?.min??0;this.raster.datasetFormat==="WCSServer"&&h.type==="raster-stretch"&&(x>1e24||f<-1e24)&&(h.dynamicRangeAdjustment=!0,h.customStatistics=null,h.stretchType==="none"&&(h.stretchType="min-max")),this.renderer=h}const a=Ke({...this.renderer.toJSON(),variableName:r}),c=ge(n,r);this.symbolizer?(this.symbolizer.rendererJSON=a,this.symbolizer.rasterInfo=c):this.symbolizer=new rt({rendererJSON:a,rasterInfo:c});const u=this.symbolizer.bind();if(u.success){if(e==="auto"){const{colormap:m}=this.raster.rasterInfo,h=this.renderer;if(m!=null&&h.type==="raster-colormap"){const y=Ie(this.raster.rasterInfo);JSON.stringify(y)!==JSON.stringify(h)&&this._configDefaultRenderer("override")}else if(h.type==="raster-stretch"){const y=this.bandIds?.length,p=h.customStatistics?.length;!h.dynamicRangeAdjustment&&p&&y&&p!==y&&this._configDefaultRenderer("override")}}}else K.getLogger(this).warn("imagery-tile-mixin",u.error||"The given renderer is not supported by the layer."),e==="auto"&&this._configDefaultRenderer("override")}async _updateRasterFunction(){if(this._isConstructedFromFunctionRaster&&V(this.raster)){const u=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&u&&this._set("rasterFunction",xe.fromJSON(u)))}let e,n=this.raster,o=!1;V(n)?(e=n.primaryRasters.rasters,n=e[0],o=!0):e=[n];const{rasterFunction:r}=this;if(r){const u={raster:n};e.length>1&&e.forEach(y=>u[y.url]=y);const m=wt(r.functionDefinition?.toJSON()??r.toJSON(),u),h=new E({rasterFunction:m});h.rasterJobHandler=this._rasterJobHandler,await h.open(),this.raster=h}else this.raster=n,await n.open();if(this._cachedRendererJson=void 0,!o&&!r)return;const{bandIds:l}=this,{bandCount:a}=this.raster.rasterInfo,c=l?.length?l.some(u=>u>=a):a>=3;l&&(c||this.renderer&&this.renderer.type!=="raster-stretch")&&this._set("bandIds",null),this._configDefaultRenderer("auto")}_convertRasterIdentifyResultToSample(e,n){const{rasterInfo:o}=this.raster,r=o.storageInfo.pyramidScalingFactor**(e.pyramidLevel??0),l=(o.pixelSize.x+o.pixelSize.y)/2*r;if(!e.dataSeries?.length)return[new Re({location:e.location,pixelValue:e.value,locationId:n,resolution:l})];const a=[];return e.dataSeries.forEach(({value:c,multidimensionalDefinition:u},m)=>{const h={Variables:u[0].variableName,Dimensions:u.flatMap(({dimensionName:p})=>p).join(",")};for(const{dimensionName:p,values:x}of u){h[p]=Array.isArray(x[0])?x[0][0]:x[0];const f=x[x.length-1];h[`${p}_Max`]=Array.isArray(f)?f[f.length-1]:f}const y=new Re({location:e.location,pixelValue:c,rasterId:m,locationId:n,resolution:l,attributes:h});a.push(y)}),a}};function s(e){if(!e.raster||!e.serviceRasterInfo)throw new M("imagery-tile","no raster")}return g([R({clonable:!1})],i.prototype,"_cachedRasterFunctionJson",void 0),g([R({clonable:!1})],i.prototype,"_compatibleFullExtent",void 0),g([R({clonable:!1})],i.prototype,"_isConstructedFromFunctionRaster",void 0),g([R({clonable:!1})],i.prototype,"_rasterFunctionUpdatePromise",void 0),g([R({type:[Ce],json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.bandIds?.join(",")!=="0,1,2"}}}}})],i.prototype,"bandIds",void 0),g([R({json:{origins:{service:{read:{source:"copyrightText"}}}}})],i.prototype,"copyright",void 0),g([R({json:{read:!1}})],i.prototype,"fullExtent",null),g([R({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.interpolation!=="bilinear"}}}}}),Be(it)],i.prototype,"interpolation",void 0),g([R()],i.prototype,"ioConfig",void 0),g([R({type:[pe],json:{write:!0}})],i.prototype,"multidimensionalDefinition",null),g([R({type:qe,json:{write:!0}})],i.prototype,"multidimensionalSubset",void 0),g([R()],i.prototype,"raster",void 0),g([R({type:xe})],i.prototype,"rasterFunction",null),g([R()],i.prototype,"serviceRasterInfo",void 0),g([R()],i.prototype,"sourceJSON",void 0),g([R({readOnly:!0,type:me,json:{read:!1}})],i.prototype,"spatialReference",void 0),g([R({type:X})],i.prototype,"tileInfo",void 0),g([R(de)],i.prototype,"url",null),g([R()],i.prototype,"renderer",null),g([R({types:Ae,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){const e=this.renderer?.type==="raster-stretch"&&this.renderer.stretchType==="none"&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType==="Raster"||!e}}},origins:{"web-scene":{types:Ge,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&e.type!=="vector-field"&&e.type!=="flow"})}}}}})],i.prototype,"internalRenderer",null),g([Je("internalRenderer")],i.prototype,"readRenderer",null),g([R({clonable:!1})],i.prototype,"symbolizer",void 0),i=g([te("esri.layers.mixins.ImageryTileMixin")],i),i};function U(t,i){if(!t||!i)return[];let s=i;i.includes("/")?(s=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";const e=[];if(i){const o=U(t,s);for(let r=0;r<o.length;r++)U(o[r],i).forEach(l=>e.push(l));return e}const n=t.getElementsByTagNameNS("*",s);if(!n||n.length===0)return[];for(let o=0;o<n.length;o++)e.push(n[o]||n.item(o));return e}function ae(t,i){if(!t||!i)return null;let s=i;i.includes("/")?(s=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";const e=U(t,s);return e.length>0?i?ae(e[0],i):e[0]:null}function le(t,i=null){const s=i?ae(t,i):t;let e;return s?(e=s.textContent||s.nodeValue,e?e.trim():null):null}function Te(t,i){const s=U(t,i),e=[];let n;for(let o=0;o<s.length;o++)n=s[o].textContent||s[o].nodeValue,n&&(n=n.trim(),n!==""&&e.push(n));return e}function Dt(t,i=null){return le(t,i)?.split(" ").map(s=>Number(s))??[]}function Ct(t,i){return Te(t,i).map(s=>Number(s))}function Bt(t,i){const s=le(t,i);return Number(s)}function Jt(t,i){const s=t?.nodeName?.toLowerCase(),e=i.toLowerCase();return s.slice(s.lastIndexOf(":")+1)===e}function Mt(t){return t.nodeName.slice(t.nodeName.lastIndexOf(":")+1)}export{w as $,Pt as X,Mt as c,ae as e,Jt as i,Te as l,E as m,U as n,Bt as o,Dt as r,le as t,Ct as u};
