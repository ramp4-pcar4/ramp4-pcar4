{"version":3,"file":"ColorSet-Cl3BWPdK.js","sources":["../../node_modules/@amcharts/amcharts5/.internal/core/util/ColorSet.js"],"sourcesContent":["import { Entity } from \"./Entity\";\r\nimport { Color } from \"./Color\";\r\n/**\r\n * An object which holds list of colors and can generate new ones.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Color_sets} for more info\r\n */\r\nexport class ColorSet extends Entity {\r\n    //protected _currentPass: number = 0;\r\n    _afterNew() {\r\n        // Applying themes because color set will not have parent\r\n        super._afterNewApplyThemes();\r\n        this._dirty[\"colors\"] = false;\r\n    }\r\n    _beforeChanged() {\r\n        if (this.isDirty(\"colors\")) {\r\n            this.reset();\r\n        }\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    generateColors() {\r\n        this.setPrivate(\"currentPass\", this.getPrivate(\"currentPass\", 0) + 1);\r\n        const pass = this.getPrivate(\"currentPass\");\r\n        const colors = this.get(\"colors\", [this.get(\"baseColor\", Color.fromHex(0xff0000))]);\r\n        if (!this.getPrivate(\"numColors\")) {\r\n            this.setPrivate(\"numColors\", colors.length);\r\n        }\r\n        //const len = colors.length;\r\n        const len = this.getPrivate(\"numColors\");\r\n        //const start = len - this.getPrivate(\"numColors\")!;\r\n        const start = 0;\r\n        const passOptions = this.get(\"passOptions\");\r\n        const reuse = this.get(\"reuse\");\r\n        for (let i = start; i < len; i++) {\r\n            if (reuse) {\r\n                colors.push(colors[i]);\r\n            }\r\n            else {\r\n                const hsl = colors[i].toHSL();\r\n                let h = hsl.h + (passOptions.hue || 0) * pass;\r\n                while (h > 1)\r\n                    h -= 1;\r\n                let s = hsl.s + (passOptions.saturation || 0) * pass;\r\n                //if (s > 1) s -= Math.floor(s);\r\n                if (s > 1)\r\n                    s = 1;\r\n                if (s < 0)\r\n                    s = 0;\r\n                let l = hsl.l + (passOptions.lightness || 0) * pass;\r\n                //if (l > 1) l -= Math.floor(l);\r\n                while (l > 1)\r\n                    l -= 1;\r\n                colors.push(Color.fromHSL(h, s, l));\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Returns a [[Color]] at specific index.\r\n     *\r\n     * If there's no color at this index, a new color is generated.\r\n     *\r\n     * @param   index  Index\r\n     * @return         Color\r\n     */\r\n    getIndex(index) {\r\n        const colors = this.get(\"colors\", []);\r\n        const saturation = this.get(\"saturation\");\r\n        if (index >= colors.length) {\r\n            this.generateColors();\r\n            return this.getIndex(index);\r\n        }\r\n        return saturation != null ? Color.saturate(colors[index], saturation) : colors[index];\r\n    }\r\n    /**\r\n     * Returns next [[Color]] in the list.\r\n     *\r\n     * If the list is out of colors, new ones are generated dynamically.\r\n     */\r\n    next() {\r\n        let currentStep = this.getPrivate(\"currentStep\", this.get(\"startIndex\", 0));\r\n        this.setPrivate(\"currentStep\", currentStep + this.get(\"step\", 1));\r\n        return this.getIndex(currentStep);\r\n    }\r\n    /**\r\n     * Resets counter to the start of the list, so the next call for `next()` will\r\n     * return the first color.\r\n     */\r\n    reset() {\r\n        this.setPrivate(\"currentStep\", this.get(\"startIndex\", 0));\r\n        this.setPrivate(\"currentPass\", 0);\r\n    }\r\n}\r\nObject.defineProperty(ColorSet, \"className\", {\r\n    enumerable: true,\r\n    configurable: true,\r\n    writable: true,\r\n    value: \"ColorSet\"\r\n});\r\nObject.defineProperty(ColorSet, \"classNames\", {\r\n    enumerable: true,\r\n    configurable: true,\r\n    writable: true,\r\n    value: Entity.classNames.concat([ColorSet.className])\r\n});\r\n//# sourceMappingURL=ColorSet.js.map"],"names":["ColorSet","Entity","pass","colors","Color","len","start","passOptions","reuse","hsl","h","index","saturation","currentStep"],"mappings":";AAOO,MAAMA,UAAiBC,EAAO;AAAA;AAAA,EAEjC,YAAY;AAER,UAAM,qBAAoB,GAC1B,KAAK,OAAO,SAAY;AAAA,EAC5B;AAAA,EACA,iBAAiB;AACb,IAAI,KAAK,QAAQ,QAAQ,KACrB,KAAK,MAAK;AAAA,EAElB;AAAA;AAAA;AAAA;AAAA,EAIA,iBAAiB;AACb,SAAK,WAAW,eAAe,KAAK,WAAW,eAAe,CAAC,IAAI,CAAC;AACpE,UAAMC,IAAO,KAAK,WAAW,aAAa,GACpCC,IAAS,KAAK,IAAI,UAAU,CAAC,KAAK,IAAI,aAAaC,EAAM,QAAQ,QAAQ,CAAC,CAAC,CAAC;AAClF,IAAK,KAAK,WAAW,WAAW,KAC5B,KAAK,WAAW,aAAaD,EAAO,MAAM;AAG9C,UAAME,IAAM,KAAK,WAAW,WAAW,GAEjCC,IAAQ,GACRC,IAAc,KAAK,IAAI,aAAa,GACpCC,IAAQ,KAAK,IAAI,OAAO;AAC9B,aAAS,IAAIF,GAAO,IAAID,GAAK;AACzB,UAAIG;AACA,QAAAL,EAAO,KAAKA,EAAO,CAAC,CAAC;AAAA,WAEpB;AACD,cAAMM,IAAMN,EAAO,CAAC,EAAE,MAAK;AAC3B,YAAIO,IAAID,EAAI,KAAKF,EAAY,OAAO,KAAKL;AACzC,eAAOQ,IAAI;AACP,UAAAA,KAAK;AACT,YAAI,IAAID,EAAI,KAAKF,EAAY,cAAc,KAAKL;AAEhD,QAAI,IAAI,MACJ,IAAI,IACJ,IAAI,MACJ,IAAI;AACR,YAAI,IAAIO,EAAI,KAAKF,EAAY,aAAa,KAAKL;AAE/C,eAAO,IAAI;AACP,eAAK;AACT,QAAAC,EAAO,KAAKC,EAAM,QAAQM,GAAG,GAAG,CAAC,CAAC;AAAA,MACtC;AAAA,EAER;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,SAASC,GAAO;AACZ,UAAMR,IAAS,KAAK,IAAI,UAAU,CAAA,CAAE,GAC9BS,IAAa,KAAK,IAAI,YAAY;AACxC,WAAID,KAASR,EAAO,UAChB,KAAK,eAAc,GACZ,KAAK,SAASQ,CAAK,KAEvBC,KAAc,OAAOR,EAAM,SAASD,EAAOQ,CAAK,GAAGC,CAAU,IAAIT,EAAOQ,CAAK;AAAA,EACxF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO;AACH,QAAIE,IAAc,KAAK,WAAW,eAAe,KAAK,IAAI,cAAc,CAAC,CAAC;AAC1E,gBAAK,WAAW,eAAeA,IAAc,KAAK,IAAI,QAAQ,CAAC,CAAC,GACzD,KAAK,SAASA,CAAW;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ;AACJ,SAAK,WAAW,eAAe,KAAK,IAAI,cAAc,CAAC,CAAC,GACxD,KAAK,WAAW,eAAe,CAAC;AAAA,EACpC;AACJ;AACA,OAAO,eAAeb,GAAU,aAAa;AAAA,EACzC,YAAY;AAAA,EACZ,cAAc;AAAA,EACd,UAAU;AAAA,EACV,OAAO;AACX,CAAC;AACD,OAAO,eAAeA,GAAU,cAAc;AAAA,EAC1C,YAAY;AAAA,EACZ,cAAc;AAAA,EACd,UAAU;AAAA,EACV,OAAOC,EAAO,WAAW,OAAO,CAACD,EAAS,SAAS,CAAC;AACxD,CAAC;","x_google_ignoreList":[0]}