import{fF as S}from"./main-CnDVnExo.js";const z=512;var d,p;(function(t){t[t.Unknown=0]="Unknown",t[t.Point=1]="Point",t[t.LineString=2]="LineString",t[t.Polygon=3]="Polygon"})(d||(d={}));let f=class v{constructor(s,i){this.x=s,this.y=i}static fromArray(s){return new v(s[0],s[1])}clone(){return new v(this.x,this.y)}equals(s,i){return s===this.x&&i===this.y}isEqual(s){return s.x===this.x&&s.y===this.y}setCoords(s,i){return this.x=s,this.y=i,this}normalize(){const s=this.x,i=this.y,h=Math.sqrt(s*s+i*i);return this.x/=h,this.y/=h,this}rightPerpendicular(){const s=this.x;return this.x=this.y,this.y=-s,this}leftPerpendicular(){const s=this.x;return this.x=-this.y,this.y=s,this}move(s,i){return this.x+=s,this.y+=i,this}assign(s){return this.x=s.x,this.y=s.y,this}assignAdd(s,i){return this.x=s.x+i.x,this.y=s.y+i.y,this}assignSub(s,i){return this.x=s.x-i.x,this.y=s.y-i.y,this}rotate(s,i){const h=this.x,e=this.y;return this.x=h*s-e*i,this.y=h*i+e*s,this}rotateReverse(s,i){const h=this.x,e=this.y;return this.x=h*s+e*i,this.y=-h*i+e*s,this}scale(s){return this.x*=s,this.y*=s,this}length(){const s=this.x,i=this.y;return Math.sqrt(s*s+i*i)}sub(s){return this.x-=s.x,this.y-=s.y,this}add(s){return this.x+=s.x,this.y+=s.y,this}static distance(s,i){const h=i.x-s.x,e=i.y-s.y;return Math.sqrt(h*h+e*e)}static add(s,i){return new v(s.x+i.x,s.y+i.y)}static sub(s,i){return new v(s.x-i.x,s.y-i.y)}};class I{constructor(s,i,h){this.ratio=s,this.x=i,this.y=h}}let D=class{constructor(t,s,i,h=8,e=8){this._lines=[],this._starts=[],this.validateTessellation=!0,this._pixelRatio=h,this._pixelMargin=e,this._tileSize=z*h,this._dz=t,this._yPos=s,this._xPos=i}setPixelMargin(t){t!==this._pixelMargin&&(this._pixelMargin=t,this.setExtent(this._extent))}setExtent(t){this._extent=t,this._finalRatio=this._tileSize/t*(1<<this._dz);let s=this._pixelRatio*this._pixelMargin;s/=this._finalRatio;const i=t>>this._dz;s>i&&(s=i),this._margin=s,this._xmin=i*this._xPos-s,this._ymin=i*this._yPos-s,this._xmax=this._xmin+i+2*s,this._ymax=this._ymin+i+2*s}reset(t){this._type=t,this._lines=[],this._starts=[],this._line=null,this._start=0}moveTo(t,s){this._pushLine(),this._prevIsIn=this._isIn(t,s),this._moveTo(t,s,this._prevIsIn),this._prevPt=new f(t,s),this._firstPt=new f(t,s),this._dist=0}lineTo(t,s){const i=this._isIn(t,s),h=new f(t,s),e=f.distance(this._prevPt,h);let l,n,x,_,a,g,m,u;if(i)this._prevIsIn?this._lineTo(t,s,!0):(l=this._prevPt,n=h,x=this._intersect(n,l),this._start=this._dist+e*(1-this._r),this._lineTo(x.x,x.y,!0),this._lineTo(n.x,n.y,!0));else if(this._prevIsIn)n=this._prevPt,l=h,x=this._intersect(n,l),this._lineTo(x.x,x.y,!0),this._lineTo(l.x,l.y,!1);else{const o=this._prevPt,r=h;if(o.x<=this._xmin&&r.x<=this._xmin||o.x>=this._xmax&&r.x>=this._xmax||o.y<=this._ymin&&r.y<=this._ymin||o.y>=this._ymax&&r.y>=this._ymax)this._lineTo(r.x,r.y,!1);else{const y=[];if((o.x<this._xmin&&r.x>this._xmin||o.x>this._xmin&&r.x<this._xmin)&&(_=(this._xmin-o.x)/(r.x-o.x),u=o.y+_*(r.y-o.y),u<=this._ymin?g=!1:u>=this._ymax?g=!0:y.push(new I(_,this._xmin,u))),(o.x<this._xmax&&r.x>this._xmax||o.x>this._xmax&&r.x<this._xmax)&&(_=(this._xmax-o.x)/(r.x-o.x),u=o.y+_*(r.y-o.y),u<=this._ymin?g=!1:u>=this._ymax?g=!0:y.push(new I(_,this._xmax,u))),(o.y<this._ymin&&r.y>this._ymin||o.y>this._ymin&&r.y<this._ymin)&&(_=(this._ymin-o.y)/(r.y-o.y),m=o.x+_*(r.x-o.x),m<=this._xmin?a=!1:m>=this._xmax?a=!0:y.push(new I(_,m,this._ymin))),(o.y<this._ymax&&r.y>this._ymax||o.y>this._ymax&&r.y<this._ymax)&&(_=(this._ymax-o.y)/(r.y-o.y),m=o.x+_*(r.x-o.x),m<=this._xmin?a=!1:m>=this._xmax?a=!0:y.push(new I(_,m,this._ymax))),y.length===0)a?g?this._lineTo(this._xmax,this._ymax,!0):this._lineTo(this._xmax,this._ymin,!0):g?this._lineTo(this._xmin,this._ymax,!0):this._lineTo(this._xmin,this._ymin,!0);else if(y.length>1&&y[0].ratio>y[1].ratio)this._start=this._dist+e*y[1].ratio,this._lineTo(y[1].x,y[1].y,!0),this._lineTo(y[0].x,y[0].y,!0);else{this._start=this._dist+e*y[0].ratio;for(let P=0;P<y.length;P++)this._lineTo(y[P].x,y[P].y,!0)}this._lineTo(r.x,r.y,!1)}}this._dist+=e,this._prevIsIn=i,this._prevPt=h}close(){if(this._line.length>2){const t=this._firstPt,s=this._prevPt;t.x===s.x&&t.y===s.y||this.lineTo(t.x,t.y);const i=this._line;let h=i.length;for(;h>=4&&(i[0].x===i[1].x&&i[0].x===i[h-2].x||i[0].y===i[1].y&&i[0].y===i[h-2].y);)i.pop(),i[0].x=i[h-2].x,i[0].y=i[h-2].y,--h}}result(t=!0){return this._pushLine(),this._lines.length===0?null:(this._type===d.Polygon&&t&&q.simplify(this._tileSize,this._margin*this._finalRatio,this._lines),this._lines)}resultWithStarts(){if(this._type!==d.LineString)throw new Error("Only valid for lines");this._pushLine();const t=this._lines,s=t.length;if(s===0)return null;const i=[];for(let h=0;h<s;h++)i.push({line:t[h],start:this._starts[h]||0});return i}_isIn(t,s){return t>=this._xmin&&t<=this._xmax&&s>=this._ymin&&s<=this._ymax}_intersect(t,s){let i,h,e;if(s.x>=this._xmin&&s.x<=this._xmax)h=s.y<=this._ymin?this._ymin:this._ymax,e=(h-t.y)/(s.y-t.y),i=t.x+e*(s.x-t.x);else if(s.y>=this._ymin&&s.y<=this._ymax)i=s.x<=this._xmin?this._xmin:this._xmax,e=(i-t.x)/(s.x-t.x),h=t.y+e*(s.y-t.y);else{h=s.y<=this._ymin?this._ymin:this._ymax,i=s.x<=this._xmin?this._xmin:this._xmax;const l=(i-t.x)/(s.x-t.x),n=(h-t.y)/(s.y-t.y);l<n?(e=l,h=t.y+l*(s.y-t.y)):(e=n,i=t.x+n*(s.x-t.x))}return this._r=e,new f(i,h)}_pushLine(){this._line&&(this._type===d.Point?this._line.length>0&&(this._lines.push(this._line),this._starts.push(this._start)):this._type===d.LineString?this._line.length>1&&(this._lines.push(this._line),this._starts.push(this._start)):this._type===d.Polygon&&this._line.length>3&&(this._lines.push(this._line),this._starts.push(this._start))),this._line=[],this._start=0}_moveTo(t,s,i){this._type!==d.Polygon?i&&(t=Math.round((t-(this._xmin+this._margin))*this._finalRatio),s=Math.round((s-(this._ymin+this._margin))*this._finalRatio),this._line.push(new f(t,s))):(i||(t<this._xmin&&(t=this._xmin),t>this._xmax&&(t=this._xmax),s<this._ymin&&(s=this._ymin),s>this._ymax&&(s=this._ymax)),t=Math.round((t-(this._xmin+this._margin))*this._finalRatio),s=Math.round((s-(this._ymin+this._margin))*this._finalRatio),this._line.push(new f(t,s)),this._isH=!1,this._isV=!1)}_lineTo(t,s,i){let h,e;if(this._type!==d.Polygon)if(i){if(t=Math.round((t-(this._xmin+this._margin))*this._finalRatio),s=Math.round((s-(this._ymin+this._margin))*this._finalRatio),this._line.length>0&&(h=this._line[this._line.length-1],h.equals(t,s)))return;this._line.push(new f(t,s))}else this._line&&this._line.length>0&&this._pushLine();else if(i||(t<this._xmin&&(t=this._xmin),t>this._xmax&&(t=this._xmax),s<this._ymin&&(s=this._ymin),s>this._ymax&&(s=this._ymax)),t=Math.round((t-(this._xmin+this._margin))*this._finalRatio),s=Math.round((s-(this._ymin+this._margin))*this._finalRatio),this._line&&this._line.length>0){h=this._line[this._line.length-1];const l=h.x===t,n=h.y===s;if(l&&n)return;this._isH&&l||this._isV&&n?(h.x=t,h.y=s,e=this._line[this._line.length-2],e.x===t&&e.y===s?(this._line.pop(),this._line.length<=1?(this._isH=!1,this._isV=!1):(e=this._line[this._line.length-2],this._isH=e.x===t,this._isV=e.y===s)):(this._isH=e.x===t,this._isV=e.y===s)):(this._line.push(new f(t,s)),this._isH=l,this._isV=n)}else this._line.push(new f(t,s))}};class N{setExtent(s){this._ratio=s===4096?1:4096/s}get validateTessellation(){return this._ratio<1}reset(s){this._lines=[],this._line=null}moveTo(s,i){this._line&&this._lines.push(this._line),this._line=[];const h=this._ratio;this._line.push(new f(s*h,i*h))}lineTo(s,i){const h=this._ratio;this._line.push(new f(s*h,i*h))}close(){const s=this._line;s&&!s[0].isEqual(s[s.length-1])&&s.push(s[0])}result(){return this._line&&this._lines.push(this._line),this._lines.length===0?null:this._lines}}(function(t){t[t.sideLeft=0]="sideLeft",t[t.sideRight=1]="sideRight",t[t.sideTop=2]="sideTop",t[t.sideBottom=3]="sideBottom"})(p||(p={}));let q=class T{static simplify(s,i,h){if(!h)return;const e=-i,l=s+i,n=-i,x=s+i,_=[],a=[],g=h.length;for(let u=0;u<g;++u){const o=h[u];if(!o||o.length<2)continue;let r,y=o[0];const P=o.length;for(let c=1;c<P;++c)r=o[c],y.x===r.x&&(y.x<=e&&(y.y>r.y?(_.push(u),_.push(c),_.push(p.sideLeft),_.push(-1)):(a.push(u),a.push(c),a.push(p.sideLeft),a.push(-1))),y.x>=l&&(y.y<r.y?(_.push(u),_.push(c),_.push(p.sideRight),_.push(-1)):(a.push(u),a.push(c),a.push(p.sideRight),a.push(-1)))),y.y===r.y&&(y.y<=n&&(y.x<r.x?(_.push(u),_.push(c),_.push(p.sideTop),_.push(-1)):(a.push(u),a.push(c),a.push(p.sideTop),a.push(-1))),y.y>=x&&(y.x>r.x?(_.push(u),_.push(c),_.push(p.sideBottom),_.push(-1)):(a.push(u),a.push(c),a.push(p.sideBottom),a.push(-1)))),y=r}if(_.length===0||a.length===0)return;T.fillParent(h,a,_),T.fillParent(h,_,a);const m=[];T.calcDeltas(m,a,_),T.calcDeltas(m,_,a),T.addDeltas(m,h)}static fillParent(s,i,h){const e=h.length,l=i.length;for(let n=0;n<l;n+=4){const x=i[n],_=i[n+1],a=i[n+2],g=s[x][_-1],m=s[x][_];let u=8092,o=-1;for(let r=0;r<e;r+=4){if(h[r+2]!==a)continue;const y=h[r],P=h[r+1],c=s[y][P-1],w=s[y][P];switch(a){case p.sideLeft:case p.sideRight:if(R(g.y,c.y,w.y)&&R(m.y,c.y,w.y)){const M=Math.abs(w.y-c.y);M<u&&(u=M,o=r)}break;case p.sideTop:case p.sideBottom:if(R(g.x,c.x,w.x)&&R(m.x,c.x,w.x)){const M=Math.abs(w.x-c.x);M<u&&(u=M,o=r)}}}i[n+3]=o}}static calcDeltas(s,i,h){const e=i.length;for(let l=0;l<e;l+=4){const n=[],x=T.calcDelta(l,i,h,n);s.push(i[l]),s.push(i[l+1]),s.push(i[l+2]),s.push(x)}}static calcDelta(s,i,h,e){const l=i[s+3];if(l===-1)return 0;const n=e.length;return n>1&&e[n-2]===l?0:(e.push(l),T.calcDelta(l,h,i,e)+1)}static addDeltas(s,i){const h=s.length;let e=0;for(let l=0;l<h;l+=4){const n=s[l+3];n>e&&(e=n)}for(let l=0;l<h;l+=4){const n=i[s[l]],x=s[l+1],_=e-s[l+3];switch(s[l+2]){case p.sideLeft:n[x-1].x-=_,n[x].x-=_,x===1&&(n[n.length-1].x-=_),x===n.length-1&&(n[0].x-=_);break;case p.sideRight:n[x-1].x+=_,n[x].x+=_,x===1&&(n[n.length-1].x+=_),x===n.length-1&&(n[0].x+=_);break;case p.sideTop:n[x-1].y-=_,n[x].y-=_,x===1&&(n[n.length-1].y-=_),x===n.length-1&&(n[0].y-=_);break;case p.sideBottom:n[x-1].y+=_,n[x].y+=_,x===1&&(n[n.length-1].y+=_),x===n.length-1&&(n[0].y+=_)}}}};const R=(t,s,i)=>t>=s&&t<=i||t>=i&&t<=s,E=Number.POSITIVE_INFINITY,L=Math.PI,V=2*L,k=128/L,H=256/360,B=L/180,C=1/Math.LN2;function b(t,s){return(t%=s)>=0?t:t+s}function A(t){return b(t*k,256)}function F(t){return b(t*H,256)}function O(t){return Math.log(t)*C}function U(t,s,i){return t*(1-i)+s*i}const W=8,Y=14,j=16;function G(t){return W+Math.max((t-Y)*j,0)}function J(t,s,i){let h,e,l,n=0;for(const x of i){h=x.length;for(let _=1;_<h;++_)e=x[_-1],l=x[_],e.y>s!=l.y>s&&((l.x-e.x)*(s-e.y)-(l.y-e.y)*(t-e.x)>0?n++:n--)}return n!==0}function K(t,s,i,h){let e,l,n,x;const _=h*h;for(const a of i){const g=a.length;if(!(g<2)){e=a[0].x,l=a[0].y;for(let m=1;m<g;++m){if(n=a[m].x,x=a[m].y,S(t,s,e,l,n,x)<_)return!0;e=n,l=x}}}return!1}function Q(t,s,i,h,e,l,n){const x=Math.max(h,Math.min(s,l))-s,_=Math.max(e,Math.min(i,n))-i;return x*x+_*_<=t*t}function X(t,s){if(s===0||Number.isNaN(s))return t;const i=[],h=new f(0,0),e=new f(0,0),l=new f(0,0);for(let n=0;n<t.length;n++){const x=t[n],_=[];for(let a=0;a<x.length;a++){const g=x[a-1],m=x[a],u=x[a+1];a===0?h.setCoords(0,0):h.assignSub(m,g).normalize().rightPerpendicular(),a===x.length-1?e.setCoords(0,0):e.assignSub(u,m).normalize().rightPerpendicular(),l.assignAdd(h,e).normalize();const o=l.x*e.x+l.y*e.y;o!==0&&l.scale(1/o),_.push(f.add(m,l.scale(s)))}i.push(_)}return i}function Z(t,s,i,h){const e=new f(t[0],t[1]);if(e.scale(h),s==="viewport"){const l=-i*(Math.PI/180),n=Math.cos(l),x=Math.sin(l);e.rotate(n,x)}return e}export{J as I,K as N,X as P,N as _,b as a,O as b,D as c,G as d,V as e,A as f,Z as g,f as h,d as i,F as l,L as o,U as p,E as r,B as s,Q as w};
