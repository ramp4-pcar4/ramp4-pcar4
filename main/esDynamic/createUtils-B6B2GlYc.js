import{aH as U,an as V,hD as X,gR as $,y as K,eY as N,gP as ee,ao as te,hQ as ae,z as se,_ as W,X as F,cl as R,Y as re,az as d,bJ as z,aG as ne,i2 as G,i3 as oe,c3 as ie,dH as O,G as le,cW as ce,gV as he,dU as pe}from"./main-6gYsRPh_.js";import{g as ue,P as fe,c as de,A as me,_ as ye,Q as A,I as xe}from"./vec32-y2_p7lFt.js";import{j as ge}from"./geodesicUtils-8mhrMpeD.js";import{c as Re}from"./distanceOperator-CgIPONfp.js";import{c as Me,u as we}from"./simplifyOperator-3QF7Gt6L.js";import{u as Te}from"./mat2d-DSvAsCNj.js";import{e as B,t as ve}from"./mat2df64-VxtldH1S.js";import{R as We,L as be}from"./quat-CCpZjkix.js";import{e as q}from"./quatf64-C16JxGFv.js";var k;let M=k=class extends U{constructor(t){super(t),this.center=null,this.geodesic=!1,this.numberOfPoints=60,this.radius=1e3,this.radiusUnit="meters"}initialize(){const t=this.center,e=this.numberOfPoints;if(this.hasZ=t?.hasZ??!1,this.rings.length!==0||!t)return;const s=V(this.radius,this.radiusUnit,"meters"),r=t.spatialReference;let o,a="geographic";if(r.isWebMercator?a="webMercator":((r.wkid&&X[r.wkid])!=null||(r.wkt2||r.wkt)&&$(r.wkt2||r.wkt))&&(a="projected"),this.geodesic){let n;switch(a){case"webMercator":n=K(t);break;case"projected":console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");break;case"geographic":n=t}o=this._createGeodesicCircle(n,s,e),a==="webMercator"&&(o=N(o))}else{let n;a==="webMercator"||a==="projected"?n=s/ee(t.spatialReference):a==="geographic"&&(n=te(s,"meters",ae(t.spatialReference).radius)),o=this._createPlanarCircle(t,n,e)}this.spatialReference=o.spatialReference,this.addRing(o.rings[0])}clone(){const{center:t,numberOfPoints:e,radius:s,radiusUnit:r,geodesic:o}=this;return new k({center:t?.clone(),numberOfPoints:e,radius:s,radiusUnit:r,geodesic:o})}_createGeodesicCircle(t,e,s){const r=[],o=[t.x,t.y];for(let a=0;a<360;a+=360/s){const n=this.hasZ?[0,0,t.z??0]:[0,0];ge(n,o,a,e,se.WGS84),r.push(n)}return r.push(r[0]),new U({rings:[r]})}_createPlanarCircle(t,e,s){const r=[],o=2*Math.PI/s;for(let a=0;a<s;++a){const n=o*a,i=[t.x+Math.cos(-n)*e,t.y+Math.sin(-n)*e];this.hasZ&&i.push(t.z??0),r.push(i)}return r.push(r[0]),new U({spatialReference:t.spatialReference,rings:[r]})}};W([F({type:R})],M.prototype,"center",void 0),W([F()],M.prototype,"geodesic",void 0),W([F()],M.prototype,"numberOfPoints",void 0),W([F()],M.prototype,"radius",void 0),W([F()],M.prototype,"radiusUnit",void 0),M=k=W([re("esri.geometry.Circle")],M);const Se=M;function I(t,e,s=null){return s!=null?[t,e,s]:[t,e]}function l(t,e,s=null){return s!=null?{x:t,y:e,z:s}:{x:t,y:e}}class E{constructor(e){this.spatialReference=e}mapToLocalMultiple(e){return e.map(s=>this.mapToLocal(s)).filter(z)}get doUnnormalization(){return!1}}let Q=class extends E{constructor(t,e,s=null){super(e),this._defaultZ=s,this.transform=B(),this.transformInv=B(),this.transform=ve(t),Te(this.transformInv,this.transform)}makeMapPoint(t,e){return I(t,e,this._defaultZ)}mapToLocal(t){return l(this.transform[0]*t[0]+this.transform[2]*t[1]+this.transform[4],this.transform[1]*t[0]+this.transform[3]*t[1]+this.transform[5])}localToMap(t){return I(this.transformInv[0]*t.x+this.transformInv[2]*t.y+this.transformInv[4],this.transformInv[1]*t.x+this.transformInv[3]*t.y+this.transformInv[5],this._defaultZ)}},Fe=class extends E{constructor(t,e){super(t.spatialReference),this.view=t,this.defaultZ=null,this.pWS=d(),this.tangentFrameUpWS=d(),this.tangentFrameRightWS=d(),this.tangentFrameForwardWS=d(),this.localFrameRightWS=d(),this.localFrameUpWS=d(),this.worldToLocalTransform=q(),this.localToWorldTransform=q(),this.scale=1,this.scale=t.resolution,this.referenceMapPoint=e,this.defaultZ=e.hasZ?e.z:null;const s=t.state.camera.viewRight;this.view.renderCoordsHelper.toRenderCoords(this.referenceMapPoint,this.pWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,0,this.tangentFrameRightWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,1,this.tangentFrameUpWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,2,this.tangentFrameForwardWS);const r=d();ue(r,this.tangentFrameForwardWS,fe(s,this.tangentFrameForwardWS)),de(this.localFrameRightWS,s,r),me(this.localFrameRightWS,this.localFrameRightWS),ye(this.localFrameUpWS,this.tangentFrameForwardWS,this.localFrameRightWS),We(this.worldToLocalTransform,this.localFrameRightWS,this.tangentFrameRightWS),be(this.localToWorldTransform,this.worldToLocalTransform)}get doUnnormalization(){return this.view.viewingMode==="global"}makeMapPoint(t,e){return I(t,e,this.defaultZ)}mapToLocal(t){const e=d();this.view.renderCoordsHelper.toRenderCoords(new R({x:t[0],y:t[1],spatialReference:this.spatialReference}),e),A(e,e,this.worldToLocalTransform);const s=this.view.renderCoordsHelper.fromRenderCoords(e,new R({spatialReference:this.view.spatialReference}));return s!=null?l(s.x/this.scale,s.y/this.scale):null}localToMap(t){const e=d();this.view.renderCoordsHelper.toRenderCoords(new R({x:t.x*this.scale,y:t.y*this.scale,spatialReference:this.spatialReference}),e),A(e,e,this.localToWorldTransform);const s=this.view.renderCoordsHelper.fromRenderCoords(e,new R({spatialReference:this.view.spatialReference}));return s!=null?I(s.x,s.y,this.defaultZ):null}};function Pe(t,e){if(t.type==="2d")return new Q(t.state.transform,t.spatialReference,e.length>2?e[2]:null);if(t.type==="3d"){const s=e.length>2?new R({x:e[0],y:e[1],z:e[2],spatialReference:t.spatialReference}):new R({x:e[0],y:e[1],spatialReference:t.spatialReference});return new Fe(t,s)}return null}function w(t,e){const s=new R({x:t[0],y:t[1],spatialReference:e});return t.length>2&&(s.z=t[2]),s}function Ce(t,e){return new pe({points:t,spatialReference:e})}function Ue(t,e,s){const r=new ne({paths:t,spatialReference:e});return s&&G(r),r}function P(t,e,s,r=!0){const o=le(t);o.forEach(n=>{const i=n[0],p=n[n.length-1];ce(i,p)&&n.length!==1||n.push(n[0])});let a=new U({rings:o,spatialReference:e});return a.rings.forEach(n=>{he(n)||n.reverse()}),s&&G(a),r&&!Me(a)&&O(e)&&(a=we(a)||a),a}function ze(t,e,s){const r=e.mapToLocalMultiple(t),o=[],a={x:r[0].x,y:r[0].y},n={x:r[1].x,y:r[1].y},i=Math.round(n.x-a.x),p=Math.round(n.y-a.y),u=Math.max(Math.abs(i),Math.abs(p));if(s){const c={x:a.x+u,y:a.y+u},m={x:a.x-u,y:a.y-u};o.push(l(c.x,m.y),l(m.x,m.y),l(m.x,c.y),l(c.x,c.y))}else{const c={x:i>0?a.x+u:a.x-u,y:p>0?a.y+u:a.y-u};o.push(l(a.x,a.y),l(c.x,a.y),l(c.x,c.y),l(a.x,c.y))}return Y(P([o.map(c=>e.localToMap(c)).filter(z)],e.spatialReference,e.doUnnormalization,!0),o,e)}function Ie(t,e,s){let r=e.mapToLocalMultiple(t);if(r.length===1){const i=r[0];r=[l(i.x-48,i.y+48),l(i.x+48,i.y-48),l(i.x+48,i.y-48),l(i.x-48,i.y+48)]}const o=[],a={x:r[0].x,y:r[0].y},n={x:r[1].x,y:r[1].y};if(s){const i=Math.round(n.x-a.x),p=Math.round(n.y-a.y);o.push(l(a.x-i,a.y-p),l(n.x,a.y-p),l(n.x,n.y),l(a.x-i,n.y))}else o.push(l(a.x,a.y),l(n.x,a.y),l(n.x,n.y),l(a.x,n.y));return Y(P([o.map(i=>e.localToMap(i)).filter(z)],e.spatialReference,e.doUnnormalization,!0),o,e)}function Y(t,e,s){const r=L(e[3],e[2],s),o=L(e[1],e[2],s),a=L(e[0],e[1],s),n=L(e[0],e[3],s);return{geometry:t,midpoints:r!=null&&o!=null&&a!=null&&n!=null?{top:r,right:o,bottom:a,left:n}:null}}function L(t,e,s){b[0]=t.x,b[1]=t.y,b[2]=0,S[0]=e.x,S[1]=e.y,S[2]=0,xe(b,b,S,.5),Z.x=b[0],Z.y=S[1],Z.z=S[2];const r=s.localToMap(Z);return r!=null?w(r,s.spatialReference):null}const Z=l(0,0,0),b=d(),S=d();function Le(t,e,s,r){const o=e.mapToLocalMultiple(t);let a=null,n=null;if(s)a=o[0],n=o[1];else{const h=o[0],f=o[1],T=Math.round(f.x-h.x),v=Math.round(f.y-h.y),y=Math.max(Math.abs(T),Math.abs(v));a=l(T>0?h.x+y/2:h.x-y/2,v>0?h.y+y/2:h.y-y/2),n=l(Math.abs(T)>Math.abs(v)?a.x-y/2:a.x,Math.abs(T)>Math.abs(v)?a.y:a.y-y/2)}const i=e.localToMap(a),p=e.localToMap(n);if(i==null||p==null)return null;e.doUnnormalization&&oe([[i,p]],e.spatialReference);const u=w(i,e.spatialReference),c=w(p,e.spatialReference),m=ie(e.spatialReference);let x=0;if(O(e.spatialReference))x=m*Re(u,c);else{const h=a.x-n.x,f=a.y-n.y;x=m*Math.sqrt(h*h+f*f)*(r||1)}const C=new Se({center:u,radius:x,radiusUnit:"meters",spatialReference:e.spatialReference});return{geometry:P(C.rings,C.spatialReference,!1),center:u,edge:c}}function Ze(t,e,s){const r=e.mapToLocalMultiple(t),o=r[0],a=r[1],n=Math.round(a.x-o.x),i=Math.round(a.y-o.y),p=l(s?o.x:o.x+n/2,s?o.y:o.y+i/2),u=s?n:n/2,c=s?i:i/2,m=60,x=[],C=2*Math.PI/m;function h(g){const D=Math.cos(g),J=Math.sin(g);return l(u*D+p.x,c*J+p.y)}for(let g=0;g<m;g++)x.push(h(g*C));x.push(x[0]);const{spatialReference:f,doUnnormalization:T}=e,v=P([x.map(g=>e.localToMap(g)).filter(z)],f,T,!1),y=e.localToMap(h(Math.PI/2)),H=e.localToMap(h(0)),_=e.localToMap(h(-Math.PI/2)),j=e.localToMap(h(Math.PI));return{geometry:v,midpoints:y!=null&&H!=null&&_!=null&&j!=null?{top:w(y,f),right:w(H,f),bottom:w(_,f),left:w(j,f)}:null}}export{Q as R,P as T,Ie as U,Pe as W,Ce as a,ze as b,Ue as j,Le as k,Ze as v};
