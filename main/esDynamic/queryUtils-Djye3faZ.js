import{bp as k,c_ as x,bI as c,fn as g,aj as m,fo as j,fp as U,L as q,fq as N,bw as O,aw as D,fr as E,ai as I,cV as d,aC as R,s as J,d5 as S,aD as L}from"./main-CnDVnExo.js";import{Q as P,V as w,L as V}from"./projectionUtils-B4YRVrjd.js";import{R as $}from"./normalizeUtils-CahpTq5j.js";import{t as _}from"./json-BI97KiBB.js";const f=[0,0];function v(t,n){if(!n)return null;if("x"in n){const s={x:0,y:0};return[s.x,s.y]=t(n.x,n.y,f),n.z!=null&&(s.z=n.z),n.m!=null&&(s.m=n.m),s}if("xmin"in n){const s={xmin:0,ymin:0,xmax:0,ymax:0};return[s.xmin,s.ymin]=t(n.xmin,n.ymin,f),[s.xmax,s.ymax]=t(n.xmax,n.ymax,f),n.hasZ&&(s.zmin=n.zmin,s.zmax=n.zmax,s.hasZ=!0),n.hasM&&(s.mmin=n.mmin,s.mmax=n.mmax,s.hasM=!0),s}return"rings"in n?{rings:b(n.rings,t),hasM:n.hasM,hasZ:n.hasZ}:"paths"in n?{paths:b(n.paths,t),hasM:n.hasM,hasZ:n.hasZ}:"points"in n?{points:B(n.points,t),hasM:n.hasM,hasZ:n.hasZ}:null}function b(t,n){const s=[];for(const a of t)s.push(B(a,n));return s}function B(t,n){const s=[];for(const a of t){const e=n(a[0],a[1],[0,0]);s.push(e),a.length>2&&e.push(a[2]),a.length>3&&e.push(a[3])}return s}async function p(t,n){if(!t||!n)return;const s=Array.isArray(t)?t.map(a=>a.geometry!=null?a.geometry.spatialReference:null).filter(k):[t];await P(s.map(a=>({source:a,dest:n})))}const F=v.bind(null,j),z=v.bind(null,U);function h(t,n,s,a){if(!t)return null;if(s||(s=n,n=t.spatialReference),!x(n)||!x(s)||c(n,s))return t;if(g(n,s)){const e=m(s)?F(t):z(t);return e.spatialReference=s,e}return w(_,[t],n,s,null,a)[0]}class C{constructor(){this._jobs=[],this._timer=null,this._process=this._process.bind(this)}async push(n,s,a,e){if(!n?.length||!s||!a||c(s,a))return n;const r={geometries:n,inSpatialReference:s,outSpatialReference:a,geographicTransformation:e,resolve:q()};return this._jobs.push(r),this._timer??=setTimeout(this._process,10),r.resolve.promise}_process(){this._timer=null;const n=this._jobs.shift();if(!n)return;const{geometries:s,inSpatialReference:a,outSpatialReference:e,resolve:r,geographicTransformation:o}=n;g(a,e)?m(e)?r(s.map(F)):r(s.map(z)):r(w(_,s,a,e,o,null)),this._jobs.length>0&&(this._timer=setTimeout(this._process,10))}}const K=new C;function Q(t,n,s,a){return K.push(t,n,s,a)}const M=new D({esriSRUnit_Meter:"meters",esriSRUnit_Kilometer:"kilometers",esriSRUnit_Foot:"feet",esriSRUnit_StatuteMile:"miles",esriSRUnit_NauticalMile:"nautical-miles",esriSRUnit_USNauticalMile:"us-nautical-miles"}),y=Object.freeze({}),G="frequency";async function H(t,n,s){const a=t.bin;return a.onField&&(a.onField=a.onField.trim()),a.onExpression?.value&&(a.onExpression.value=a.onExpression.value.trim()),a.splitBy&&(a.splitBy.value&&(a.splitBy.value=a.splitBy.value.trim()),a.splitBy.outAlias&&(a.splitBy.outAlias=a.splitBy.outAlias.trim())),a.stackBy&&(a.stackBy.value&&(a.stackBy.value=a.stackBy.value.trim()),a.stackBy.outAlias&&(a.stackBy.outAlias=a.stackBy.outAlias.trim())),"normalizationField"in a.parameters&&a.parameters.normalizationField&&(a.parameters.normalizationField=a.parameters.normalizationField.trim()),t.outStatistics?.length||(t.outStatistics=[{statisticType:"count",onStatisticField:"1",outStatisticFieldName:G}]),A(t,n,s)}async function A(t,n,s){const{outFields:a,orderByFields:e,groupByFieldsForStatistics:r,outStatistics:o}=t;if(a)for(let i=0;i<a.length;i++)a[i]=a[i].trim();if(e)for(let i=0;i<e.length;i++)e[i]=e[i].trim();if(r)for(let i=0;i<r.length;i++)r[i]=r[i].trim();if(o)for(let i=0;i<o.length;i++)o[i].onStatisticField&&(o[i].onStatisticField=o[i].onStatisticField.trim());return t.geometry&&!t.outSR&&(t.outSR=t.geometry.spatialReference),T(t,n,s)}async function T(t,n,s){if(!t)return null;let{where:a}=t;if(t.where=a=a?.trim(),(!a||/^1 *= *1$/.test(a)||n&&n===a)&&(t.where=null),!t.geometry)return t;let e=await X(t);if(t.distance=0,t.units=null,t.spatialRel==="esriSpatialRelEnvelopeIntersects"){const{spatialReference:r}=t.geometry;e=N(e),e.spatialReference=r}if(e){await p(e.spatialReference,s),e=W(e,s);const r=(await $(O(e)))[0];if(r==null)throw y;const o="quantizationParameters"in t&&t.quantizationParameters?.tolerance||"maxAllowableOffset"in t&&t.maxAllowableOffset||0,i=o&&Z(e,s)?{densificationStep:8*o}:void 0,l=r.toJSON(),u=h(l,l.spatialReference,s,i);if(!u)throw y;u.spatialReference=s,t.geometry=u}return t}function Z(t,n){if(!t)return!1;const s=t.spatialReference;return(S(t)||R(t)||L(t))&&!c(s,n)&&!V(s,n)}function W(t,n){const s=t.spatialReference;return Z(t,n)&&S(t)?{spatialReference:s,rings:[[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]]]}:t}async function X(t){const{distance:n,units:s}=t,a=t.geometry;if(n==null||"vertexAttributes"in a)return a;const e=a.spatialReference,r=s?M.fromJSON(s):E(e),o=e&&(I(e)||m(e))?a:await p(e,d).then(()=>h(a,d)),i=await import("./geodesicBufferOperator-McC9toTk.js");await i.load();const l=i.execute(o,n||1,{unit:r})??void 0;if(!l||!R(l)||l.rings.length===0)throw new J("unsupported-query:invalid-parameters","Invalid parameters for query by distance");return l}function Y(t,n){return t==null?null:typeof t=="string"?n?new Date(`1970-01-01T${t}Z`).getTime():new Date(t).getTime():t instanceof Date?t.getTime():t}export{T as B,y as S,A as a,Q as b,M as g,Y as h,h as j,H as w,p as x};
