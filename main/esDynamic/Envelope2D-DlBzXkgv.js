import{m as e,z as p,O as c,U as N,P as l,L as d}from"./Point2D-CaHJVGk1.js";class a{static construct(i,s,t,m){return new a(i,s,t,m)}constructor(i,s,t,m){this.m_EnvelopeType=2,i===void 0?(this.xmin=Number.NaN,this.ymin=Number.NaN,this.xmax=Number.NaN,this.ymax=Number.NaN):typeof i=="number"?(this.xmin=i,this.ymin=s,this.xmax=t,this.ymax=m):(this.xmin=i.xmin,this.ymin=i.ymin,this.xmax=i.xmax,this.ymax=i.ymax),this.normalize()}static constructEmpty(){return new a(Number.NaN,Number.NaN,Number.NaN,Number.NaN)}clone(){return new a(this)}assign(i){return this.xmin=i.xmin,this.xmax=i.xmax,this.ymin=i.ymin,this.ymax=i.ymax,this}width(){return this.xmax-this.xmin}height(){return this.ymax-this.ymin}maxDimension(){return Math.max(this.width(),this.height())}minDimension(){return Math.min(this.width(),this.height())}sqrDiagonal(){const i=this.width(),s=this.height();return i*i+s*s}diagonal(){return Math.sqrt(this.sqrDiagonal())}getCenterX(){return .5*(this.xmin+this.xmax)}getCenterY(){return .5*(this.ymin+this.ymax)}getCenter(){return e.construct(this.getCenterX(),this.getCenterY())}queryCenter(i){i.x=.5*(this.xmin+this.xmax),i.y=.5*(this.ymin+this.ymax)}setEmpty(){this.xmin=Number.NaN,this.ymin=Number.NaN,this.xmax=Number.NaN,this.ymax=Number.NaN}setInfinite(){this.xmin=Number.NEGATIVE_INFINITY,this.xmax=Number.POSITIVE_INFINITY,this.ymin=Number.NEGATIVE_INFINITY,this.ymax=Number.POSITIVE_INFINITY}isDegenerate(i){return!this.isEmpty()&&(this.width()<=i||this.height()<=i)}isZero(){return!(this.isEmpty()||this.width()&&this.height())}isEmpty(){return Number.isNaN(this.xmin)||Number.isNaN(this.ymin)||Number.isNaN(this.xmax)||Number.isNaN(this.ymax)}mergeNeCoords(i,s){this.xmin>i?this.xmin=i:this.xmax<i&&(this.xmax=i),this.ymin>s?this.ymin=s:this.ymax<s&&(this.ymax=s)}mergeNe(i){this.mergeNeCoords(i.x,i.y)}mergeCoords(i,s){this.isEmpty()?(this.xmin=i,this.ymin=s,this.xmax=i,this.ymax=s):(this.xmin>i?this.xmin=i:this.xmax<i&&(this.xmax=i),this.ymin>s?this.ymin=s:this.ymax<s&&(this.ymax=s))}merge(i){this.mergeCoords(i.x,i.y)}mergeEnvelope2D(i){i.isEmpty()||(this.mergeCoords(i.xmin,i.ymin),this.mergeNeCoords(i.xmax,i.ymax))}mergePoints(i,s){for(let t=0;t<s;){if(!this.isEmpty()){for(let m=t;m<s;m++)this.mergeNe(i[m]);break}this.setCoords(i[t]),t++}}mergePointsInterleaved(i,s,t){for(let m=2*s,n=m+2*t;m<n;m+=2)this.mergeCoords(i.read(m),i.read(m+1))}inflateCoords(i,s){this.isEmpty()||(this.xmin-=i,this.xmax+=i,this.ymin-=s,this.ymax+=s,(this.xmin>this.xmax||this.ymin>this.ymax)&&this.setEmpty())}getInflatedCoords(i,s){const t=this.clone();return t.inflateCoords(i,s),t}inflate(i){this.inflateCoords(i,i)}getInflated(i){const s=this.clone();return s.inflateCoords(i,i),s}zoom(i,s){this.isEmpty()||this.setCoords({center:this.getCenter(),width:i*this.width(),height:s*this.height()})}scale(i){i<0&&this.setEmpty(),this.xmin*=i,this.xmax*=i,this.ymin*=i,this.ymax*=i}equals(i,s){return!(!this.isEmpty()||!i.isEmpty())||(s?Math.abs(this.xmin-i.xmin)<=s&&Math.abs(this.ymin-i.ymin)<=s&&Math.abs(this.xmax-i.xmax)<=s&&Math.abs(this.ymax-i.ymax)<=s:this.xmin===i.xmin&&this.ymin===i.ymin&&this.xmax===i.xmax&&this.ymax===i.ymax)}setCoords(i){i.xmin!==void 0?(this.xmin=i.xmin,this.xmax=i.xmax,this.ymin=i.ymin,this.ymax=i.ymax):i.x!==void 0?(this.xmin=i.x,this.xmax=i.x,this.ymin=i.y,this.ymax=i.y):i.pt1!==void 0?(this.xmin=i.pt1.x,this.ymin=i.pt1.y,this.xmax=i.pt2.x,this.ymax=i.pt2.y,this.normalize()):i.env2D!==void 0?(this.xmin=i.env2D.xmin,this.xmax=i.env2D.xmax,this.ymin=i.env2D.ymin,this.ymax=i.env2D.ymax,this.normalize()):i.pt!==void 0?(this.xmin=i.pt.x,this.xmax=i.pt.x,this.ymin=i.pt.y,this.ymax=i.pt.y):i.center!==void 0?(this.xmin=i.center.x-.5*i.width,this.xmax=this.xmin+i.width,this.ymin=i.center.y-.5*i.height,this.ymax=this.ymin+i.height,this.normalize()):p("unrecognized input type for setCoords"),this.normalize()}queryIntervalX(i){this.isEmpty()?i.setEmpty():i.setCoords(this.xmin,this.xmax)}queryIntervalY(i){this.isEmpty()?i.setEmpty():i.setCoords(this.ymin,this.ymax)}setFromPoints(i,s){if(s===0)return void this.setEmpty();if(Array.isArray(i)){const m=i;this.setCoords(m[0]);for(let n=1;n<s;){if(!this.isEmpty()){for(let h=n;h<s;h++)this.mergeNe(m[h]);return}this.setCoords(m[n]),n++}return}const t=i;this.setCoords({x:t[0],y:t[1]});for(let m=1,n=2*s;m<n;m+=2){if(!this.isEmpty()){for(let h=m,x=2*s;h<x;h+=2)this.mergeNeCoords(t[h],t[h+1]);return}this.setCoords({x:t[m],y:t[m+1]}),m+=2}}normalize(){let i=!1;this.xmin<=this.xmax||([this.xmin,this.xmax]=[this.xmax,this.xmin],i=!0),this.ymin<=this.ymax||([this.ymin,this.ymax]=[this.ymax,this.ymin],i=!0),!i||this.xmin<=this.xmax&&this.ymin<=this.ymax||this.setEmpty()}isValid(){return this.isEmpty()||this.xmin<=this.xmax&&this.ymin<=this.ymax}getLowerLeft(){return new e(this.xmin,this.ymin)}getLowerRight(){return new e(this.xmax,this.ymin)}getUpperLeft(){return new e(this.xmin,this.ymax)}getUpperRight(){return new e(this.xmax,this.ymax)}move(i,s){this.isEmpty()||(this.xmin+=i,this.ymin+=s,this.xmax+=i,this.ymax+=s)}centerAtCoords(i,s){this.move(i-this.getCenterX(),s-this.getCenterY())}centerAt(i){this.centerAtCoords(i.x,i.y)}containsCoords(i,s){return i>=this.xmin&&i<=this.xmax&&s>=this.ymin&&s<=this.ymax}contains(i){return this.containsCoords(i.x,i.y)}containsEnvelope(i){return i.xmin>=this.xmin&&i.xmax<=this.xmax&&i.ymin>=this.ymin&&i.ymax<=this.ymax}containsExclusiveCoords(i,s){return i>this.xmin&&i<this.xmax&&s>this.ymin&&s<this.ymax}containsExclusive(i){return this.containsExclusiveCoords(i.x,i.y)}containsExclusiveEnvelope(i){return i.xmin>this.xmin&&i.xmax<this.xmax&&i.ymin>this.ymin&&i.ymax<this.ymax}isIntersecting(i){return(this.xmin<=i.xmin?this.xmax>=i.xmin:i.xmax>=this.xmin)&&(this.ymin<=i.ymin?this.ymax>=i.ymin:i.ymax>=this.ymin)}isIntersectingNe(i){return(this.xmin<=i.xmin?this.xmax>=i.xmin:i.xmax>=this.xmin)&&(this.ymin<=i.ymin?this.ymax>=i.ymin:i.ymax>=this.ymin)}intersect(i){if(this.isEmpty())return!1;if(i.isEmpty())return this.setEmpty(),!1;i.xmin>this.xmin&&(this.xmin=i.xmin),i.xmax<this.xmax&&(this.xmax=i.xmax),i.ymin>this.ymin&&(this.ymin=i.ymin),i.ymax<this.ymax&&(this.ymax=i.ymax);const s=this.xmin<=this.xmax&&this.ymin<=this.ymax;return s||this.setEmpty(),s}queryCorner(i){switch(3&i){case 0:return new e(this.xmin,this.ymin);case 1:return new e(this.xmin,this.ymax);case 2:return new e(this.xmax,this.ymax);default:return new e(this.xmax,this.ymin)}}queryCorners(i){i[0].setCoords(this.xmin,this.ymin),i[1].setCoords(this.xmin,this.ymax),i[2].setCoords(this.xmax,this.ymax),i[3].setCoords(this.xmax,this.ymin)}queryCornersReversed(i){i[0].setCoords(this.xmin,this.ymin),i[1].setCoords(this.xmax,this.ymin),i[2].setCoords(this.xmax,this.ymax),i[3].setCoords(this.xmin,this.ymax)}reaspect(i,s){if(this.isEmpty())return;const t=i/s,m=.5*this.width(),n=.5*this.height()*t;if(m<=n){const h=this.getCenterX();this.xmin=h-n,this.xmax=h+n}else{const h=m/t,x=this.getCenterY();this.ymin=x-h,this.ymax=x+h}this.normalize()}getArea(){return this.isEmpty()?0:this.width()*this.height()}getLength(){return this.isEmpty()?0:2*(this.width()+this.height())}clipCode(i){return(i.x<this.xmin?1:0)|(i.x>this.xmax?1:0)<<1|(i.y<this.ymin?1:0)<<2|(i.y>this.ymax?1:0)<<3}clipLine(i,s){let t=this.clipCode(i),m=this.clipCode(s);if(t&m)return 0;if(!(t|m))return 4;const n=(t?1:0)|(m?2:0);do{const h=s.x-i.x,x=s.y-i.y;if(Math.abs(h)>Math.abs(x)?t&a.XMASK?(t&a.XLESSXMIN?(i.y+=x*(this.xmin-i.x)/h,i.x=this.xmin):(i.y+=x*(this.xmax-i.x)/h,i.x=this.xmax),t=this.clipCode(i)):m&a.XMASK?(m&a.XLESSXMIN?(s.y+=x*(this.xmin-s.x)/h,s.x=this.xmin):(s.y+=x*(this.xmax-s.x)/h,s.x=this.xmax),m=this.clipCode(s)):t?(t&a.YLESSYMIN?(i.x+=h*(this.ymin-i.y)/x,i.y=this.ymin):(i.x+=h*(this.ymax-i.y)/x,i.y=this.ymax),t=this.clipCode(i)):(m&a.YLESSYMIN?(s.x+=h*(this.ymin-s.y)/x,s.y=this.ymin):(s.x+=h*(this.ymax-s.y)/x,s.y=this.ymax),m=this.clipCode(s)):t&a.YMASK?(t&a.YLESSYMIN?(i.x+=h*(this.ymin-i.y)/x,i.y=this.ymin):(i.x+=h*(this.ymax-i.y)/x,i.y=this.ymax),t=this.clipCode(i)):m&a.YMASK?(m&a.YLESSYMIN?(s.x+=h*(this.ymin-s.y)/x,s.y=this.ymin):(s.x+=h*(this.ymax-s.y)/x,s.y=this.ymax),m=this.clipCode(s)):t?(t&a.XLESSXMIN?(i.y+=x*(this.xmin-i.x)/h,i.x=this.xmin):(i.y+=x*(this.xmax-i.x)/h,i.x=this.xmax),t=this.clipCode(i)):(m&a.XLESSXMIN?(s.y+=x*(this.xmin-s.x)/h,s.x=this.xmin):(s.y+=x*(this.xmax-s.x)/h,s.x=this.xmax),m=this.clipCode(s)),t&m)return 0}while(t|m);return n}distanceFromEnvelope(i){return Math.sqrt(this.sqrDistanceEnvelope(i,null,null))}distance(i){return Math.sqrt(this.sqrDistance(i))}sqrDistanceEnvelope(i,s,t){if(!s&&!t){if(this.isEmpty()||i.isEmpty())return Number.NaN;let r,o=0,u=0;return r=this.xmin-i.xmax,r>o&&(o=r),r=this.ymin-i.ymax,r>u&&(u=r),r=i.xmin-this.xmax,r>o&&(o=r),r=i.ymin-this.ymax,r>u&&(u=r),o*o+u*u}if(this.isEmpty()||i.isEmpty())return s&&s.setNAN(),t&&t.setNAN(),Number.NaN;let m,n=0,h=0;const x=Math.max(this.xmin,i.xmin),y=Math.max(this.ymin,i.ymin);return s&&s.setCoords(x,y),t&&t.setCoords(x,y),m=this.xmin-i.xmax,m>n&&(n=m,s&&(s.x=this.xmin),t&&(t.x=i.xmax)),m=this.ymin-i.ymax,m>h&&(h=m,s&&(s.y=this.ymin),t&&(t.y=i.ymax)),m=i.xmin-this.xmax,m>n&&(n=m,s&&(s.x=this.xmax),t&&(t.x=i.xmin)),m=i.ymin-this.ymax,m>h&&(h=m,s&&(s.y=this.ymax),t&&(t.y=i.ymin)),n*n+h*h}sqrDistance(i,s){if(s===void 0){if(this.isEmpty()||i.isNAN())return Number.NaN;let h,x=0,y=0;return h=this.xmin-i.x,h>x&&(x=h),h=this.ymin-i.y,h>y&&(y=h),h=i.x-this.xmax,h>x&&(x=h),h=i.y-this.ymax,h>y&&(y=h),x*x+y*y}if(this.isEmpty()||i.isNAN())return s.setNAN(),Number.NaN;s.assign(i);let t,m=0,n=0;return t=this.xmin-i.x,t>m&&(m=t,s.x=this.xmin),t=this.ymin-i.y,t>n&&(n=t,s.y=this.ymin),t=i.x-this.xmax,t>m&&(m=t,s.x=this.xmax),t=i.y-this.ymax,t>n&&(n=t,s.y=this.ymax),m*m+n*n}sqrMaxMinDistanceEnvelope(i){if(this.isEmpty()||i.isEmpty())return Number.NaN;let s=Number.MAX_VALUE;{const t=e.sqrDistanceCoords(this.xmin,this.ymin,i.xmax,i.ymin),m=e.sqrDistanceCoords(this.xmin,this.ymin,i.xmax,i.ymax),n=e.sqrDistanceCoords(this.xmin,this.ymax,i.xmax,i.ymin),h=e.sqrDistanceCoords(this.xmin,this.ymax,i.xmax,i.ymax),x=Math.max(t,m),y=Math.max(n,h),r=Math.max(x,y);s=Math.min(r,s)}{const t=e.sqrDistanceCoords(this.xmin,this.ymin,i.xmin,i.ymax),m=e.sqrDistanceCoords(this.xmin,this.ymin,i.xmax,i.ymax),n=e.sqrDistanceCoords(this.xmax,this.ymin,i.xmin,i.ymax),h=e.sqrDistanceCoords(this.xmax,this.ymin,i.xmax,i.ymax),x=Math.max(t,m),y=Math.max(n,h),r=Math.max(x,y);s=Math.min(r,s)}{const t=e.sqrDistanceCoords(this.xmax,this.ymin,i.xmin,i.ymin),m=e.sqrDistanceCoords(this.xmax,this.ymin,i.xmin,i.ymax),n=e.sqrDistanceCoords(this.xmax,this.ymax,i.xmin,i.ymin),h=e.sqrDistanceCoords(this.xmax,this.ymax,i.xmin,i.ymax),x=Math.max(t,m),y=Math.max(n,h),r=Math.max(x,y);s=Math.min(r,s)}{const t=e.sqrDistanceCoords(this.xmin,this.ymax,i.xmin,i.ymin),m=e.sqrDistanceCoords(this.xmin,this.ymax,i.xmax,i.ymin),n=e.sqrDistanceCoords(this.xmax,this.ymax,i.xmin,i.ymin),h=e.sqrDistanceCoords(this.xmax,this.ymax,i.xmax,i.ymin),x=Math.max(t,m),y=Math.max(n,h),r=Math.max(x,y);s=Math.min(r,s)}return s}sqrMaxDistanceEnvelope(i){if(this.isEmpty()||i.isEmpty())return Number.NaN;let s=0;const t=c(e,4);this.queryCorners(t);const m=c(e,4);i.queryCorners(m);for(let n=0;n<4;n++)for(let h=0;h<4;h++){const x=e.sqrDistance(t[n],m[h]);x>s&&(s=x)}return s}sqrMaxMinDistance(i){const s=e.sqrDistance(i,this.getLowerLeft()),t=e.sqrDistance(i,this.getUpperLeft()),m=e.sqrDistance(i,this.getLowerRight()),n=e.sqrDistance(i,this.getUpperRight());let h,x=Math.max(s,t);return h=Math.max(s,m),x>h&&(x=h),h=Math.max(t,n),x>h&&(x=h),h=Math.max(m,n),x>h&&(x=h),x}sqrMinDistance(i){return this.contains(i)?0:this.sqrDistance(i)}sqrMaxDistance(i){let s=e.sqrDistance(i,this.getLowerLeft());return s=Math.max(e.sqrDistance(i,this.getUpperLeft()),s),s=Math.max(e.sqrDistance(i,this.getUpperRight()),s),s=Math.max(e.sqrDistance(i,this.getLowerRight()),s),s}snapToBoundary(i){if(i.isNAN())return!1;if(this.isEmpty())return i.setNAN(),!0;let s=!0;if(i.x<this.xmin?i.x=this.xmin:i.x>this.xmax?i.x=this.xmax:s=!1,i.y<this.ymin?i.y=this.ymin:i.y>this.ymax?i.y=this.ymax:s=!1,s)return!0;if(i.x===this.xmin||i.x===this.xmax||i.y===this.ymin||i.y===this.ymax)return!1;const t=this.xmax-i.x,m=i.x-this.xmin,n=this.ymax-i.y,h=i.y-this.ymin;return Math.max(t,m)>Math.max(n,h)?i.y=h<n?this.ymin:this.ymax:i.x=m<t?this.xmin:this.xmax,!0}snapClip(i){const s=N(i.x,this.xmin,this.xmax),t=N(i.y,this.ymin,this.ymax);return e.construct(s,t)}boundaryDistance(i){if(this.isEmpty()||i.isNAN())return Number.NaN;if(i.x===this.xmin)return i.y-this.ymin;const s=this.ymax-this.ymin,t=this.xmax-this.xmin;if(i.y===this.ymax)return s+i.x-this.xmin;if(i.x===this.xmax)return s+t+this.ymax-i.y;if(i.y===this.ymin)return 2*s+t+this.xmax-i.x;const m=new e;return m.setCoordsPoint2D(i),this.snapToBoundary(m),this.boundaryDistance(m)}envelopeSide(i){if(this.isEmpty())return-1;let s=this.boundaryDistance(i);const t=this.ymax-this.ymin,m=this.xmax-this.xmin;return s<t?0:(s-=t)<m?1:s-m<t?2:3}querySide(i,s){switch(i){case 0:s.constructFromCoords(this.xmin,this.ymin,this.xmin,this.ymax);break;case 1:s.constructFromCoords(this.xmin,this.ymax,this.xmax,this.ymax);break;case 2:s.constructFromCoords(this.xmax,this.ymax,this.xmax,this.ymin);break;case 3:s.constructFromCoords(this.xmax,this.ymin,this.xmin,this.ymin);break;default:l("query_side")}return s}isPointOnBoundary(i,s){return Math.abs(i.x-this.xmin)<=s||Math.abs(i.x-this.xmax)<=s||Math.abs(i.y-this.ymin)<=s||Math.abs(i.y-this.ymax)<=s}calculateToleranceFromEnvelope(){return this.isEmpty()?d():(Math.abs(this.xmin)+Math.abs(this.xmax)+Math.abs(this.ymin)+Math.abs(this.ymax)+1)*d()}toString(){return`[${this.xmin}, ${this.ymin}, ${this.xmax}, ${this.ymax}]`}}a.XLESSXMIN=1,a.YLESSYMIN=4,a.XMASK=3,a.YMASK=12;export{a as Envelope2D};
