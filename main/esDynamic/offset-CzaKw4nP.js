import{convertToSpatialReferenceUnit as y,toLengthUnit as R}from"./unitConversion-2l1knzxj.js";import{w as u}from"./operatorOffset-CMhPy0cY.js";import{fromGeometry as E,getSpatialReference as G,fromSpatialReference as d,toGeometry as g}from"./apiConverter-DPFCeb7X.js";import{fromGeometry as h,toGeometry as x}from"./jsonConverter-CCOLtWma.js";const l={round:0,bevel:1,miter:2,square:3};function S(r,t,n,e,i,s){t=y(R(n),r.spatialReference,t);const f=E(r),m=G(r),a=v(f,d(m),t,e,i,s);return g(a,m)}function b(r,t,n,e,i,s){t=y(R(n),r.spatialReference,t);const f=h(r),m=f.getGeometry(),a=f.getSpatialReference(),c=v(m,a,t,e,i,s);return x(c,a)}function v(r,t,n,e,i,s){const f=u(r,t,n,l[e],i,s);if(!f.isEmpty())return f;{const o=r.clone();o.reverseAllPaths();const p=u(o,t,-n,l[e],i,s);if(!p.isEmpty())return p.reverseAllPaths(),p}const m=Math.abs(n)/10,a=m/10;let c=s;if(e==="round"&&(c+=a),e==="bevel"||e==="square"){const o=u(r,t,n,l[e="miter"],i,s);if(!o.isEmpty())return o}if(e==="miter"){const o=u(r,t,n,l[e="round"],i,s);if(!o.isEmpty())return o}if(e==="round")for(;c<=m;c+=a){const o=u(r,t,n,l[e],i,c);if(!o.isEmpty())return o}return null}export{S as executeOffset,b as executeOffsetJson};
