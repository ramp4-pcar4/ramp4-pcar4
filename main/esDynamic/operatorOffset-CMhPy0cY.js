import{t as N,s as Q}from"./SimpleGeometryCursor-DSF_YyIm.js";import{B as V,b as O,u as q,z as $}from"./ProjectionTransformation-D_aEWxWN.js";import{j as Z,b as z,a as w,f as tt,z as st,m as A,W as d,K as G,h as et,i as it}from"./Point2D-BVUQyGsf.js";function nt(x,t,i,n,s,o){if(x===null&&z(""),x.getDimension()<1&&z(""),s>0||z(""),Z(x),t===0||x.isEmpty())return x;const h=new P(o);return h.m_bUseZ=x.hasAttribute(1),h.m_bUseM=x.hasAttribute(2),h.m_inputGeometry=x,h.m_distance=t,h.m_tolerance=s,h.m_joins=i,h.m_miterLimit=n>1?n:1,h.m_progressCounter=0,h.constructOffset()}const T=1.4142135623730951,D=.017453292519943295,E=256,X=512,v=1024;class M{static construct(t,i,n){const s=new M;return s.x=t.x,s.y=t.y,s.m_next=-1,s.m_prev=-1,s.z=i,s.m=n,s.type=0,s}clone(){const t=new M;return t.x=this.x,t.y=this.y,t.m_next=this.m_next,t.m_prev=this.m_prev,t.z=this.z,t.m=this.m,t.type=this.type,t}asPoint2D(){return new A(this.x,this.y)}}function ot(){return{pt:new M,bAtExistingPt:!1}}class P{constructor(t){this.m_distance=-1,this.m_tolerance=-1,this.m_miterLimit=10,this.m_joins=0,this.m_progressCounter=0,this.m_bUseZ=!1,this.m_bUseM=!1,this.m_srcPts=[],this.m_srcPtCount=0,this.m_offsetPts=[],this.m_offsetPtCount=0,this.m_a1=0,this.m_a2=0,this.m_progressTracker=t}constructOffset(){const t=this.m_inputGeometry.getGeometryType();if(t===w.enumLine)return this.offsetLine();if(t===w.enumEnvelope)return this.offsetEnvelope();if(tt(t)){const i=new O;return i.addSegment(this.m_inputGeometry,!0),this.m_inputGeometry=i,this.constructOffset()}if(t===w.enumPolyline){const i=new O;return this.offsetMultiPath(i),i}if(t===w.enumPolygon){const i=new q;return this.offsetMultiPath(i),i}st("")}offsetLine(){const t=this.m_inputGeometry,i=t.getStartXY(),n=t.getEndXY(),s=new A;s.setSub(n,i),s.normalize(),s.leftPerpendicularThis(),s.scale(this.m_distance),i.addThis(s),n.addThis(s);const o=t.clone();return o.setStartXY(i),o.setEndXY(n),o}offsetEnvelope(){const t=this.m_inputGeometry;if(this.m_distance>0&&this.m_joins!==2){const n=new q;return n.addEnvelope(t,!1),this.m_inputGeometry=n,this.constructOffset()}const i=t.clone();return i.inflateCoords(this.m_distance,this.m_distance),i}progress(){}static buildPoint(t,i,n,s){s.x=t.x+i*Math.cos(n),s.y=t.y+i*Math.sin(n),s.type=t.type,s.z=t.z,s.m=t.m,s.m_next=-1,s.m_prev=-1}addPoint(t){this.m_offsetPts.push(t.clone()),this.m_offsetPtCount++}addPointEx(t,i){if(this.m_offsetPtCount===0)return void this.addPoint(t);const n=this.m_srcPtCount,s=this.m_srcPts[i===0?n-1:i-1],o=this.m_srcPts[i],h=P.dotSign(s,o,this.m_offsetPts[this.m_offsetPtCount-1],t);if(h>0)this.addPoint(t);else if(h<0)if(P.dotSign(s,o,o,this.m_offsetPts[this.m_offsetPtCount-1])>0){const e=new M;let r;r=i===0?n-2:i===1?n-1:i-2;const u=this.m_srcPts[r],c=Math.atan2(s.y-u.y,s.x-u.x);if(P.buildPoint(s,this.m_distance,c-d,e),this.m_offsetPts[this.m_offsetPtCount-1]=e.clone(),this.m_joins===1||this.m_joins===2){e.x=.5*(e.x+s.x),e.y=.5*(e.y+s.y),this.addPoint(e),P.buildPoint(s,this.m_distance,this.m_a1+d,e);const m=e.clone();m.x=.5*(m.x+s.x),m.y=.5*(m.y+s.y),m.type|=E,this.addPoint(m),this.addPoint(e)}else P.buildPoint(s,this.m_distance,this.m_a1+d,e),e.type|=E,this.addPoint(e);this.addPointEx(t,i)}else{const e=new M;if(P.buildPoint(o,this.m_distance,this.m_a1+d,e),this.addPoint(e),this.m_joins===1||this.m_joins===2){e.x=.5*(e.x+o.x),e.y=.5*(e.y+o.y),this.addPoint(e),P.buildPoint(o,this.m_distance,this.m_a2-d,e);const r=e.clone();r.x=.5*(r.x+o.x),r.y=.5*(r.y+o.y),r.type|=E,this.addPoint(r),this.addPoint(e)}else P.buildPoint(o,this.m_distance,this.m_a2-d,e),e.type|=E,this.addPoint(e)}}buildOffset(){const t=new M,i=this.m_srcPtCount;this.m_offsetPtCount=0;const n=.5*this.m_tolerance;let s=0,o=0;for(let h=0;h<i;h++){const e=this.m_srcPts[h],r=h===0?this.m_srcPts[i-1]:this.m_srcPts[h-1],u=h===i-1?this.m_srcPts[0]:this.m_srcPts[h+1];let c,m,b=0;{const f=r.x-e.x,a=r.y-e.y,_=u.x-e.x,l=u.y-e.y;c=Math.atan2(a,f),m=Math.atan2(l,_),this.m_a1=c,this.m_a2=m,h===0&&(s=c,o=m),b=A.orientationRobust(e.asPoint2D(),r.asPoint2D(),u.asPoint2D())}const g=m;if(m<c&&(m+=G),!(Math.abs(Math.abs(c-m)-Math.PI)<1e-8))if(b*this.m_distance>0)if(this.m_joins===1||this.m_joins===2){P.buildPoint(e,this.m_distance,c+d,t),this.addPoint(t);const f=.001;t.x=e.x+(t.x-e.x)*f,t.y=e.y+(t.y-e.y)*f,this.addPoint(t),P.buildPoint(e,this.m_distance,m-d,t);const a=t.clone();a.x=e.x+(a.x-e.x)*f,a.y=e.y+(a.y-e.y)*f,a.type|=E,this.addPoint(a),this.addPoint(t)}else{const f=.5*(m-c),a=f===0?this.m_distance:this.m_distance/Math.abs(Math.sin(f));P.buildPoint(e,a,.5*(c+m),t),this.addPointEx(t,h)}else{if(e.type&X){const f=1-n/Math.abs(this.m_distance);let a=1,_=this.m_distance<0?-Math.PI:Math.PI;if(f>-1&&f<1){let p=2*Math.acos(f);p<D&&(p=D),a=Math.trunc(Math.PI/p+1.5),a>1&&(_/=a)}a<=1&&(a=2,_/=2);let l=c+d;P.buildPoint(e,this.m_distance,l,t),h===0&&(t.type|=v),this.addPointEx(t,h);const y=this.m_distance/Math.cos(_/2);for(l+=_/2,P.buildPoint(e,y,l,t),t.type|=v,this.addPoint(t);--a>0;)l+=_,P.buildPoint(e,y,l,t),t.type|=v,this.addPoint(t);P.buildPoint(e,this.m_distance,m-d,t),t.type|=v,this.addPoint(t);continue}if(this.m_joins!==1){if(this.m_joins===0){const f=1-n/Math.abs(this.m_distance);let a=1,_=m-d-(c+d);if(f>-1&&f<1){let p=2*Math.acos(f);p<D&&(p=D),a=Math.trunc(Math.abs(_)/p+1.5),a>1&&(_/=a)}const l=this.m_distance/Math.cos(.5*_);let y=c+d+.5*_;for(P.buildPoint(e,l,y,t),this.addPointEx(t,h);--a>0;)y+=_,P.buildPoint(e,l,y,t),this.addPoint(t);continue}if(this.m_joins===2){const f=r.x-e.x,a=r.y-e.y,_=u.x-e.x,l=u.y-e.y;let y=(f*_+a*l)/Math.sqrt(f*f+a*a)/Math.sqrt(_*_+l*l);if(y=Math.max(y,-1),y>1-1e-8){P.buildPoint(e,T*this.m_distance,m-.25*Math.PI,t),this.addPointEx(t,h),P.buildPoint(e,T*this.m_distance,m+.25*Math.PI,t),this.addPoint(t);continue}const p=Math.abs(this.m_distance/Math.sin(.5*Math.acos(y))),I=Math.abs(this.m_miterLimit*this.m_distance);if(p>I){const F=.5*(m-c),K=this.m_distance/Math.abs(Math.sin(F));P.buildPoint(e,K,.5*(c+m),t);const W=A.construct(t.x,t.y),Y=A.construct(e.x,e.y),C=new A;C.setSub(W,Y);const U=new A;U.setScaleAdd(I/C.length(),C,Y);const H=Math.sqrt(p*p-this.m_distance*this.m_distance),J=(p-I)*Math.abs(this.m_distance)/H;this.m_distance>0?C.rightPerpendicularThis():C.leftPerpendicularThis(),C.scale(J/C.length());const j=new A;j.setAdd(U,C);const S=new A;S.setSub(U,C),t.x=j.x,t.y=j.y,this.addPointEx(t,h),t.x=S.x,t.y=S.y,this.addPoint(t);continue}const R=.5*(m-c),B=this.m_distance/Math.abs(Math.sin(R));P.buildPoint(e,B,.5*(c+m),t),this.addPointEx(t,h);continue}{let f;if(m=g,this.m_distance>0?(m>c&&(m-=G),f=c-m<d):(m<c&&(m+=G),f=m-c<d),f){const a=this.m_distance*T;let _;_=a<0?c+.25*Math.PI:c+3*Math.PI*.25,P.buildPoint(e,a,_,t),this.addPointEx(t,h),_=a<0?m-.25*Math.PI:m-3*Math.PI*.25,P.buildPoint(e,a,_,t),this.addPoint(t)}else{const a=.5*(m-c),_=this.m_distance/Math.abs(Math.sin(a));m<c&&(m+=G),P.buildPoint(e,_,(c+m)/2,t),this.addPointEx(t,h)}}}else P.buildPoint(e,this.m_distance,c+d,t),this.addPointEx(t,h),P.buildPoint(e,this.m_distance,m-d,t),this.addPoint(t)}}return this.m_a1=s,this.m_a2=o,this.addPointEx(this.m_offsetPts[0],0),this.m_offsetPts[0]=this.m_offsetPts[this.m_offsetPtCount-1].clone(),this.removeBadSegsFast()}removeBadSegsFast(){let t=!1;for(let n=0;n<this.m_offsetPtCount;n++){const s=this.m_offsetPts[n];s.m_next=n+1,s.m_prev=n-1}this.m_offsetPts[0].m_prev=this.m_offsetPtCount-2,this.m_offsetPts[this.m_offsetPtCount-2].m_next=0;let i=0;for(let n=0;n<this.m_offsetPtCount;n++)if(this.m_offsetPts[i].type&E){const s=this.deleteClosedSeg(i);if(s===-1){t=!0;break}i=s}else i=this.m_offsetPts[i].m_next;return!t&&(this.compressOffsetArray(i),!0)}deleteClosedSeg(t){const i=this.m_offsetPtCount-1;let n,s,o=t;for(let h=1;h<=i-2;h++){o=this.m_offsetPts[o].m_next,n=o,s=t;for(let e=1;e<=h;e++){if(s=this.m_offsetPts[s].m_prev,(this.m_offsetPts[s].type&E)===0&&(this.m_offsetPts[n].type&E)===0){const r=this.handleClosedIntersection(s,n);if(r!==-1)return r}n=this.m_offsetPts[n].m_prev}}return-1}handleClosedIntersection(t,i){const n=this.m_offsetPts[this.m_offsetPts[t].m_prev],s=this.m_offsetPts[t],o=this.m_offsetPts[this.m_offsetPts[i].m_prev],h=this.m_offsetPts[i];if(!this.sectGraphicRect(n,s,o,h))return-1;const e=ot();if(((s.x-n.x)*(h.y-o.y)-(s.y-n.y)*(h.x-o.x))*this.m_distance<0&&this.findIntersection(n,s,o,h,e)&&!e.bAtExistingPt){const r=Math.sqrt((s.x-n.x)*(s.x-n.x)+(s.y-n.y)*(s.y-n.y)),u=(s.x-n.x)/r,c=(s.y-n.y)/r,m=Math.sqrt((h.x-o.x)*(h.x-o.x)+(h.y-o.y)*(h.y-o.y)),b=(h.x-o.x)/m,g=(h.y-o.y)/m;let f=!1;const a=e.pt.clone();a.x+=(u+b)*1e-8,a.y+=(c+g)*1e-8;let _=o,l=e.pt,y=this.m_offsetPts[t].m_prev;for(;l.y>a.y!=_.y>a.y&&a.x<(_.x-l.x)*(a.y-l.y)/(_.y-l.y)+l.x&&(f=!f),_=l,y=this.m_offsetPts[y].m_next,y!==i;)l=this.m_offsetPts[y];if(f)return-1;const p=this.m_offsetPts[t].m_prev;return e.pt.type=s.type,e.pt.m_next=i,e.pt.m_prev=p,this.m_offsetPts[t]=e.pt,this.m_offsetPts[i].m_prev=t,i}return-1}sectGraphicRect(t,i,n,s){return Math.max(t.x,i.x)>=Math.min(n.x,s.x)&&Math.max(n.x,s.x)>=Math.min(t.x,i.x)&&Math.max(t.y,i.y)>=Math.min(n.y,s.y)&&Math.max(n.y,s.y)>=Math.min(t.y,i.y)}findIntersection(t,i,n,s,o){let h,e,r,u;return o.bAtExistingPt=!1,h=(i.y-t.y)*(s.x-n.x)-(i.x-t.x)*(s.y-n.y),e=(n.y-t.y)*(i.x-t.x)-(n.x-t.x)*(i.y-t.y),r=h===0?2:e/h,r>=0&&r<=1&&(u=r,h=(s.y-n.y)*(i.x-t.x)-(s.x-n.x)*(i.y-t.y),e=(t.y-n.y)*(s.x-n.x)-(t.x-n.x)*(s.y-n.y),r=h===0?2:e/h,r>=0&&r<=1)&&(o.pt.x=t.x+r*(i.x-t.x),o.pt.y=t.y+r*(i.y-t.y),this.m_bUseZ&&(o.pt.z=n.z+u*(s.z-n.z)),this.m_bUseM&&(o.pt.m=n.m+u*(s.m-n.m)),u!==0&&u!==1||r!==0&&r!==1||(o.bAtExistingPt=!0),!((u===0||u===1)&&r>0&&r<1||(r===0||r===1)&&u>0&&u<1))}compressOffsetArray(t){for(;this.m_offsetPts[t].m_prev<t;)t=this.m_offsetPts[t].m_prev;let i=0,n=t;do{const s=this.m_offsetPts[n].clone();this.m_offsetPts[i]=s,n=s.m_next,i++}while(n!==t);this.m_offsetPts[i]=this.m_offsetPts[0].clone(),this.m_offsetPtCount=i+1}addPart(t,i){if(!(i<2))for(let n=0;n<i;n++){const s=this.m_offsetPts[t+n];if(n?this.m_bUseZ?this.m_resultPath.lineTo3DCoords(s.x,s.y,s.z):this.m_resultPath.lineToCoords(s.x,s.y):this.m_bUseZ?this.m_resultPath.startPath3DCoords(s.x,s.y,s.z):this.m_resultPath.startPathCoords(s.x,s.y),this.m_bUseM){const o=this.m_resultPath.getPointCount()-1;this.m_resultPath.setAttribute(2,o,0,s.m)}}}offsetMultiPath(t){const i=$(this.m_inputGeometry,0,this.m_tolerance,0,this.m_progressTracker,12e3),n=i.querySegmentIterator();n.resetToFirstPath();let s=-1;for(;n.nextPath();)s++,this.offsetPath(i,s,t)}offsetPath(t,i,n){let s=t.getPathStart(i),o=t.getPathEnd(i);if(this.m_resultPath=n,t.isClosedPath(i)){const h=t.getXY(s);for(;o>s&&t.getXY(o-1).equals(h);)o--;if(o-s>=2){this.m_srcPtCount=o-s,this.m_srcPts.length=this.m_srcPtCount;for(let e=s;e<o;e++)this.progress(),this.m_srcPts[e-s]=M.construct(t.getXY(e),this.m_bUseZ?t.getAttributeAsDbl(1,e,0):0,this.m_bUseM?t.getAttributeAsDbl(2,e,0):0);this.buildOffset()&&this.addPart(0,this.m_offsetPtCount-1)}}else{const h=t.getXY(s);for(;s<o-1&&t.getXY(s+1).equals(h);)s++;const e=t.getXY(o-1);for(;s<o-1&&t.getXY(o-2).equals(e);)o--;if(o-s>=2){this.m_srcPtCount=2*(o-s)-2,this.m_srcPts.length=this.m_srcPtCount;let r=M.construct(h,this.m_bUseZ?t.getAttributeAsDbl(1,s,0):0,this.m_bUseM?t.getAttributeAsDbl(2,s,0):0);r.type|=X+v,this.m_srcPts[0]=r;let u=1,c=this.m_srcPtCount-1;for(let m=s+1;m<o-1;m++,u++,c--)this.progress(),r=M.construct(t.getXY(m),this.m_bUseZ?t.getAttributeAsDbl(1,m,0):0,this.m_bUseM?t.getAttributeAsDbl(2,m,0):0),this.m_srcPts[u]=r.clone(),r.type|=v,this.m_srcPts[c]=r.clone();if(r=M.construct(t.getXY(o-1),this.m_bUseZ?t.getAttributeAsDbl(1,o-1,0):0,this.m_bUseM?t.getAttributeAsDbl(2,o-1,0):0),r.type|=X,this.m_srcPts[u]=r.clone(),this.buildOffset())if(this.m_offsetPts.length>=2){let m=-1,b=-1,g=(this.m_offsetPts[this.m_offsetPtCount-1].type&v)!==0;g||(m=0);for(let f=1;f<this.m_offsetPtCount;f++){this.progress();const a=(this.m_offsetPts[f].type&v)!==0;a?g||(b=f-1,b-m+1>1&&this.addPart(m,b-m+1)):g&&(m=f-1),g=a}g||(b=this.m_offsetPtCount-1,b-m+1>1&&this.addPart(m,b-m+1))}else{const m=this.m_offsetPtCount-1;m-0>=1&&this.addPart(0,m-0+1)}}}this.m_srcPts.length=0,this.m_srcPtCount=0,this.m_offsetPts.length=0,this.m_offsetPtCount=0}static dotSign(t,i,n,s){const o=i.x-t.x,h=i.y-t.y,e=s.x-n.x,r=s.y-n.y,u=et(o,h,e,r);return it(u)}}class ht{getOperatorType(){return 10108}accelerateGeometry(t,i,n){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}executeMany(t,i,n,s,o,h,e){return new L(t,i,n,s,o,h,e)}execute(t,i,n,s,o,h,e){return new L(null,i,n,s,o,h,e).offset(t)}}class L extends N{constructor(t,i,n,s,o,h,e){super(),this.m_progressTracker=e,this.m_index=-1,this.m_inputGeoms=t,this.m_spatialReference=i,this.m_distance=n,this.m_joins=s,this.m_miterLimit=o,this.m_flattenError=h}tock(){return!0}getRank(){return 1}next(){if(!this.m_inputGeoms)return null;let t;for(;t=this.m_inputGeoms.next();)return this.m_index=this.m_inputGeoms.getGeometryID(),this.offset(t);return null}getGeometryID(){return this.m_index}offset(t){let i;return Z(t),i=this.m_flattenError<=0?V(this.m_spatialReference,t,!0).total():this.m_flattenError,nt(t,this.m_distance,this.m_joins,this.m_miterLimit,i,this.m_progressTracker)}}const k=new ht;function mt(x,t,i,n,s,o){return k.execute(x,t,i,n,s,o,null)}function rt(x,t,i,n,s,o){const h=k.executeMany(new Q(x),t,i,n,s,o,null);return Array.from(h)}export{rt as j,mt as w};
