import{dH as j,fA as q,fB as B,fC as C,fD as H,fE as z,ew as N,bw as s,bx as i,bz as D,ap as F,fF as G,aq as I,dC as l,fG as k,dX as E,fH as P,by as T}from"./main-CzbArNue.js";import{e as y}from"./mat4f64-CSKppSlJ.js";import{v as M,b as p,x as U}from"./quat-DOwnX5ja.js";import{e as x}from"./quatf64-aQ5IuZRd.js";function a(t=w){return[t[0],t[1],t[2],t[3]]}function c(t,o,n=a()){return j(n,t),n[3]=o,n}function Q(t,o=a()){const n=z(e,t);return v(o,N(M(o,n))),o}function A(t,o,n=a()){return p(e,t,f(t)),p(b,o,f(o)),U(e,b,e),v(n,N(M(n,e)))}function R(t,o,n,m=a()){return c(q,t,u),c(B,o,$),c(C,n,d),A(u,$,u),A(u,d,m),m}function S(t){return t}function X(t){return t[3]}function f(t){return H(t[3])}function v(t,o){return t[3]=o,t}const w=[0,0,1,0],e=x(),b=x();a();const u=a(),$=a(),d=a();var h;let r=h=class extends D{constructor(t){super(t),this.translation=F(),this.rotationAxis=G(w),this.rotationAngle=0,this.scale=I(1,1,1)}get rotation(){return c(this.rotationAxis,this.rotationAngle)}set rotation(t){this.rotationAxis=l(t),this.rotationAngle=X(t)}get localMatrix(){const t=y();return p(g,this.rotation,f(this.rotation)),k(t,g,this.translation,this.scale),t}get localMatrixInverse(){return E(y(),this.localMatrix)}equals(t){return this===t||t!=null&&P(this.localMatrix,t.localMatrix)}clone(){const t={translation:l(this.translation),rotationAxis:l(this.rotationAxis),rotationAngle:this.rotationAngle,scale:l(this.scale)};return new h(t)}};s([i({type:[Number],nonNullable:!0,json:{write:!0}})],r.prototype,"translation",void 0),s([i({type:[Number],nonNullable:!0,json:{write:!0}})],r.prototype,"rotationAxis",void 0),s([i({type:Number,nonNullable:!0,json:{write:!0}})],r.prototype,"rotationAngle",void 0),s([i({type:[Number],nonNullable:!0,json:{write:!0}})],r.prototype,"scale",void 0),s([i()],r.prototype,"rotation",null),s([i()],r.prototype,"localMatrix",null),s([i()],r.prototype,"localMatrixInverse",null),r=h=s([T("esri.geometry.support.MeshTransform")],r);const g=x(),V=r;export{V as N,R as d,a as j,Q as k,S as w,f as z};
