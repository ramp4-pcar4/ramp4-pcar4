import{h7 as O,ci as x,aY as v,bE as C,h8 as k}from"./main-DCIX61zy.js";import{O as F}from"./quat-Xt9oEsiT.js";import{e as R}from"./quatf64-C16JxGFv.js";import{t as A,n as w}from"./vec3f32-BS0cezmI.js";import{a as U,b as B,d as J}from"./PointCloudUniqueValueRenderer-xBokarMf.js";import{w as N,l as V,c as T,I as q}from"./I3SBinaryReader-B-IG1_cG.js";import{I as z}from"./orientedBoundingBox-CdpnVLBk.js";function E(f,e,l,n){const{rendererJSON:c,isRGBRenderer:m}=f;let t=null,u=null;if(e&&m)t=e;else if(e&&c?.type==="pointCloudUniqueValueRenderer"){u=U.fromJSON(c);const r=u.colorUniqueValueInfos;t=new Uint8Array(3*n);const s=g(u.fieldTransformType);for(let o=0;o<n;o++){const a=(s?s(e[o]):e[o])+"";for(let i=0;i<r.length;i++)if(r[i].values.includes(a)){t[3*o]=r[i].color.r,t[3*o+1]=r[i].color.g,t[3*o+2]=r[i].color.b;break}}}else if(e&&c?.type==="pointCloudStretchRenderer"){u=B.fromJSON(c);const r=u.stops;t=new Uint8Array(3*n);const s=g(u.fieldTransformType);for(let o=0;o<n;o++){const a=s?s(e[o]):e[o],i=r.length-1;if(a<r[0].value)t[3*o]=r[0].color.r,t[3*o+1]=r[0].color.g,t[3*o+2]=r[0].color.b;else if(a>=r[i].value)t[3*o]=r[i].color.r,t[3*o+1]=r[i].color.g,t[3*o+2]=r[i].color.b;else for(let b=1;b<r.length;b++)if(a<r[b].value){const p=(a-r[b-1].value)/(r[b].value-r[b-1].value);t[3*o]=r[b].color.r*p+r[b-1].color.r*(1-p),t[3*o+1]=r[b].color.g*p+r[b-1].color.g*(1-p),t[3*o+2]=r[b].color.b*p+r[b-1].color.b*(1-p);break}}}else if(e&&c?.type==="pointCloudClassBreaksRenderer"){u=J.fromJSON(c);const r=u.colorClassBreakInfos;t=new Uint8Array(3*n);const s=g(u.fieldTransformType);for(let o=0;o<n;o++){const a=s?s(e[o]):e[o];for(let i=0;i<r.length;i++)if(a>=r[i].minValue&&a<=r[i].maxValue){t[3*o]=r[i].color.r,t[3*o+1]=r[i].color.g,t[3*o+2]=r[i].color.b;break}}}else t=new Uint8Array(3*n).fill(255);if(l&&u?.colorModulation){const r=u.colorModulation.minValue,s=u.colorModulation.maxValue,o=.3;for(let a=0;a<n;a++){const i=l[a],b=i>=s?1:i<=r?o:o+(1-o)*(i-r)/(s-r);t[3*a]=b*t[3*a],t[3*a+1]=b*t[3*a+1],t[3*a+2]=b*t[3*a+2]}}return t}function Y(f,e){if(f.encoding==null||f.encoding===""){const l=N(e,f);if(l.vertexAttributes.position==null)return;const n=V(e,l.vertexAttributes.position),c=l.header.fields,m=[c.offsetX,c.offsetY,c.offsetZ],t=[c.scaleX,c.scaleY,c.scaleZ],u=n.length/3,r=new Float64Array(3*u);for(let s=0;s<u;s++)r[3*s]=n[3*s]*t[0]+m[0],r[3*s+1]=n[3*s+1]*t[1]+m[1],r[3*s+2]=n[3*s+2]*t[2]+m[2];return r}if(f.encoding==="lepcc-xyz")return T(e).result}function h(f,e,l){return f?.attributeInfo.useElevation?e?X(e,l):null:f?.attributeInfo.storageInfo?q(f.attributeInfo.storageInfo,f.buffer,l):null}function X(f,e){const l=new Float64Array(e);for(let n=0;n<e;n++)l[n]=f[3*n+2];return l}function Z(f,e,l,n,c){const m=f.length/3;let t=0;for(let u=0;u<m;u++){let r=!0;for(let s=0;s<n.length&&r;s++){const{filterJSON:o}=n[s],a=c[s].values[u];switch(o.type){case"pointCloudValueFilter":{const i=o.mode==="exclude";o.values.includes(a)===i&&(r=!1);break}case"pointCloudBitfieldFilter":{const i=M(o.requiredSetBits),b=M(o.requiredClearBits);((a&i)!==i||a&b)&&(r=!1);break}case"pointCloudReturnFilter":{const i=15&a,b=a>>>4&15,p=b>1,S=i===1,y=i===b;let I=!1;for(const d of o.includedReturns)if(d==="last"&&y||d==="firstOfMany"&&S&&p||d==="lastOfMany"&&y&&p||d==="single"&&!p){I=!0;break}I||(r=!1);break}}}r&&(l[t]=u,f[3*t]=f[3*u],f[3*t+1]=f[3*u+1],f[3*t+2]=f[3*u+2],e[3*t]=e[3*u],e[3*t+1]=e[3*u+1],e[3*t+2]=e[3*u+2],t++)}return t}function g(f){switch(f){default:case null:case"none":return e=>e;case"low-four-bit":return e=>15&e;case"high-four-bit":return e=>(240&e)>>4;case"absolute-value":return e=>Math.abs(e);case"modulo-ten":return e=>e%10}}function M(f){let e=0;for(const l of f||[])e|=1<<l;return e}class _{transform(e){const l=this._transform(e),n=[l.points.buffer,l.rgb.buffer];l.pointIdFilterMap!=null&&n.push(l.pointIdFilterMap.buffer);for(const c of l.attributes)"buffer"in c.values&&O(c.values.buffer)&&c.values.buffer!==l.rgb.buffer&&n.push(c.values.buffer);return Promise.resolve({result:l,transferList:n})}_transform(e){const l=Y(e.schema,e.geometryBuffer);let n=l.length/3,c=null;const m=new Array,t=h(e.primaryAttributeData,l,n);e.primaryAttributeData!=null&&t&&m.push({attributeInfo:e.primaryAttributeData.attributeInfo,values:t});const u=h(e.modulationAttributeData,l,n);e.modulationAttributeData!=null&&u&&m.push({attributeInfo:e.modulationAttributeData.attributeInfo,values:u});let r=E(e.rendererInfo,t,u,n);if(e.filterInfo&&e.filterInfo.length>0&&e.filterAttributesData!=null){const o=e.filterAttributesData.filter(x).map(a=>{const i=h(a,l,n),b={attributeInfo:a.attributeInfo,values:i};return m.push(b),b});c=new Uint32Array(n),n=Z(l,r,c,e.filterInfo,o)}for(const o of e.userAttributesData){const a=h(o,l,n);m.push({attributeInfo:o.attributeInfo,values:a})}3*n<r.length&&(r=new Uint8Array(r.buffer.slice(0,3*n))),G(l,n,e.elevationOffset);const s=j(l,n,z.fromData(e.obbData),v.fromJSON(e.inSR),v.fromJSON(e.outSR));return{obbData:e.obbData,points:s,rgb:r,attributes:m,pointIdFilterMap:c}}}function j(f,e,l,n,c){if(!C(f,n,0,f,c,0,e))throw new Error("Can't reproject");const m=A(l.center),t=w(),u=w(),r=A(l.halfSize);F(D,l.quaternion);const s=new Float32Array(3*e);for(let o=0;o<e;o++){let a=3*o;t[0]=f[a]-m[0],t[1]=f[a+1]-m[1],t[2]=f[a+2]-m[2],k(u,t,D),r[0]=Math.max(r[0],Math.abs(u[0])),r[1]=Math.max(r[1],Math.abs(u[1])),r[2]=Math.max(r[2],Math.abs(u[2])),s[a++]=t[0],s[a++]=t[1],s[a]=t[2]}return l.halfSize=r,s}function G(f,e,l){if(l!==0)for(let n=0;n<e;n++)f[3*n+2]+=l}const D=R();function L(){return new _}export{L as default};
