{"version":3,"file":"form-DdIDvPV9.js","sources":["../../node_modules/@esri/calcite-components/dist/components/form.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.\n * v2.13.2\n */\nimport { h } from '@stencil/core/internal/client';\nimport { q as queryElementRoots, c as closestElementCrossShadowBoundary } from './dom.js';\n\n/**\n * Any form <Component> with a `calcite<Component>Input` event needs to be included in this array.\n */\nconst componentsWithInputEvent = [\n    \"calcite-input\",\n    \"calcite-input-number\",\n    \"calcite-input-text\",\n    \"calcite-text-area\",\n];\n/**\n * Get the event name to listen for that, when emitted, will clear the\n * validation message that displays after form submission. Only validation\n * messages that are set by the browser will be cleared. If a user sets\n * validationMessage to a custom value, they are responsible for clearing it.\n *\n * Exported for testing purposes.\n *\n * @param componentTag the tag of the component, e.g. \"calcite-input\"\n * @returns the event name\n */\nfunction getClearValidationEventName(componentTag) {\n    const componentTagCamelCase = componentTag\n        .split(\"-\")\n        .map((part, index) => index === 0 ? part : `${part[0].toUpperCase()}${part.slice(1)}`)\n        .join(\"\");\n    const clearValidationEvent = `${componentTagCamelCase}${componentsWithInputEvent.includes(componentTag) ? \"Input\" : \"Change\"}`;\n    return clearValidationEvent;\n}\n/**\n * Exported for testing purposes.\n */\nconst hiddenFormInputSlotName = \"hidden-form-input\";\nfunction isCheckable(component) {\n    return \"checked\" in component;\n}\nconst onFormResetMap = new WeakMap();\nconst formComponentSet = new WeakSet();\n/**\n * This helps determine if our form component is part of a composite form-associated component.\n *\n * @param form\n * @param formComponentEl\n */\nfunction hasRegisteredFormComponentParent(form, formComponentEl) {\n    // if we have a parent component using the form ID attribute, we assume it is form-associated\n    const hasParentComponentWithFormIdSet = closestElementCrossShadowBoundary(formComponentEl.parentElement, \"[form]\");\n    if (hasParentComponentWithFormIdSet) {\n        return true;\n    }\n    // we use events as a way to test for nested form-associated components across shadow bounds\n    const formComponentRegisterEventName = \"calciteInternalFormComponentRegister\";\n    let hasRegisteredFormComponentParent = false;\n    form.addEventListener(formComponentRegisterEventName, (event) => {\n        hasRegisteredFormComponentParent = event\n            .composedPath()\n            .some((element) => formComponentSet.has(element));\n        event.stopPropagation();\n    }, { once: true });\n    formComponentEl.dispatchEvent(new CustomEvent(formComponentRegisterEventName, {\n        bubbles: true,\n        composed: true,\n    }));\n    return hasRegisteredFormComponentParent;\n}\nfunction displayValidationMessage(component, { status, message, icon }) {\n    if (\"status\" in component) {\n        component.status = status;\n    }\n    if (\"validationIcon\" in component && typeof component.validationIcon !== \"string\") {\n        component.validationIcon = icon;\n    }\n    if (\"validationMessage\" in component && !component.validationMessage) {\n        component.validationMessage = message;\n    }\n}\nfunction getValidationComponent(el) {\n    // radio-button is formAssociated, but the validation props are on the parent group\n    if (el.nodeName === \"CALCITE-RADIO-BUTTON\") {\n        return closestElementCrossShadowBoundary(el, \"calcite-radio-button-group\");\n    }\n    return el;\n}\nconst invalidEvent = new CustomEvent(\"calciteInvalid\", { bubbles: true, composed: true });\nfunction invalidHandler(event) {\n    // target is the hidden input, which is slotted in the actual form component\n    const hiddenInput = event?.target;\n    const hiddenInputMessage = hiddenInput?.validationMessage;\n    // not necessarily a calcite-input, but we don't have an HTMLCalciteFormAssociatedElement type\n    const formComponent = getValidationComponent(hiddenInput?.parentElement);\n    if (!formComponent) {\n        return;\n    }\n    const componentTag = formComponent?.nodeName?.toLowerCase();\n    const componentTagParts = componentTag?.split(\"-\");\n    if (componentTagParts.length < 2 || componentTagParts[0] !== \"calcite\") {\n        return;\n    }\n    // prevent the browser from showing the native validation popover\n    event?.preventDefault();\n    if (\"validity\" in formComponent) {\n        formComponent.validity = hiddenInput?.validity;\n    }\n    // dispatch a \"calciteInvalid\" so users can set custom validation messages\n    formComponent.dispatchEvent(invalidEvent);\n    displayValidationMessage(formComponent, {\n        message: hiddenInputMessage,\n        icon: true,\n        status: \"invalid\",\n    });\n    const clearValidationEvent = getClearValidationEventName(componentTag);\n    formComponent.addEventListener(clearValidationEvent, () => {\n        if (\"status\" in formComponent) {\n            formComponent.status = \"idle\";\n        }\n        if (\"validationIcon\" in formComponent && !formComponent.validationIcon) {\n            formComponent.validationIcon = false;\n        }\n        if (\"validationMessage\" in formComponent &&\n            formComponent.validationMessage === hiddenInputMessage) {\n            formComponent.validationMessage = \"\";\n        }\n        if (\"validity\" in formComponent) {\n            formComponent.validity = hiddenInput?.validity;\n        }\n    }, { once: true });\n}\n/**\n * Helper to submit a form.\n *\n * @param component\n * @returns true if its associated form was submitted, false otherwise.\n */\nfunction submitForm(component) {\n    const { formEl } = component;\n    if (!formEl) {\n        return false;\n    }\n    formEl.addEventListener(\"invalid\", invalidHandler, true);\n    formEl.requestSubmit();\n    formEl.removeEventListener(\"invalid\", invalidHandler, true);\n    requestAnimationFrame(() => {\n        const invalidEls = formEl.querySelectorAll(\"[status=invalid]\");\n        // focus the first invalid element that has a validation message\n        for (const el of invalidEls) {\n            if (el?.validationMessage) {\n                el?.setFocus();\n                break;\n            }\n        }\n    });\n    return true;\n}\n/**\n * Helper to reset a form.\n *\n * @param component\n */\nfunction resetForm(component) {\n    component.formEl?.reset();\n}\n/**\n * Helper to set up form interactions on connectedCallback.\n *\n * @param component\n */\nfunction connectForm(component) {\n    const { el, value } = component;\n    const associatedForm = findAssociatedForm(component);\n    if (!associatedForm || hasRegisteredFormComponentParent(associatedForm, el)) {\n        return;\n    }\n    component.formEl = associatedForm;\n    component.defaultValue = value;\n    if (isCheckable(component)) {\n        component.defaultChecked = component.checked;\n    }\n    const boundOnFormReset = (component.onFormReset || onFormReset).bind(component);\n    associatedForm.addEventListener(\"reset\", boundOnFormReset);\n    onFormResetMap.set(component.el, boundOnFormReset);\n    formComponentSet.add(el);\n}\n/**\n * Utility method to find a form-component's associated form element.\n *\n * @param component\n */\nfunction findAssociatedForm(component) {\n    const { el, form } = component;\n    return form\n        ? queryElementRoots(el, { id: form })\n        : closestElementCrossShadowBoundary(el, \"form\");\n}\nfunction onFormReset() {\n    if (\"status\" in this) {\n        this.status = \"idle\";\n    }\n    if (\"validationIcon\" in this) {\n        this.validationIcon = false;\n    }\n    if (\"validationMessage\" in this) {\n        this.validationMessage = \"\";\n    }\n    if (isCheckable(this)) {\n        this.checked = this.defaultChecked;\n        return;\n    }\n    this.value = this.defaultValue;\n}\n/**\n * Helper to tear down form interactions on disconnectedCallback.\n *\n * @param component\n */\nfunction disconnectForm(component) {\n    const { el, formEl } = component;\n    if (!formEl) {\n        return;\n    }\n    const boundOnFormReset = onFormResetMap.get(el);\n    formEl.removeEventListener(\"reset\", boundOnFormReset);\n    onFormResetMap.delete(el);\n    component.formEl = null;\n    formComponentSet.delete(el);\n}\n/**\n * Helper for setting the default value on initialization after connectedCallback.\n *\n * Note that this is only needed if the default value cannot be determined on connectedCallback.\n *\n * @param component\n * @param value\n */\nfunction afterConnectDefaultValueSet(component, value) {\n    component.defaultValue = value;\n}\nconst internalHiddenInputInputEvent = \"calciteInternalHiddenInputInput\";\nconst hiddenInputInputHandler = (event) => {\n    event.target.dispatchEvent(new CustomEvent(internalHiddenInputInputEvent, { bubbles: true }));\n};\nconst removeHiddenInputChangeEventListener = (input) => input.removeEventListener(\"input\", hiddenInputInputHandler);\n/**\n * Helper for maintaining a form-associated's hidden input in sync with the component.\n *\n * Based on Ionic's approach: https://github.com/ionic-team/ionic-framework/blob/e4bf052794af9aac07f887013b9250d2a045eba3/core/src/utils/helpers.ts#L198\n *\n * @param component\n */\nfunction syncHiddenFormInput(component) {\n    const { el, formEl, name, value } = component;\n    const { ownerDocument } = el;\n    const inputs = el.querySelectorAll(`input[slot=\"${hiddenFormInputSlotName}\"]`);\n    if (!formEl || !name) {\n        inputs.forEach((input) => {\n            removeHiddenInputChangeEventListener(input);\n            input.remove();\n        });\n        return;\n    }\n    const values = Array.isArray(value) ? value : [value];\n    const extra = [];\n    const seen = new Set();\n    inputs.forEach((input) => {\n        const valueMatch = values.find((val) => \n        /* intentional non-strict equality check */\n        val == input.value);\n        if (valueMatch != null) {\n            seen.add(valueMatch);\n            defaultSyncHiddenFormInput(component, input, valueMatch);\n        }\n        else {\n            extra.push(input);\n        }\n    });\n    let docFrag;\n    values.forEach((value) => {\n        if (seen.has(value)) {\n            return;\n        }\n        let input = extra.pop();\n        if (!input) {\n            input = ownerDocument.createElement(\"input\");\n            input.slot = hiddenFormInputSlotName;\n        }\n        if (!docFrag) {\n            docFrag = ownerDocument.createDocumentFragment();\n        }\n        docFrag.append(input);\n        // emits when hidden input is autofilled\n        input.addEventListener(\"input\", hiddenInputInputHandler);\n        defaultSyncHiddenFormInput(component, input, value);\n    });\n    if (docFrag) {\n        el.append(docFrag);\n    }\n    extra.forEach((input) => {\n        removeHiddenInputChangeEventListener(input);\n        input.remove();\n    });\n}\nfunction defaultSyncHiddenFormInput(component, input, value) {\n    const { defaultValue, disabled, form, name, required } = component;\n    // keep in sync to prevent losing reset value\n    input.defaultValue = defaultValue;\n    input.disabled = disabled;\n    input.name = name;\n    input.required = required;\n    input.tabIndex = -1;\n    // we set the attr as the prop is read-only\n    if (form) {\n        input.setAttribute(\"form\", form);\n    }\n    else {\n        input.removeAttribute(\"form\");\n    }\n    if (isCheckable(component)) {\n        input.checked = component.checked;\n        // keep in sync to prevent losing reset value\n        input.defaultChecked = component.defaultChecked;\n        // heuristic to support default/on mode from https://html.spec.whatwg.org/multipage/input.html#dom-input-value-default-on\n        input.value = component.checked ? value || \"on\" : \"\";\n    }\n    else {\n        input.value = value || \"\";\n    }\n    component.syncHiddenFormInput?.(input);\n    const validationComponent = getValidationComponent(component.el);\n    if (validationComponent && \"validity\" in validationComponent) {\n        // mutate the component's validity object to prevent a rerender\n        // https://stenciljs.com/docs/properties#mutable-arrays-and-objects\n        for (const key in { ...input?.validity }) {\n            validationComponent.validity[key] = input.validity[key];\n        }\n    }\n}\n/**\n * Helper to render the slot for form-associated component's hidden input.\n *\n * If the component has a default slot, this must be placed at the bottom of the component's root container to ensure it is the last child.\n *\n * render(): VNode {\n *   <Host>\n *     <div class={CSS.container}>\n *     // ...\n *     <HiddenFormInputSlot component={this} />\n *     </div>\n *   </Host>\n * }\n *\n * Note that the hidden-form-input Sass mixin must be added to the component's style to apply specific styles.\n *\n * @param root0\n * @param root0.component\n */\nconst HiddenFormInputSlot = ({ component, }) => {\n    syncHiddenFormInput(component);\n    return h(\"slot\", { name: hiddenFormInputSlotName });\n};\n\nexport { HiddenFormInputSlot as H, afterConnectDefaultValueSet as a, connectForm as c, disconnectForm as d, findAssociatedForm as f, internalHiddenInputInputEvent as i, resetForm as r, submitForm as s };\n\n//# sourceMappingURL=form.js.map"],"names":["componentsWithInputEvent","getClearValidationEventName","componentTag","part","index","hiddenFormInputSlotName","isCheckable","component","onFormResetMap","formComponentSet","hasRegisteredFormComponentParent","form","formComponentEl","closestElementCrossShadowBoundary","formComponentRegisterEventName","event","element","displayValidationMessage","status","message","icon","getValidationComponent","el","invalidEvent","invalidHandler","hiddenInput","hiddenInputMessage","formComponent","componentTagParts","clearValidationEvent","submitForm","formEl","invalidEls","resetForm","connectForm","value","associatedForm","findAssociatedForm","boundOnFormReset","onFormReset","queryElementRoots","disconnectForm","internalHiddenInputInputEvent","hiddenInputInputHandler","removeHiddenInputChangeEventListener","input","syncHiddenFormInput","name","ownerDocument","inputs","values","extra","seen","valueMatch","val","defaultSyncHiddenFormInput","docFrag","defaultValue","disabled","required","validationComponent","key","HiddenFormInputSlot","h"],"mappings":"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","x_google_ignoreList":[0]}