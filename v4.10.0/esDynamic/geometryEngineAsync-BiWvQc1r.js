import{D as f,f1 as w,f2 as h}from"./main-DCIX61zy.js";function r(n){return Array.isArray(n)?n[0]?.spatialReference:n?.spatialReference}function l(n){return n&&(Array.isArray(n)?n.map(l):n.toJSON?n.toJSON():n)}function c(n){return Array.isArray(n)?n.map(t=>w(t)):w(n)}function S(n,t){let e;return Array.isArray(n)?e=n:(e=[],e.push(n),t!=null&&e.push(t)),e}let p;async function d(){return p||(p=h("geometryEngineWorker",{strategy:"distributed"})),p}async function a(n,t){return(await d()).invoke("executeGEOperation",{operation:n,parameters:l(t)})}async function m(n,t){const e=await d();return Promise.all(e.broadcast("executeGEOperation",{operation:n,parameters:l(t)}))}function R(n){return a("extendedSpatialReferenceInfo",[n])}async function x(n,t){return c(await a("clip",[r(n),n,t]))}async function A(n,t){return c(await a("cut",[r(n),n,t]))}function O(n,t){return a("contains",[r(n),n,t])}function D(n,t){return a("crosses",[r(n),n,t])}function J(n,t,e){return a("distance",[r(n),n,t,e])}function N(n,t){return a("equals",[r(n),n,t])}function L(n,t){return a("intersects",[r(n),n,t])}function T(n,t){return a("touches",[r(n),n,t])}function V(n,t){return a("within",[r(n),n,t])}function v(n,t){return a("disjoint",[r(n),n,t])}function E(n,t){return a("overlaps",[r(n),n,t])}function b(n,t,e){return a("relate",[r(n),n,t,e])}function z(n){return a("isSimple",[r(n),n])}async function H(n){return c(await a("simplify",[r(n),n]))}async function I(n,t=!1){return c(await a("convexHull",[r(n),n,t]))}async function P(n,t){return c(await a("difference",[r(n),n,t]))}async function j(n,t){return c(await a("symmetricDifference",[r(n),n,t]))}async function k(n,t){return c(await a("intersect",[r(n),n,t]))}async function q(n,t=null){const e=S(n,t);return c(await a("union",[r(e),e]))}async function B(n,t,e,i,s,u){return c(await a("offset",[r(n),n,t,e,i,s,u]))}async function C(n,t,e,i=!1){const s=[r(n),n,t,e,i];return c(await a("buffer",s))}async function G(n,t,e,i,s,u){const g=[r(n),n,t,e,i,s,u];return c(await a("geodesicBuffer",g))}async function W(n,t,e=!0){const i=await a("nearestCoordinate",[r(n),n,t,e]);return{...i,coordinate:f.fromJSON(i.coordinate)}}async function F(n,t){const e=await a("nearestVertex",[r(n),n,t]);return{...e,coordinate:f.fromJSON(e.coordinate)}}async function K(n,t,e,i){return(await a("nearestVertices",[r(n),n,t,e,i])).map(s=>({...s,coordinate:f.fromJSON(s.coordinate)}))}function y(n){return"xmin"in n?n.center:"x"in n?n:n.extent?.center}async function M(n,t,e){if(n==null)throw new o;const i=n.spatialReference;if((e=e??y(n))==null)throw new o;const s=n.constructor.fromJSON(await a("rotate",[i,n,t,e]));return s.spatialReference=i,s}async function Q(n,t){if(n==null)throw new o;const e=n.spatialReference;if((t=t??y(n))==null)throw new o;const i=n.constructor.fromJSON(await a("flipHorizontal",[e,n,t]));return i.spatialReference=e,i}async function U(n,t){if(n==null)throw new o;const e=n.spatialReference;if((t=t??y(n))==null)throw new o;const i=n.constructor.fromJSON(await a("flipVertical",[e,n,t]));return i.spatialReference=e,i}async function X(n,t,e,i){return c(await a("generalize",[r(n),n,t,e,i]))}async function Y(n,t,e){return c(await a("densify",[r(n),n,t,e]))}async function Z(n,t,e,i=0){return c(await a("geodesicDensify",[r(n),n,t,e,i]))}function _(n,t){return a("planarArea",[r(n),n,t])}function $(n,t){return a("planarLength",[r(n),n,t])}function nn(n,t,e){return a("geodesicArea",[r(n),n,t,e])}function tn(n,t,e){return a("geodesicLength",[r(n),n,t,e])}async function en(n,t){return c(await a("intersectLinesToPoints",[r(n),n,t]))}async function an(n,t){await m("changeDefaultSpatialReferenceTolerance",[n,t])}async function rn(n){await m("clearDefaultSpatialReferenceTolerance",[n])}class o extends Error{constructor(){super("Illegal Argument Exception")}}export{C as buffer,an as changeDefaultSpatialReferenceTolerance,rn as clearDefaultSpatialReferenceTolerance,x as clip,O as contains,I as convexHull,D as crosses,A as cut,Y as densify,P as difference,v as disjoint,J as distance,N as equals,R as extendedSpatialReferenceInfo,Q as flipHorizontal,U as flipVertical,X as generalize,nn as geodesicArea,G as geodesicBuffer,Z as geodesicDensify,tn as geodesicLength,k as intersect,en as intersectLinesToPoints,L as intersects,z as isSimple,W as nearestCoordinate,F as nearestVertex,K as nearestVertices,B as offset,E as overlaps,_ as planarArea,$ as planarLength,b as relate,M as rotate,H as simplify,j as symmetricDifference,T as touches,q as union,V as within};
