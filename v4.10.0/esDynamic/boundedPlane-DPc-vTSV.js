import{aq as E,dA as V,dF as u,dC as l,dE as d,dP as ts,dQ as w,dR as rs,dS as P,dT as es,dU as cs,al as p,dB as _,H as O,dV as us,dW as gs,dX as m,dY as bs,dZ as F,ao as H,dD as W,ap as T,G as fs}from"./main-DCIX61zy.js";import{s as Y,w as ls}from"./sphere-_Zcui0FU.js";import{e as Z}from"./mat4f64-Dn1WEGBx.js";import{v as ds,A as G,M as ps}from"./lineSegment-CMEPBlyR.js";import{M as v,D as ms,h as hs,P as q,c as r,U as Is,x as Ps,q as Ms,w as Ns,z as K,H as ws,f as y,O as A,y as Ts}from"./plane-B2J4G_40.js";const C=()=>fs.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");class vs{constructor(){this.plane=v(),this.origin=T(),this.basis1=T(),this.basis2=T()}}const ys=vs;function h(s=os){return{plane:v(s.plane),origin:V(s.origin),basis1:V(s.basis1),basis2:V(s.basis2)}}function As(s,i,n){const a=Ds.get();return a.origin=s,a.basis1=i,a.basis2=n,a.plane=ms(0,0,0,0),N(a),a}function M(s,i=h()){return j(s.origin,s.basis1,s.basis2,i)}function Ss(s,i){u(i.origin,s.origin),u(i.basis1,s.basis1),u(i.basis2,s.basis2),hs(i.plane,s.plane)}function j(s,i,n,a=h()){return u(a.origin,s),u(a.basis1,i),u(a.basis2,n),N(a),Us(a,"fromValues()"),a}function N(s){q(s.basis2,s.basis1,s.origin,s.plane)}function L(s,i,n){s!==n&&M(s,n);const a=l(r.get(),f(s),i);return d(n.origin,n.origin,a),n.plane[3]-=i,n}function xs(s,i,n){return X(i,n),L(n,k(s,s.origin),n),n}function Es(s,i){const n=s.basis1[0],a=s.basis2[1],[o,t]=s.origin;return ts(o-n,t-a,o+n,t+a,i)}function X(s,i=h()){const n=(s[2]-s[0])/2,a=(s[3]-s[1])/2;return w(i.origin,s[0]+n,s[1]+a,0),w(i.basis1,n,0,0),w(i.basis2,0,a,0),Is(0,0,1,0,i.plane),i}function B(s,i,n){return!!Ps(s.plane,i,n)&&ns(s,n)}function Vs(s,i,n){if(B(s,i,n))return n;const a=J(s,i,r.get());return d(n,i.origin,l(r.get(),i.direction,rs(i.origin,a)/P(i.direction))),n}function J(s,i,n){const a=S.get();as(s,i,a,S.get());let o=Number.POSITIVE_INFINITY;for(const t of z){const e=U(s,t,x.get()),g=r.get();if(Ms(a,e,g)){const c=es(r.get(),i.origin,g),b=Math.abs(cs(p(i.direction,c)));b<o&&(o=b,u(n,g))}}return o===Number.POSITIVE_INFINITY?Q(s,i,n):n}function _s(s,i){return(i-s)/i}function Q(s,i,n){if(B(s,i,n))return n;const a=S.get(),o=S.get();as(s,i,a,o);let t=Number.POSITIVE_INFINITY;for(const e of z){const g=U(s,e,x.get()),c=r.get();if(Ns(a,g,c)){const b=ls(i,c);if(!K(o,c))continue;b<t&&(t=b,u(n,c))}}return R(s,i.origin)<t&&$(s,i.origin,n),n}function $(s,i,n){const a=ws(s.plane,i,r.get()),o=G(is(s,s.basis1),a,-1,1,r.get()),t=G(is(s,s.basis2),a,-1,1,r.get());return _(n,d(r.get(),o,t),s.origin),n}function ss(s,i,n){const{origin:a,basis1:o,basis2:t}=s,e=_(r.get(),i,a),g=y(o,e),c=y(t,e),b=y(f(s),e);return w(n,g,c,b)}function R(s,i){const n=ss(s,i,r.get()),{basis1:a,basis2:o}=s,t=P(a),e=P(o),g=Math.max(Math.abs(n[0])-t,0),c=Math.max(Math.abs(n[1])-e,0),b=n[2];return g*g+c*c+b*b}function Os(s,i){return Math.sqrt(R(s,i))}function Fs(s,i){let n=Number.NEGATIVE_INFINITY;for(const a of z){const o=U(s,a,x.get()),t=ps(o,i);t>n&&(n=t)}return Math.sqrt(n)}function Ys(s,i){return K(s.plane,i)&&ns(s,i)}function qs(s,i,n,a){return ks(s,n,a)}function k(s,i){const n=-s.plane[3];return y(f(s),i)-n}function Cs(s,i,n,a){const o=k(s,i),t=l(zs,f(s),n-o);return d(a,i,t),a}function js(s,i){return O(s.basis1,i.basis1)&&O(s.basis2,i.basis2)&&O(s.origin,i.origin)}function Bs(s,i,n){return s!==n&&M(s,n),us(I,i),gs(I,I),m(n.basis1,s.basis1,I),m(n.basis2,s.basis2,I),m(A(n.plane),A(s.plane),I),m(n.origin,s.origin,i),Ts(n.plane,n.plane,n.origin),n}function Rs(s,i,n,a){return s!==a&&M(s,a),bs(D,i,n),m(a.basis1,s.basis1,D),m(a.basis2,s.basis2,D),N(a),a}function f(s){return A(s.plane)}function ks(s,i,n){switch(i){case F.X:u(n,s.basis1),H(n,n);break;case F.Y:u(n,s.basis2),H(n,n);break;case F.Z:u(n,f(s))}return n}function ns(s,i){const n=_(r.get(),i,s.origin),a=W(s.basis1),o=W(s.basis2),t=p(s.basis1,n),e=p(s.basis2,n);return-t-a<0&&t-a<0&&-e-o<0&&e-o<0}function is(s,i){const n=x.get();return u(n.origin,s.origin),u(n.vector,i),n}function U(s,i,n){const{basis1:a,basis2:o,origin:t}=s,e=l(r.get(),a,i.origin[0]),g=l(r.get(),o,i.origin[1]);d(n.origin,e,g),d(n.origin,n.origin,t);const c=l(r.get(),a,i.direction[0]),b=l(r.get(),o,i.direction[1]);return l(n.vector,d(c,c,b),2),n}function Us(s,i){Math.abs(p(s.basis1,s.basis2)/(P(s.basis1)*P(s.basis2)))>1e-6&&C().warn(i,"Provided basis vectors are not perpendicular"),Math.abs(p(s.basis1,f(s)))>1e-6&&C().warn(i,"Basis vectors and plane normal are not perpendicular"),Math.abs(-p(f(s),s.origin)-s.plane[3])>1e-6&&C().warn(i,"Plane offset is not consistent with plane origin")}function as(s,i,n,a){const o=f(s);q(o,i.direction,i.origin,n),q(A(n),o,i.origin,a)}const os={plane:v(),origin:E(0,0,0),basis1:E(1,0,0),basis2:E(0,1,0)},S=new Y(v),x=new Y(ds),zs=T(),Ds=new Y(()=>h()),z=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],I=Z(),D=Z(),Hs=Object.freeze(Object.defineProperty({__proto__:null,BoundedPlaneClass:ys,altitudeAt:k,axisAt:qs,cameraFrustumCoverage:_s,closestPoint:Q,closestPointOnSilhouette:J,copy:M,copyWithoutVerify:Ss,create:h,distance:Os,distance2:R,distanceToSilhouette:Fs,elevate:L,equals:js,extrusionContainsPoint:Ys,fromAABoundingRect:X,fromValues:j,getExtent:Es,intersectRay:B,intersectRayClosestSilhouette:Vs,normal:f,projectPoint:$,projectPointLocal:ss,rotate:Rs,setAltitudeAt:Cs,setExtent:xs,transform:Bs,up:os,updateUnboundedPlane:N,wrap:As},Symbol.toStringTag,{value:"Module"}));export{j as J,N as K,h as W,M as Z,Hs as k};
