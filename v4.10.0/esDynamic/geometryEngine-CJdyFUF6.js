import{aZ as p,aY as l}from"./main-DCIX61zy.js";import{G as t}from"./geometryEngineBase-DDJcGEx2.js";import{hydratedAdapter as r}from"./hydrated-Bw6jVxCj.js";function i(n){const e=Array.isArray(n)?n[0].spatialReference:n.spatialReference;return e?p(l,e):l.WGS84}function d(n){return t.extendedSpatialReferenceInfo(n)}function m(n,e){return t.clip(r,i(n),n,e)}function g(n,e){return t.cut(r,i(n),n,e)}function h(n,e){return t.contains(r,i(n),n,e)}function w(n,e){return t.crosses(r,i(n),n,e)}function R(n,e,a){return t.distance(r,i(n),n,e,a)}function x(n,e){return t.equals(r,i(n),n,e)}function S(n,e){return t.intersects(r,i(n),n,e)}function y(n,e){return t.touches(r,i(n),n,e)}function A(n,e){return t.within(r,i(n),n,e)}function D(n,e){return t.disjoint(r,i(n),n,e)}function L(n,e){return t.overlaps(r,i(n),n,e)}function T(n,e,a){return t.relate(r,i(n),n,e,a)}function V(n){return t.isSimple(r,i(n),n)}function v(n){return t.simplify(r,i(n),n)}function z(n,e=!1){return t.convexHull(r,i(n),n,e)}function H(n,e){return t.difference(r,i(n),n,e)}function I(n,e){return t.symmetricDifference(r,i(n),n,e)}function J(n,e){return t.intersect(r,i(n),n,e)}function N(n,e=null){return t.union(r,i(n),n,e)}function O(n,e,a,s,c,u){return t.offset(r,i(n),n,e,a,s,c,u)}function b(n,e,a,s=!1){return t.buffer(r,i(n),n,e,a,s)}function j(n,e,a,s,c,u){return t.geodesicBuffer(r,i(n),n,e,a,s,c,u)}function q(n,e,a=!0){return t.nearestCoordinate(r,i(n),n,e,a)}function B(n,e){return t.nearestVertex(r,i(n),n,e)}function C(n,e,a,s){return t.nearestVertices(r,i(n),n,e,a,s)}function f(n){return"xmin"in n?"center"in n?n.center:null:"x"in n?n:"extent"in n?n.extent?.center??null:null}function E(n,e,a){if(n==null)throw new o;const s=n.spatialReference;if((a=a??f(n))==null)throw new o;const c=n.constructor.fromJSON(t.rotate(n,e,a));return c.spatialReference=s,c}function G(n,e){if(n==null)throw new o;const a=n.spatialReference;if((e=e??f(n))==null)throw new o;const s=n.constructor.fromJSON(t.flipHorizontal(n,e));return s.spatialReference=a,s}function P(n,e){if(n==null)throw new o;const a=n.spatialReference;if((e=e??f(n))==null)throw new o;const s=n.constructor.fromJSON(t.flipVertical(n,e));return s.spatialReference=a,s}function W(n,e,a,s){return t.generalize(r,i(n),n,e,a,s)}function Y(n,e,a){return t.densify(r,i(n),n,e,a)}function Z(n,e,a,s=0){return t.geodesicDensify(r,i(n),n,e,a,s)}function k(n,e){return t.planarArea(r,i(n),n,e)}function F(n,e){return t.planarLength(r,i(n),n,e)}function K(n,e,a){return t.geodesicArea(r,i(n),n,e,a)}function M(n,e,a){return t.geodesicLength(r,i(n),n,e,a)}function Q(n,e){return t.intersectLinesToPoints(r,i(n),n,e)}function U(n,e){t.changeDefaultSpatialReferenceTolerance(n,e)}function X(n){t.clearDefaultSpatialReferenceTolerance(n)}class o extends Error{constructor(){super("Illegal Argument Exception")}}export{b as buffer,U as changeDefaultSpatialReferenceTolerance,X as clearDefaultSpatialReferenceTolerance,m as clip,h as contains,z as convexHull,w as crosses,g as cut,Y as densify,H as difference,D as disjoint,R as distance,x as equals,d as extendedSpatialReferenceInfo,G as flipHorizontal,P as flipVertical,W as generalize,K as geodesicArea,j as geodesicBuffer,Z as geodesicDensify,M as geodesicLength,J as intersect,Q as intersectLinesToPoints,S as intersects,V as isSimple,q as nearestCoordinate,B as nearestVertex,C as nearestVertices,O as offset,L as overlaps,k as planarArea,F as planarLength,T as relate,E as rotate,v as simplify,I as symmetricDifference,y as touches,N as union,A as within};
