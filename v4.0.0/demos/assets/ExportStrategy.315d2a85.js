import{bR as R,cO as _,K as d,N as l,O as w,P as z,_ as P,bQ as W,M as S,fd as b,eN as N}from"./main.efb50b2c.js";import{v as $}from"./Bitmap.3de272b0.js";const E=Math.PI/180;function H(e){return e*E}function q(e,i){const p=H(i.rotation),t=Math.abs(Math.cos(p)),o=Math.abs(Math.sin(p)),[a,s]=i.size;return e[0]=Math.round(s*o+a*t),e[1]=Math.round(s*t+a*o),e}function O(e,i,p,t){const[o,a]=i,[s,r]=t,u=.5*p;return e[0]=o-u*s,e[1]=a-u*r,e[2]=o+u*s,e[3]=a+u*r,e}const m=R(),c=[0,0],v=new _(0,0,0,0),x={container:null,fetchSource:null,requestUpdate:null,imageMaxWidth:2048,imageMaxHeight:2048,imageRotationSupported:!1,imageNormalizationSupported:!1,hidpi:!1};let n=class extends z{constructor(e){super(e),this._imagePromise=null,this.bitmaps=[],this.hidpi=x.hidpi,this.imageMaxWidth=x.imageMaxWidth,this.imageMaxHeight=x.imageMaxHeight,this.imageRotationSupported=x.imageRotationSupported,this.imageNormalizationSupported=x.imageNormalizationSupported,this.update=P(async(i,p)=>{if(!i.stationary||this.destroyed)return null;const t=i.state,o=W(t.spatialReference),a=this.hidpi?i.pixelRatio:1,s=this.imageNormalizationSupported&&t.worldScreenWidth&&t.worldScreenWidth<t.size[0];s?(c[0]=t.worldScreenWidth,c[1]=t.size[1]):this.imageRotationSupported?(c[0]=t.size[0],c[1]=t.size[1]):q(c,t);const r=Math.floor(c[0]*a)>this.imageMaxWidth||Math.floor(c[1]*a)>this.imageMaxHeight,u=o&&(t.extent.xmin<o.valid[0]||t.extent.xmax>o.valid[1]),f=!this.imageNormalizationSupported&&u,y=!r&&!f,M=this.imageRotationSupported?t.rotation:0;if(y){const h=s?t.paddedViewState.center:t.center;this._imagePromise=this._singleExport(t,c,h,t.resolution,M,a,p)}else{let h=Math.min(this.imageMaxWidth,this.imageMaxHeight);f&&(h=Math.min(t.worldScreenWidth,h)),this._imagePromise=this._tiledExport(t,h,a,p)}return this._imagePromise.then(async h=>{if(this._imagePromise=null,!this.destroyed){this.bitmaps=h??[];for(const g of this.container.children)h.includes(g)||g.fadeOut().then(()=>{g.remove()});for(const g of h)this.container.addChild(g),g.fadeIn()}}).catch(h=>{throw this._imagePromise=null,h})},5e3)}destroy(){this.bitmaps=[]}get updating(){return!this.destroyed&&this._imagePromise!==null}updateExports(e){for(const i of this.container.children){if(!i.visible||!i.stage)return;e(i),i.invalidateTexture(),i.requestRender()}}async _export(e,i,p,t,o,a){const s=await this.fetchSource(e,Math.floor(i*o),Math.floor(p*o),{rotation:t,pixelRatio:o,signal:a}),r=new $(s,"additive");return r.x=e.xmin,r.y=e.ymax,r.resolution=e.width/i,r.rotation=t,r.pixelRatio=o,r}async _singleExport(e,i,p,t,o,a,s){O(m,p,t,i);const r=new S(m[0],m[1],m[2],m[3],e.spatialReference);return[await this._export(r,i[0],i[1],o,a,s)]}_tiledExport(e,i,p,t){const o=b.create({size:i,spatialReference:e.spatialReference,scales:[e.scale]}),a=new N(o),s=a.getTileCoverage(e);if(!s)return null;const r=[];return s.forEach((u,f,y,M)=>{v.set(u,f,y,M),a.getTileBounds(m,v);const h=new S(m[0],m[1],m[2],m[3],e.spatialReference);r.push(this._export(h,i,i,0,p,t))}),Promise.all(r)}};d([l()],n.prototype,"_imagePromise",void 0),d([l()],n.prototype,"bitmaps",void 0),d([l()],n.prototype,"container",void 0),d([l()],n.prototype,"fetchSource",void 0),d([l()],n.prototype,"hidpi",void 0),d([l()],n.prototype,"imageMaxWidth",void 0),d([l()],n.prototype,"imageMaxHeight",void 0),d([l()],n.prototype,"imageRotationSupported",void 0),d([l()],n.prototype,"imageNormalizationSupported",void 0),d([l()],n.prototype,"requestUpdate",void 0),d([l()],n.prototype,"updating",null),n=d([w("esri.views.2d.layers.support.ExportStrategy")],n);const I=n;export{I as S};
