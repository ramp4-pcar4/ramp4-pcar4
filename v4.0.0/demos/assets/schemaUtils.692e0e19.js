import{a6 as Z,R as $,c8 as Y,s as c,cR as ie,K as A,N as he,cY as we,O as Se,cZ as ae,c_ as se,m as oe,i as U,c$ as N,e as T,d0 as Fe,ae as q,b6 as re,bj as Te}from"./main.efb50b2c.js";import{l as B,S as h,r as Ee}from"./Utils.f67560a4.js";import{c as ze}from"./utils.9619dae6.js";import{o as Ve}from"./visualVariablesUtils.087ada97.js";import{createSymbolSchema as x}from"./createSymbolSchema.47a02593.js";import{t as Ie}from"./CIMSymbolHelper.6248d0ad.js";import{a5 as $e}from"./enums.6e42a319.js";import"./MaterialKey.c216087c.js";import"./ExpandedCIM.7b8d9605.js";import{x as Q}from"./MD5.97b39efc.js";import{e as ue}from"./util.5d5e59e8.js";function Oe(e){if(!e)return B.NONE;let i=0;for(const t of e)if(t.type==="size"){const s=Ve(t);i|=s,t.target==="outline"&&(i|=s<<4)}else t.type==="color"?i|=B.COLOR:t.type==="opacity"?i|=B.OPACITY:t.type==="rotation"&&(i|=B.ROTATION);return i}function Me(e){if(!("visualVariables"in e)||!e.hasVisualVariables("size"))return 0;const i=e.getVisualVariablesForType("size");if(!i[0])return 0;const t=i[0];if(t.target==="outline")return 0;if(t.transformationType==="stops")return t.stops.map(s=>s.size).reduce(G,0);if(t.transformationType==="clamped-linear"){let s=-1/0,r=-1/0;return s=typeof t.maxSize=="number"?t.maxSize:t.maxSize.stops.map(n=>n.size).reduce(G,0),r=typeof t.minSize=="number"?t.minSize:t.minSize.stops.map(n=>n.size).reduce(G,0),Math.max(s,r)}return t.transformationType==="real-world-size"?30:void 0}$e.metrics,new Ie(0,0,24,24);function G(e,i){return Math.max(e,i)}const D=8,pe=D-2,P=Z.getLogger("esri.views.2d.layers.features.support.rendererUtils"),xt=e=>{if(!("visualVariables"in e)||!e.visualVariables||!e.visualVariables.length)return e;const i=e.clone(),t=i.visualVariables.map(s=>fe(s)?ce(s):s);return i.visualVariables=t,i};function Le(e){return e.map(i=>fe(i)?ce(i.clone()):i)}function fe(e){return(e.type==="size"||e.type==="color"||e.type==="opacity")&&e.stops!=null}function ce(e){return e.stops=Re(e.type,e.stops),e}function z(e,i,t){return(1-t)*e+t*i}function Ce(e,i){const[t,...s]=i,r=s.pop(),n=s[0].value,a=s[s.length-1].value,l=(a-n)/pe,o=[];for(let u=n;u<a;u+=l){let p=0;for(;u>=s[p].value;)p++;const y=s[p],f=i[p-1],O=u-f.value,d=y.value===f.value?1:O/(y.value-f.value);if(e==="color"){const m=s[p],g=i[p-1],b=m.color.clone();b.r=z(g.color.r,b.r,d),b.g=z(g.color.g,b.g,d),b.b=z(g.color.b,b.b,d),b.a=z(g.color.a,b.a,d),o.push({value:u,color:b,label:m.label})}else if(e==="size"){const m=s[p],g=i[p-1],b=ie(m.size),_=z(ie(g.size),b,d);o.push({value:u,size:_,label:m.label})}else{const m=s[p],g=z(i[p-1].opacity,m.opacity,d);o.push({value:u,opacity:g,label:m.label})}}return[t,...o,r]}function Ne(e){const[i,...t]=e,s=t.pop();for(;t.length>pe;){let r=0,n=0;for(let a=1;a<t.length;a++){const l=t[a-1],o=t[a],u=Math.abs(o.value-l.value);u>n&&(n=u,r=a)}t.splice(r,1)}return[i,...t,s]}function Re(e,i){return i.length<=D?i:(P.warn(`Found ${i.length} Visual Variable stops, but MapView only supports ${D}. Displayed stops will be simplified.`),i.length>2*D?Ce(e,i):Ne(i))}function X(){if($("heatmap-force-raster"))return"raster";const{supportsTextureFloat:e,supportsTextureHalfFloat:i,supportsColorBufferFloat:t,supportsColorBufferFloatBlend:s,supportsColorBufferHalfFloat:r}=Y("2d");return e&&t&&s||i&&r?"symbol":$("heatmap-allow-raster-fallback")?"raster":"none"}function ht(e){if(!e)return!0;switch(e.type){case"dot-density":if(!Y("2d").supportsTextureFloat)return P.error(new c("webgl-missing-extension","Missing WebGL extension OES_Texture_Float which is required for DotDensity")),!1;break;case"heatmap":{const i=X();if(i==="none"||i==="raster"&&!$("heatmap-force-raster")){const t=Y("2d"),s=["supportsTextureFloat","supportsTextureHalfFloat","supportsColorBufferFloat","supportsColorBufferFloatBlend","supportsColorBufferHalfFloat"].filter(r=>!t[r]).join(", ");if(i==="none")return P.errorOnce(new c("webgl-missing-extension",`Missing WebGL${t.type} requirements for Heatmap: ${s}`)),!1;i==="raster"&&P.warnOnce(`Missing WebGL${t.type} requirements for accelerated Heatmap: ${s}. Feature support may be limited.`)}break}}return!0}var K;let R=K=class extends ae{writeLevels(e,i,t){for(const s in e){const r=this.levels[s];return void(i.stops=r)}}clone(){return new K({axis:this.axis,field:this.field,valueExpression:this.valueExpression,valueExpressionTitle:this.valueExpressionTitle,maxDataValue:this.maxDataValue,maxSize:se(this.maxSize)?this.maxSize.clone():this.maxSize,minDataValue:this.minDataValue,minSize:se(this.minSize)?this.minSize.clone():this.minSize,normalizationField:this.normalizationField,stops:this.stops&&this.stops.map(e=>e.clone()),target:this.target,useSymbolValue:this.useSymbolValue,valueRepresentation:this.valueRepresentation,valueUnit:this.valueUnit,legendOptions:this.legendOptions&&this.legendOptions.clone(),levels:oe(this.levels)})}};A([he()],R.prototype,"levels",void 0),A([we("levels")],R.prototype,"writeLevels",null),R=K=A([Se("esri.views.2d.engine.LevelDependentSizeVariable")],R);const de=Z.getLogger("esri.views.2d.layers.support.clusterUtils");$.add("esri-cluster-arcade-enabled",!0);const _e=$("esri-cluster-arcade-enabled"),Be=(e,i,t,s)=>{const r=i.clone();if(!Ue(r))return r;if(t.fields)for(const n of t.fields)ye(e,n);if("visualVariables"in r){const n=(r.visualVariables||[]).filter(l=>l.valueExpression!=="$view.scale"),a=ke(n);n.forEach(l=>{l.type==="rotation"?l.field?l.field=V(e,l.field,"avg_angle"):l.valueExpression&&(l.field=k(e,l.valueExpression,"avg_angle"),l.valueExpression=null):l.normalizationField?(l.field=V(e,l.field,"norm",l.normalizationField),l.normalizationField=null):l.field?l.field=V(e,l.field,"avg"):(l.field=k(e,l.valueExpression,"avg"),l.valueExpression=null)}),U(a)&&!De(n)&&(n.push(Pe(t,s)),r.dynamicClusterSize=!0),r.visualVariables=n}switch(r.type){case"simple":break;case"unique-value":r.field?r.field=V(e,r.field,"mode"):r.valueExpression&&(r.field=k(e,r.valueExpression,"mode"),r.valueExpression=null);break;case"class-breaks":r.normalizationField?(r.field=V(e,r.field,"norm",r.normalizationField),r.normalizationField=null):r.field?r.field=V(e,r.field,"avg"):(r.field=k(e,r.valueExpression,"avg"),r.valueExpression=null)}return r},ke=e=>{for(const i of e)if(i.type==="size")return i;return null},De=e=>{for(const i of e)if(i.field==="cluster_count")return!0;return!1},Pe=(e,i)=>{const t=[new N({value:0,size:0}),new N({value:1})];if(U(i))return new ae({field:"cluster_count",stops:[...t,new N({value:2,size:0})]});const s=Object.keys(i).reduce((r,n)=>({...r,[n]:[...t,new N({value:Math.max(2,i[n].minValue),size:e.clusterMinSize}),new N({value:Math.max(3,i[n].maxValue),size:e.clusterMaxSize})]}),{});return new R({field:"cluster_count",levels:s})},Ue=e=>{const i=t=>de.error(new c("Unsupported-renderer",t,{renderer:e}));if(e.type==="unique-value"){if(e.field2||e.field3)return i("FeatureReductionCluster does not support multi-field UniqueValueRenderers"),!1}else if(e.type==="class-breaks"){if(e.normalizationField){const t=e.normalizationType;if(t!=="field")return i(`FeatureReductionCluster does not support a normalizationType of ${t}`),!1}}else if(e.type!=="simple")return i(`FeatureReductionCluster does not support renderers of type ${e.type}`),!1;if(!_e){if("valueExpression"in e&&e.valueExpression)return i("FeatureReductionCluster does not currently support renderer.valueExpression. Support will be added in a future release"),!1;if(("visualVariables"in e&&e.visualVariables||[]).some(t=>!(!("valueExpression"in t)||!t.valueExpression)))return i("FeatureReductionCluster does not currently support visualVariables with a valueExpression. Support will be added in a future release"),!1}return!0};function Ae(e,i,t){switch(e){case"avg":case"avg_angle":return`cluster_avg_${i}`;case"mode":return`cluster_type_${i}`;case"norm":{const s=t,r="field",n=i.toLowerCase()+",norm:"+r+","+s.toLowerCase();return"cluster_avg_"+Q(n)}}}function ye(e,i){const{name:t,outStatistic:s}=i,{onStatisticField:r,onStatisticValueExpression:n,statisticType:a}=s;if(n){const l=Q(n.toLowerCase());e.push({name:t,outStatistic:{onStatisticField:l,onStatisticValueExpression:n,statisticType:a}})}else r?e.push({name:t,outStatistic:{onStatisticField:r,statisticType:a}}):de.error(new c("mapview-unsupported-field","Unable to handle field",{field:i}))}function k(e,i,t){const s=Q(i),r=t==="mode"?`cluster_type_${s}`:`cluster_avg_${s}`;return e.some(n=>n.name===r)||e.push({name:r,outStatistic:{onStatisticField:s,onStatisticValueExpression:i,statisticType:t}}),r}function V(e,i,t,s){if(i==="cluster_count"||e.some(n=>n.name===i))return i;const r=Ae(t,i,s);return e.some(n=>n.name===r)||(t==="norm"?e.push({name:r,outStatistic:{onStatisticField:i,onStatisticNormalizationField:s,statisticType:t}}):e.push({name:r,outStatistic:{onStatisticField:i,statisticType:t}})),r}const I=Z.getLogger("esri.views.2d.layers.features.schemaUtils"),v="ValidationError",qe={esriGeometryPoint:["above-right","above-center","above-left","center-center","center-left","center-right","below-center","below-left","below-right"],esriGeometryPolygon:["always-horizontal"],esriGeometryPolyline:["center-along"],esriGeometryMultipoint:null};function F(e){let i=0,t=0,s=h.DEFAULT;if(T(e)){if(t=Me(e),"visualVariables"in e&&(i=Oe(e.visualVariables||[]),e.type==="dot-density"&&(s=h.DOT_DENSITY)),e.type==="heatmap"&&(s=h.HEATMAP),e.type==="dictionary")return{maxVVSize:t,vvFlags:i,symbologyType:h.DEFAULT};if(e.type==="pie-chart")return{maxVVSize:t,vvFlags:i,symbologyType:h.PIE_CHART};if(s!==h.DOT_DENSITY&&s!==h.HEATMAP){const r=e.getSymbols();"backgroundFillSymbol"in e&&e.backgroundFillSymbol&&r.push(e.backgroundFillSymbol);let n=!0,a=!0;for(const l of r)if(l.type==="cim"&&(a=!1),l.type==="simple-fill"||l.type==="picture-fill"){const o=l.outline,u=o&&o.style!=="none"&&o.style!=="solid",p=l.type==="simple-fill"&&l.style!=="none"&&l.style!=="solid",y=l.type==="picture-fill"||p||u;u&&(n=!1),y&&(a=!1)}n?s=a?h.OUTLINE_FILL_SIMPLE:h.OUTLINE_FILL:a&&(s=h.SIMPLE)}}return{vvFlags:i,maxVVSize:t,symbologyType:s}}function Ge(e,i){const t=e.labelPlacement,s=qe[i];if(!e.symbol)return I.warn("No ILabelClass symbol specified."),!0;if(!s)return I.error(new c("mapview-labeling:unsupported-geometry-type",`Unable to create labels for Feature Layer, ${i} is not supported`)),!0;if(!s.includes(t)){const r=s[0];t&&I.warn(`Found invalid label placement type ${t} for ${i}. Defaulting to ${r}`),e.labelPlacement=r}return!1}function me(e,i){const t=oe(e);return t.some(s=>Ge(s,i))?[]:t}function wt(e){return $("esri-2d-update-debug")&&console.debug("Created new schema",ne(e,!0)),ne(e)}function ne(e,i=!1){try{const t=Ye(e,i),s=Ze(e),r={};t.map(l=>He(r,e,l));const n=T(e.subtypeCode)?`${e.subtypeField} = ${e.subtypeCode}`:null;return{source:{definitionExpression:Fe(e.definitionExpression,n),fields:e.fields.map(l=>l.toJSON()),gdbVersion:e.gdbVersion,historicMoment:e.historicMoment?.getTime(),outFields:e.availableFields,pixelBuffer:e.pixelBuffer,spatialReference:e.spatialReference.toJSON(),timeExtent:e.timeExtent?.toJSON(),customParameters:e.customParameters},attributes:{fields:{},indexCount:0},processors:t,tileRenderer:s,targets:r}}catch(t){if(t.fieldName===v)return I.error(t),null;throw t}}function He(e,i,t){switch(t.target){case"feature":return void J(e,H(i),t);case"aggregate":{if(!("featureReduction"in i))return;const s=i.featureReduction;switch(s.type){case"selection":throw new c(v,"Mapview does not support `selection` reduction type",s);case"binning":return J(e,H(i),t),void Je(e,s,t);case"cluster":return J(e,H(i),t),void je(e,s,t)}}}}function ee(e,i){for(const t in i){const s=i[t];if(s.target!==e.name)continue;const r=e.attributes[t];r?(r.context.mesh=r.context.mesh||s.context.mesh,r.context.storage=r.context.storage||s.context.storage):e.attributes[t]=s}return e}function H(e){return[q(e.filter)?.toJSON()??null,q(q(e.featureEffect)?.filter)?.toJSON()??null]}function J(e,i,t){return e.feature||(e.feature={name:"feature",input:"source",filters:i,attributes:{}}),ee(e.feature,t.attributes.fields),e}function Je(e,i,t){return e.aggregate||(e.aggregate={name:"aggregate",type:"bin",filters:null,input:"feature",params:{fixedBinLevel:i.fixedBinLevel},attributes:{}}),ee(e.aggregate,t.attributes.fields),e}function je(e,i,t){return e.aggregate||(e.aggregate={name:"aggregate",type:"cluster",input:"feature",filters:null,attributes:{},params:{clusterRadius:re(i.clusterRadius/2),clusterPixelBuffer:64*Math.ceil(re(i.clusterMaxSize)/64),fields:t.aggregateFields}}),ee(e.aggregate,t.attributes.fields),e}function w(e,i){return i.field?S(e,{...i,type:"field",field:i.field}):i.valueExpression?S(e,{...i,type:"expression",valueExpression:i.valueExpression}):{field:null,fieldIndex:null}}function S(e,i){switch(i.type){case"expression":{const t=i.valueExpression;if(!e.fields[t]){const s=e.indexCount++;e.fields[t]={...i,name:t,fieldIndex:s}}return{fieldIndex:e.fields[t].fieldIndex}}case"label-expression":{const t=JSON.stringify(i.label);if(!e.fields[t]){const s=e.indexCount++;e.fields[t]={...i,name:t,fieldIndex:s}}return{fieldIndex:e.fields[t].fieldIndex}}case"field":{const t=i.field;return i.target==="aggregate"&&e.fields[t]||(e.fields[t]={...i,name:t}),{field:t}}case"statistic":return e.fields[i.name]={...i},{field:i.name}}}function Ye(e,i=!1){const t=new Array;let s=0;return t.push(We(e,s++,i)),t}function j(e,i,t,s,r,n=!1){const a=S(i,{type:"label-expression",target:s,context:{mesh:!0},resultType:"string",label:{labelExpression:t.labelExpression,labelExpressionInfo:t.labelExpressionInfo?{expression:t.labelExpressionInfo.expression}:null,symbol:!!t.symbol,where:t.where}}),{fieldIndex:l}=a,o=F(e);return{...x(t,o,n),fieldIndex:l,target:s,index:r}}function Ke(e,i,t){const s="featureReduction"in i&&i.featureReduction;if(!s)return{fields:[],labels:[],matcher:null,rendererOverride:null};const r="aggregate",n=[];let a=null,l=ue(i.geometryType),o=[],u=null;if(s)switch(s.type){case"selection":throw new c(v,"Mapview does not support `selection` reduction type",s);case"cluster":case"binning":if(s.type==="cluster"?l="esriGeometryPoint":s.type==="binning"&&(l="esriGeometryPolygon"),s.renderer){for(const p of s.fields)ye(n,p);u=s.renderer,a=W(null,r,s.renderer,t),o=s&&s.labelsVisible&&s.labelingInfo||[]}else if(s.type==="cluster"){if(u=Be(n,i.renderer,s,null),s.symbol){const p=F(u);a={type:"simple",symbol:x(s.symbol,p,t),symbologyType:p.symbologyType}}o=s&&s.labelsVisible&&s.labelingInfo||[]}}return Xe(e,n),{labels:me(o,s.type==="binning"?"esriGeometryPolygon":l),matcher:a,fields:n,rendererOverride:u}}function We(e,i,t=!1){const s={indexCount:0,fields:{}},r="featureReduction"in e&&e.featureReduction?"aggregate":"feature";if("sublayers"in e){const d={type:"subtype",subtypeField:e.subtypeField,renderers:{},symbologyType:h.DEFAULT},m={type:"subtype",mapping:{},target:"feature"},g={type:"subtype",classes:{}},b={type:"symbol",target:"feature",aggregateFields:[],attributes:s,storage:m,mesh:{matcher:d,aggregateMatcher:null,labels:g,sortKey:null}},_=new Set;let ge=0;for(const{renderer:E,subtypeCode:M,labelingInfo:be,labelsVisible:ve}of e.sublayers){const L=W(s,r,E,t),C=le(s,r,E),te=ve&&be;if("visualVariables"in E&&E.visualVariables&&E.visualVariables.length)throw new c(v,"Visual variables are currently not supported for subtype layers");if(L.type==="dictionary")throw new c(v,"Dictionary renderer is not supported in subtype layers");if(L.type==="subtype")throw new c(v,"Nested subtype renderers is not supported");if(T(C)&&C.type==="subtype")throw new c(v,"Nested subtype storage is not supported");if(T(C)&&T(C.attributeMapping))throw new c(v,"Non-visual-variable attributes are not supported in subtype layers");if(L.type==="heatmap")throw new c(v,"Heatmaps are not supported in subtype layers");if(L.type==="pie-chart")throw new c(v,"Pie-charts are not supported in subtype layers");if(_.has(M))throw new c(v,"Subtype codes for sublayers must be unique");_.add(M),d.renderers[M]=L,m.mapping[M]=C,te&&(g.classes[M]=te.map(xe=>j(E,s,xe,"feature",ge++,t)))}return b}if(e.renderer.type==="heatmap"&&X()==="raster"){const{radius:d,fieldOffset:m,field:g}=e.renderer;return{type:"heatmap",aggregateFields:[],attributes:s,target:r,storage:null,mesh:{radius:d,fieldOffset:m,field:w(s,{target:r,field:g,resultType:"numeric"}).field}}}const n=Ke(s,e,t),a=ue(e.geometryType),l=n.rendererOverride??e.renderer,o=W(s,r,l,t),u=le(s,r,l),p=Qe(s,e.orderBy),y=me(e.labelsVisible&&e.labelingInfo||[],a);let f=0;const O=[...y.map(d=>j(l,s,d,"feature",f++,t)),...n.labels.map(d=>j(l,s,d,"aggregate",f++,t))];return{type:"symbol",target:r,attributes:s,aggregateFields:n.fields,storage:u,mesh:{matcher:o,labels:{type:"simple",classes:O},aggregateMatcher:n.matcher,sortKey:p}}}function Ze(e){return e.renderer?.type==="heatmap"&&X()==="raster"?{type:"heatmap"}:{type:"symbol"}}function Qe(e,i){if(U(i)||!i.length)return null;i.length>1&&I.warn(`Layer rendering currently only supports ordering by 1 orderByInfo, but found ${i.length}. All but the first will be discarded`);const t=i[0],s=t.order==="ascending"?"asc":"desc";return t.field?{field:t.field,order:s}:t.valueExpression?{fieldIndex:S(e,{type:"expression",target:"feature",valueExpression:t.valueExpression,resultType:"numeric"}).fieldIndex,order:s}:(I.error(new c(v,"Expected to find a field or valueExpression for OrderByInfo",t)),null)}function Xe(e,i){const t={mesh:!0,storage:!0};for(const s of i){const{name:r,outStatistic:n}=s,{statisticType:a,onStatisticField:l}=n;let o=null,u=null,p=null;const y="numeric",f="feature";"onStatisticValueExpression"in n?u=S(e,{type:"expression",target:f,valueExpression:n.onStatisticValueExpression,resultType:y}).fieldIndex:"onStatisticNormalizationField"in n?(o=S(e,{type:"field",target:f,field:l,resultType:y}).field,p=n.onStatisticNormalizationField):o=S(e,{type:"field",target:f,field:l,resultType:y}).field,S(e,{type:"statistic",target:"aggregate",name:r,context:t,inField:o,inNormalizationField:p,inFieldIndex:u,statisticType:a})}}function le(e,i,t){let s;switch(t.type){case"simple":case"class-breaks":case"unique-value":case"dictionary":s={visualVariables:!0,attributes:null};break;default:s=ze(t).getStorageSpec(t)}return et(e,i,s,t)}function et(e,i,t,s){if(U(t))return null;const{visualVariables:r,attributes:n}=t;let a=null;r&&"visualVariables"in s&&(a=tt(e,i,s.visualVariables));const l=T(a)?4:0;let o=null;return T(n)&&(o=n.map((u,p)=>{const{field:y,fieldIndex:f}=w(e,{valueExpression:u.valueExpression,field:u.field,resultType:"numeric",target:i});return{binding:p+l,field:y,fieldIndex:f}})),{type:"simple",target:i,attributeMapping:o,vvMapping:a}}function tt(e,i,t){if(!t||!t.length)return[];const s={storage:!0},r="numeric";return Le(t).map(n=>{const a=Ee(n.type),{field:l,fieldIndex:o}=w(e,{target:i,valueExpression:n.valueExpression,field:n.field,context:s,resultType:r});switch(n.type){case"size":return n.valueExpression==="$view.scale"?null:{type:"size",binding:a,field:l,fieldIndex:o,normalizationField:w(e,{target:i,field:n.normalizationField,context:s,resultType:r}).field,valueRepresentation:n.valueRepresentation??null};case"color":return{type:"color",binding:a,field:l,fieldIndex:o,normalizationField:w(e,{target:i,field:n.normalizationField,context:s,resultType:r}).field};case"opacity":return{type:"opacity",binding:a,field:l,fieldIndex:o,normalizationField:w(e,{target:i,field:n.normalizationField,context:s,resultType:r}).field};case"rotation":return{type:"rotation",binding:a,field:l,fieldIndex:o}}}).filter(n=>n)}function W(e,i,t,s=!1){const r=Te(e,{indexCount:0,fields:{}});switch(t.type){case"simple":case"dot-density":return it(r,t,s);case"class-breaks":return rt(r,i,t,s);case"unique-value":return nt(r,i,t,s);case"dictionary":return lt(r,t,s);case"heatmap":return at(r,t,s);case"pie-chart":return st(r,t,s)}}function it(e,i,t=!1){const s=i.getSymbols(),r=s.length?s[0]:null,n=F(i);return{type:"simple",symbol:x(r,n,t),symbologyType:n.symbologyType}}function st(e,i,t=!1){const s=i.getSymbols(),r=s[0],n=s.length>1?s[1]:null,a=F(i);return{type:"pie-chart",markerSymbol:x(r,a,t),fillSymbol:x(n,a,t),symbologyType:a.symbologyType}}function rt(e,i,t,s=!1){const r={mesh:!0,use:"renderer.field"},n=t.backgroundFillSymbol,{field:a,fieldIndex:l}=w(e,{target:i,field:t.field,valueExpression:t.valueExpression,resultType:"numeric",context:r}),o=t.normalizationType,u=o==="log"?"esriNormalizeByLog":o==="percent-of-total"?"esriNormalizeByPercentOfTotal":o==="field"?"esriNormalizeByField":null,p=F(t),y=t.classBreakInfos.map(f=>({symbol:x(f.symbol,p,s),min:f.minValue,max:f.maxValue})).sort((f,O)=>f.min-O.min);return{type:"interval",attributes:e.fields,field:a,fieldIndex:l,backgroundFillSymbol:x(n,p,s),defaultSymbol:x(t.defaultSymbol,p,s),intervals:y,normalizationField:t.normalizationField,normalizationTotal:t.normalizationTotal,normalizationType:u,isMaxInclusive:t.isMaxInclusive,symbologyType:p.symbologyType}}function nt(e,i,t,s=!1){const r=[],n=t.backgroundFillSymbol,a={target:i,context:{mesh:!0},resultType:"string"};if(t.field&&typeof t.field!="string")throw new c(v,"Expected renderer.field to be a string",t);const{field:l,fieldIndex:o}=w(e,{...a,field:t.field,valueExpression:t.valueExpression}),u=F(t);for(const p of t.uniqueValueInfos)r.push({value:""+p.value,symbol:x(p.symbol,u,s)});return{type:"map",attributes:e.fields,field:l,fieldIndex:o,field2:w(e,{...a,field:t.field2}).field,field3:w(e,{...a,field:t.field3}).field,fieldDelimiter:t.fieldDelimiter,backgroundFillSymbol:x(n,u),defaultSymbol:x(t.defaultSymbol,u),map:r,symbologyType:u.symbologyType}}function lt(e,i,t=!1){const s=F(i);return{type:"dictionary",config:i.config,fieldMap:i.fieldMap,scaleExpression:i.scaleExpression,url:i.url,symbolOptions:s,symbologyType:s.symbologyType}}function at(e,i,t=!1){const s=i.getSymbols(),r=s.length?s[0]:null,n=F(i);return{type:"heatmap",symbol:x(r,n,t),symbologyType:n.symbologyType}}export{W as K,F as S,Be as c,ke as d,Pe as f,xt as i,Ue as m,ht as v,ye as x,wt as z};
