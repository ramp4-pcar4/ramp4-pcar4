import{a6 as W,R as B,s as V,aT as f,e as M,aZ as L,ae as z}from"./main.efb50b2c.js";import{t as S,M as g,L as u,D as w,u as k,G as y,P as R,U as A}from"./enums.de935fa5.js";const H=W.getLogger("esri/views/webgl");function Y(s,t){switch(t){case s.INVALID_ENUM:return"Invalid Enum. An unacceptable value has been specified for an enumerated argument.";case s.INVALID_VALUE:return"Invalid Value. A numeric argument is out of range.";case s.INVALID_OPERATION:return"Invalid Operation. The specified command is not allowed for the current state.";case s.INVALID_FRAMEBUFFER_OPERATION:return"Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";case s.OUT_OF_MEMORY:return"Out of memory. Not enough memory is left to execute the command.";case s.CONTEXT_LOST_WEBGL:return"WebGL context has been lost";default:return"Unknown error"}}const v=!!B("enable-feature:webgl-debug");function K(){return v}function $(){return v}function b(s){if(K()){const t=s.getError();if(t){const e=Y(s,t),a=new Error().stack;H.error(new V("webgl-error","WebGL error occured",{message:e,stack:a}))}}}function D(s){return window.WebGL2RenderingContext&&s instanceof window.WebGL2RenderingContext}const F=4;class _{constructor(t,e,a=null){if(this._context=t,this.type="texture",this._glName=null,this._descriptor=void 0,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._wasImmutablyAllocated=!1,t.instanceCounter.increment(S.Texture,this),this._descriptor={target:g.TEXTURE_2D,samplingMode:u.LINEAR,wrapMode:w.REPEAT,flipped:!1,hasMipmap:!1,isOpaque:!1,unpackAlignment:4,preMultiplyAlpha:!1,isImmutable:!1,...e},t.type!==f.WEBGL2&&(this._descriptor.isImmutable&&(this._descriptor.isImmutable=!1),x(this._descriptor.target)))throw new Error("3D and array textures are not supported in WebGL1");this._descriptor.target===g.TEXTURE_CUBE_MAP?this._setDataCubeMap(a):this.setData(a)}get glName(){return this._glName}get descriptor(){return this._descriptor}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty}dispose(){this._context.gl&&this._glName&&(this._context.unbindTexture(this),this._context.gl.deleteTexture(this._glName),this._glName=null,this._context.instanceCounter.decrement(S.Texture,this))}release(){this.dispose()}resize(t,e){const a=this._descriptor;if(a.width!==t||a.height!==e){if(this._wasImmutablyAllocated)throw new Error("Immutable textures can't be resized!");a.width=t,a.height=e,this._descriptor.target===g.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}_setDataCubeMap(t=null){for(let e=g.TEXTURE_CUBE_MAP_POSITIVE_X;e<=g.TEXTURE_CUBE_MAP_NEGATIVE_Z;e++)this._setData(t,e)}setData(t){this._setData(t)}_setData(t,e){if(!this._context||!this._context.gl)return;const a=this._context.gl;this._glName||(this._glName=a.createTexture()),t===void 0&&(t=null);const r=this._descriptor;e??(e=r.target);const o=x(e);t===null&&(r.width=r.width||F,r.height=r.height||F,o&&(r.depth=r.depth??1));const p=this._context.bindTexture(this,_.TEXTURE_UNIT_FOR_UPDATES);this._context.setActiveTexture(_.TEXTURE_UNIT_FOR_UPDATES),_._validateTexture(this._context,r),this._configurePixelStorage();const n=r.pixelFormat;let i=r.internalFormat?r.internalFormat:this._deriveInternalFormat(n,r.dataType);if(P(t)){let h=t.width,l=t.height;const m=1;t instanceof HTMLVideoElement&&(h=t.videoWidth,l=t.videoHeight),r.width&&r.height,o&&r.depth,r.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(e,i,r.hasMipmap,h,l,m),this._texImage(e,0,i,h,l,m,t),b(a),r.hasMipmap&&this.generateMipmap(),r.width===void 0&&(r.width=h),r.height===void 0&&(r.height=l),o&&r.depth===void 0&&(r.depth=m)}else{const{width:h,height:l,depth:m}=r;if(h!=null&&l!=null||console.error("Width and height must be specified!"),o&&m==null&&console.error("Depth must be specified!"),r.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(e,i,r.hasMipmap,h,l,m),a.DEPTH24_STENCIL8&&i===a.DEPTH_STENCIL&&(i=a.DEPTH24_STENCIL8),U(t)){const E=t.levels,c=G(e,h,l,m),d=Math.min(c-1,E.length-1);D(a)?a.texParameteri(r.target,a.TEXTURE_MAX_LEVEL,d):r.hasMipmap=r.hasMipmap&&c===E.length;const T=i;if(!Z(T))throw new Error("Attempting to use compressed data with an umcompressed format!");this._forEachMipmapLevel((I,N,O,X)=>{const C=E[Math.min(I,E.length-1)];this._compressedTexImage(e,I,T,N,O,X,C)},d)}else M(t)?(this._texImage(e,0,i,h,l,m,t),b(a),r.hasMipmap&&this.generateMipmap()):this._forEachMipmapLevel((E,c,d,T)=>{this._texImage(e,E,i,c,d,T,null),b(a)})}_._applySamplingMode(a,this._descriptor),_._applyWrapMode(a,this._descriptor),_._applyAnisotropicFilteringParameters(this._context,this._descriptor),b(a),this._context.bindTexture(p,_.TEXTURE_UNIT_FOR_UPDATES)}updateData(t,e,a,r,o,p){p||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const n=this._context.gl,i=this._descriptor,{pixelFormat:h,internalFormat:l,dataType:m,isImmutable:E,target:c}=i;if(E&&!this._wasImmutablyAllocated)throw new Error("Cannot update immutable texture before allocation!");const d=this._context.bindTexture(this,_.TEXTURE_UNIT_FOR_UPDATES);(e<0||a<0||r>i.width||o>i.height||e+r>i.width||a+o>i.height)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage(),P(p)?n.texSubImage2D(c,t,e,a,h,m,p):U(p)?n.compressedTexSubImage2D(c,t,e,a,r,o,l,p.levels[t]):n.texSubImage2D(c,t,e,a,r,o,h,m,p),this._context.bindTexture(d,_.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(t,e,a,r,o,p,n,i){i||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const h=this._context.gl;if(!D(h))throw new Error("3D textures are not supported in WebGL1");const l=this._descriptor,{pixelFormat:m,dataType:E,isImmutable:c,target:d,internalFormat:T}=l;if(c&&!this._wasImmutablyAllocated)throw new Error("Cannot update immutable texture before allocation!");x(d)||console.warn("Attempting to set 3D texture data on a non-3D texture");const I=this._context.bindTexture(this,_.TEXTURE_UNIT_FOR_UPDATES);if(this._context.setActiveTexture(_.TEXTURE_UNIT_FOR_UPDATES),(e<0||a<0||r<0||o>l.width||p>l.height||n>l.depth||e+o>l.width||a+p>l.height||r+n>l.depth)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage(),U(i))i=i.levels[t],h.compressedTexSubImage3D(d,t,e,a,r,o,p,n,T,i);else{const N=i;h.texSubImage3D(d,t,e,a,r,o,p,n,m,E,N)}this._context.bindTexture(I,_.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const t=this._descriptor;if(!t.hasMipmap){if(this._wasImmutablyAllocated)throw new Error("Cannot add mipmaps to immutable texture after allocation");t.hasMipmap=!0,this._samplingModeDirty=!0,_._validateTexture(this._context,t)}t.samplingMode===u.LINEAR?(this._samplingModeDirty=!0,t.samplingMode=u.LINEAR_MIPMAP_NEAREST):t.samplingMode===u.NEAREST&&(this._samplingModeDirty=!0,t.samplingMode=u.NEAREST_MIPMAP_NEAREST);const e=this._context.bindTexture(this,_.TEXTURE_UNIT_FOR_UPDATES);this._context.setActiveTexture(_.TEXTURE_UNIT_FOR_UPDATES),this._context.gl.generateMipmap(t.target),this._context.bindTexture(e,_.TEXTURE_UNIT_FOR_UPDATES)}setSamplingMode(t){t!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=t,this._samplingModeDirty=!0)}setWrapMode(t){t!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=t,_._validateTexture(this._context,this._descriptor),this._wrapModeDirty=!0)}applyChanges(){const t=this._context.gl,e=this._descriptor;this._samplingModeDirty&&(_._applySamplingMode(t,e),this._samplingModeDirty=!1),this._wrapModeDirty&&(_._applyWrapMode(t,e),this._wrapModeDirty=!1)}_deriveInternalFormat(t,e){if(this._context.type===f.WEBGL1)return t;switch(e){case y.FLOAT:switch(t){case R.RGBA:return A.RGBA32F;case R.RGB:return A.RGB32F;default:throw new Error("Unable to derive format")}case y.UNSIGNED_BYTE:switch(t){case R.RGBA:return A.RGBA8;case R.RGB:return A.RGB8}default:return t}}_configurePixelStorage(){const t=this._context.gl,{unpackAlignment:e,flipped:a,preMultiplyAlpha:r}=this._descriptor;t.pixelStorei(t.UNPACK_ALIGNMENT,e),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,a?1:0),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r?1:0)}_texStorage(t,e,a,r,o,p){const n=this._context.gl;if(!D(n))throw new Error("Immutable textures are not supported in WebGL1");if(!q(e))throw new Error("Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const i=a?G(t,r,o,p):1;x(t)?n.texStorage3D(t,i,e,r,o,p):n.texStorage2D(t,i,e,r,o),this._wasImmutablyAllocated=!0}_texImage(t,e,a,r,o,p,n){const i=this._context.gl;let h=null;const l=this._context.type===f.WEBGL2,m=x(t),{isImmutable:E,pixelFormat:c,dataType:d}=this._descriptor;if(l&&(h=i),l||!P(n))if(E){if(M(n)){const T=n;m?h.texSubImage3D(t,e,0,0,0,r,o,p,c,d,T):i.texSubImage2D(t,e,0,0,r,o,c,d,T)}}else{const T=z(n);m?h.texImage3D(t,e,a,r,o,p,0,c,d,T):i.texImage2D(t,e,a,r,o,0,c,d,T)}else i.texImage2D(t,0,a,c,d,n)}_compressedTexImage(t,e,a,r,o,p,n){const i=this._context.gl;let h=null;const l=x(t),m=this._descriptor.isImmutable;if(l){if(this._context.type!==f.WEBGL2)throw new Error("3D textures are not supported in WebGL1");h=i}m?M(n)&&(l?h.compressedTexSubImage3D(t,e,0,0,0,r,o,p,a,n):i.compressedTexSubImage2D(t,e,0,0,r,o,a,n)):l?h.compressedTexImage3D(t,e,a,r,o,p,0,n):i.compressedTexImage2D(t,e,a,r,o,0,n)}_forEachMipmapLevel(t,e=1/0){let{width:a,height:r,depth:o,hasMipmap:p,target:n}=this._descriptor;const i=n===g.TEXTURE_3D;for(let h=0;t(h,a,r,o),p&&(a!==1||r!==1||i&&o!==1)&&!(h>=e);++h)a=Math.max(1,a>>1),r=Math.max(1,r>>1),i&&(o=Math.max(1,o>>1))}static _validateTexture(t,e){(e.width<0||e.height<0||e.depth<0)&&console.error("Negative dimension parameters are not allowed!");const a=D(t.gl),r=L(e.width)&&L(e.height);a||!e.isImmutable&&!x(e.target)||console.error("Immutable and 3D-like textures are not supported in WebGL1!"),a||r||(typeof e.wrapMode=="number"?e.wrapMode!==w.CLAMP_TO_EDGE&&console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"):e.wrapMode.s===w.CLAMP_TO_EDGE&&e.wrapMode.t===w.CLAMP_TO_EDGE||console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"),e.hasMipmap&&console.error("Mipmapping requires power-of-two textures!"))}static _applySamplingMode(t,e){let a=e.samplingMode,r=e.samplingMode;a===u.LINEAR_MIPMAP_NEAREST||a===u.LINEAR_MIPMAP_LINEAR?(a=u.LINEAR,e.hasMipmap||(r=u.LINEAR)):a!==u.NEAREST_MIPMAP_NEAREST&&a!==u.NEAREST_MIPMAP_LINEAR||(a=u.NEAREST,e.hasMipmap||(r=u.NEAREST)),t.texParameteri(e.target,t.TEXTURE_MAG_FILTER,a),t.texParameteri(e.target,t.TEXTURE_MIN_FILTER,r)}static _applyWrapMode(t,e){typeof e.wrapMode=="number"?(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode)):(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode.s),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode.t))}static _applyAnisotropicFilteringParameters(t,e){const a=t.capabilities.textureFilterAnisotropic;!a||t.gl.texParameterf(e.target,a.TEXTURE_MAX_ANISOTROPY,e.maxAnisotropy??1)}}function q(s){return s in A}function Z(s){return s in k}function U(s){return M(s)&&"type"in s&&s.type==="compressed"}function j(s){return M(s)&&"byteLength"in s}function P(s){return M(s)&&!U(s)&&!j(s)}function x(s){return s===g.TEXTURE_3D||s===g.TEXTURE_2D_ARRAY}function G(s,t,e,a=1){let r=Math.max(t,e);return s===g.TEXTURE_3D&&(r=Math.max(r,a)),Math.round(Math.log(r)/Math.LN2)+1}_.TEXTURE_UNIT_FOR_UPDATES=0;export{K as a,$ as c,D as n,b as s,_ as u};
