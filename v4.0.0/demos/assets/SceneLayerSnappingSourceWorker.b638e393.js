import{cu as bt,i3 as y,e as X,by as H,i6 as x,jP as tt,jQ as et,ia as nt,jR as Nt,bh as m,b8 as A,b3 as Rt,i as ot,bj as At,jS as it,ih as k,iy as $,K as Ft,O as Mt}from"./main.efb50b2c.js";import{v as It,l as St,d as xt}from"./lineSegment.930527e9.js";import{d as st,q as D,j as rt,k as q,E as F,X as ht,_ as S,Q as at}from"./sphere.471697c0.js";import{E as dt}from"./QueryEngineResult.191af376.js";import{s as pt}from"./vectorStacks.78d4f069.js";import{extractComponentsEdgeLocationsLayout as jt}from"./EdgeProcessingWorker.8b5e83be.js";import"./preload-helper.387dac8f.js";import"./quantizationUtils.d09757e3.js";import"./WhereClause.5a38bf79.js";import"./utils.9dfb26f2.js";import"./projectionSupport.a2ec70ff.js";import"./json.d1a0fa35.js";import"./utils.1e6f5f3b.js";import"./quatf64.ddec7ef6.js";import"./mat4f64.a79dd289.js";import"./deduplicate.9837c6dd.js";import"./InterleavedLayout.a13cfeee.js";import"./BufferView.02e80ac7.js";import"./types.2e1ddd0e.js";import"./VertexAttribute.5551e0d8.js";import"./enums.de935fa5.js";import"./VertexElementDescriptor.d386088d.js";function Lt(o){return o?{ray:st(o.ray),c0:o.c0,c1:o.c1}:{ray:st(),c0:0,c1:Number.MAX_VALUE}}new pt(()=>({c0:0,c1:0,ray:null}));var v;(function(o){o[o.NONE=0]="NONE",o[o.CLAMP=1]="CLAMP",o[o.INFINITE_MIN=4]="INFINITE_MIN",o[o.INFINITE_MAX=8]="INFINITE_MAX"})(v||(v={}));v.INFINITE_MIN|v.INFINITE_MAX;v.INFINITE_MAX;function C(o,t){for(let e=0;e<Q.NUM;e++){const n=o[e];if(n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]>=t[3])return!1}return!0}var ct,d;(function(o){o[o.LEFT=0]="LEFT",o[o.RIGHT=1]="RIGHT",o[o.BOTTOM=2]="BOTTOM",o[o.TOP=3]="TOP",o[o.NEAR=4]="NEAR",o[o.FAR=5]="FAR"})(ct||(ct={})),function(o){o[o.NEAR_BOTTOM_LEFT=0]="NEAR_BOTTOM_LEFT",o[o.NEAR_BOTTOM_RIGHT=1]="NEAR_BOTTOM_RIGHT",o[o.NEAR_TOP_RIGHT=2]="NEAR_TOP_RIGHT",o[o.NEAR_TOP_LEFT=3]="NEAR_TOP_LEFT",o[o.FAR_BOTTOM_LEFT=4]="FAR_BOTTOM_LEFT",o[o.FAR_BOTTOM_RIGHT=5]="FAR_BOTTOM_RIGHT",o[o.FAR_TOP_RIGHT=6]="FAR_TOP_RIGHT",o[o.FAR_TOP_LEFT=7]="FAR_TOP_LEFT"}(d||(d={}));d.FAR_BOTTOM_RIGHT,d.NEAR_BOTTOM_RIGHT,d.NEAR_BOTTOM_LEFT,d.FAR_BOTTOM_LEFT,d.NEAR_BOTTOM_LEFT,d.NEAR_BOTTOM_RIGHT,d.NEAR_TOP_RIGHT,d.NEAR_TOP_LEFT,d.FAR_BOTTOM_RIGHT,d.FAR_BOTTOM_LEFT,d.FAR_TOP_LEFT,d.FAR_TOP_RIGHT,d.NEAR_BOTTOM_RIGHT,d.FAR_BOTTOM_RIGHT,d.FAR_TOP_RIGHT,d.NEAR_TOP_RIGHT,d.FAR_BOTTOM_LEFT,d.NEAR_BOTTOM_LEFT,d.NEAR_TOP_LEFT,d.FAR_TOP_LEFT,d.FAR_TOP_LEFT,d.NEAR_TOP_LEFT,d.NEAR_TOP_RIGHT,d.FAR_TOP_RIGHT;var Q,lt;(function(o){o[o.NUM=6]="NUM"})(Q||(Q={})),function(o){o[o.NUM=8]="NUM"}(lt||(lt={}));new pt(Lt);class j{constructor(t,e){this._objectToBoundingSphere=t,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new c,this._objectCount=0,e&&(e.maximumObjectsPerNode!==void 0&&(this._maximumObjectsPerNode=e.maximumObjectsPerNode),e.maximumDepth!==void 0&&(this._maximumDepth=e.maximumDepth))}get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}destroy(){this._degenerateObjects.clear(),c.clearPool(),J[0]=null,M.prune(),I.prune()}add(t,e=t.length){this._objectCount+=e,this._grow(t,e);const n=c.acquire();for(let i=0;i<e;i++){const s=t[i];this._isDegenerate(s)?this._degenerateObjects.add(s):(n.init(this._root),this._add(s,n))}c.release(n)}remove(t,e=null){this._objectCount-=t.length;const n=c.acquire();for(const i of t){const s=X(e)?e:D(this._objectToBoundingSphere(i),$t);B(s[3])?(n.init(this._root),this._remove(i,s,n)):this._degenerateObjects.delete(i)}c.release(n),this._shrink()}update(t,e){if(!B(e[3])&&this._isDegenerate(t))return;const n=vt(t);this.remove(n,e),this.add(n)}forEachAlongRay(t,e,n){const i=rt(t,e);this._forEachNode(this._root,s=>{if(!this._intersectsNode(i,s))return!1;const h=s.node;return h.terminals.forAll(r=>{this._intersectsObject(i,r)&&n(r)}),h.residents!==null&&h.residents.forAll(r=>{this._intersectsObject(i,r)&&n(r)}),!0})}forEachAlongRayWithVerticalOffset(t,e,n,i){const s=rt(t,e);this._forEachNode(this._root,h=>{if(!this._intersectsNodeWithOffset(s,h,i))return!1;const r=h.node;return r.terminals.forAll(a=>{this._intersectsObjectWithOffset(s,a,i)&&n(a)}),r.residents!==null&&r.residents.forAll(a=>{this._intersectsObjectWithOffset(s,a,i)&&n(a)}),!0})}forEach(t){this._forEachNode(this._root,e=>{const n=e.node;return n.terminals.forAll(t),n.residents!==null&&n.residents.forAll(t),!0}),this._degenerateObjects.forEach(t)}forEachDegenerateObject(t){this._degenerateObjects.forEach(t)}findClosest(t,e,n,i=()=>!0,s=1/0){let h=1/0,r=1/0,a=null;const l=V(t,e),u=_=>{if(--s,!i(_))return;const O=this._objectToBoundingSphere(_);if(!C(n,O))return;const b=R(t,e,F(O)),L=b-O[3],f=b+O[3];L<h&&(h=L,r=f,a=_)};return this._forEachNodeDepthOrdered(this._root,_=>{if(s<=0||!C(n,_.bounds)||(H(E,l,_.halfSize),x(E,E,_.bounds),R(t,e,E)>r))return!1;const O=_.node;return O.terminals.forAll(b=>u(b)),O.residents!==null&&O.residents.forAll(b=>u(b)),!0},t,e),a}forEachInDepthRange(t,e,n,i,s,h,r){let a=-1/0,l=1/0;const u={setRange:f=>{n===j.DepthOrder.FRONT_TO_BACK?(a=Math.max(a,f.near),l=Math.min(l,f.far)):(a=Math.max(a,-f.far),l=Math.min(l,-f.near))}};u.setRange(i);const _=R(e,n,t),O=V(e,n),b=V(e,-n),L=f=>{if(!r(f))return;const N=this._objectToBoundingSphere(f),P=F(N),Z=R(e,n,P)-_,Et=Z-N[3],gt=Z+N[3];Et>l||gt<a||!C(h,N)||s(f,u)};this._forEachNodeDepthOrdered(this._root,f=>{if(!C(h,f.bounds)||(H(E,O,f.halfSize),x(E,E,f.bounds),R(e,n,E)-_>l)||(H(E,b,f.halfSize),x(E,E,f.bounds),R(e,n,E)-_<a))return!1;const N=f.node;return N.terminals.forAll(P=>L(P)),N.residents!==null&&N.residents.forAll(P=>L(P)),!0},e,n)}forEachNode(t){this._forEachNode(this._root,e=>t(e.node,e.bounds,e.halfSize))}forEachNeighbor(t,e){const n=q(e),i=F(e),s=h=>{const r=this._objectToBoundingSphere(h),a=q(r),l=n+a;tt(F(r),i)-l*l<=0&&t(h)};this._forEachNode(this._root,h=>{const r=q(h.bounds),a=n+r;if(tt(F(h.bounds),i)-a*a>0)return!1;const l=h.node;return l.terminals.forAll(u=>s(u)),l.residents!==null&&l.residents.forAll(u=>s(u)),!0}),this.forEachDegenerateObject(s)}_intersectsNode(t,e){return w(e.bounds,2*-e.halfSize,p),w(e.bounds,2*e.halfSize,T),et(t.origin,t.direction,p,T)}_intersectsNodeWithOffset(t,e,n){return w(e.bounds,2*-e.halfSize,p),w(e.bounds,2*e.halfSize,T),n.applyToMinMax(p,T),et(t.origin,t.direction,p,T)}_intersectsObject(t,e){const n=this._objectToBoundingSphere(e);return!(n[3]>0)||ht(n,t)}_intersectsObjectWithOffset(t,e,n){const i=this._objectToBoundingSphere(e);return!(i[3]>0)||ht(n.applyToBoundingSphere(i),t)}_forEachNode(t,e){let n=c.acquire().init(t);const i=[n];for(;i.length!==0;){if(n=i.pop(),e(n)&&!n.isLeaf())for(let s=0;s<n.node.children.length;s++)n.node.children[s]&&i.push(c.acquire().init(n).advance(s));c.release(n)}}_forEachNodeDepthOrdered(t,e,n,i=j.DepthOrder.FRONT_TO_BACK){let s=c.acquire().init(t);const h=[s];for(yt(n,i,ft);h.length!==0;){if(s=h.pop(),e(s)&&!s.isLeaf())for(let r=7;r>=0;--r){const a=ft[r];s.node.children[a]&&h.push(c.acquire().init(s).advance(a))}c.release(s)}}_remove(t,e,n){M.clear();const i=n.advanceTo(e,(s,h)=>{M.push(s.node),M.push(h)})?n.node.terminals:n.node.residents;if(i.removeUnordered(t),i.length===0)for(let s=M.length-2;s>=0;s-=2){const h=M.data[s],r=M.data[s+1];if(!this._purge(h,r))break}}_nodeIsEmpty(t){if(t.terminals.length!==0)return!1;if(t.residents!==null)return t.residents.length===0;for(let e=0;e<t.children.length;e++)if(t.children[e])return!1;return!0}_purge(t,e){return e>=0&&(t.children[e]=null),!!this._nodeIsEmpty(t)&&(t.residents===null&&(t.residents=new y({shrink:!0})),!0)}_add(t,e){e.advanceTo(this._objectToBoundingSphere(t))?e.node.terminals.push(t):(e.node.residents.push(t),e.node.residents.length>this._maximumObjectsPerNode&&e.depth<this._maximumDepth&&this._split(e))}_split(t){const e=t.node.residents;t.node.residents=null;for(let n=0;n<e.length;n++){const i=c.acquire().init(t);this._add(e.getItemAt(n),i),c.release(i)}}_grow(t,e){if(e!==0&&(ut(t,e,n=>this._objectToBoundingSphere(n),g),B(g[3])&&!this._fitsInsideTree(g)))if(this._nodeIsEmpty(this._root.node))D(g,this._root.bounds),this._root.halfSize=1.25*g[3];else{const n=this._rootBoundsForRootAsSubNode(g);this._placingRootViolatesMaxDepth(n)?this._rebuildTree(g,n):this._growRootAsSubNode(n),c.release(n)}}_rebuildTree(t,e){nt(K,e.bounds),K[3]=e.halfSize,ut([t,K],2,i=>i,U);const n=c.acquire().init(this._root);this._root.initFrom(null,U,1.25*U[3]),this._forEachNode(n,i=>(this.add(i.node.terminals.data,i.node.terminals.length),i.node.residents!==null&&this.add(i.node.residents.data,i.node.residents.length),!0)),c.release(n)}_placingRootViolatesMaxDepth(t){const e=Math.log(t.halfSize/this._root.halfSize)*Math.LOG2E;let n=0;return this._forEachNode(this._root,i=>(n=Math.max(n,i.depth),n+e<=this._maximumDepth)),n+e>this._maximumDepth}_rootBoundsForRootAsSubNode(t){const e=t[3],n=t;let i=-1/0;const s=this._root.bounds,h=this._root.halfSize;for(let r=0;r<3;r++){const a=s[r]-h-(n[r]-e),l=n[r]+e-(s[r]+h),u=Math.max(0,Math.ceil(a/(2*h))),_=Math.max(0,Math.ceil(l/(2*h)))+1,O=2**Math.ceil(Math.log(u+_)*Math.LOG2E);i=Math.max(i,O),z[r].min=u,z[r].max=_}for(let r=0;r<3;r++){let a=z[r].min,l=z[r].max;const u=(i-(a+l))/2;a+=Math.ceil(u),l+=Math.floor(u);const _=s[r]-h-a*h*2;W[r]=_+(l+a)*h}return W[3]=i*h*Ot,c.acquire().initFrom(null,W,i*h,0)}_growRootAsSubNode(t){const e=this._root.node;nt(g,this._root.bounds),g[3]=this._root.halfSize,this._root.init(t),t.advanceTo(g,null,!0),t.node.children=e.children,t.node.residents=e.residents,t.node.terminals=e.terminals}_shrink(){for(;;){const t=this._findShrinkIndex();if(t===-1)break;this._root.advance(t),this._root.depth=0}}_findShrinkIndex(){if(this._root.node.terminals.length!==0||this._root.isLeaf())return-1;let t=null;const e=this._root.node.children;let n=0,i=0;for(;i<e.length&&t==null;)n=i++,t=e[n];for(;i<e.length;)if(e[i++])return-1;return n}_isDegenerate(t){return!B(this._objectToBoundingSphere(t)[3])}_fitsInsideTree(t){const e=this._root.bounds,n=this._root.halfSize;return t[3]<=n&&t[0]>=e[0]-n&&t[0]<=e[0]+n&&t[1]>=e[1]-n&&t[1]<=e[1]+n&&t[2]>=e[2]-n&&t[2]<=e[2]+n}}class c{constructor(){this.bounds=S(),this.halfSize=0,this.initFrom(null,null,0,0)}init(t){return this.initFrom(t.node,t.bounds,t.halfSize,t.depth)}initFrom(t,e,n,i=this.depth){return this.node=X(t)?t:c.createEmptyNode(),X(e)&&D(e,this.bounds),this.halfSize=n,this.depth=i,this}advance(t){let e=this.node.children[t];e||(e=c.createEmptyNode(),this.node.children[t]=e),this.node=e,this.halfSize/=2,this.depth++;const n=Tt[t];return this.bounds[0]+=n[0]*this.halfSize,this.bounds[1]+=n[1]*this.halfSize,this.bounds[2]+=n[2]*this.halfSize,this.bounds[3]=this.halfSize*Ot,this}advanceTo(t,e,n=!1){for(;;){if(this.isTerminalFor(t))return e&&e(this,-1),!0;if(this.isLeaf()){if(!n)return e&&e(this,-1),!1;this.node.residents=null}const i=this._childIndex(t);e&&e(this,i),this.advance(i)}}isLeaf(){return this.node.residents!=null}isTerminalFor(t){return t[3]>this.halfSize/2}_childIndex(t){const e=this.bounds;return(e[0]<t[0]?1:0)+(e[1]<t[1]?2:0)+(e[2]<t[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new y({shrink:!0}),residents:new y({shrink:!0})}}static acquire(){return c._pool.acquire()}static release(t){c._pool.release(t)}static clearPool(){c._pool.prune()}}function Pt(o,t){o[0]=Math.min(o[0],t[0]-t[3]),o[1]=Math.min(o[1],t[1]-t[3]),o[2]=Math.min(o[2],t[2]-t[3])}function Bt(o,t){o[0]=Math.max(o[0],t[0]+t[3]),o[1]=Math.max(o[1],t[1]+t[3]),o[2]=Math.max(o[2],t[2]+t[3])}function w(o,t,e){e[0]=o[0]+t,e[1]=o[1]+t,e[2]=o[2]+t}function ut(o,t,e,n){if(t===1){const i=e(o[0]);D(i,n)}else{p[0]=1/0,p[1]=1/0,p[2]=1/0,T[0]=-1/0,T[1]=-1/0,T[2]=-1/0;for(let i=0;i<t;i++){const s=e(o[i]);B(s[3])&&(Pt(p,s),Bt(T,s))}Nt(n,p,T,.5),n[3]=Math.max(T[0]-p[0],T[1]-p[1],T[2]-p[2])/2}}function yt(o,t,e){if(!I.length)for(let n=0;n<8;++n)I.push({index:0,distance:0});for(let n=0;n<8;++n){const i=Tt[n];I.data[n].index=n,I.data[n].distance=R(o,t,i)}I.sort((n,i)=>n.distance-i.distance);for(let n=0;n<8;++n)e[n]=I.data[n].index}function V(o,t){let e=1/0,n=null;for(let i=0;i<8;++i){const s=R(o,t,_t[i]);s<e&&(e=s,n=_t[i])}return n}function R(o,t,e){return t*(o[0]*e[0]+o[1]*e[1]+o[2]*e[2])}function B(o){return!isNaN(o)&&o!==-1/0&&o!==1/0&&o>0}c._pool=new bt(c),function(o){var t;(t=o.DepthOrder||(o.DepthOrder={}))[t.FRONT_TO_BACK=1]="FRONT_TO_BACK",t[t.BACK_TO_FRONT=-1]="BACK_TO_FRONT"}(j||(j={}));const Tt=[m(-1,-1,-1),m(1,-1,-1),m(-1,1,-1),m(1,1,-1),m(-1,-1,1),m(1,-1,1),m(-1,1,1),m(1,1,1)],_t=[m(-1,-1,-1),m(-1,-1,1),m(-1,1,-1),m(-1,1,1),m(1,-1,-1),m(1,-1,1),m(1,1,-1),m(1,1,1)],Ot=Math.sqrt(3),J=[null];function vt(o){return J[0]=o,J}const W=S(),E=A(),p=A(),T=A(),M=new y,$t=S(),g=S(),K=S(),U=S(),z=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],I=new y,ft=[0,0,0,0,0,0,0,0],mt=j;let Y=class{constructor(){this._idToComponent=new Map,this._components=new mt(o=>o.bounds),this._edges=new mt(o=>o.bounds),this._tmpLineSegment=It(),this._tmpP1=A(),this._tmpP2=A(),this._tmpP3=A(),this.remoteClient=null}async fetchCandidates(o,t){await Promise.resolve(),Rt(t),await this._ensureEdgeLocations(o,t);const e=[];return this._edges.forEachNeighbor(n=>this._addCandidates(o,n,e),o.bounds),{result:{candidates:e}}}async _ensureEdgeLocations(o,t){const e=[];if(this._components.forEachNeighbor(s=>{if(ot(s.info)){const{id:h,uid:r}=s;e.push({id:h,uid:r})}},o.bounds),!e.length)return;const n={components:e},i=await this.remoteClient.invoke("fetchAllEdgeLocations",n,At(t,{}));for(const s of i.components)this._setFetchEdgeLocations(s)}async add(o){const t=new G(o.id,o.bounds);return this._idToComponent.set(t.id,t),this._components.add([t]),{result:{}}}async remove(o){const t=this._idToComponent.get(o.id);if(t){const e=[];this._edges.forEachNeighbor(n=>{n.component===t&&e.push(n)},t.bounds),this._edges.remove(e),this._components.remove([t]),this._idToComponent.delete(t.id)}return{result:{}}}_setFetchEdgeLocations(o){const t=this._idToComponent.get(o.id);if(ot(t)||o.uid!==t.uid)return;const e=jt.createView(o.locations),n=new Array(e.count),i=A(),s=A();for(let a=0;a<e.count;a++){const l=S(),u=F(l);e.position0.getVec(a,i),e.position1.getVec(a,s),it(u,u,i,.5),it(u,u,s,.5),x(u,u,o.origin),l[3]=k(u,i);const _=new Ct(t,a,l);n[a]=_}this._edges.add(n);const{objectIds:h,origin:r}=o;t.info={locations:e,objectIds:h,origin:r}}_addCandidates(o,t,e){const{locations:n,origin:i,objectIds:s}=t.component.info,h=n.position0.getVec(t.index,this._tmpP1),r=n.position1.getVec(t.index,this._tmpP2);x(h,h,i),x(r,r,i);const a=s[n.componentIndex.get(t.index)];this._addEdgeCandidate(o,a,h,r,e),this._addVertexCandidate(o,a,h,e),this._addVertexCandidate(o,a,r,e)}_addEdgeCandidate(o,t,e,n,i){if(!(o.types&dt.EDGE))return;const s=F(o.bounds),h=St(e,n,this._tmpLineSegment),r=xt(h,s,this._tmpP3);if(!at(o.bounds,r))return null;i.push({type:"edge",objectId:t,target:$(r),distance:k(s,r),start:$(e),end:$(n)})}_addVertexCandidate(o,t,e,n){if(!(o.types&dt.VERTEX))return;const i=F(o.bounds);if(!at(o.bounds,e))return null;n.push({type:"vertex",objectId:t,target:$(e),distance:k(i,e)})}};function re(){return new Y}Y=Ft([Mt("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")],Y);class G{constructor(t,e){this.id=t,this.bounds=e,this.info=null,this.uid=++G.uid}}G.uid=0;class Ct{constructor(t,e,n){this.component=t,this.index=e,this.bounds=n}}export{Y as SceneLayerSnappingSourceWorker,re as default};
